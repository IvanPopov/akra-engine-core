provide akra.system;

float2 screenTextureRatio : INPUT_TEXTURE_RATIO;
float2 screenTextureSize : INPUT_TEXTURE_SIZE;
float2 aspectRatio : SCREEN_ASPECT_RATIO = float2(1.,1.);
float4x4 viewMat : VIEW_MATRIX;
float4x4 projMat : PROJ_MATRIX;
texture tex0 : INPUT_TEXTURE;
texture tex1 : DEPTH_TEXTURE;

sampler screenSampler : INPUT_SAMPLER = sampler_state
{
	Texture = <tex0>;
};

sampler depthSampler : DEPTH_SAMPLER = sampler_state
{
	Texture = <tex1>;
};

struct VS_OUT{
	float4 position : POSITION;
	float2 screenPosition : SCREEN_POSITION;
	float2 textureCoords : TEXCOORD0;
	float2 blurBasis : BLUR_BASIS;
};
/*
float3 unproj(float4x4 projMat,float3 screenCoords){
	float z = -projMat[3][2]/(projMat[2][2] + screenCoords.z);
	float y = -(screenCoords.y * z + projMat[2][1] * z)/projMat[1][1];
	float x = -(screenCoords.x * z + projMat[2][0] * z)/projMat[0][0];

	return float3(x,y,z);
};
*/
float unprojZ(float4x4 projMat, float screenZ){
    return -projMat[3][2]/(projMat[2][2] + screenZ);
};

VS_OUT vs_dof_shading1(float2 pos: POSITION){
	VS_OUT Out;

	Out.position = float4(pos,0.,1.);
	Out.screenPosition = pos;
	//Out.textureCoords = float2(texCoodrX,texCoordY);
	Out.textureCoords = (pos + 1.)/2. * screenTextureRatio;
	Out.blurBasis = float2(1.,0.);
	
	return Out;
};
VS_OUT vs_dof_shading2(float2 pos: POSITION){
	VS_OUT Out;

	Out.position = float4(pos,0.,1.);
	Out.screenPosition = pos;
	//Out.textureCoords = float2(texCoodrX,texCoordY);
	Out.textureCoords = (pos + 1.)/2. * screenTextureRatio;
	Out.blurBasis = float2(.5,.87);
	
	return Out;
};
VS_OUT vs_dof_shading3(float2 pos: POSITION){
	VS_OUT Out;

	Out.position = float4(pos,0.,1.);
	Out.screenPosition = pos;
	//Out.textureCoords = float2(texCoodrX,texCoordY);
	Out.textureCoords = (pos + 1.)/2. * screenTextureRatio;
	Out.blurBasis = float2(-.5,.87);
	
	return Out;
};

float dofRadius : DOF_RADIUS = 2.;
float dofFocalPlane: DOF_FOCAL_PLANE = 10.;
float dofFocusDistance: DOF_FOCUS_DISTANCE = 0.05;

float4 fs_dof_shading(VS_OUT IN) : COLOR {
	float _dofFocusDistance = clamp(dofFocusDistance, 0.01, 0.5);
	float _dofFocalPlane = clamp(dofFocalPlane, 0.1, 1000000.);
	float _dofRadius = clamp(dofRadius, .0, 250.);

	float _dofImFocalPlane = 1./(1./_dofFocusDistance - 1./_dofFocalPlane);
	
	float sceneDepth = tex2D(depthSampler, IN.textureCoords).x;
	float sceneDepthReal = unprojZ(projMat, sceneDepth*2.-1.);

	float4 baseImage = tex2D(screenSampler, IN.textureCoords);
	float baseImageBlurFactor = abs(1. - 2. / ( 1. + abs(sceneDepthReal) / _dofFocalPlane ));
	//float sceneImDepthReal = 1./(1./_dofFocusDistance - 1./sceneDepthReal);

	float dofRadiusInTexture = _dofRadius / max(screenTextureSize.x,screenTextureSize.y);
	int samp = int(min(float(ceil(pow(_dofRadius,0.7))),25.));

	float dofStep = 1./float(samp);
	float dofStepWeight = 1./(1.+2.*float(samp));

	float4 dof_result = float4(0.);

	float4 prevImage = baseImage;

	dof_result += baseImage*float4(dofStepWeight);
	for(int j=-1;j<=1;j+=2) {
		for(int i=1;i<=25;i++) {
			if(i>samp) {
				break;
			}
			else {
				float dr = dofRadiusInTexture*float(i)*float(j)*dofStep;
				float2 readPos = clamp(IN.textureCoords + IN.blurBasis*float2(dr)/aspectRatio, float2(0.), screenTextureRatio-float2(1.)/screenTextureSize);
				
				float newDepth = tex2D(depthSampler, readPos).x;
				float newDepthReal = unprojZ(projMat, newDepth*2.-1.);

				float4 newDof;
				
				float blurFactor = 1. - 2. / ( 1. + abs(newDepthReal) / _dofFocalPlane );

				/*if(blurFactor > 0.5) {
					
				}
				else if(blurFactor > 0.1) {

				}
				else if(blurFactor > -0.1) {

				}
				else if(blurFactor > -0.5) {

				}
				else if(blurFactor > -1.) {

				}*/

				if ( float(i)*dofStep < abs(baseImageBlurFactor) && baseImageBlurFactor > blurFactor ) {
					newDof = tex2D(screenSampler, readPos);
				}
				else if ( float(i)*dofStep > abs(baseImageBlurFactor) && -blurFactor > float(i)*dofStep ) {
					newDof = tex2D(screenSampler, readPos);
					//prevImage = newDof;
				}
				else {
					//newDof = prevImage;
					newDof = baseImage;
				}

				dof_result += newDof * dofStepWeight;
			}
		}
	}


	return dof_result;// + baseImage;
};

technique dof : POST_EFFECT {
	pass pass1{
		VertexShader = compile vs_dof_shading1();
		PixelShader = compile fs_dof_shading();
	};
	pass pass2{
		VertexShader = compile vs_dof_shading2();
		PixelShader = compile fs_dof_shading();
	};
	pass pass3{
		VertexShader = compile vs_dof_shading3();
		PixelShader = compile fs_dof_shading();
	};
};


