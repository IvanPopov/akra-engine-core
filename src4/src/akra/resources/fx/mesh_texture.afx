provide akra.system;

struct VS_IN_2{
	float3 tex_coord0: TEXCOORD0;
	float3 tex_coord1: TEXCOORD1;
	float3 tex_coord2: TEXCOORD2;
	float3 tex_coord3: TEXCOORD3;
	float3 tex_coord4: TEXCOORD4;
	float3 tex_coord5: TEXCOORD5;
	float3 tex_coord6: TEXCOORD6;
	float3 tex_coord7: TEXCOORD7;
	float3 tex_coord8: TEXCOORD8;
	float3 tex_coord9: TEXCOORD9;
	float3 tex_coord10: TEXCOORD10;
	float3 tex_coord11: TEXCOORD11;
	float3 tex_coord12: TEXCOORD12;
	float3 tex_coord13: TEXCOORD13;
	float3 tex_coord14: TEXCOORD14;
	float3 tex_coord15: TEXCOORD15;
};

struct VS_OUT_2{
	float3 vert:VERTEX;
	float3 norm:NORMAL;
//    float4x4 normal_mat:NORMAL_MAT;
	float3 tc_diffuse: TEXCOORD0;
	float3 tc_ambient: TEXCOORD1;
	float3 tc_specular: TEXCOORD2;
	float3 tc_emissive: TEXCOORD3;
	float3 tc_normal: TEXCOORD4;
	float3 tc_shininess: TEXCOORD5;
};

texture tex0:TEXTURE0;
texture tex1:TEXTURE1;
texture tex2:TEXTURE2;
texture tex3:TEXTURE3;
texture tex4:TEXTURE4;
texture tex5:TEXTURE5;

sampler sampler_diffuse:S_DIFFUSE  = sampler_state
{
	Texture = <tex0>;
};
sampler sampler_ambient:S_AMBIENT  = sampler_state
{
	Texture = <tex1>;
};
sampler sampler_specular:S_SPECULAR  = sampler_state
{
	Texture = <tex2>;
};
sampler sampler_emissive:S_EMISSIVE  = sampler_state
{
	Texture = <tex3>;
};
sampler sampler_normal:S_NORMAL  = sampler_state
{
	Texture = <tex4>;
};

sampler sampler_shininess: S_SHININESS = sampler_state
{
	Texture = <tex5>;
};

struct base_material{
	float4 diffuse:DIFFUSE;
	float4 ambient:AMBIENT;
	float4 emissive:EMISSIVE;
	float4 specular:SPECULAR;
	float shininess:SHININESS;
};;

shared base_material Fragment_material;
shared float3 Normal;


struct Material {
	float4 ambient:AMBIENT;
	float4 diffuse:DIFFUSE;
	float4 specular:SPECULAR;
	float4 emissive:EMISSIVE;
	float shininess:SHININESS;
};

VS_OUT_2 vs_mesh_texture(VS_IN_2 IN) {
	VS_OUT_2 Out;

	Out.tc_diffuse = IN.tex_coord0;
	Out.tc_ambient = IN.tex_coord1;
	Out.tc_specular = IN.tex_coord2;
	Out.tc_emissive = IN.tex_coord3;
	Out.tc_normal = IN.tex_coord4;
	Out.tc_shininess = IN.tex_coord5;

	return Out;
}

Material defaultMaterial:MATERIAL;

float4x4 model_mat:MODEL_MATRIX;
float4x4 view_mat:VIEW_MATRIX;

bool useNormal;
bool normalFix;


void fs_mesh_texture_deferre_pass_1(VS_OUT_2 IN){
    float3 texNormal = tex2D(sampler_normal, float2(IN.tc_normal.xy)).xyz;    
    Normal = calcNormal(texNormal, IN.norm.xyz, IN.tc_normal.xy);

    Fragment_material.emissive = clamp(defaultMaterial.emissive + tex2D(sampler_emissive, float2(IN.tc_emissive.xy)), 0., 1.);
    Fragment_material.diffuse = clamp(defaultMaterial.diffuse + tex2D(sampler_diffuse, float2(IN.tc_diffuse.xy)), 0., 1.);
    
    if(!normalFix){
        Fragment_material.shininess = clamp(defaultMaterial.shininess + tex2D(sampler_shininess, float2(IN.tc_shininess.xy)), 0., 1.).r;
    }
}

void fs_mesh_texture_deferre_pass_2(VS_OUT_2 IN){
    Fragment_material.specular = clamp(defaultMaterial.specular + tex2D(sampler_specular, float2(IN.tc_specular.xy)), 0., 1.);
    Fragment_material.ambient = clamp(defaultMaterial.ambient + tex2D(sampler_ambient, float2(IN.tc_ambient.xy)), 0., 1.);

	if(normalFix){
		Fragment_material.shininess = clamp(defaultMaterial.shininess + tex2D(sampler_shininess, float2(IN.tc_shininess.xy)), 0., 1.).r;
	}
}

void fs_mesh_texture_normal(VS_OUT_2 IN){
    float3 texNormal = tex2D(sampler_normal, float2(IN.tc_normal.xy)).xyz;    
    Normal = calcNormal(texNormal, IN.norm.xyz, IN.tc_normal.xy);
}

void fs_mesh_texture_material(VS_OUT_2 IN){
    Fragment_material.emissive = clamp(defaultMaterial.emissive + tex2D(sampler_emissive, float2(IN.tc_emissive.xy)), 0., 1.);
    Fragment_material.diffuse = clamp(defaultMaterial.diffuse + tex2D(sampler_diffuse, float2(IN.tc_diffuse.xy)), 0., 1.);
    Fragment_material.specular = clamp(defaultMaterial.specular + tex2D(sampler_specular, float2(IN.tc_specular.xy)), 0., 1.);
    Fragment_material.ambient = clamp(defaultMaterial.ambient + tex2D(sampler_ambient, float2(IN.tc_ambient.xy)), 0., 1.);

    Fragment_material.shininess = defaultMaterial.shininess;
}

void fs_mesh_texture_full(VS_OUT_2 IN){

    float3 texNormal = tex2D(sampler_normal, float2(IN.tc_normal.xy)).xyz;    
    
    Normal = calcNormal(texNormal, IN.norm.xyz, IN.tc_normal.xy);
    Fragment_material.emissive = clamp(defaultMaterial.emissive + tex2D(sampler_emissive, float2(IN.tc_emissive.xy)), 0., 1.);
    Fragment_material.diffuse = clamp(defaultMaterial.diffuse + tex2D(sampler_diffuse, float2(IN.tc_diffuse.xy)), 0., 1.);
    Fragment_material.specular = clamp(defaultMaterial.specular + tex2D(sampler_specular, float2(IN.tc_specular.xy)), 0., 1.);
    Fragment_material.ambient = clamp(defaultMaterial.ambient + tex2D(sampler_ambient, float2(IN.tc_ambient.xy)), 0., 1.);

    Fragment_material.shininess = clamp(defaultMaterial.shininess + tex2D(sampler_shininess, float2(IN.tc_shininess.xy)), 0., 1.).r;
}

float3 calcNormal(float3 texNormal, float3 vertexNormal, float2 tc_normal) {
    float3 result_normal = float3(0.);

    if(texNormal == float3(0.) || !useNormal){
        result_normal = vertexNormal;
    }
    else {        
        float3 normal = normalize(vertexNormal);
        float3 tangent = float3(dFdx(tc_normal.x), dFdy(tc_normal.x), 0.);
        tangent.z = -dot(tangent.xy,normal.xy)/normal.z;
        tangent = normalize(tangent);
        float3 binormal = cross(tangent, normal);

        //формируем матрицу трансформации
        float3x3 m3fTransform;
        m3fTransform[0] = tangent;
        m3fTransform[1] = binormal;
        m3fTransform[2] = normal;

        texNormal.xy = (texNormal.xy - 0.5) * 2.;

		texNormal = normalize(texNormal);

        result_normal = m3fTransform * texNormal;
    }

    return normalize(result_normal);
}

foreign bool optimeizeForDeferredPass1;
foreign bool optimeizeForDeferredPass2;
foreign bool optimizeForLPPPrepare;
foreign bool optimizeForLPPApply;

technique mesh_texture {
    import akra.system.mesh_geometry;
    pass p0 {
        VertexShader = compile vs_mesh_texture();
        if(optimeizeForDeferredPass1) {
            PixelShader = compile fs_mesh_texture_deferre_pass_1();
        }
        else if(optimeizeForDeferredPass2) {
            PixelShader = compile fs_mesh_texture_deferre_pass_2();
        }
        else if(optimizeForLPPPrepare) {
            PixelShader = compile fs_mesh_texture_normal();
        }
        //else if(optimizeForLPPApply) {
        //    PixelShader = compile fs_mesh_texture_material();
        //}
        else {
            PixelShader = compile fs_mesh_texture_full();
        }
    }
}