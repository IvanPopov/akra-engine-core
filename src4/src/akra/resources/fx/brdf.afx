include "common.afx";

float fixFloatPresision(float value){
	//if(abs(value) < 0.01){
	//	return sign(value) * 0.01;
	//}

	return value;
}

float GFunc(float3 l, float3 v, float3 n, float k){
	//float divisor = fixFloatPresision(4. * dot_saturate(n, l) * dot_saturate(n, v));
	//return G1Func(l, n, k) * G1Func(v, n, k) / divisor;

	//return G1Func(l, n, k);// * G1Func(v, n, k) ;
	//return 0.25 / (G1Func(l, n, k) * G1Func(v, n, k));
	return 1. / (G1Func(l, n, k) * G1Func(v, n, k));
}

float G1Func(float3 v, float3 n, float k){
	//return dot_saturate(n, v) / fixFloatPresision(dot_saturate(n, v) * (1. - k) + k);
	float NoV = dot_saturate(n, v);
	return NoV + sqrt( NoV * (NoV - NoV * k) + k );
}

float3 Squaref3( float3 x )
{
	return x*x;
}
//************************* DIFFUSE MODEL *********************************** */
float3 Diffuse_Lambert( float3 DiffuseColor )
{
	return DiffuseColor / PI; // 1 rcp 1 mul
}

// [Burley 2012, "Physically-Based Shading at Disney"]
float3 Diffuse_Burley( float3 DiffuseColor, float Roughness, float NoV,
					   float NoL, float VoH )
{
	float FD90 = 0.5 + 2. * VoH * VoH * Roughness;
	float FdV = 1. + (FD90 - 1.) * exp2((-5.55473 * NoV - 6.98316) * NoV );
	float FdL = 1. + (FD90 - 1.) * exp2((-5.55473 * NoL - 6.98316) * NoL );
	return DiffuseColor / PI * FdV * FdL;
}

// [Gotanda 2012, "Beyond a Simple Physically Based Blinn-Phong Model in Real-Time"]
float3 Diffuse_OrenNayar( float3 DiffuseColor, float Roughness, float NoV,
						  float NoL, float VoH )
{
	float VoL = 2. * VoH - 1.;
	float m = Roughness * Roughness;
	float m2 = m * m;
	float C1 = 1. - 0.5 * m2 / (m2 + 0.33);
	float Cosri = VoL - NoV * NoL;
	float C2 = 0.45 * m2 / (m2 + 0.09) * Cosri * (
		Cosri >= 0. ? min( 1., NoL / NoV ) : NoL );
	return DiffuseColor / PI * ( NoL * C1 + C2 );
}

float3 Diffuse_Func( float3 DiffuseColor, float Roughness, float NoV,
					float NoL, float VoH )
{
	// Diffuse model
	// 0: Lambert -- default
	// 1: Burley
	// 2: Oren-Nayar
	int PHYSICAL_DIFFUSE = 0;

	if (PHYSICAL_DIFFUSE == 0){
		return Diffuse_Lambert( DiffuseColor );  // 1 rcp 1 mul
	}
	else if (PHYSICAL_DIFFUSE == 1){
		return Diffuse_Burley( DiffuseColor, Roughness, NoV, NoL, VoH );
	}
	else if (PHYSICAL_DIFFUSE == 2){
		return Diffuse_OrenNayar( DiffuseColor, Roughness, NoV, NoL, VoH );
	}
}

//************************* D FUNCTIONS ************************************* */
// [Blinn 1977, "Models of light reflection for computer synthesized pictures"]
float D_Blinn( float Roughness, float NoH )
{
	float m = Roughness * Roughness;
	float m2 = m * m;
	float n = 2. / m2 - 2.;
	return (n+2.) / 2. * pow( saturate(NoH), n ); // 1 mad, 1 exp, 1 mul, 1 log
}

// [Beckmann 1963, "The scattering of electromagnetic waves from rough surfaces"]
float D_Beckmann( float Roughness, float NoH )
{
	float m = Roughness * Roughness;
	float m2 = m * m;
	float NoH2 = NoH * NoH;
	return exp( (NoH2 - 1.) / (m2 * NoH2) ) / ( m2 * NoH2 * NoH2 );
}

// GGX / Trowbridge-Reitz
// [Walter et al. 2007, "Microfacet models for refraction through rough surfaces"]
float D_GGX( float Roughness, float NoH )
{
	float m = Roughness * Roughness; 			// 1 mul
	float m2 = m * m;							// 1 mul
	float d = ( NoH * m2 - NoH ) * NoH + 1.;	// 2 mul 2 add
	return m2 / max( d*d, 0.00001 );			// 2 mul, 1 rcp
}	// 2 add 6 mul 1 rcp

float D_Func( float Roughness, float NoH )
{
	// Microfacet distribution function
	// 0: Blinn
	// 1: Beckmann
	// 2: GGX -- default
	int PHYSICAL_SPEC_D = 2;

	if (PHYSICAL_SPEC_D == 0){
		return D_Blinn( Roughness, NoH );
	}
	else if (PHYSICAL_SPEC_D == 1){
		return D_Beckmann( Roughness, NoH );
	}
	else if (PHYSICAL_SPEC_D == 2){
		return D_GGX( Roughness, NoH );	// 2 add 6 mul 1 rcp
	}
}


//************************* GEOMETRIC FUNCTIONS ***************************** */
float G_Implicit()
{
	return 0.25;
}

// [Neumann et al. 1999, "Compact metallic reflectance models"]
float G_Neumann( float NoV, float NoL )
{
	return 1. / ( 4. * max( NoL, NoV ) );
}

// [Kelemen 2001, "A microfacet based coupled specular-matte brdf model with importance sampling"]
float G_Kelemen( float3 L, float3 V )
{
	return 1. / ( 2. + 2. * dot(L, V) );
}

// Tuned to match behavior of G_Smith
// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
float G_Schlick( float Roughness, float NoV, float NoL )
{
	float k = Roughness * Roughness * 0.5;		//3 mul
	float G_SchlickV = NoV * (1. - k) + k;		//2 add 1 mul
	float G_SchlickL = NoL * (1. - k) + k;		//2 add 1 mul
	return 0.25 / ( G_SchlickV * G_SchlickL);	//2 mul 1 rcp
}	//4 add 7 mul 1 rcp

// Smith term for GGX modified by Disney to be less "hot" for small roughness values
// [Smith 1967, "Geometrical shadowing of a random rough surface"]
// [Burley 2012, "Physically-Based Shading at Disney"]
float G_Smith( float Roughness, float NoV, float NoL )
{
	float a = Roughness * Roughness;
	float a2 = a*a;

	float G_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
	float G_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
	return 1. / ( G_SmithV * G_SmithL );
}

float GeometricVisibility( float Roughness, float NoV, float NoL,
						   float3 L, float3 V )
{
	// Geometric attenuation or shadowing
	// 0: Implicit
	// 1: Neumann
	// 2: Kelemen
	// 3: Schlick -- default
	// 4: Smith (matched to GGX)
	int PHYSICAL_SPEC_G = 3;

	if (PHYSICAL_SPEC_G == 0){
		return G_Implicit();
	}
	else if (PHYSICAL_SPEC_G == 1){
		return G_Neumann( NoV, NoL );
	}
	else if (PHYSICAL_SPEC_G == 2){
		return G_Kelemen( L, V );
	}
	else if (PHYSICAL_SPEC_G == 3){
		return G_Schlick( Roughness, NoV, NoL );//4 add 7 mul 1 rcp
	}
	else if (PHYSICAL_SPEC_G == 4){
		return G_Smith( Roughness, NoV, NoL );
	}
}

//*********************** Fresnel ******************************************* */
float3 F_None( float3 SpecularColor )
{
	return SpecularColor;
}

// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
// [Lagarde 2012, "Spherical Gaussian approximation for Blinn-Phong, Phong and Fresnel"]
float3 F_Schlick( float3 SpecularColor, float VoH )
{
	// Anything less than 2% is physically impossible and is instead considered to be shadowing 
	return SpecularColor + ( saturate( 50.0 * SpecularColor.g ) - SpecularColor )
							* exp2( (-5.55473 * VoH - 6.98316) * VoH );

	//float Fc = exp2( (-5.55473 * VoH - 6.98316) * VoH );	// 1 mad, 1 mul, 1 exp
	//return Fc + (1 - Fc) * SpecularColor;					// 1 add, 3 mad
}	//3 add 3 mul 1 exp

float3 F_Fresnel( float3 SpecularColor, float VoH )
{
	float3 SpecularColorSqrt = sqrt( clamp( SpecularColor, 0., 0.99) );
	float3 n = ( 1. + SpecularColorSqrt ) / ( 1. - SpecularColorSqrt );
	float3 g = sqrt( n*n + VoH*VoH - 1. );
	return 0.5 * Squaref3( (g - VoH) / (g + VoH) )
			   * ( 1. + Squaref3( ((g+VoH)*VoH - 1.) / ((g-VoH)*VoH + 1.) ) );
}

float3 Fresnel( float3 SpecularColor, float VoH )
{
	// Fresnel
	// 0: None
	// 1: Schlick -- default
	// 2: Fresnel
	int PHYSICAL_SPEC_F = 1;

	if (PHYSICAL_SPEC_F == 0){
		return F_None( SpecularColor );
	}
	else if (PHYSICAL_SPEC_F == 1){
		return F_Schlick( SpecularColor, VoH ); //3 add 3 mul 1 exp
	}
	else if (PHYSICAL_SPEC_F == 2){
		return F_Fresnel( SpecularColor, VoH );
	}
}

//******** for LPP **** */
float LPP_F_Schlick_Exp(float VoH)
{
	return exp2( (-5.55473 * VoH - 6.98316) * VoH );
}

float3 schlick_specular_modifier(float3 SpecularColorMat){
    return ( saturate( 50.0 * SpecularColorMat.g ) - SpecularColorMat );
}

//********* for Reflections ****** */
float3 EnvBRDFApprox( float3 SpecularColor, float Roughness, float NoV )
{
	// [ Lazarov 2013, "Getting More Physical in Call of Duty: Black Ops II" ]
	// Adaptation to fit our G term.
	const float4 c0 = { -1., -0.0275, -0.572, 0.022 };
	const float4 c1 = { 1., 0.0425, 1.04, -0.04 };
	float4 r = Roughness * c0 + c1;						// 1 add 1 mul
	float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y; //2 mul 1 pow
	float2 AB = float2( -1.04, 1.04 ) * a004 + r.zw;	// 1 add 1 mul

	return SpecularColor * AB.x + AB.y; // 1 add 1 mul
}	//3 add 3 mul 1 pow

float EnvBRDFApproxNonmetal( float Roughness, float NoV )
{
	// Same as EnvBRDFApprox( 0.04, Roughness, NoV )
	const float2 c0 = { -1., -0.0275 };
	const float2 c1 = { 1., 0.0425 };
	float2 r = Roughness * c0 + c1;
	return min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
}