struct light_data {
	float4 diffuse     : DIFFUSE;
	float4 ambient     : AMBIENT;
	float4 specular    : SPECULAR;
	float3 attenuation : ATTENUATION;
	float3 position    : POSITION; //in camera space
};

struct sun_light_data {
	float3 sunDir: SUN_DIRECTION;
	float3 eyePos: EYE_POSITION;
	float3 ground0: GROUNDC0;
	float3 ground1: GROUNDC1;
	float3 hg: HG;
	int skyDomeId: SKY_DOME_ID; 
};

struct pixel_data{
	float4 diffuse  : DIFFUSE;
	float4 ambient  : AMBIENT;
	float4 specular : SPECULAR;
	float3 position : POSITION; //in camera space
	float3 normal   : NORMAL;
	float shininess : SHININESS;
	float  depth    : DEPTH;
	int    id       : RENDER_OBJECT_ID;
};

struct light_omni{
	light_data lightData : LIGHT_DATA;
};

struct light_project{
	light_data lightData   : LIGHT_DATA;
	float4x4 shadow_matrix : SHADOW_MATRIX;
};

struct light_omni_shadows{
	light_data lightData      : LIGHT_DATA;
	float4x4 toLightSpace[6] : TO_LIGHT_SPACE;
	float4x4 optimized_projection_matrix[6] : OPTIMIZED_PROJECTION_MATRIX;
};

struct light_project_shadows{
	light_data lightData   : LIGHT_DATA;
	float4x4 toLightSpace : TO_LIGHT_SPACE;
	float4x4 real_projection_matrix : REAL_PROJECTION_MATRIX;
	float4x4 optimized_projection_matrix : OPTIMIZED_PROJECTION_MATRIX;
};

struct light_sun{
	sun_light_data lightData : LIGHT_DATA;
};

struct light_sun_shadows{
	sun_light_data lightData : LIGHT_DATA;
	float4x4 toLightSpace : TO_LIGHT_SPACE;
	float4x4 optimized_projection_matrix : OPTIMIZED_PROJECTION_MATRIX;
};


struct calc_light_Params {
	float3 ambient;
	float3 diffuse;
	float3 specular;
	float shadowMultiplier;
};


float calcAttenuation(float light_dir_length, float3 attenuation) {
    return  1.0 / (attenuation.x + attenuation.y * light_dir_length + attenuation.z * light_dir_length * light_dir_length);
}

float4 returnColor(float4 color) {
	if(isPrepareAll){
		return float4(color.xyz, 1.);
	}
	else {
		return color;
	}
}

foreign bool isForLPPPass0 = false;
foreign bool isForLPPPass1 = false;
foreign bool isPrepareAll = true;
foreign bool isUsedBlinnPhong = false;
foreign bool isUsedPhong = true;

calc_light_Params prepareBaseLightParams(pixel_data pixelData, light_data lightData) {
	calc_light_Params lightParams;

	float3 light_dir = lightData.position - pixelData.position;
    float attenuation = calcAttenuation(length(light_dir), lightData.attenuation);

    light_dir = normalize(light_dir);

    if(isPrepareAll || isForLPPPass0){
    	float light_distancedotVpow = 0.5;

	    if(pixelData.shininess != 0.){
	        float3 view_dir = normalize(-pixelData.position);
	        float3 reflect_dir = normalize(reflect(-light_dir, pixelData.normal));

	        light_distancedotVpow = pow(max(0., min(1., dot(reflect_dir, view_dir))), pixelData.shininess);
	    }

	    lightParams.diffuse = lightData.diffuse.xyz * max(dot(pixelData.normal, light_dir), .0) * attenuation;
	    lightParams.specular = lightData.specular.xyz * light_distancedotVpow * attenuation;
    }

    if(isUsedPhong && (isPrepareAll || isForLPPPass1)) {
    	lightParams.ambient = lightData.ambient.xyz * attenuation;
    }

    return lightParams;
}

calc_light_Params prepareBaseLightParamsSun(pixel_data pixelData, float3 light_dir, float4 diffuse, float4 ambient, float4 specular){
	calc_light_Params lightParams;
	
	if(isPrepareAll || isForLPPPass0){
		light_dir = normalize(light_dir);
		float3 fixNormal = lerp(light_dir, pixelData.normal, kFixNormal);
		float light_distancedotVpow = 0.;

		if(pixelData.shininess != 0. && specular.xyz != float3(0.)){
			float3 view_dir = normalize(-pixelData.position);
			float3 reflect_dir = normalize(reflect(-light_dir, fixNormal));

			light_distancedotVpow = pow(max(0., min(1., dot(reflect_dir, view_dir))), pixelData.shininess);
		}

		lightParams.diffuse = diffuse.xyz * max(dot(fixNormal, light_dir), .0);
		lightParams.specular = specular.xyz * light_distancedotVpow;
	}

	if(isUsedPhong && (isPrepareAll || isForLPPPass1)) {
    	lightParams.ambient = ambient.xyz;
    }
	
	return lightParams;
}

float4 applyBaseLightParams(pixel_data pixelData, light_data lightData){
	float4 color = float4(0.);
	calc_light_Params lightParams = prepareBaseLightParams(pixelData, lightData);

	if(isPrepareAll){
		color = pixelData.ambient * float4(lightParams.ambient, 1.0) + pixelData.diffuse * float4(lightParams.diffuse, 1.0) + pixelData.specular * float4(lightParams.specular, 1.0);
	}
	else if(isForLPPPass0) {
		color = float4(lightParams.diffuse, lightParams.specular.x);
	}
	else if(isForLPPPass1) {
		color = float4(lightParams.ambient, 0.);
	}

	return color;
}

float kFixNormal = 0.5;
float fSunSpecular = 0.;
float fSunAmbient = 0.;
float3 camPos: CAMERA_POSITION;
float4x4 invView: INV_VIEW_CAMERA_MAT;
float4x4 view: VIEW_MATRIX;

float4 applyBaseLightParamsSun(pixel_data pixelData, sun_light_data lightData, float3 worldPos) {
	float4 color = float4(0.);

	float3 v3Pos = lightData.eyePos - pixelData.position.xyz;
	float fCos = dot(lightData.sunDir, v3Pos)/length(v3Pos);
	float fCos2 = fCos * fCos;

	float3 Mie = getMiePhase(fCos, fCos2, lightData.hg) * lightData.ground1;
	float4 lightDiffuse = float4(0.);

	lightDiffuse.rgb = getRayleighPhase(fCos2) * lightData.ground0 + Mie;
	lightDiffuse.rgb = HDR(lightDiffuse.rgb);
	float fFogValue = ComputeVolumetricFog(worldPos - camPos);
	
	calc_light_Params lightParams = prepareBaseLightParamsSun(pixelData, float4(view * float4(lightData.sunDir, 0.)).xyz, lightDiffuse, float4(fSunAmbient), float4(fSunSpecular));

	if(isPrepareAll){
		color = pixelData.ambient * float4(lightParams.ambient, 1.0) + pixelData.diffuse * float4(lightParams.diffuse, 1.0) + pixelData.specular * float4(lightParams.specular, 1.0);
	}
	else if(isForLPPPass0) {
		color = float4(lightParams.diffuse, lightParams.specular.x);
	}
	else if(isForLPPPass1) {
		color = float4(lightParams.ambient, 0.);
	}

	return color;
}

float calcProjectLightInfluence(float4x4 toLightProjectSpace, float3 position){
	float lightAttenuation = -1.;

	float4 v4fTmp = toLightProjectSpace * float4(position, 1.);
	float3 v3fTest = abs(v4fTmp.xyz/v4fTmp.w);

	//тест на попадание в область действия источника
	//if(all(lessThanEqual(v3fTest,float3(1.)))){
	if(length(v3fTest) <= sqrt(3.) && v4fTmp.w >= 0.){ //более приятно выглядит
		float alpha = 0.05;
		lightAttenuation = (exp(-alpha*dot(v3fTest,v3fTest)) - exp(-alpha*3.))/(1. - exp(-alpha*3.));
	}

	return lightAttenuation;
}

bool isUnderShadowInfluence(float4x4 toLightSpace, float4x4 projMat, float3 position, out float2 shadowTexCoords, out float realDepth) {
	float4 v4fLightSpace = toLightSpace *float4(position, 1.);

	float4 v4fTmp = projMat * v4fLightSpace;
	float3 v3fOptimizedLightSpacePosition = v4fTmp.xyz/v4fTmp.w;

	float3 v3fTest = abs(v3fOptimizedLightSpacePosition.xyz);

	//тест на попадание в область действия источника
	//так как здесь происходит считывание из текстуру другой тест не корректен
	if(all(lessThanEqual(v3fTest.xy, float2(1.))) && v3fOptimizedLightSpacePosition.z >= -1. && v4fTmp.w >= 0.){
		shadowTexCoords = (v3fOptimizedLightSpacePosition.xy + 1.)/2.;
		realDepth = v4fLightSpace.z;
		return true;
	}
	
	return false;
}

float unprojZ(float4x4 projMat, float screenZ){
	return -projMat[3][2]/(projMat[2][2] + screenZ);
};

float unprojOrthoZ(float4x4 projMat, float screenZ){
	return (screenZ - projMat[3][2])/projMat[2][2];
	//return -projMat[3][2]/(projMat[2][2] + screenZ);
};

float fMinShadow : MIN_SHADOW_VALUE = 0.5;
float shadowConstant : SHADOW_CONSTANT = 5.e+2;
float shadowAttenuationConstant: SHADOW_ATTENUATION_CONSTANT = 0.2;

float calculateShadowMultiplier(sampler shadowSampler, float2 v2fShadowTextureCoords, float4x4 projMat, float realDepth){
	float lightDepth = tex2D(shadowSampler, v2fShadowTextureCoords).x*2. - 1.;
	//float lightDepth = blur(shadowSampler,v2fShadowTextureCoords,float2(1./512.)).x*2. - 1.;
	if(lightDepth == 1.){
		return 1.;
	}

	float lightRealDepth = unprojZ(projMat, lightDepth); //negative

	float fShadowMultiplier = clamp(exp(shadowConstant*(1.e-2 - lightRealDepth + realDepth)), fMinShadow, 1.);
	fShadowMultiplier = 1. - (1. - fShadowMultiplier) * exp(shadowAttenuationConstant*(realDepth - lightRealDepth));
	return fShadowMultiplier;
}

float alpha = 3.;

float4 blur(sampler Sampler,float2 texCoords, float2 invTexSize){
	const int blurX = 2;
	const int blurY = 2;

	float4 value = float4(0.);
	float totalWeight = 0.;
	for(int i=-blurX;i<=blurX;i++){
		for(int j=-blurY;j<=blurY;j++){
			float fX = float(i);
			float fY = float(j);
			float weight = exp(-alpha*(fX*fX + fY*fY));
			totalWeight += weight;
			value += weight * tex2D(Sampler,texCoords + invTexSize*float2(fX,fY));
		}
	}
	return value/totalWeight;
}




float Exposure = -2.0;
float c = 0.002f; // height falloff
float b = 0.002f; // global density

float3 HDR( float3 LDR){
	return 1.0f - exp( Exposure * LDR );
}

float getMiePhase(float fCos, float fCos2, float3 vHG){
	//return 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(1.0 + g2 - 2.0*g*fCos, 1.5);
	return vHG.x * (1.0 + fCos2) / pow(abs(vHG.y - vHG.z * fCos), 1.5);
}

// Calculates the Rayleigh phase function
float getRayleighPhase(float fCos2){
	return 0.75 + 0.75 * fCos2;
}

float cHeightFalloff = 0.002f; 
float cGlobalDensity  = 0.002f;

float ComputeVolumetricFog(float3 cameraToWorldPos) 
{  
  //float3 cameraToWorldPos = v3Pos - camPos;
  float cVolFogHeightDensityAtViewer = exp(-cHeightFalloff * camPos.y); 
  float fogInt = length( cameraToWorldPos ) * cVolFogHeightDensityAtViewer; 
  const float cSlopeThreshold = 0.01; 
  if(abs(cameraToWorldPos.y) > cSlopeThreshold) 
  { 
	float t = cHeightFalloff * cameraToWorldPos.y; 
	fogInt *= (1.0 - exp(-t)) / t; 
  } 
  return exp(-cGlobalDensity * fogInt); 
}

float calculateSunShadowMultiplier(sampler shadowSampler, float2 v2fShadowTextureCoords, float4x4 projMat, float realDepth){

	float lightDepth = tex2D(shadowSampler, v2fShadowTextureCoords).x*2. - 1.;
	if(lightDepth == 1.){
		return 1.;
	}

	float lightRealDepth = unprojOrthoZ(projMat, lightDepth); //negative

	return clamp(exp(shadowConstant*(0.08 - lightRealDepth + realDepth)), fMinShadow, 1.);
};

float readRealLightDepth(sampler shadowSampler, float2 v2fShadowTextureCoords, float4x4 projMat){
	float lightDepth = tex2D(shadowSampler, v2fShadowTextureCoords).x*2. - 1.;
	if(lightDepth == 1.){
		return 1.;
	}

	return unprojOrthoZ(projMat, lightDepth); //negative
};

float2 v2fShadowTexSize = float2(2048.);

float calculateSunShadowMultiplierUpgraded(sampler shadowSampler, float2 v2fShadowTextureCoords, float4x4 projMat, float realDepth){

	float2 v2fTexPos = v2fShadowTextureCoords * v2fShadowTexSize - float2(0.5);
	float2 v2fTmp = floor(v2fTexPos);
	float2 alpha = v2fTexPos - v2fTmp;
	float2 beta = float2(1.) - alpha;

	float2 v2fTex1 = (v2fTmp + float2(0.5))/v2fShadowTexSize;
	float2 v2fTex2 = v2fTex1 + float2(1.)/v2fShadowTexSize;

	float lightDepth1 = readRealLightDepth(shadowSampler, float2(v2fTex1.x, v2fTex1.y), projMat);
	float lightDepth2 = readRealLightDepth(shadowSampler, float2(v2fTex1.x, v2fTex2.y), projMat);
	float lightDepth3 = readRealLightDepth(shadowSampler, float2(v2fTex2.x, v2fTex1.y), projMat);
	float lightDepth4 = readRealLightDepth(shadowSampler, float2(v2fTex2.x, v2fTex2.y), projMat);

	float lightRealDepth = 0.;
	float quantity = 0.;
	float minDepth = -1000000.;

	if(lightDepth1 < 0.){lightRealDepth += lightDepth1; quantity++; minDepth = max(minDepth, lightDepth1);}
	if(lightDepth2 < 0.){lightRealDepth += lightDepth2; quantity++; minDepth = max(minDepth, lightDepth2);}
	if(lightDepth3 < 0.){lightRealDepth += lightDepth3; quantity++; minDepth = max(minDepth, lightDepth3);}
	if(lightDepth4 < 0.){lightRealDepth += lightDepth4; quantity++; minDepth = max(minDepth, lightDepth4);}

	if(quantity == 0.){
		return 1.;
	}
	else{
		lightRealDepth = lightRealDepth/quantity;
	}

	float fShadowMultiplier;
	fShadowMultiplier = clamp(exp(shadowConstant*(0.08 - lightRealDepth + realDepth)), fMinShadow, 1.);
	fShadowMultiplier = 1. - (1. - fShadowMultiplier) * exp(shadowAttenuationConstant*(realDepth - minDepth));
	return fShadowMultiplier;

	// fShadowMultiplier = (shadowMult1 * alpha.y + shadowMult2 * beta.y) * alpha.x
	// 						+ (shadowMult3 * alpha.y + shadowMult4 * beta.y) * beta.x;   
	// return fShadowMultiplier;
};