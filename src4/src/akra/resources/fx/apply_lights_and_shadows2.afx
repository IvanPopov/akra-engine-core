provide akra.system;

include "lightDataStructs.afx";

foreign int nOmniShadows;
foreign int nOmni;
foreign int nProjectShadows;
foreign int nProject;
foreign int nSun;
foreign int nSunShadows;

sampler project_shadow_sampler[nProjectShadows] : PROJECT_SHADOW_SAMPLER;
sampler omni_shadow_sampler[nOmniShadows * 6] : OMNI_SHADOW_SAMPLER;
sampler sun_shadow_sampler[nSunShadows] : SUN_SHADOW_SAMPLER;

light_omni_shadows points_omni_shadows[nOmniShadows];
light_omni points_omni[nOmni];
light_project_shadows points_project_shadows[nProjectShadows];
light_project points_project[nProject];
light_sun points_sun[nSun];
light_sun_shadows points_sun_shadows[nSunShadows];

shared float4 result_color = float4(0.);
shared pixel_data pixelData;

float4 apply_light_omni() : COLOR {
	for(int i = 0; i < nOmni; i++){
		if(isPrepareAll){
			result_color += applyBaseLightParams(pixelData, points_omni[i].lightData);
		}
	}
	
	return float4(result_color.xyz, 1.);
}

float4 apply_light_project() : COLOR{
	for(int i = 0; i < nProject; i++){
		float lightAttenuation = calcProjectLightInfluence(points_project[i].shadow_matrix, pixelData.position);
		if(lightAttenuation >= 0.) {
			result_color += applyBaseLightParams(pixelData, points_project[i].lightData) * lightAttenuation;
		}
	}

	return float4(result_color.xyz, 1.);
}

float4 apply_light_omni_shadow() : COLOR{
	for(int i = 0; i < nOmniShadows; i++){
		float4 tmpColor = applyBaseLightParams(pixelData, points_omni_shadows[i].lightData);
		float shadowMultiplier = 1.;

		bool isOk = true;
		for(int j = 0; j < 6; j++){
			float2 shadowTexCoords;
			float realDepth;
			if(isOk){
				if(isUnderShadowInfluence(points_omni_shadows[i].toLightSpace[j], 
										points_omni_shadows[i].optimized_projection_matrix[j],
										pixelData.position,
										shadowTexCoords, realDepth)){

					shadowMultiplier = calculateShadowMultiplier(omni_shadow_sampler[i * 6 + j], shadowTexCoords,
																 points_omni_shadows[i].optimized_projection_matrix[j], realDepth);
					isOk = false;
					break;
				}
			}
			else {
				break;
			}
		}

		result_color += tmpColor * shadowMultiplier;
	}

	return float4(result_color.xyz, 1.);
}

float4 apply_light_project_shadows() : COLOR{
	for(int i = 0; i < nProjectShadows; i++){
		float lightAttenuation = calcProjectLightInfluence(points_project_shadows[i].real_projection_matrix * points_project_shadows[i].toLightSpace, pixelData.position);

		if(lightAttenuation >= 0.){
			float4 tmpColor = applyBaseLightParams(pixelData,points_project_shadows[i].lightData) * lightAttenuation;
			float shadowMultiplier = 1.;
			float2 shadowTexCoords;
			float realDepth;

			if(isUnderShadowInfluence(points_project_shadows[i].toLightSpace, 
									points_project_shadows[i].optimized_projection_matrix,
									pixelData.position,
									shadowTexCoords, realDepth)) {
				shadowMultiplier = calculateShadowMultiplier(project_shadow_sampler[i], shadowTexCoords,
																points_project_shadows[i].optimized_projection_matrix, realDepth);
			}

			result_color += tmpColor * shadowMultiplier;
		}
	}

	return float4(result_color.xyz, 1.);
}

technique omniLighting{
	pass applyOmniLighting{
		if(nOmni > 0){
			PixelShader = compile apply_light_omni();
		}
	};
};

technique projectLighting{
	pass applyProjectLighting{
		if(nProject > 0){
			PixelShader = compile apply_light_project();
		}
	};
};

technique omniShadowsLighting{
	pass applyOmniShadowsLighting{
		if(nOmniShadows > 0){
			PixelShader = compile apply_light_omni_shadow();
		}
	};   
};

technique projectShadowsLighting{
	pass applyProjectShadowsLighting{
		if(nProjectShadows > 0){
			PixelShader = compile apply_light_project_shadows();
		}
	};   
};