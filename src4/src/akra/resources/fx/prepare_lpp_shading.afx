provide akra.system;

struct VS_OUT_1{
    //float3 vert:VERTEX;
    float3 norm:NORMAL;
    float3 tc_normal:TEXCOORD4;
};

bool useNormal;

sampler sampler_normal:S_NORMAL;

struct base_material {
    float shininess:SHININESS;
};

shared base_material Fragment_material;
shared float3 Normal;

int objectId : RENDER_OBJECT_ID;
const float MAX_SHININESS = 1.;

float4 fs_prepare_lpp_geometry(VS_OUT_1 IN) : COLOR {   
    float3 normalAndShininess = float3(Normal.xy, 0.);
    normalAndShininess.z = min(Fragment_material.shininess, MAX_SHININESS);
    if(Normal.z < 0.) {
        normalAndShininess.z += MAX_SHININESS + 0.1;
    }
    return float4(normalAndShininess, float(objectId));
}

technique prepare_lpp_geometry {
    pass p1{
        PixelShader = compile fs_prepare_lpp_geometry();
    };
}



float2 screenTextureRatio : SCREEN_TEXTURE_RATIO;

struct VS_OUT_2{
    float4 position : POSITION;
    float2 screenPosition : SCREEN_POSITION;
    float2 textureCoords : TEXCOORD0;
};

VS_OUT_2 vs_prepare_lpp_data_base(float2 position : POSITION){
    VS_OUT_2 Out;

    //float texCoodrX = (IN.position.x + 1.)/2. * screenTextureRatio.x;
    //float texCoordY = 1. - (1. - (IN.position.y + 1.)/2.) * screenTextureRatio.y;
    //float texCoordY = (IN.position.y + 1.)/2. * screenTextureRatio.y;

    Out.position = float4(position,0.,1.);
    Out.screenPosition = position;
    //Out.textureCoords = float2(texCoodrX,texCoordY);
    Out.textureCoords = (position + 1.)/2. * screenTextureRatio;
    
    return Out;
}

struct light_data {
    float4 diffuse     : DIFFUSE;
    float4 ambient     : AMBIENT;
    float4 specular    : SPECULAR;
    float3 attenuation : ATTENUATION;
    float3 position    : POSITION; //in camera space
};

struct light_omni{
    light_data lightData : LIGHT_DATA;
};

foreign int nOmni;

light_omni points_omni[nOmni];

texture tex0 : LPP_NORMAL_BUFFER_TEXTURE;
texture tex1 : LPP_DEPTH_BUFFER_TEXTURE;

sampler normalBuffer : SAMPLER_NORMAL_BUFFER = sampler_state
{
    Texture = <tex0>;
    MinFilter = NEAREST;
    MagFilter = NEAREST;
};

sampler depthBuffer : SAMPLER_DEPTH_BUFFER = sampler_state
{
    Texture = <tex1>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

float4x4 projMat : PROJ_MATRIX;
float3 unproj(float4x4 projMat, float3 screenCoords){
    
    //mat4[i] - i-й столбец матрицы 
    //не строка, а именно столбец
  
    float z = -projMat[3][2]/(projMat[2][2] + screenCoords.z);
    float y = -(screenCoords.y * z + projMat[2][1] * z)/projMat[1][1];
    float x = -(screenCoords.x * z + projMat[2][0] * z)/projMat[0][0];
  
    return float3(x,y,z);
};

struct pixel_data {
    float3 position  : POSITION; //in camera space
    float3 normal    : NORMAL;
    int    id        : RENDER_OBJECT_ID; 
    float  shininess : SHININESS;
    float  depth     : DEPTH;
};

shared pixel_data pixelData;
shared float4 result_color = float4(0.);

void fs_prepare_lpp_data_base(float2 texCoords: TEXCOORD0, float2 screenPosition : SCREEN_POSITION) {
    float4 bufferData = tex2D(normalBuffer, texCoords);
    //if(bufferData.w == 0.){
    //    discard;
    //}

    fs_prepare_lpp_data_positionOnly(texCoords, screenPosition);
    float3 normal = float3(bufferData.xy, sqrt(1. - dot(bufferData.xy, bufferData.xy)));
    float shininess = bufferData.z > MAX_SHININESS ? (bufferData.z - MAX_SHININESS - 0.1) : bufferData.z;

    if(bufferData.z > MAX_SHININESS){
        normal.z *= -1.;
    }
    
    pixelData.normal = normal;
    pixelData.shininess = shininess;
    pixelData.id = int(bufferData.w);
}

void fs_prepare_lpp_data_positionOnly(float2 texCoords: TEXCOORD0, float2 screenPosition : SCREEN_POSITION) {
    float depth = tex2D(depthBuffer, texCoords).x * 2. - 1.;
    float3 pixelPos = unproj(projMat, float3(screenPosition.xy,depth));
    pixelData.depth = depth;
    pixelData.position = pixelPos;
}

foreign bool prepareOnlyPosition;
technique prepare_lpp_lights_base {
    pass p1{
        VertexShader = compile vs_prepare_lpp_data_base();
        if(prepareOnlyPosition) {
            PixelShader = compile fs_prepare_lpp_data_positionOnly();            
        }
        else {
            PixelShader = compile fs_prepare_lpp_data_base();
        }
    }
}
