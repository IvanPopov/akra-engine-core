provide akra.system;

struct VS_OUT_1{
    //float3 vert:VERTEX;
    float3 norm:NORMAL;
    float3 tc_normal:TEXCOORD4;
};

bool useNormal;

sampler sampler_normal:S_NORMAL;
struct Material {
    float shininess:SHININESS;
};

Material defaultMaterial:MATERIAL;
int objectId : RENDER_OBJECT_ID;
shared float3 Normal;
const float MAX_SHININESS = 30000.;

float4 fs_prepare_lpp_geometry(VS_OUT_1 IN) : COLOR {   
    float3 normalAndShininess = float3(Normal.xy, 0.);
    normalAndShininess.z = min(defaultMaterial.shininess, MAX_SHININESS - 1.);
    if(Normal.z >= 0.){
        normalAndShininess.z += MAX_SHININESS;
    }
    return float4(normalAndShininess, float(objectId));
}

technique prepare_lpp_geometry {
    pass p1{
        PixelShader = compile fs_prepare_lpp_geometry();
    };
}



float2 screenTextureRatio : SCREEN_TEXTURE_RATIO;

struct VS_OUT_2{
    float4 position : POSITION;
    float2 screenPosition : SCREEN_POSITION;
    float2 textureCoords : TEXCOORD0;
};

VS_OUT_2 vs_prepare_lpp_data_base(float2 position : POSITION){
    VS_OUT_2 Out;

    //float texCoodrX = (IN.position.x + 1.)/2. * screenTextureRatio.x;
    //float texCoordY = 1. - (1. - (IN.position.y + 1.)/2.) * screenTextureRatio.y;
    //float texCoordY = (IN.position.y + 1.)/2. * screenTextureRatio.y;

    Out.position = float4(position,0.,1.);
    Out.screenPosition = position;
    //Out.textureCoords = float2(texCoodrX,texCoordY);
    Out.textureCoords = (position + 1.)/2. * screenTextureRatio;
    
    return Out;
}

struct light_data {
    float4 diffuse     : DIFFUSE;
    float4 ambient     : AMBIENT;
    float4 specular    : SPECULAR;
    float3 attenuation : ATTENUATION;
    float3 position    : POSITION; //in camera space
};

struct light_omni{
    light_data lightData : LIGHT_DATA;
};

foreign int nOmni;

light_omni points_omni[nOmni];

texture tex0 : LPP_NORMAL_BUFFER_TEXTURE;
texture tex1 : LPP_DEPTH_BUFFER_TEXTURE;

sampler normalBuffer : SAMPLER_NORMAL_BUFFER = sampler_state
{
    Texture = <tex0>;
    MinFilter = NEAREST;
    MagFilter = NEAREST;
};

sampler depthBuffer : SAMPLER_DEPTH_BUFFER = sampler_state
{
    Texture = <tex1>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

float4x4 projMat : PROJ_MATRIX;
float3 unproj(float4x4 projMat, float3 screenCoords){
    
    //mat4[i] - i-й столбец матрицы 
    //не строка, а именно столбец
  
    float z = -projMat[3][2]/(projMat[2][2] + screenCoords.z);
    float y = -(screenCoords.y * z + projMat[2][1] * z)/projMat[1][1];
    float x = -(screenCoords.x * z + projMat[2][0] * z)/projMat[0][0];
  
    return float3(x,y,z);
};

struct pixel_data {
    float3 position  : POSITION; //in camera space
    float3 normal    : NORMAL;
    int    id        : RENDER_OBJECT_ID; 
    float  shininess : SHININESS;
    float  depth     : DEPTH;
};

shared pixel_data pixelData;
shared float4 result_color = float4(0.);

void fs_prepare_lpp_data_base(float2 texCoords: TEXCOORD0, float2 screenPosition : SCREEN_POSITION) {
    fs_prepare_lpp_data_positionOnly(texCoords, screenPosition);
    float4 bufferData = tex2D(normalBuffer, texCoords);    
    float3 normal = float3(bufferData.xy, sqrt(1. - dot(bufferData.xy, bufferData.xy)));
    float shininess = bufferData.z >= MAX_SHININESS ? (bufferData.z - MAX_SHININESS) : bufferData.z;

    if(bufferData.z < MAX_SHININESS){
        normal.z *= -1.;
    }
    
    pixelData.normal = normal;
    pixelData.shininess = shininess;
    pixelData.id = int(bufferData.w);
}

void fs_prepare_lpp_data_positionOnly(float2 texCoords: TEXCOORD0, float2 screenPosition : SCREEN_POSITION) {
    float depth = tex2D(depthBuffer, texCoords).x * 2. - 1.;
    float3 pixelPos = unproj(projMat, float3(screenPosition.xy,depth));
    pixelData.depth = depth;
    pixelData.position = pixelPos;
}


float4 prepare_lpp_lights_omni() : COLOR {
    for(int i = 0; i < nOmni; i++){
        result_color += calculateLight(pixelData, points_omni[i].lightData);
    }

    return result_color;
}

float4 prepare_lpp_lights_omni_ambient() : COLOR {
    for(int i = 0; i < nOmni; i++){
        result_color += calculateAbmientLight(pixelData, points_omni[i].lightData);
    }

    result_color.w = 1.;

    return result_color;
}

float4 calculateLight(pixel_data pixelData, light_data lightData){
    float3 light_dir = lightData.position - pixelData.position;
    float attenuation = calcAttenuation(length(light_dir), lightData.attenuation);

    light_dir = normalize(light_dir);
    float light_distancedotVpow = 0.;

    if(pixelData.shininess != 0.){
        float3 view_dir = normalize(-pixelData.position);
        float3 reflect_dir = normalize(reflect(-light_dir, pixelData.normal));

        light_distancedotVpow = pow(max(0., min(1., dot(reflect_dir, view_dir))), pixelData.shininess);
    }
    
    float specular = lightData.specular.x * light_distancedotVpow * attenuation;

    float diffuseMultiplier =  max(dot(pixelData.normal, light_dir), .0) * attenuation;

    return float4(lightData.diffuse.xyz * diffuseMultiplier, specular);
}

float calcAttenuation(float light_dir_length, float3 attenuation) {
    return  1.0 / (attenuation.x + attenuation.y * light_dir_length + attenuation.z * light_dir_length * light_dir_length);
}

float4 calculateAbmientLight(pixel_data pixelData, light_data lightData){
    float3 light_dir = lightData.position - pixelData.position;
    float attenuation = calcAttenuation(length(light_dir), lightData.attenuation);

    return float4(lightData.ambient.xyz * attenuation, 0.);
}

foreign bool prepareOnlyPosition;
technique prepare_lpp_lights_base {
    pass p1{
        VertexShader = compile vs_prepare_lpp_data_base();
        if(prepareOnlyPosition) {
            PixelShader = compile fs_prepare_lpp_data_positionOnly();            
        }
        else {
            PixelShader = compile fs_prepare_lpp_data_base();
        }
    }
}

technique prepare_lpp_lights_omni{
    pass p1{
        if(nOmni > 0){
            PixelShader = compile prepare_lpp_lights_omni();
        }
    }
}

technique prepare_lpp_lights_omni_ambient{
    pass p1{
        if(nOmni > 0){
            PixelShader = compile prepare_lpp_lights_omni_ambient();
        }
    };
};

