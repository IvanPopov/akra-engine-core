provide akra.system;

include "common.afx";

texture tex0 : INPUT_TEXTURE;
texture tex1 : DEPTH_TEXTURE;
float4x4 projMat : PROJ_MATRIX;

sampler screenSampler : INPUT_SAMPLER = sampler_state
{
	Texture = <tex0>;
	MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

sampler depthSampler : SAMPLER_SCENE_DEPTH = sampler_state
{
	Texture = <tex1>;
};

struct VS_OUT{
	float4 position : POSITION;
	float2 screenPosition : SCREEN_POSITION;
	float2 textureCoords : TEXCOORD0;
};;

float2 screenTextureRatio : INPUT_TEXTURE_RATIO;

VS_OUT vs_fxaa_shading(float2 pos: POSITION){
	VS_OUT Out;

	Out.position = float4(pos,0.,1.);
    Out.screenPosition = pos;
	//Out.textureCoords = float2(texCoodrX,texCoordY);
    Out.textureCoords = (pos + 1.)/2. * screenTextureRatio;
	
	return Out;
};

float2 screenSize : INPUT_TEXTURE_SIZE;

////////////////////////////////////////////////////////////////////////////////
float4 fs_fxaa_shading(VS_OUT IN) : COLOR{
	//if (IN.textureCoords.x < 0.498){
		//if (IN.textureCoords.y < 0.498){ //SW bottom left
			//return localMlaa(IN.textureCoords);
		//}
		//if (IN.textureCoords.y > 0.502){ //NW top left
			//return localMlaa(IN.textureCoords);
		//}
	//}
	//if (IN.textureCoords.x > 0.502){
		//if (IN.textureCoords.y < 0.498){ //SE bottom right
			//return fxaaOldTransformed2Hybrid(IN.textureCoords);
		//}
		//if (IN.textureCoords.y > 0.502){ //NE top right
			//return tex2D(screenSampler, IN.textureCoords);
		//}
	//}
	//return float4(1., 0., 0., 1.);


    return tex2D(screenSampler, IN.textureCoords);


};
////////////////////////////////////////////////////////////////////////////////
///////////////////////////// various functions ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

float fxaaLuma(float3 rgb)
{
	// Calculating luminocity of the points

	// Good way:
	return dot(rgb, float3(0.299, 0.587, 0.114));

	// or: (original paper)
	//float3 luma = float3(1., (0.587/0.299), 0.);
	// return rgb.g * (0.587/0.299) + rgb.r;
	// or: (unreal)
	// return rgb.g;
}

float4 fxaaTexture(float2 textureCoords)
{
	return tex2D(screenSampler, textureCoords);
}

float4 fxaaTextureOffset( float N, float W, float2 textureCoords, float2 invScreenSize)
{
	return fxaaTextureOffset(float2(W, N), textureCoords, invScreenSize);
}

float4 fxaaTextureOffset( float2 NW, float2 textureCoords, float2 invScreenSize)
{
	return fxaaTexture(textureCoords - NW * invScreenSize);
}

float fxaaLumaTex(float2 textureCoords)
{
	return fxaaLuma(tex2D(screenSampler, textureCoords).xyz);
}

float fxaaLumaTexOffset(float2 initCoords, float2 relCoords, float2 invScreenSize)
{
	return fxaaLuma(tex2D(screenSampler, initCoords + relCoords * invScreenSize).xyz);
}

float fxaaDepthTexture(float2 textureCoords)
{// the further the less
	return tex2D(depthSampler, textureCoords).r;
}

float fxaaDistance(float2 textureCoords)
{
	return unprojZ(projMat, fxaaDepthTexture(textureCoords));
}

float fxaaDepthTextureOffset( float N, float W, float2 textureCoords, float2 invScreenSize)
{
	return fxaaDepthTexture(textureCoords + (float2(-W, -N) * invScreenSize));
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////// AA hybrids ///////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

float4 fxaaOldTransformed2Hybrid(float2 textureCoords)
{
	float4 tf2 = transformedFxaa2(textureCoords);
	float4 of = oldFxaa(textureCoords);
	if (fxaaLuma(tf2.xyz) > fxaaLuma(of.xyz))
		return tf2;// * 0.9 + of * 0.1;
	return tf2 * 0.1 + of * 0.9;
}


////////////////////////////////////////////////////////////////////////////////
///////////////////////// Adaptation of MLAA to local data /////////////////////
////////////////////////////////////////////////////////////////////////////////

float LOC_MLAA_RANGE_MIN = 0.066;
float LOC_MLAA_RANGE_SCALE = 0.83;

float2 getDirection(float lumaAv, float lumaN, float lumaS,
								  float lumaW, float lumaE)
{

	float2 dir = float2(0.);
	if (lumaN < lumaAv || lumaS < lumaAv){
		if (lumaN > lumaS) {
			dir.x = 1.;
		}
		else {
			dir.x = -1.;
		}
	}

	if (lumaW < lumaAv || lumaE < lumaAv){
		if (lumaW > lumaE) {
			dir.x = 1.;
		}
		else {
			dir.x = -1.;
		}
	}
	return dir;

	//bool bBrightN = lumaN > lumaAv;
	//bool bBrightW = lumaW > lumaAv;
	//bool bBrightE = lumaE > lumaAv;
	//bool bBrightS = lumaS > lumaAv;

	//float goN;
	//if (bBrightN){
		//if (bBrightS){
				//goN = 0.;
			//} else {
			//goN = 1.;
		//}
	//} else if (bBrightS){
		//goN = -1.;
	//}

	//float goW;
	//if (bBrightW){
		//if (bBrightE){
				//goW = 0.;
			//} else {
			//goW = 1.;
		//}
	//} else if (bBrightE){
		//goW = -1.;
	//}
}

float2 specifyDirection(float2 startDir, float2 rcpScreenSize)
{
	// если всё 0
		// проверь все 4, верни макс направление
	// если север не 0 и запад не 0
		// верни (проверять не нужно - и так ясно, куда идти)
	// если север не ноль
		//проверь св и сз, верни макс, если больше среднего
	//если запад не ноль
		// проверь сз и юз, верни макс, если больше среднего
	return float2(0.);
}

float mlaaTest(float lumaAv, float lumaTested)
{
	if (lumaTested > lumaAv)
		return 1.;
	return 0.;
}


float4 localMlaa(float2 pos)
{
	float2 rcpScreenSize =  1. / screenSize;

	float4 rgbyM = fxaaTexture(pos);
	float3 rgbM = rgbyM.xyz;
	float lumaM = fxaaLuma(rgbM);

	float3 rgbN  = fxaaTextureOffset( 1.,  0., pos, rcpScreenSize).xyz;
	float3 rgbW  = fxaaTextureOffset( 0.,  1., pos, rcpScreenSize).xyz;
	float3 rgbS  = fxaaTextureOffset(-1.,  0., pos, rcpScreenSize).xyz;
	float3 rgbE  = fxaaTextureOffset( 0., -1., pos, rcpScreenSize).xyz;

	float lumaN  = fxaaLuma(rgbN);
	float lumaW  = fxaaLuma(rgbW);
	float lumaS  = fxaaLuma(rgbS);
	float lumaE  = fxaaLuma(rgbE);

	float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));
	float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));
	float range = rangeMax - rangeMin;

	//if (range < LOC_MLAA_RANGE_MIN)
		//return rgbyM;
	if (rangeMax * LOC_MLAA_RANGE_SCALE < rangeMin || rangeMax < LOC_MLAA_RANGE_MIN)
		return rgbyM;
	//else
		//return float4(0., 1., 0., 1.);

	float lumaAv = (lumaN + lumaW + lumaE + lumaS + lumaM) / 5.;
	//if (lumaM > lumaAv)
		//return float4(0., 1., 0., 1.);
	//return float4(1., 0., 0., 1.);

	float2 relPos = float2(0.);
	float2 startDir = getDirection(lumaAv, lumaN, lumaS, lumaW, lumaE);
	if (startDir.x == 0. && startDir.y == 0.)
		return float4(0., 1., 0., 1.);
	float nbuf = 0.;
	float wbuf = 0.;

	//for(int i=0; i < 8; i++){
		//// try to move N/S
		//if (abs(startDir.x) > 0.1){ //calc err
			//nbuf = startDir.x * mlaaTest(lumaAv, fxaaLumaTexOffset(pos, relPos + float2(startDir.x, 0.), rcpScreenSize));
		//}
		//else {
			//nbuf = mlaaTest(lumaAv, fxaaLumaTexOffset(pos, relPos + float2(1., 0.), rcpScreenSize));
			//if (nbuf < 0.1)
				//nbuf = - mlaaTest(lumaAv, fxaaLumaTexOffset(pos, relPos + float2(-1., 0.), rcpScreenSize));
			//startDir.x = nbuf;
		//}
//
		//// try to move S/W
		//if (abs(startDir.y) > 0.1){ //calc err
			//wbuf = startDir.y * mlaaTest(lumaAv, fxaaLumaTexOffset(pos, relPos + float2(startDir.y, 0.), rcpScreenSize));
		//}
		//else {
			//wbuf = mlaaTest(lumaAv, fxaaLumaTexOffset(pos, relPos + float2(1., 0.), rcpScreenSize));
			//if (wbuf < 0.1)
				//wbuf = - mlaaTest(lumaAv, fxaaLumaTexOffset(pos, relPos + float2(-1., 0.), rcpScreenSize));
			//startDir.y = wbuf;
		//}
//
		////// if we didn't move, let's try something else
		////if (abs(nbuf) < 0.1 && abs(wbuf) < 0.1){
			////if (abs(startDir.x * startDir.y) < 0.1){
				////// how the fuck did this happen?
				////return float4(0., 1., 0., 1.); // or find any diagonal way?
			////}
			////else if (abs(startDir.x) > 0.1 && abs(startDir.y) > 0.1){ // let's cut the chase
				////if (abs(mlaaTest(lumaAv, fxaaLumaTexOffset(pos, relPos + startDir, rcpScreenSize))) > 0.1){
					////nbuf = startDir.x;
					////wbuf = startDir.y;
				////}
				////else break;
			////}
		////}
//
		//relPos += float2(nbuf, wbuf);
	//}

	return float4((relPos.x + relPos.y)/8., 0., 0., 1.);
}



////////////////////////////////////////////////////////////////////////////////
////////////////////// Transformed shader //////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// Only used on FXAA Quality.
// This used to be the FXAA_QUALITY_SUBPIX define.
// It is here now to allow easier tuning.
// Choose the amount of sub-pixel aliasing removal.
// This can effect sharpness.
//   1.00 - upper limit (softer)
//   0.75 - default amount of filtering
//   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
//   0.25 - almost off
//   0.00 - completely off
float fxaaQualitySubpix = 0.75;

// Only used on FXAA Quality.
// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
// It is here now to allow easier tuning.
// The minimum amount of local contrast required to apply algorithm.
//   0.333 - too little (faster)
//   0.250 - low quality
//   0.166 - default
//   0.125 - high quality 
//   0.063 - overkill (slower)
float fxaaQualityEdgeThreshold = 0.166;

// Only used on FXAA Quality.
// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
// It is here now to allow easier tuning.
// Trims the algorithm from processing darks.
//   0.0833 - upper limit (default, the start of visible unfiltered edges)
//   0.0625 - high quality (faster)
//   0.0312 - visible limit (slower)
// Special notes when using FXAA_GREEN_AS_LUMA,
//   Likely want to set this to zero.
//   As colors that are mostly not-green
//   will appear very dark in the green channel!
//   Tune by looking at mostly non-green content,
//   then start at zero and increase until aliasing is a problem.
float fxaaQualityEdgeThresholdMin = 0.0625;

// 5 lookups minimum 
// if edge: + 6 lookups
// + 2 lookups * (FXAA_QUALITY_PS - 2) 

//int FXAA_QUALITY_PS = 12;
//float FXAA_QUALITY_P0 = 1.0;
//float FXAA_QUALITY_P1 = 1.5;
//float FXAA_QUALITY_P2 = 2.0;
//float FXAA_QUALITY_P3 = 2.0;
//float FXAA_QUALITY_P4 = 2.0;
//float FXAA_QUALITY_P5 = 2.0;
//float FXAA_QUALITY_P6 = 2.0;
//float FXAA_QUALITY_P7 = 2.0;
//float FXAA_QUALITY_P8 = 2.0;
//float FXAA_QUALITY_P9 = 2.0;
//float FXAA_QUALITY_P10 = 4.0;
//float FXAA_QUALITY_P11 = 8.0;  //final val

//int FXAA_QUALITY_PS = 5;
//float FXAA_QUALITY_P0 = 1.0;
//float FXAA_QUALITY_P1 = 1.5;
//float FXAA_QUALITY_P2 = 2.0;
//float FXAA_QUALITY_P3 = 4.0;
//float FXAA_QUALITY_P4 = 12.0;  //final val
//float FXAA_QUALITY_P5 = 0.0;
//float FXAA_QUALITY_P6 = 0.0;
//float FXAA_QUALITY_P7 = 0.0;
//float FXAA_QUALITY_P8 = 0.0;
//float FXAA_QUALITY_P9 = 0.0;
//float FXAA_QUALITY_P10 = 0.0;
//float FXAA_QUALITY_P11 = 0.0;

int FXAA_QUALITY_PS = 6;
float FXAA_QUALITY_P0 = 1.0;
float FXAA_QUALITY_P1 = 1.5;
float FXAA_QUALITY_P2 = 2.0;
float FXAA_QUALITY_P3 = 2.0;
float FXAA_QUALITY_P4 = 2.0;
float FXAA_QUALITY_P5 = 8.0;  //final val
float FXAA_QUALITY_P6 = 0.0;
float FXAA_QUALITY_P7 = 0.0;
float FXAA_QUALITY_P8 = 0.0;
float FXAA_QUALITY_P9 = 0.0;
float FXAA_QUALITY_P10 = 0.0;
float FXAA_QUALITY_P11 = 0.0;

// This one uses a little bit of depth buffer to highlight lines that are
// close to the camera.
float4 transformedFxaa2(float2 pos)
{
	//return float4( 0., -fxaaDistance(pos)*0.01, 0., 1.);
	// Only used on FXAA Quality.
	// This must be from a constant/uniform.
	// {x_} = 1.0/screenWidthInPixels
	// {_y} = 1.0/screenHeightInPixels
	float2 rcpScreenSize =  1. / screenSize;
	//FxaaTex tex - no need for direct access

	float2 posM;
	posM.x = pos.x;
	posM.y = pos.y;
	float4 rgbyM = fxaaTexture(posM);
	float3 rgbM = rgbyM.xyz;
	float lumaM = fxaaLuma(rgbM);

	float3 rgbN  = fxaaTextureOffset( 1.,  0., posM, rcpScreenSize).xyz;
	float3 rgbW  = fxaaTextureOffset( 0.,  1., posM, rcpScreenSize).xyz;
	float3 rgbS  = fxaaTextureOffset(-1.,  0., posM, rcpScreenSize).xyz;
	float3 rgbE  = fxaaTextureOffset( 0., -1., posM, rcpScreenSize).xyz;

	float lumaN  = fxaaLuma(rgbN);
	float lumaW  = fxaaLuma(rgbW);
	float lumaS  = fxaaLuma(rgbS);
	float lumaE  = fxaaLuma(rgbE);

	float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));
	float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));
	float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
	float range = rangeMax - rangeMin;
	float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);

	if (range < rangeMaxClamped) return rgbyM;

	float3 rgbNW = fxaaTextureOffset( 1.,  1., posM, rcpScreenSize).xyz;
	float3 rgbSW = fxaaTextureOffset(-1.,  1., posM, rcpScreenSize).xyz;
	float3 rgbSE = fxaaTextureOffset(-1., -1., posM, rcpScreenSize).xyz;
	float3 rgbNE = fxaaTextureOffset( 1., -1., posM, rcpScreenSize).xyz;
	float lumaNW = fxaaLuma(rgbNW);
	float lumaSW = fxaaLuma(rgbSW);
	float lumaSE = fxaaLuma(rgbSE);
	float lumaNE = fxaaLuma(rgbNE);

	float lumaNS = lumaN + lumaS;
	float lumaWE = lumaW + lumaE;
	float subpixRcpRange = 1.0/range;
	float subpixNSWE = lumaNS + lumaWE;
	float edgeHorz1 = (-2.0 * lumaM) + lumaNS;
	float edgeVert1 = (-2.0 * lumaM) + lumaWE;

	float lumaNESE = lumaNE + lumaSE;
	float lumaNWNE = lumaNW + lumaNE;
	float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
	float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;

	float lumaNWSW = lumaNW + lumaSW;
	float lumaSWSE = lumaSW + lumaSE;
	float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
	float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
	float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
	float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
	float edgeHorz = abs(edgeHorz3) + edgeHorz4;
	float edgeVert = abs(edgeVert3) + edgeVert4;

	float subpixNWSWNESE = lumaNWSW + lumaNESE;
	float lengthSign = rcpScreenSize.x;
	bool horzSpan = edgeHorz >= edgeVert;
	float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;

	if(!horzSpan) lumaN = lumaW;
	if(!horzSpan) lumaS = lumaE;
	if(horzSpan) lengthSign = rcpScreenSize.y;
	float subpixB = (subpixA * (1.0/12.0)) - lumaM;
	// y not?
	//float subpixB = (subpixA * (1.0/16.0)) - lumaM;

	float gradientN = lumaN - lumaM;
	float gradientS = lumaS - lumaM;
	float lumaNN = lumaN + lumaM;
	float lumaSS = lumaS + lumaM;
	bool pairN = abs(gradientN) >= abs(gradientS);
	float gradient = max(abs(gradientN), abs(gradientS));
	if(pairN) lengthSign = -lengthSign;
	float subpixC = saturate(abs(subpixB) * subpixRcpRange);

	float2 posB;
	posB.x = posM.x;
	posB.y = posM.y;
	float2 offNP;
	offNP.x = (!horzSpan) ? 0.0 : rcpScreenSize.x;
	offNP.y = ( horzSpan) ? 0.0 : rcpScreenSize.y;
	if(!horzSpan) posB.x += lengthSign * 0.5;
	if( horzSpan) posB.y += lengthSign * 0.5;

	float2 posN;
	posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
	posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
	float2 posP;
	posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
	posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
	float subpixD = ((-2.0)*subpixC) + 3.0;
	float lumaEndN = fxaaLumaTex(posN);
	float subpixE = subpixC * subpixC;
	float lumaEndP = fxaaLumaTex(posP);

	if(!pairN) lumaNN = lumaSS;
	float gradientScaled = gradient * 1.0/4.0;
	float lumaMM = lumaM - lumaNN * 0.5;
	float subpixF = subpixD * subpixE;
	bool lumaMLTZero = lumaMM < 0.0;

	lumaEndN -= lumaNN * 0.5;
	lumaEndP -= lumaNN * 0.5;
	bool doneN = abs(lumaEndN) >= gradientScaled;
	bool doneP = abs(lumaEndP) >= gradientScaled;
	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
	if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
	if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;

	if(doneN && doneP) {
		if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
		if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
		if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
		if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
		doneN = abs(lumaEndN) >= gradientScaled;
		doneP = abs(lumaEndP) >= gradientScaled;
		if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
		if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
		if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
		if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;

		if(doneN && doneP && FXAA_QUALITY_PS > 3) {
			if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
			if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
			if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
			if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
			doneN = abs(lumaEndN) >= gradientScaled;
			doneP = abs(lumaEndP) >= gradientScaled;
			if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
			if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
			if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
			if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;

			if(doneN && doneP && FXAA_QUALITY_PS > 4) {
				if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
				if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
				if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
				if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
				doneN = abs(lumaEndN) >= gradientScaled;
				doneP = abs(lumaEndP) >= gradientScaled;
				if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
				if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
				if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
				if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
				if(doneN && doneP && FXAA_QUALITY_PS > 5) {
					if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
					if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
					if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
					if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
					doneN = abs(lumaEndN) >= gradientScaled;
					doneP = abs(lumaEndP) >= gradientScaled;
					if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
					if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
					if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
					if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
					if(doneN && doneP && FXAA_QUALITY_PS > 6) {
						if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
						if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
						if(doneN && doneP && FXAA_QUALITY_PS > 7) {
							if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
							if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
							if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
							if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
							doneN = abs(lumaEndN) >= gradientScaled;
							doneP = abs(lumaEndP) >= gradientScaled;
							if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
							if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
							if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
							if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;

	if(doneN && doneP && FXAA_QUALITY_PS > 8) {
		if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
		if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
		if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
		if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
		doneN = abs(lumaEndN) >= gradientScaled;
		doneP = abs(lumaEndP) >= gradientScaled;
		if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
		if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
		if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
		if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
		if(doneN && doneP && FXAA_QUALITY_PS > 9) {
			if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
			if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
			if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
			if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
			doneN = abs(lumaEndN) >= gradientScaled;
			doneP = abs(lumaEndP) >= gradientScaled;
			if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
			if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
			if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
			if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
			if(doneN && doneP && FXAA_QUALITY_PS > 10) {
				if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
				if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
				if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
				if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
				doneN = abs(lumaEndN) >= gradientScaled;
				doneP = abs(lumaEndP) >= gradientScaled;
				if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
				if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
				if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
				if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
				if(doneN && doneP && FXAA_QUALITY_PS > 11) {
					if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
					if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
					if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
					if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
					doneN = abs(lumaEndN) >= gradientScaled;
					doneP = abs(lumaEndP) >= gradientScaled;
					if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
					if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
					if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
					if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
					//if(doneN && doneP && FXAA_QUALITY_PS > 12) {
						//if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
						//if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
						//if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						//if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						//doneN = abs(lumaEndN) >= gradientScaled;
						//doneP = abs(lumaEndP) >= gradientScaled;
						//if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
						//if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
						//if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
						//if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
					//}
				}
			}
		}
	}
						}
					}
				}
			}
		}
	}

	float dstN = posM.x - posN.x;
	float dstP = posP.x - posM.x;
	if(!horzSpan) dstN = posM.y - posN.y;
	if(!horzSpan) dstP = posP.y - posM.y;

	bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
	float spanLength = (dstP + dstN);
	bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
	float spanLengthRcp = 1.0/spanLength;

	bool directionN = dstN < dstP;
	float dstMin = min(dstN, dstP);
	bool goodSpan = directionN ? goodSpanN : goodSpanP;
	float subpixG = subpixF * subpixF;
	float pixelOffset = (dstMin * (-spanLengthRcp)) + 0.5;
	float subpixH = subpixG * fxaaQualitySubpix;

	float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
	float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
	float2 toPosM = float2(posM);
	if(!horzSpan){
		posM.x += pixelOffsetSubpix * lengthSign;
		toPosM.x += lengthSign;
	}
	if( horzSpan){
		posM.y += pixelOffsetSubpix * lengthSign;
		toPosM.y += lengthSign;
	}

	// positive if initial position is closer
	//float dist = fxaaDepthTexture(toPosM) - fxaaDepthTexture(pos);
	float dist = fxaaDistance(toPosM) - fxaaDistance(pos);
	float absDist = saturate(abs(dist));

	//if (pos.x != posM.x) return float4(0., 1., 0., 1.);
	//if (pos.y != posM.y) return float4(0., 0., 1., 1.);

	float3 destinationColor = fxaaTexture(toPosM).xyz;
	float3 changedColor = fxaaTexture(posM).xyz;
	float3 inititalColor = rgbM;

	//if (dist > 0.001){
		//if (shit.x < shit2.x) shit.x += (shit2.x - shit.x)*0.4;
		//if (shit.y < shit2.y) shit.y += (shit2.y - shit.y)*0.4;
		//if (shit.z < shit2.z) shit.z += (shit2.z - shit.z)*0.4;

		//if (shit.x > shit2.x) shit.x -= (shit2.x - shit.x)*0.4;
		//if (shit.y > shit2.y) shit.y -= (shit2.y - shit.y)*0.4;
		//if (shit.z > shit2.z) shit.z -= (shit2.z - shit.z)*0.4;
	//}
	float corrDistance = absDist;
	if (dist > 0.){
		if(fxaaLuma(destinationColor) > fxaaLuma(inititalColor)){
			changedColor += corrDistance * (destinationColor - changedColor) / 20.;
		}
		//return float4(0., absDist, 0., 1.);
	} else if (dist < 0.){
		if(fxaaLuma(destinationColor) < fxaaLuma(inititalColor)){
			changedColor += corrDistance * (inititalColor - changedColor) / 3.;
		}
		//return float4(absDist, 0., 0., 1.);
	}
	//if (shit.x != shit2.x || 
		//shit.y != shit2.y || 
		//shit.z != shit2.z) return float4(0., 1., 0., 1.);
	//if (abs(posM.x - pos.x) > rcpScreenSize.x || 
		//abs(posM.y - pos.y) > rcpScreenSize.y) return float4(0., 0., 1., 1.);

	return float4(changedColor, rgbyM.w);
}


float4 transformedFxaa1(float2 pos)
{
	// Only used on FXAA Quality.
	// This must be from a constant/uniform.
	// {x_} = 1.0/screenWidthInPixels
	// {_y} = 1.0/screenHeightInPixels
	float2 rcpScreenSize =  1. / screenSize;
	//FxaaTex tex - no need for direct access

	float2 posM;
	posM.x = pos.x;
	posM.y = pos.y;
	float4 rgbyM = fxaaTexture(posM);
	float3 rgbM = rgbyM.xyz;
	float lumaM = fxaaLuma(rgbM);

	float3 rgbN  = fxaaTextureOffset( 1.,  0., posM, rcpScreenSize).xyz;
	float3 rgbW  = fxaaTextureOffset( 0.,  1., posM, rcpScreenSize).xyz;
	float3 rgbS  = fxaaTextureOffset(-1.,  0., posM, rcpScreenSize).xyz;
	float3 rgbE  = fxaaTextureOffset( 0., -1., posM, rcpScreenSize).xyz;

	float lumaN  = fxaaLuma(rgbN);
	float lumaW  = fxaaLuma(rgbW);
	float lumaS  = fxaaLuma(rgbS);
	float lumaE  = fxaaLuma(rgbE);

	float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));
	float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));
	float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
	float range = rangeMax - rangeMin;
	float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);

	if (range < rangeMaxClamped) return rgbyM;

	float3 rgbNW = fxaaTextureOffset( 1.,  1., posM, rcpScreenSize).xyz;
	float3 rgbSW = fxaaTextureOffset(-1.,  1., posM, rcpScreenSize).xyz;
	float3 rgbSE = fxaaTextureOffset(-1., -1., posM, rcpScreenSize).xyz;
	float3 rgbNE = fxaaTextureOffset( 1., -1., posM, rcpScreenSize).xyz;
	float lumaNW = fxaaLuma(rgbNW);
	float lumaSW = fxaaLuma(rgbSW);
	float lumaSE = fxaaLuma(rgbSE);
	float lumaNE = fxaaLuma(rgbNE);

	float lumaNS = lumaN + lumaS;
	float lumaWE = lumaW + lumaE;
	float subpixRcpRange = 1.0/range;
	float subpixNSWE = lumaNS + lumaWE;
	float edgeHorz1 = (-2.0 * lumaM) + lumaNS;
	float edgeVert1 = (-2.0 * lumaM) + lumaWE;

	float lumaNESE = lumaNE + lumaSE;
	float lumaNWNE = lumaNW + lumaNE;
	float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
	float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;

	float lumaNWSW = lumaNW + lumaSW;
	float lumaSWSE = lumaSW + lumaSE;
	float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
	float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
	float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
	float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
	float edgeHorz = abs(edgeHorz3) + edgeHorz4;
	float edgeVert = abs(edgeVert3) + edgeVert4;

	float subpixNWSWNESE = lumaNWSW + lumaNESE;
	float lengthSign = rcpScreenSize.x;
	bool horzSpan = edgeHorz >= edgeVert;
	float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;

	if(!horzSpan) lumaN = lumaW;
	if(!horzSpan) lumaS = lumaE;
	if(horzSpan) lengthSign = rcpScreenSize.y;
	float subpixB = (subpixA * (1.0/12.0)) - lumaM;
	// y not?
	//float subpixB = (subpixA * (1.0/16.0)) - lumaM;

	float gradientN = lumaN - lumaM;
	float gradientS = lumaS - lumaM;
	float lumaNN = lumaN + lumaM;
	float lumaSS = lumaS + lumaM;
	bool pairN = abs(gradientN) >= abs(gradientS);
	float gradient = max(abs(gradientN), abs(gradientS));
	if(pairN) lengthSign = -lengthSign;
	float subpixC = saturate(abs(subpixB) * subpixRcpRange);

	float2 posB;
	posB.x = posM.x;
	posB.y = posM.y;
	float2 offNP;
	offNP.x = (!horzSpan) ? 0.0 : rcpScreenSize.x;
	offNP.y = ( horzSpan) ? 0.0 : rcpScreenSize.y;
	if(!horzSpan) posB.x += lengthSign * 0.5;
	if( horzSpan) posB.y += lengthSign * 0.5;

	float2 posN;
	posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
	posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
	float2 posP;
	posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
	posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
	float subpixD = ((-2.0)*subpixC) + 3.0;
	float lumaEndN = fxaaLumaTex(posN);
	float subpixE = subpixC * subpixC;
	float lumaEndP = fxaaLumaTex(posP);

	if(!pairN) lumaNN = lumaSS;
	float gradientScaled = gradient * 1.0/4.0;
	float lumaMM = lumaM - lumaNN * 0.5;
	float subpixF = subpixD * subpixE;
	bool lumaMLTZero = lumaMM < 0.0;

	lumaEndN -= lumaNN * 0.5;
	lumaEndP -= lumaNN * 0.5;
	bool doneN = abs(lumaEndN) >= gradientScaled;
	bool doneP = abs(lumaEndP) >= gradientScaled;
	if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
	if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
	if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
	if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;

	if(doneN && doneP) {
		if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
		if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
		if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
		if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
		doneN = abs(lumaEndN) >= gradientScaled;
		doneP = abs(lumaEndP) >= gradientScaled;
		if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
		if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
		if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
		if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;

		if(doneN && doneP && FXAA_QUALITY_PS > 3) {
			if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
			if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
			if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
			if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
			doneN = abs(lumaEndN) >= gradientScaled;
			doneP = abs(lumaEndP) >= gradientScaled;
			if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
			if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
			if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
			if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;

			if(doneN && doneP && FXAA_QUALITY_PS > 4) {
				if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
				if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
				if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
				if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
				doneN = abs(lumaEndN) >= gradientScaled;
				doneP = abs(lumaEndP) >= gradientScaled;
				if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
				if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
				if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
				if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
				if(doneN && doneP && FXAA_QUALITY_PS > 5) {
					if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
					if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
					if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
					if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
					doneN = abs(lumaEndN) >= gradientScaled;
					doneP = abs(lumaEndP) >= gradientScaled;
					if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
					if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
					if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
					if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
					if(doneN && doneP && FXAA_QUALITY_PS > 6) {
						if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
						if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
						if(doneN && doneP && FXAA_QUALITY_PS > 7) {
							if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
							if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
							if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
							if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
							doneN = abs(lumaEndN) >= gradientScaled;
							doneP = abs(lumaEndP) >= gradientScaled;
							if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
							if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
							if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
							if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;

	if(doneN && doneP && FXAA_QUALITY_PS > 8) {
		if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
		if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
		if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
		if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
		doneN = abs(lumaEndN) >= gradientScaled;
		doneP = abs(lumaEndP) >= gradientScaled;
		if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
		if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
		if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
		if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
		if(doneN && doneP && FXAA_QUALITY_PS > 9) {
			if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
			if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
			if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
			if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
			doneN = abs(lumaEndN) >= gradientScaled;
			doneP = abs(lumaEndP) >= gradientScaled;
			if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
			if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
			if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
			if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
			if(doneN && doneP && FXAA_QUALITY_PS > 10) {
				if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
				if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
				if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
				if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
				doneN = abs(lumaEndN) >= gradientScaled;
				doneP = abs(lumaEndP) >= gradientScaled;
				if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
				if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
				if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
				if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
				if(doneN && doneP && FXAA_QUALITY_PS > 11) {
					if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
					if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
					if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
					if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
					doneN = abs(lumaEndN) >= gradientScaled;
					doneP = abs(lumaEndP) >= gradientScaled;
					if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
					if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
					if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
					if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
					//if(doneN && doneP && FXAA_QUALITY_PS > 12) {
						//if(!doneN) lumaEndN = fxaaLumaTex(posN.xy);
						//if(!doneP) lumaEndP = fxaaLumaTex(posP.xy);
						//if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						//if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						//doneN = abs(lumaEndN) >= gradientScaled;
						//doneP = abs(lumaEndP) >= gradientScaled;
						//if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
						//if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
						//if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
						//if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
					//}
				}
			}
		}
	}
						}
					}
				}
			}
		}
	}

	float dstN = posM.x - posN.x;
	float dstP = posP.x - posM.x;
	if(!horzSpan) dstN = posM.y - posN.y;
	if(!horzSpan) dstP = posP.y - posM.y;

	bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
	float spanLength = (dstP + dstN);
	bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
	float spanLengthRcp = 1.0/spanLength;

	bool directionN = dstN < dstP;
	float dstMin = min(dstN, dstP);
	bool goodSpan = directionN ? goodSpanN : goodSpanP;
	float subpixG = subpixF * subpixF;
	float pixelOffset = (dstMin * (-spanLengthRcp)) + 0.5;
	float subpixH = subpixG * fxaaQualitySubpix;

	float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
	float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
	float2 toPosM = float2(posM);
	if(!horzSpan){
		posM.x += pixelOffsetSubpix * lengthSign;
		toPosM.x += lengthSign;
	}
	if( horzSpan){
		posM.y += pixelOffsetSubpix * lengthSign;
		toPosM.y += lengthSign;
	}

	float dist = abs(fxaaDepthTexture(toPosM) - fxaaDepthTexture(pos));
 	
	float3 shit = fxaaTexture(posM).xyz;
 	float3 shit2 = rgbM;
 	
	if (dist > 0.001){
		if (shit.x < shit2.x) shit.x += (shit2.x - shit.x)*0.4;
		if (shit.y < shit2.y) shit.y += (shit2.y - shit.y)*0.4;
		if (shit.z < shit2.z) shit.z += (shit2.z - shit.z)*0.4;
 	
		if (shit.x > shit2.x) shit.x -= (shit2.x - shit.x)*0.4;
		if (shit.y > shit2.y) shit.y -= (shit2.y - shit.y)*0.4;
		if (shit.z > shit2.z) shit.z -= (shit2.z - shit.z)*0.4;
	}

	return float4(shit, rgbyM.w);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////// Original shader /////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// @c http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf
// The minimum amount of local contrast required to apply algorithm.
// 1/3 – too little
// 1/4 – low quality
// 1/8 – high quality
// 1/16 – overkill
float FXAA_EDGE_THRESHOLD = 1./16.;
// Trims the algorithm from processing darks.
// 1/32 – visible limit
// 1/16 – high quality
// 1/12 – upper limit (start of visible unfiltered edges)
float FXAA_EDGE_THRESHOLD_MIN = 1./32.;
// Toggle subpix filtering.
// 0 – turn off
// 1 – turn on
// 2 – turn on force full (ignore FXAA_SUBPIX_TRIM and CAP)
int FXAA_SUBPIX = 1;
// Controls removal of sub-pixel aliasing.
// 1/2 – low removal
// 1/3 – medium removal
// 1/4 – default removal
// 1/8 – high removal
// 0 – complete removal
float FXAA_SUBPIX_TRIM = 1./3.;
// Insures fine detail is not completely removed.
// This partly overrides FXAA_SUBPIX_TRIM.
// 3/4 – default amount of filtering
// 7/8 – high amount of filtering
// 1 – no capping of filtering
float FXAA_SUBPIX_CAP = 3./4.;
// Da fuck?
float FXAA_SUBPIX_TRIM_SCALE = (1.0/(1.0 - FXAA_SUBPIX_TRIM));
// How much to accelerate search using anisotropic filtering.
// 1 – no acceleration
// 2 – skip by 2 pixels
// 3 – skip by 3 pixels
// 4 – skip by 4 pixels (hard upper limit)
int FXAA_SEARCH_ACCELERATION = 1;
//Controls the maximum number of search steps.
//Multiply by FXAA_SEARCH_ACCELERATION for filtering radius.
int FXAA_SEARCH_STEPS = 4;
// Controls when to stop searching.
// 1/4 – seems best quality wise
float FXAA_SEARCH_THRESHOLD = 1./4.;

float4 originalFxaa(float2 textureCoords)
{ // UNFINISHED!
	float2 invScreenSize = 1. / screenSize; // size of 1 pixel
	float3 rgbN = fxaaTextureOffset( 1.,  0., textureCoords, invScreenSize).xyz;
	float3 rgbW = fxaaTextureOffset( 0.,  1., textureCoords, invScreenSize).xyz;
	float3 rgbM = fxaaTextureOffset( 0.,  0., textureCoords, invScreenSize).xyz;
	float3 rgbE = fxaaTextureOffset( 0., -1., textureCoords, invScreenSize).xyz;
	float3 rgbS = fxaaTextureOffset(-1.,  0., textureCoords, invScreenSize).xyz;
	float lumaN = fxaaLuma(rgbN);
	float lumaW = fxaaLuma(rgbW);
	float lumaM = fxaaLuma(rgbM);
	float lumaE = fxaaLuma(rgbE);
	float lumaS = fxaaLuma(rgbS);
	float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
	float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
	float range = rangeMax - rangeMin;
	if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {
		return float4(rgbM, tex2D(screenSampler, textureCoords + invScreenSize).w);
	}
	// detected edges:
	// return float4(1., 0., 0., 1.);

	float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;
	float rangeL = abs(lumaL - lumaM);
	float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;
	blendL = min(FXAA_SUBPIX_CAP, blendL);

	float3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;
	// ...
	float3 rgbNW = fxaaTextureOffset(  1.,  1., textureCoords, invScreenSize).xyz;
	float3 rgbNE = fxaaTextureOffset(  1., -1., textureCoords, invScreenSize).xyz;
	float3 rgbSW = fxaaTextureOffset( -1.,  1., textureCoords, invScreenSize).xyz;
	float3 rgbSE = fxaaTextureOffset( -1., -1., textureCoords, invScreenSize).xyz;
	rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);
	rgbL *= float3(1.0/9.0);
	float lumaNW = fxaaLuma(rgbNW);
	float lumaSW = fxaaLuma(rgbSW);
	float lumaNE = fxaaLuma(rgbNE);
	float lumaSE = fxaaLuma(rgbSE);

	// hoizontal/vertical edge detection
	float edgeVert =
		abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +
		abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +
		abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));
	float edgeHorz =
		abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +
		abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +
		abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));
	bool horzSpan = edgeHorz >= edgeVert;
	//if (horzSpan){
		//return float4(1., 1., 0., 1.); //yellow
	//}
	//else {
		//return float4(0., 0., 1., 1.); //blue
	//}

	bool doneN = false;
	bool doneP = false;
	float2 offNP = invScreenSize * float2(float(FXAA_SEARCH_ACCELERATION));
	float gradientN = lumaN * 0.1;
	float lumaEndN = lumaN;
	float lumaEndP = lumaN;
	float2 posN = float2(0.);
	float2 posP = float2(0.);
	for(int i = 0; i < 4; i++) {
		if (!doneN){
			lumaEndN = lumaN;
			//lumaEndN = fxaaLuma(fxaaTextureOffset(
				//posN.x, posN.y, textureCoords, invScreenSize).xyz);
		}
		if(!doneP){
			lumaEndP = lumaN;
			//lumaEndP = fxaaLuma(fxaaTextureOffset(
				//posP.x, posP.y, textureCoords, invScreenSize).xyz);
		}
		doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);
		doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);
		if(doneN && doneP){
			break;
		}

		if(!doneN){
			posN -= offNP;
		}
		if(!doneP){
			posP += offNP;
		}
	}

	return float4(0., 0., 0., 1.);
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////// Old shader ////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

float FXAA_SPAN_MAX = 4.0;
float FXAA_REDUCE_MUL = 1.0/8.0;
float FXAA_REDUCE_MIN = 1.0/128.0;

float4 oldFxaa(float2 textureCoords)
{
	float4 resColor;
	resColor.w = 1.0;

	float2 texCoords = textureCoords;
	float2 invScreenSize = 1. / screenSize;
	
	//float FXAA_SPAN_MAX = 4.0;
	//float FXAA_REDUCE_MUL = 1.0/8.0;
	//float FXAA_REDUCE_MIN = 1.0/128.0;

	float3 rgbNW=tex2D(screenSampler,texCoords+(float2(-1.0,-1.0) * invScreenSize)).xyz;
	float3 rgbNE=tex2D(screenSampler,texCoords+(float2(1.0,-1.0) * invScreenSize)).xyz;
	float3 rgbSW=tex2D(screenSampler,texCoords+(float2(-1.0,1.0) * invScreenSize)).xyz;
	float3 rgbSE=tex2D(screenSampler,texCoords+(float2(1.0,1.0) * invScreenSize)).xyz;
	float3 rgbM=tex2D(screenSampler,texCoords).xyz;

	resColor.w = tex2D(screenSampler,texCoords).w;

	// Calculating luminocity of the points
	float3 luma=float3(0.299, 0.587, 0.114);
	// or: (original paper) apply optimization
	//float3 luma = float3(1., (0.587/0.299), 0.);
	//rgb.y * (0.587/0.299) + rgb.x;
	// or: (unreal) apply optimization
	// float3 luma = float3(0., 1., 0.);
	float lumaNW = dot(rgbNW, luma);
	float lumaNE = dot(rgbNE, luma);
	float lumaSW = dot(rgbSW, luma);
	float lumaSE = dot(rgbSE, luma);
	float lumaM  = dot(rgbM,  luma);
	
	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
	
	float2 dir;
	dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
	dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));
	
	float dirReduce = max(
		(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),
		FXAA_REDUCE_MIN);
	  
	float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);
	
	dir = min(float2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
		  max(float2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
		  dir * rcpDirMin)) / screenSize;
		
	float3 rgbA = (1.0/2.0) * (
		tex2D(screenSampler, texCoords.xy + dir * (1.0/3.0 - 0.5)).xyz +
		tex2D(screenSampler, texCoords.xy + dir * (2.0/3.0 - 0.5)).xyz);
	float3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
		tex2D(screenSampler, texCoords.xy + dir * (0.0/3.0 - 0.5)).xyz +
		tex2D(screenSampler, texCoords.xy + dir * (3.0/3.0 - 0.5)).xyz);
	float lumaB = dot(rgbB, luma);

	if((lumaB < lumaMin) || (lumaB > lumaMax)){
		resColor.xyz=rgbA;
	}
	else {
		resColor.xyz=rgbB;
	}

	return resColor;
}

technique fxaa : POST_EFFECT {
	pass applyFXAA{
		/*		
		ZENABLE = false;
		BLENDENABLE = TRUE;
		SRCBLEND = ONE;
		DESTBLEND = INVSRCALPHA;
		*/
		VertexShader = compile vs_fxaa_shading();
		PixelShader = compile fs_fxaa_shading();
	};
};


