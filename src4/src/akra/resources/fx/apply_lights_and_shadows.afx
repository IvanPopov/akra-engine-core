provide akra.system;

include "lightingFunctions.afx";

foreign int nOmniShadows;
foreign int nOmni;
foreign int nProjectShadows;
foreign int nProject;
foreign int nSun;
foreign int nSunShadows;

texture envTex0 : ENVMAP;

sampler2D envSampler0 : ENV_SAMPLER_0 = sampler_state
{
	Texture = <envTex0>;
	MipFilter = LINEAR;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
};

sampler project_shadow_sampler[nProjectShadows] : PROJECT_SHADOW_SAMPLER;
sampler omni_shadow_sampler[nOmniShadows * 6] : OMNI_SHADOW_SAMPLER;
sampler sun_shadow_sampler[nSunShadows] : SUN_SHADOW_SAMPLER;

light_omni_shadows points_omni_shadows[nOmniShadows];
light_omni points_omni[nOmni];
light_project_shadows points_project_shadows[nProjectShadows];
light_project points_project[nProject];
light_sun points_sun[nSun];
light_sun_shadows points_sun_shadows[nSunShadows];

shared float4 result_color = float4(0.);
shared pixel_data pixelData;

float4 apply_light_omni() : COLOR {
	for(int i = 0; i < nOmni; i++){
		result_color += applyBaseLightParams(pixelData, points_omni[i].lightData);
	}
	
	//result_color = float4(pixelData.shininess);
	return returnColor(result_color);
}

float4 apply_light_project() : COLOR{
	for(int i = 0; i < nProject; i++){
		float lightAttenuation = calcProjectLightInfluence(points_project[i].shadow_matrix, pixelData.position);
		if(lightAttenuation >= 0.) {
			result_color += applyBaseLightParams(pixelData, points_project[i].lightData) * lightAttenuation;
		}
	}

	return returnColor(result_color);
}

float4 apply_light_omni_shadow() : COLOR{
	for(int i = 0; i < nOmniShadows; i++){
		float4 tmpColor = applyBaseLightParams(pixelData, points_omni_shadows[i].lightData);
		float shadowMultiplier = 1.;

		bool isOk = true;
		for(int j = 0; j < 6; j++){
			float2 shadowTexCoords;
			float realDepth;
			if(isOk){
				if(isUnderShadowInfluence(points_omni_shadows[i].toLightSpace[j], 
										points_omni_shadows[i].optimized_projection_matrix[j],
										pixelData.position,
										shadowTexCoords, realDepth)){

					shadowMultiplier = calculateShadowMultiplier(omni_shadow_sampler[i * 6 + j], shadowTexCoords,
																 points_omni_shadows[i].optimized_projection_matrix[j], realDepth);
					isOk = false;
					break;
				}
			}
			else {
				break;
			}
		}

		result_color += tmpColor * shadowMultiplier;
	}

	return returnColor(result_color);
}

float4 apply_light_project_shadows() : COLOR{
	for(int i = 0; i < nProjectShadows; i++){
		float lightAttenuation = calcProjectLightInfluence(points_project_shadows[i].real_projection_matrix * points_project_shadows[i].toLightSpace, pixelData.position);

		if(lightAttenuation >= 0.){
			float4 tmpColor = applyBaseLightParams(pixelData,points_project_shadows[i].lightData) * lightAttenuation;
			float shadowMultiplier = 1.;
			float2 shadowTexCoords;
			float realDepth;

			if(isUnderShadowInfluence(points_project_shadows[i].toLightSpace, 
									points_project_shadows[i].optimized_projection_matrix,
									pixelData.position,
									shadowTexCoords, realDepth)) {
				shadowMultiplier = calculateShadowMultiplier(project_shadow_sampler[i], shadowTexCoords,
																points_project_shadows[i].optimized_projection_matrix, realDepth);
			}

			result_color += tmpColor * shadowMultiplier;
		}
	}

	return returnColor(result_color);
}

bool isNeedLightFromSun(pixel_data pixelData){
	for(int j = 0; j < nSun; j++) {
		if(pixelData.id == points_sun[j].lightData.skyDomeId){
			return false;
		}
	}

	for(int j = 0; j < nSunShadows; j++) {
		if(pixelData.id == points_sun_shadows[j].lightData.skyDomeId){
			return false;
		}
	}

	return true;
}

float4 apply_sun_light() : COLOR {
	float3 worldPos = float4(invView * float4(pixelData.position.xyz, 1.)).xyz;

	if(isNeedLightFromSun(pixelData)) {
		for(int i = 0; i < nSun; i++) {
			float4 color = applyBaseLightParamsSun(pixelData, points_sun[i].lightData, worldPos);

			if(isPrepareAll){
				float fFogValue = ComputeVolumetricFog(worldPos - camPos);
				color = float4(lerp(points_sun[i].lightData.ground0, color.rgb, fFogValue), 1.);
			}
			
			result_color += color;
		}
	}

	return returnColor(result_color);
}

float4 apply_sun_light_shadows() : COLOR {
	float3 worldPos = float4(invView * float4(pixelData.position.xyz, 1.)).xyz;

	if(isNeedLightFromSun(pixelData)) {
		for(int i = 0; i < nSunShadows; i++){
			float4 color = applyBaseLightParamsSun(pixelData, points_sun_shadows[i].lightData, worldPos);
			float shadowMultiplier = 1.;
			float2 shadowTexCoords;
			float realDepth;

			if(isUnderShadowInfluence(points_sun_shadows[i].toLightSpace,
									points_sun_shadows[i].optimized_projection_matrix,
									pixelData.position,
									shadowTexCoords, realDepth)){

				shadowMultiplier = calculateSunShadowMultiplierUpgraded(sun_shadow_sampler[i], shadowTexCoords,
																points_sun_shadows[i].optimized_projection_matrix, realDepth);
			}
			color = color * shadowMultiplier;

			if(isPrepareAll){
				float fFogValue = ComputeVolumetricFog(worldPos - camPos);
				color = float4(lerp(points_sun_shadows[i].lightData.ground0, color.rgb, fFogValue), 1.);
			}

			result_color += color;
		}
	}

	return returnColor(result_color);
};

float4 apply_pbs_reflection(): COLOR {
	float4 reflection = calulatePBSReflection(pixelData.position, pixelData.normal, 
			pixelData.specular.xyz, pixelData.shininess, envSampler0);
	// lowering reflection brightness if we have a strong lighting already
	//float4 color = resultAFXColor;
	reflection *= float4(1.) - result_color;
	result_color += reflection;
	return result_color;
};

technique omniLighting{
	pass applyOmniLighting{
		if(nOmni > 0){
			PixelShader = compile apply_light_omni();
		}
	};
};

technique projectLighting{
	pass applyProjectLighting{
		if(nProject > 0){
			PixelShader = compile apply_light_project();
		}
	};
};

technique omniShadowsLighting{
	pass applyOmniShadowsLighting{
		if(nOmniShadows > 0){
			PixelShader = compile apply_light_omni_shadow();
		}
	};   
};

technique projectShadowsLighting{
	pass applyProjectShadowsLighting{
		if(nProjectShadows > 0){
			PixelShader = compile apply_light_project_shadows();
		}
	};   
};

technique sunLighting{
	pass applySunLighting{
		if(nSun > 0){
			PixelShader = compile apply_sun_light();
		}
	}
};

technique sunShadowsLighting{
	pass applySunShadowsLighting{
		if(nSunShadows > 0){
			PixelShader = compile apply_sun_light_shadows();
		}
	}
};

technique pbsReflection{
	pass applyPbsReflection{
		if(isUsedPBSSimple){
			PixelShader = compile apply_pbs_reflection();
		}
	}
};