float4 floatToFloat4(float value){
  float data = value;
  float4 result = float4(0.);

  if(data == 0.){
    float signedZeroTest = 1./value;
    if(signedZeroTest < 0.){
      result.x = 128.;
    }
    return result/255.;
  }

  if(data < 0.){
    result.x=128.;
    data = -data;
  }

  float power=0.;

  for(int i=0;i>-1;i++){
    if(data>=2.){
      data = data/2.;
      power++;
    }
    else if(data<1.){
      data = data*2.;
      power--;
      if(power == -126.){
        break;
      }
    }
    else{
      break;
    }
  }

  if(power == -126. && data < 1.){
    power = 0.;
  }
  else{
    power = power+127.;
    data = data - 1.;
  }

  result.x+=floor(power/2.);
  result.y = mod(power,2.)*128.;

  data *= 128.;

  result.y += floor(data);

  data -= floor(data);
  data *= 256.;

  result.z += floor(data);

  data -= floor(data);
  data *= 256.;

  result.w += floor(data);

  return result/255.;
}

float3 floatToFloat3(float value){
  float data = value;
  float3 result = float3(0.);

  if(data == 0.){
    float signedZeroTest = 1./value;
    if(signedZeroTest < 0.){
      result.x = 128.;
    }
    return result/255.;
  }

  if(data < 0.){
    result.x=128.;
    data = -data;
  }

  float power=0.;

  for(int i=0;i>-1;i++){
    if(data>=2.){
      data = data/2.;
      power++;
    }
    else if(data<1.){
      data = data*2.;
      power--;
      if(power == -62.){
        break;
      }
    }
    else{
      break;
    }
  }

  if(power == -62. && data < 1.){
    power = 0.;
  }
  else{
    power = power+63.;
    data = data - 1.;
  }

  result.x+=power;

  data *= 256.;

  result.y = floor(data);

  data -= floor(data);
  data *= 256.;

  result.z = floor(data);
  //return result;
  return result/255.;
}

float float4ToFloat(float4 value){
  float4 data = floor(value*255.);

  if(data.x == 127. || data.x == 255.){
    data.x--;
    //обходим исключительный случай float (+/- Infinity и Nan), то есть максимальное значение показателя экспоненты
  }

  if(data == float4(0.)){
    return 0.;
  }
  float sign = 1.;
  float power;
  float mantissa;

  if(data.x >= 128.){
    sign = -1.;
    data.x -= 128.;
  }

  power = data.x*2.;

  if(data.y >= 128.){
    data.y -= 128.;
    power+=1.;
  }

  //конструирование мантиссы идет в обратном порядке (от младших разрядов к старшим) так удобней;
  mantissa = data.w;
  mantissa = mantissa/256.;

  mantissa += data.z;
  mantissa = mantissa/256.;

  mantissa += data.y;
  mantissa = mantissa/128.;

  if(power == 0.){
    power -= 126.;
  }
  else{
    mantissa += 1.;
    power -= 127.;
  }
  return sign * mantissa * pow(2.,power);
}

float float3ToFloat(float3 value){
  float3 data = floor(value*255.);

  if(data.x == 127. || data.x == 255.){
    data.x--;
    //обходим исключительный случай float (+/- Infinity и Nan), то есть максимальное значение показателя экспоненты
  }

//  if(data.y == 127. || data.y == 255.){
//    data.y--;
//    //обходим исключительный случай float (+/- Infinity и Nan), то есть максимальное значение показателя экспоненты
//  }
//
//  if(data.z == 127. || data.z == 255.){
//    data.z--;
//    //обходим исключительный случай float (+/- Infinity и Nan), то есть максимальное значение показателя экспоненты
//  }

  if(data == float3(0.)){
    return 0.;
  }
  float sign = 1.;
  float power;
  float mantissa;

  if(data.x >= 128.){
    sign = -1.;
    data.x -= 128.;
  }

  power = data.x;

  //конструирование мантиссы идет в обратном порядке (от младших разрядов к старшим) так удобней;

  mantissa += data.z;
  mantissa = mantissa/256.;

  mantissa += data.y;
  mantissa = mantissa/256.;

  if(power == 0.){
    power -= 62.;
  }
  else{
    mantissa += 1.;
    power -= 63.;
  }
  return sign * mantissa * pow(2.,power);
}