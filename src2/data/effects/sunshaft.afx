provide akra.system;

float2 screenTextureRatio : INPUT_TEXTURE_RATIO;
float2 aspectRatio : SCREEN_ASPECT_RATIO = float2(1.,1.);
texture tex0 : INPUT_TEXTURE;
texture tex1 : SUNSHAFT_INFO;
texture tex2 : DEPTH_TEXTURE;

sampler screenSampler : INPUT_SAMPLER = sampler_state
{
	Texture = <tex0>;
};

sampler sunshaftInfoSampler : SUNSHAFT_SAMPLER = sampler_state
{
	Texture = <tex1>;
};

sampler depthSampler : DEPTH_TEXTURE = sampler_state
{
	Texture = <tex2>;
};

struct VS_OUT{
	float4 position : POSITION;
	float2 screenPosition : SCREEN_POSITION;
	float2 textureCoords : TEXCOORD0;
};

VS_OUT vs_sunshaft_shading(float2 pos: POSITION){
	VS_OUT Out;

	Out.position = float4(pos,0.,1.);
	Out.screenPosition = pos;
	//Out.textureCoords = float2(texCoodrX,texCoordY);
	Out.textureCoords = (pos + 1.)/2. * screenTextureRatio;
	
	return Out;
};

int samples : SUNSHAFT_SAMPLES = 100;
int skyDomeId : SUNSHAFT_SKYDOME_ID = 0;
float sunshaftAngle : SUNSHAFT_ANGLE = 1.;
float sunshaftIntensity : SUNSHAFT_INTENSITY = 0.3;
float2 sunshaftPos : SUNSHAFT_POSITION = float2(0.5,0.5);
float3 sunshaftColor : SUNSHAFT_COLOR = float3(1.);
float sunshaftDepth : SUNSHAFT_DEPTH = 0.;
float sunshaftSunSize : SUNSHAFT_SUN_SIZE = 0.1;
float sunshaftDecay : SUNSHAFT_DECAY = 0.25;

float4 fs_sunshaft_shading(VS_OUT IN) : COLOR {
	float4 baseImage = tex2D(screenSampler, IN.textureCoords);

	if(sunshaftAngle<0.) {
		return baseImage;
	}

	float baseDepth = tex2D(depthSampler, IN.textureCoords).r;
	float2 sunShaftPosInTexture = sunshaftPos * screenTextureRatio;
	float2 fromSunToPixel = (IN.textureCoords-sunShaftPosInTexture)*aspectRatio;

	if(length(fromSunToPixel)<sunshaftSunSize && baseDepth >= sunshaftDepth) {
		return float4(sunshaftColor,1.);
	}

	float sunshaftStep = 1./float(samples);
	for(int i=0;i<100;i++) {
		if(i>samples) {
			break;
		}
		else {
			float approach = pow(float(i)*sunshaftStep,1./sunshaftDecay);
			float2 tPos = sunShaftPosInTexture + (IN.textureCoords-sunShaftPosInTexture)*approach;
			float4 deferredData = tex2D(sunshaftInfoSampler,tPos);
			if( tex2D(depthSampler,tPos).r >= sunshaftDepth+(baseDepth-sunshaftDepth)*approach ) {
				baseImage += float4(sunshaftColor,1.)*sunshaftAngle*sunshaftIntensity*sunshaftStep*(1.-approach);
			}
		}
	}
	// baseImage += float4(0.6);
	return baseImage;
};	

technique sunshaft : POST_EFFECT {
	pass pass1{
		VertexShader = compile vs_sunshaft_shading();
		PixelShader = compile fs_sunshaft_shading();
	};
};


