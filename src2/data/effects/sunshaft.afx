provide akra.system;

float2 screenTextureRatio : INPUT_TEXTURE_RATIO;
texture tex0 : INPUT_TEXTURE;
texture tex1 : SUNSHAFT_INFO;

sampler screenSampler : INPUT_SAMPLER = sampler_state
{
	Texture = <tex0>;
};

sampler sunshaftInfoSampler : SUNSHAFT_SAMPLER = sampler_state
{
	Texture = <tex1>;
};

struct VS_OUT{
	float4 position : POSITION;
	float2 screenPosition : SCREEN_POSITION;
	float2 textureCoords : TEXCOORD0;
};

VS_OUT vs_sunshaft_shading(float2 pos: POSITION){
	VS_OUT Out;

	Out.position = float4(pos,0.,1.);
	Out.screenPosition = pos;
	//Out.textureCoords = float2(texCoodrX,texCoordY);
	Out.textureCoords = (pos + 1.)/2. * screenTextureRatio;
	
	return Out;
};

int samples : SUNSHAFT_SAMPLES = 100;
int skyDomeId : SUNSHAFT_SKYDOME_ID = 0;
float sunshaftIntensity : SUNSHAFT_INTENSITY = 0.3;
float2 sunshaftPos : SUNSHAFT_POSITION = float2(0.5,0.5);

float4 fs_sunshaft_shading(VS_OUT IN) : COLOR {
	float2 sunShaftPosInTexture = sunshaftPos * screenTextureRatio;
	if(length(IN.textureCoords - sunShaftPosInTexture)<0.01) {
		return float4(1.,0.,0.,1.);
	}

	float sunshaftStep = 1./float(samples);

	float4 baseImage = tex2D(screenSampler, IN.textureCoords);
	for(int i=0;i<100;i++) {
		if(i>samples) {
			break;
		}
		else {
			float2 tPos = sunShaftPosInTexture + (IN.textureCoords-sunShaftPosInTexture)*float(i)*sunshaftStep;
			float4 deferredData = tex2D(sunshaftInfoSampler,tPos);
			if(deferredData.w == 0.) {
				baseImage += tex2D(screenSampler, tPos)*sunshaftStep*sunshaftIntensity * length(IN.textureCoords-tPos)/length(IN.textureCoords-sunShaftPosInTexture);
			}
		}
	}
	// baseImage += float4(0.6);
	return baseImage;
};	

technique sunshaft : POST_EFFECT {
	pass pass1{
		VertexShader = compile vs_sunshaft_shading();
		PixelShader = compile fs_sunshaft_shading();
	};
};


