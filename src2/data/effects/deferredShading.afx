provide akra.system;

include "floatSpecialFunctions.afx";

texture tex0 : DEFERRED_TEXTURE0;
texture tex1 : DEFERRED_TEXTURE1;
texture tex2 : DEFERRED_TEXTURE2;
texture tex3 : DEFERRED_TEXTURE3;
texture tex4 : SCENE_DEPTH_TEXTURE;

sampler deferredTexture0 : SAMPLER_TEXTURE0 = sampler_state
{
	Texture = <tex0>;
	MinFilter = NEAREST;
	MagFilter = NEAREST;
};

sampler deferredTexture1 : SAMPLER_TEXTURE1 = sampler_state
{
	Texture = <tex1>;
	MinFilter = NEAREST;
	MagFilter = NEAREST;
};

sampler deferredTexture2 : SAMPLER_TEXTURE2 = sampler_state
{
	Texture = <tex2>;
	MinFilter = NEAREST;
	MagFilter = NEAREST;
};

sampler deferredTexture3 : SAMPLER_TEXTURE3 = sampler_state
{
	Texture = <tex3>;
	MinFilter = NEAREST;
	MagFilter = NEAREST;
};

sampler sceneDepthTexture : SAMPLER_SCENE_DEPTH = sampler_state
{
	TEXTURE = <tex4>;
	MinFilter = LINEAR;
	MagFilter = LINEAR;
};

struct pixel_data{
    float4 diffuse  : DIFFUSE;
    float4 ambient  : AMBIENT;
    float4 specular : SPECULAR;
    float3 position : POSITION; //in camera space
    float3 normal   : NORMAL;
    float  shininess: SHININESS;
    int    id 		: RENDER_OBJECT_ID;
};

float2 screenTextureRatio : SCREEN_TEXTURE_RATIO;

struct VS_IN{
	float2 position : POSITION;
};

struct VS_OUT{
	float4 position : POSITION;
	float2 screenPosition : SCREEN_POSITION;
	float2 textureCoords : TEXCOORD0;
};;

VS_OUT vs_deferred_shading(VS_IN IN){
	VS_OUT Out;

	//float texCoodrX = (IN.position.x + 1.)/2. * screenTextureRatio.x;
	//float texCoordY = 1. - (1. - (IN.position.y + 1.)/2.) * screenTextureRatio.y;
	//float texCoordY = (IN.position.y + 1.)/2. * screenTextureRatio.y;

	Out.position = float4(IN.position,0.,1.);
	Out.screenPosition = IN.position;
	//Out.textureCoords = float2(texCoodrX,texCoordY);
    Out.textureCoords = (IN.position + 1.)/2. * screenTextureRatio;
	
	return Out;
};

float4x4 projMat : PROJ_MATRIX;

float3 unproj(float4x4 projMat,float3 screenCoords){
	
	//mat4[i] - i-й столбец матрицы 
	//не строка, а именно столбец
  
    float z = -projMat[3][2]/(projMat[2][2] + screenCoords.z);
    float y = -(screenCoords.y * z + projMat[2][1] * z)/projMat[1][1];
    float x = -(screenCoords.x * z + projMat[2][0] * z)/projMat[0][0];
  
    return float3(x,y,z);
};

shared pixel_data pixelData;
shared float4 result_color;

bool normalFix;

float4 fs_deferred_shading(VS_OUT IN) : COLOR{
	float2 textureCoords = IN.textureCoords;

    float depth = tex2D(sceneDepthTexture,textureCoords).x*2.-1.;
    float4 data0 = tex2D(deferredTexture0,textureCoords);
    float4 data1 = tex2D(deferredTexture1,textureCoords);

    pixelData.position = unproj(projMat, float3(IN.screenPosition.xy,depth));
    pixelData.id = int(data0.w);

    if(data0.w==0.){
        discard;
    }

    float4 emissive = float4(floatToFloat3(data0.x),1.);

    float3 temp = floatToFloat3(data0.y);
    if(normalFix){
    	pixelData.normal = float3((temp.xyz * 2. - 1.) * 0.95);
    	pixelData.shininess = data1.z * 255.;
    }
    else {
    	temp.xy = (temp.xy*2. - 1.) * 0.95;//fix me
    	pixelData.normal = normalize(float3(temp.xy, sqrt(1. - clamp(dot(temp.xy,temp.xy),0.,1.))));
    	pixelData.shininess = temp.z * 255.;
    }    

    pixelData.diffuse = float4(floatToFloat3(data0.z),1.);
    pixelData.ambient = float4(floatToFloat3(data1.x),1.);
    pixelData.specular = float4(floatToFloat3(data1.y),1.);

    result_color = emissive;

    return result_color;
};	

technique deferredShading{
	pass applyDeferredShading{
		VertexShader = compile vs_deferred_shading();
		PixelShader = compile fs_deferred_shading();
	};
};