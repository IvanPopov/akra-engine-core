provide akra.system;

struct pos_tex{
    float3 pos:POSITION;
    float3 norm: NORMAL;
    float2 texcoord:TEXCOORD;
};

struct VS_IN{
    pos_tex data[]:INDEX0;
};

struct VS_IN_ROAM{
    pos_tex data[][]:INDEX0;
};

struct VS_OUT{
    float4 pos:POSITION;
    float3 norm: NORMAL;
    float3 vert:VERTEX;
    float2 texcoord : TEXCOORD;
    float3 edgeTest : EDGE_TEST;
};

float4x4 model_mat:MODEL_MATRIX;
float4x4 view_mat:VIEW_MATRIX;
float4x4 proj_mat:PROJ_MATRIX;

VS_OUT vs_terrain(VS_IN IN) {
    VS_OUT Out;

    float4 pos = float4(IN.data.pos, 1.);

    float4 vertex = view_mat * model_mat * pos;

    Out.vert = vertex.xyz;
    Out.pos = proj_mat * vertex;
    Out.norm = normalize((view_mat * model_mat * float4(IN.data.norm.xyz, 0.)).xyz);
    Out.texcoord = float2(IN.data.texcoord.x,IN.data.texcoord.y);

    if(mod(float(@(IN.data)),3.) == 0.){
        Out.edgeTest = float3(1.,0.,0.);
    }
    else if(mod(float(@(IN.data)),3.) == 1.){
        Out.edgeTest = float3(0.,1.,0.);
    }
    else {
        Out.edgeTest = float3(0.,0.,1.);
    }

    return Out;
}

VS_OUT vs_terrain_roam(VS_IN_ROAM IN) {
    VS_OUT Out;

    float4 pos = float4(IN.data.pos, 1.);

    float4 vertex = view_mat * model_mat * pos;

    Out.vert = vertex.xyz;
    Out.pos = proj_mat * vertex;
    Out.norm = normalize((view_mat * model_mat * float4(IN.data.norm.xyz, 0.)).xyz);
    Out.texcoord = IN.data.texcoord;

    if(mod(float(@@(IN.data)),3.) == 0.){
        Out.edgeTest = float3(1.,0.,0.);
    }
    else if(mod(float(@@(IN.data)),3.) == 1.){
        Out.edgeTest = float3(0.,1.,0.);
    }
    else {
        Out.edgeTest = float3(0.,0.,1.);
    }

    return Out;
}

struct base_material{
    float4 diffuse:DIFFUSE;
    float4 ambient:AMBIENT;
    float4 emissive:EMISSIVE;
    float4 specular:SPECULAR;
    float shininess:SHININESS;
};;

shared base_material Fragment_material;
shared float3 Normal;

texture tex0:TEXTURE0;
texture tex1:TEXTURE1;
texture tex2:TEXTURE2;
texture tex3:TEXTURE3;
texture tex4:TEXTURE4;
texture tex5:TEXTURE5;
texture tex6:TEXTURE6;

sampler textureTerrain0:S_TERRAIN0 = sampler_state
{
    Texture = <tex0>;
};
sampler textureTerrain1:S_TERRAIN1 = sampler_state
{
    Texture = <tex1>;
};
sampler textureTerrain2:S_TERRAIN2 = sampler_state
{
    Texture = <tex2>;
};
sampler textureTerrain3:S_TERRAIN3 = sampler_state
{
    Texture = <tex3>;
};
sampler textureTerrain4:S_TERRAIN4 = sampler_state
{
    Texture = <tex4>;
};
sampler textureTerrain5:S_TERRAIN5 = sampler_state
{
    Texture = <tex5>;
};
sampler ptNormal:S_NORMAL = sampler_state
{
    Texture = <tex6>;
};

bool textureTerrainIsLoaded0;
bool textureTerrainIsLoaded1;
bool textureTerrainIsLoaded2;
bool textureTerrainIsLoaded3;
bool textureTerrainIsLoaded4;
bool textureTerrainIsLoaded5;

float2 textureCoord0;
float2 textureCoord1;
float2 textureCoord2;
float2 textureCoord3;
float2 textureCoord4;
float2 textureCoord5;


float2 cameraCoordTerrain : CAMERA_COORD;
bool isDebug, isRealNormal, isWithBalckSectors;

void fs_terrain(VS_OUT IN){
    float4 color;
    float2 new_texcoord;
    float3 normal;

    

    float4 mainColor = tex2D(textureTerrain0, IN.texcoord);
    bool isMainColored = (mainColor.xyz != float3(0.));
    bool isNeedColored = true;
   
    new_texcoord = (IN.texcoord-textureCoord5)*32.;
    //All(lessThanEqual((mainColor - color).xyz, float3(0.1)))
    if(textureTerrainIsLoaded5 && (new_texcoord.x>=0. && new_texcoord.x<1. && new_texcoord.y>=0. && new_texcoord.y<1.0))
    {
        color = tex2D(textureTerrain5, new_texcoord);//; + float4(0., 0.1, 0.1, 1.);
        
        if(color.xyz == float3(0.) && isMainColored)
        {
            isNeedColored = true;
        }
        else
        {
            isNeedColored = false;
        }
    }
    
    if(isNeedColored)
    {
        new_texcoord =(IN.texcoord-textureCoord4)*16.;

        if(textureTerrainIsLoaded4 && (new_texcoord.x>=0. && new_texcoord.x<1.&& new_texcoord.y>=0. && new_texcoord.y<1.0))
        {
            color = tex2D(textureTerrain4, new_texcoord);//; + float4(0.1, 0.1, 0., 1.);
            
            if(color.xyz == float3(0.) && isMainColored)
            {
                isNeedColored = true;
            }
            else
            {
                isNeedColored = false;
            }
        }
    }

    if(isNeedColored)
    {
        new_texcoord = (IN.texcoord-textureCoord3)*8.;

        if(textureTerrainIsLoaded3 && (new_texcoord.x>=0. && new_texcoord.x<1. && new_texcoord.y>=0. && new_texcoord.y<1.0))
        {
            color = tex2D(textureTerrain3, new_texcoord);//; + float4(0.1, 0., 0.1, 1.);

           if(color.xyz == float3(0.) && isMainColored)
            {
                isNeedColored = true;
            }
            else
            {
                isNeedColored = false;
            }
        }
    }

    if(isNeedColored)
    {
        new_texcoord = (IN.texcoord-textureCoord2)*4.;

        if(textureTerrainIsLoaded2 && (new_texcoord.x>=0. && new_texcoord.x<1. && new_texcoord.y>=0. && new_texcoord.y<1.0))
        {
            color = tex2D(textureTerrain2, new_texcoord);//; + float4(0., 0., 0.1, 1.);

            if(color.xyz == float3(0.) && isMainColored)
            {
                isNeedColored = true;
            }
            else
            {
                isNeedColored = false;
            }
        }
    }
    
    if(isNeedColored)
    {
        new_texcoord = (IN.texcoord-textureCoord1)*2.;

        if(textureTerrainIsLoaded1 && (new_texcoord.x >= 0. && new_texcoord.x < 1. && new_texcoord.y >= 0. && new_texcoord.y < 1.))
        {
            color = tex2D(textureTerrain1, new_texcoord);// + float4(0.1, 0., 0., 1.);

            if(color.xyz == float3(0.) && isMainColored)
            {
                isNeedColored = true;
            }
            else
            {
                isNeedColored = false;
                //color = float4(1., 0., 0., 1.);
//                if(all(lessThan(color.xyz, float3(0.1))) ){
//                    color = mainColor;
//                }
            }
        }
    }

    if(isNeedColored)
    {
        color = mainColor;
        //color = float4(0., 1., 0., 1.);
    }

    normal = tex2D(ptNormal, float2(IN.texcoord.x, IN.texcoord.y)).rgb;
    //normal = float3(0.5, 0.5, 1.);

    normal.xy = normal.xy * 2. - 1.;
    normal = (view_mat * model_mat * float4(normal, 0.)).xyz;//float4(normalize(normal), 0.)).xyz);
    Normal = normalize(normal);

    // Normal = IN.norm;

    if(isDebug){
        if(isRealNormal){
            Fragment_material.emissive = float4(tex2D(ptNormal, float2(IN.texcoord.x, IN.texcoord.y)).rgb, 0.);
            Fragment_material.diffuse = float4(0.);
        }
        else {
            Fragment_material.emissive = float4((Normal.xyz + 1.)/2., 0.);
            Fragment_material.diffuse = float4(0.);
        }
    }
    else {

        if(IN.edgeTest.x * IN.edgeTest.y * IN.edgeTest.z < 0.001)
        {
           Fragment_material.emissive = float4(0.5, 0.5, 0.5, 1.);
        }
        else {
           Fragment_material.emissive = float4(0.);
        }
        
        Fragment_material.emissive = float4(0.);
        Fragment_material.diffuse = color;
    }
    
    Fragment_material.ambient = float4(0.);
    Fragment_material.shininess = 0.;
}

technique terrain{
    pass p0 {
        if(engine.terrain.isROAM){
            VertexShader = compile vs_terrain_roam();
        }
        else {
            VertexShader = compile vs_terrain();
        }
        
        PixelShader = compile fs_terrain();
    }
}