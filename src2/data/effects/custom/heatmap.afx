provide akra.custom;
include "../floatSpecialFunctions.afx";

texture tex0 : INPUT_TEXTURE;
texture tex1 : BACKGROUND_MAP;

sampler screenSampler : INPUT_SAMPLER = sampler_state
{
	Texture = <tex0>;
};

sampler bgSampler = sampler_state
{
	Texture = <tex1>;
};


struct VS_OUT{
	float4 position : POSITION;
	float2 screenPosition : SCREEN_POSITION;
	float2 textureCoords : TEXCOORD0;
};;


float2 screenTextureRatio : INPUT_TEXTURE_RATIO;
float2 screenSize : INPUT_TEXTURE_SIZE;

VS_OUT vs_fxaa_shading(float2 pos: POSITION){
	VS_OUT Out;

	Out.position = float4(pos,0.,1.);
    Out.screenPosition = pos;
	//Out.textureCoords = float2(texCoodrX,texCoordY);
    Out.textureCoords = (pos + 1.)/2. * screenTextureRatio;
	
	return Out;
};



VS_OUT vs_heatmap(float2 pos: POSITION) 
{
	VS_OUT Out;

	Out.position = float4(pos,0.,1.);
    Out.screenPosition = pos;
    Out.textureCoords = (pos + 1.)/2. * screenTextureRatio;
	
	return Out;
};

float3 HSVtoRGB(float3 HSV)
{
    float3 RGB = float3(0.);
    float C = HSV.z * HSV.y;
    float H = HSV.x * 6.;
    float X = C * (1. - abs(mod(H, 2.) - 1.));
    if (HSV.y != 0.)
    {
        float I = floor(H);
        if (I == 0.) { RGB = float3(C, X, 0.); }
        else if (I == 1.) { RGB = float3(X, C, 0.); }
        else if (I == 2.) { RGB = float3(0., C, X); }
        else if (I == 3.) { RGB = float3(0., X, C); }
        else if (I == 4.) { RGB = float3(X, 0., C); }
        else { RGB = float3(C, 0., X); }
    }
    float M = HSV.z - C;
    return RGB + M;
}

float3 RGBtoHSV(float3 RGB)
{
    float3 HSV = float3(0.);
    float M = min(RGB.r, min(RGB.g, RGB.b));
    HSV.z = max(RGB.r, max(RGB.g, RGB.b));
    float C = HSV.z - M;
    if (C != 0.)
    {
        HSV.y = C / HSV.z;
        float3 D = (((HSV.z - RGB) / 6.) + (C / 2.)) / C;
        if (RGB.r == HSV.z)
            HSV.x = D.b - D.g;
        else if (RGB.g == HSV.z)
            HSV.x = (1.0/3.0) + D.r - D.b;
        else if (RGB.b == HSV.z)
            HSV.x = (2.0/3.0) + D.g - D.r;
        if ( HSV.x < 0.0 ) { HSV.x += 1.0; }
        if ( HSV.x > 1.0 ) { HSV.x -= 1.0; }
    }
    return HSV;
}

float hMult: HUE_MULTIPLIER = 1.0;
float sMult: SATURATION_MULTIPLIER = 1.0;
float vMult: VALUE_MULTIPLIER = 1.0;
bool enabled: HEATMAP_ENABLED = true;

float4 fs_heatmap(VS_OUT IN) : COLOR 
{
	float2 textureCoords = IN.textureCoords;

	float4 fg = tex2D(screenSampler, textureCoords);
    float4 rgba = fg;

    float3 hsv = RGBtoHSV(rgba.rgb);
    hsv.x *= hMult;
    hsv.y *= sMult;
    hsv.z *= vMult;
    rgba = float4(HSVtoRGB(hsv), 1.);

    if (!enabled) {
    	return rgba;
    }

    float4 bg = tex2D(bgSampler, textureCoords);
	float4 colors[3];
	colors[0] = fg;//float4(0., 0., 1., 1.);
	colors[1] = bg;//float4(1., 1., 0., 1.);
	colors[2] = bg;//float4(1., 0., 0., 1.);

	//colors[2] = float4(floatToFloat3(data0.z), 1.);
	//colors[2] = float4(float3((floatToFloat3(data0.y).xyz * 2. - 1.) * 0.95), 1.);
	float lum = (rgba.r + rgba.g + rgba.b) / 3.;
	float4 thermal;

	if (lum < 0.5) {
		thermal = mix(colors[0], colors[1], (lum - float(0.) * 0.5) / 0.5);	
	}
	else {
		thermal = mix(colors[1], colors[2], (lum - float(1.) * 0.5) / 0.5);	
	}

	return thermal;
};	


technique heatmap : POST_EFFECT {	
	pass heatmap 
	{
		VertexShader = compile vs_heatmap();
		PixelShader = compile fs_heatmap();
	};
};