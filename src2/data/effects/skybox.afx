provide akra.system;

texture tex0 : INPUT_TEXTURE;
texture skyBox : SKYBOX_TEXTURE;

sampler sceneTexture : INPUT_SAMPLER = sampler_state
{
	Texture = <tex0>;
//	MinFilter = LINEAR;
//	MagFilter = LINEAR;
};

texture tex1 : DEFERRED_TEXTURE0;

sampler deferredTexture0 : SAMPLER_TEXTURE0 = sampler_state
{
	Texture = <tex1>;
//	MinFilter = NEAREST;
//	MagFilter = NEAREST;
};

//texture tex2 : SKYBOX_TEXTURE;
//texture tex2 : TEXTURE2;

//struct sky_fix {
//	samplerCUBE skyboxSampler : SAMPLER_SKYBOX;
//};;

samplerCUBE skyboxSampler : SAMPLER_SKYBOX = sampler_state
{
    Texture = <skyBox>;
};


//sky_fix sky_container : SKY_FIX;
float2 screenTextureRatio : SCREEN_TEXTURE_RATIO;
float2 inputTextureRatio : INPUT_TEXTURE_RATIO;

struct VS_IN{
	float2 position : POSITION;
};

struct VS_OUT{
	float4 position : POSITION;
	float2 texCoords : TEXCOORD0;
	float2 texCoordsDeferred : TEXCOORD1;
	float3 texCoordsSkybox : TEXCOORD2;
};;

float4x4 projMat : PROJ_MATRIX;
float4x4 invView : INV_VIEW_CAMERA_MAT;
float3 cameraPos : CAMERA_POSITION;

float3 unproj(float4x4 projMat,float3 screenCoords){
	
	//mat4[i] - i-й столбец матрицы 
	//не строка, а именно столбец
  
    float z = -projMat[3][2]/(projMat[2][2] + screenCoords.z);
    float y = -(screenCoords.y * z + projMat[2][1] * z)/projMat[1][1];
    float x = -(screenCoords.x * z + projMat[2][0] * z)/projMat[0][0];
  
    return float3(x,y,z);
};

VS_OUT vs_skybox(VS_IN IN){
	VS_OUT Out;

	float3 cubeVertex = float3(IN.position,1.);
    float3 cubeVertexInCameraSpace = unproj(projMat,cubeVertex);
    float3 cubeVertexInRealSpace = (invView * float4(cubeVertexInCameraSpace,1.)).xyz;
    float3 skyboxVector = cubeVertexInRealSpace - cameraPos;

	Out.position = float4(IN.position,0.,1.);
	Out.texCoords = (IN.position+1.)/2. * inputTextureRatio;
    Out.texCoordsDeferred = (IN.position + 1.)/2. * screenTextureRatio;
    Out.texCoordsSkybox = skyboxVector;
	
	return Out;
};

float4 fs_skybox(VS_OUT IN) : COLOR{
	float2 textureCoords = IN.texCoords;

    float4 deferredData = tex2D(deferredTexture0,IN.texCoordsDeferred);

    if(deferredData.w != 0.){
        return tex2D(sceneTexture,textureCoords);
    }
    else {
    	return texCUBE(skyboxSampler,IN.texCoordsSkybox);
    }
};	

technique skybox{
	pass skybox{
		VertexShader = compile vs_skybox();
		PixelShader = compile fs_skybox();
	};
};