provide akra.system;

texture tex0 : INPUT_TEXTURE;
texture skyBox : SKYBOX_TEXTURE;

sampler sceneTexture : INPUT_SAMPLER = sampler_state
{
	Texture = <tex0>;
//	MinFilter = LINEAR;
//	MagFilter = LINEAR;
};

texture tex1 : DEFERRED_TEXTURE0;

sampler deferredTexture0 : SAMPLER_TEXTURE0 = sampler_state
{
	Texture = <tex1>;
//	MinFilter = NEAREST;
//	MagFilter = NEAREST;
};

//texture tex2 : SKYBOX_TEXTURE;
//texture tex2 : TEXTURE2;

//struct sky_fix {
//	samplerCUBE skyboxSampler : SAMPLER_SKYBOX;
//};;

samplerCUBE skyboxSampler : SAMPLER_SKYBOX = sampler_state
{
    Texture = <skyBox>;
};


//sky_fix sky_container : SKY_FIX;
float2 screenTextureRatio : SCREEN_TEXTURE_RATIO;
float2 inputTextureRatio : INPUT_TEXTURE_RATIO;

struct VS_IN{
	float2 position : POSITION;
};

struct VS_OUT{
	float4 position : POSITION;
	float2 texCoords : TEXCOORD0;
	float2 texCoordsDeferred : TEXCOORD1;
	float3 texCoordsSkybox : TEXCOORD2;
};;

float4x4 projMat : PROJ_MATRIX;
float4x4 invView : INV_VIEW_CAMERA_MAT;
float3 cameraPos : CAMERA_POSITION;

float3 unproj(float4x4 projMat,float3 screenCoords){
	
	//mat4[i] - i-й столбец матрицы 
	//не строка, а именно столбец
  
    float z = -projMat[3][2]/(projMat[2][2] + screenCoords.z);
    float y = -(screenCoords.y * z + projMat[2][1] * z)/projMat[1][1];
    float x = -(screenCoords.x * z + projMat[2][0] * z)/projMat[0][0];
  
    return float3(x,y,z);
};

VS_OUT vs_skybox(VS_IN IN){
	VS_OUT Out;

	float3 cubeVertex = float3(IN.position,1.);
    float3 cubeVertexInCameraSpace = unproj(projMat,cubeVertex);
    float3 cubeVertexInRealSpace = (invView * float4(cubeVertexInCameraSpace,1.)).xyz;
    float3 skyboxVector = float3(1., 2., 1.) * (cubeVertexInRealSpace - cameraPos);

	Out.position = float4(IN.position,0.,1.);
	Out.texCoords = (IN.position+1.)/2. * inputTextureRatio;
    Out.texCoordsDeferred = (IN.position + 1.)/2. * screenTextureRatio;
    Out.texCoordsSkybox = skyboxVector;
	
	return Out;
};

float4 fs_skybox(VS_OUT IN) : COLOR{
	float2 textureCoords = IN.texCoords;

    float4 deferredData = tex2D(deferredTexture0,IN.texCoordsDeferred);

    if(deferredData.w != 0.){
        return tex2D(sceneTexture,textureCoords);
    }
    else {
    	return texCUBE(skyboxSampler,IN.texCoordsSkybox);
    }
};	

technique skybox{
	pass skybox{
		VertexShader = compile vs_skybox();
		PixelShader = compile fs_skybox();
	};
};


int outline_target: OUTLINE_TARGET;
int outline_soid: OUTLINE_SOID;
int outline_reid: OUTLINE_REID;

VS_OUT vs_outline(VS_IN IN) 
{
	VS_OUT Out;

	Out.position = float4(IN.position, 0., 1.);
	Out.texCoords = (IN.position+1.) / 2. * inputTextureRatio;
    Out.texCoordsDeferred = (IN.position + 1.) / 2. * screenTextureRatio;
	
	return Out;
};

float4 fs_outline(VS_OUT IN) : COLOR 
{
	float2 textureCoords = IN.texCoords;

    float4 deferredData = tex2D(deferredTexture0, IN.texCoordsDeferred);
    
   // int rid = int(deferredData.w);
    //int reid = int(floor((rid - 1.) / 1024.) + .5);
    //int soid = int((float(rid) - 1.) - (1024. * float(reid)));
    int rid = int(deferredData.w);
    int soid_begin  = 1024 * outline_soid + 1;
    int soid_end 	= soid_begin + 1024;

    if (outline_target == 0 || (rid < soid_begin || rid >= soid_end)) 
    {
    	return resultAFXColor;
    }


    for (int y = -3; y < 3; y ++)
	{
		float fy = IN.texCoordsDeferred.y + float(y) / 1024.;
		rid = int(tex2D(deferredTexture0, float2(IN.texCoordsDeferred.x, fy)).w);
		if (rid < soid_begin || rid >= soid_end)
	    {
	    	return float4(1.);
	    }
	}

	for (int x = -3; x < 3; x ++)
	{
		float fx = IN.texCoordsDeferred.x + float(x) / 1024.;
		rid = int(tex2D(deferredTexture0, float2(fx, IN.texCoordsDeferred.y)).w);
		if (rid < soid_begin || rid >= soid_end) 
	    {
	    	return float4(1.);
	    }
	}

    return resultAFXColor / 2.;
};	

technique outline 
{
	pass outline 
	{
		VertexShader = compile vs_outline();
		PixelShader = compile fs_outline();
	};
};

