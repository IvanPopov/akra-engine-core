provide akra.system;

struct VS_IN_2{
    float3 tex_coord0: TEXCOORD0;
    float3 tex_coord1: TEXCOORD1;
    float3 tex_coord2: TEXCOORD2;
    float3 tex_coord3: TEXCOORD3;
    float3 tex_coord4: TEXCOORD4;
    float3 tex_coord5: TEXCOORD5;
    float3 tex_coord6: TEXCOORD6;
    float3 tex_coord7: TEXCOORD7;
    float3 tex_coord8: TEXCOORD8;
    float3 tex_coord9: TEXCOORD9;
    float3 tex_coord10: TEXCOORD10;
    float3 tex_coord11: TEXCOORD11;
    float3 tex_coord12: TEXCOORD12;
    float3 tex_coord13: TEXCOORD13;
    float3 tex_coord14: TEXCOORD14;
    float3 tex_coord15: TEXCOORD15;
};

struct VS_OUT_2{
    float3 vert:VERTEX;
    float3 norm:NORMAL;
//    float4x4 normal_mat:NORMAL_MAT;
    float3 tc_diffuse: TEXCOORD0;
    float3 tc_ambient: TEXCOORD1;
    float3 tc_specular: TEXCOORD2;
    float3 tc_emissive: TEXCOORD3;
    float3 tc_normal: TEXCOORD4;
};

texture tex0:TEXTURE0;
texture tex1:TEXTURE1;
texture tex2:TEXTURE2;
texture tex3:TEXTURE3;
texture tex4:TEXTURE4;

sampler sampler_diffuse:S_DIFFUSE  = sampler_state
{
    Texture = <tex0>;
};
sampler sampler_ambient:S_AMBIENT  = sampler_state
{
    Texture = <tex1>;
};
sampler sampler_specular:S_SPECULAR  = sampler_state
{
    Texture = <tex2>;
};
sampler sampler_emissive:S_EMISSIVE  = sampler_state
{
    Texture = <tex3>;
};
sampler sampler_normal:S_NORMAL  = sampler_state
{
    Texture = <tex4>;
};

struct base_material{
    float4 diffuse:DIFFUSE;
    float4 ambient:AMBIENT;
    float4 emissive:EMISSIVE;
    float4 specular:SPECULAR;
    float shininess:SHININESS;
};;

shared base_material Fragment_material;
shared float3 Normal;


struct Material {
    float4 ambient:AMBIENT;
    float4 diffuse:DIFFUSE;
    float4 specular:SPECULAR;
    float4 emissive:EMISSIVE;
    float shininess:SHININESS;
};

VS_OUT_2 vs_mesh_texture(VS_IN_2 IN) {
    VS_OUT_2 Out;

    Out.tc_diffuse = IN.tex_coord0;
    Out.tc_ambient = IN.tex_coord1;
    Out.tc_specular = IN.tex_coord2;
    Out.tc_emissive = IN.tex_coord3;
    Out.tc_normal = IN.tex_coord4;

	return Out;
}

Material defaultMaterial:MATERIAL;

float4x4 model_mat:MODEL_MATRIX;
float4x4 view_mat:VIEW_MATRIX;

bool useNormal;
bool normalFix;

/*float4 fs_consistent_colors(VS_OUT_2 IN): COLOR {
    return tex2D(sampler_diffuse, float2(IN.as.xy));
}*/

void fs_mesh_texture_pass_1(VS_OUT_2 IN){
    float3 texNormal = tex2D(sampler_normal, float2(IN.tc_normal.xy)).xyz;
    float4 norm;

    if(texNormal == float3(0.) || !useNormal){
        norm = float4(IN.norm.xyz, 0.);
    }
    else {
        
        float3 normal = normalize(IN.norm.xyz);
        //float3 binormal = normalize(cross(float3(dFdx(IN.tc_normal.x), dFdy(IN.tc_normal.x), -length(normal.xy)), normal));

        float3 tangent = float3(dFdx(IN.tc_normal.x), dFdy(IN.tc_normal.x), 0.);
        tangent.z = -dot(tangent.xy,normal.xy)/normal.z;
        tangent = normalize(tangent);

        float3 binormal = cross(tangent, normal);

        /*float3 binormal = float3(dFdx(IN.tc_normal.y), dFdy(IN.tc_normal.y), 0.);
        binormal.z = -dot(binormal.xy,normal.xy)/normal.z;
        binormal = normalize(binormal);*/
            
        /*if (binormal == float3(0.)) {
            binormal = normalize(cross(float3(0., 1., 0.), normal));
        }*/

        //формируем матрицу трансформации
        float3x3 m3fTransform;
        m3fTransform[0] = tangent;
        m3fTransform[1] = binormal;
        m3fTransform[2] = normal;


        //texNormal.z *= 2.;
        texNormal.xy = (texNormal.xy - 0.5) * 2.;

        texNormal = normalize(texNormal);

        norm = float4(m3fTransform * texNormal, 0.);
    }

    Normal = normalize(norm.xyz);
//    Normal = normalize(float3(normalize(IN.norm) + tex2D(sampler_normal, float2(IN.tc_normal.xy)).xyz));
    Fragment_material.emissive = clamp(defaultMaterial.emissive + tex2D(sampler_emissive, float2(IN.tc_emissive.xy)), 0., 1.);
    Fragment_material.diffuse = clamp(defaultMaterial.diffuse + tex2D(sampler_diffuse, float2(IN.tc_diffuse.xy)), 0., 1.);
    
    if(!normalFix){
        Fragment_material.shininess = defaultMaterial.shininess;
    }

    //Fragment_material.emissive = float4(IN.tc_emissive.xy, 0., 1.);
}

void fs_mesh_texture_pass_2(VS_OUT_2 IN){
    Fragment_material.specular = clamp(defaultMaterial.specular + tex2D(sampler_specular, float2(IN.tc_specular.xy)), 0., 1.);
    Fragment_material.ambient = clamp(defaultMaterial.ambient + tex2D(sampler_ambient, float2(IN.tc_ambient.xy)), 0., 1.);

    if(normalFix){
        Fragment_material.shininess = defaultMaterial.shininess;
    }
}

void fs_mesh_texture_full(VS_OUT_2 IN){
    float3 texNormal = tex2D(sampler_normal, float2(IN.tc_normal.xy)).xyz;
    float4 norm;

    if(texNormal == float3(0.) || !useNormal){
        norm = float4(IN.norm.xyz, 0.);
    }
    else {
        
        float3 normal = normalize(IN.norm.xyz);
        //float3 binormal = normalize(cross(float3(dFdx(IN.tc_normal.x), dFdy(IN.tc_normal.x), -length(normal.xy)), normal));

        float3 tangent = float3(dFdx(IN.tc_normal.x), dFdy(IN.tc_normal.x), 0.);
        tangent.z = -dot(tangent.xy,normal.xy)/normal.z;
        tangent = normalize(tangent);

        float3 binormal = cross(tangent, normal);

        /*float3 binormal = float3(dFdx(IN.tc_normal.y), dFdy(IN.tc_normal.y), 0.);
        binormal.z = -dot(binormal.xy,normal.xy)/normal.z;
        binormal = normalize(binormal);*/
            
        /*if (binormal == float3(0.)) {
            binormal = normalize(cross(float3(0., 1., 0.), normal));
        }*/

        //формируем матрицу трансформации
        float3x3 m3fTransform;
        m3fTransform[0] = tangent;
        m3fTransform[1] = binormal;
        m3fTransform[2] = normal;


        //texNormal.z *= 2.;
        texNormal.xy = (texNormal.xy - 0.5) * 2.;

        texNormal = normalize(texNormal);

        norm = float4(m3fTransform * texNormal, 0.);
    }

    Normal = normalize(norm.xyz);
//    Normal = normalize(float3(normalize(IN.norm) + tex2D(sampler_normal, float2(IN.tc_normal.xy)).xyz));
    Fragment_material.emissive = clamp(defaultMaterial.emissive + tex2D(sampler_emissive, float2(IN.tc_emissive.xy)), 0., 1.);
    Fragment_material.diffuse = clamp(defaultMaterial.diffuse + tex2D(sampler_diffuse, float2(IN.tc_diffuse.xy)), 0., 1.);
    Fragment_material.specular = clamp(defaultMaterial.specular + tex2D(sampler_specular, float2(IN.tc_specular.xy)), 0., 1.);
    Fragment_material.ambient = clamp(defaultMaterial.ambient + tex2D(sampler_ambient, float2(IN.tc_ambient.xy)), 0., 1.);

    Fragment_material.shininess = defaultMaterial.shininess;
}

technique mesh_texture{
    import akra.system.mesh_geometry shift 0;
    import akra.system.mesh_geometry shift 1;
    pass p0 {
        VertexShader = compile vs_mesh_texture();
        PixelShader = compile fs_mesh_texture_pass_1();
    }
    pass p1 {
        VertexShader = compile vs_mesh_texture();
        PixelShader = compile fs_mesh_texture_pass_2();
    }
}

technique mesh_texture_full{
    import akra.system.mesh_geometry;
    pass p0 {
        VertexShader = compile vs_mesh_texture();
        PixelShader = compile fs_mesh_texture_full();
    }
}