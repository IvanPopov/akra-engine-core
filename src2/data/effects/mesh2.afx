provide akra.system;

struct test_pos{
    float2 pos_xy:S_POSITION_XY;
    float pos_z[][]:S_POSITION_Z;
    float pos_w:S_POSITION_W;
};

struct test_norm_1{
    float norm_x:NORM_X;
    float2 norm_yz:NORM_YZ;
    float norm_w:NORM_W;
};
struct test_norm_2{
    float norm_x:NORM_X;
    float3 norm_yzw:NORM_YZW;
};
/*
struct VS_IN{
    test_pos pos[]:POSITION;
    float4 norm:NORMAL;
    float3 tex_coord0: TEXCOORD0;
    float3 tex_coord1: TEXCOORD1;
    float3 tex_coord2: TEXCOORD2;
    float3 tex_coord3: TEXCOORD3;
    float3 tex_coord4: TEXCOORD4;
    float3 tex_coord5: TEXCOORD5;
    float3 tex_coord6: TEXCOORD6;
    float3 tex_coord7: TEXCOORD7;
    float3 tex_coord8: TEXCOORD8;
    float3 tex_coord9: TEXCOORD9;
    float3 tex_coord10: TEXCOORD10;
    float3 tex_coord11: TEXCOORD11;
    float3 tex_coord12: TEXCOORD12;
    float3 tex_coord13: TEXCOORD13;
    float3 tex_coord14: TEXCOORD14;
    float3 tex_coord15: TEXCOORD15;
};
struct VS_OUT{
    float4 pos:POSITION;
    float3 vert:VERTEX;
    float3 norm:NORMAL;
    float3 tc_diffuse: TEXCOORD0;
    float3 tc_ambient: TEXCOORD1;
    float3 tc_specular: TEXCOORD2;
    float3 tc_emissive: TEXCOORD3;
};
*/

struct VS_IN_1{
    test_pos pos[]:POSITION;
    test_norm_1 norm[]:NORMAL;
};

struct VS_IN_2{
    test_norm_2 norm[]:NORMAL;
    float3 tex_coord0: TEXCOORD0;
    float3 tex_coord1: TEXCOORD1;
    float3 tex_coord2: TEXCOORD2;
    float3 tex_coord3: TEXCOORD3;
    float3 tex_coord4: TEXCOORD4;
    float3 tex_coord5: TEXCOORD5;
    float3 tex_coord6: TEXCOORD6;
    float3 tex_coord7: TEXCOORD7;
    float3 tex_coord8: TEXCOORD8;
    float3 tex_coord9: TEXCOORD9;
    float3 tex_coord10: TEXCOORD10;
    float3 tex_coord11: TEXCOORD11;
    float3 tex_coord12: TEXCOORD12;
    float3 tex_coord13: TEXCOORD13;
    float3 tex_coord14: TEXCOORD14;
    float3 tex_coord15: TEXCOORD15;
};

struct VS_OUT_1{
    float4 pos:POSITION;
    float3 vert:VERTEX;
    float3 norm:NORMAL;
};

struct VS_OUT_2{
    float3 vert:VERTEX;
    float3 norm:NORMAL;
    float3 tc_diffuse: TEXCOORD0;
    float3 tc_ambient: TEXCOORD1;
    float3 tc_specular: TEXCOORD2;
    float3 tc_emissive: TEXCOORD3;
};

struct test_Struct_X_1{
    float a:U_a;
    float b:U_b;
};
struct test_Struct_X_2{
    float c:U_c;
    float b:U_b;
};

struct test_Struct_1{
    test_Struct_X_1 x:U_X;
    float y:U_Y;
};
struct test_Struct_2{
    test_Struct_X_1 x:U_X;
    float z:U_Z;
};
///////////////////////////
float4x4 model_mat:MODEL_MATRIX;
float4x4 view_mat:VIEW_MATRIX;
float4x4 proj_mat:PROJ_MATRIX;
float3x3 normal_mat:NORMAL_MATRIX;

global test_Struct_1 external_test:TESTVAR;

VS_OUT_1 vs_mesh_geometry(VS_IN_1 IN, uniform test_Struct_1 u1:UTEST) {
    VS_OUT_1 Out;
    external_test.x.a = 1.0;
    external_test.y = 2.0;
	float4 pos = float4(IN.pos.pos_xy.x,IN.pos.pos_xy.y,@@(IN.pos.pos_z), 1.);
    float4 vertex;
    float4 pos1[][](memof IN.pos);
    float3 norm = float3(IN.norm.norm_x, IN.norm.norm_yz.x,IN.norm.norm_yz.y);
    norm.x += u1.x.a + u1.y;
    @@pos1 = @(IN.pos);
    @pos1 = @(IN.pos);
    pos1.w = 1.0;

	vertex = (view_mat * model_mat * (pos + pos1));

    Out.norm = normalize((normal_mat * norm));
    Out.vert = vertex.xyz;
	Out.pos = proj_mat * vertex;

    return Out;
}

texture tex0:TEXTURE0;
texture tex1:TEXTURE1;
texture tex2:TEXTURE2;
texture tex3:TEXTURE3;

sampler sampler_diffuse:S_DIFFUSE  = sampler_state
{
    Texture = <tex0>;
};
sampler sampler_ambient:S_AMBIENT  = sampler_state
{
    Texture = <tex1>;
};
sampler sampler_specular:S_SPECULAR  = sampler_state
{
    Texture = <tex2>;
};
sampler sampler_emissive:S_EMISSIVE  = sampler_state
{
    Texture = <tex3>;
};
struct Material {
    float4 ambient:AMBIENT;
    float4 diffuse:DIFFUSE;
    float4 specular:SPECULAR;
    float4 emissive:EMISSIVE;
    float shininess:SHININESS;
};

struct LIGHTPOINT {
	float4 position:LIGHT_POSITION;
 	float4 ambient:LIGHT_AMBIENT;
	float4 diffuse:LIGHT_DIFFUSE;
	float4 specular:LIGHT_SPECULAR;
	float4 emissive:LIGHT_EMISSIVE;
	float3 attenuation:LIGHT_ATTENUATION;
};


VS_OUT_2 vs_mesh_texture(VS_IN_2 IN, uniform test_Struct_2 u1:UTEST) {
    VS_OUT_2 Out;
    float3 norm = float3(IN.norm.norm_x, IN.norm.norm_yzw.x,IN.norm.norm_yzw.y);
    norm.x += u1.x.b + u1.z;
    Out.norm = normalize((normal_mat * norm));
    Out.tc_diffuse = IN.tex_coord0;
    Out.tc_ambient = IN.tex_coord1;
    Out.tc_specular = IN.tex_coord2;
    Out.tc_emissive = IN.tex_coord3;

	return Out;
}

Material defaultMaterial:MATERIAL;
float3 eye_pos:EYE_POSITION;

float4 fs_mesh_texture(VS_OUT_2 IN): COLOR{
    float4 color;

    LIGHTPOINT light_point;
    light_point.position = float4(10., 20., 10., 1.);
    light_point.ambient = float4(1., 1., 1., 1.);
    light_point.diffuse = float4(1., 1., 1., 1.);
    light_point.specular = float4(1., 1., 1., 1.);
    light_point.attenuation = float3(1., 0.00, .000);

    float3 light_dir = light_point.position.xyz - IN.vert;
    float light_dir_length = length(light_dir);
    light_dir = normalize(light_dir);

    // direction from vert to observer (ViewDir)
    float3 view_dir = normalize((view_mat * model_mat * float4(eye_pos, 1.0)).xyz - IN.vert);

    // length from source of light to vert
    float3 light_distance = normalize(reflect(-light_dir, IN.norm));

    // attenuation
    float attenuation = 1.0 / (light_point.attenuation.x +
        light_point.attenuation.y *
        light_dir_length + light_point.attenuation.z *
        light_dir_length * light_dir_length);

    color = (defaultMaterial.emissive + tex2D(sampler_emissive, float2(IN.tc_emissive)));

    // add ambient
    color += (defaultMaterial.ambient + tex2D(sampler_ambient, float2(IN.tc_ambient.xy))) * light_point.ambient * attenuation;

    // add diffuse lighting
    color += (defaultMaterial.diffuse + tex2D(sampler_diffuse, float2(IN.tc_diffuse.xy))) * light_point.diffuse * max(dot(IN.norm, light_dir), .0) * attenuation;

    // add reflect lighting
    //float light_distancedotVpow = max(pow(dot(light_distance, view_dir), defaultMaterial.shininess), 0.0);
    float light_distancedotVpow = pow(max(dot(light_distance, view_dir), .0), defaultMaterial.shininess);
    color += (defaultMaterial.specular + tex2D(sampler_specular, float2(IN.tc_specular.xy))) * light_point.specular * light_distancedotVpow * attenuation;

    return float4(color.xyz, 1.);
}


technique mesh_geometry{
    pass p0 {
        VertexShader = compile vs_mesh_geometry();
    }
}

technique mesh_texture{
    pass p0 {
        VertexShader = compile vs_mesh_texture();
        PixelShader = compile fs_mesh_texture();
    }
}

