provide akra.system;

struct VS_IN{
    float4 pos:POSITION;
    float4 norm:NORMAL;
    float3 tex_coord0: TEXCOORD0;
    float3 tex_coord1: TEXCOORD1;
    float3 tex_coord2: TEXCOORD2;
    float3 tex_coord3: TEXCOORD3;
    float3 tex_coord4: TEXCOORD4;
    float3 tex_coord5: TEXCOORD5;
    float3 tex_coord6: TEXCOORD6;
    float3 tex_coord7: TEXCOORD7;
    float3 tex_coord8: TEXCOORD8;
    float3 tex_coord9: TEXCOORD9;
    float3 tex_coord10: TEXCOORD10;
    float3 tex_coord11: TEXCOORD11;
    float3 tex_coord12: TEXCOORD12;
    float3 tex_coord13: TEXCOORD13;
    float3 tex_coord14: TEXCOORD14;
    float3 tex_coord15: TEXCOORD15;
};

struct VS_OUT{
    float4 pos:POSITION;
    float3 vert:VERTEX;
    float3 norm:NORMAL;
    float3 tc_diffuse: TEXCOORD0;
    float3 tc_ambient: TEXCOORD1;
    float3 tc_specular: TEXCOORD2;
    float3 tc_emissive: TEXCOORD3;
};

float4x4 model_mat:MODEL_MATRIX;
float4x4 view_mat:VIEW_MATRIX;
float4x4 proj_mat:PROJ_MATRIX;
float3x3 normal_mat:NORMAL_MATRIX;

texture tex0:TEXTURE0;
texture tex1:TEXTURE1;
texture tex2:TEXTURE2;
texture tex3:TEXTURE3;

sampler sampler_diffuse:S_DIFFUSE  = sampler_state
{
    Texture = <tex0>;
};
sampler sampler_ambient:S_AMBIENT  = sampler_state
{
    Texture = <tex1>;
};
sampler sampler_specular:S_SPECULAR  = sampler_state
{
    Texture = <tex2>;
};
sampler sampler_emissive:S_EMISSIVE  = sampler_state
{
    Texture = <tex3>;
};
struct Material {
    float4 ambient:AMBIENT;
    float4 diffuse:DIFFUSE;
    float4 specular:SPECULAR;
    float4 emissive:EMISSIVE;
    float shininess:SHININESS;
};

struct LIGHTPOINT {
	float4 position:LIGHT_POSITION;
 	float4 ambient:LIGHT_AMBIENT;
	float4 diffuse:LIGHT_DIFFUSE;
	float4 specular:LIGHT_SPECULAR;
	float4 emissive:LIGHT_EMISSIVE;
	float3 attenuation:LIGHT_ATTENUATION;
};


VS_OUT vs_mesh_texture(VS_IN IN) {
    VS_OUT Out;

    Out.tc_diffuse = IN.tex_coord0;
    Out.tc_ambient = IN.tex_coord1;
    Out.tc_specular = IN.tex_coord2;
    Out.tc_emissive = IN.tex_coord3;

	return Out;
}

Material defaultMaterial:MATERIAL;
float3 eye_pos:EYE_POSITION;

float4 fs_mesh_texture(VS_OUT IN): COLOR{
    float4 color;

    LIGHTPOINT light_point;
    light_point.position = float4(10., 20., 10., 1.);
    light_point.ambient = float4(1., 1., 1., 1.);
    light_point.diffuse = float4(1., 1., 1., 1.);
    light_point.specular = float4(1., 1., 1., 1.);
    light_point.attenuation = float3(1., 0.00, .000);

    float3 light_dir = light_point.position.xyz - IN.vert;
    float light_dir_length = length(light_dir);
    light_dir = normalize(light_dir);

    // direction from vert to observer (ViewDir)
    float3 view_dir = normalize((view_mat * model_mat * float4(eye_pos, 1.0)).xyz - IN.vert);

    // length from source of light to vert
    float3 light_distance = normalize(reflect(-light_dir, IN.norm));

    // attenuation
    float attenuation = 1.0 / (light_point.attenuation.x +
        light_point.attenuation.y *
        light_dir_length + light_point.attenuation.z *
        light_dir_length * light_dir_length);

    color = (defaultMaterial.emissive + tex2D(sampler_emissive, float2(IN.tc_emissive)));

    // add ambient
    color += (defaultMaterial.ambient + tex2D(sampler_ambient, float2(IN.tc_ambient.xy))) * light_point.ambient * attenuation;

    // add diffuse lighting
    color += (defaultMaterial.diffuse + tex2D(sampler_diffuse, float2(IN.tc_diffuse.xy))) * light_point.diffuse * max(dot(IN.norm, light_dir), .0) * attenuation;

    // add reflect lighting
    //float light_distancedotVpow = max(pow(dot(light_distance, view_dir), defaultMaterial.shininess), 0.0);
    float light_distancedotVpow = pow(max(dot(light_distance, view_dir), .0), defaultMaterial.shininess);
    color += (defaultMaterial.specular + tex2D(sampler_specular, float2(IN.tc_specular.xy))) * light_point.specular * light_distancedotVpow * attenuation;

    return float4(color.xyz, 1.);
}



technique mesh_texture{
    pass p0 {
        VertexShader = compile vs_mesh_texture();
        PixelShader = compile fs_mesh_texture();
    }
}