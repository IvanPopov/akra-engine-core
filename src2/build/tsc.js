/* *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var TypeScript;
(function (TypeScript) {
    function hasFlag(val, flag) {
        return (val & flag) != 0;
    }
    TypeScript.hasFlag = hasFlag;
    function isDef(val) {
        return val !== undefined;
    }
    TypeScript.isDef = isDef;
    function isNull(val) {
        return val === null;
    }
    TypeScript.isNull = isNull;
    function isDefAndNotNull(val) {
        return val != null;
    }
    TypeScript.isDefAndNotNull = isDefAndNotNull;
    (function (ErrorRecoverySet) {
        ErrorRecoverySet._map = [];
        ErrorRecoverySet.None = 0;
        ErrorRecoverySet.Comma = 1;
        ErrorRecoverySet.SColon = 1 << 1;
        ErrorRecoverySet.Asg = 1 << 2;
        ErrorRecoverySet.BinOp = 1 << 3;
        ErrorRecoverySet.RBrack = 1 << 4;
        ErrorRecoverySet.RCurly = 1 << 5;
        ErrorRecoverySet.RParen = 1 << 6;
        ErrorRecoverySet.Dot = 1 << 7;
        ErrorRecoverySet.Colon = 1 << 8;
        ErrorRecoverySet.PrimType = 1 << 9;
        ErrorRecoverySet.AddOp = 1 << 10;
        ErrorRecoverySet.LCurly = 1 << 11;
        ErrorRecoverySet.PreOp = 1 << 12;
        ErrorRecoverySet.RegExp = 1 << 13;
        ErrorRecoverySet.LParen = 1 << 14;
        ErrorRecoverySet.LBrack = 1 << 15;
        ErrorRecoverySet.Scope = 1 << 16;
        ErrorRecoverySet.In = 1 << 17;
        ErrorRecoverySet.SCase = 1 << 18;
        ErrorRecoverySet.Else = 1 << 19;
        ErrorRecoverySet.Catch = 1 << 20;
        ErrorRecoverySet.Var = 1 << 21;
        ErrorRecoverySet.Stmt = 1 << 22;
        ErrorRecoverySet.While = 1 << 23;
        ErrorRecoverySet.ID = 1 << 24;
        ErrorRecoverySet.Prefix = 1 << 25;
        ErrorRecoverySet.Literal = 1 << 26;
        ErrorRecoverySet.RLit = 1 << 27;
        ErrorRecoverySet.Func = 1 << 28;
        ErrorRecoverySet.EOF = 1 << 29;
        ErrorRecoverySet.TypeScriptS = 1 << 30;
        ErrorRecoverySet.ExprStart = ErrorRecoverySet.SColon | ErrorRecoverySet.AddOp | ErrorRecoverySet.LCurly | ErrorRecoverySet.PreOp | ErrorRecoverySet.RegExp | ErrorRecoverySet.LParen | ErrorRecoverySet.LBrack | ErrorRecoverySet.ID | ErrorRecoverySet.Prefix | ErrorRecoverySet.RLit | ErrorRecoverySet.Func | ErrorRecoverySet.Literal;
        ErrorRecoverySet.StmtStart = ErrorRecoverySet.ExprStart | ErrorRecoverySet.SColon | ErrorRecoverySet.Var | ErrorRecoverySet.Stmt | ErrorRecoverySet.While | ErrorRecoverySet.TypeScriptS;
        ErrorRecoverySet.Postfix = ErrorRecoverySet.Dot | ErrorRecoverySet.LParen | ErrorRecoverySet.LBrack;
    })(TypeScript.ErrorRecoverySet || (TypeScript.ErrorRecoverySet = {}));
    var ErrorRecoverySet = TypeScript.ErrorRecoverySet;
    (function (AllowedElements) {
        AllowedElements._map = [];
        AllowedElements.None = 0;
        AllowedElements.ModuleDeclarations = 1 << 2;
        AllowedElements.ClassDeclarations = 1 << 3;
        AllowedElements.InterfaceDeclarations = 1 << 4;
        AllowedElements.AmbientDeclarations = 1 << 10;
        AllowedElements.Properties = 1 << 11;
        AllowedElements.Global = AllowedElements.ModuleDeclarations | AllowedElements.ClassDeclarations | AllowedElements.InterfaceDeclarations | AllowedElements.AmbientDeclarations;
        AllowedElements.QuickParse = AllowedElements.Global | AllowedElements.Properties;
    })(TypeScript.AllowedElements || (TypeScript.AllowedElements = {}));
    var AllowedElements = TypeScript.AllowedElements;
    (function (Modifiers) {
        Modifiers._map = [];
        Modifiers.None = 0;
        Modifiers.Private = 1;
        Modifiers.Public = 1 << 1;
        Modifiers.Readonly = 1 << 2;
        Modifiers.Ambient = 1 << 3;
        Modifiers.Exported = 1 << 4;
        Modifiers.Getter = 1 << 5;
        Modifiers.Setter = 1 << 6;
        Modifiers.Static = 1 << 7;
        Modifiers.Inline = 1 << 8;
    })(TypeScript.Modifiers || (TypeScript.Modifiers = {}));
    var Modifiers = TypeScript.Modifiers;
    (function (ASTFlags) {
        ASTFlags._map = [];
        ASTFlags.None = 0;
        ASTFlags.ExplicitSemicolon = 1;
        ASTFlags.AutomaticSemicolon = 1 << 1;
        ASTFlags.Writeable = 1 << 2;
        ASTFlags.Error = 1 << 3;
        ASTFlags.DotLHSPartial = 1 << 4;
        ASTFlags.DotLHS = 1 << 5;
        ASTFlags.IsStatement = 1 << 6;
        ASTFlags.StrictMode = 1 << 7;
        ASTFlags.PossibleOptionalParameter = 1 << 8;
        ASTFlags.ClassBaseConstructorCall = 1 << 9;
        ASTFlags.OptionalName = 1 << 10;
        ASTFlags.SkipNextRParen = 1 << 11;
        ASTFlags.TypeReference = 1 << 12;
    })(TypeScript.ASTFlags || (TypeScript.ASTFlags = {}));
    var ASTFlags = TypeScript.ASTFlags;
    (function (DeclFlags) {
        DeclFlags._map = [];
        DeclFlags.None = 0;
        DeclFlags.Exported = 1;
        DeclFlags.Private = 1 << 1;
        DeclFlags.Public = 1 << 2;
        DeclFlags.Ambient = 1 << 3;
        DeclFlags.Static = 1 << 4;
        DeclFlags.LocalStatic = 1 << 5;
        DeclFlags.GetAccessor = 1 << 6;
        DeclFlags.SetAccessor = 1 << 7;
    })(TypeScript.DeclFlags || (TypeScript.DeclFlags = {}));
    var DeclFlags = TypeScript.DeclFlags;
    (function (ModuleFlags) {
        ModuleFlags._map = [];
        ModuleFlags.None = 0;
        ModuleFlags.Exported = 1;
        ModuleFlags.Private = 1 << 1;
        ModuleFlags.Public = 1 << 2;
        ModuleFlags.Ambient = 1 << 3;
        ModuleFlags.Static = 1 << 4;
        ModuleFlags.LocalStatic = 1 << 5;
        ModuleFlags.GetAccessor = 1 << 6;
        ModuleFlags.SetAccessor = 1 << 7;
        ModuleFlags.IsEnum = 1 << 8;
        ModuleFlags.ShouldEmitModuleDecl = 1 << 9;
        ModuleFlags.IsWholeFile = 1 << 10;
        ModuleFlags.IsDynamic = 1 << 11;
        ModuleFlags.MustCaptureThis = 1 << 12;
    })(TypeScript.ModuleFlags || (TypeScript.ModuleFlags = {}));
    var ModuleFlags = TypeScript.ModuleFlags;
    (function (SymbolFlags) {
        SymbolFlags._map = [];
        SymbolFlags.None = 0;
        SymbolFlags.Exported = 1;
        SymbolFlags.Private = 1 << 1;
        SymbolFlags.Public = 1 << 2;
        SymbolFlags.Ambient = 1 << 3;
        SymbolFlags.Static = 1 << 4;
        SymbolFlags.LocalStatic = 1 << 5;
        SymbolFlags.GetAccessor = 1 << 6;
        SymbolFlags.SetAccessor = 1 << 7;
        SymbolFlags.Property = 1 << 8;
        SymbolFlags.Readonly = 1 << 9;
        SymbolFlags.ModuleMember = 1 << 10;
        SymbolFlags.InterfaceMember = 1 << 11;
        SymbolFlags.ClassMember = 1 << 12;
        SymbolFlags.BuiltIn = 1 << 13;
        SymbolFlags.TypeSetDuringScopeAssignment = 1 << 14;
        SymbolFlags.Constant = 1 << 15;
        SymbolFlags.Optional = 1 << 16;
        SymbolFlags.RecursivelyReferenced = 1 << 17;
        SymbolFlags.Bound = 1 << 18;
        SymbolFlags.CompilerGenerated = 1 << 19;
    })(TypeScript.SymbolFlags || (TypeScript.SymbolFlags = {}));
    var SymbolFlags = TypeScript.SymbolFlags;
    (function (VarFlags) {
        VarFlags._map = [];
        VarFlags.None = 0;
        VarFlags.Exported = 1;
        VarFlags.Private = 1 << 1;
        VarFlags.Public = 1 << 2;
        VarFlags.Ambient = 1 << 3;
        VarFlags.Static = 1 << 4;
        VarFlags.LocalStatic = 1 << 5;
        VarFlags.GetAccessor = 1 << 6;
        VarFlags.SetAccessor = 1 << 7;
        VarFlags.AutoInit = 1 << 8;
        VarFlags.Property = 1 << 9;
        VarFlags.Readonly = 1 << 10;
        VarFlags.Class = 1 << 11;
        VarFlags.ClassProperty = 1 << 12;
        VarFlags.ClassBodyProperty = 1 << 13;
        VarFlags.ClassConstructorProperty = 1 << 14;
        VarFlags.ClassSuperMustBeFirstCallInConstructor = 1 << 15;
        VarFlags.Constant = 1 << 16;
        VarFlags.MustCaptureThis = 1 << 17;
    })(TypeScript.VarFlags || (TypeScript.VarFlags = {}));
    var VarFlags = TypeScript.VarFlags;
    (function (FncFlags) {
        FncFlags._map = [];
        FncFlags.None = 0;
        FncFlags.Exported = 1;
        FncFlags.Private = 1 << 1;
        FncFlags.Public = 1 << 2;
        FncFlags.Ambient = 1 << 3;
        FncFlags.Static = 1 << 4;
        FncFlags.LocalStatic = 1 << 5;
        FncFlags.GetAccessor = 1 << 6;
        FncFlags.SetAccessor = 1 << 7;
        FncFlags.Signature = 1 << 9;
        FncFlags.Method = 1 << 10;
        FncFlags.HasReturnExpression = 1 << 11;
        FncFlags.CallMember = 1 << 12;
        FncFlags.ConstructMember = 1 << 13;
        FncFlags.HasSelfReference = 1 << 14;
        FncFlags.IsFatArrowFunction = 1 << 15;
        FncFlags.IndexerMember = 1 << 16;
        FncFlags.IsFunctionExpression = 1 << 17;
        FncFlags.ClassMethod = 1 << 18;
        FncFlags.ClassPropertyMethodExported = 1 << 19;
        FncFlags.HasSuperReferenceInFatArrowFunction = 1 << 20;
        FncFlags.IsPropertyBound = 1 << 21;
        FncFlags.Inline = 1 << 22;
    })(TypeScript.FncFlags || (TypeScript.FncFlags = {}));
    var FncFlags = TypeScript.FncFlags;
    (function (SignatureFlags) {
        SignatureFlags._map = [];
        SignatureFlags.None = 0;
        SignatureFlags.IsIndexer = 1;
        SignatureFlags.IsStringIndexer = 1 << 1;
        SignatureFlags.IsNumberIndexer = 1 << 2;
    })(TypeScript.SignatureFlags || (TypeScript.SignatureFlags = {}));
    var SignatureFlags = TypeScript.SignatureFlags;
                    function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags) {
        return fncOrVarOrSymbolOrModuleFlags;
    }
    TypeScript.ToDeclFlags = ToDeclFlags;
    (function (TypeFlags) {
        TypeFlags._map = [];
        TypeFlags.None = 0;
        TypeFlags.HasImplementation = 1;
        TypeFlags.HasSelfReference = 1 << 1;
        TypeFlags.MergeResult = 1 << 2;
        TypeFlags.IsEnum = 1 << 3;
        TypeFlags.BuildingName = 1 << 4;
        TypeFlags.HasBaseType = 1 << 5;
        TypeFlags.HasBaseTypeOfObject = 1 << 6;
        TypeFlags.IsClass = 1 << 7;
    })(TypeScript.TypeFlags || (TypeScript.TypeFlags = {}));
    var TypeFlags = TypeScript.TypeFlags;
    (function (TypeRelationshipFlags) {
        TypeRelationshipFlags._map = [];
        TypeRelationshipFlags.SuccessfulComparison = 0;
        TypeRelationshipFlags.SourceIsNullTargetIsVoidOrUndefined = 1;
        TypeRelationshipFlags.RequiredPropertyIsMissing = 1 << 1;
        TypeRelationshipFlags.IncompatibleSignatures = 1 << 2;
        TypeRelationshipFlags.SourceSignatureHasTooManyParameters = 3;
        TypeRelationshipFlags.IncompatibleReturnTypes = 1 << 4;
        TypeRelationshipFlags.IncompatiblePropertyTypes = 1 << 5;
        TypeRelationshipFlags.IncompatibleParameterTypes = 1 << 6;
    })(TypeScript.TypeRelationshipFlags || (TypeScript.TypeRelationshipFlags = {}));
    var TypeRelationshipFlags = TypeScript.TypeRelationshipFlags;
    (function (CodeGenTarget) {
        CodeGenTarget._map = [];
        CodeGenTarget.ES3 = 0;
        CodeGenTarget.ES5 = 1;
    })(TypeScript.CodeGenTarget || (TypeScript.CodeGenTarget = {}));
    var CodeGenTarget = TypeScript.CodeGenTarget;
    (function (ModuleGenTarget) {
        ModuleGenTarget._map = [];
        ModuleGenTarget.Synchronous = 0;
        ModuleGenTarget.Asynchronous = 1;
        ModuleGenTarget.Local = 1 << 1;
    })(TypeScript.ModuleGenTarget || (TypeScript.ModuleGenTarget = {}));
    var ModuleGenTarget = TypeScript.ModuleGenTarget;
    TypeScript.codeGenTarget = 0 /* ES3 */ ;
    TypeScript.moduleGenTarget = 0 /* Synchronous */ ;
    TypeScript.optimizeModuleCodeGen = true;
    function flagsToString(e, flags) {
        var builder = "";
        for(var i = 1; i < (1 << 31); i = i << 1) {
            if ((flags & i) != 0) {
                for(var k in e) {
                    if (e[k] == i) {
                        if (builder.length > 0) {
                            builder += "|";
                        }
                        builder += k;
                        break;
                    }
                }
            }
        }
        return builder;
    }
    TypeScript.flagsToString = flagsToString;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (NodeType) {
        NodeType._map = [];
        NodeType._map[0] = "None";
        NodeType.None = 0;
        NodeType._map[1] = "Empty";
        NodeType.Empty = 1;
        NodeType._map[2] = "EmptyExpr";
        NodeType.EmptyExpr = 2;
        NodeType._map[3] = "True";
        NodeType.True = 3;
        NodeType._map[4] = "False";
        NodeType.False = 4;
        NodeType._map[5] = "This";
        NodeType.This = 5;
        NodeType._map[6] = "Super";
        NodeType.Super = 6;
        NodeType._map[7] = "QString";
        NodeType.QString = 7;
        NodeType._map[8] = "Regex";
        NodeType.Regex = 8;
        NodeType._map[9] = "Null";
        NodeType.Null = 9;
        NodeType._map[10] = "ArrayLit";
        NodeType.ArrayLit = 10;
        NodeType._map[11] = "ObjectLit";
        NodeType.ObjectLit = 11;
        NodeType._map[12] = "Void";
        NodeType.Void = 12;
        NodeType._map[13] = "Comma";
        NodeType.Comma = 13;
        NodeType._map[14] = "Pos";
        NodeType.Pos = 14;
        NodeType._map[15] = "Neg";
        NodeType.Neg = 15;
        NodeType._map[16] = "Delete";
        NodeType.Delete = 16;
        NodeType._map[17] = "Await";
        NodeType.Await = 17;
        NodeType._map[18] = "In";
        NodeType.In = 18;
        NodeType._map[19] = "Dot";
        NodeType.Dot = 19;
        NodeType._map[20] = "From";
        NodeType.From = 20;
        NodeType._map[21] = "Is";
        NodeType.Is = 21;
        NodeType._map[22] = "InstOf";
        NodeType.InstOf = 22;
        NodeType._map[23] = "Typeof";
        NodeType.Typeof = 23;
        NodeType._map[24] = "NumberLit";
        NodeType.NumberLit = 24;
        NodeType._map[25] = "Name";
        NodeType.Name = 25;
        NodeType._map[26] = "TypeParameter";
        NodeType.TypeParameter = 26;
        NodeType._map[27] = "GenericType";
        NodeType.GenericType = 27;
        NodeType._map[28] = "TypeRef";
        NodeType.TypeRef = 28;
        NodeType._map[29] = "Index";
        NodeType.Index = 29;
        NodeType._map[30] = "Call";
        NodeType.Call = 30;
        NodeType._map[31] = "New";
        NodeType.New = 31;
        NodeType._map[32] = "Asg";
        NodeType.Asg = 32;
        NodeType._map[33] = "AsgAdd";
        NodeType.AsgAdd = 33;
        NodeType._map[34] = "AsgSub";
        NodeType.AsgSub = 34;
        NodeType._map[35] = "AsgDiv";
        NodeType.AsgDiv = 35;
        NodeType._map[36] = "AsgMul";
        NodeType.AsgMul = 36;
        NodeType._map[37] = "AsgMod";
        NodeType.AsgMod = 37;
        NodeType._map[38] = "AsgAnd";
        NodeType.AsgAnd = 38;
        NodeType._map[39] = "AsgXor";
        NodeType.AsgXor = 39;
        NodeType._map[40] = "AsgOr";
        NodeType.AsgOr = 40;
        NodeType._map[41] = "AsgLsh";
        NodeType.AsgLsh = 41;
        NodeType._map[42] = "AsgRsh";
        NodeType.AsgRsh = 42;
        NodeType._map[43] = "AsgRs2";
        NodeType.AsgRs2 = 43;
        NodeType._map[44] = "ConditionalExpression";
        NodeType.ConditionalExpression = 44;
        NodeType._map[45] = "LogOr";
        NodeType.LogOr = 45;
        NodeType._map[46] = "LogAnd";
        NodeType.LogAnd = 46;
        NodeType._map[47] = "Or";
        NodeType.Or = 47;
        NodeType._map[48] = "Xor";
        NodeType.Xor = 48;
        NodeType._map[49] = "And";
        NodeType.And = 49;
        NodeType._map[50] = "Eq";
        NodeType.Eq = 50;
        NodeType._map[51] = "Ne";
        NodeType.Ne = 51;
        NodeType._map[52] = "Eqv";
        NodeType.Eqv = 52;
        NodeType._map[53] = "NEqv";
        NodeType.NEqv = 53;
        NodeType._map[54] = "Lt";
        NodeType.Lt = 54;
        NodeType._map[55] = "Le";
        NodeType.Le = 55;
        NodeType._map[56] = "Gt";
        NodeType.Gt = 56;
        NodeType._map[57] = "Ge";
        NodeType.Ge = 57;
        NodeType._map[58] = "Add";
        NodeType.Add = 58;
        NodeType._map[59] = "Sub";
        NodeType.Sub = 59;
        NodeType._map[60] = "Mul";
        NodeType.Mul = 60;
        NodeType._map[61] = "Div";
        NodeType.Div = 61;
        NodeType._map[62] = "Mod";
        NodeType.Mod = 62;
        NodeType._map[63] = "Lsh";
        NodeType.Lsh = 63;
        NodeType._map[64] = "Rsh";
        NodeType.Rsh = 64;
        NodeType._map[65] = "Rs2";
        NodeType.Rs2 = 65;
        NodeType._map[66] = "Not";
        NodeType.Not = 66;
        NodeType._map[67] = "LogNot";
        NodeType.LogNot = 67;
        NodeType._map[68] = "IncPre";
        NodeType.IncPre = 68;
        NodeType._map[69] = "DecPre";
        NodeType.DecPre = 69;
        NodeType._map[70] = "IncPost";
        NodeType.IncPost = 70;
        NodeType._map[71] = "DecPost";
        NodeType.DecPost = 71;
        NodeType._map[72] = "TypeAssertion";
        NodeType.TypeAssertion = 72;
        NodeType._map[73] = "FuncDecl";
        NodeType.FuncDecl = 73;
        NodeType._map[74] = "Member";
        NodeType.Member = 74;
        NodeType._map[75] = "VarDecl";
        NodeType.VarDecl = 75;
        NodeType._map[76] = "ArgDecl";
        NodeType.ArgDecl = 76;
        NodeType._map[77] = "Return";
        NodeType.Return = 77;
        NodeType._map[78] = "Break";
        NodeType.Break = 78;
        NodeType._map[79] = "Continue";
        NodeType.Continue = 79;
        NodeType._map[80] = "Throw";
        NodeType.Throw = 80;
        NodeType._map[81] = "For";
        NodeType.For = 81;
        NodeType._map[82] = "ForIn";
        NodeType.ForIn = 82;
        NodeType._map[83] = "If";
        NodeType.If = 83;
        NodeType._map[84] = "While";
        NodeType.While = 84;
        NodeType._map[85] = "DoWhile";
        NodeType.DoWhile = 85;
        NodeType._map[86] = "Block";
        NodeType.Block = 86;
        NodeType._map[87] = "Case";
        NodeType.Case = 87;
        NodeType._map[88] = "Switch";
        NodeType.Switch = 88;
        NodeType._map[89] = "Try";
        NodeType.Try = 89;
        NodeType._map[90] = "TryCatch";
        NodeType.TryCatch = 90;
        NodeType._map[91] = "TryFinally";
        NodeType.TryFinally = 91;
        NodeType._map[92] = "Finally";
        NodeType.Finally = 92;
        NodeType._map[93] = "Catch";
        NodeType.Catch = 93;
        NodeType._map[94] = "List";
        NodeType.List = 94;
        NodeType._map[95] = "Script";
        NodeType.Script = 95;
        NodeType._map[96] = "ClassDeclaration";
        NodeType.ClassDeclaration = 96;
        NodeType._map[97] = "InterfaceDeclaration";
        NodeType.InterfaceDeclaration = 97;
        NodeType._map[98] = "ModuleDeclaration";
        NodeType.ModuleDeclaration = 98;
        NodeType._map[99] = "ImportDeclaration";
        NodeType.ImportDeclaration = 99;
        NodeType._map[100] = "With";
        NodeType.With = 100;
        NodeType._map[101] = "Label";
        NodeType.Label = 101;
        NodeType._map[102] = "LabeledStatement";
        NodeType.LabeledStatement = 102;
        NodeType._map[103] = "EBStart";
        NodeType.EBStart = 103;
        NodeType._map[104] = "GotoEB";
        NodeType.GotoEB = 104;
        NodeType._map[105] = "EndCode";
        NodeType.EndCode = 105;
        NodeType._map[106] = "Error";
        NodeType.Error = 106;
        NodeType._map[107] = "Comment";
        NodeType.Comment = 107;
        NodeType._map[108] = "Debugger";
        NodeType.Debugger = 108;
        NodeType.GeneralNode = NodeType.FuncDecl;
        NodeType.LastAsg = NodeType.AsgRs2;
    })(TypeScript.NodeType || (TypeScript.NodeType = {}));
    var NodeType = TypeScript.NodeType;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            this["constructor"] = undefined;
        }
        return BlockIntrinsics;
    })();
    TypeScript.BlockIntrinsics = BlockIntrinsics;    
    var StringHashTable = (function () {
        function StringHashTable() {
            this.itemCount = 0;
            this.table = (new BlockIntrinsics());
        }
        StringHashTable.prototype.getAllKeys = function () {
            var result = [];
            for(var k in this.table) {
                if (this.table[k] != undefined) {
                    result[result.length] = k;
                }
            }
            return result;
        };
        StringHashTable.prototype.add = function (key, data) {
            if (this.table[key] != undefined) {
                return false;
            }
            this.table[key] = data;
            this.itemCount++;
            return true;
        };
        StringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.table[key] != undefined) {
                this.table[key] = data;
                return false;
            }
            this.table[key] = data;
            this.itemCount++;
            return true;
        };
        StringHashTable.prototype.map = function (fn, context) {
            for(var k in this.table) {
                var data = this.table[k];
                if (data != undefined) {
                    fn(k, this.table[k], context);
                }
            }
        };
        StringHashTable.prototype.every = function (fn, context) {
            for(var k in this.table) {
                var data = this.table[k];
                if (data != undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }
            return true;
        };
        StringHashTable.prototype.some = function (fn, context) {
            for(var k in this.table) {
                var data = this.table[k];
                if (data != undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }
            return false;
        };
        StringHashTable.prototype.count = function () {
            return this.itemCount;
        };
        StringHashTable.prototype.lookup = function (key) {
            var data = this.table[key];
            if (data != undefined) {
                return data;
            } else {
                return (null);
            }
        };
        return StringHashTable;
    })();
    TypeScript.StringHashTable = StringHashTable;    
    var DualStringHashTable = (function () {
        function DualStringHashTable(primaryTable, secondaryTable) {
            this.primaryTable = primaryTable;
            this.secondaryTable = secondaryTable;
            this.insertPrimary = true;
        }
        DualStringHashTable.prototype.getAllKeys = function () {
            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());
        };
        DualStringHashTable.prototype.add = function (key, data) {
            if (this.insertPrimary) {
                return this.primaryTable.add(key, data);
            } else {
                return this.secondaryTable.add(key, data);
            }
        };
        DualStringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.insertPrimary) {
                return this.primaryTable.addOrUpdate(key, data);
            } else {
                return this.secondaryTable.addOrUpdate(key, data);
            }
        };
        DualStringHashTable.prototype.map = function (fn, context) {
            this.primaryTable.map(fn, context);
            this.secondaryTable.map(fn, context);
        };
        DualStringHashTable.prototype.every = function (fn, context) {
            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);
        };
        DualStringHashTable.prototype.some = function (fn, context) {
            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);
        };
        DualStringHashTable.prototype.count = function () {
            return this.primaryTable.count() + this.secondaryTable.count();
        };
        DualStringHashTable.prototype.lookup = function (key) {
            var data = this.primaryTable.lookup(key);
            if (data != undefined) {
                return data;
            } else {
                return this.secondaryTable.lookup(key);
            }
        };
        return DualStringHashTable;
    })();
    TypeScript.DualStringHashTable = DualStringHashTable;    
    function numberHashFn(key) {
        var c2 = 0x27d4eb2d;
        key = (key ^ 61) ^ (key >>> 16);
        key = key + (key << 3);
        key = key ^ (key >>> 4);
        key = key * c2;
        key = key ^ (key >>> 15);
        return key;
    }
    TypeScript.numberHashFn = numberHashFn;
    function combineHashes(key1, key2) {
        return key2 ^ ((key1 >> 5) + key1);
    }
    TypeScript.combineHashes = combineHashes;
    var HashEntry = (function () {
        function HashEntry(key, data) {
            this.key = key;
            this.data = data;
        }
        return HashEntry;
    })();
    TypeScript.HashEntry = HashEntry;    
    var HashTable = (function () {
        function HashTable(size, hashFn, equalsFn) {
            this.size = size;
            this.hashFn = hashFn;
            this.equalsFn = equalsFn;
            this.itemCount = 0;
            this.table = new Array();
            for(var i = 0; i < this.size; i++) {
                this.table[i] = null;
            }
        }
        HashTable.prototype.add = function (key, data) {
            var current;
            var entry = new HashEntry(key, data);
            var val = this.hashFn(key);
            val = val % this.size;
            for(current = this.table[val]; current != null; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    return false;
                }
            }
            entry.next = this.table[val];
            this.table[val] = entry;
            this.itemCount++;
            return true;
        };
        HashTable.prototype.remove = function (key) {
            var current;
            var val = this.hashFn(key);
            val = val % this.size;
            var result = null;
            var prevEntry = null;
            for(current = this.table[val]; current != null; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    result = current.data;
                    this.itemCount--;
                    if (prevEntry) {
                        prevEntry.next = current.next;
                    } else {
                        this.table[val] = current.next;
                    }
                    break;
                }
                prevEntry = current;
            }
            return result;
        };
        HashTable.prototype.count = function () {
            return this.itemCount;
        };
        HashTable.prototype.lookup = function (key) {
            var current;
            var val = this.hashFn(key);
            val = val % this.size;
            for(current = this.table[val]; current != null; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    return (current.data);
                }
            }
            return (null);
        };
        return HashTable;
    })();
    TypeScript.HashTable = HashTable;    
    var SimpleHashTable = (function () {
        function SimpleHashTable() {
            this.keys = [];
            this.values = [];
        }
        SimpleHashTable.prototype.lookup = function (key, findValue) {
            var searchArray = this.keys;
            if (findValue) {
                searchArray = this.values;
            }
            for(var i = 0; i < searchArray.length; i++) {
                if (searchArray[i] == key) {
                    return {
                        key: this.keys[i],
                        data: this.values[i]
                    };
                }
            }
            return null;
        };
        SimpleHashTable.prototype.add = function (key, data) {
            var lookupData = this.lookup(key);
            if (lookupData) {
                return false;
            }
            this.keys[this.keys.length] = key;
            this.values[this.values.length] = data;
            return true;
        };
        return SimpleHashTable;
    })();
    TypeScript.SimpleHashTable = SimpleHashTable;    
})(TypeScript || (TypeScript = {}));
var __extends = this.__extends || function (d, b) {
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TypeScript;
(function (TypeScript) {
    var ASTSpan = (function () {
        function ASTSpan() {
            this.minChar = -1;
            this.limChar = -1;
        }
        return ASTSpan;
    })();
    TypeScript.ASTSpan = ASTSpan;    
    TypeScript.astID = 0;
    var AST = (function (_super) {
        __extends(AST, _super);
        function AST(nodeType) {
                _super.call(this);
            this.nodeType = nodeType;
            this.type = null;
            this.flags = 4 /* Writeable */ ;
            this.astID = TypeScript.astID++;
            this.passCreated = TypeScript.CompilerDiagnostics.analysisPass;
            this.preComments = null;
            this.postComments = null;
            this.docComments = null;
            this.isParenthesized = false;
        }
        AST.prototype.getLength = function () {
            return this.limChar - this.minChar;
        };
        AST.prototype.getID = function () {
            return this.astID;
        };
        AST.prototype.isExpression = function () {
            return false;
        };
        AST.prototype.isStatementOrExpression = function () {
            return false;
        };
        AST.prototype.isCompoundStatement = function () {
            return false;
        };
        AST.prototype.isLeaf = function () {
            return this.isStatementOrExpression() && (!this.isCompoundStatement());
        };
        AST.prototype.isDeclaration = function () {
            return false;
        };
        AST.prototype.typeCheck = function (typeFlow) {
            switch(this.nodeType) {
                case 106 /* Error */ :
                case 2 /* EmptyExpr */ :
                    this.type = typeFlow.anyType;
                    break;
                case 5 /* This */ :
                    return typeFlow.typeCheckThis(this);
                case 9 /* Null */ :
                    this.type = typeFlow.nullType;
                    break;
                case 4 /* False */ :
                case 3 /* True */ :
                    this.type = typeFlow.booleanType;
                    break;
                case 6 /* Super */ :
                    return typeFlow.typeCheckSuper(this);
                case 105 /* EndCode */ :
                case 1 /* Empty */ :
                case 12 /* Void */ :
                    this.type = typeFlow.voidType;
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        };
        AST.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            switch(this.nodeType) {
                case 5 /* This */ :
                    if (!emitter.inlineEngine.inline(this, emitter, tokenId, startLine)) {
                        emitter.recordSourceMappingStart(this);
                        if (emitter.thisFnc && (TypeScript.hasFlag(emitter.thisFnc.fncFlags, 32768 /* IsFatArrowFunction */ ))) {
                            emitter.writeToOutput("_this");
                        } else {
                            emitter.writeToOutput("this");
                        }
                        emitter.recordSourceMappingEnd(this);
                    }
                    break;
                case 9 /* Null */ :
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("null");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case 4 /* False */ :
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("false");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case 3 /* True */ :
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("true");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case 6 /* Super */ :
                    emitter.recordSourceMappingStart(this);
                    emitter.emitSuperReference();
                    emitter.recordSourceMappingEnd(this);
                    break;
                case 105 /* EndCode */ :
                case 106 /* Error */ :
                case 2 /* EmptyExpr */ :
                    break;
                case 1 /* Empty */ :
                    emitter.recordSourceMappingStart(this);
                    emitter.recordSourceMappingEnd(this);
                    break;
                case 12 /* Void */ :
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("void ");
                    emitter.recordSourceMappingEnd(this);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        AST.prototype.print = function (context) {
            context.startLine();
            var lineCol = {
                line: -1,
                col: -1
            };
            var limLineCol = {
                line: -1,
                col: -1
            };
            if (context.parser !== null) {
                context.parser.getSourceLineCol(lineCol, this.minChar);
                context.parser.getSourceLineCol(limLineCol, this.limChar);
                context.write("(" + lineCol.line + "," + lineCol.col + ")--" + "(" + limLineCol.line + "," + limLineCol.col + "): ");
            }
            var lab = this.printLabel();
            if (TypeScript.hasFlag(this.flags, 8 /* Error */ )) {
                lab += " (Error)";
            }
            context.writeLine(lab);
        };
        AST.prototype.printLabel = function () {
            if (TypeScript.nodeTypeTable[this.nodeType] !== undefined) {
                return TypeScript.nodeTypeTable[this.nodeType];
            } else {
                return (TypeScript.NodeType)._map[this.nodeType];
            }
        };
        AST.prototype.addToControlFlow = function (context) {
            context.walker.options.goChildren = false;
            context.addContent(this);
        };
        AST.prototype.netFreeUses = function (container, freeUses) {
        };
        AST.prototype.treeViewLabel = function () {
            return (TypeScript.NodeType)._map[this.nodeType];
        };
        AST.getResolvedIdentifierName = function getResolvedIdentifierName(name) {
            if (!name) {
                return "";
            }
            var resolved = "";
            var start = 0;
            var i = 0;
            while(i <= name.length - 6) {
                if (name.charAt(i) == '\\' && name.charAt(i + 1) == 'u') {
                    var charCode = parseInt(name.substr(i + 2, 4), 16);
                    resolved += name.substr(start, i - start);
                    resolved += String.fromCharCode(charCode);
                    i += 6;
                    start = i;
                    continue;
                }
                i++;
            }
            resolved += name.substring(start);
            return resolved;
        };
        AST.prototype.getDocComments = function () {
            if (!this.isDeclaration() || !this.preComments || this.preComments.length == 0) {
                return [];
            }
            if (!this.docComments) {
                var preCommentsLength = this.preComments.length;
                var docComments = [];
                for(var i = preCommentsLength - 1; i >= 0; i--) {
                    if (this.preComments[i].isDocComment()) {
                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;
                        if (prevDocComment == null || (this.preComments[i].limLine == prevDocComment.minLine || this.preComments[i].limLine + 1 == prevDocComment.minLine)) {
                            docComments.push(this.preComments[i]);
                            continue;
                        }
                    }
                    break;
                }
                this.docComments = docComments.reverse();
            }
            return this.docComments;
        };
        return AST;
    })(ASTSpan);
    TypeScript.AST = AST;    
    var IncompleteAST = (function (_super) {
        __extends(IncompleteAST, _super);
        function IncompleteAST(min, lim) {
                _super.call(this, 106 /* Error */ );
            this.minChar = min;
            this.limChar = lim;
        }
        return IncompleteAST;
    })(AST);
    TypeScript.IncompleteAST = IncompleteAST;    
    var ASTList = (function (_super) {
        __extends(ASTList, _super);
        function ASTList() {
                _super.call(this, 94 /* List */ );
            this.enclosingScope = null;
            this.members = new Array();
        }
        ASTList.prototype.addToControlFlow = function (context) {
            var len = this.members.length;
            for(var i = 0; i < len; i++) {
                if (context.noContinuation) {
                    context.addUnreachable(this.members[i]);
                    break;
                } else {
                    this.members[i] = context.walk(this.members[i], this);
                }
            }
            context.walker.options.goChildren = false;
        };
        ASTList.prototype.append = function (ast) {
            this.members[this.members.length] = ast;
            return this;
        };
        ASTList.prototype.appendAll = function (ast) {
            if (ast.nodeType == 94 /* List */ ) {
                var list = ast;
                for(var i = 0, len = list.members.length; i < len; i++) {
                    this.append(list.members[i]);
                }
            } else {
                this.append(ast);
            }
            return this;
        };
        ASTList.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascriptList(this, null, 55 /* Semicolon */ , startLine, false, false);
            emitter.recordSourceMappingEnd(this);
        };
        ASTList.prototype.typeCheck = function (typeFlow) {
            var len = this.members.length;
            typeFlow.nestingLevel++;
            for(var i = 0; i < len; i++) {
                if (this.members[i]) {
                    this.members[i] = this.members[i].typeCheck(typeFlow);
                }
            }
            typeFlow.nestingLevel--;
            return this;
        };
        return ASTList;
    })(AST);
    TypeScript.ASTList = ASTList;    
    var Identifier = (function (_super) {
        __extends(Identifier, _super);
        function Identifier(actualText, hasEscapeSequence) {
                _super.call(this, 25 /* Name */ );
            this.actualText = actualText;
            this.hasEscapeSequence = hasEscapeSequence;
            this.sym = null;
            this.cloId = -1;
            this.setText(actualText, hasEscapeSequence);
        }
        Identifier.prototype.setText = function (actualText, hasEscapeSequence) {
            this.actualText = actualText;
            if (hasEscapeSequence) {
                this.text = AST.getResolvedIdentifierName(actualText);
            } else {
                this.text = actualText;
            }
        };
        Identifier.prototype.isMissing = function () {
            return false;
        };
        Identifier.prototype.isLeaf = function () {
            return true;
        };
        Identifier.prototype.treeViewLabel = function () {
            return "id: " + this.actualText;
        };
        Identifier.prototype.printLabel = function () {
            if (this.actualText) {
                return "id: " + this.actualText;
            } else {
                return "name node";
            }
        };
        Identifier.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckName(this);
        };
        Identifier.prototype.emit = function (emitter, tokenId, startLine) {
            if (!emitter.inlineEngine.inline(this, emitter, tokenId, startLine)) {
                emitter.emitJavascriptName(this, true);
            }
        };
        Identifier.fromToken = function fromToken(token) {
            return new Identifier(token.getText(), (token).hasEscapeSequence);
        };
        return Identifier;
    })(AST);
    TypeScript.Identifier = Identifier;    
    var MissingIdentifier = (function (_super) {
        __extends(MissingIdentifier, _super);
        function MissingIdentifier() {
                _super.call(this, "__missing");
        }
        MissingIdentifier.prototype.isMissing = function () {
            return true;
        };
        MissingIdentifier.prototype.emit = function (emitter, tokenId, startLine) {
        };
        return MissingIdentifier;
    })(Identifier);
    TypeScript.MissingIdentifier = MissingIdentifier;    
    var Label = (function (_super) {
        __extends(Label, _super);
        function Label(id) {
                _super.call(this, 101 /* Label */ );
            this.id = id;
        }
        Label.prototype.printLabel = function () {
            return this.id.actualText + ":";
        };
        Label.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.voidType;
            return this;
        };
        Label.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.recordSourceMappingStart(this.id);
            emitter.writeToOutput(this.id.actualText);
            emitter.recordSourceMappingEnd(this.id);
            emitter.writeLineToOutput(":");
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        return Label;
    })(AST);
    TypeScript.Label = Label;    
    var Expression = (function (_super) {
        __extends(Expression, _super);
        function Expression(nodeType) {
                _super.call(this, nodeType);
        }
        Expression.prototype.isExpression = function () {
            return true;
        };
        Expression.prototype.isStatementOrExpression = function () {
            return true;
        };
        return Expression;
    })(AST);
    TypeScript.Expression = Expression;    
    var UnaryExpression = (function (_super) {
        __extends(UnaryExpression, _super);
        function UnaryExpression(nodeType, operand) {
                _super.call(this, nodeType);
            this.operand = operand;
            this.targetType = null;
            this.castTerm = null;
        }
        UnaryExpression.prototype.addToControlFlow = function (context) {
            _super.prototype.addToControlFlow.call(this, context);
            if (this.nodeType == 80 /* Throw */ ) {
                context.returnStmt();
            }
        };
        UnaryExpression.prototype.typeCheck = function (typeFlow) {
            switch(this.nodeType) {
                case 66 /* Not */ :
                    return typeFlow.typeCheckBitNot(this);
                case 67 /* LogNot */ :
                    return typeFlow.typeCheckLogNot(this);
                case 14 /* Pos */ :
                case 15 /* Neg */ :
                    return typeFlow.typeCheckUnaryNumberOperator(this);
                case 70 /* IncPost */ :
                case 68 /* IncPre */ :
                case 71 /* DecPost */ :
                case 69 /* DecPre */ :
                    return typeFlow.typeCheckIncOrDec(this);
                case 10 /* ArrayLit */ :
                    typeFlow.typeCheckArrayLit(this);
                    return this;
                case 11 /* ObjectLit */ :
                    typeFlow.typeCheckObjectLit(this);
                    return this;
                case 80 /* Throw */ :
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.voidType;
                    return this;
                case 23 /* Typeof */ :
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.stringType;
                    return this;
                case 16 /* Delete */ :
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.booleanType;
                    break;
                case 72 /* TypeAssertion */ :
                    this.castTerm = typeFlow.typeCheck(this.castTerm);
                    var applyTargetType = !this.operand.isParenthesized;
                    var targetType = applyTargetType ? this.castTerm.type : null;
                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);
                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);
                    this.type = this.castTerm.type;
                    return this;
                case 12 /* Void */ :
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.checker.undefinedType;
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        };
        UnaryExpression.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            switch(this.nodeType) {
                case 70 /* IncPost */ :
                    emitter.emitJavascript(this.operand, 100 /* PlusPlus */ , false);
                    emitter.writeToOutput("++");
                    break;
                case 67 /* LogNot */ :
                    emitter.writeToOutput("!");
                    emitter.emitJavascript(this.operand, 99 /* Exclamation */ , false);
                    break;
                case 71 /* DecPost */ :
                    emitter.emitJavascript(this.operand, 101 /* MinusMinus */ , false);
                    emitter.writeToOutput("--");
                    break;
                case 11 /* ObjectLit */ :
                    emitter.emitObjectLiteral(this.operand);
                    break;
                case 10 /* ArrayLit */ :
                    emitter.emitArrayLiteral(this.operand);
                    break;
                case 66 /* Not */ :
                    emitter.writeToOutput("~");
                    emitter.emitJavascript(this.operand, 98 /* Tilde */ , false);
                    break;
                case 15 /* Neg */ :
                    emitter.writeToOutput("-");
                    if (this.operand.nodeType == 15 /* Neg */ ) {
                        this.operand.isParenthesized = true;
                    }
                    emitter.emitJavascript(this.operand, 94 /* Minus */ , false);
                    break;
                case 14 /* Pos */ :
                    emitter.writeToOutput("+");
                    if (this.operand.nodeType == 14 /* Pos */ ) {
                        this.operand.isParenthesized = true;
                    }
                    emitter.emitJavascript(this.operand, 93 /* Plus */ , false);
                    break;
                case 68 /* IncPre */ :
                    emitter.writeToOutput("++");
                    emitter.emitJavascript(this.operand, 100 /* PlusPlus */ , false);
                    break;
                case 69 /* DecPre */ :
                    emitter.writeToOutput("--");
                    emitter.emitJavascript(this.operand, 101 /* MinusMinus */ , false);
                    break;
                case 80 /* Throw */ :
                    emitter.writeToOutput("throw ");
                    emitter.emitJavascript(this.operand, 98 /* Tilde */ , false);
                    emitter.writeToOutput(";");
                    break;
                case 23 /* Typeof */ :
                    emitter.writeToOutput("typeof ");
                    emitter.emitJavascript(this.operand, 98 /* Tilde */ , false);
                    break;
                case 16 /* Delete */ :
                    emitter.writeToOutput("delete ");
                    emitter.emitJavascript(this.operand, 98 /* Tilde */ , false);
                    break;
                case 12 /* Void */ :
                    emitter.writeToOutput("void ");
                    emitter.emitJavascript(this.operand, 98 /* Tilde */ , false);
                    break;
                case 72 /* TypeAssertion */ :
                    emitter.emitJavascript(this.operand, 98 /* Tilde */ , false);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        return UnaryExpression;
    })(Expression);
    TypeScript.UnaryExpression = UnaryExpression;    
    var CallExpression = (function (_super) {
        __extends(CallExpression, _super);
        function CallExpression(nodeType, target, typeArguments, arguments) {
                _super.call(this, nodeType);
            this.target = target;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.signature = null;
            this.minChar = this.target.minChar;
        }
        CallExpression.prototype.typeCheck = function (typeFlow) {
            if (this.nodeType == 31 /* New */ ) {
                return typeFlow.typeCheckNew(this);
            } else {
                return typeFlow.typeCheckCall(this);
            }
        };
        CallExpression.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.nodeType == 31 /* New */ ) {
                emitter.emitNew(this.target, this.arguments);
            } else {
                emitter.emitCall(this, this.target, this.arguments);
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        return CallExpression;
    })(Expression);
    TypeScript.CallExpression = CallExpression;    
    var BinaryExpression = (function (_super) {
        __extends(BinaryExpression, _super);
        function BinaryExpression(nodeType, operand1, operand2) {
                _super.call(this, nodeType);
            this.operand1 = operand1;
            this.operand2 = operand2;
        }
        BinaryExpression.prototype.typeCheck = function (typeFlow) {
            switch(this.nodeType) {
                case 19 /* Dot */ :
                    return typeFlow.typeCheckDotOperator(this);
                case 32 /* Asg */ :
                    return typeFlow.typeCheckAsgOperator(this);
                case 58 /* Add */ :
                case 59 /* Sub */ :
                case 60 /* Mul */ :
                case 61 /* Div */ :
                case 62 /* Mod */ :
                case 47 /* Or */ :
                case 49 /* And */ :
                    return typeFlow.typeCheckArithmeticOperator(this, false);
                case 48 /* Xor */ :
                    return typeFlow.typeCheckBitwiseOperator(this, false);
                case 51 /* Ne */ :
                case 50 /* Eq */ :
                    var text;
                    if (typeFlow.checker.styleSettings.eqeqeq) {
                        text = TypeScript.nodeTypeTable[this.nodeType];
                        typeFlow.checker.errorReporter.styleError(this, "use of " + text);
                    } else if (typeFlow.checker.styleSettings.eqnull) {
                        text = TypeScript.nodeTypeTable[this.nodeType];
                        if ((this.operand2 !== null) && (this.operand2.nodeType == 9 /* Null */ )) {
                            typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null");
                        }
                    }
                case 52 /* Eqv */ :
                case 53 /* NEqv */ :
                case 54 /* Lt */ :
                case 55 /* Le */ :
                case 57 /* Ge */ :
                case 56 /* Gt */ :
                    return typeFlow.typeCheckBooleanOperator(this);
                case 29 /* Index */ :
                    return typeFlow.typeCheckIndex(this);
                case 74 /* Member */ :
                    this.type = typeFlow.voidType;
                    return this;
                case 45 /* LogOr */ :
                    return typeFlow.typeCheckLogOr(this);
                case 46 /* LogAnd */ :
                    return typeFlow.typeCheckLogAnd(this);
                case 33 /* AsgAdd */ :
                case 34 /* AsgSub */ :
                case 36 /* AsgMul */ :
                case 35 /* AsgDiv */ :
                case 37 /* AsgMod */ :
                case 40 /* AsgOr */ :
                case 38 /* AsgAnd */ :
                    return typeFlow.typeCheckArithmeticOperator(this, true);
                case 39 /* AsgXor */ :
                    return typeFlow.typeCheckBitwiseOperator(this, true);
                case 63 /* Lsh */ :
                case 64 /* Rsh */ :
                case 65 /* Rs2 */ :
                    return typeFlow.typeCheckShift(this, false);
                case 41 /* AsgLsh */ :
                case 42 /* AsgRsh */ :
                case 43 /* AsgRs2 */ :
                    return typeFlow.typeCheckShift(this, true);
                case 13 /* Comma */ :
                    return typeFlow.typeCheckCommaOperator(this);
                case 22 /* InstOf */ :
                    return typeFlow.typeCheckInstOf(this);
                case 18 /* In */ :
                    return typeFlow.typeCheckInOperator(this);
                case 20 /* From */ :
                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of 'from' keyword in binary expression");
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        };
        BinaryExpression.prototype.emit = function (emitter, tokenId, startLine) {
            var binTokenId = TypeScript.nodeTypeToTokTable[this.nodeType];
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.nodeType != 13 /* Comma */  && binTokenId != undefined) {
                var isPrinted = false;
                var pGetterSymbol = null;
                var pGetter = null;
                var op1 = this.operand1;
                var isSetter = false;
                if (this.operand1.nodeType === 19 /* Dot */  && (this.operand1).operand2.nodeType == 25 /* Name */ ) {
                    var id = (this.operand1).operand2;
                    var target = (this.operand1);
                    if (TypeScript.isDefAndNotNull(id.sym) && id.sym.isAccessor()) {
                        var isSetter = binTokenId === TypeScript.TokenID.Equals;
                        var sym = isSetter? (id.sym).setter: (id.sym).getter;
                        var funcDecl = sym ? (sym.declAST) : null;
                        pGetterSymbol = id.sym;
                        pGetter = pGetterSymbol.declAST;
                        pGetterSymbol.declAST = null;
                        if (!TypeScript.isNull(funcDecl) && funcDecl.isInline() && emitter.inlineEngine.inlineFunction(emitter, target, funcDecl, this.operand2)) {
                            isPrinted = true;
                        }
                    }
                }
                if (!isPrinted || !isSetter) {
                    if (!isPrinted) emitter.emitJavascript(this.operand1, binTokenId, false);

                    if (!TypeScript.isNull(pGetter)) {
                        pGetterSymbol.declAST = pGetter;
                    }
                    if (TypeScript.tokenTable[binTokenId].text == "instanceof") {
                        emitter.writeToOutput(" instanceof ");
                    } else if (TypeScript.tokenTable[binTokenId].text == "in") {
                        emitter.writeToOutput(" in ");
                    } else {
                        emitter.writeToOutputTrimmable(" " + TypeScript.tokenTable[binTokenId].text + " ");
                    }
                    emitter.emitJavascript(this.operand2, binTokenId, false);
                }
            } else {
                switch(this.nodeType) {
                    case 19 /* Dot */ :
                        if (!emitter.tryEmitConstant(this)) {
                            var id = this.operand2;
                            if (TypeScript.isDefAndNotNull(id.sym) && id.sym.isAccessor()) {
                                var funcDecl = id.sym.declAST;
                                if (!TypeScript.isNull(funcDecl) && funcDecl.isInline() && emitter.inlineEngine.inlineFunction(emitter, this, funcDecl)) {
                                    break;
                                }
                            }
                            emitter.emitJavascript(this.operand1, 102 /* Dot */ , false);
                            emitter.writeToOutput(".");
                            emitter.emitJavascriptName(this.operand2, false);
                        }
                        break;
                    case 29 /* Index */ :
                        emitter.emitIndex(this.operand1, this.operand2);
                        break;
                    case 74 /* Member */ :
                        if (this.operand2.nodeType == 73 /* FuncDecl */  && (this.operand2).isAccessor()) {
                            var funcDecl = this.operand2;
                            if (TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ )) {
                                emitter.writeToOutput("get ");
                            } else {
                                emitter.writeToOutput("set ");
                            }
                            emitter.emitJavascript(this.operand1, 76 /* Colon */ , false);
                        } else {
                            emitter.emitJavascript(this.operand1, 76 /* Colon */ , false);
                            emitter.writeToOutputTrimmable(": ");
                        }
                        emitter.emitJavascript(this.operand2, 62 /* Comma */ , false);
                        break;
                    case 13 /* Comma */ :
                        emitter.emitJavascript(this.operand1, 62 /* Comma */ , false);
                        if (emitter.emitState.inObjectLiteral) {
                            emitter.writeLineToOutput(", ");
                        } else {
                            emitter.writeToOutput(", ");
                        }
                        emitter.emitJavascript(this.operand2, 62 /* Comma */ , false);
                        break;
                    case 21 /* Is */ :
                        throw new Error("should be de-sugared during type check");
                    default:
                        throw new Error("please implement in derived class");
                }
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        BinaryExpression.prototype.printLabel = function () {
            if (this.nodeType === 19 /* Dot */ ) {
                return "{" + this.operand1.printLabel() + "}.{" + this.operand2.printLabel() + "}";
            }
            return _super.prototype.printLabel.call(this);
        };
        return BinaryExpression;
    })(Expression);
    TypeScript.BinaryExpression = BinaryExpression;    
    var ConditionalExpression = (function (_super) {
        __extends(ConditionalExpression, _super);
        function ConditionalExpression(operand1, operand2, operand3) {
                _super.call(this, 44 /* ConditionalExpression */ );
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.operand3 = operand3;
        }
        ConditionalExpression.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckQMark(this);
        };
        ConditionalExpression.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.operand1, 75 /* Question */ , false);
            emitter.writeToOutput(" ? ");
            emitter.emitJavascript(this.operand2, 75 /* Question */ , false);
            emitter.writeToOutput(" : ");
            emitter.emitJavascript(this.operand3, 75 /* Question */ , false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        return ConditionalExpression;
    })(Expression);
    TypeScript.ConditionalExpression = ConditionalExpression;    
    var NumberLiteral = (function (_super) {
        __extends(NumberLiteral, _super);
        function NumberLiteral(value, text) {
                _super.call(this, 24 /* NumberLit */ );
            this.value = value;
            this.text = text;
        }
        NumberLiteral.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.doubleType;
            return this;
        };
        NumberLiteral.prototype.treeViewLabel = function () {
            return "num: " + this.printLabel();
        };
        NumberLiteral.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        NumberLiteral.prototype.printLabel = function () {
            return this.text;
        };
        return NumberLiteral;
    })(Expression);
    TypeScript.NumberLiteral = NumberLiteral;    
    var RegexLiteral = (function (_super) {
        __extends(RegexLiteral, _super);
        function RegexLiteral(text) {
                _super.call(this, 8 /* Regex */ );
            this.text = text;
        }
        RegexLiteral.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.regexType;
            return this;
        };
        RegexLiteral.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        return RegexLiteral;
    })(Expression);
    TypeScript.RegexLiteral = RegexLiteral;    
    var StringLiteral = (function (_super) {
        __extends(StringLiteral, _super);
        function StringLiteral(text) {
                _super.call(this, 7 /* QString */ );
            this.text = text;
        }
        StringLiteral.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitStringLiteral(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        StringLiteral.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.stringType;
            return this;
        };
        StringLiteral.prototype.treeViewLabel = function () {
            return "st: " + this.text;
        };
        StringLiteral.prototype.printLabel = function () {
            return this.text;
        };
        return StringLiteral;
    })(Expression);
    TypeScript.StringLiteral = StringLiteral;    
    var ModuleElement = (function (_super) {
        __extends(ModuleElement, _super);
        function ModuleElement(nodeType) {
                _super.call(this, nodeType);
        }
        return ModuleElement;
    })(AST);
    TypeScript.ModuleElement = ModuleElement;    
    var ImportDeclaration = (function (_super) {
        __extends(ImportDeclaration, _super);
        function ImportDeclaration(id, alias) {
                _super.call(this, 99 /* ImportDeclaration */ );
            this.id = id;
            this.alias = alias;
            this.varFlags = 0 /* None */ ;
            this.isDynamicImport = false;
        }
        ImportDeclaration.prototype.isStatementOrExpression = function () {
            return true;
        };
        ImportDeclaration.prototype.isDeclaration = function () {
            return true;
        };
        ImportDeclaration.prototype.emit = function (emitter, tokenId, startLine) {
            var mod = this.alias.type;
            if (!this.isDynamicImport || (this.id.sym && !(this.id.sym).onlyReferencedAsTypeRef)) {
                var prevModAliasId = emitter.modAliasId;
                var prevFirstModAlias = emitter.firstModAlias;
                emitter.recordSourceMappingStart(this);
                emitter.emitParensAndCommentsInPlace(this, true);
                emitter.writeToOutput("var " + this.id.actualText + " = ");
                emitter.modAliasId = this.id.actualText;
                emitter.firstModAlias = this.firstAliasedModToString();
                emitter.emitJavascript(this.alias, 98 /* Tilde */ , false);
                if (!this.isDynamicImport) {
                    emitter.writeToOutput(";");
                }
                emitter.emitParensAndCommentsInPlace(this, false);
                emitter.recordSourceMappingEnd(this);
                emitter.modAliasId = prevModAliasId;
                emitter.firstModAlias = prevFirstModAlias;
            }
        };
        ImportDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckImportDecl(this);
        };
        ImportDeclaration.prototype.getAliasName = function (aliasAST) {
            if (typeof aliasAST === "undefined") { aliasAST = this.alias; }
            if (aliasAST.nodeType == 25 /* Name */ ) {
                return (aliasAST).actualText;
            } else {
                var dotExpr = aliasAST;
                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);
            }
        };
        ImportDeclaration.prototype.firstAliasedModToString = function () {
            if (this.alias.nodeType == 25 /* Name */ ) {
                return (this.alias).actualText;
            } else {
                var dotExpr = this.alias;
                var firstMod = dotExpr.operand1;
                return firstMod.actualText;
            }
        };
        return ImportDeclaration;
    })(ModuleElement);
    TypeScript.ImportDeclaration = ImportDeclaration;    
    var BoundDecl = (function (_super) {
        __extends(BoundDecl, _super);
        function BoundDecl(id, nodeType, nestingLevel) {
                _super.call(this, nodeType);
            this.id = id;
            this.nestingLevel = nestingLevel;
            this.init = null;
            this.typeExpr = null;
            this.varFlags = 0 /* None */ ;
            this.sym = null;
        }
        BoundDecl.prototype.isDeclaration = function () {
            return true;
        };
        BoundDecl.prototype.isStatementOrExpression = function () {
            return true;
        };
        BoundDecl.prototype.isPrivate = function () {
            return TypeScript.hasFlag(this.varFlags, 2 /* Private */ );
        };
        BoundDecl.prototype.isPublic = function () {
            return TypeScript.hasFlag(this.varFlags, 4 /* Public */ );
        };
        BoundDecl.prototype.isProperty = function () {
            return TypeScript.hasFlag(this.varFlags, 512 /* Property */ );
        };
        BoundDecl.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckBoundDecl(this);
        };
        BoundDecl.prototype.printLabel = function () {
            return this.treeViewLabel();
        };
        return BoundDecl;
    })(AST);
    TypeScript.BoundDecl = BoundDecl;    
    var VarDecl = (function (_super) {
        __extends(VarDecl, _super);
        function VarDecl(id, nest) {
                _super.call(this, id, 75 /* VarDecl */ , nest);
        }
        VarDecl.prototype.isAmbient = function () {
            return TypeScript.hasFlag(this.varFlags, 8 /* Ambient */ );
        };
        VarDecl.prototype.isExported = function () {
            return TypeScript.hasFlag(this.varFlags, 1 /* Exported */ );
        };
        VarDecl.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.varFlags, 16 /* Static */ );
        };
        VarDecl.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitJavascriptVarDecl(this, tokenId);
        };
        VarDecl.prototype.treeViewLabel = function () {
            return "var " + this.id.actualText;
        };
        return VarDecl;
    })(BoundDecl);
    TypeScript.VarDecl = VarDecl;    
    var ArgDecl = (function (_super) {
        __extends(ArgDecl, _super);
        function ArgDecl(id) {
                _super.call(this, id, 76 /* ArgDecl */ , 0);
            this.isOptional = false;
            this.parameterPropertySym = null;
        }
        ArgDecl.prototype.isOptionalArg = function () {
            return this.isOptional || this.init;
        };
        ArgDecl.prototype.treeViewLabel = function () {
            return "arg: " + this.id.actualText;
        };
        ArgDecl.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.id.actualText);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        return ArgDecl;
    })(BoundDecl);
    TypeScript.ArgDecl = ArgDecl;    
    var internalId = 0;
    var FuncDecl = (function (_super) {
        __extends(FuncDecl, _super);
        function FuncDecl(name, bod, isConstructor, typeArguments, arguments, vars, scopes, statics, nodeType) {
                _super.call(this, nodeType);
            this.name = name;
            this.bod = bod;
            this.isConstructor = isConstructor;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.vars = vars;
            this.scopes = scopes;
            this.statics = statics;
            this.hint = null;
            this.fncFlags = 0 /* None */ ;
            this.returnTypeAnnotation = null;
            this.variableArgList = false;
            this.jumpRefs = null;
            this.internalNameCache = null;
            this.tmp1Declared = false;
            this.enclosingFnc = null;
            this.freeVariables = [];
            this.unitIndex = -1;
            this.classDecl = null;
            this.boundToProperty = null;
            this.isOverload = false;
            this.innerStaticFuncs = [];
            this.isInlineCallLiteral = false;
            this.accessorSymbol = null;
            this.leftCurlyCount = 0;
            this.rightCurlyCount = 0;
            this.returnStatementsWithExpressions = [];
            this.scopeType = null;
            this.endingToken = null;
            this.constructorSpan = null;
        }
        FuncDecl.prototype.isDeclaration = function () {
            return true;
        };
        FuncDecl.prototype.internalName = function () {
            if (this.internalNameCache == null) {
                var extName = this.getNameText();
                if (extName) {
                    this.internalNameCache = "_internal_" + extName;
                } else {
                    this.internalNameCache = "_internal_" + internalId++;
                }
            }
            return this.internalNameCache;
        };
        FuncDecl.prototype.hasSelfReference = function () {
            return TypeScript.hasFlag(this.fncFlags, 16384 /* HasSelfReference */ );
        };
        FuncDecl.prototype.setHasSelfReference = function () {
            this.fncFlags |= 16384 /* HasSelfReference */ ;
        };
        FuncDecl.prototype.hasSuperReferenceInFatArrowFunction = function () {
            return TypeScript.hasFlag(this.fncFlags, 1048576 /* HasSuperReferenceInFatArrowFunction */ );
        };
        FuncDecl.prototype.setHasSuperReferenceInFatArrowFunction = function () {
            this.fncFlags |= 1048576 /* HasSuperReferenceInFatArrowFunction */ ;
        };
        FuncDecl.prototype.addCloRef = function (id, sym) {
            if (this.envids == null) {
                this.envids = new Array();
            }
            this.envids[this.envids.length] = id;
            var outerFnc = this.enclosingFnc;
            if (sym) {
                while(outerFnc && (outerFnc.type.symbol != sym.container)) {
                    outerFnc.addJumpRef(sym);
                    outerFnc = outerFnc.enclosingFnc;
                }
            }
            return this.envids.length - 1;
        };
        FuncDecl.prototype.addJumpRef = function (sym) {
            if (this.jumpRefs == null) {
                this.jumpRefs = new Array();
            }
            var id = new Identifier(sym.name);
            this.jumpRefs[this.jumpRefs.length] = id;
            id.sym = sym;
            id.cloId = this.addCloRef(id, null);
        };
        FuncDecl.prototype.buildControlFlow = function () {
            var entry = new TypeScript.BasicBlock();
            var exit = new TypeScript.BasicBlock();
            var context = new TypeScript.ControlFlowContext(entry, exit);
            var controlFlowPrefix = function (ast, parent, walker) {
                ast.addToControlFlow(walker.state);
                return ast;
            };
            var walker = TypeScript.getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);
            context.walker = walker;
            walker.walk(this.bod, this);
            return context;
        };
        FuncDecl.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckFunction(this);
        };
        FuncDecl.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitJavascriptFunction(this);
        };
        FuncDecl.prototype.getNameText = function () {
            if (this.name) {
                return this.name.actualText;
            } else {
                return this.hint;
            }
        };
        FuncDecl.prototype.isMethod = function () {
            return (this.fncFlags & 1024 /* Method */ ) != 0 /* None */ ;
        };
        FuncDecl.prototype.isCallMember = function () {
            return TypeScript.hasFlag(this.fncFlags, 4096 /* CallMember */ );
        };
        FuncDecl.prototype.isConstructMember = function () {
            return TypeScript.hasFlag(this.fncFlags, 8192 /* ConstructMember */ );
        };
        FuncDecl.prototype.isIndexerMember = function () {
            return TypeScript.hasFlag(this.fncFlags, 65536 /* IndexerMember */ );
        };
        FuncDecl.prototype.isSpecialFn = function () {
            return this.isCallMember() || this.isIndexerMember() || this.isConstructMember();
        };
        FuncDecl.prototype.isAnonymousFn = function () {
            return this.name === null;
        };
        FuncDecl.prototype.isAccessor = function () {
            return TypeScript.hasFlag(this.fncFlags, 64 /* GetAccessor */ ) || TypeScript.hasFlag(this.fncFlags, 128 /* SetAccessor */ );
        };
        FuncDecl.prototype.isGetAccessor = function () {
            return TypeScript.hasFlag(this.fncFlags, 64 /* GetAccessor */ );
        };
        FuncDecl.prototype.isSetAccessor = function () {
            return TypeScript.hasFlag(this.fncFlags, 128 /* SetAccessor */ );
        };
        FuncDecl.prototype.isAmbient = function () {
            return TypeScript.hasFlag(this.fncFlags, 8 /* Ambient */ );
        };
        FuncDecl.prototype.isExported = function () {
            return TypeScript.hasFlag(this.fncFlags, 1 /* Exported */ );
        };
        FuncDecl.prototype.isPrivate = function () {
            return TypeScript.hasFlag(this.fncFlags, 2 /* Private */ );
        };
        FuncDecl.prototype.isPublic = function () {
            return TypeScript.hasFlag(this.fncFlags, 4 /* Public */ );
        };
        FuncDecl.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.fncFlags, 16 /* Static */ );
        };
        FuncDecl.prototype.isInline = function () {
            return TypeScript.hasFlag(this.fncFlags, 4194304 /* Inline */ );
        };
        FuncDecl.prototype.treeViewLabel = function () {
            if (this.name == null) {
                return "funcExpr";
            } else {
                return "func: " + this.name.actualText;
            }
        };
        FuncDecl.prototype.ClearFlags = function () {
            this.fncFlags = 0 /* None */ ;
        };
        FuncDecl.prototype.isSignature = function () {
            return (this.fncFlags & 512 /* Signature */ ) != 0 /* None */ ;
        };
        return FuncDecl;
    })(AST);
    TypeScript.FuncDecl = FuncDecl;    
    var LocationInfo = (function () {
        function LocationInfo(filename, lineMap, unitIndex) {
            this.filename = filename;
            this.lineMap = lineMap;
            this.unitIndex = unitIndex;
        }
        return LocationInfo;
    })();
    TypeScript.LocationInfo = LocationInfo;    
    TypeScript.unknownLocationInfo = new LocationInfo("unknown", null, -1);
    var Script = (function (_super) {
        __extends(Script, _super);
        function Script(vars, scopes) {
                _super.call(this, new Identifier("script"), null, false, null, null, vars, scopes, null, 95 /* Script */ );
            this.locationInfo = null;
            this.referencedFiles = [];
            this.requiresGlobal = false;
            this.requiresExtendsBlock = false;
            this.isResident = false;
            this.isDeclareFile = false;
            this.hasBeenTypeChecked = false;
            this.topLevelMod = null;
            this.leftCurlyCount = 0;
            this.rightCurlyCount = 0;
            this.containsUnicodeChar = false;
            this.containsUnicodeCharInComment = false;
            this.externallyVisibleImportedSymbols = [];
            this.vars = vars;
        }
        Script.prototype.setCachedEmitRequired = function (value) {
            this.cachedEmitRequired = value;
            return this.cachedEmitRequired;
        };
        Script.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckScript(this);
        };
        Script.prototype.treeViewLabel = function () {
            return "Script";
        };
        Script.prototype.emitRequired = function (emitOptions) {
            if (this.cachedEmitRequired != undefined) {
                return this.cachedEmitRequired;
            }
            if (!this.isDeclareFile && !this.isResident && this.bod) {
                if (this.bod.members.length == 0) {
                    return this.setCachedEmitRequired(true);
                }
                for(var i = 0, len = this.bod.members.length; i < len; i++) {
                    var stmt = this.bod.members[i];
                    if (stmt.nodeType == 98 /* ModuleDeclaration */ ) {
                        if (!TypeScript.hasFlag((stmt).modFlags, 512 /* ShouldEmitModuleDecl */  | 8 /* Ambient */ )) {
                            return this.setCachedEmitRequired(true);
                        }
                    } else if (stmt.nodeType == 96 /* ClassDeclaration */ ) {
                        if (!TypeScript.hasFlag((stmt).varFlags, 8 /* Ambient */ )) {
                            return this.setCachedEmitRequired(true);
                        }
                    } else if (stmt.nodeType == 75 /* VarDecl */ ) {
                        if (!TypeScript.hasFlag((stmt).varFlags, 8 /* Ambient */ )) {
                            return this.setCachedEmitRequired(true);
                        }
                    } else if (stmt.nodeType == 73 /* FuncDecl */ ) {
                        if (!(stmt).isSignature()) {
                            return this.setCachedEmitRequired(true);
                        }
                    } else if (stmt.nodeType != 97 /* InterfaceDeclaration */  && stmt.nodeType != 1 /* Empty */ ) {
                        return this.setCachedEmitRequired(true);
                    }
                }
                if (emitOptions.emitComments && ((this.bod.preComments && this.bod.preComments.length > 0) || (this.bod.postComments && this.bod.postComments.length > 0))) {
                    return this.setCachedEmitRequired(true);
                }
            }
            return this.setCachedEmitRequired(false);
        };
        Script.prototype.emit = function (emitter, tokenId, startLine) {
            if (this.emitRequired(emitter.emitOptions)) {
                emitter.emitJavascriptList(this.bod, null, 55 /* Semicolon */ , true, false, false, true, this.requiresExtendsBlock);
            }
        };
        Script.prototype.AddExternallyVisibleImportedSymbol = function (symbol, checker) {
            if (this.isExternallyVisibleSymbol(symbol)) {
                return;
            }
            if (!symbol.getType().symbol.isExternallyVisible(checker)) {
                var quotes = "";
                var moduleName = symbol.getType().symbol.prettyName;
                if (!TypeScript.isQuoted(moduleName)) {
                    quotes = "'";
                }
                checker.errorReporter.simpleError(symbol.declAST, "Externally visible import statement uses non exported module " + quotes + moduleName + quotes);
            }
            this.externallyVisibleImportedSymbols.push(symbol);
        };
        Script.prototype.isExternallyVisibleSymbol = function (symbol) {
            for(var i = 0; i < this.externallyVisibleImportedSymbols.length; i++) {
                if (this.externallyVisibleImportedSymbols[i] == symbol) {
                    return true;
                }
            }
            return false;
        };
        return Script;
    })(FuncDecl);
    TypeScript.Script = Script;    
    var NamedDeclaration = (function (_super) {
        __extends(NamedDeclaration, _super);
        function NamedDeclaration(nodeType, name, members) {
                _super.call(this, nodeType);
            this.name = name;
            this.members = members;
            this.leftCurlyCount = 0;
            this.rightCurlyCount = 0;
        }
        NamedDeclaration.prototype.isDeclaration = function () {
            return true;
        };
        return NamedDeclaration;
    })(ModuleElement);
    TypeScript.NamedDeclaration = NamedDeclaration;    
    var ModuleDeclaration = (function (_super) {
        __extends(ModuleDeclaration, _super);
        function ModuleDeclaration(name, members, vars, endingToken) {
                _super.call(this, 98 /* ModuleDeclaration */ , name, members);
            this.endingToken = endingToken;
            this.modFlags = 512 /* ShouldEmitModuleDecl */ ;
            this.amdDependencies = [];
            this.containsUnicodeChar = false;
            this.containsUnicodeCharInComment = false;
            this.vars = vars;
            this.prettyName = this.name.actualText;
        }
        ModuleDeclaration.prototype.isExported = function () {
            return TypeScript.hasFlag(this.modFlags, 1 /* Exported */ );
        };
        ModuleDeclaration.prototype.isAmbient = function () {
            return TypeScript.hasFlag(this.modFlags, 8 /* Ambient */ );
        };
        ModuleDeclaration.prototype.isEnum = function () {
            return TypeScript.hasFlag(this.modFlags, 256 /* IsEnum */ );
        };
        ModuleDeclaration.prototype.isWholeFile = function () {
            return TypeScript.hasFlag(this.modFlags, 1024 /* IsWholeFile */ );
        };
        ModuleDeclaration.prototype.recordNonInterface = function () {
            this.modFlags &= ~512 /* ShouldEmitModuleDecl */ ;
        };
        ModuleDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckModule(this);
        };
        ModuleDeclaration.prototype.emit = function (emitter, tokenId, startLine) {
            if (!TypeScript.hasFlag(this.modFlags, 512 /* ShouldEmitModuleDecl */ )) {
                emitter.emitParensAndCommentsInPlace(this, true);
                emitter.emitJavascriptModule(this);
                emitter.emitParensAndCommentsInPlace(this, false);
            }
        };
        return ModuleDeclaration;
    })(NamedDeclaration);
    TypeScript.ModuleDeclaration = ModuleDeclaration;    
    var TypeDeclaration = (function (_super) {
        __extends(TypeDeclaration, _super);
        function TypeDeclaration(nodeType, name, typeParameters, extendsList, implementsList, members) {
                _super.call(this, nodeType, name, members);
            this.typeParameters = typeParameters;
            this.extendsList = extendsList;
            this.implementsList = implementsList;
            this.varFlags = 0 /* None */ ;
        }
        TypeDeclaration.prototype.isExported = function () {
            return TypeScript.hasFlag(this.varFlags, 1 /* Exported */ );
        };
        TypeDeclaration.prototype.isAmbient = function () {
            return TypeScript.hasFlag(this.varFlags, 8 /* Ambient */ );
        };
        return TypeDeclaration;
    })(NamedDeclaration);
    TypeScript.TypeDeclaration = TypeDeclaration;    
    var ClassDeclaration = (function (_super) {
        __extends(ClassDeclaration, _super);
        function ClassDeclaration(name, typeParameters, members, extendsList, implementsList) {
                _super.call(this, 96 /* ClassDeclaration */ , name, typeParameters, extendsList, implementsList, members);
            this.knownMemberNames = {};
            this.constructorDecl = null;
            this.constructorNestingLevel = 0;
            this.endingToken = null;
        }
        ClassDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckClass(this);
        };
        ClassDeclaration.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitJavascriptClass(this);
        };
        return ClassDeclaration;
    })(TypeDeclaration);
    TypeScript.ClassDeclaration = ClassDeclaration;    
    var InterfaceDeclaration = (function (_super) {
        __extends(InterfaceDeclaration, _super);
        function InterfaceDeclaration(name, typeParameters, members, extendsList, implementsList) {
                _super.call(this, 97 /* InterfaceDeclaration */ , name, typeParameters, extendsList, implementsList, members);
        }
        InterfaceDeclaration.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckInterface(this);
        };
        InterfaceDeclaration.prototype.emit = function (emitter, tokenId, startLine) {
        };
        return InterfaceDeclaration;
    })(TypeDeclaration);
    TypeScript.InterfaceDeclaration = InterfaceDeclaration;    
    var Statement = (function (_super) {
        __extends(Statement, _super);
        function Statement(nodeType) {
                _super.call(this, nodeType);
            this.flags |= 64 /* IsStatement */ ;
        }
        Statement.prototype.isLoop = function () {
            return false;
        };
        Statement.prototype.isStatementOrExpression = function () {
            return true;
        };
        Statement.prototype.isCompoundStatement = function () {
            return this.isLoop();
        };
        Statement.prototype.typeCheck = function (typeFlow) {
            this.type = typeFlow.voidType;
            return this;
        };
        return Statement;
    })(ModuleElement);
    TypeScript.Statement = Statement;    
    var LabeledStatement = (function (_super) {
        __extends(LabeledStatement, _super);
        function LabeledStatement(labels, stmt) {
                _super.call(this, 102 /* LabeledStatement */ );
            this.labels = labels;
            this.stmt = stmt;
        }
        LabeledStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.labels) {
                var labelsLen = this.labels.members.length;
                for(var i = 0; i < labelsLen; i++) {
                    this.labels.members[i].emit(emitter, tokenId, startLine);
                }
            }
            this.stmt.emit(emitter, tokenId, true);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        LabeledStatement.prototype.typeCheck = function (typeFlow) {
            typeFlow.typeCheck(this.labels);
            this.stmt = this.stmt.typeCheck(typeFlow);
            return this;
        };
        LabeledStatement.prototype.addToControlFlow = function (context) {
            var beforeBB = context.current;
            var bb = new TypeScript.BasicBlock();
            context.current = bb;
            beforeBB.addSuccessor(bb);
        };
        return LabeledStatement;
    })(Statement);
    TypeScript.LabeledStatement = LabeledStatement;    
    var Block = (function (_super) {
        __extends(Block, _super);
        function Block(statements, isStatementBlock) {
                _super.call(this, 86 /* Block */ );
            this.statements = statements;
            this.isStatementBlock = isStatementBlock;
        }
        Block.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.isStatementBlock) {
                emitter.writeLineToOutput(" {");
                emitter.indenter.increaseIndent();
            } else {
                emitter.setInVarBlock(this.statements.members.length);
            }
            var temp = emitter.setInObjectLiteral(false);
            if (this.statements) {
                emitter.emitJavascriptList(this.statements, null, 55 /* Semicolon */ , true, false, false);
            }
            if (this.isStatementBlock) {
                emitter.indenter.decreaseIndent();
                emitter.emitIndent();
                emitter.writeToOutput("}");
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        Block.prototype.addToControlFlow = function (context) {
            var afterIfNeeded = new TypeScript.BasicBlock();
            context.pushStatement(this, context.current, afterIfNeeded);
            if (this.statements) {
                context.walk(this.statements, this);
            }
            context.walker.options.goChildren = false;
            context.popStatement();
            if (afterIfNeeded.predecessors.length > 0) {
                context.current.addSuccessor(afterIfNeeded);
                context.current = afterIfNeeded;
            }
        };
        Block.prototype.typeCheck = function (typeFlow) {
            if (!typeFlow.checker.styleSettings.emptyBlocks) {
                if ((this.statements === null) || (this.statements.members.length == 0)) {
                    typeFlow.checker.errorReporter.styleError(this, "empty block");
                }
            }
            typeFlow.typeCheck(this.statements);
            return this;
        };
        return Block;
    })(Statement);
    TypeScript.Block = Block;    
    var Jump = (function (_super) {
        __extends(Jump, _super);
        function Jump(nodeType) {
                _super.call(this, nodeType);
            this.target = null;
            this.resolvedTarget = null;
        }
        Jump.prototype.hasExplicitTarget = function () {
            return (this.target);
        };
        Jump.prototype.setResolvedTarget = function (parser, stmt) {
            if (stmt.isLoop()) {
                this.resolvedTarget = stmt;
                return true;
            }
            if (this.nodeType === 79 /* Continue */ ) {
                parser.reportParseError("continue statement applies only to loops");
                return false;
            } else {
                if ((stmt.nodeType == 88 /* Switch */ ) || this.hasExplicitTarget()) {
                    this.resolvedTarget = stmt;
                    return true;
                } else {
                    parser.reportParseError("break statement with no label can apply only to a loop or switch statement");
                    return false;
                }
            }
        };
        Jump.prototype.addToControlFlow = function (context) {
            _super.prototype.addToControlFlow.call(this, context);
            context.unconditionalBranch(this.resolvedTarget, (this.nodeType == 79 /* Continue */ ));
        };
        Jump.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.nodeType == 78 /* Break */ ) {
                emitter.writeToOutput("break");
            } else {
                emitter.writeToOutput("continue");
            }
            if (this.hasExplicitTarget()) {
                emitter.writeToOutput(" " + this.target);
            }
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(";");
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        return Jump;
    })(Statement);
    TypeScript.Jump = Jump;    
    var WhileStatement = (function (_super) {
        __extends(WhileStatement, _super);
        function WhileStatement(cond) {
                _super.call(this, 84 /* While */ );
            this.cond = cond;
            this.body = null;
        }
        WhileStatement.prototype.isLoop = function () {
            return true;
        };
        WhileStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("while(");
            emitter.emitJavascript(this.cond, 53 /* While */ , false);
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, false);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        WhileStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckWhile(this);
        };
        WhileStatement.prototype.addToControlFlow = function (context) {
            var loopHeader = context.current;
            var loopStart = new TypeScript.BasicBlock();
            var afterLoop = new TypeScript.BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            context.addContent(this.cond);
            var condBlock = context.current;
            var targetInfo = null;
            if (this.body) {
                context.current = new TypeScript.BasicBlock();
                condBlock.addSuccessor(context.current);
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
            }
            context.current = afterLoop;
            condBlock.addSuccessor(afterLoop);
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        };
        return WhileStatement;
    })(Statement);
    TypeScript.WhileStatement = WhileStatement;    
    var DoWhileStatement = (function (_super) {
        __extends(DoWhileStatement, _super);
        function DoWhileStatement() {
                _super.call(this, 85 /* DoWhile */ );
            this.body = null;
            this.whileAST = null;
            this.cond = null;
        }
        DoWhileStatement.prototype.isLoop = function () {
            return true;
        };
        DoWhileStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("do");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.recordSourceMappingStart(this.whileAST);
            emitter.writeToOutput(" while");
            emitter.recordSourceMappingEnd(this.whileAST);
            emitter.writeToOutput('(');
            emitter.emitJavascript(this.cond, 57 /* CloseParen */ , false);
            emitter.writeToOutput(")");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(";");
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        DoWhileStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckDoWhile(this);
        };
        DoWhileStatement.prototype.addToControlFlow = function (context) {
            var loopHeader = context.current;
            var loopStart = new TypeScript.BasicBlock();
            var afterLoop = new TypeScript.BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            var targetInfo = null;
            if (this.body) {
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
                context.addContent(this.cond);
                context.current = afterLoop;
                loopEnd.addSuccessor(afterLoop);
            } else {
                context.addUnreachable(this.cond);
            }
            context.walker.options.goChildren = false;
        };
        return DoWhileStatement;
    })(Statement);
    TypeScript.DoWhileStatement = DoWhileStatement;    
    var IfStatement = (function (_super) {
        __extends(IfStatement, _super);
        function IfStatement(cond) {
                _super.call(this, 83 /* If */ );
            this.cond = cond;
            this.elseBod = null;
            this.statement = new ASTSpan();
        }
        IfStatement.prototype.isCompoundStatement = function () {
            return true;
        };
        IfStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("if (");
            emitter.emitJavascript(this.cond, 23 /* If */ , false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascriptStatements(this.thenBod, true);
            if (this.elseBod) {
                if (this.elseBod.nodeType === 83 /* If */ ) {
                    emitter.writeToOutput(" else ");
                    this.elseBod.emit(emitter, tokenId, false);
                } else {
                    emitter.writeToOutput(" else");
                    emitter.emitJavascriptStatements(this.elseBod, true);
                }
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        IfStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckIf(this);
        };
        IfStatement.prototype.addToControlFlow = function (context) {
            this.cond.addToControlFlow(context);
            var afterIf = new TypeScript.BasicBlock();
            var beforeIf = context.current;
            context.pushStatement(this, beforeIf, afterIf);
            var hasContinuation = false;
            context.current = new TypeScript.BasicBlock();
            beforeIf.addSuccessor(context.current);
            context.walk(this.thenBod, this);
            if (!context.noContinuation) {
                hasContinuation = true;
                context.current.addSuccessor(afterIf);
            }
            if (this.elseBod) {
                context.current = new TypeScript.BasicBlock();
                context.noContinuation = false;
                beforeIf.addSuccessor(context.current);
                context.walk(this.elseBod, this);
                if (!context.noContinuation) {
                    hasContinuation = true;
                    context.current.addSuccessor(afterIf);
                } else {
                    if (hasContinuation) {
                        context.noContinuation = false;
                    }
                }
            } else {
                beforeIf.addSuccessor(afterIf);
                context.noContinuation = false;
                hasContinuation = true;
            }
            var targetInfo = context.popStatement();
            if (afterIf.predecessors.length > 0) {
                context.noContinuation = false;
                hasContinuation = true;
            }
            if (hasContinuation) {
                context.current = afterIf;
            }
            context.walker.options.goChildren = false;
        };
        return IfStatement;
    })(Statement);
    TypeScript.IfStatement = IfStatement;    
    var ReturnStatement = (function (_super) {
        __extends(ReturnStatement, _super);
        function ReturnStatement() {
                _super.call(this, 77 /* Return */ );
            this.returnExpression = null;
        }
        ReturnStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            if (this.returnExpression) {
                emitter.writeToOutput("return ");
                emitter.emitJavascript(this.returnExpression, 55 /* Semicolon */ , false);
                if (this.returnExpression.nodeType === 73 /* FuncDecl */ ) {
                    emitter.writeToOutput(";");
                }
            } else {
                emitter.writeToOutput("return;");
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        ReturnStatement.prototype.addToControlFlow = function (context) {
            _super.prototype.addToControlFlow.call(this, context);
            context.returnStmt();
        };
        ReturnStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckReturn(this);
        };
        return ReturnStatement;
    })(Statement);
    TypeScript.ReturnStatement = ReturnStatement;    
    var EndCode = (function (_super) {
        __extends(EndCode, _super);
        function EndCode() {
                _super.call(this, 105 /* EndCode */ );
        }
        return EndCode;
    })(AST);
    TypeScript.EndCode = EndCode;    
    var ForInStatement = (function (_super) {
        __extends(ForInStatement, _super);
        function ForInStatement(lval, obj) {
                _super.call(this, 82 /* ForIn */ );
            this.lval = lval;
            this.obj = obj;
            this.statement = new ASTSpan();
            if (this.lval && (this.lval.nodeType == 75 /* VarDecl */ )) {
                (this.lval).varFlags |= 256 /* AutoInit */ ;
            }
        }
        ForInStatement.prototype.isLoop = function () {
            return true;
        };
        ForInStatement.prototype.isFiltered = function () {
            if (this.body) {
                var singleItem = null;
                if (this.body.nodeType == 94 /* List */ ) {
                    var stmts = this.body;
                    if (stmts.members.length == 1) {
                        singleItem = stmts.members[0];
                    }
                } else {
                    singleItem = this.body;
                }
                if (singleItem !== null) {
                    if (singleItem.nodeType == 86 /* Block */ ) {
                        var block = singleItem;
                        if ((block.statements !== null) && (block.statements.members.length == 1)) {
                            singleItem = block.statements.members[0];
                        }
                    }
                    if (singleItem.nodeType == 83 /* If */ ) {
                        var cond = (singleItem).cond;
                        if (cond.nodeType == 30 /* Call */ ) {
                            var target = (cond).target;
                            if (target.nodeType == 19 /* Dot */ ) {
                                var binex = target;
                                if ((binex.operand1.nodeType == 25 /* Name */ ) && (this.obj.nodeType == 25 /* Name */ ) && ((binex.operand1).actualText == (this.obj).actualText)) {
                                    var prop = binex.operand2;
                                    if (prop.actualText == "hasOwnProperty") {
                                        var args = (cond).arguments;
                                        if ((args !== null) && (args.members.length == 1)) {
                                            var arg = args.members[0];
                                            if ((arg.nodeType == 25 /* Name */ ) && (this.lval.nodeType == 25 /* Name */ )) {
                                                if (((this.lval).actualText) == (arg).actualText) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        ForInStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("for(");
            emitter.emitJavascript(this.lval, 19 /* For */ , false);
            emitter.writeToOutput(" in ");
            emitter.emitJavascript(this.obj, 19 /* For */ , false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascriptStatements(this.body, true);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        ForInStatement.prototype.typeCheck = function (typeFlow) {
            if (typeFlow.checker.styleSettings.forin) {
                if (!this.isFiltered()) {
                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter");
                }
            }
            return typeFlow.typeCheckForIn(this);
        };
        ForInStatement.prototype.addToControlFlow = function (context) {
            if (this.lval) {
                context.addContent(this.lval);
            }
            if (this.obj) {
                context.addContent(this.obj);
            }
            var loopHeader = context.current;
            var loopStart = new TypeScript.BasicBlock();
            var afterLoop = new TypeScript.BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            if (this.body) {
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
            }
            context.current = afterLoop;
            context.noContinuation = false;
            loopHeader.addSuccessor(afterLoop);
            context.walker.options.goChildren = false;
        };
        return ForInStatement;
    })(Statement);
    TypeScript.ForInStatement = ForInStatement;    
    var ForStatement = (function (_super) {
        __extends(ForStatement, _super);
        function ForStatement(init) {
                _super.call(this, 81 /* For */ );
            this.init = init;
        }
        ForStatement.prototype.isLoop = function () {
            return true;
        };
        ForStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("for(");
            if (this.init) {
                if (this.init.nodeType != 94 /* List */ ) {
                    emitter.emitJavascript(this.init, 19 /* For */ , false);
                } else {
                    emitter.setInVarBlock((this.init).members.length);
                    emitter.emitJavascriptList(this.init, null, 19 /* For */ , false, false, false);
                }
            }
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.cond, 19 /* For */ , false);
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.incr, 19 /* For */ , false);
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        ForStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckFor(this);
        };
        ForStatement.prototype.addToControlFlow = function (context) {
            if (this.init) {
                context.addContent(this.init);
            }
            var loopHeader = context.current;
            var loopStart = new TypeScript.BasicBlock();
            var afterLoop = new TypeScript.BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            var condBlock = null;
            var continueTarget = loopStart;
            var incrBB = null;
            if (this.incr) {
                incrBB = new TypeScript.BasicBlock();
                continueTarget = incrBB;
            }
            if (this.cond) {
                condBlock = context.current;
                context.addContent(this.cond);
                context.current = new TypeScript.BasicBlock();
                condBlock.addSuccessor(context.current);
            }
            var targetInfo = null;
            if (this.body) {
                context.pushStatement(this, continueTarget, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (this.incr) {
                if (context.noContinuation) {
                    if (incrBB.predecessors.length == 0) {
                        context.addUnreachable(this.incr);
                    }
                } else {
                    context.current.addSuccessor(incrBB);
                    context.current = incrBB;
                    context.addContent(this.incr);
                }
            }
            var loopEnd = context.current;
            if (!(context.noContinuation)) {
                loopEnd.addSuccessor(loopStart);
            }
            if (condBlock) {
                condBlock.addSuccessor(afterLoop);
                context.noContinuation = false;
            }
            if (afterLoop.predecessors.length > 0) {
                context.noContinuation = false;
                context.current = afterLoop;
            }
            context.walker.options.goChildren = false;
        };
        return ForStatement;
    })(Statement);
    TypeScript.ForStatement = ForStatement;    
    var WithStatement = (function (_super) {
        __extends(WithStatement, _super);
        function WithStatement(expr) {
                _super.call(this, 100 /* With */ );
            this.expr = expr;
            this.withSym = null;
        }
        WithStatement.prototype.isCompoundStatement = function () {
            return true;
        };
        WithStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("with (");
            if (this.expr) {
                emitter.emitJavascript(this.expr, 52 /* With */ , false);
            }
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        WithStatement.prototype.typeCheck = function (typeFlow) {
            return typeFlow.typeCheckWith(this);
        };
        return WithStatement;
    })(Statement);
    TypeScript.WithStatement = WithStatement;    
    var SwitchStatement = (function (_super) {
        __extends(SwitchStatement, _super);
        function SwitchStatement(val) {
                _super.call(this, 88 /* Switch */ );
            this.val = val;
            this.defaultCase = null;
            this.statement = new ASTSpan();
        }
        SwitchStatement.prototype.isCompoundStatement = function () {
            return true;
        };
        SwitchStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("switch(");
            emitter.emitJavascript(this.val, 107 /* Identifier */ , false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();
            var casesLen = this.caseList.members.length;
            for(var i = 0; i < casesLen; i++) {
                var caseExpr = this.caseList.members[i];
                emitter.emitJavascript(caseExpr, 3 /* Case */ , true);
            }
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        SwitchStatement.prototype.typeCheck = function (typeFlow) {
            var len = this.caseList.members.length;
            this.val = typeFlow.typeCheck(this.val);
            for(var i = 0; i < len; i++) {
                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);
            }
            this.defaultCase = typeFlow.typeCheck(this.defaultCase);
            this.type = typeFlow.voidType;
            return this;
        };
        SwitchStatement.prototype.addToControlFlow = function (context) {
            var condBlock = context.current;
            context.addContent(this.val);
            var execBlock = new TypeScript.BasicBlock();
            var afterSwitch = new TypeScript.BasicBlock();
            condBlock.addSuccessor(execBlock);
            context.pushSwitch(execBlock);
            context.current = execBlock;
            context.pushStatement(this, execBlock, afterSwitch);
            context.walk(this.caseList, this);
            context.popSwitch();
            var targetInfo = context.popStatement();
            var hasCondContinuation = (this.defaultCase == null);
            if (this.defaultCase == null) {
                condBlock.addSuccessor(afterSwitch);
            }
            if (afterSwitch.predecessors.length > 0) {
                context.noContinuation = false;
                context.current = afterSwitch;
            } else {
                context.noContinuation = true;
            }
            context.walker.options.goChildren = false;
        };
        return SwitchStatement;
    })(Statement);
    TypeScript.SwitchStatement = SwitchStatement;    
    var CaseStatement = (function (_super) {
        __extends(CaseStatement, _super);
        function CaseStatement() {
                _super.call(this, 87 /* Case */ );
            this.expr = null;
            this.colonSpan = new ASTSpan();
        }
        CaseStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.expr) {
                emitter.writeToOutput("case ");
                emitter.emitJavascript(this.expr, 107 /* Identifier */ , false);
            } else {
                emitter.writeToOutput("default");
            }
            emitter.recordSourceMappingStart(this.colonSpan);
            emitter.writeToOutput(":");
            emitter.recordSourceMappingEnd(this.colonSpan);
            if (this.body.members.length == 1 && this.body.members[0].nodeType == 86 /* Block */ ) {
                emitter.emitJavascriptStatements(this.body, false);
            } else {
                emitter.writeLineToOutput("");
                emitter.indenter.increaseIndent();
                emitter.emitBareJavascriptStatements(this.body);
                emitter.indenter.decreaseIndent();
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        CaseStatement.prototype.typeCheck = function (typeFlow) {
            this.expr = typeFlow.typeCheck(this.expr);
            typeFlow.typeCheck(this.body);
            this.type = typeFlow.voidType;
            return this;
        };
        CaseStatement.prototype.addToControlFlow = function (context) {
            var execBlock = new TypeScript.BasicBlock();
            var sw = context.currentSwitch[context.currentSwitch.length - 1];
            if (this.expr) {
                var exprBlock = new TypeScript.BasicBlock();
                context.current = exprBlock;
                sw.addSuccessor(exprBlock);
                context.addContent(this.expr);
                exprBlock.addSuccessor(execBlock);
            } else {
                sw.addSuccessor(execBlock);
            }
            context.current = execBlock;
            if (this.body) {
                context.walk(this.body, this);
            }
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        };
        return CaseStatement;
    })(Statement);
    TypeScript.CaseStatement = CaseStatement;    
    var TypeParameter = (function (_super) {
        __extends(TypeParameter, _super);
        function TypeParameter(name, constraint) {
                _super.call(this, 26 /* TypeParameter */ );
            this.name = name;
            this.constraint = constraint;
        }
        return TypeParameter;
    })(AST);
    TypeScript.TypeParameter = TypeParameter;    
    var GenericType = (function (_super) {
        __extends(GenericType, _super);
        function GenericType(name, typeArguments) {
                _super.call(this, 27 /* GenericType */ );
            this.name = name;
            this.typeArguments = typeArguments;
        }
        return GenericType;
    })(AST);
    TypeScript.GenericType = GenericType;    
    var TypeReference = (function (_super) {
        __extends(TypeReference, _super);
        function TypeReference(term, arrayCount) {
                _super.call(this, 28 /* TypeRef */ );
            this.term = term;
            this.arrayCount = arrayCount;
        }
        TypeReference.prototype.emit = function (emitter, tokenId, startLine) {
            throw new Error("should not emit a type ref");
        };
        TypeReference.prototype.typeCheck = function (typeFlow) {
            var prevInTCTR = typeFlow.inTypeRefTypeCheck;
            typeFlow.inTypeRefTypeCheck = true;
            var typeLink = TypeScript.getTypeLink(this, typeFlow.checker, true);
            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);
            if (this.term) {
                typeFlow.typeCheck(this.term);
            }
            typeFlow.checkForVoidConstructor(typeLink.type, this);
            this.type = typeLink.type;
            if (this.term) {
                this.term.type = this.type;
            }
            typeFlow.inTypeRefTypeCheck = prevInTCTR;
            return this;
        };
        return TypeReference;
    })(AST);
    TypeScript.TypeReference = TypeReference;    
    var TryFinally = (function (_super) {
        __extends(TryFinally, _super);
        function TryFinally(tryNode, finallyNode) {
                _super.call(this, 91 /* TryFinally */ );
            this.tryNode = tryNode;
            this.finallyNode = finallyNode;
        }
        TryFinally.prototype.isCompoundStatement = function () {
            return true;
        };
        TryFinally.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.tryNode, 48 /* Try */ , false);
            emitter.emitJavascript(this.finallyNode, 18 /* Finally */ , false);
            emitter.recordSourceMappingEnd(this);
        };
        TryFinally.prototype.typeCheck = function (typeFlow) {
            this.tryNode = typeFlow.typeCheck(this.tryNode);
            this.finallyNode = typeFlow.typeCheck(this.finallyNode);
            this.type = typeFlow.voidType;
            return this;
        };
        TryFinally.prototype.addToControlFlow = function (context) {
            var afterFinally = new TypeScript.BasicBlock();
            context.walk(this.tryNode, this);
            var finBlock = new TypeScript.BasicBlock();
            if (context.current) {
                context.current.addSuccessor(finBlock);
            }
            context.current = finBlock;
            context.pushStatement(this, null, afterFinally);
            context.walk(this.finallyNode, this);
            if (!context.noContinuation && context.current) {
                context.current.addSuccessor(afterFinally);
            }
            if (afterFinally.predecessors.length > 0) {
                context.current = afterFinally;
            } else {
                context.noContinuation = true;
            }
            context.popStatement();
            context.walker.options.goChildren = false;
        };
        return TryFinally;
    })(Statement);
    TypeScript.TryFinally = TryFinally;    
    var TryCatch = (function (_super) {
        __extends(TryCatch, _super);
        function TryCatch(tryNode, catchNode) {
                _super.call(this, 90 /* TryCatch */ );
            this.tryNode = tryNode;
            this.catchNode = catchNode;
        }
        TryCatch.prototype.isCompoundStatement = function () {
            return true;
        };
        TryCatch.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.tryNode, 48 /* Try */ , false);
            emitter.emitJavascript(this.catchNode, 4 /* Catch */ , false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        TryCatch.prototype.addToControlFlow = function (context) {
            var beforeTry = context.current;
            var tryBlock = new TypeScript.BasicBlock();
            beforeTry.addSuccessor(tryBlock);
            context.current = tryBlock;
            var afterTryCatch = new TypeScript.BasicBlock();
            context.pushStatement(this, null, afterTryCatch);
            context.walk(this.tryNode, this);
            if (!context.noContinuation) {
                if (context.current) {
                    context.current.addSuccessor(afterTryCatch);
                }
            }
            context.current = new TypeScript.BasicBlock();
            beforeTry.addSuccessor(context.current);
            context.walk(this.catchNode, this);
            context.popStatement();
            if (!context.noContinuation) {
                if (context.current) {
                    context.current.addSuccessor(afterTryCatch);
                }
            }
            context.current = afterTryCatch;
            context.walker.options.goChildren = false;
        };
        TryCatch.prototype.typeCheck = function (typeFlow) {
            this.tryNode = typeFlow.typeCheck(this.tryNode);
            this.catchNode = typeFlow.typeCheck(this.catchNode);
            this.type = typeFlow.voidType;
            return this;
        };
        return TryCatch;
    })(Statement);
    TypeScript.TryCatch = TryCatch;    
    var Try = (function (_super) {
        __extends(Try, _super);
        function Try(body) {
                _super.call(this, 89 /* Try */ );
            this.body = body;
        }
        Try.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("try ");
            emitter.emitJavascript(this.body, 48 /* Try */ , false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        Try.prototype.typeCheck = function (typeFlow) {
            this.body = typeFlow.typeCheck(this.body);
            return this;
        };
        Try.prototype.addToControlFlow = function (context) {
            if (this.body) {
                context.walk(this.body, this);
            }
            context.walker.options.goChildren = false;
            context.noContinuation = false;
        };
        return Try;
    })(Statement);
    TypeScript.Try = Try;    
    var Catch = (function (_super) {
        __extends(Catch, _super);
        function Catch(param, body) {
                _super.call(this, 93 /* Catch */ );
            this.param = param;
            this.body = body;
            this.statement = new ASTSpan();
            this.containedScope = null;
            if (this.param) {
                this.param.varFlags |= 256 /* AutoInit */ ;
            }
        }
        Catch.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(" ");
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("catch (");
            emitter.emitJavascript(this.param, 56 /* OpenParen */ , false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascript(this.body, 4 /* Catch */ , false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        Catch.prototype.addToControlFlow = function (context) {
            if (this.param) {
                context.addContent(this.param);
                var bodBlock = new TypeScript.BasicBlock();
                context.current.addSuccessor(bodBlock);
                context.current = bodBlock;
            }
            if (this.body) {
                context.walk(this.body, this);
            }
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        };
        Catch.prototype.typeCheck = function (typeFlow) {
            var prevScope = typeFlow.scope;
            typeFlow.scope = this.containedScope;
            this.param = typeFlow.typeCheck(this.param);
            var exceptVar = new TypeScript.ValueLocation();
            var varSym = new TypeScript.VariableSymbol((this.param).id.text, this.param.minChar, typeFlow.checker.locationInfo.unitIndex, exceptVar);
            exceptVar.symbol = varSym;
            exceptVar.typeLink = new TypeScript.TypeLink();
            exceptVar.typeLink.type = typeFlow.anyType;
            var thisFnc = typeFlow.thisFnc;
            if (thisFnc && thisFnc.type) {
                exceptVar.symbol.container = thisFnc.type.symbol;
            } else {
                exceptVar.symbol.container = null;
            }
            this.param.sym = exceptVar.symbol;
            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol, typeFlow.checker.errorReporter, false, false, false);
            this.body = typeFlow.typeCheck(this.body);
            if (typeFlow.checker.inProvisionalTypecheckMode()) {
                var table = typeFlow.scope.getTable();
                (table).secondaryTable.table[exceptVar.symbol.name] = undefined;
            }
            this.type = typeFlow.voidType;
            typeFlow.scope = prevScope;
            return this;
        };
        return Catch;
    })(Statement);
    TypeScript.Catch = Catch;    
    var Finally = (function (_super) {
        __extends(Finally, _super);
        function Finally(body) {
                _super.call(this, 92 /* Finally */ );
            this.body = body;
        }
        Finally.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(" finally");
            emitter.emitJavascript(this.body, 18 /* Finally */ , false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        Finally.prototype.addToControlFlow = function (context) {
            if (this.body) {
                context.walk(this.body, this);
            }
            context.walker.options.goChildren = false;
            context.noContinuation = false;
        };
        Finally.prototype.typeCheck = function (typeFlow) {
            this.body = typeFlow.typeCheck(this.body);
            return this;
        };
        return Finally;
    })(Statement);
    TypeScript.Finally = Finally;    
    var Comment = (function (_super) {
        __extends(Comment, _super);
        function Comment(content, isBlockComment, endsLine) {
                _super.call(this, 107 /* Comment */ );
            this.content = content;
            this.isBlockComment = isBlockComment;
            this.endsLine = endsLine;
            this.text = null;
            this.docCommentText = null;
        }
        Comment.prototype.getText = function () {
            if (this.text == null) {
                if (this.isBlockComment) {
                    this.text = this.content.split("\n");
                    for(var i = 0; i < this.text.length; i++) {
                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '');
                    }
                } else {
                    this.text = [
                        (this.content.replace(/^\s+|\s+$/g, ''))
                    ];
                }
            }
            return this.text;
        };
        Comment.prototype.isDocComment = function () {
            if (this.isBlockComment) {
                return this.content.charAt(2) == "*" && this.content.charAt(3) != "/";
            }
            return false;
        };
        Comment.prototype.getDocCommentText = function () {
            if (this.docCommentText == null) {
                this.docCommentText = Comment.cleanJSDocComment(this.content);
            }
            return this.docCommentText;
        };
        Comment.consumeLeadingSpace = function consumeLeadingSpace(line, startIndex, maxSpacesToRemove) {
            var endIndex = line.length;
            if (maxSpacesToRemove != undefined) {
                endIndex = TypeScript.min(startIndex + maxSpacesToRemove, endIndex);
            }
            for(; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode != TypeScript.LexCodeSpace && charCode != TypeScript.LexCodeTAB) {
                    return startIndex;
                }
            }
            if (endIndex != line.length) {
                return endIndex;
            }
            return -1;
        };
        Comment.isSpaceChar = function isSpaceChar(line, index) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);
                return charCode == TypeScript.LexCodeSpace || charCode == TypeScript.LexCodeTAB;
            }
            return index == length;
        };
        Comment.cleanDocCommentLine = function cleanDocCommentLine(line, jsDocStyleComment, jsDocLineSpaceToRemove) {
            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex != -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) == '*') {
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);
                    if (nonSpaceIndex != -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    } else {
                        return null;
                    }
                }
                return {
                    minChar: nonSpaceIndex,
                    limChar: line.charAt(line.length - 1) == "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }
            return null;
        };
        Comment.cleanJSDocComment = function cleanJSDocComment(content, spacesToRemove) {
            var docCommentLines = [];
            content = content.replace("/**", "");
            if (content.length >= 2 && content.charAt(content.length - 1) == "/" && content.charAt(content.length - 2) == "*") {
                content = content.substring(0, content.length - 2);
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for(var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    continue;
                }
                var docCommentText = "";
                var prevPos = cleanLinePos.minChar;
                for(var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {
                    var wasInParamtag = inParamTag;
                    if (line.indexOf("param", i + 1) == i + 1 && Comment.isSpaceChar(line, i + 6)) {
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }
                        prevPos = i;
                        inParamTag = true;
                    } else if (wasInParamtag) {
                        prevPos = i;
                        inParamTag = false;
                    }
                }
                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);
                }
                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove == undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }
            return docCommentLines.join("\n");
        };
        Comment.getDocCommentText = function getDocCommentText(comments) {
            var docCommentText = [];
            for(var c = 0; c < comments.length; c++) {
                var commentText = comments[c].getDocCommentText();
                if (commentText != "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        };
        Comment.getParameterDocCommentText = function getParameterDocCommentText(param, fncDocComments) {
            if (fncDocComments.length == 0 || !fncDocComments[0].isBlockComment) {
                return "";
            }
            for(var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].content;
                for(var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!Comment.isSpaceChar(commentContents, j)) {
                        continue;
                    }
                    j = Comment.consumeLeadingSpace(commentContents, j);
                    if (j == -1) {
                        break;
                    }
                    if (commentContents.charCodeAt(j) == TypeScript.LexCodeLC) {
                        j++;
                        var charCode = 0;
                        for(var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);
                            if (charCode == TypeScript.LexCodeLC) {
                                curlies++;
                                continue;
                            }
                            if (charCode == TypeScript.LexCodeRC) {
                                curlies--;
                                if (curlies == 0) {
                                    break;
                                } else {
                                    continue;
                                }
                            }
                            if (charCode == TypeScript.LexCodeAtSign) {
                                break;
                            }
                        }
                        if (j == commentContents.length) {
                            break;
                        }
                        if (charCode == TypeScript.LexCodeAtSign) {
                            continue;
                        }
                        j = Comment.consumeLeadingSpace(commentContents, j + 1);
                        if (j == -1) {
                            break;
                        }
                    }
                    if (param != commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {
                        continue;
                    }
                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);
                    if (j == -1) {
                        return "";
                    }
                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);
                    var paramSpacesToRemove = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex != 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) == "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex != j && commentContents.charAt(startSpaceRemovalIndex) == "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }
                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }
            return "";
        };
        Comment.getDocCommentFirstOverloadSignature = function getDocCommentFirstOverloadSignature(signatureGroup) {
            for(var i = 0; i < signatureGroup.signatures.length; i++) {
                var signature = signatureGroup.signatures[i];
                if (signature == signatureGroup.definitionSignature) {
                    continue;
                }
                return TypeScript.Comment.getDocCommentText(signature.declAST.getDocComments());
            }
            return "";
        };
        return Comment;
    })(AST);
    TypeScript.Comment = Comment;    
    var DebuggerStatement = (function (_super) {
        __extends(DebuggerStatement, _super);
        function DebuggerStatement() {
                _super.call(this, 108 /* Debugger */ );
        }
        DebuggerStatement.prototype.emit = function (emitter, tokenId, startLine) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("debugger");
            emitter.recordSourceMappingEnd(this);
            emitter.writeLineToOutput(";");
            emitter.emitParensAndCommentsInPlace(this, false);
        };
        return DebuggerStatement;
    })(Statement);
    TypeScript.DebuggerStatement = DebuggerStatement;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AstWalkOptions = (function () {
        function AstWalkOptions() {
            this.goChildren = true;
            this.goNextSibling = true;
            this.reverseSiblings = false;
        }
        AstWalkOptions.prototype.stopWalk = function (stop) {
            if (typeof stop === "undefined") { stop = true; }
            this.goChildren = !stop;
            this.goNextSibling = !stop;
        };
        return AstWalkOptions;
    })();
    TypeScript.AstWalkOptions = AstWalkOptions;    
    var AstWalker = (function () {
        function AstWalker(childrenWalkers, pre, post, options, state) {
            this.childrenWalkers = childrenWalkers;
            this.pre = pre;
            this.post = post;
            this.options = options;
            this.state = state;
        }
        AstWalker.prototype.walk = function (ast, parent) {
            var preAst = this.pre(ast, parent, this);
            if (preAst === undefined) {
                preAst = ast;
            }
            if (this.options.goChildren) {
                var svGoSib = this.options.goNextSibling;
                this.options.goNextSibling = true;
                this.childrenWalkers[ast.nodeType](ast, parent, this);
                this.options.goNextSibling = svGoSib;
            } else {
                this.options.goChildren = true;
            }
            if (this.post) {
                var postAst = this.post(preAst, parent, this);
                if (postAst === undefined) {
                    postAst = preAst;
                }
                return postAst;
            } else {
                return preAst;
            }
        };
        return AstWalker;
    })();    
    var AstWalkerFactory = (function () {
        function AstWalkerFactory() {
            this.childrenWalkers = [];
            this.initChildrenWalkers();
        }
        AstWalkerFactory.prototype.walk = function (ast, pre, post, options, state) {
            return this.getWalker(pre, post, options, state).walk(ast, null);
        };
        AstWalkerFactory.prototype.getWalker = function (pre, post, options, state) {
            return this.getSlowWalker(pre, post, options, state);
        };
        AstWalkerFactory.prototype.getSlowWalker = function (pre, post, options, state) {
            if (!options) {
                options = new AstWalkOptions();
            }
            return new AstWalker(this.childrenWalkers, pre, post, options, state);
        };
        AstWalkerFactory.prototype.initChildrenWalkers = function () {
            this.childrenWalkers[0 /* None */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[1 /* Empty */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[2 /* EmptyExpr */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[3 /* True */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[4 /* False */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[5 /* This */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[6 /* Super */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[7 /* QString */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[8 /* Regex */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[9 /* Null */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[10 /* ArrayLit */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[11 /* ObjectLit */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[12 /* Void */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[13 /* Comma */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[14 /* Pos */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[15 /* Neg */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[16 /* Delete */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[17 /* Await */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[18 /* In */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[19 /* Dot */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[20 /* From */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[21 /* Is */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[22 /* InstOf */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[23 /* Typeof */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[24 /* NumberLit */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[25 /* Name */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[26 /* TypeParameter */ ] = ChildrenWalkers.walkTypeParameterChildren;
            this.childrenWalkers[27 /* GenericType */ ] = ChildrenWalkers.walkGenericTypeChildren;
            this.childrenWalkers[28 /* TypeRef */ ] = ChildrenWalkers.walkTypeReferenceChildren;
            this.childrenWalkers[29 /* Index */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[30 /* Call */ ] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[31 /* New */ ] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[32 /* Asg */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[33 /* AsgAdd */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[34 /* AsgSub */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[35 /* AsgDiv */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[36 /* AsgMul */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[37 /* AsgMod */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[38 /* AsgAnd */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[39 /* AsgXor */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[40 /* AsgOr */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[41 /* AsgLsh */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[42 /* AsgRsh */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[43 /* AsgRs2 */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[44 /* ConditionalExpression */ ] = ChildrenWalkers.walkTrinaryExpressionChildren;
            this.childrenWalkers[45 /* LogOr */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[46 /* LogAnd */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[47 /* Or */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[48 /* Xor */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[49 /* And */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[50 /* Eq */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[51 /* Ne */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[52 /* Eqv */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[53 /* NEqv */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[54 /* Lt */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[55 /* Le */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[56 /* Gt */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[57 /* Ge */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[58 /* Add */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[59 /* Sub */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[60 /* Mul */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[61 /* Div */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[62 /* Mod */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[63 /* Lsh */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[64 /* Rsh */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[65 /* Rs2 */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[66 /* Not */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[67 /* LogNot */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[68 /* IncPre */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[69 /* DecPre */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[70 /* IncPost */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[71 /* DecPost */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[72 /* TypeAssertion */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[73 /* FuncDecl */ ] = ChildrenWalkers.walkFuncDeclChildren;
            this.childrenWalkers[74 /* Member */ ] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[75 /* VarDecl */ ] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[76 /* ArgDecl */ ] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[77 /* Return */ ] = ChildrenWalkers.walkReturnStatementChildren;
            this.childrenWalkers[78 /* Break */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[79 /* Continue */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[80 /* Throw */ ] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[81 /* For */ ] = ChildrenWalkers.walkForStatementChildren;
            this.childrenWalkers[82 /* ForIn */ ] = ChildrenWalkers.walkForInStatementChildren;
            this.childrenWalkers[83 /* If */ ] = ChildrenWalkers.walkIfStatementChildren;
            this.childrenWalkers[84 /* While */ ] = ChildrenWalkers.walkWhileStatementChildren;
            this.childrenWalkers[85 /* DoWhile */ ] = ChildrenWalkers.walkDoWhileStatementChildren;
            this.childrenWalkers[86 /* Block */ ] = ChildrenWalkers.walkBlockChildren;
            this.childrenWalkers[87 /* Case */ ] = ChildrenWalkers.walkCaseStatementChildren;
            this.childrenWalkers[88 /* Switch */ ] = ChildrenWalkers.walkSwitchStatementChildren;
            this.childrenWalkers[89 /* Try */ ] = ChildrenWalkers.walkTryChildren;
            this.childrenWalkers[90 /* TryCatch */ ] = ChildrenWalkers.walkTryCatchChildren;
            this.childrenWalkers[91 /* TryFinally */ ] = ChildrenWalkers.walkTryFinallyChildren;
            this.childrenWalkers[92 /* Finally */ ] = ChildrenWalkers.walkFinallyChildren;
            this.childrenWalkers[93 /* Catch */ ] = ChildrenWalkers.walkCatchChildren;
            this.childrenWalkers[94 /* List */ ] = ChildrenWalkers.walkListChildren;
            this.childrenWalkers[95 /* Script */ ] = ChildrenWalkers.walkScriptChildren;
            this.childrenWalkers[96 /* ClassDeclaration */ ] = ChildrenWalkers.walkClassDeclChildren;
            this.childrenWalkers[97 /* InterfaceDeclaration */ ] = ChildrenWalkers.walkTypeDeclChildren;
            this.childrenWalkers[98 /* ModuleDeclaration */ ] = ChildrenWalkers.walkModuleDeclChildren;
            this.childrenWalkers[99 /* ImportDeclaration */ ] = ChildrenWalkers.walkImportDeclChildren;
            this.childrenWalkers[100 /* With */ ] = ChildrenWalkers.walkWithStatementChildren;
            this.childrenWalkers[101 /* Label */ ] = ChildrenWalkers.walkLabelChildren;
            this.childrenWalkers[102 /* LabeledStatement */ ] = ChildrenWalkers.walkLabeledStatementChildren;
            this.childrenWalkers[103 /* EBStart */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[104 /* GotoEB */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[105 /* EndCode */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[106 /* Error */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[107 /* Comment */ ] = ChildrenWalkers.walkNone;
            this.childrenWalkers[108 /* Debugger */ ] = ChildrenWalkers.walkNone;
            for(var e in (TypeScript.NodeType)._map) {
                if ((this.childrenWalkers)[e] === undefined) {
                    throw new Error("initWalkers function is not up to date with enum content!");
                }
            }
        };
        return AstWalkerFactory;
    })();
    TypeScript.AstWalkerFactory = AstWalkerFactory;    
    var globalAstWalkerFactory;
    function getAstWalkerFactory() {
        if (!globalAstWalkerFactory) {
            globalAstWalkerFactory = new AstWalkerFactory();
        }
        return globalAstWalkerFactory;
    }
    TypeScript.getAstWalkerFactory = getAstWalkerFactory;
    var ChildrenWalkers;
    (function (ChildrenWalkers) {
        function walkNone(preAst, parent, walker) {
        }
        ChildrenWalkers.walkNone = walkNone;
        function walkListChildren(preAst, parent, walker) {
            var len = preAst.members.length;
            if (walker.options.reverseSiblings) {
                for(var i = len - 1; i >= 0; i--) {
                    if (walker.options.goNextSibling) {
                        preAst.members[i] = walker.walk(preAst.members[i], preAst);
                    }
                }
            } else {
                for(var i = 0; i < len; i++) {
                    if (walker.options.goNextSibling) {
                        preAst.members[i] = walker.walk(preAst.members[i], preAst);
                    }
                }
            }
        }
        ChildrenWalkers.walkListChildren = walkListChildren;
        function walkUnaryExpressionChildren(preAst, parent, walker) {
            if (preAst.castTerm) {
                preAst.castTerm = walker.walk(preAst.castTerm, preAst);
            }
            if (preAst.operand) {
                preAst.operand = walker.walk(preAst.operand, preAst);
            }
        }
        ChildrenWalkers.walkUnaryExpressionChildren = walkUnaryExpressionChildren;
        function walkBinaryExpressionChildren(preAst, parent, walker) {
            if (walker.options.reverseSiblings) {
                if (preAst.operand2) {
                    preAst.operand2 = walker.walk(preAst.operand2, preAst);
                }
                if ((preAst.operand1) && (walker.options.goNextSibling)) {
                    preAst.operand1 = walker.walk(preAst.operand1, preAst);
                }
            } else {
                if (preAst.operand1) {
                    preAst.operand1 = walker.walk(preAst.operand1, preAst);
                }
                if ((preAst.operand2) && (walker.options.goNextSibling)) {
                    preAst.operand2 = walker.walk(preAst.operand2, preAst);
                }
            }
        }
        ChildrenWalkers.walkBinaryExpressionChildren = walkBinaryExpressionChildren;
        function walkTypeParameterChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
            if (preAst.constraint && (walker.options.goNextSibling)) {
                preAst.constraint = walker.walk(preAst.constraint, preAst);
            }
        }
        ChildrenWalkers.walkTypeParameterChildren = walkTypeParameterChildren;
        function walkGenericTypeChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
            if (preAst.typeArguments && (walker.options.goNextSibling)) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }
        }
        ChildrenWalkers.walkGenericTypeChildren = walkGenericTypeChildren;
        function walkTypeReferenceChildren(preAst, parent, walker) {
            if (preAst.term) {
                preAst.term = walker.walk(preAst.term, preAst);
            }
        }
        ChildrenWalkers.walkTypeReferenceChildren = walkTypeReferenceChildren;
        function walkCallExpressionChildren(preAst, parent, walker) {
            if (!walker.options.reverseSiblings) {
                preAst.target = walker.walk(preAst.target, preAst);
            }
            if (preAst.arguments && (walker.options.goNextSibling)) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
            if ((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {
                preAst.target = walker.walk(preAst.target, preAst);
            }
        }
        ChildrenWalkers.walkCallExpressionChildren = walkCallExpressionChildren;
        function walkTrinaryExpressionChildren(preAst, parent, walker) {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2 && (walker.options.goNextSibling)) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
            if (preAst.operand3 && (walker.options.goNextSibling)) {
                preAst.operand3 = walker.walk(preAst.operand3, preAst);
            }
        }
        ChildrenWalkers.walkTrinaryExpressionChildren = walkTrinaryExpressionChildren;
        function walkFuncDeclChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }
            if (preAst.arguments && (walker.options.goNextSibling)) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
            if (preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {
                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);
            }
            if (preAst.bod && (walker.options.goNextSibling)) {
                preAst.bod = walker.walk(preAst.bod, preAst);
            }
        }
        ChildrenWalkers.walkFuncDeclChildren = walkFuncDeclChildren;
        function walkBoundDeclChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }
            if ((preAst.typeExpr) && (walker.options.goNextSibling)) {
                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);
            }
        }
        ChildrenWalkers.walkBoundDeclChildren = walkBoundDeclChildren;
        function walkReturnStatementChildren(preAst, parent, walker) {
            if (preAst.returnExpression) {
                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);
            }
        }
        ChildrenWalkers.walkReturnStatementChildren = walkReturnStatementChildren;
        function walkForStatementChildren(preAst, parent, walker) {
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }
            if (preAst.cond && walker.options.goNextSibling) {
                preAst.cond = walker.walk(preAst.cond, preAst);
            }
            if (preAst.incr && walker.options.goNextSibling) {
                preAst.incr = walker.walk(preAst.incr, preAst);
            }
            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkForStatementChildren = walkForStatementChildren;
        function walkForInStatementChildren(preAst, parent, walker) {
            preAst.lval = walker.walk(preAst.lval, preAst);
            if (walker.options.goNextSibling) {
                preAst.obj = walker.walk(preAst.obj, preAst);
            }
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkForInStatementChildren = walkForInStatementChildren;
        function walkIfStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.thenBod && (walker.options.goNextSibling)) {
                preAst.thenBod = walker.walk(preAst.thenBod, preAst);
            }
            if (preAst.elseBod && (walker.options.goNextSibling)) {
                preAst.elseBod = walker.walk(preAst.elseBod, preAst);
            }
        }
        ChildrenWalkers.walkIfStatementChildren = walkIfStatementChildren;
        function walkWhileStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkWhileStatementChildren = walkWhileStatementChildren;
        function walkDoWhileStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkDoWhileStatementChildren = walkDoWhileStatementChildren;
        function walkBlockChildren(preAst, parent, walker) {
            if (preAst.statements) {
                preAst.statements = walker.walk(preAst.statements, preAst);
            }
        }
        ChildrenWalkers.walkBlockChildren = walkBlockChildren;
        function walkCaseStatementChildren(preAst, parent, walker) {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }
            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkCaseStatementChildren = walkCaseStatementChildren;
        function walkSwitchStatementChildren(preAst, parent, walker) {
            if (preAst.val) {
                preAst.val = walker.walk(preAst.val, preAst);
            }
            if ((preAst.caseList) && walker.options.goNextSibling) {
                preAst.caseList = walker.walk(preAst.caseList, preAst);
            }
        }
        ChildrenWalkers.walkSwitchStatementChildren = walkSwitchStatementChildren;
        function walkTryChildren(preAst, parent, walker) {
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkTryChildren = walkTryChildren;
        function walkTryCatchChildren(preAst, parent, walker) {
            if (preAst.tryNode) {
                preAst.tryNode = walker.walk(preAst.tryNode, preAst);
            }
            if ((preAst.catchNode) && walker.options.goNextSibling) {
                preAst.catchNode = walker.walk(preAst.catchNode, preAst);
            }
        }
        ChildrenWalkers.walkTryCatchChildren = walkTryCatchChildren;
        function walkTryFinallyChildren(preAst, parent, walker) {
            if (preAst.tryNode) {
                preAst.tryNode = walker.walk(preAst.tryNode, preAst);
            }
            if (preAst.finallyNode && walker.options.goNextSibling) {
                preAst.finallyNode = walker.walk(preAst.finallyNode, preAst);
            }
        }
        ChildrenWalkers.walkTryFinallyChildren = walkTryFinallyChildren;
        function walkFinallyChildren(preAst, parent, walker) {
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkFinallyChildren = walkFinallyChildren;
        function walkCatchChildren(preAst, parent, walker) {
            if (preAst.param) {
                preAst.param = walker.walk(preAst.param, preAst);
            }
            if ((preAst.body) && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkCatchChildren = walkCatchChildren;
        function walkRecordChildren(preAst, parent, walker) {
            preAst.name = walker.walk(preAst.name, preAst);
            if (walker.options.goNextSibling && preAst.members) {
                preAst.members = walker.walk(preAst.members, preAst);
            }
        }
        ChildrenWalkers.walkRecordChildren = walkRecordChildren;
        function walkNamedTypeChildren(preAst, parent, walker) {
            walkRecordChildren(preAst, parent, walker);
        }
        ChildrenWalkers.walkNamedTypeChildren = walkNamedTypeChildren;
        function walkClassDeclChildren(preAst, parent, walker) {
            walkNamedTypeChildren(preAst, parent, walker);
            if (walker.options.goNextSibling && preAst.typeParameters) {
                preAst.typeParameters = walker.walk(preAst.typeParameters, preAst);
            }
            if (walker.options.goNextSibling && preAst.extendsList) {
                preAst.extendsList = walker.walk(preAst.extendsList, preAst);
            }
            if (walker.options.goNextSibling && preAst.implementsList) {
                preAst.implementsList = walker.walk(preAst.implementsList, preAst);
            }
        }
        ChildrenWalkers.walkClassDeclChildren = walkClassDeclChildren;
        function walkScriptChildren(preAst, parent, walker) {
            if (preAst.bod) {
                preAst.bod = walker.walk(preAst.bod, preAst);
            }
        }
        ChildrenWalkers.walkScriptChildren = walkScriptChildren;
        function walkTypeDeclChildren(preAst, parent, walker) {
            walkNamedTypeChildren(preAst, parent, walker);
            if (walker.options.goNextSibling && preAst.typeParameters) {
                preAst.typeParameters = walker.walk(preAst.typeParameters, preAst);
            }
            if (walker.options.goNextSibling && preAst.extendsList) {
                preAst.extendsList = walker.walk(preAst.extendsList, preAst);
            }
            if (walker.options.goNextSibling && preAst.implementsList) {
                preAst.implementsList = walker.walk(preAst.implementsList, preAst);
            }
        }
        ChildrenWalkers.walkTypeDeclChildren = walkTypeDeclChildren;
        function walkModuleDeclChildren(preAst, parent, walker) {
            walkRecordChildren(preAst, parent, walker);
        }
        ChildrenWalkers.walkModuleDeclChildren = walkModuleDeclChildren;
        function walkImportDeclChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
            if (preAst.alias) {
                preAst.alias = walker.walk(preAst.alias, preAst);
            }
        }
        ChildrenWalkers.walkImportDeclChildren = walkImportDeclChildren;
        function walkWithStatementChildren(preAst, parent, walker) {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }
            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkWithStatementChildren = walkWithStatementChildren;
        function walkLabelChildren(preAst, parent, walker) {
        }
        ChildrenWalkers.walkLabelChildren = walkLabelChildren;
        function walkLabeledStatementChildren(preAst, parent, walker) {
            preAst.labels = walker.walk(preAst.labels, preAst);
            if (walker.options.goNextSibling) {
                preAst.stmt = walker.walk(preAst.stmt, preAst);
            }
        }
        ChildrenWalkers.walkLabeledStatementChildren = walkLabeledStatementChildren;
    })(ChildrenWalkers || (ChildrenWalkers = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (AstWalkerWithDetailCallback) {
        function walk(script, callback) {
            var pre = function (cur, parent) {
                walker.options.goChildren = AstWalkerCallback(true, cur, callback);
                return cur;
            };
            var post = function (cur, parent) {
                AstWalkerCallback(false, cur, callback);
                return cur;
            };
            var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);
            walker.walk(script, null);
        }
        AstWalkerWithDetailCallback.walk = walk;
        function AstWalkerCallback(pre, ast, callback) {
            var nodeType = ast.nodeType;
            var callbackString = (TypeScript.NodeType)._map[nodeType] + "Callback";
            if (callback[callbackString]) {
                return callback[callbackString](pre, ast);
            }
            if (callback.DefaultCallback) {
                return callback.DefaultCallback(pre, ast);
            }
            return true;
        }
    })(TypeScript.AstWalkerWithDetailCallback || (TypeScript.AstWalkerWithDetailCallback = {}));
    var AstWalkerWithDetailCallback = TypeScript.AstWalkerWithDetailCallback;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function lastOf(items) {
        return (items === null || items.length === 0) ? null : items[items.length - 1];
    }
    TypeScript.lastOf = lastOf;
    function max(a, b) {
        return a >= b ? a : b;
    }
    TypeScript.max = max;
    function min(a, b) {
        return a <= b ? a : b;
    }
    TypeScript.min = min;
    var AstPath = (function () {
        function AstPath() {
            this.asts = [];
            this.top = -1;
        }
        AstPath.reverseIndexOf = function reverseIndexOf(items, index) {
            return (items === null || items.length <= index) ? null : items[items.length - index - 1];
        };
        AstPath.prototype.clone = function () {
            var clone = new AstPath();
            clone.asts = this.asts.map(function (value) {
                return value;
            });
            clone.top = this.top;
            return clone;
        };
        AstPath.prototype.pop = function () {
            var head = this.ast();
            this.up();
            while(this.asts.length > this.count()) {
                this.asts.pop();
            }
            return head;
        };
        AstPath.prototype.push = function (ast) {
            while(this.asts.length > this.count()) {
                this.asts.pop();
            }
            this.top = this.asts.length;
            this.asts.push(ast);
        };
        AstPath.prototype.up = function () {
            if (this.top <= -1) {
                throw new Error("Invalid call to 'up'");
            }
            this.top--;
        };
        AstPath.prototype.down = function () {
            if (this.top == this.ast.length - 1) {
                throw new Error("Invalid call to 'down'");
            }
            this.top++;
        };
        AstPath.prototype.nodeType = function () {
            if (this.ast() == null) {
                return 0 /* None */ ;
            }
            return this.ast().nodeType;
        };
        AstPath.prototype.ast = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));
        };
        AstPath.prototype.parent = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);
        };
        AstPath.prototype.count = function () {
            return this.top + 1;
        };
        AstPath.prototype.get = function (index) {
            return this.asts[index];
        };
        AstPath.prototype.isNameOfClass = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === 25 /* Name */ ) && (this.parent().nodeType === 96 /* ClassDeclaration */ ) && ((this.parent()).name === this.ast());
        };
        AstPath.prototype.isNameOfInterface = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === 25 /* Name */ ) && (this.parent().nodeType === 97 /* InterfaceDeclaration */ ) && ((this.parent()).name === this.ast());
        };
        AstPath.prototype.isNameOfArgument = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === 25 /* Name */ ) && (this.parent().nodeType === 76 /* ArgDecl */ ) && ((this.parent()).id === this.ast());
        };
        AstPath.prototype.isNameOfVariable = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === 25 /* Name */ ) && (this.parent().nodeType === 75 /* VarDecl */ ) && ((this.parent()).id === this.ast());
        };
        AstPath.prototype.isNameOfModule = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === 25 /* Name */ ) && (this.parent().nodeType === 98 /* ModuleDeclaration */ ) && ((this.parent()).name === this.ast());
        };
        AstPath.prototype.isNameOfFunction = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.ast().nodeType === 25 /* Name */ ) && (this.parent().nodeType === 73 /* FuncDecl */ ) && ((this.parent()).name === this.ast());
        };
        AstPath.prototype.isChildOfScript = function () {
            var ast = lastOf(this.asts);
            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === 94 /* List */  && this.asts[this.top - 2].nodeType === 95 /* Script */ ;
        };
        AstPath.prototype.isChildOfModule = function () {
            var ast = lastOf(this.asts);
            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === 94 /* List */  && this.asts[this.top - 2].nodeType === 98 /* ModuleDeclaration */ ;
        };
        AstPath.prototype.isChildOfClass = function () {
            var ast = lastOf(this.asts);
            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === 94 /* List */  && this.asts[this.top - 2].nodeType === 96 /* ClassDeclaration */ ;
        };
        AstPath.prototype.isArgumentOfClassConstructor = function () {
            var ast = lastOf(this.asts);
            return this.count() >= 5 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === 94 /* List */  && this.asts[this.top - 2].nodeType === 73 /* FuncDecl */  && this.asts[this.top - 3].nodeType === 94 /* List */  && this.asts[this.top - 4].nodeType === 96 /* ClassDeclaration */  && ((this.asts[this.top - 2]).isConstructor) && ((this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) && ((this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);
        };
        AstPath.prototype.isChildOfInterface = function () {
            var ast = lastOf(this.asts);
            return this.count() >= 3 && this.asts[this.top] === ast && this.asts[this.top - 1].nodeType === 94 /* List */  && this.asts[this.top - 2].nodeType === 97 /* InterfaceDeclaration */ ;
        };
        AstPath.prototype.isTopLevelImplicitModule = function () {
            return this.count() >= 1 && this.asts[this.top].nodeType === 98 /* ModuleDeclaration */  && TypeScript.hasFlag((this.asts[this.top]).modFlags, 1024 /* IsWholeFile */ );
        };
        AstPath.prototype.isBodyOfTopLevelImplicitModule = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === 94 /* List */  && this.asts[this.top - 1].nodeType === 98 /* ModuleDeclaration */  && (this.asts[this.top - 1]).members == this.asts[this.top - 0] && TypeScript.hasFlag((this.asts[this.top - 1]).modFlags, 1024 /* IsWholeFile */ );
        };
        AstPath.prototype.isBodyOfScript = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 95 /* Script */  && (this.asts[this.top - 1]).bod == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfSwitch = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 88 /* Switch */  && (this.asts[this.top - 1]).caseList == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfModule = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 98 /* ModuleDeclaration */  && (this.asts[this.top - 1]).members == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfClass = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 96 /* ClassDeclaration */  && (this.asts[this.top - 1]).members == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfFunction = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 73 /* FuncDecl */  && (this.asts[this.top - 1]).bod == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfInterface = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 97 /* InterfaceDeclaration */  && (this.asts[this.top - 1]).members == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfBlock = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 86 /* Block */  && (this.asts[this.top - 1]).statements == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfFor = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 81 /* For */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfCase = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 87 /* Case */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfTry = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 89 /* Try */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfCatch = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 93 /* Catch */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfDoWhile = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 85 /* DoWhile */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfWhile = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 84 /* While */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfForIn = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 82 /* ForIn */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfWith = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 100 /* With */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfFinally = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 92 /* Finally */  && (this.asts[this.top - 1]).body == this.asts[this.top - 0];
        };
        AstPath.prototype.isCaseOfSwitch = function () {
            return this.count() >= 3 && this.asts[this.top - 2].nodeType === 88 /* Switch */  && this.asts[this.top - 1].nodeType === 94 /* List */  && (this.asts[this.top - 2]).caseList == this.asts[this.top - 1];
        };
        AstPath.prototype.isDefaultCaseOfSwitch = function () {
            return this.count() >= 3 && this.asts[this.top - 2].nodeType === 88 /* Switch */  && this.asts[this.top - 1].nodeType === 94 /* List */  && (this.asts[this.top - 2]).caseList == this.asts[this.top - 1] && (this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];
        };
        AstPath.prototype.isListOfObjectLit = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 11 /* ObjectLit */  && this.asts[this.top - 0].nodeType === 94 /* List */  && (this.asts[this.top - 1]).operand == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfObjectLit = function () {
            return this.isListOfObjectLit();
        };
        AstPath.prototype.isEmptyListOfObjectLit = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 11 /* ObjectLit */  && this.asts[this.top - 0].nodeType === 94 /* List */  && (this.asts[this.top - 1]).operand == this.asts[this.top - 0] && (this.asts[this.top - 0]).members.length == 0;
        };
        AstPath.prototype.isMemberOfObjectLit = function () {
            return this.count() >= 3 && this.asts[this.top - 2].nodeType === 11 /* ObjectLit */  && this.asts[this.top - 1].nodeType === 94 /* List */  && this.asts[this.top - 0].nodeType === 74 /* Member */  && (this.asts[this.top - 2]).operand == this.asts[this.top - 1];
        };
        AstPath.prototype.isNameOfMemberOfObjectLit = function () {
            return this.count() >= 4 && this.asts[this.top - 3].nodeType === 11 /* ObjectLit */  && this.asts[this.top - 2].nodeType === 94 /* List */  && this.asts[this.top - 1].nodeType === 74 /* Member */  && this.asts[this.top - 0].nodeType === 25 /* Name */  && (this.asts[this.top - 3]).operand == this.asts[this.top - 2];
        };
        AstPath.prototype.isListOfArrayLit = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 10 /* ArrayLit */  && this.asts[this.top - 0].nodeType === 94 /* List */  && (this.asts[this.top - 1]).operand == this.asts[this.top - 0];
        };
        AstPath.prototype.isTargetOfMember = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 74 /* Member */  && (this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];
        };
        AstPath.prototype.isMemberOfMember = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 74 /* Member */  && (this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];
        };
        AstPath.prototype.isItemOfList = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 94 /* List */ ;
        };
        AstPath.prototype.isThenOfIf = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 83 /* If */  && (this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];
        };
        AstPath.prototype.isElseOfIf = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 83 /* If */  && (this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];
        };
        AstPath.prototype.isBodyOfDefaultCase = function () {
            return this.isBodyOfCase();
        };
        AstPath.prototype.isSingleStatementList = function () {
            return this.count() >= 1 && this.asts[this.top].nodeType === 94 /* List */  && (this.asts[this.top]).members.length === 1;
        };
        AstPath.prototype.isArgumentListOfFunction = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === 94 /* List */  && this.asts[this.top - 1].nodeType === 73 /* FuncDecl */  && (this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        };
        AstPath.prototype.isArgumentOfFunction = function () {
            return this.count() >= 3 && this.asts[this.top - 1].nodeType === 94 /* List */  && this.asts[this.top - 2].nodeType === 73 /* FuncDecl */  && (this.asts[this.top - 2]).arguments === this.asts[this.top - 1];
        };
        AstPath.prototype.isArgumentListOfCall = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === 94 /* List */  && this.asts[this.top - 1].nodeType === 30 /* Call */  && (this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        };
        AstPath.prototype.isArgumentListOfNew = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === 94 /* List */  && this.asts[this.top - 1].nodeType === 31 /* New */  && (this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        };
        AstPath.prototype.isSynthesizedBlock = function () {
            return this.count() >= 1 && this.asts[this.top - 0].nodeType === 86 /* Block */  && (this.asts[this.top - 0]).isStatementBlock === false;
        };
        AstPath.prototype.isInClassImplementsList = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.parent().nodeType === 96 /* ClassDeclaration */ ) && (this.isMemberOfList((this.parent()).implementsList, this.ast()));
        };
        AstPath.prototype.isInInterfaceExtendsList = function () {
            if (this.ast() === null || this.parent() === null) {
                return false;
            }
            return (this.parent().nodeType === 97 /* InterfaceDeclaration */ ) && (this.isMemberOfList((this.parent()).extendsList, this.ast()));
        };
        AstPath.prototype.isMemberOfList = function (list, item) {
            if (list && list.members) {
                for(var i = 0, n = list.members.length; i < n; i++) {
                    if (list.members[i] === item) {
                        return true;
                    }
                }
            }
            return false;
        };
        return AstPath;
    })();
    TypeScript.AstPath = AstPath;    
    function isValidAstNode(ast) {
        if (ast === null) {
            return false;
        }
        if (ast.minChar === -1 || ast.limChar === -1) {
            return false;
        }
        return true;
    }
    TypeScript.isValidAstNode = isValidAstNode;
    var AstPathContext = (function () {
        function AstPathContext() {
            this.path = new TypeScript.AstPath();
        }
        return AstPathContext;
    })();
    TypeScript.AstPathContext = AstPathContext;    
    (function (GetAstPathOptions) {
        GetAstPathOptions._map = [];
        GetAstPathOptions.Default = 0;
        GetAstPathOptions.EdgeInclusive = 1;
        GetAstPathOptions.DontPruneSearchBasedOnPosition = 1 << 1;
    })(TypeScript.GetAstPathOptions || (TypeScript.GetAstPathOptions = {}));
    var GetAstPathOptions = TypeScript.GetAstPathOptions;
    function getAstPathToPosition(script, pos, options) {
        if (typeof options === "undefined") { options = 0 /* Default */ ; }
        var lookInComments = function (comments) {
            if (comments && comments.length > 0) {
                for(var i = 0; i < comments.length; i++) {
                    var minChar = comments[i].minChar;
                    var limChar = comments[i].limChar;
                    if (!comments[i].isBlockComment) {
                        limChar++;
                    }
                    if (pos >= minChar && pos < limChar) {
                        ctx.path.push(comments[i]);
                    }
                }
            }
        };
        var pre = function (cur, parent, walker) {
            if (isValidAstNode(cur)) {
                var inclusive = TypeScript.hasFlag(options, 1 /* EdgeInclusive */ ) || cur.nodeType === 25 /* Name */  || pos === script.limChar;
                var minChar = cur.minChar;
                var limChar = cur.limChar + (inclusive ? 1 : 0);
                if (pos >= minChar && pos < limChar) {
                    var previous = ctx.path.ast();
                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                        ctx.path.push(cur);
                    } else {
                    }
                }
                if (pos < limChar) {
                    lookInComments(cur.preComments);
                }
                if (pos >= minChar) {
                    lookInComments(cur.postComments);
                }
                if (!TypeScript.hasFlag(options, 2 /* DontPruneSearchBasedOnPosition */ )) {
                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }
            return cur;
        };
        var ctx = new AstPathContext();
        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);
        return ctx.path;
    }
    TypeScript.getAstPathToPosition = getAstPathToPosition;
    function getTokenizationOffset(script, position) {
        var bestOffset = 0;
        var pre = function (cur, parent, walker) {
            if (TypeScript.isValidAstNode(cur)) {
                if (cur.minChar <= position) {
                    bestOffset = max(bestOffset, cur.minChar);
                }
                if (cur.minChar > position || cur.limChar < bestOffset) {
                    walker.options.goChildren = false;
                }
            }
            return cur;
        };
        TypeScript.getAstWalkerFactory().walk(script, pre);
        return bestOffset;
    }
    TypeScript.getTokenizationOffset = getTokenizationOffset;
    function walkAST(ast, callback) {
        var pre = function (cur, parent, walker) {
            var path = walker.state;
            path.push(cur);
            callback(path, walker);
            return cur;
        };
        var post = function (cur, parent, walker) {
            var path = walker.state;
            path.pop();
            return cur;
        };
        var path = new AstPath();
        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);
    }
    TypeScript.walkAST = walkAST;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AstLogger = (function () {
        function AstLogger(logger) {
            this.logger = logger;
        }
        AstLogger.prototype.logScript = function (script) {
            var _this = this;
            this.logLinemap(script.locationInfo.lineMap);
            var stack = [];
            var pre = function (cur, parent) {
                stack.push(cur);
                var indent = (stack.length - 1) * 2;
                _this.logComments(script, cur.preComments, indent);
                _this.logNode(script, cur, indent);
                _this.logComments(script, cur.postComments, indent);
                return cur;
            };
            var post = function (cur, parent) {
                stack.pop();
                return cur;
            };
            TypeScript.getAstWalkerFactory().walk(script, pre, post);
        };
        AstLogger.prototype.logNode = function (script, cur, indent) {
            var msg = this.addPadding("", indent, "| ", true);
            msg = msg.concat("+ " + cur.treeViewLabel());
            msg = this.addPadding(msg, 70, " ", false);
            msg = msg + this.addLineColumn(script, cur.minChar);
            msg = this.addPadding(msg, 80, " ", false);
            msg = msg + "=> ";
            msg = msg + this.addLineColumn(script, cur.limChar);
            msg = this.addPadding(msg, 102, " ", false);
            msg = msg.concat("[" + this.addPadding(cur.minChar.toString(), 1, " ", true) + ", " + this.addPadding(cur.limChar.toString(), 1, " ", true) + "]");
            msg = this.addPadding(msg, 115, " ", false);
            msg = msg.concat("sym=" + (cur).sym);
            msg = this.addPadding(msg, 135, " ", false);
            msg = msg.concat("type=" + (cur.type === null ? "null" : cur.type.getTypeName()));
            this.logger.log(msg);
        };
        AstLogger.prototype.logComments = function (script, comments, indent) {
            if (comments == null) {
                return;
            }
            for(var i = 0; i < comments.length; i++) {
                this.logNode(script, comments[i], indent);
            }
        };
        AstLogger.prototype.logLinemap = function (linemap) {
            var result = "[";
            for(var i = 0; i < linemap.length; i++) {
                if (i > 0) {
                    result += ",";
                }
                result += linemap[i];
            }
            result += "]";
            this.logger.log("linemap: " + result);
        };
        AstLogger.prototype.addPadding = function (s, targetLength, paddingString, leftPadding) {
            var result = (leftPadding ? "" : s);
            for(var i = s.length; i < targetLength; i++) {
                result = result + paddingString;
            }
            result = result + (leftPadding ? s : "");
            return result;
        };
        AstLogger.prototype.addLineColumn = function (script, position) {
            var lineInfo = {
                line: -1,
                col: -1
            };
            TypeScript.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap);
            if (lineInfo.col !== -1) {
                lineInfo.col++;
            }
            return "(" + lineInfo.line + ", " + lineInfo.col + ")";
        };
        return AstLogger;
    })();
    TypeScript.AstLogger = AstLogger;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Binder = (function () {
        function Binder(checker) {
            this.checker = checker;
        }
        Binder.prototype.resolveBaseTypeLinks = function (typeLinks, scope) {
            var extendsList = null;
            if (typeLinks) {
                extendsList = new Array();
                for(var i = 0, len = typeLinks.length; i < len; i++) {
                    extendsList[i] = this.checker.resolveBaseTypeLink(typeLinks[i], scope);
                }
            }
            return extendsList;
        };
        Binder.prototype.resolveBases = function (scope, type) {
            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);
            var i = 0, len = type.extendsList.length;
            var derivedIsClass = type.isClassInstance();
            for(; i < len; i++) {
                var baseIsClass = type.extendsList[i].isClassInstance();
                if (type.extendsList[i] != this.checker.anyType) {
                    var baseRef = type.extendsTypeLinks[i].ast;
                    if (derivedIsClass) {
                        if (!baseIsClass) {
                            this.checker.errorReporter.simpleError(baseRef, "A class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is not a class.");
                        }
                    } else {
                        if (baseIsClass) {
                            this.checker.errorReporter.simpleError(baseRef, "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");
                        }
                    }
                }
            }
            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);
            if (type.implementsList) {
                for(i = 0, len = type.implementsList.length; i < len; i++) {
                    var iface = type.implementsList[i];
                    var baseRef = type.implementsTypeLinks[i].ast;
                    if (iface.isClassInstance()) {
                        if (derivedIsClass) {
                            this.checker.errorReporter.simpleError(baseRef, "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");
                        }
                    }
                }
            }
        };
        Binder.prototype.resolveSignatureGroup = function (signatureGroup, scope, instanceType) {
            var supplyVar = !(signatureGroup.hasImplementation);
            for(var i = 0, len = signatureGroup.signatures.length; i < len; i++) {
                var signature = signatureGroup.signatures[i];
                if (instanceType) {
                    signature.returnType.type = instanceType;
                } else {
                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);
                }
                var paramLen = signature.parameters.length;
                for(var j = 0; j < paramLen; j++) {
                    this.bindSymbol(scope, signature.parameters[j]);
                }
                if (signature.hasVariableArgList) {
                    var lastParam = signature.parameters[paramLen - 1];
                    lastParam.argsOffset = paramLen - 1;
                    if (!lastParam.getType().isArray()) {
                        this.checker.errorReporter.simpleErrorFromSym(lastParam, "... parameter must have array type");
                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);
                    }
                }
            }
        };
        Binder.prototype.bindType = function (scope, type, instanceType) {
            if (instanceType) {
                this.bindType(scope, instanceType, null);
            }
            var callAndConstructScope = scope;
            if (type.hasMembers()) {
                var members = type.members;
                var ambientMembers = type.ambientMembers;
                var typeMembers = type.getAllEnclosedTypes();
                var ambientTypeMembers = type.getAllAmbientEnclosedTypes();
                var memberScope = new TypeScript.SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);
                var agg = new TypeScript.SymbolAggregateScope(type.symbol);
                var prevCurrentModDecl = this.checker.currentModDecl;
                var prevBindStatus = this.checker.inBind;
                agg.addParentScope(memberScope);
                agg.addParentScope(scope);
                if (type.isModuleType()) {
                    this.checker.currentModDecl = type.symbol.declAST;
                    this.checker.inBind = true;
                }
                if (members) {
                    this.bind(agg, type.members.allMembers);
                }
                if (typeMembers) {
                    this.bind(agg, typeMembers.allMembers);
                }
                if (ambientMembers) {
                    this.bind(agg, ambientMembers.allMembers);
                }
                if (ambientTypeMembers) {
                    this.bind(agg, ambientTypeMembers.allMembers);
                }
                if (type.isModuleType()) {
                    callAndConstructScope = agg;
                }
                this.checker.currentModDecl = prevCurrentModDecl;
                this.checker.inBind = prevBindStatus;
            }
            if (type.extendsTypeLinks) {
                this.resolveBases(scope, type);
            }
            if (type.construct) {
                this.resolveSignatureGroup(type.construct, callAndConstructScope, instanceType);
            }
            if (type.call) {
                this.resolveSignatureGroup(type.call, callAndConstructScope, null);
            }
            if (type.index) {
                this.resolveSignatureGroup(type.index, scope, null);
            }
            if (type.elementType) {
                this.bindType(scope, type.elementType, null);
            }
        };
        Binder.prototype.bindSymbol = function (scope, symbol) {
            if (!symbol.bound) {
                var prevLocationInfo = this.checker.locationInfo;
                if ((this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {
                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];
                }
                switch(symbol.kind()) {
                    case 1 /* Type */ :
                        if (symbol.flags & 262144 /* Bound */ ) {
                            break;
                        }
                        var typeSymbol = symbol;
                        typeSymbol.flags |= 262144 /* Bound */ ;
                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == 25 /* Name */ ) {
                            var modPath = (typeSymbol.aliasLink.alias).text;
                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, function (id) {
                                return scope.find(id, false, true);
                            });
                            if (modSym) {
                                typeSymbol.type = modSym.getType();
                            }
                        }
                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {
                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);
                            if (typeSymbol.type.isModuleType()) {
                                for(var i = 0; i < typeSymbol.expansions.length; i++) {
                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);
                                }
                            }
                        }
                        break;
                    case 2 /* Field */ :
                        this.checker.resolveTypeLink(scope, (symbol).field.typeLink, false);
                        break;
                    case 3 /* Parameter */ :
                        this.checker.resolveTypeLink(scope, (symbol).parameter.typeLink, true);
                        break;
                }
                this.checker.locationInfo = prevLocationInfo;
            }
            symbol.bound = true;
        };
        Binder.prototype.bind = function (scope, table) {
            table.map(function (key, sym, binder) {
                binder.bindSymbol(scope, sym);
            }, this);
        };
        return Binder;
    })();
    TypeScript.Binder = Binder;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Base64Format = (function () {
        function Base64Format() { }
        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        Base64Format.encode = function encode(inValue) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        };
        Base64Format.decodeChar = function decodeChar(inChar) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            } else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        };
        return Base64Format;
    })();    
    var Base64VLQFormat = (function () {
        function Base64VLQFormat() { }
        Base64VLQFormat.encode = function encode(inValue) {
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            } else {
                inValue = inValue << 1;
            }
            var encodedStr = "";
            do {
                var currentDigit = inValue & 31;
                inValue = inValue >> 5;
                if (inValue > 0) {
                    currentDigit = currentDigit | 32;
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while(inValue > 0);
            return encodedStr;
        };
        Base64VLQFormat.decode = function decode(inString) {
            var result = 0;
            var negative = false;
            var shift = 0;
            for(var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15;
                } else {
                    result = result | ((byte & 31) << shift);
                }
                shift += (i == 0) ? 4 : 5;
                if ((byte & 32) === 32) {
                } else {
                    return {
                        value: negative ? -(result) : result,
                        rest: inString.substr(i + 1)
                    };
                }
            }
            throw new Error('Base64 value "' + inString + '" finished with a continuation bit');
        };
        return Base64VLQFormat;
    })();
    TypeScript.Base64VLQFormat = Base64VLQFormat;    
})(TypeScript || (TypeScript = {}));
var JSON2 = {};
((function () {
    'use strict';
    function f(n) {
        return n < 10 ? '0' + n : n;
    }
    if (typeof Date.prototype.toJSON !== 'function') {
        Date.prototype.toJSON = function (key) {
            return isFinite(this.valueOf()) ? this.getUTCFullYear() + '-' + f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate()) + 'T' + f(this.getUTCHours()) + ':' + f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds()) + 'Z' : null;
        };
        var strProto = String.prototype;
        var numProto = Number.prototype;
        numProto.JSON = strProto.JSON = (Boolean).prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }
    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"': '\\"',
        '\\': '\\\\'
    }, rep;
    function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
        var i, k = null, v, length, mind = gap, partial, value = holder[key];
        if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }
        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }
        switch(typeof value) {
            case 'string':
                return quote(value);
            case 'number':
                return isFinite(value) ? String(value) : 'null';
            case 'boolean':
            case 'null':
                return String(value);
            case 'object':
                if (!value) {
                    return 'null';
                }
                gap += indent;
                partial = [];
                if (Object.prototype.toString.apply(value, []) === '[object Array]') {
                    length = value.length;
                    for(i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }
                    v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }
                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for(i = 0; i < length; i += 1) {
                        if (typeof rep[i] === 'string') {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                } else {
                    for(k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                }
                v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
                gap = mind;
                return v;
        }
    }
    if (typeof JSON2.stringify !== 'function') {
        JSON2.stringify = function (value, replacer, space) {
            var i;
            gap = '';
            indent = '';
            if (typeof space === 'number') {
                for(i = 0; i < space; i += 1) {
                    indent += ' ';
                }
            } else if (typeof space === 'string') {
                indent = space;
            }
            rep = replacer;
            if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }
            return str('', {
                '': value
            });
        };
    }
})());
var TypeScript;
(function (TypeScript) {
    var SourceMapPosition = (function () {
        function SourceMapPosition() { }
        return SourceMapPosition;
    })();
    TypeScript.SourceMapPosition = SourceMapPosition;    
    var SourceMapping = (function () {
        function SourceMapping() {
            this.start = new SourceMapPosition();
            this.end = new SourceMapPosition();
            this.nameIndex = -1;
            this.childMappings = [];
        }
        return SourceMapping;
    })();
    TypeScript.SourceMapping = SourceMapping;    
    var SourceMapper = (function () {
        function SourceMapper(tsFileName, jsFileName, jsFile, sourceMapOut, errorReporter, emitFullPathOfSourceMap) {
            this.jsFile = jsFile;
            this.sourceMapOut = sourceMapOut;
            this.errorReporter = errorReporter;
            this.sourceMappings = [];
            this.currentMappings = [];
            this.names = [];
            this.currentNameIndex = [];
            this.currentMappings.push(this.sourceMappings);
            jsFileName = TypeScript.switchToForwardSlashes(jsFileName);
            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);
            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);
            var fixedPath = jsFileName.substring(0, removalIndex);
            if (emitFullPathOfSourceMap) {
                if (jsFileName.indexOf("://") == -1) {
                    jsFileName = "file:///" + jsFileName;
                }
                this.jsFileName = jsFileName;
            }
            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);
        }
        SourceMapper.MapFileExtension = ".map";
        SourceMapper.EmitSourceMapping = function EmitSourceMapping(allSourceMappers) {
            var sourceMapper = allSourceMappers[0];
            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);
            var sourceMapOut = sourceMapper.sourceMapOut;
            var mappingsString = "";
            var tsFiles = [];
            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var namesList = [];
            var namesCount = 0;
            var emitComma = false;
            var recordedPosition = null;
            for(var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {
                sourceMapper = allSourceMappers[sourceMapperIndex];
                var currentSourceIndex = tsFiles.length;
                tsFiles.push(sourceMapper.tsFileName);
                if (sourceMapper.names.length > 0) {
                    namesList.push.apply(namesList, sourceMapper.names);
                }
                var recordSourceMapping = function (mappedPosition, nameIndex) {
                    if (recordedPosition != null && recordedPosition.emittedColumn == mappedPosition.emittedColumn && recordedPosition.emittedLine == mappedPosition.emittedLine) {
                        return;
                    }
                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while(prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    } else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);
                    prevSourceIndex = currentSourceIndex;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;
                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;
                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);
                        prevNameIndex = namesCount + nameIndex;
                    }
                    emitComma = true;
                    recordedPosition = mappedPosition;
                };
                var recordSourceMappingSiblings = function (sourceMappings) {
                    for(var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                };
                recordSourceMappingSiblings(sourceMapper.sourceMappings, -1);
                namesCount = namesCount + sourceMapper.names.length;
            }
            sourceMapOut.Write(JSON2.stringify({
                version: 3,
                file: sourceMapper.jsFileName,
                sources: tsFiles,
                names: namesList,
                mappings: mappingsString
            }));
            try  {
                sourceMapOut.Close();
            } catch (ex) {
                sourceMapper.errorReporter.emitterError(null, ex.message);
            }
        };
        return SourceMapper;
    })();
    TypeScript.SourceMapper = SourceMapper;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (EAccessorModes) {
        EAccessorModes._map = [];
        EAccessorModes._map[0] = "GETTER";
        EAccessorModes.GETTER = 0;
        EAccessorModes._map[1] = "SETTER";
        EAccessorModes.SETTER = 1;
    })(TypeScript.EAccessorModes || (TypeScript.EAccessorModes = {}));
    var EAccessorModes = TypeScript.EAccessorModes;
    var InlineTextWriter = (function () {
        function InlineTextWriter() {
            this.buffer = "";
        }
        InlineTextWriter.prototype.Write = function (str) {
            this.buffer += str;
        };
        InlineTextWriter.prototype.WriteLine = function (str) {
            this.Write(str + '\r\n');
        };
        InlineTextWriter.prototype.Close = function () {
            this.Clear();
        };
        InlineTextWriter.prototype.Clear = function () {
            this.buffer = "";
        };
        return InlineTextWriter;
    })();    
    var InlineEngine = (function () {
        function InlineEngine() {
            this.contextMap = [];
            this.deferredContext = new Array();
            this.bEnabled = true;
            this.inlineStack = [];
            this.pDepthInfo = [];
            this.argMap = [];
            this.deferredArgument = [];
            this.lastArg = {
                i: 0,
                n: 0,
                arg: null
            };
            this.outBuffer = new InlineTextWriter();
            this.emitter = null;
        }
        InlineEngine.prototype.grabImitterOutput = function (emitter) {
            var pOut = emitter.outfile;
            this.emitter = emitter;
            emitter.outfile = this.outBuffer;
            this.outBuffer = pOut;
        };
        InlineEngine.prototype.restoreImitterOutput = function () {
            var pOut = this.emitter.outfile;
            this.emitter.outfile = this.outBuffer;
            this.outBuffer = pOut;
            this.emitter = null;
        };
        InlineEngine.prototype.normalizeModuleName = function (emitter, container) {
            if (!this.isActive()) {
                return container.name;
            }
            var origin = container;
            var pGroupT = [];
            var pGroupP = emitter.moduleDeclList;
            while(container) {
                pGroupT.push(container);
                container = container.container;
            }
            pGroupT.length--;
            pGroupT.reverse();
            var s = "";
            emitter.writeToOutput("/*checked (origin: " + origin.name + ")>>*/");
            for(var i = 0; i < pGroupP.length; ++i) {
                if (pGroupP[i].name.text != pGroupT[i].name) {
                    for(var j = i; j < pGroupT.length; ++j) {
                        s += pGroupT[j].name + (j != pGroupT.length - 1 ? "." : "");
                    }
                    return s;
                }
                if (i == pGroupT.length - 1) {
                    return s + origin.name;
                }
                s += pGroupP[i].name.text + ".";
            }
            return origin.name;
        };
        InlineEngine.prototype.begin = function (pFunc) {
            if (typeof pFunc === "undefined") { pFunc = null; }
            this.pDepthInfo.push([]);
            this.argMap.push([]);
            this.inlineStack.push(pFunc);
        };
        InlineEngine.prototype.end = function () {
            this.pDepthInfo.pop();
            this.argMap.pop();
            this.inlineStack.pop();
        };
        InlineEngine.prototype.depth = function () {
            return this.pDepthInfo.length;
        };
        InlineEngine.prototype.argv = function (iLevel) {
            return this.pDepthInfo[!TypeScript.isDef(iLevel) ? this.pDepthInfo.length - 1 : iLevel >= 0 ? iLevel : this.pDepthInfo.length - 1 + iLevel];
        };
        InlineEngine.prototype.argc = function () {
            return this.pDepthInfo[this.pDepthInfo.length - 1].length;
        };
        InlineEngine.prototype.argumentsMap = function (iLevel) {
            return this.argMap[!TypeScript.isDef(iLevel) ? this.argMap.length - 1 : iLevel >= 0 ? iLevel : this.argMap.length - 1 + iLevel];
        };
        InlineEngine.prototype.isActive = function () {
            return this.depth() > 0;
        };
        InlineEngine.prototype.disable = function () {
            this.bEnabled = false;
        };
        InlineEngine.prototype.enable = function () {
            this.bEnabled = true;
        };
        InlineEngine.prototype.isEnabled = function () {
            return this.bEnabled;
        };
        InlineEngine.prototype.replaceArgumentByText = function (emitter, pExpr) {
            if (this.emitter === null) {
                this.grabImitterOutput(emitter);
            }
            var pWriter = (emitter.outfile);
            var sCurrentData = pWriter.buffer;
            var sResult;
            pWriter.Clear();
            emitter.emitJavascript(pExpr, 56 /* OpenParen */ , false);
            sResult = pWriter.buffer;
            pWriter.buffer = sCurrentData;
            if (this.emitter !== null) {
                this.restoreImitterOutput();
            }
            return new TypeScript.StringLiteral(sResult);
        };
        InlineEngine.prototype.findArgIndex = function (pArg) {
            var argv = this.argv();
            for(var i = 0; i < argv.length; ++i) {
                if (argv[i] === pArg) {
                    return i;
                }
            }
            throw new Error("cannot find argument in inline argument map");
        };
        InlineEngine.prototype.replaceArgument = function (emitter, pArg, pExpr) {
            var argv = this.argv();
            var argMap = this.argumentsMap();
            var n = argv.length;
            argMap[n] = this.replaceArgumentByText(emitter, pExpr);
            argv.push(pArg);
        };
        InlineEngine.prototype.printArgumentsMap = function () {
            var s = "";
            s += "\n";
            for(var i = 0; i < this.depth(); ++i) {
                var map = this.argumentsMap(i);
                s += i + ": " + this.inlineStack[i].treeViewLabel() + "[ ";
                for(var j = 0; j < map.length; ++j) {
                    s += "(" + this.argv(i)[j].printLabel() + ") " + (map[j] ? map[j].printLabel() : null) + ", ";
                }
                s += " ]\n";
            }
            console.log(s);
        };
        InlineEngine.prototype.rollbackArgument = function (pArg) {
            var n = this.findArgIndex(pArg);
            var argMap = this.argumentsMap();
            if (argMap[n]) {
                argMap[n] = null;
                return true;
            }
            return false;
        };
        InlineEngine.prototype.findArgumentIndexByProto = function (pProto, iLevel) {
            if (typeof iLevel === "undefined") { iLevel = 0; }
            var argv = this.argv(iLevel);
            var argv = this.argv(iLevel);
            for(var i = 0; i < argv.length; ++i) {
                if (argv[i].id.text == pProto.text) {
                    break;
                }
            }
            if (i == argv.length) {
                return -1;
            }
            return i;
        };
        InlineEngine.prototype.getArgument = function (pProto) {
            for(var i = this.depth() - 1; i >= 0; --i) {
                var n = this.findArgumentIndexByProto(pProto, i);
                if (n < 0) {
                    continue;
                }
                var argMap = this.argumentsMap(i);
                if (argMap[n] === null) {
                    continue;
                }
                this.lastArg.n = n;
                this.lastArg.i = i;
                this.lastArg.arg = argMap[n];
                return argMap[n] || null;
            }
            return null;
        };
        InlineEngine.prototype.shiftArgument = function (pProto) {
            var lastArg = this.lastArg;
            var i = lastArg.i;
            var n = lastArg.n;
            var arg = lastArg.arg;
            var argMap = this.argumentsMap(i);
            this.deferredArgument.push({
                i: i,
                n: n,
                arg: arg
            });
            argMap[n] = null;
            return arg;
        };
        InlineEngine.prototype.unshiftArgument = function (pProto) {
            var defArg = this.deferredArgument.pop();
            var i = defArg.i;
            var n = defArg.n;
            var argMap = this.argumentsMap(i);
            argMap[n] = defArg.arg;
        };
        InlineEngine.prototype.replaceContext = function (pExpr) {
            var ctx = this.getContext();
            this.contextMap.push(pExpr);
        };
        InlineEngine.prototype.printContextMap = function () {
            var s = "{ ";
            for(var i = 0; i < this.contextMap.length; ++i) {
                s += this.contextMap[i].printLabel() + (i == this.contextMap.length - 1 ? "" : ", ");
            }
            s += " }";
            console.log(s);
        };
        InlineEngine.prototype.rollbackContext = function () {
            return TypeScript.isDefAndNotNull(this.contextMap.pop());
        };
        InlineEngine.prototype.getContext = function () {
            return this.contextMap[this.contextMap.length - 1];
        };
        InlineEngine.prototype.shiftContext = function () {
            var pExpr = this.contextMap.pop() || null;
            this.deferredContext.push(pExpr);
            return pExpr;
        };
        InlineEngine.prototype.unshiftContext = function () {
            this.contextMap.push(this.deferredContext.pop());
        };
        InlineEngine.prototype.getExpression = function (eExpr, pProto) {
            if (typeof pProto === "undefined") { pProto = null; }
            if (eExpr === 25 /* Name */ ) {
                return this.getArgument(pProto);
            }
            if (eExpr !== 5 /* This */ ) {
                throw new Error("unsupported call");
            }
            return this.getContext();
        };
        InlineEngine.prototype.shiftExpression = function (eExpr, pProto) {
            if (typeof pProto === "undefined") { pProto = null; }
            if (eExpr == 25 /* Name */ ) {
                return this.shiftArgument(pProto);
            }
            return this.shiftContext();
        };
        InlineEngine.prototype.unshiftExpression = function (eExpr, pProto) {
            if (typeof pProto === "undefined") { pProto = null; }
            if (eExpr == 25 /* Name */ ) {
                this.unshiftArgument(pProto);
                return;
            }
            this.unshiftContext();
        };
        InlineEngine.prototype.inline = function (target, emitter, tokenId, startLine) {
            if (!this.isActive()) {
                return false;
            }
            var eqv = this.getExpression(target.nodeType, target);
            if (!TypeScript.isDefAndNotNull(eqv)) {
                return false;
            }
            if (eqv.nodeType != 25 /* Name */ ) {
                emitter.writeToOutput("(");
            }
            this.shiftExpression(target.nodeType, target);
            emitter.emitJavascript(eqv, 56 /* OpenParen */ , false);
            this.unshiftExpression(target.nodeType, target);
            if (eqv.nodeType != 25 /* Name */ ) {
                emitter.writeToOutput(")");
            }
            return true;
        };
        InlineEngine.prototype.inlineFunction = function (emitter, target, funcDecl, argData) {
            return false;
            if (typeof argData === "undefined") { argData = null; }
            var realTarget = target;
            var isUnsupported = false;
            var type = null;
            if (!this.isEnabled()) {
                return false;
            }
            var args = null;
            if (TypeScript.isDefAndNotNull(argData)) {
                if (argData.nodeType != 94 /* List */ ) {
                    args = [
                        argData
                    ];
                } else {
                    args = (argData).members;
                }
            } else {
                args = [];
            }
            if (this.depth() > 1 && TypeScript.isDefAndNotNull(args)) {
                for(var i = 0; i < args.length; ++i) {
                    switch(args[i].nodeType) {
                        case 30 /* Call */ :
                        case 31 /* New */ :
                        case 10 /* ArrayLit */ :
                        case 11 /* ObjectLit */ :
                            emitter.writeToOutput("/*warning: used unsafe argument when you call the inline function(" + args[i].printLabel() + ")*/");
                            return false;
                    }
                }
            }
            if (target.nodeType == 25 /* Name */  || target.nodeType == 19 /* Dot */  || target.nodeType == 31 /* New */  || target.nodeType == 5 /* This */  || target.nodeType == 32 /* Asg */ ) {
                if (target.nodeType != 25 /* Name */ ) {
                    if (target.nodeType == 19 /* Dot */ ) {
                        realTarget = (target).operand1;
                    }
                    type = realTarget.type;
                    if (TypeScript.isNull(type)) {
                        emitter.writeToOutput("/*not inlined, because context type is undefined*/");
                        return false;
                    }
                    if (!type.isClassInstance() && !type.isModuleType()) {
                        emitter.writeToOutput("/*not inlined, because context is not class or module*/");
                        return false;
                    }
                }
            } else {
                emitter.writeToOutput("/*not inlined, because expression has unsupported type(type: " + target.nodeType + ")*/");
                return false;
            }
            type = realTarget.type;
            var body = funcDecl.bod.members;
            if ((body.length > 1 && !(body.length == 2 && body[1].nodeType == 105 /* EndCode */ )) && body[0].nodeType != 77 /* Return */ ) {
                emitter.writeToOutput("/*not inlined, because supportes only single statement functions(cur. st. count: " + body.length + ")*/");
                return false;
            }
            var expType = body[0].nodeType;
            if (expType != 77 /* Return */  && expType != 30 /* Call */  && expType != 19 /* Dot */  && expType != 32 /* Asg */ ) {
                emitter.writeToOutput("/*not inlined, because first statement is not return/call/dot(cur st.: " + body[0].treeViewLabel() + ")*/");
                return false;
            }
            this.begin(funcDecl);
            var argv = funcDecl.arguments.members;
            for(var i = 0; i < argv.length; ++i) {
                this.replaceArgument(emitter, argv[i], args[i] || new TypeScript.Identifier("undefined"));
            }
            if (!TypeScript.isNull(type)) {
                if (type.isClassInstance()) {
                    this.replaceContext(realTarget);
                }
            }
            var st = funcDecl.bod.members[0];
            var res = st.nodeType == 77 /* Return */  ? (st).returnExpression : st;
            emitter.writeToOutput("(");
            emitter.emitJavascript(res, 56 /* OpenParen */ , true);
            emitter.writeToOutput(")");
            for(var i = 0; i < argv.length; ++i) {
                this.rollbackArgument(argv[i]);
            }
            if (!TypeScript.isNull(type)) {
                if (type.isClassInstance()) {
                    this.rollbackContext();
                }
            }
            this.end();
            return true;
        };
        return InlineEngine;
    })();
    TypeScript.InlineEngine = InlineEngine;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (EmitContainer) {
        EmitContainer._map = [];
        EmitContainer._map[0] = "Prog";
        EmitContainer.Prog = 0;
        EmitContainer._map[1] = "Module";
        EmitContainer.Module = 1;
        EmitContainer._map[2] = "DynamicModule";
        EmitContainer.DynamicModule = 2;
        EmitContainer._map[3] = "Class";
        EmitContainer.Class = 3;
        EmitContainer._map[4] = "Constructor";
        EmitContainer.Constructor = 4;
        EmitContainer._map[5] = "Function";
        EmitContainer.Function = 5;
        EmitContainer._map[6] = "Args";
        EmitContainer.Args = 6;
        EmitContainer._map[7] = "Interface";
        EmitContainer.Interface = 7;
    })(TypeScript.EmitContainer || (TypeScript.EmitContainer = {}));
    var EmitContainer = TypeScript.EmitContainer;
    var EmitState = (function () {
        function EmitState() {
            this.column = 0;
            this.line = 0;
            this.pretty = false;
            this.inObjectLiteral = false;
            this.container = 0 /* Prog */ ;
        }
        return EmitState;
    })();
    TypeScript.EmitState = EmitState;    
    var EmitOptions = (function () {
        function EmitOptions(settings) {
            this.ioHost = null;
            this.outputMany = true;
            this.commonDirectoryPath = "";
            this.minWhitespace = settings.minWhitespace;
            this.propagateConstants = settings.propagateConstants;
            this.emitComments = settings.emitComments;
            this.outputOption = settings.outputOption;
            this.emitFullSourceMapPath = settings.emitFullSourceMapPath;
        }
        EmitOptions.prototype.mapOutputFileName = function (fileName, extensionChanger) {
            if (this.outputMany) {
                var updatedFileName = fileName;
                if (this.outputOption != "") {
                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");
                    updatedFileName = this.outputOption + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            } else {
                return extensionChanger(this.outputOption, true);
            }
        };
        return EmitOptions;
    })();
    TypeScript.EmitOptions = EmitOptions;    
    var Indenter = (function () {
        function Indenter() {
            this.indentAmt = 0;
        }
        Indenter.indentStep = 4;
        Indenter.indentStepString = "    ";
        Indenter.indentStrings = [];
        Indenter.prototype.increaseIndent = function () {
            this.indentAmt += Indenter.indentStep;
        };
        Indenter.prototype.decreaseIndent = function () {
            this.indentAmt -= Indenter.indentStep;
        };
        Indenter.prototype.getIndent = function () {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for(var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        };
        return Indenter;
    })();
    TypeScript.Indenter = Indenter;    
    var Emitter = (function () {
        function Emitter(checker, emittingFileName, outfile, emitOptions, errorReporter) {
            this.checker = checker;
            this.emittingFileName = emittingFileName;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.errorReporter = errorReporter;
            this.globalThisCapturePrologueEmitted = false;
            this.extendsPrologueEmitted = false;
            this.thisClassNode = null;
            this.thisFnc = null;
            this.moduleDeclList = [];
            this.moduleName = "";
            this.emitState = new EmitState();
            this.indenter = new Indenter();
            this.ambientModule = false;
            this.modAliasId = null;
            this.firstModAlias = null;
            this.allSourceMappers = [];
            this.sourceMapper = null;
            this.captureThisStmtString = "var _this = this;";
            this.varListCountStack = [
                0
            ];
            this.inlineEngine = new TypeScript.InlineEngine();
        }
        Emitter.prototype.setSourceMappings = function (mapper) {
            this.allSourceMappers.push(mapper);
            this.sourceMapper = mapper;
        };
        Emitter.prototype.writeToOutput = function (s) {
            this.outfile.Write(s);
            this.emitState.column += s.length;
        };
        Emitter.prototype.writeToOutputTrimmable = function (s) {
            if (this.emitOptions.minWhitespace) {
                s = s.replace(/[\s]*/g, '');
            }
            this.writeToOutput(s);
        };
        Emitter.prototype.writeLineToOutput = function (s) {
            if (this.emitOptions.minWhitespace) {
                this.writeToOutput(s);
                var c = s.charCodeAt(s.length - 1);
                if (!((c == TypeScript.LexCodeSpace) || (c == TypeScript.LexCodeSMC) || (c == TypeScript.LexCodeLBR))) {
                    this.writeToOutput(' ');
                }
            } else {
                this.outfile.WriteLine(s);
                this.emitState.column = 0;
                this.emitState.line++;
            }
        };
        Emitter.prototype.writeCaptureThisStatement = function (ast) {
            this.emitIndent();
            this.recordSourceMappingStart(ast);
            this.writeToOutput(this.captureThisStmtString);
            this.recordSourceMappingEnd(ast);
            this.writeLineToOutput("");
        };
        Emitter.prototype.setInVarBlock = function (count) {
            this.varListCountStack[this.varListCountStack.length - 1] = count;
        };
        Emitter.prototype.setInObjectLiteral = function (val) {
            var temp = this.emitState.inObjectLiteral;
            this.emitState.inObjectLiteral = val;
            return temp;
        };
        Emitter.prototype.setContainer = function (c) {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        };
        Emitter.prototype.getIndentString = function () {
            if (this.emitOptions.minWhitespace) {
                return "";
            } else {
                return this.indenter.getIndent();
            }
        };
        Emitter.prototype.emitIndent = function () {
            if (!this.inlineEngine.isActive()) {
                this.writeToOutput(this.getIndentString());
            }
        };
        Emitter.prototype.emitCommentInPlace = function (comment) {
            var text = comment.getText();
            var hadNewLine = false;
            if (comment.isBlockComment) {
                if (this.emitState.column == 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                if (text.length > 1 || comment.endsLine) {
                    for(var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                    hadNewLine = true;
                } else {
                    this.recordSourceMappingEnd(comment);
                }
            } else {
                if (this.emitState.column == 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
                hadNewLine = true;
            }
            if (hadNewLine) {
                this.emitIndent();
            } else {
                this.writeToOutput(" ");
            }
        };
        Emitter.prototype.emitParensAndCommentsInPlace = function (ast, pre) {
            var comments = pre ? ast.preComments : ast.postComments;
            if (ast.isParenthesized && !pre) {
                this.writeToOutput(")");
            }
            if (this.emitOptions.emitComments && comments && comments.length != 0) {
                for(var i = 0; i < comments.length; i++) {
                    this.emitCommentInPlace(comments[i]);
                }
            }
            if (ast.isParenthesized && pre) {
                this.writeToOutput("(");
            }
        };
        Emitter.prototype.emitObjectLiteral = function (content) {
            if (content.members.length === 0) {
                this.writeToOutput("{}");
                return;
            }
            this.writeLineToOutput("{");
            this.indenter.increaseIndent();
            var inObjectLiteral = this.setInObjectLiteral(true);
            this.emitJavascriptList(content, ",", 62 /* Comma */ , true, false, false);
            this.setInObjectLiteral(inObjectLiteral);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
        };
        Emitter.prototype.emitArrayLiteral = function (content) {
            this.writeToOutput("[");
            if (content) {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascriptList(content, ", ", 62 /* Comma */ , true, false, false);
                this.indenter.decreaseIndent();
                this.emitIndent();
            }
            this.writeToOutput("]");
        };
        Emitter.prototype.emitNew = function (target, args) {
            this.writeToOutput("new ");
            if (target.nodeType == 28 /* TypeRef */ ) {
                var typeRef = target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                } else {
                    this.emitJavascript(typeRef.term, 98 /* Tilde */ , false);
                    this.writeToOutput("()");
                }
            } else {
                this.emitJavascript(target, 98 /* Tilde */ , false);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitJavascriptList(args, ", ", 62 /* Comma */ , false, false, false);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        };
        Emitter.prototype.getConstantValue = function (init) {
            if (init) {
                if (init.nodeType === 24 /* NumberLit */ ) {
                    var numLit = init;
                    return numLit.value;
                } else if (init.nodeType === 63 /* Lsh */ ) {
                    var binop = init;
                    if (binop.operand1.nodeType === 24 /* NumberLit */  && binop.operand2.nodeType === 24 /* NumberLit */ ) {
                        return (binop.operand1).value << (binop.operand2).value;
                    }
                } else if (init.nodeType === 25 /* Name */ ) {
                    var ident = init;
                    if (ident.sym !== null && ident.sym.declAST.nodeType === 75 /* VarDecl */ ) {
                        var varDecl = ident.sym.declAST;
                        return this.getConstantValue(varDecl.init);
                    }
                }
            }
            return null;
        };
        Emitter.prototype.tryEmitConstant = function (dotExpr) {
            if (!this.emitOptions.propagateConstants) {
                return false;
            }
            var propertyName = dotExpr.operand2;
            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {
                if (TypeScript.hasFlag(propertyName.sym.flags, 32768 /* Constant */ )) {
                    if (propertyName.sym.declAST) {
                        var boundDecl = propertyName.sym.declAST;
                        var value = this.getConstantValue(boundDecl.init);
                        if (value !== null) {
                            this.writeToOutput(value.toString());
                            var comment = " /* ";
                            comment += propertyName.actualText;
                            comment += " */ ";
                            this.writeToOutput(comment);
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        Emitter.prototype.emitCall = function (callNode, target, args) {
            var funcDecl = null;
            var isInlined = false;
            if (!this.emitSuperCall(callNode)) {
                if (!TypeScript.hasFlag(callNode.flags, 512 /* ClassBaseConstructorCall */ )) {
                    if (target.nodeType == 73 /* FuncDecl */  && !target.isParenthesized) {
                        this.writeToOutput("(");
                    }
                    if (callNode.target.nodeType == 6 /* Super */  && this.emitState.container == 4 /* Constructor */ ) {
                        this.writeToOutput("_super.call");
                    } else {
                        if (TypeScript.isDefAndNotNull(callNode.signature)) {
                            funcDecl = callNode.signature.declAST;
                            if (TypeScript.isDefAndNotNull(funcDecl) && funcDecl.isInline()) {
                                isInlined = this.inlineEngine.inlineFunction(this, target, funcDecl, args);
                            }
                            if (!isInlined) {
                                this.emitJavascript(target, 56 /* OpenParen */ , false);
                            }
                        } else {
                            this.emitJavascript(target, 56 /* OpenParen */ , false);
                        }
                    }
                    if (target.nodeType == 73 /* FuncDecl */  && !target.isParenthesized) {
                        this.writeToOutput(")");
                    }
                    if (!isInlined) {
                        this.recordSourceMappingStart(args);
                        this.writeToOutput("(");
                        if (callNode.target.nodeType == 6 /* Super */  && this.emitState.container == 4 /* Constructor */ ) {
                            this.writeToOutput("this");
                            if (args && args.members.length) {
                                this.writeToOutput(", ");
                            }
                        }
                        this.emitJavascriptList(args, ", ", 62 /* Comma */ , false, false, false);
                        this.writeToOutput(")");
                        this.recordSourceMappingEnd(args);
                    }
                } else {
                    this.indenter.decreaseIndent();
                    this.indenter.decreaseIndent();
                    var constructorCall = new TypeScript.ASTList();
                    constructorCall.members[0] = callNode;
                    this.emitConstructorCalls(constructorCall, this.thisClassNode);
                    this.indenter.increaseIndent();
                    this.indenter.increaseIndent();
                }
            }
        };
        Emitter.prototype.emitConstructorCalls = function (bases, classDecl) {
            if (bases == null) {
                return;
            }
            var basesLen = bases.members.length;
            this.recordSourceMappingStart(classDecl);
            for(var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol = null;
                if (baseExpr.nodeType == 30 /* Call */ ) {
                    baseSymbol = (baseExpr).target.type.symbol;
                } else {
                    baseSymbol = baseExpr.type.symbol;
                }
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                if (baseExpr.nodeType == 30 /* Call */ ) {
                    this.emitIndent();
                    this.writeToOutput("_super.call(this");
                    var args = (baseExpr).arguments;
                    if (args && (args.members.length > 0)) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(args, ", ", 62 /* Comma */ , false, false, false);
                    }
                    this.writeToOutput(")");
                } else {
                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {
                        this.emitIndent();
                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");
                        this.writeToOutput(".call(this)");
                    }
                }
            }
            this.recordSourceMappingEnd(classDecl);
        };
        Emitter.prototype.emitInnerFunction = function (funcDecl, printName, isMember, bases, hasSelfRef, classDecl) {
            var isClassConstructor = funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ );
            var hasNonObjectBaseType = isClassConstructor && TypeScript.hasFlag(this.thisClassNode.type.instanceType.typeFlags, 32 /* HasBaseType */ ) && !TypeScript.hasFlag(this.thisClassNode.type.instanceType.typeFlags, 64 /* HasBaseTypeOfObject */ );
            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && TypeScript.hasFlag((this.thisClassNode).varFlags, 32768 /* ClassSuperMustBeFirstCallInConstructor */ );
            var shouldParenthesize = TypeScript.hasFlag(funcDecl.fncFlags, 131072 /* IsFunctionExpression */ ) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (TypeScript.hasFlag(funcDecl.flags, 1 /* ExplicitSemicolon */ ) || TypeScript.hasFlag(funcDecl.flags, 2 /* AutomaticSemicolon */ ));
            this.emitParensAndCommentsInPlace(funcDecl, true);
            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            if (!(funcDecl.isAccessor() && (funcDecl.accessorSymbol).isObjectLitField)) {
                this.writeToOutput((funcDecl.isInline() ? "/** @inline */" : "") + "function ");
            }
            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }
            this.writeToOutput("(");
            var argsLen = 0;
            var i = 0;
            var arg;
            var defaultArgs = [];
            if (funcDecl.arguments) {
                var tempContainer = this.setContainer(6 /* Args */ );
                argsLen = funcDecl.arguments.members.length;
                var printLen = argsLen;
                if (funcDecl.variableArgList) {
                    printLen--;
                }
                for(i = 0; i < printLen; i++) {
                    arg = funcDecl.arguments.members[i];
                    if (arg.init) {
                        defaultArgs.push(arg);
                    }
                    this.emitJavascript(arg, 56 /* OpenParen */ , false);
                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);
            }
            this.writeLineToOutput(") {");
            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();
            for(i = 0; i < defaultArgs.length; i++) {
                var arg = defaultArgs[i];
                this.emitIndent();
                this.recordSourceMappingStart(arg);
                this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");
                this.recordSourceMappingStart(arg.id);
                this.writeToOutput(arg.id.actualText);
                this.recordSourceMappingEnd(arg.id);
                this.writeToOutput(" = ");
                this.emitJavascript(arg.init, 56 /* OpenParen */ , false);
                this.writeLineToOutput("; }");
                this.recordSourceMappingEnd(arg);
            }
            if (funcDecl.isConstructor && ((funcDecl.classDecl).varFlags & 131072 /* MustCaptureThis */ )) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {
                if (funcDecl.arguments) {
                    argsLen = funcDecl.arguments.members.length;
                    for(i = 0; i < argsLen; i++) {
                        arg = funcDecl.arguments.members[i];
                        if ((arg.varFlags & 512 /* Property */ ) != 0 /* None */ ) {
                            this.emitIndent();
                            this.recordSourceMappingStart(arg);
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput("this." + arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeToOutput(" = ");
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput(arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeLineToOutput(";");
                            this.recordSourceMappingEnd(arg);
                        }
                    }
                }
                if (!TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) {
                    this.emitConstructorCalls(bases, classDecl);
                }
            }
            if (hasSelfRef) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.variableArgList) {
                argsLen = funcDecl.arguments.members.length;
                var lastArg = funcDecl.arguments.members[argsLen - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(lastArg.id);
                this.writeToOutput(lastArg.id.actualText);
                this.recordSourceMappingEnd(lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var _i = 0;");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput(" ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput("; ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i++");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
            if (funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ ) && !classPropertiesMustComeAfterSuperCall) {
                var nProps = (this.thisClassNode.members).members.length;
                for(var i = 0; i < nProps; i++) {
                    if ((this.thisClassNode.members).members[i].nodeType == 75 /* VarDecl */ ) {
                        var varDecl = (this.thisClassNode.members).members[i];
                        if (!TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ ) && varDecl.init) {
                            this.emitIndent();
                            this.emitJavascriptVarDecl(varDecl, 98 /* Tilde */ );
                            this.writeLineToOutput("");
                        }
                    }
                }
            }
            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl.endingToken);
            this.writeToOutput("}");
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl.endingToken);
            this.recordSourceMappingEnd(funcDecl);
            if (shouldParenthesize) {
                this.writeToOutput(")");
            }
            this.recordSourceMappingEnd(funcDecl);
            this.emitParensAndCommentsInPlace(funcDecl, false);
            if (!isMember && !TypeScript.hasFlag(funcDecl.fncFlags, 131072 /* IsFunctionExpression */ ) && (!TypeScript.hasFlag(funcDecl.fncFlags, 512 /* Signature */ ) || funcDecl.isConstructor)) {
                this.writeLineToOutput("");
            } else if (TypeScript.hasFlag(funcDecl.fncFlags, 131072 /* IsFunctionExpression */ )) {
                if (TypeScript.hasFlag(funcDecl.flags, 1 /* ExplicitSemicolon */ ) || TypeScript.hasFlag(funcDecl.flags, 2 /* AutomaticSemicolon */ )) {
                    this.writeLineToOutput(";");
                }
            }
        };
        Emitter.prototype.emitJavascriptModule = function (moduleDecl) {
            var modName = moduleDecl.name.actualText;
            if (TypeScript.isTSFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 3));
            } else if (TypeScript.isSTRFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 4));
            }
            if (!TypeScript.hasFlag(moduleDecl.modFlags, 8 /* Ambient */ )) {
                var isDynamicMod = TypeScript.hasFlag(moduleDecl.modFlags, 2048 /* IsDynamic */ );
                var prevOutFile = this.outfile;
                var prevOutFileName = this.emittingFileName;
                var prevAllSourceMappers = this.allSourceMappers;
                var prevSourceMapper = this.sourceMapper;
                var prevColumn = this.emitState.column;
                var prevLine = this.emitState.line;
                var temp = this.setContainer(1 /* Module */ );
                var svModuleName = this.moduleName;
                var isExported = TypeScript.hasFlag(moduleDecl.modFlags, 1 /* Exported */ );
                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;
                var isWholeFile = TypeScript.hasFlag(moduleDecl.modFlags, 1024 /* IsWholeFile */ );
                this.moduleName = moduleDecl.name.actualText;
                if (isDynamicMod) {
                    var tsModFileName = TypeScript.stripQuotes(moduleDecl.name.actualText);
                    var modFilePath = TypeScript.trimModName(tsModFileName) + ".js";
                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScript.TypeScriptCompiler.mapToJSFileName);
                    if (this.emitOptions.ioHost) {
                        if (TypeScript.switchToForwardSlashes(modFilePath) != TypeScript.switchToForwardSlashes(this.emittingFileName)) {
                            this.emittingFileName = modFilePath;
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);
                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);
                            if (prevSourceMapper != null) {
                                this.allSourceMappers = [];
                                var sourceMappingFile = this.createFile(this.emittingFileName + TypeScript.SourceMapper.MapFileExtension, false);
                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter, this.emitOptions.emitFullSourceMapPath));
                                this.emitState.column = 0;
                                this.emitState.line = 0;
                            }
                        } else {
                            TypeScript.CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");
                        }
                    }
                    this.setContainer(2 /* DynamicModule */ );
                    this.recordSourceMappingStart(moduleDecl);
                    if (TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                        var dependencyList = "[\"require\", \"exports\"";
                        var importList = "require, exports";
                        var importStatement = null;
                        for(var i = 0; i < (moduleDecl.mod).importedModules.length; i++) {
                            importStatement = (moduleDecl.mod).importedModules[i];
                            if (importStatement.id.sym && !(importStatement.id.sym).onlyReferencedAsTypeRef) {
                                if (i <= (moduleDecl.mod).importedModules.length - 1) {
                                    dependencyList += ", ";
                                    importList += ", ";
                                }
                                importList += "__" + importStatement.id.actualText + "__";
                                dependencyList += importStatement.firstAliasedModToString();
                            }
                        }
                        for(var i = 0; i < moduleDecl.amdDependencies.length; i++) {
                            dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
                        }
                        dependencyList += "]";
                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                    } else {
                    }
                } else {
                    if (!isExported) {
                        this.recordSourceMappingStart(moduleDecl);
                        this.writeToOutput("var ");
                        this.recordSourceMappingStart(moduleDecl.name);
                        this.writeToOutput(this.moduleName);
                        this.recordSourceMappingEnd(moduleDecl.name);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(moduleDecl);
                        this.emitIndent();
                    }
                    this.writeToOutput("(");
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("function (");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(") {");
                }
                if (!isWholeFile) {
                    this.recordSourceMappingNameStart(this.moduleName);
                }
                if (!isDynamicMod || TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                    this.indenter.increaseIndent();
                }
                if (moduleDecl.modFlags & 4096 /* MustCaptureThis */ ) {
                    this.writeCaptureThisStatement(moduleDecl);
                }
                this.emitJavascriptList(moduleDecl.members, null, 55 /* Semicolon */ , true, false, false);
                if (!isDynamicMod || TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                    this.indenter.decreaseIndent();
                }
                this.emitIndent();
                if (isDynamicMod) {
                    if (TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                        this.writeLineToOutput("})");
                    } else {
                    }
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    if (this.outfile != prevOutFile) {
                        this.Close();
                        if (prevSourceMapper != null) {
                            this.allSourceMappers = prevAllSourceMappers;
                            this.sourceMapper = prevSourceMapper;
                            this.emitState.column = prevColumn;
                            this.emitState.line = prevLine;
                        }
                        this.outfile = prevOutFile;
                        this.emittingFileName = prevOutFileName;
                    }
                } else {
                    var containingMod = null;
                    if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {
                        containingMod = moduleDecl.type.symbol.container.declAST;
                    }
                    var parentIsDynamic = containingMod && TypeScript.hasFlag(containingMod.modFlags, 2048 /* IsDynamic */ );
                    this.recordSourceMappingStart(moduleDecl.endingToken);
                    if (temp == 0 /* Prog */  && isExported) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                    } else if (isExported || temp == 0 /* Prog */ ) {
                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                    } else if (!isExported && temp != 0 /* Prog */ ) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                    } else {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")();");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    this.writeLineToOutput("");
                    if (temp != 0 /* Prog */  && isExported) {
                        this.emitIndent();
                        this.recordSourceMappingStart(moduleDecl);
                        if (parentIsDynamic) {
                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                        } else {
                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                        }
                        this.recordSourceMappingEnd(moduleDecl);
                    }
                }
                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.moduleDeclList.length--;
            }
        };
        Emitter.prototype.emitIndex = function (operand1, operand2) {
            var temp = this.setInObjectLiteral(false);
            this.emitJavascript(operand1, 98 /* Tilde */ , false);
            this.writeToOutput("[");
            this.emitJavascriptList(operand2, ", ", 62 /* Comma */ , false, false, false);
            this.writeToOutput("]");
            this.setInObjectLiteral(temp);
        };
        Emitter.prototype.emitStringLiteral = function (text) {
            this.writeToOutput(text);
        };
        Emitter.prototype.emitJavascriptFunction = function (funcDecl) {
            if (TypeScript.hasFlag(funcDecl.fncFlags, 512 /* Signature */ ) || funcDecl.isOverload) {
                return;
            }
            var temp;
            var tempFnc = this.thisFnc;
            this.thisFnc = funcDecl;
            if (funcDecl.isConstructor) {
                temp = this.setContainer(4 /* Constructor */ );
            } else {
                temp = this.setContainer(5 /* Function */ );
            }
            var bases = null;
            var hasSelfRef = false;
            var funcName = funcDecl.getNameText();
            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) && ((temp != 4 /* Constructor */ ) || ((funcDecl.fncFlags & 1024 /* Method */ ) == 0 /* None */ ))) {
                var tempLit = this.setInObjectLiteral(false);
                if (this.thisClassNode) {
                    bases = this.thisClassNode.extendsList;
                }
                hasSelfRef = Emitter.shouldCaptureThis(funcDecl);
                this.recordSourceMappingStart(funcDecl);
                if (TypeScript.hasFlag(funcDecl.fncFlags, 1 /* Exported */  | 524288 /* ClassPropertyMethodExported */ ) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {
                    this.writeToOutput("this." + funcName + " = ");
                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);
                } else {
                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);
                }
                this.setInObjectLiteral(tempLit);
            }
            this.setContainer(temp);
            this.thisFnc = tempFnc;
            if (!TypeScript.hasFlag(funcDecl.fncFlags, 512 /* Signature */ )) {
                if (TypeScript.hasFlag(funcDecl.fncFlags, 16 /* Static */ )) {
                    if (this.thisClassNode) {
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        } else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName + " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                } else if ((this.emitState.container == 1 /* Module */  || this.emitState.container == 2 /* DynamicModule */ ) && TypeScript.hasFlag(funcDecl.fncFlags, 1 /* Exported */  | 524288 /* ClassPropertyMethodExported */ )) {
                    this.emitIndent();
                    var modName = this.emitState.container == 1 /* Module */  ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeLineToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        };
        Emitter.prototype.emitAmbientVarDecl = function (varDecl) {
            if (varDecl.init) {
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, 62 /* Comma */ , false);
                this.recordSourceMappingEnd(varDecl);
                this.writeToOutput(";");
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        };
        Emitter.prototype.varListCount = function () {
            return this.varListCountStack[this.varListCountStack.length - 1];
        };
        Emitter.prototype.emitVarDeclVar = function () {
            if (this.varListCount() >= 0) {
                this.writeToOutput("var ");
                this.setInVarBlock(-this.varListCount());
            }
            return true;
        };
        Emitter.prototype.onEmitVar = function () {
            if (this.varListCount() > 0) {
                this.setInVarBlock(this.varListCount() - 1);
            } else if (this.varListCount() < 0) {
                this.setInVarBlock(this.varListCount() + 1);
            }
        };
        Emitter.prototype.emitJavascriptVarDecl = function (varDecl, tokenId) {
            if ((varDecl.varFlags & 8 /* Ambient */ ) == 8 /* Ambient */ ) {
                this.emitAmbientVarDecl(varDecl);
                this.onEmitVar();
            } else {
                var sym = varDecl.sym;
                var hasInitializer = (varDecl.init != null);
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                if (sym && sym.isMember() && sym.container && (sym.container.kind() == 1 /* Type */ )) {
                    var type = (sym.container).type;
                    if (type.isClass() && (!TypeScript.hasFlag(sym.flags, 1024 /* ModuleMember */ ))) {
                        if (this.emitState.container != 6 /* Args */ ) {
                            if (TypeScript.hasFlag(sym.flags, 16 /* Static */ )) {
                                this.writeToOutput(sym.container.name + ".");
                            } else {
                                this.writeToOutput("this.");
                            }
                        }
                    } else if (type.hasImplementation()) {
                        if (!TypeScript.hasFlag(sym.flags, 1 /* Exported */ ) && (sym.container == this.checker.gloMod || !TypeScript.hasFlag(sym.flags, 256 /* Property */ ))) {
                            this.emitVarDeclVar();
                        } else if (TypeScript.hasFlag(varDecl.varFlags, 32 /* LocalStatic */ )) {
                            this.writeToOutput(".");
                        } else {
                            if (this.emitState.container == 2 /* DynamicModule */ ) {
                                this.writeToOutput("exports.");
                            } else {
                                this.writeToOutput(this.moduleName + ".");
                            }
                        }
                    } else {
                        if (tokenId != 56 /* OpenParen */ ) {
                            if (TypeScript.hasFlag(sym.flags, 1 /* Exported */ ) && sym.container == this.checker.gloMod) {
                                this.writeToOutput("this.");
                            } else {
                                this.emitVarDeclVar();
                            }
                        }
                    }
                } else {
                    if (tokenId != 56 /* OpenParen */ ) {
                        this.emitVarDeclVar();
                    }
                }
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                if (hasInitializer) {
                    this.writeToOutputTrimmable(" = ");
                    this.varListCountStack.push(0);
                    this.emitJavascript(varDecl.init, 62 /* Comma */ , false);
                    this.varListCountStack.pop();
                }
                this.onEmitVar();
                if ((tokenId != 56 /* OpenParen */ )) {
                    if (this.varListCount() < 0) {
                        this.writeToOutput(", ");
                    } else if (tokenId != 19 /* For */ ) {
                        this.writeToOutputTrimmable(";");
                    }
                }
                this.recordSourceMappingEnd(varDecl);
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        };
        Emitter.prototype.declEnclosed = function (moduleDecl) {
            if (moduleDecl == null) {
                return true;
            }
            for(var i = 0, len = this.moduleDeclList.length; i < len; i++) {
                if (this.moduleDeclList[i] == moduleDecl) {
                    return true;
                }
            }
            return false;
        };
        Emitter.prototype.emitJavascriptName = function (name, addThis) {
            var sym = name.sym;
            this.emitParensAndCommentsInPlace(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                if (addThis && (this.emitState.container != 6 /* Args */ ) && sym) {
                    if (sym.container && (sym.container.name != TypeScript.globalId)) {
                        if (TypeScript.hasFlag(sym.flags, 16 /* Static */ ) && (TypeScript.hasFlag(sym.flags, 256 /* Property */ ))) {
                            if (sym.declModule && TypeScript.hasFlag(sym.declModule.modFlags, 2048 /* IsDynamic */ )) {
                                this.writeToOutput("exports.");
                            } else {
                                this.writeToOutput(sym.container.name + ".");
                            }
                        } else if (sym.kind() == 2 /* Field */ ) {
                            var fieldSym = sym;
                            if (TypeScript.hasFlag(fieldSym.flags, 1024 /* ModuleMember */ )) {
                                if ((sym.container != this.checker.gloMod) && ((TypeScript.hasFlag(sym.flags, 256 /* Property */ )) || TypeScript.hasFlag(sym.flags, 1 /* Exported */ ))) {
                                    if (TypeScript.hasFlag(sym.declModule.modFlags, 2048 /* IsDynamic */ )) {
                                        this.writeToOutput("exports.");
                                    } else {
                                        var contName = this.inlineEngine.normalizeModuleName(this, sym.container);
                                        this.writeToOutput(contName + ".");
                                    }
                                }
                            } else {
                                if (sym.isInstanceProperty()) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            }
                        } else if (sym.kind() == 1 /* Type */ ) {
                            if (sym.isInstanceProperty()) {
                                var typeSym = sym;
                                var type = typeSym.type;
                                if (type.call && !TypeScript.hasFlag(sym.flags, 1024 /* ModuleMember */ )) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            } else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {
                                this.writeToOutput(sym.container.name + ".");
                            }
                        }
                    } else if (sym.container == this.checker.gloMod && TypeScript.hasFlag(sym.flags, 1 /* Exported */ ) && !TypeScript.hasFlag(sym.flags, 8 /* Ambient */ ) && !((sym.isType() || sym.isMember()) && sym.declModule && TypeScript.hasFlag(sym.declModule.modFlags, 8 /* Ambient */ )) && this.emitState.container == 0 /* Prog */  && sym.declAST.nodeType != 73 /* FuncDecl */ ) {
                        this.writeToOutput("this.");
                    }
                }
                if (sym && sym.declAST && sym.declAST.nodeType == 98 /* ModuleDeclaration */  && (TypeScript.hasFlag((sym.declAST).modFlags, 2048 /* IsDynamic */ ))) {
                    var moduleDecl = sym.declAST;
                    if (TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                        this.writeLineToOutput("__" + this.modAliasId + "__;");
                    } else {
                        var modPath = name.actualText;
                        var isSingleQuotedMod = TypeScript.isSingleQuoted(modPath);
                        var isAmbient = moduleDecl.mod.symbol.declAST && TypeScript.hasFlag((moduleDecl.mod.symbol.declAST).modFlags, 8 /* Ambient */ );
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : TypeScript.quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!TypeScript.isRelative(TypeScript.stripQuotes(modPath)) ? TypeScript.quoteStr("./" + TypeScript.stripQuotes(modPath)) : modPath);
                        if (isSingleQuotedMod) {
                            modPath = TypeScript.changeToSingleQuote(modPath);
                        }
                        this.writeToOutput("require(" + modPath + ")");
                    }
                } else {
                    this.writeToOutput(name.actualText);
                }
            }
            this.recordSourceMappingEnd(name);
            this.emitParensAndCommentsInPlace(name, false);
        };
        Emitter.prototype.emitJavascriptStatements = function (stmts, emitEmptyBod) {
            if (stmts) {
                if (stmts.nodeType != 86 /* Block */ ) {
                    var hasContents = (stmts && (stmts.nodeType != 94 /* List */  || ((stmts).members.length > 0)));
                    if (emitEmptyBod || hasContents) {
                        var hasOnlyBlockStatement = ((stmts.nodeType == 86 /* Block */ ) || ((stmts.nodeType == 94 /* List */ ) && ((stmts).members.length == 1) && ((stmts).members[0].nodeType == 86 /* Block */ )));
                        this.recordSourceMappingStart(stmts);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput(" {");
                            this.indenter.increaseIndent();
                        }
                        this.emitJavascriptList(stmts, null, 55 /* Semicolon */ , true, false, false);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput("");
                            this.indenter.decreaseIndent();
                            this.emitIndent();
                            this.writeToOutput("}");
                        }
                        this.recordSourceMappingEnd(stmts);
                    }
                } else {
                    this.emitJavascript(stmts, 55 /* Semicolon */ , true);
                }
            } else if (emitEmptyBod) {
                this.writeToOutput("{ }");
            }
        };
        Emitter.prototype.emitBareJavascriptStatements = function (stmts, emitClassPropertiesAfterSuperCall) {
            if (typeof emitClassPropertiesAfterSuperCall === "undefined") { emitClassPropertiesAfterSuperCall = false; }
            if (stmts.nodeType != 86 /* Block */ ) {
                if (stmts.nodeType == 94 /* List */ ) {
                    var stmtList = stmts;
                    if ((stmtList.members.length == 2) && (stmtList.members[0].nodeType == 86 /* Block */ ) && (stmtList.members[1].nodeType == 105 /* EndCode */ )) {
                        this.emitJavascript(stmtList.members[0], 55 /* Semicolon */ , true);
                        this.writeLineToOutput("");
                    } else {
                        this.emitJavascriptList(stmts, null, 55 /* Semicolon */ , true, false, emitClassPropertiesAfterSuperCall);
                    }
                } else {
                    this.emitJavascript(stmts, 55 /* Semicolon */ , true);
                }
            } else {
                this.emitJavascript(stmts, 55 /* Semicolon */ , true);
            }
        };
        Emitter.prototype.recordSourceMappingNameStart = function (name) {
            if (this.sourceMapper) {
                var finalName = name;
                if (!name) {
                    finalName = "";
                } else if (this.sourceMapper.currentNameIndex.length > 0) {
                    finalName = this.sourceMapper.names[this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]] + "." + name;
                }
                this.sourceMapper.names.push(finalName);
                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);
            }
        };
        Emitter.prototype.recordSourceMappingNameEnd = function () {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        };
        Emitter.prototype.recordSourceMappingStart = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                var lineCol = {
                    line: -1,
                    col: -1
                };
                var sourceMapping = new TypeScript.SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;
                TypeScript.getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);
                sourceMapping.start.sourceColumn = lineCol.col;
                sourceMapping.start.sourceLine = lineCol.line;
                TypeScript.getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);
                sourceMapping.end.sourceColumn = lineCol.col;
                sourceMapping.end.sourceLine = lineCol.line;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        };
        Emitter.prototype.recordSourceMappingEnd = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                this.sourceMapper.currentMappings.pop();
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];
                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        };
        Emitter.prototype.Close = function () {
            if (this.sourceMapper != null) {
                TypeScript.SourceMapper.EmitSourceMapping(this.allSourceMappers);
            }
            try  {
                this.outfile.Close();
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        };
        Emitter.prototype.emitJavascriptList = function (ast, delimiter, tokenId, startLine, onlyStatics, emitClassPropertiesAfterSuperCall, emitPrologue, requiresExtendsBlock) {
            if (typeof emitClassPropertiesAfterSuperCall === "undefined") { emitClassPropertiesAfterSuperCall = false; }
            if (typeof emitPrologue === "undefined") { emitPrologue = false; }
            if (ast == null) {
                return;
            } else if (ast.nodeType != 94 /* List */ ) {
                this.emitPrologue(emitPrologue);
                this.emitJavascript(ast, tokenId, startLine);
            } else {
                var list = ast;
                this.emitParensAndCommentsInPlace(ast, true);
                if (list.members.length == 0) {
                    this.emitParensAndCommentsInPlace(ast, false);
                    return;
                }
                var len = list.members.length;
                for(var i = 0; i < len; i++) {
                    if (emitPrologue) {
                        if (i == 1 || !TypeScript.hasFlag(list.flags, 128 /* StrictMode */ )) {
                            this.emitPrologue(requiresExtendsBlock);
                            emitPrologue = false;
                        }
                    }
                    if (i == 1 && emitClassPropertiesAfterSuperCall) {
                        var constructorDecl = (this.thisClassNode).constructorDecl;
                        if (constructorDecl && constructorDecl.arguments) {
                            var argsLen = constructorDecl.arguments.members.length;
                            for(var iArg = 0; iArg < argsLen; iArg++) {
                                var arg = constructorDecl.arguments.members[iArg];
                                if ((arg.varFlags & 512 /* Property */ ) != 0 /* None */ ) {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(arg);
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput("this." + arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeToOutput(" = ");
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput(arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeLineToOutput(";");
                                    this.recordSourceMappingEnd(arg);
                                }
                            }
                        }
                        var nProps = (this.thisClassNode.members).members.length;
                        for(var iMember = 0; iMember < nProps; iMember++) {
                            if ((this.thisClassNode.members).members[iMember].nodeType == 75 /* VarDecl */ ) {
                                var varDecl = (this.thisClassNode.members).members[iMember];
                                if (!TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ ) && varDecl.init) {
                                    this.emitIndent();
                                    this.emitJavascriptVarDecl(varDecl, 98 /* Tilde */ );
                                    this.writeLineToOutput("");
                                }
                            }
                        }
                    }
                    var emitNode = list.members[i];
                    var isStaticDecl = (emitNode.nodeType == 73 /* FuncDecl */  && TypeScript.hasFlag((emitNode).fncFlags, 16 /* Static */ )) || (emitNode.nodeType == 75 /* VarDecl */  && TypeScript.hasFlag((emitNode).varFlags, 16 /* Static */ ));
                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {
                        continue;
                    }
                    this.emitJavascript(emitNode, tokenId, startLine);
                    if (delimiter && (i < (len - 1))) {
                        if (startLine) {
                            this.writeLineToOutput(delimiter);
                        } else {
                            this.writeToOutput(delimiter);
                        }
                    } else if (startLine && (emitNode.nodeType != 98 /* ModuleDeclaration */ ) && (emitNode.nodeType != 97 /* InterfaceDeclaration */ ) && (!((emitNode.nodeType == 75 /* VarDecl */ ) && ((((emitNode).varFlags) & 8 /* Ambient */ ) == 8 /* Ambient */ ) && (((emitNode).init) == null)) && this.varListCount() >= 0) && (emitNode.nodeType != 86 /* Block */  || (emitNode).isStatementBlock) && (emitNode.nodeType != 105 /* EndCode */ ) && (emitNode.nodeType != 73 /* FuncDecl */ )) {
                        this.writeLineToOutput("");
                    }
                }
                this.emitParensAndCommentsInPlace(ast, false);
            }
        };
        Emitter.prototype.emitJavascript = function (ast, tokenId, startLine) {
            if (ast == null) {
                return;
            }
            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != 94 /* List */ ) && (ast.nodeType != 86 /* Block */ )) {
                if ((ast.nodeType != 97 /* InterfaceDeclaration */ ) && (!((ast.nodeType == 75 /* VarDecl */ ) && ((((ast).varFlags) & 8 /* Ambient */ ) == 8 /* Ambient */ ) && (((ast).init) == null)) && this.varListCount() >= 0) && (ast.nodeType != 105 /* EndCode */ ) && ((ast.nodeType != 73 /* FuncDecl */ ) || (this.emitState.container != 4 /* Constructor */ ))) {
                    this.emitIndent();
                }
            }
            ast.emit(this, tokenId, startLine);
            if ((tokenId == 55 /* Semicolon */ ) && (ast.nodeType < 73 /* GeneralNode */ )) {
                this.writeToOutput(";");
            }
        };
        Emitter.prototype.emitPropertyAccessor = function (funcDecl, className, isProto) {
            if (!(funcDecl.accessorSymbol).hasBeenEmitted) {
                var accessorSymbol = funcDecl.accessorSymbol;
                this.emitIndent();
                this.recordSourceMappingStart(funcDecl);
                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \"" : ", \"") + funcDecl.name.actualText + "\"" + ", {");
                this.indenter.increaseIndent();
                if (accessorSymbol.getter) {
                    var getter = accessorSymbol.getter.declAST;
                    this.emitIndent();
                    this.recordSourceMappingStart(getter);
                    this.writeToOutput("get: ");
                    this.emitInnerFunction(getter, false, isProto, null, Emitter.shouldCaptureThis(getter), null);
                    this.writeLineToOutput(",");
                }
                if (accessorSymbol.setter) {
                    var setter = accessorSymbol.setter.declAST;
                    this.emitIndent();
                    this.recordSourceMappingStart(setter);
                    this.writeToOutput("set: ");
                    this.emitInnerFunction(setter, false, isProto, null, Emitter.shouldCaptureThis(setter), null);
                    this.writeLineToOutput(",");
                }
                this.emitIndent();
                this.writeLineToOutput("enumerable: true,");
                this.emitIndent();
                this.writeLineToOutput("configurable: true");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("});");
                this.recordSourceMappingEnd(funcDecl);
                accessorSymbol.hasBeenEmitted = true;
            }
        };
        Emitter.prototype.emitPrototypeMember = function (member, className) {
            if (member.nodeType == 73 /* FuncDecl */ ) {
                var funcDecl = member;
                if (funcDecl.isAccessor()) {
                    this.emitPropertyAccessor(funcDecl, className, true);
                } else {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");
                    this.emitInnerFunction(funcDecl, false, true, null, Emitter.shouldCaptureThis(funcDecl), null);
                    this.writeLineToOutput(";");
                }
            } else if (member.nodeType == 75 /* VarDecl */ ) {
                var varDecl = member;
                if (varDecl.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(varDecl);
                    this.recordSourceMappingStart(varDecl.id);
                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);
                    this.recordSourceMappingEnd(varDecl.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(varDecl.init, 63 /* Equals */ , false);
                    this.recordSourceMappingEnd(varDecl);
                    this.writeLineToOutput(";");
                }
            }
        };
        Emitter.prototype.emitAddBaseMethods = function (className, base, classDecl) {
            if (base.members) {
                var baseSymbol = base.symbol;
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                base.members.allMembers.map(function (key, s, c) {
                    var sym = s;
                    if ((sym.kind() == 1 /* Type */ ) && (sym).type.call) {
                        this.recordSourceMappingStart(sym.declAST);
                        this.writeLineToOutput(className + ".prototype." + sym.name + " = " + baseName + ".prototype." + sym.name + ";");
                        this.recordSourceMappingEnd(sym.declAST);
                    }
                }, null);
            }
            if (base.extendsList) {
                for(var i = 0, len = base.extendsList.length; i < len; i++) {
                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);
                }
            }
        };
        Emitter.prototype.emitJavascriptClass = function (classDecl) {
            if (!TypeScript.hasFlag(classDecl.varFlags, 8 /* Ambient */ )) {
                var svClassNode = this.thisClassNode;
                var i = 0;
                this.thisClassNode = classDecl;
                var className = classDecl.name.actualText;
                this.emitParensAndCommentsInPlace(classDecl, true);
                var temp = this.setContainer(3 /* Class */ );
                this.recordSourceMappingStart(classDecl);
                if (TypeScript.hasFlag(classDecl.varFlags, 1 /* Exported */ ) && classDecl.type.symbol.container == this.checker.gloMod) {
                    this.writeToOutput("this." + className);
                } else {
                    this.writeToOutput("var " + className);
                }
                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
                var baseNameDecl = null;
                var baseName = null;
                if (hasBaseClass) {
                    this.writeLineToOutput(" = (function (_super) {");
                } else {
                    this.writeLineToOutput(" = (function () {");
                }
                this.recordSourceMappingNameStart(className);
                this.indenter.increaseIndent();
                if (hasBaseClass) {
                    baseNameDecl = classDecl.extendsList.members[0];
                    baseName = baseNameDecl.nodeType == 30 /* Call */  ? (baseNameDecl).target : baseNameDecl;
                    this.emitIndent();
                    this.writeLineToOutput("__extends(" + className + ", _super);");
                }
                this.emitIndent();
                var constrDecl = classDecl.constructorDecl;
                if (constrDecl) {
                    this.emitJavascript(classDecl.constructorDecl, 56 /* OpenParen */ , false);
                } else {
                    var wroteProps = 0;
                    this.recordSourceMappingStart(classDecl);
                    this.indenter.increaseIndent();
                    this.writeToOutput("function " + classDecl.name.actualText + "() {");
                    this.recordSourceMappingNameStart("constructor");
                    if (hasBaseClass) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeLineToOutput("_super.apply(this, arguments);");
                        wroteProps++;
                    }
                    if (classDecl.varFlags & 131072 /* MustCaptureThis */ ) {
                        this.writeCaptureThisStatement(classDecl);
                    }
                    var members = (this.thisClassNode.members).members;
                    for(var i = 0; i < members.length; i++) {
                        if (members[i].nodeType == 75 /* VarDecl */ ) {
                            var varDecl = members[i];
                            if (!TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ ) && varDecl.init) {
                                this.writeLineToOutput("");
                                this.emitIndent();
                                this.emitJavascriptVarDecl(varDecl, 98 /* Tilde */ );
                                wroteProps++;
                            }
                        }
                    }
                    if (wroteProps) {
                        this.writeLineToOutput("");
                        this.indenter.decreaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("}");
                    } else {
                        this.writeLineToOutput(" }");
                        this.indenter.decreaseIndent();
                    }
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(classDecl);
                }
                var membersLen = classDecl.members.members.length;
                for(var j = 0; j < membersLen; j++) {
                    var memberDecl = classDecl.members.members[j];
                    if (memberDecl.nodeType == 73 /* FuncDecl */ ) {
                        var fn = memberDecl;
                        if (TypeScript.hasFlag(fn.fncFlags, 1024 /* Method */ ) && !fn.isSignature()) {
                            if (!TypeScript.hasFlag(fn.fncFlags, 16 /* Static */ )) {
                                this.emitPrototypeMember(fn, className);
                            } else {
                                if (fn.isAccessor()) {
                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);
                                } else {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(fn);
                                    this.writeToOutput(classDecl.name.actualText + "." + fn.name.actualText + " = ");
                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true, null, Emitter.shouldCaptureThis(fn), null);
                                    this.writeLineToOutput(";");
                                }
                            }
                        }
                    } else if (memberDecl.nodeType == 75 /* VarDecl */ ) {
                        var varDecl = memberDecl;
                        if (TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ )) {
                            if (varDecl.init) {
                                this.emitIndent();
                                this.recordSourceMappingStart(varDecl);
                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");
                                this.emitJavascript(varDecl.init, 63 /* Equals */ , false);
                                this.writeLineToOutput(";");
                                this.recordSourceMappingEnd(varDecl);
                            }
                        }
                    } else {
                        throw Error("We want to catch this");
                    }
                }
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeLineToOutput("return " + className + ";");
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput(")(");
                if (hasBaseClass) {
                    this.emitJavascript(baseName, 98 /* Tilde */ , false);
                }
                this.writeToOutput(");");
                this.recordSourceMappingEnd(classDecl);
                if ((temp == 1 /* Module */  || temp == 2 /* DynamicModule */ ) && TypeScript.hasFlag(classDecl.varFlags, 1 /* Exported */ )) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = temp == 1 /* Module */  ? this.moduleName : "exports";
                    this.recordSourceMappingStart(classDecl);
                    this.writeToOutput(modName + "." + className + " = " + className + ";");
                    this.recordSourceMappingEnd(classDecl);
                }
                this.emitIndent();
                this.recordSourceMappingEnd(classDecl);
                this.emitParensAndCommentsInPlace(classDecl, false);
                this.setContainer(temp);
                this.thisClassNode = svClassNode;
            }
        };
        Emitter.prototype.emitPrologue = function (reqInherits) {
            if (!this.extendsPrologueEmitted) {
                if (reqInherits) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }
            if (!this.globalThisCapturePrologueEmitted) {
                if (this.checker.mustCaptureGlobalThis) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        };
        Emitter.prototype.emitSuperReference = function () {
            this.writeToOutput("_super.prototype");
        };
        Emitter.prototype.emitSuperCall = function (callEx) {
            if (callEx.target.nodeType == 19 /* Dot */ ) {
                var dotNode = callEx.target;
                if (dotNode.operand1.nodeType == 6 /* Super */ ) {
                    this.emitJavascript(dotNode, 56 /* OpenParen */ , false);
                    this.writeToOutput(".call(");
                    this.emitThis();
                    if (callEx.arguments && callEx.arguments.members.length > 0) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(callEx.arguments, ", ", 62 /* Comma */ , false, false, false);
                    }
                    this.writeToOutput(")");
                    return true;
                }
            }
            return false;
        };
        Emitter.prototype.emitThis = function () {
            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {
                this.writeToOutput("_this");
            } else {
                this.writeToOutput("this");
            }
        };
        Emitter.shouldCaptureThis = function shouldCaptureThis(func) {
            return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();
        };
        Emitter.prototype.createFile = function (fileName, useUTF8) {
            try  {
                return this.emitOptions.ioHost.createFile(fileName, useUTF8);
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        };
        return Emitter;
    })();
    TypeScript.Emitter = Emitter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ErrorReporter = (function () {
        function ErrorReporter(outfile) {
            this.outfile = outfile;
            this.parser = null;
            this.checker = null;
            this.lineCol = {
                line: 0,
                col: 0
            };
            this.emitAsComments = true;
            this.hasErrors = false;
            this.pushToErrorSink = false;
            this.errorSink = [];
        }
        ErrorReporter.prototype.getCapturedErrors = function () {
            return this.errorSink;
        };
        ErrorReporter.prototype.freeCapturedErrors = function () {
            this.errorSink = [];
        };
        ErrorReporter.prototype.captureError = function (emsg) {
            this.errorSink[this.errorSink.length] = emsg;
        };
        ErrorReporter.prototype.setErrOut = function (outerr) {
            this.outfile = outerr;
            this.emitAsComments = false;
        };
        ErrorReporter.prototype.emitPrefix = function () {
            if (this.emitAsComments) {
                this.outfile.Write("// ");
            }
            this.outfile.Write(this.checker.locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): ");
        };
        ErrorReporter.prototype.writePrefix = function (ast) {
            if (ast) {
                this.setError(ast);
            } else {
                this.lineCol.line = 0;
                this.lineCol.col = 0;
            }
            this.emitPrefix();
        };
        ErrorReporter.prototype.writePrefixFromSym = function (symbol) {
            if (symbol && this.checker.locationInfo.lineMap) {
                TypeScript.getSourceLineColFromMap(this.lineCol, symbol.location, this.checker.locationInfo.lineMap);
            } else {
                this.lineCol.line = -1;
                this.lineCol.col = -1;
            }
            this.emitPrefix();
        };
        ErrorReporter.prototype.setError = function (ast) {
            if (ast) {
                ast.flags |= 8 /* Error */ ;
                if (this.checker.locationInfo.lineMap) {
                    TypeScript.getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap);
                }
            }
        };
        ErrorReporter.prototype.reportError = function (ast, message) {
            if (this.pushToErrorSink) {
                this.captureError(message);
                return;
            }
            this.hasErrors = true;
            if (ast && this.parser.errorRecovery && this.parser.errorCallback) {
                var len = (ast.limChar - ast.minChar);
                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex);
            } else {
                this.writePrefix(ast);
                this.outfile.WriteLine(message);
            }
        };
        ErrorReporter.prototype.reportErrorFromSym = function (symbol, message) {
            if (this.pushToErrorSink) {
                this.captureError(message);
                return;
            }
            this.hasErrors = true;
            if (this.parser.errorRecovery && this.parser.errorCallback) {
                this.parser.errorCallback(symbol.location, symbol.length, message, this.checker.locationInfo.unitIndex);
            } else {
                this.writePrefixFromSym(symbol);
                this.outfile.WriteLine(message);
            }
        };
        ErrorReporter.prototype.emitterError = function (ast, message) {
            this.reportError(ast, message);
            throw Error("EmitError");
        };
        ErrorReporter.prototype.duplicateIdentifier = function (ast, name) {
            this.reportError(ast, "Duplicate identifier '" + name + "'");
        };
        ErrorReporter.prototype.showRef = function (ast, text, symbol) {
            var defLineCol = {
                line: -1,
                col: -1
            };
            this.parser.getSourceLineCol(defLineCol, symbol.location);
            this.reportError(ast, "symbol " + text + " defined at (" + defLineCol.line + "," + defLineCol.col + ")");
        };
        ErrorReporter.prototype.unresolvedSymbol = function (ast, name) {
            this.reportError(ast, "The name '" + name + "' does not exist in the current scope");
        };
        ErrorReporter.prototype.symbolDoesNotReferToAValue = function (ast, name) {
            this.reportError(ast, "The name '" + name + "' does not refer to a value");
        };
        ErrorReporter.prototype.styleError = function (ast, msg) {
            var bkThrow = this.pushToErrorSink;
            this.pushToErrorSink = false;
            this.reportError(ast, "STYLE: " + msg);
            this.pushToErrorSink = bkThrow;
        };
        ErrorReporter.prototype.simpleError = function (ast, msg) {
            this.reportError(ast, msg);
        };
        ErrorReporter.prototype.simpleErrorFromSym = function (sym, msg) {
            this.reportErrorFromSym(sym, msg);
        };
        ErrorReporter.prototype.invalidSuperReference = function (ast) {
            this.simpleError(ast, "Keyword 'super' can only be used inside a class instance method");
        };
        ErrorReporter.prototype.valueCannotBeModified = function (ast) {
            this.simpleError(ast, "The left-hand side of an assignment expression must be a variable, property or indexer");
        };
        ErrorReporter.prototype.invalidCall = function (ast, nodeType, scope) {
            var targetType = ast.target.type;
            var typeName = targetType.getScopedTypeName(scope);
            if (targetType.construct && (nodeType == 30 /* Call */ )) {
                this.reportError(ast, "Value of type '" + typeName + "' is not callable.  Did you mean to include 'new'?");
            } else {
                var catString = (nodeType == 30 /* Call */ ) ? "callable" : "newable";
                this.reportError(ast, "Value of type '" + typeName + "' is not " + catString);
            }
        };
        ErrorReporter.prototype.indexLHS = function (ast, scope) {
            var targetType = ast.operand1.type.getScopedTypeName(scope);
            var indexType = ast.operand2.type.getScopedTypeName(scope);
            this.simpleError(ast, "Value of type '" + targetType + "' is not indexable by type '" + indexType + "'");
        };
        ErrorReporter.prototype.incompatibleTypes = function (ast, t1, t2, op, scope, comparisonInfo) {
            if (!t1) {
                t1 = this.checker.anyType;
            }
            if (!t2) {
                t2 = this.checker.anyType;
            }
            var reason = comparisonInfo ? comparisonInfo.message : "";
            if (op) {
                this.reportError(ast, "Operator '" + op + "' cannot be applied to types '" + t1.getScopedTypeName(scope) + "' and '" + t2.getScopedTypeName(scope) + "'" + (reason ? ": " + reason : ""));
            } else {
                this.reportError(ast, "Cannot convert '" + t1.getScopedTypeName(scope) + "' to '" + t2.getScopedTypeName(scope) + "'" + (reason ? ": " + reason : ""));
            }
        };
        ErrorReporter.prototype.expectedClassOrInterface = function (ast) {
            this.simpleError(ast, "Expected var, class, interface, or module");
        };
        ErrorReporter.prototype.unaryOperatorTypeError = function (ast, op, type) {
            this.reportError(ast, "Operator '" + op + "' cannot be applied to type '" + type.getTypeName() + "'");
        };
        return ErrorReporter;
    })();
    TypeScript.ErrorReporter = ErrorReporter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TypeContext) {
        TypeContext._map = [];
        TypeContext.NoTypes = 0;
        TypeContext.ArraySuffix = 1;
        TypeContext.Primitive = 2;
        TypeContext.Named = 4;
        TypeContext.AllSimpleTypes = TypeContext.Primitive | TypeContext.Named;
        TypeContext.AllTypes = TypeContext.Primitive | TypeContext.Named | TypeContext.ArraySuffix;
    })(TypeScript.TypeContext || (TypeScript.TypeContext = {}));
    var TypeContext = TypeScript.TypeContext;
    var QuickParseResult = (function () {
        function QuickParseResult(Script, endLexState) {
            this.Script = Script;
            this.endLexState = endLexState;
        }
        return QuickParseResult;
    })();
    TypeScript.QuickParseResult = QuickParseResult;    
    var Parser = (function () {
        function Parser() {
            this.varLists = [];
            this.scopeLists = [];
            this.staticsLists = [];
            this.scanner = new TypeScript.Scanner();
            this.currentToken = null;
            this.needTerminator = false;
            this.inFunction = false;
            this.inInterfaceDecl = false;
            this.currentClassDecl = null;
            this.inFncDecl = false;
            this.anonId = new TypeScript.Identifier("_anonymous");
            this.style_requireSemi = false;
            this.style_funcInLoop = true;
            this.incremental = false;
            this.errorRecovery = false;
            this.outfile = undefined;
            this.errorCallback = null;
            this.ambientModule = false;
            this.ambientClass = false;
            this.topLevel = true;
            this.allowImportDeclaration = true;
            this.currentUnitIndex = (-1);
            this.prevIDTok = null;
            this.statementInfoStack = new Array();
            this.hasTopLevelImportOrExport = false;
            this.strictMode = false;
            this.nestingLevel = 0;
            this.prevExpr = null;
            this.currentClassDefinition = null;
            this.parsingClassConstructorDefinition = false;
            this.parsingDeclareFile = false;
            this.amdDependencies = [];
            this.inferPropertiesFromThisAssignment = false;
            this.requiresExtendsBlock = false;
            this.fname = "";
        }
        Parser.prototype.resetStmtStack = function () {
            this.statementInfoStack = new Array();
        };
        Parser.prototype.inLoop = function () {
            for(var j = this.statementInfoStack.length - 1; j >= 0; j--) {
                if (this.statementInfoStack[j].stmt.isLoop()) {
                    return true;
                }
            }
            return false;
        };
        Parser.prototype.pushStmt = function (stmt, labels) {
            var info = {
                stmt: stmt,
                labels: labels
            };
            this.statementInfoStack.push(info);
        };
        Parser.prototype.popStmt = function () {
            return this.statementInfoStack.pop();
        };
        Parser.prototype.resolveJumpTarget = function (jump) {
            var resolvedTarget = TypeScript.AST.getResolvedIdentifierName(jump.target);
            var len = this.statementInfoStack.length;
            for(var i = len - 1; i >= 0; i--) {
                var info = this.statementInfoStack[i];
                if (jump.target) {
                    if (info.labels && (info.labels.members.length > 0)) {
                        for(var j = 0, labLen = info.labels.members.length; j < labLen; j++) {
                            var label = info.labels.members[j];
                            if (label.id.text == resolvedTarget) {
                                jump.setResolvedTarget(this, info.stmt);
                                return;
                            }
                        }
                    }
                } else {
                    if (info.stmt.isLoop()) {
                        jump.setResolvedTarget(this, info.stmt);
                        return;
                    } else if ((info.stmt.nodeType == 88 /* Switch */ ) && (jump.nodeType == 78 /* Break */ )) {
                        jump.setResolvedTarget(this, info.stmt);
                        return;
                    }
                }
            }
            if (jump.target) {
                this.reportParseError("could not find enclosing statement with label " + jump.target);
            } else {
                if (jump.nodeType == 78 /* Break */ ) {
                    this.reportParseError("break statement requires enclosing loop or switch");
                } else {
                    this.reportParseError("continue statement requires enclosing loop");
                }
            }
        };
        Parser.prototype.setErrorRecovery = function (outfile) {
            this.outfile = outfile;
            this.errorRecovery = true;
        };
        Parser.prototype.getSourceLineCol = function (lineCol, minChar) {
            TypeScript.getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap);
        };
        Parser.prototype.createRef = function (text, hasEscapeSequence, minChar) {
            var id = new TypeScript.Identifier(text, hasEscapeSequence);
            id.minChar = minChar;
            return id;
        };
        Parser.prototype.reportParseStyleError = function (message) {
            this.reportParseError("STYLE: " + message);
        };
        Parser.prototype.reportParseError = function (message, startPos, pos) {
            if (typeof startPos === "undefined") { startPos = this.scanner.startPos; }
            if (typeof pos === "undefined") { pos = this.scanner.pos; }
            var len = Math.max(1, pos - startPos);
            if (this.errorCallback) {
                this.errorCallback(startPos, len, message, this.currentUnitIndex);
            } else if (this.errorRecovery) {
                var lineCol = {
                    line: -1,
                    col: -1
                };
                this.getSourceLineCol(lineCol, startPos);
                if (this.outfile) {
                    this.outfile.WriteLine("// " + this.fname + " (" + lineCol.line + "," + lineCol.col + "): " + message);
                }
            } else {
                throw new SyntaxError(this.fname + " (" + this.scanner.line + "," + this.scanner.col + "): " + message);
            }
        };
        Parser.prototype.checkNextToken = function (tokenId, errorRecoverySet, errorText) {
            if (typeof errorText === "undefined") { errorText = null; }
            this.currentToken = this.scanner.scan();
            this.checkCurrentToken(tokenId, errorRecoverySet, errorText);
        };
        Parser.prototype.skip = function (errorRecoverySet) {
            errorRecoverySet |= 536870912 /* EOF */ ;
            var ersTok = 0 /* None */ ;
            var tokenInfo = TypeScript.lookupToken(this.currentToken.tokenId);
            if (tokenInfo != undefined) {
                ersTok = tokenInfo.ers;
            }
            var pendingRightCurlies = 0;
            while(((ersTok & errorRecoverySet) == 0 /* None */ ) || (this.currentToken.tokenId == 61 /* CloseBrace */ ) && (pendingRightCurlies > 0)) {
                if (this.currentToken.tokenId == 60 /* OpenBrace */ ) {
                    pendingRightCurlies++;
                } else if (this.currentToken.tokenId == 61 /* CloseBrace */ ) {
                    pendingRightCurlies--;
                }
                this.currentToken = this.scanner.scan();
                ersTok = 0 /* None */ ;
                tokenInfo = TypeScript.lookupToken(this.currentToken.tokenId);
                if (tokenInfo != undefined) {
                    ersTok = tokenInfo.ers;
                }
            }
        };
        Parser.prototype.checkCurrentToken = function (tokenId, errorRecoverySet, errorText) {
            if (typeof errorText === "undefined") { errorText = null; }
            if (this.currentToken.tokenId != tokenId) {
                errorText = errorText == null ? ("Expected '" + TypeScript.tokenTable[tokenId].text + "'") : errorText;
                this.reportParseError(errorText);
                if (this.errorRecovery) {
                    this.skip(errorRecoverySet);
                }
            } else {
                this.currentToken = this.scanner.scan();
            }
        };
        Parser.prototype.pushDeclLists = function () {
            this.staticsLists.push(new TypeScript.ASTList());
            this.varLists.push(new TypeScript.ASTList());
            this.scopeLists.push(new TypeScript.ASTList());
        };
        Parser.prototype.popDeclLists = function () {
            this.staticsLists.pop();
            this.varLists.pop();
            this.scopeLists.pop();
        };
        Parser.prototype.topVarList = function () {
            return this.varLists[this.varLists.length - 1];
        };
        Parser.prototype.topScopeList = function () {
            return this.scopeLists[this.scopeLists.length - 1];
        };
        Parser.prototype.topStaticsList = function () {
            return this.staticsLists[this.staticsLists.length - 1];
        };
        Parser.prototype.parseComment = function (comment) {
            if (comment) {
                var c = new TypeScript.Comment(comment.value, comment.isBlock, comment.endsLine);
                c.minChar = comment.startPos;
                c.limChar = comment.startPos + comment.value.length;
                var lineCol = {
                    line: -1,
                    col: -1
                };
                this.getSourceLineCol(lineCol, c.minChar);
                c.minLine = lineCol.line;
                this.getSourceLineCol(lineCol, c.limChar);
                c.limLine = lineCol.line;
                if (!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == "///") {
                    var dependencyPath = TypeScript.getAdditionalDependencyPath(comment.value);
                    if (dependencyPath) {
                        this.amdDependencies.push(dependencyPath);
                    }
                    if (TypeScript.getImplicitImport(comment.value)) {
                        this.hasTopLevelImportOrExport = true;
                    }
                }
                return c;
            } else {
                return null;
            }
        };
        Parser.prototype.parseCommentsInner = function (comments) {
            if (comments) {
                var commentASTs = new Array();
                for(var i = 0; i < comments.length; i++) {
                    commentASTs.push(this.parseComment(comments[i]));
                }
                return commentASTs;
            } else {
                return null;
            }
        };
        Parser.prototype.parseComments = function () {
            var comments = this.scanner.getComments();
            return this.parseCommentsInner(comments);
        };
        Parser.prototype.parseCommentsForLine = function (line) {
            var comments = this.scanner.getCommentsForLine(line);
            return this.parseCommentsInner(comments);
        };
        Parser.prototype.combineComments = function (comment1, comment2) {
            if (comment1 == null) {
                return comment2;
            } else if (comment2 == null) {
                return comment1;
            } else {
                return comment1.concat(comment2);
            }
        };
        Parser.prototype.parseEnumDecl = function (errorRecoverySet, modifiers) {
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;
            var name = null;
            if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                name = TypeScript.Identifier.fromToken(this.currentToken);
                name.minChar = this.scanner.startPos;
                name.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
            } else {
                this.reportParseError("Enum declaration requires identifier");
                if (this.errorRecovery) {
                    name = new TypeScript.MissingIdentifier();
                    name.minChar = this.scanner.startPos;
                    name.limChar = this.scanner.startPos;
                    name.flags |= 8 /* Error */ ;
                }
            }
            var membersMinChar = this.scanner.startPos;
            this.checkCurrentToken(60 /* OpenBrace */ , errorRecoverySet | 16777216 /* ID */ );
            this.pushDeclLists();
            var members = new TypeScript.ASTList();
            members.minChar = membersMinChar;
            var mapDecl = new TypeScript.VarDecl(new TypeScript.Identifier("_map"), 0);
            mapDecl.varFlags |= 1 /* Exported */ ;
            mapDecl.varFlags |= 2 /* Private */ ;
            mapDecl.varFlags |= (512 /* Property */  | 4 /* Public */ );
            mapDecl.init = new TypeScript.UnaryExpression(10 /* ArrayLit */ , null);
            members.append(mapDecl);
            var lastValue = null;
            var memberNames = [];
            for(; ; ) {
                var minChar = this.scanner.startPos;
                var limChar;
                var memberName = null;
                var memberValue = null;
                var preComments = null;
                var postComments = null;
                if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToIDName(this.currentToken)) {
                    memberName = TypeScript.Identifier.fromToken(this.currentToken);
                    memberName.minChar = this.scanner.startPos;
                    memberName.limChar = this.scanner.pos;
                    memberNames.push(memberName);
                } else if (this.currentToken.tokenId == 61 /* CloseBrace */ ) {
                    break;
                } else {
                    this.reportParseError("Expected identifer of enum member");
                    if (this.errorRecovery) {
                        memberName = new TypeScript.MissingIdentifier();
                        memberName.minChar = this.scanner.startPos;
                        memberName.limChar = this.scanner.startPos;
                        memberName.flags |= 8 /* Error */ ;
                    }
                }
                limChar = this.scanner.pos;
                preComments = this.parseComments();
                this.currentToken = this.scanner.scan();
                postComments = this.parseComments();
                if (this.currentToken.tokenId == 63 /* Equals */ ) {
                    this.currentToken = this.scanner.scan();
                    memberValue = this.parseExpr(errorRecoverySet, 1 /* Comma */ , true, 0 /* NoTypes */ );
                    lastValue = memberValue;
                    limChar = memberValue.limChar;
                } else {
                    if (lastValue == null) {
                        memberValue = new TypeScript.NumberLiteral(0, "0");
                        lastValue = memberValue;
                    } else {
                        var nextValue = lastValue.value + 1;
                        memberValue = new TypeScript.NumberLiteral(nextValue, nextValue.toString());
                        lastValue = memberValue;
                    }
                    var map = new TypeScript.BinaryExpression(32 /* Asg */ , new TypeScript.BinaryExpression(29 /* Index */ , new TypeScript.Identifier("_map"), memberValue), new TypeScript.StringLiteral('"' + memberName.actualText + '"'));
                    members.append(map);
                }
                var member = new TypeScript.VarDecl(memberName, this.nestingLevel);
                member.minChar = minChar;
                member.limChar = limChar;
                member.init = memberValue;
                member.typeExpr = new TypeScript.TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);
                member.varFlags |= (1024 /* Readonly */  | 512 /* Property */ );
                if (memberValue.nodeType == 24 /* NumberLit */ ) {
                    member.varFlags |= 65536 /* Constant */ ;
                } else if (memberValue.nodeType === 63 /* Lsh */ ) {
                    var binop = memberValue;
                    if (binop.operand1.nodeType === 24 /* NumberLit */  && binop.operand2.nodeType === 24 /* NumberLit */ ) {
                        member.varFlags |= 65536 /* Constant */ ;
                    }
                } else if (memberValue.nodeType === 25 /* Name */ ) {
                    var nameNode = memberValue;
                    for(var i = 0; i < memberNames.length; i++) {
                        var memberName = memberNames[i];
                        if (memberName.text === nameNode.text) {
                            member.varFlags |= 65536 /* Constant */ ;
                            break;
                        }
                    }
                }
                member.preComments = preComments;
                members.append(member);
                member.postComments = postComments;
                member.varFlags |= 1 /* Exported */ ;
                if (this.currentToken.tokenId == 62 /* Comma */ ) {
                    this.currentToken = this.scanner.scan();
                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine));
                    if ((this.currentToken.tokenId == 107 /* Identifier */ ) || (TypeScript.convertTokToIDName(this.currentToken))) {
                        continue;
                    }
                }
                break;
            }
            var endingToken = new TypeScript.ASTSpan();
            endingToken.minChar = this.scanner.startPos;
            endingToken.limChar = this.scanner.pos;
            this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
            members.limChar = this.scanner.lastTokenLimChar();
            var modDecl = new TypeScript.ModuleDeclaration(name, members, this.topVarList(), endingToken);
            modDecl.modFlags |= 256 /* IsEnum */ ;
            this.popDeclLists();
            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            return modDecl;
        };
        Parser.prototype.parseDottedName = function (enclosedList) {
            this.currentToken = this.scanner.scan();
            if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                var id = TypeScript.Identifier.fromToken(this.currentToken);
                id.preComments = this.parseComments();
                enclosedList[enclosedList.length] = id;
                id.minChar = this.scanner.startPos;
                id.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
                if (this.currentToken.tokenId == 102 /* Dot */ ) {
                    this.parseDottedName(enclosedList);
                }
            } else {
                this.reportParseError("need identifier after '.'");
            }
        };
        Parser.prototype.isValidImportPath = function (importPath) {
            importPath = TypeScript.stripQuotes(importPath);
            if (!importPath || importPath.indexOf(':') != -1 || importPath.indexOf('\\') != -1 || importPath.charAt(0) == '/') {
                return false;
            }
            return true;
        };
        Parser.prototype.parseImportDeclaration = function (errorRecoverySet, modifiers) {
            var name = null;
            var alias = null;
            var importDecl = null;
            var minChar = this.scanner.startPos;
            var isDynamicImport = false;
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId == 107 /* Identifier */  || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                name = TypeScript.Identifier.fromToken(this.currentToken);
            } else {
                this.reportParseError("Expected identifer after 'import'");
                name = new TypeScript.MissingIdentifier();
            }
            name.minChar = this.scanner.startPos;
            name.limChar = this.scanner.pos;
            this.currentToken = this.scanner.scan();
            this.checkCurrentToken(63 /* Equals */ , errorRecoverySet | 16777216 /* ID */ );
            var aliasPreComments = this.parseComments();
            var limChar;
            if (this.currentToken.tokenId == 107 /* Identifier */  || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                if (this.currentToken.tokenId == 30 /* Module */ ) {
                    limChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                    if (this.currentToken.tokenId == 56 /* OpenParen */ ) {
                        this.currentToken = this.scanner.scan();
                        if (this.currentToken.tokenId == 108 /* StringLiteral */  || this.currentToken.tokenId == 107 /* Identifier */  || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                            if (this.currentToken.tokenId == 108 /* StringLiteral */ ) {
                                if (this.topLevel) {
                                    this.hasTopLevelImportOrExport = true;
                                } else if (!this.allowImportDeclaration) {
                                    this.reportParseError("Import declaration of external module is permitted only in global or top level dynamic modules");
                                }
                                var aliasText = this.currentToken.getText();
                                alias = TypeScript.Identifier.fromToken(this.currentToken);
                                alias.minChar = this.scanner.startPos;
                                alias.limChar = this.scanner.pos;
                                if (!this.isValidImportPath((alias).text)) {
                                    this.reportParseError("Invalid import path");
                                }
                                isDynamicImport = true;
                                this.currentToken = this.scanner.scan();
                                alias.preComments = aliasPreComments;
                            } else {
                                alias = this.parseExpr(errorRecoverySet | 2 /* SColon */ , 2 /* Assignment */ , true, 0 /* NoTypes */ );
                                alias.preComments = aliasPreComments;
                            }
                        }
                        limChar = this.scanner.pos;
                        this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet | 16777216 /* ID */ );
                        if (alias) {
                            alias.postComments = this.parseComments();
                        }
                    }
                } else {
                    alias = this.parseExpr(errorRecoverySet | 2 /* SColon */ , 2 /* Assignment */ , true, 0 /* NoTypes */ );
                    limChar = this.scanner.pos;
                }
            } else {
                this.reportParseError("Expected module name");
                alias = new TypeScript.MissingIdentifier();
                alias.minChar = this.scanner.startPos;
                if (this.currentToken.tokenId == 55 /* Semicolon */ ) {
                    alias.limChar = this.scanner.startPos;
                } else {
                    alias.limChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                }
                alias.flags |= 8 /* Error */ ;
                limChar = alias.limChar;
            }
            importDecl = new TypeScript.ImportDeclaration(name, alias);
            importDecl.isDynamicImport = isDynamicImport;
            importDecl.minChar = minChar;
            importDecl.limChar = limChar;
            return importDecl;
        };
        Parser.prototype.parseModuleDecl = function (errorRecoverySet, modifiers, preComments) {
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;
            var svAmbient = this.ambientModule;
            var svTopLevel = this.topLevel;
            this.topLevel = false;
            if (this.parsingDeclareFile || svAmbient || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                this.ambientModule = true;
            }
            this.currentToken = this.scanner.scan();
            var name = null;
            var enclosedList = null;
            this.pushDeclLists();
            var minChar = this.scanner.startPos;
            var isDynamicMod = false;
            if ((this.currentToken.tokenId == 107 /* Identifier */ ) || (this.currentToken.tokenId == 108 /* StringLiteral */ ) || (!TypeScript.isPrimitiveTypeToken(this.currentToken) && TypeScript.convertTokToID(this.currentToken, this.strictMode))) {
                var nameText = this.currentToken.getText();
                if (this.currentToken.tokenId == 108 /* StringLiteral */ ) {
                    isDynamicMod = true;
                    if (!this.ambientModule) {
                        this.reportParseError("Only ambient dynamic modules may have string literal names");
                    }
                    if (!svTopLevel) {
                        this.reportParseError("Dynamic modules may not be nested within other modules");
                    }
                }
                name = TypeScript.Identifier.fromToken(this.currentToken);
                name.minChar = this.scanner.startPos;
                name.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
            } else if (this.currentToken.tokenId == 60 /* OpenBrace */ ) {
                this.reportParseError("Module name missing");
                name = new TypeScript.Identifier("");
                name.minChar = minChar;
                name.limChar = minChar;
            }
            if (this.currentToken.tokenId == 102 /* Dot */ ) {
                enclosedList = new Array();
                this.parseDottedName(enclosedList);
            }
            if (name == null) {
                name = new TypeScript.MissingIdentifier();
            }
            var moduleBody = new TypeScript.ASTList();
            var bodyMinChar = this.scanner.startPos;
            this.checkCurrentToken(60 /* OpenBrace */ , errorRecoverySet | 16777216 /* ID */ );
            if (svTopLevel && isDynamicMod) {
                this.allowImportDeclaration = true;
            } else {
                this.allowImportDeclaration = false;
            }
            this.parseStatementList(errorRecoverySet | 32 /* RCurly */ , moduleBody, true, true, TypeScript.AllowedElements.Global, modifiers);
            moduleBody.minChar = bodyMinChar;
            moduleBody.limChar = this.scanner.pos;
            var endingToken = new TypeScript.ASTSpan();
            endingToken.minChar = this.scanner.startPos;
            endingToken.limChar = this.scanner.pos;
            this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
            var limChar = this.scanner.lastTokenLimChar();
            var moduleDecl;
            this.allowImportDeclaration = svTopLevel;
            if (enclosedList && (enclosedList.length > 0)) {
                var len = enclosedList.length;
                var innerName = enclosedList[len - 1];
                var innerDecl = new TypeScript.ModuleDeclaration(innerName, moduleBody, this.topVarList(), endingToken);
                innerDecl.preComments = preComments;
                if (this.parsingDeclareFile || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                    innerDecl.modFlags |= 8 /* Ambient */ ;
                }
                innerDecl.modFlags |= 1 /* Exported */ ;
                innerDecl.minChar = minChar;
                innerDecl.limChar = limChar;
                this.popDeclLists();
                var outerModBod;
                for(var i = len - 2; i >= 0; i--) {
                    outerModBod = new TypeScript.ASTList();
                    outerModBod.append(innerDecl);
                    innerName = enclosedList[i];
                    innerDecl = new TypeScript.ModuleDeclaration(innerName, outerModBod, new TypeScript.ASTList(), endingToken);
                    outerModBod.minChar = innerDecl.minChar = minChar;
                    outerModBod.limChar = innerDecl.limChar = limChar;
                    if (this.parsingDeclareFile || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                        innerDecl.modFlags |= 8 /* Ambient */ ;
                    }
                    innerDecl.modFlags |= 1 /* Exported */ ;
                }
                outerModBod = new TypeScript.ASTList();
                outerModBod.append(innerDecl);
                outerModBod.minChar = minChar;
                outerModBod.limChar = limChar;
                moduleDecl = new TypeScript.ModuleDeclaration(name, outerModBod, new TypeScript.ASTList(), endingToken);
            } else {
                moduleDecl = new TypeScript.ModuleDeclaration(name, moduleBody, this.topVarList(), endingToken);
                moduleDecl.preComments = preComments;
                this.popDeclLists();
            }
            if (this.parsingDeclareFile || svAmbient || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                moduleDecl.modFlags |= 8 /* Ambient */ ;
            }
            if (svAmbient || TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                moduleDecl.modFlags |= 1 /* Exported */ ;
            }
            if (isDynamicMod) {
                moduleDecl.modFlags |= 2048 /* IsDynamic */ ;
            }
            this.ambientModule = svAmbient;
            this.topLevel = svTopLevel;
            moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            moduleDecl.limChar = moduleBody.limChar;
            return moduleDecl;
        };
        Parser.prototype.parseTypeReferenceTail = function (errorRecoverySet, minChar, term) {
            var result = new TypeScript.TypeReference(term, 0);
            result.minChar = minChar;
            while(this.currentToken.tokenId == 58 /* OpenBracket */ ) {
                this.currentToken = this.scanner.scan();
                result.arrayCount++;
                this.checkCurrentToken(59 /* CloseBracket */ , errorRecoverySet | 32768 /* LBrack */ );
            }
            result.limChar = this.scanner.lastTokenLimChar();
            return result;
        };
        Parser.prototype.parseNamedType = function (errorRecoverySet, minChar, term, tail) {
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId == 102 /* Dot */ ) {
                var curpos = this.scanner.pos;
                this.currentToken = this.scanner.scan();
                if ((this.currentToken.tokenId == 107 /* Identifier */ ) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && TypeScript.convertTokToID(this.currentToken, this.strictMode))) {
                    var op2 = TypeScript.Identifier.fromToken(this.currentToken);
                    op2.minChar = this.scanner.startPos;
                    op2.limChar = this.scanner.pos;
                    var dotNode = new TypeScript.BinaryExpression(19 /* Dot */ , term, op2);
                    dotNode.minChar = term.minChar;
                    dotNode.limChar = op2.limChar;
                    return this.parseNamedType(errorRecoverySet, minChar, dotNode, tail);
                } else {
                    this.reportParseError("need identifier after '.'");
                    if (this.errorRecovery) {
                        term.flags |= 32 /* DotLHS */ ;
                        term.limChar = this.scanner.lastTokenLimChar();
                        return term;
                    } else {
                        var eop2 = new TypeScript.MissingIdentifier();
                        eop2.minChar = this.scanner.pos;
                        eop2.limChar = this.scanner.pos;
                        var edotNode = new TypeScript.BinaryExpression(19 /* Dot */ , term, eop2);
                        edotNode.flags |= 8 /* Error */ ;
                        edotNode.minChar = term.minChar;
                        edotNode.limChar = eop2.limChar;
                        return this.parseNamedType(errorRecoverySet, minChar, edotNode, tail);
                    }
                }
            } else {
                if (tail) {
                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, term);
                } else {
                    return term;
                }
            }
        };
        Parser.prototype.parseTypeReference = function (errorRecoverySet, allowVoid) {
            var minChar = this.scanner.startPos;
            var isConstructorMember = false;
            switch(this.currentToken.tokenId) {
                case 51 /* Void */ :
                    if (!allowVoid) {
                        this.reportParseError("void not a valid type in this context");
                    }
                case 0 /* Any */ :
                case 32 /* Number */ :
                case 1 /* Bool */ :
                case 42 /* String */ : {
                    var text = TypeScript.tokenTable[this.currentToken.tokenId].text;
                    var predefinedIdentifier = new TypeScript.Identifier(text);
                    predefinedIdentifier.minChar = minChar;
                    predefinedIdentifier.limChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, predefinedIdentifier);
                }
                case 107 /* Identifier */ :
                    var ident = this.createRef(this.currentToken.getText(), (this.currentToken).hasEscapeSequence, minChar);
                    ident.limChar = this.scanner.pos;
                    return this.parseNamedType(errorRecoverySet, minChar, ident, true);
                case 60 /* OpenBrace */ :
                    return this.parseObjectType(minChar, errorRecoverySet);
                case 31 /* New */ :
                    this.currentToken = this.scanner.scan();
                    if (this.currentToken.tokenId != 56 /* OpenParen */ ) {
                        this.reportParseError("Expected '('");
                    } else {
                        isConstructorMember = true;
                    }
                case 56 /* OpenParen */ : {
                    var formals = new TypeScript.ASTList();
                    var variableArgList = this.parseFormalParameterList(errorRecoverySet | 64 /* RParen */ , formals, false, true, false, false, false, false, null, true);
                    this.checkCurrentToken(106 /* EqualsGreaterThan */ , errorRecoverySet);
                    var returnType = this.parseTypeReference(errorRecoverySet, true);
                    var funcDecl = new TypeScript.FuncDecl(null, null, false, null, formals, null, null, null, 73 /* FuncDecl */ );
                    funcDecl.returnTypeAnnotation = returnType;
                    funcDecl.variableArgList = variableArgList;
                    funcDecl.fncFlags |= 512 /* Signature */ ;
                    if (isConstructorMember) {
                        funcDecl.fncFlags |= 8192 /* ConstructMember */ ;
                        funcDecl.hint = "_construct";
                        funcDecl.classDecl = null;
                    }
                    funcDecl.minChar = minChar;
                    funcDecl.flags |= 4096 /* TypeReference */ ;
                    var trt = this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl);
                    funcDecl.limChar = trt.limChar;
                    return trt;
                }
                default:
                    this.reportParseError("Expected type name");
                    var etr = new TypeScript.TypeReference(null, 0);
                    etr.flags |= 8 /* Error */ ;
                    etr.minChar = this.scanner.pos;
                    etr.limChar = this.scanner.pos;
                    return etr;
            }
        };
        Parser.prototype.parseObjectType = function (minChar, errorRecoverySet) {
            this.currentToken = this.scanner.scan();
            var members = new TypeScript.ASTList();
            members.minChar = minChar;
            var prevInInterfaceDecl = this.inInterfaceDecl;
            this.inInterfaceDecl = true;
            this.parseTypeMemberList(errorRecoverySet | 32 /* RCurly */ , members);
            this.inInterfaceDecl = prevInInterfaceDecl;
            this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
            var interfaceDecl = new TypeScript.InterfaceDeclaration(this.anonId, null, members, null, null);
            interfaceDecl.minChar = minChar;
            interfaceDecl.limChar = members.limChar;
            var typeRef = this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl);
            typeRef.flags |= 4096 /* TypeReference */ ;
            return typeRef;
        };
        Parser.prototype.parseFunctionBlock = function (errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar) {
            this.checkCurrentToken(60 /* OpenBrace */ , errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);
            var savedInFunction = this.inFunction;
            this.inFunction = true;
            this.parseStatementList(errorRecoverySet | 32 /* RCurly */  | TypeScript.ErrorRecoverySet.StmtStart, bod, true, false, allowedElements, parentModifiers);
            bod.minChar = bodMinChar;
            bod.limChar = this.scanner.pos;
            this.inFunction = savedInFunction;
            if (bod.limChar > bod.minChar) {
                var ec = new TypeScript.EndCode();
                ec.minChar = bod.limChar;
                ec.limChar = ec.minChar;
                bod.append(ec);
            }
        };
        Parser.prototype.parseFunctionStatements = function (errorRecoverySet, name, isConstructor, isMethod, args, allowedElements, minChar, requiresSignature, parentModifiers) {
            this.pushDeclLists();
            var svStmtStack = this.statementInfoStack;
            this.resetStmtStack();
            var bod = null;
            var wasShorthand = false;
            var isAnonLambda = false;
            var limChar;
            var isInline = false;
            if (requiresSignature) {
                limChar = this.scanner.pos;
                if (this.currentToken.tokenId === 60 /* OpenBrace */ ) {
                    this.reportParseError("Function declarations are not permitted within interfaces, ambient modules or classes");
                    bod = new TypeScript.ASTList();
                    var bodMinChar = this.scanner.startPos;
                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);
                    this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
                    if (this.currentToken.tokenId === 55 /* Semicolon */ ) {
                        this.currentToken = this.scanner.scan();
                    }
                } else {
                    this.checkCurrentToken(55 /* Semicolon */ , errorRecoverySet, "Expected ';'");
                }
            } else {
                bod = new TypeScript.ASTList();
                var bodMinChar = this.scanner.startPos;
                if (this.currentToken.tokenId == 106 /* EqualsGreaterThan */ ) {
                    if (isMethod) {
                        this.reportParseError("'=>' may not be used for class methods");
                    }
                    wasShorthand = true;
                    this.currentToken = this.scanner.scan();
                }
                if (wasShorthand && this.currentToken.tokenId != 60 /* OpenBrace */ ) {
                    var retExpr = this.parseExpr(errorRecoverySet | 2 /* SColon */ , 2 /* Assignment */ , true, 0 /* NoTypes */ );
                    var retStmt = new TypeScript.ReturnStatement();
                    retStmt.returnExpression = retExpr;
                    retStmt.minChar = retExpr.minChar;
                    retStmt.limChar = retExpr.limChar;
                    bod.minChar = bodMinChar;
                    bod.limChar = retExpr.limChar;
                    bod.append(retStmt);
                    isInline = true;
                } else if (this.currentToken.tokenId != 105 /* EndOfFile */ ) {
                    isAnonLambda = wasShorthand;
                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);
                }
                limChar = this.scanner.pos;
            }
            var funcDecl = new TypeScript.FuncDecl(name, bod, isConstructor, null, args, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);
            var staticFuncDecl = false;
            if (!requiresSignature) {
                if (!wasShorthand || isAnonLambda) {
                    funcDecl.endingToken = new TypeScript.ASTSpan();
                    funcDecl.endingToken.minChar = this.scanner.startPos;
                    funcDecl.endingToken.limChar = this.scanner.pos;
                    this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
                    if (isAnonLambda) {
                        funcDecl.fncFlags |= 32768 /* IsFatArrowFunction */ ;
                    }
                } else {
                    funcDecl.fncFlags |= 32768 /* IsFatArrowFunction */ ;
                    funcDecl.endingToken = new TypeScript.ASTSpan();
                    funcDecl.endingToken.minChar = bod.members[0].minChar;
                    funcDecl.endingToken.limChar = bod.members[0].limChar;
                }
            }
            funcDecl.minChar = minChar;
            funcDecl.limChar = limChar;
            if (isInline) {
                funcDecl.fncFlags |= 4194304 /* Inline */ ;
            }
            if (requiresSignature) {
                funcDecl.fncFlags |= 512 /* Signature */ ;
            }
            this.statementInfoStack = svStmtStack;
            return funcDecl;
        };
        Parser.prototype.transformAnonymousArgsIntoFormals = function (formals, argList) {
            var _this = this;
            var translateBinExOperand = function (operand) {
                if (operand.nodeType == 13 /* Comma */ ) {
                    return _this.transformAnonymousArgsIntoFormals(formals, operand);
                } else if (operand.nodeType == 25 /* Name */  || operand.nodeType == 32 /* Asg */ ) {
                    var opArg = operand.nodeType == 32 /* Asg */  ? (operand).operand1 : operand;
                    opArg.isParenthesized = false;
                    var arg = new TypeScript.ArgDecl(opArg);
                    arg.preComments = opArg.preComments;
                    arg.postComments = opArg.postComments;
                    arg.minChar = operand.minChar;
                    arg.limChar = operand.limChar;
                    if (TypeScript.hasFlag(opArg.flags, 256 /* PossibleOptionalParameter */ )) {
                        arg.isOptional = true;
                    }
                    if (operand.nodeType == 32 /* Asg */ ) {
                        arg.init = (operand).operand2;
                    }
                    formals.append(arg);
                    return arg.isOptional || arg.init;
                } else {
                    _this.reportParseError("Invalid lambda argument");
                }
                return false;
            };
            if (argList) {
                if (argList.nodeType == 13 /* Comma */ ) {
                    var commaList = argList;
                    if (commaList.operand1.isParenthesized) {
                        this.reportParseError("Invalid lambda argument", commaList.operand1.minChar, commaList.operand1.limChar);
                    }
                    if (commaList.operand2.isParenthesized) {
                        this.reportParseError("Invalid lambda argument", commaList.operand2.minChar, commaList.operand2.limChar);
                    }
                    var isOptional = translateBinExOperand(commaList.operand1);
                    isOptional = translateBinExOperand(commaList.operand2) || isOptional;
                    return isOptional;
                } else {
                    return translateBinExOperand(argList);
                }
            }
        };
        Parser.prototype.parseFormalParameterList = function (errorRecoverySet, formals, isClassConstr, isSig, isIndexer, isGetter, isSetter, isLambda, preProcessedLambdaArgs, expectClosingRParen) {
            formals.minChar = this.scanner.startPos;
            if (isIndexer) {
                this.currentToken = this.scanner.scan();
            } else if (!isLambda) {
                this.checkCurrentToken(56 /* OpenParen */ , errorRecoverySet | 64 /* RParen */ );
            }
            var sawEllipsis = false;
            var firstArg = true;
            var hasOptional = false;
            var haveFirstArgID = false;
            if (isLambda && preProcessedLambdaArgs && preProcessedLambdaArgs.nodeType != 2 /* EmptyExpr */ ) {
                hasOptional = this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs);
                formals.minChar = preProcessedLambdaArgs.minChar;
                haveFirstArgID = true;
            }
            while(true) {
                var munchedArg = false;
                var argFlags = 0 /* None */ ;
                var argMinChar = this.scanner.startPos;
                if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == 45 /* This */ ) {
                    if (!isClassConstr) {
                        this.reportParseError("Instance property declarations using 'this' may only be used in class constructors");
                    }
                    this.currentToken = this.scanner.scan();
                    argFlags |= (4 /* Public */  | 512 /* Property */ );
                    if (this.currentClassDefinition) {
                        this.currentClassDefinition.varFlags |= 32768 /* ClassSuperMustBeFirstCallInConstructor */ ;
                    }
                }
                if (this.currentToken.tokenId == 37 /* Public */ ) {
                    argFlags |= (4 /* Public */  | 512 /* Property */ );
                    if (this.currentClassDefinition) {
                        this.currentClassDefinition.varFlags |= 32768 /* ClassSuperMustBeFirstCallInConstructor */ ;
                    }
                } else if (this.currentToken.tokenId == 41 /* Inline */ ) {
                } else if (this.currentToken.tokenId == 35 /* Private */ ) {
                    argFlags |= (2 /* Private */  | 512 /* Property */ );
                    if (this.currentClassDefinition) {
                        this.currentClassDefinition.varFlags |= 32768 /* ClassSuperMustBeFirstCallInConstructor */ ;
                    }
                } else if (this.currentToken.tokenId == 40 /* Static */  && isClassConstr) {
                    this.reportParseError("Static properties can not be declared as parameter properties");
                    this.currentToken = this.scanner.scan();
                }
                if (argFlags != 0 /* None */ ) {
                    if (!isClassConstr) {
                        this.reportParseError("only constructor parameters can be properties");
                    }
                    this.currentToken = this.scanner.scan();
                    if (TypeScript.isModifier(this.currentToken)) {
                        this.reportParseError("Multiple modifiers may not be applied to parameters");
                        this.currentToken = this.scanner.scan();
                    }
                    if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == 45 /* This */ ) {
                        if (!isClassConstr) {
                            this.reportParseError("Instance property declarations using 'this' may only be used in class constructors");
                        }
                        this.currentToken = this.scanner.scan();
                        this.currentToken = this.scanner.scan();
                    }
                } else if (this.currentToken.tokenId == 103 /* DotDotDot */ ) {
                    sawEllipsis = true;
                    this.currentToken = this.scanner.scan();
                    if (!(this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                        this.reportParseError("'...' parameters require both a parameter name and an array type annotation to be specified");
                        sawEllipsis = false;
                    }
                }
                var argId = null;
                if (!haveFirstArgID && (this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                    argId = TypeScript.Identifier.fromToken(this.currentToken);
                    argId.minChar = this.scanner.startPos;
                    argId.limChar = this.scanner.pos;
                }
                if (haveFirstArgID || argId) {
                    munchedArg = true;
                    var type = null;
                    var arg = null;
                    if (haveFirstArgID && formals.members.length) {
                        arg = formals.members[formals.members.length - 1];
                        if (arg.isOptional) {
                            hasOptional = true;
                        }
                    } else {
                        arg = new TypeScript.ArgDecl(argId);
                        if (isGetter) {
                            this.reportParseError("Property getters may not take any arguments");
                        }
                        if (isSetter && !firstArg) {
                            this.reportParseError("Property setters may only take one argument");
                        }
                        arg.minChar = argMinChar;
                        arg.preComments = this.parseComments();
                        this.currentToken = this.scanner.scan();
                    }
                    if (this.currentToken.tokenId == 75 /* Question */ ) {
                        arg.isOptional = true;
                        hasOptional = true;
                        this.currentToken = this.scanner.scan();
                    }
                    if (this.currentToken.tokenId == 76 /* Colon */ ) {
                        this.currentToken = this.scanner.scan();
                        type = this.parseTypeReference(errorRecoverySet, false);
                    }
                    if (this.currentToken.tokenId == 63 /* Equals */ ) {
                        if (isSig) {
                            this.reportParseError("Arguments in signatures may not have default values");
                        }
                        hasOptional = true;
                        this.currentToken = this.scanner.scan();
                        arg.init = this.parseExpr(1 /* Comma */  | errorRecoverySet, 1 /* Comma */ , false, 0 /* NoTypes */ );
                    }
                    if (hasOptional && !arg.isOptionalArg() && !sawEllipsis) {
                        this.reportParseError("Optional parameters may only be followed by other optional parameters");
                    }
                    if (sawEllipsis && arg.isOptionalArg()) {
                        this.reportParseError("Varargs may not be optional or have default parameters");
                    }
                    if (sawEllipsis && !type) {
                        this.reportParseError("'...' parameters require both a parameter name and an array type annotation to be specified");
                    }
                    arg.postComments = this.parseComments();
                    arg.typeExpr = type;
                    arg.limChar = this.scanner.lastTokenLimChar();
                    arg.varFlags |= argFlags;
                    if (!haveFirstArgID) {
                        formals.append(arg);
                    } else {
                        haveFirstArgID = false;
                    }
                }
                firstArg = false;
                if (this.currentToken.tokenId == 62 /* Comma */ ) {
                    if ((munchedArg) && (!sawEllipsis)) {
                        this.currentToken = this.scanner.scan();
                        continue;
                    } else {
                        this.reportParseError("Unexpected ',' in argument list");
                        if (this.errorRecovery) {
                            this.currentToken = this.scanner.scan();
                            continue;
                        }
                    }
                } else {
                    break;
                }
            }
            if (isIndexer) {
                this.checkCurrentToken(59 /* CloseBracket */ , errorRecoverySet | 2048 /* LCurly */  | 2 /* SColon */ );
            } else if (expectClosingRParen) {
                this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet | 2048 /* LCurly */  | 2 /* SColon */ );
            }
            formals.limChar = this.currentToken.tokenId == 105 /* EndOfFile */  ? this.scanner.pos : this.scanner.lastTokenLimChar();
            return sawEllipsis;
        };
        Parser.prototype.parseFncDecl = function (errorRecoverySet, isDecl, requiresSignature, isMethod, methodName, indexer, isStatic, markedAsAmbient, modifiers, lambdaArgContext, expectClosingRParen, isInline) {
            if (typeof isInline === "undefined") { isInline = false; }
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;
            var prevInConstr = this.parsingClassConstructorDefinition;
            this.parsingClassConstructorDefinition = false;
            var name = null;
            var fnMin = this.scanner.startPos;
            var minChar = this.scanner.pos;
            var prevNestingLevel = this.nestingLevel;
            var preComments = this.parseComments();
            var isLambda = !!lambdaArgContext;
            this.nestingLevel = 0;
            if ((!this.style_funcInLoop) && this.inLoop()) {
                this.reportParseStyleError("function declaration in loop");
            }
            if (!isMethod && !isStatic && !indexer && !lambdaArgContext && !methodName) {
                this.currentToken = this.scanner.scan();
                if ((this.currentToken.tokenId != 107 /* Identifier */ ) && (!TypeScript.convertTokToID(this.currentToken, this.strictMode))) {
                    if (isDecl) {
                        this.reportParseError("Function declaration must include identifier");
                        this.nestingLevel = prevNestingLevel;
                        return new TypeScript.IncompleteAST(fnMin, this.scanner.pos);
                    }
                } else {
                    name = TypeScript.Identifier.fromToken(this.currentToken);
                    name.minChar = this.scanner.startPos;
                    name.limChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                }
            } else {
                if (methodName) {
                    name = methodName;
                }
            }
            var args = new TypeScript.ASTList();
            var variableArgList = false;
            var isOverload = false;
            var isGetter = TypeScript.hasFlag(modifiers, 32 /* Getter */ );
            var isSetter = TypeScript.hasFlag(modifiers, 64 /* Setter */ );
            if ((this.currentToken.tokenId == 56 /* OpenParen */ ) || (indexer && (this.currentToken.tokenId == 58 /* OpenBracket */ )) || (lambdaArgContext && (lambdaArgContext.preProcessedLambdaArgs || this.currentToken.tokenId == 103 /* DotDotDot */ ))) {
                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, requiresSignature, indexer, isGetter, isSetter, isLambda, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null, expectClosingRParen);
            }
            var returnType = null;
            if (this.currentToken.tokenId == 76 /* Colon */ ) {
                this.currentToken = this.scanner.scan();
                if (TypeScript.hasFlag(modifiers, 64 /* Setter */ )) {
                    this.reportParseError("Property setters may not declare a return type");
                }
                returnType = this.parseTypeReference(errorRecoverySet, true);
            }
            if (indexer && args.members.length == 0) {
                this.reportParseError("Index signatures require a parameter type to be specified");
            }
            if (isLambda && this.currentToken.tokenId != 106 /* EqualsGreaterThan */ ) {
                this.reportParseError("Expected '=>'");
            }
            if (isDecl && !(this.parsingDeclareFile || markedAsAmbient) && !this.ambientModule && !this.ambientClass && !this.inInterfaceDecl && this.currentToken.tokenId == 55 /* Semicolon */ ) {
                isOverload = true;
                isDecl = false;
                requiresSignature = true;
            }
            var svInFncDecl = this.inFncDecl;
            this.inFncDecl = true;
            var funcDecl = this.parseFunctionStatements(errorRecoverySet | 32 /* RCurly */ , name, false, isMethod, args, 0 /* None */ , minChar, requiresSignature, 0 /* None */ );
            this.inFncDecl = svInFncDecl;
            funcDecl.variableArgList = variableArgList;
            funcDecl.isOverload = isOverload;
            if (isStatic) {
                funcDecl.fncFlags |= 16 /* Static */ ;
            }
            if (requiresSignature) {
                funcDecl.fncFlags |= 512 /* Signature */ ;
            }
            if (indexer) {
                funcDecl.fncFlags |= 65536 /* IndexerMember */ ;
            }
            if (isInline) {
                funcDecl.fncFlags |= 4194304 /* Inline */ ;
            }
            funcDecl.returnTypeAnnotation = returnType;
            if (((this.inInterfaceDecl || this.currentClassDefinition) && !this.inFncDecl) && isMethod) {
                funcDecl.fncFlags |= 1024 /* Method */ ;
                funcDecl.fncFlags |= 524288 /* ClassPropertyMethodExported */ ;
            }
            funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            this.nestingLevel = prevNestingLevel;
            this.parsingClassConstructorDefinition = prevInConstr;
            funcDecl.preComments = preComments;
            return funcDecl;
        };
        Parser.prototype.convertToTypeReference = function (ast) {
            var result;
            switch(ast.nodeType) {
                case 28 /* TypeRef */ :
                    return ast;
                case 25 /* Name */ :
                    result = new TypeScript.TypeReference(ast, 0);
                    result.minChar = ast.minChar;
                    result.limChar = ast.limChar;
                    return result;
                case 29 /* Index */ : {
                    var expr = ast;
                    result = this.convertToTypeReference(expr.operand1);
                    if (result) {
                        result.arrayCount++;
                        result.minChar = expr.minChar;
                        result.limChar = expr.limChar;
                        return result;
                    } else {
                        var etr = new TypeScript.AST(106 /* Error */ );
                        return etr;
                    }
                }
            }
            return null;
        };
        Parser.prototype.parseArgList = function (errorRecoverySet) {
            var args = new TypeScript.ASTList();
            args.minChar = this.scanner.startPos;
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId !== 57 /* CloseParen */ ) {
                while(true) {
                    if (args.members.length > 0xffff) {
                        this.reportParseError("max number of args exceeded");
                        break;
                    }
                    var arg = this.parseExpr(1 /* Comma */  | errorRecoverySet, 1 /* Comma */ , true, 0 /* NoTypes */ );
                    args.append(arg);
                    if (this.currentToken.tokenId != 62 /* Comma */ ) {
                        break;
                    }
                    this.currentToken = this.scanner.scan();
                }
            }
            args.limChar = this.scanner.pos;
            return args;
        };
        Parser.prototype.parseBaseList = function (extendsList, implementsList, errorRecoverySet, isClass) {
            var keyword = true;
            var currentList = extendsList;
            for(; ; ) {
                if (keyword) {
                    if (this.currentToken.tokenId === 24 /* Implements */ ) {
                        currentList = implementsList;
                    } else if (this.currentToken.tokenId == 15 /* Extends */  && !this.requiresExtendsBlock) {
                        this.requiresExtendsBlock = isClass;
                    }
                    this.currentToken = this.scanner.scan();
                    keyword = false;
                }
                var baseName = null;
                if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                    var minChar = this.scanner.startPos;
                    baseName = TypeScript.Identifier.fromToken(this.currentToken);
                    baseName.minChar = minChar;
                    baseName.limChar = this.scanner.pos;
                    baseName = this.parseNamedType(errorRecoverySet | 2048 /* LCurly */ , minChar, baseName, false);
                } else {
                    this.reportParseError("Expected base name");
                    if (this.errorRecovery) {
                        baseName = new TypeScript.MissingIdentifier();
                        baseName.minChar = this.scanner.pos;
                        baseName.limChar = this.scanner.pos;
                        baseName.flags |= 8 /* Error */ ;
                    }
                }
                if (this.currentToken.tokenId == 56 /* OpenParen */ ) {
                    if (isClass) {
                        this.reportParseError("Base classes may only be initialized via a 'super' call within the constructor body");
                    } else {
                        this.reportParseError("Interfaces may not be extended with a call expression");
                    }
                } else {
                    currentList.append(baseName);
                }
                if (isClass && currentList == extendsList && extendsList.members.length > 1) {
                    this.reportParseError("A class may only extend one other class");
                }
                if (this.currentToken.tokenId == 62 /* Comma */ ) {
                    this.currentToken = this.scanner.scan();
                    continue;
                } else if ((this.currentToken.tokenId == 15 /* Extends */ ) || (this.currentToken.tokenId == 24 /* Implements */ )) {
                    if (this.currentToken.tokenId == 15 /* Extends */  && !this.requiresExtendsBlock) {
                        this.requiresExtendsBlock = isClass;
                    }
                    currentList = extendsList;
                    keyword = true;
                    continue;
                }
                break;
            }
        };
        Parser.prototype.parseClassDecl = function (errorRecoverySet, minChar, modifiers) {
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;
            if ((modifiers & 4 /* Readonly */ ) != 0 /* None */ ) {
                this.reportParseError("const modifier is implicit for class");
            }
            if (this.parsingDeclareFile || this.ambientModule) {
                modifiers |= 8 /* Ambient */ ;
                modifiers |= 16 /* Exported */ ;
            }
            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & 8 /* Ambient */ ) != 0 /* None */ ;
            var svAmbientClass = this.ambientClass;
            this.ambientClass = classIsMarkedAsAmbient;
            this.currentToken = this.scanner.scan();
            var name = null;
            if ((this.currentToken.tokenId == 107 /* Identifier */ ) || (!TypeScript.isPrimitiveTypeToken(this.currentToken) && TypeScript.convertTokToID(this.currentToken, this.strictMode))) {
                name = TypeScript.Identifier.fromToken(this.currentToken);
                name.minChar = this.scanner.startPos;
                name.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
            } else {
                this.reportParseError("class missing name");
                if (this.errorRecovery) {
                    name = new TypeScript.MissingIdentifier();
                    name.minChar = this.scanner.pos;
                    name.limChar = this.scanner.pos;
                    name.flags |= 8 /* Error */ ;
                }
            }
            var extendsList = null;
            var implementsList = null;
            var requiresSignature = false;
            if ((this.currentToken.tokenId == 15 /* Extends */ ) || (this.currentToken.tokenId == 24 /* Implements */ )) {
                extendsList = new TypeScript.ASTList();
                implementsList = new TypeScript.ASTList();
                this.parseBaseList(extendsList, implementsList, errorRecoverySet, true);
            }
            var classDecl = new TypeScript.ClassDeclaration(name, null, new TypeScript.ASTList(), extendsList, implementsList);
            this.currentClassDefinition = classDecl;
            this.parseClassElements(classDecl, errorRecoverySet, modifiers);
            if (this.ambientModule || this.parsingDeclareFile || TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                classDecl.varFlags |= 1 /* Exported */ ;
            }
            if (this.ambientModule || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                classDecl.varFlags |= 8 /* Ambient */ ;
            }
            classDecl.varFlags |= 2048 /* Class */ ;
            this.ambientClass = svAmbientClass;
            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            return classDecl;
        };
        Parser.prototype.parseClassElements = function (classDecl, errorRecoverySet, parentModifiers) {
            var modifiers = parentModifiers;
            var resetModifiers = false;
            var membersMinChar = this.scanner.startPos;
            this.checkCurrentToken(60 /* OpenBrace */ , errorRecoverySet);
            this.nestingLevel++;
            var currentMemberMinChar = this.scanner.startPos;
            var wasGetOrSetId = false;
            while(!(this.currentToken.tokenId == 61 /* CloseBrace */  || this.currentToken.tokenId == 105 /* EndOfFile */ )) {
                var scanNext = true;
                var publicOrPrivateFlags = 2 /* Public */  | 1 /* Private */ ;
                if (this.currentToken.tokenId == 22 /* Get */ ) {
                    if (modifiers & 32 /* Getter */ ) {
                        this.reportParseError("Duplicate 'get' declaration in class body");
                    }
                    if (modifiers & 64 /* Setter */ ) {
                        this.reportParseError("Getter already marked as a setter");
                    }
                    modifiers |= 32 /* Getter */ ;
                } else if (this.currentToken.tokenId == 39 /* Set */ ) {
                    if (modifiers & 64 /* Setter */ ) {
                        this.reportParseError("Duplicate 'set' declaration in class body");
                    }
                    if (modifiers & 32 /* Getter */ ) {
                        this.reportParseError("Setter already marked as a getter");
                    }
                    modifiers |= 64 /* Setter */ ;
                } else if (this.currentToken.tokenId == 35 /* Private */ ) {
                    if (modifiers & publicOrPrivateFlags) {
                        this.reportParseError("Multiple modifiers may not be applied to class members");
                    }
                    modifiers |= 1 /* Private */ ;
                } else if (this.currentToken.tokenId == 37 /* Public */ ) {
                    if (modifiers & publicOrPrivateFlags) {
                        this.reportParseError("Multiple modifiers may not be applied to class members");
                    }
                    modifiers |= 2 /* Public */ ;
                } else if (this.currentToken.tokenId == 41 /* Inline */ ) {
                    modifiers |= 256 /* Inline */ ;
                } else if (this.currentToken.tokenId == 40 /* Static */ ) {
                    if (modifiers & 128 /* Static */ ) {
                        this.reportParseError("Multiple modifiers may not be applied to class members");
                    }
                    modifiers |= 128 /* Static */ ;
                } else if (this.currentToken.tokenId == 21 /* Constructor */ ) {
                    if (modifiers != parentModifiers) {
                        this.reportParseError("Constructors may not have modifiers");
                    }
                    this.parseClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers);
                    scanNext = false;
                    resetModifiers = true;
                } else if (wasGetOrSetId || this.currentToken.tokenId == 107 /* Identifier */  || TypeScript.convertTokToIDName(this.currentToken)) {
                    var idText = wasGetOrSetId ? ((modifiers & 32 /* Getter */ ) ? "get" : "set") : this.currentToken.getText();
                    var id = wasGetOrSetId ? new TypeScript.Identifier(idText) : TypeScript.Identifier.fromToken(this.currentToken);
                    id.minChar = this.scanner.startPos;
                    id.limChar = this.scanner.pos;
                    if (wasGetOrSetId) {
                        modifiers = modifiers ^ ((modifiers & 32 /* Getter */ ) ? 32 /* Getter */  : 64 /* Setter */ );
                        wasGetOrSetId = false;
                    } else {
                        this.currentToken = this.scanner.scan();
                    }
                    if (this.currentToken.tokenId == 56 /* OpenParen */ ) {
                        this.parseClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers);
                        scanNext = false;
                    } else {
                        if (modifiers & 32 /* Getter */  || modifiers & 64 /* Setter */ ) {
                            this.reportParseError("Property accessors must be functions");
                        }
                        var varDecl = this.parseClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers);
                        if (varDecl.init && varDecl.init.nodeType == 73 /* FuncDecl */ ) {
                            if (this.currentToken.tokenId == 61 /* CloseBrace */ ) {
                                scanNext = false;
                            }
                        } else if (varDecl.init && varDecl.init.nodeType == 11 /* ObjectLit */  && this.currentToken.tokenId != 55 /* Semicolon */ ) {
                            scanNext = false;
                            varDecl.init.flags |= 2 /* AutomaticSemicolon */ ;
                        } else if (this.currentToken.tokenId != 55 /* Semicolon */ ) {
                            this.reportParseError("Expected ';'");
                            scanNext = false;
                        }
                    }
                    resetModifiers = true;
                } else if (this.currentToken.tokenId == 43 /* Super */ ) {
                    this.reportParseError("Base class initializers must be the first statement in a class definition");
                } else if (!wasGetOrSetId && ((modifiers & 32 /* Getter */ ) || (modifiers & 64 /* Setter */ )) && ((this.currentToken.tokenId == 56 /* OpenParen */ ) || (this.currentToken.tokenId == 63 /* Equals */ ) || (this.currentToken.tokenId == 76 /* Colon */ ) || (this.currentToken.tokenId == 55 /* Semicolon */ ))) {
                    wasGetOrSetId = true;
                    scanNext = false;
                } else if (this.currentToken.tokenId != 55 /* Semicolon */ ) {
                    this.reportParseError("Unexpected '" + this.currentToken.getText() + "' in class definition");
                    resetModifiers = true;
                }
                if (scanNext) {
                    this.currentToken = this.scanner.scan();
                }
                if (resetModifiers) {
                    modifiers = parentModifiers;
                    currentMemberMinChar = this.scanner.startPos;
                    resetModifiers = false;
                }
            }
            var membersLimChar = this.scanner.pos;
            if (this.currentToken.tokenId == 61 /* CloseBrace */ ) {
                classDecl.endingToken = new TypeScript.ASTSpan();
                classDecl.endingToken.minChar = this.scanner.startPos;
                classDecl.endingToken.limChar = this.scanner.pos;
                if (!this.currentClassDefinition.members.members.length) {
                    this.currentClassDefinition.preComments = this.parseComments();
                }
                this.currentToken = this.scanner.scan();
            }
            this.nestingLevel--;
            this.currentClassDefinition.members.minChar = membersMinChar;
            this.currentClassDefinition.members.limChar = membersLimChar;
            this.currentClassDefinition.limChar = membersLimChar;
            this.currentClassDefinition = null;
        };
        Parser.prototype.parseClassConstructorDeclaration = function (minChar, errorRecoverySet, modifiers) {
            this.parsingClassConstructorDefinition = true;
            var isAmbient = this.parsingDeclareFile || TypeScript.hasFlag(modifiers, 8 /* Ambient */ );
            var args = new TypeScript.ASTList();
            var variableArgList = false;
            var preComments = this.parseComments();
            var constructorSpan = new TypeScript.ASTSpan();
            constructorSpan.minChar = this.scanner.startPos;
            constructorSpan.limChar = this.scanner.pos;
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId == 56 /* OpenParen */ ) {
                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, isAmbient, false, false, false, false, null, true);
                if (args.members.length > 0) {
                    var lastArg = args.members[args.members.length - 1];
                }
            }
            var requiresSignature = isAmbient || this.currentToken.tokenId == 55 /* Semicolon */ ;
            if (requiresSignature) {
                for(var i = 0; i < args.members.length; i++) {
                    var arg = args.members[i];
                    if (TypeScript.hasFlag(arg.varFlags, 512 /* Property */ )) {
                        this.reportParseError("Overload or ambient signatures may not specify parameter properties", arg.minChar, arg.limChar);
                    }
                }
            }
            if (!requiresSignature) {
                this.currentClassDefinition.constructorNestingLevel = this.nestingLevel + 1;
            }
            var constructorFuncDecl = this.parseFunctionStatements(errorRecoverySet | 32 /* RCurly */ , this.currentClassDefinition.name, true, false, args, 2048 /* Properties */ , minChar, requiresSignature, modifiers);
            constructorFuncDecl.constructorSpan = constructorSpan;
            constructorFuncDecl.preComments = preComments;
            if (requiresSignature && !isAmbient) {
                constructorFuncDecl.isOverload = true;
            }
            constructorFuncDecl.variableArgList = variableArgList;
            this.currentClassDecl = null;
            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentClassDefinition.name);
            constructorFuncDecl.classDecl = this.currentClassDefinition;
            if (isAmbient) {
                constructorFuncDecl.fncFlags |= 8 /* Ambient */ ;
            }
            if (requiresSignature) {
                constructorFuncDecl.fncFlags |= 512 /* Signature */ ;
            }
            if (this.ambientModule || TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                constructorFuncDecl.fncFlags |= 1 /* Exported */ ;
            }
            if (this.currentClassDefinition.constructorDecl) {
                if (!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {
                    this.reportParseError("Duplicate constructor definition");
                }
            }
            if (isAmbient || !constructorFuncDecl.isSignature()) {
                this.currentClassDefinition.constructorDecl = constructorFuncDecl;
            }
            constructorFuncDecl.fncFlags |= 262144 /* ClassMethod */ ;
            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = constructorFuncDecl;
            this.parsingClassConstructorDefinition = false;
            return constructorFuncDecl;
        };
        Parser.prototype.parseClassMemberVariableDeclaration = function (text, minChar, isDeclaredInConstructor, errorRecoverySet, modifiers) {
            var varDecl = new TypeScript.VarDecl(text, this.nestingLevel);
            varDecl.minChar = minChar;
            var isStatic = false;
            varDecl.preComments = this.parseComments();
            varDecl.varFlags |= 4096 /* ClassProperty */ ;
            if (this.currentToken.tokenId == 76 /* Colon */ ) {
                this.currentToken = this.scanner.scan();
                varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | 4 /* Asg */  | 1 /* Comma */ , false);
                if (varDecl.typeExpr && varDecl.typeExpr.nodeType == 28 /* TypeRef */ ) {
                    var typeExpr = (varDecl.typeExpr);
                    if (typeExpr.term && typeExpr.term.nodeType == 73 /* FuncDecl */ ) {
                        typeExpr.term.preComments = varDecl.preComments;
                    }
                }
            }
            if (this.currentToken.tokenId == 63 /* Equals */ ) {
                if (this.parsingDeclareFile || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                    this.reportParseError("context does not permit variable initializer");
                    if (this.errorRecovery) {
                        this.skip(errorRecoverySet);
                        varDecl.flags |= 8 /* Error */ ;
                        varDecl.limChar = this.scanner.lastTokenLimChar();
                        return varDecl;
                    }
                }
                this.currentToken = this.scanner.scan();
                varDecl.init = this.parseExpr(1 /* Comma */  | errorRecoverySet, 1 /* Comma */ , true, 0 /* NoTypes */ );
                varDecl.limChar = varDecl.init.limChar;
                if (!(modifiers & 128 /* Static */ )) {
                    this.currentClassDefinition.varFlags |= 32768 /* ClassSuperMustBeFirstCallInConstructor */ ;
                }
            } else {
                varDecl.limChar = this.scanner.pos;
            }
            if (modifiers & 128 /* Static */ ) {
                varDecl.varFlags |= 16 /* Static */ ;
                isStatic = true;
            }
            if ((modifiers & 1 /* Private */ ) != 0 /* None */ ) {
                varDecl.varFlags |= 2 /* Private */ ;
            } else {
                varDecl.varFlags |= 4 /* Public */ ;
            }
            varDecl.varFlags |= 512 /* Property */ ;
            if (isDeclaredInConstructor) {
                varDecl.varFlags |= 16384 /* ClassConstructorProperty */ ;
            }
            if (!isDeclaredInConstructor && !isStatic) {
                varDecl.varFlags |= 8192 /* ClassBodyProperty */ ;
            }
            this.currentClassDefinition.knownMemberNames[text.actualText] = true;
            if (!isDeclaredInConstructor) {
                this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = varDecl;
            }
            varDecl.postComments = this.parseComments();
            return varDecl;
        };
        Parser.prototype.parseClassMemberFunctionDeclaration = function (methodName, minChar, errorRecoverySet, modifiers) {
            var wasAccessorID = this.prevIDTok != null;
            var isAccessor = TypeScript.hasFlag(modifiers, 32 /* Getter */ ) || TypeScript.hasFlag(modifiers, 64 /* Setter */ );
            var isStatic = TypeScript.hasFlag(modifiers, 128 /* Static */ );
            var isInline = TypeScript.hasFlag(modifiers, 256 /* Inline */ );
            var isAmbient = this.ambientModule || TypeScript.hasFlag(modifiers, 8 /* Ambient */ );
            errorRecoverySet |= 64 /* RParen */ ;
            if (isAccessor && (modifiers & 8 /* Ambient */ )) {
                this.reportParseError("Property accessors may not be declared in ambient classes");
            }
            var ast = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null, true, isInline);
            if (ast.nodeType == 106 /* Error */ ) {
                return ast;
            }
            var funcDecl = ast;
            funcDecl.minChar = minChar;
            if (funcDecl.bod !== null) {
                funcDecl.limChar = funcDecl.bod.limChar;
            }
            if (modifiers & 1 /* Private */ ) {
                funcDecl.fncFlags |= 2 /* Private */ ;
            } else {
                funcDecl.fncFlags |= 4 /* Public */ ;
            }
            if (isStatic) {
                funcDecl.fncFlags |= 16 /* Static */ ;
            }
            if (isAccessor) {
                if (TypeScript.hasFlag(modifiers, 32 /* Getter */ )) {
                    funcDecl.fncFlags |= 64 /* GetAccessor */ ;
                    funcDecl.hint = "get" + funcDecl.name.actualText;
                } else {
                    funcDecl.fncFlags |= 128 /* SetAccessor */ ;
                    funcDecl.hint = "set" + funcDecl.name.actualText;
                }
                funcDecl.fncFlags |= 131072 /* IsFunctionExpression */ ;
                if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                    this.reportParseError("Property accessors are only available when targeting ES5 or greater", funcDecl.minChar, funcDecl.limChar);
                }
            }
            funcDecl.fncFlags |= 262144 /* ClassMethod */ ;
            this.currentClassDefinition.knownMemberNames[methodName.actualText] = true;
            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = funcDecl;
            return funcDecl;
        };
        Parser.prototype.parseTypeMember = function (errorRecoverySet) {
            var minChar = this.scanner.startPos;
            var propertyDecl = this.parsePropertyDeclaration(errorRecoverySet, 2 /* Public */ , true, false);
            if (propertyDecl) {
                propertyDecl.minChar = minChar;
                if (propertyDecl.nodeType == 75 /* VarDecl */ ) {
                    this.checkCurrentToken(55 /* Semicolon */ , errorRecoverySet);
                }
            }
            return propertyDecl;
        };
        Parser.prototype.parseTypeMemberList = function (errorRecoverySet, members) {
            errorRecoverySet |= 1073741824 /* TypeScriptS */ ;
            while(true) {
                switch(this.currentToken.tokenId) {
                    case 61 /* CloseBrace */ :
                    case 105 /* EndOfFile */ :
                        members.limChar = this.scanner.pos;
                        return;
                }
                var element = this.parseTypeMember(errorRecoverySet);
                if (element) {
                    members.append(element);
                }
            }
        };
        Parser.prototype.parseInterfaceDecl = function (errorRecoverySet, modifiers) {
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;
            this.currentToken = this.scanner.scan();
            var minChar = this.scanner.pos;
            var name = null;
            if ((this.currentToken.tokenId == 107 /* Identifier */ ) || (!TypeScript.isPrimitiveTypeToken(this.currentToken) && TypeScript.convertTokToID(this.currentToken, this.strictMode))) {
                name = TypeScript.Identifier.fromToken(this.currentToken);
                name.minChar = this.scanner.startPos;
                name.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
            } else {
                this.reportParseError("interface missing name");
                if (this.errorRecovery) {
                    name = new TypeScript.MissingIdentifier();
                    name.minChar = this.scanner.pos;
                    name.limChar = this.scanner.pos;
                    name.flags |= 8 /* Error */ ;
                }
            }
            var extendsList = null;
            var implementsList = null;
            if (this.currentToken.tokenId === 15 /* Extends */  || this.currentToken.tokenId === 24 /* Implements */ ) {
                if (this.currentToken.tokenId === 24 /* Implements */ ) {
                    this.reportParseError("Expected 'extends'");
                }
                extendsList = new TypeScript.ASTList();
                implementsList = new TypeScript.ASTList();
                extendsList.minChar = this.scanner.startPos;
                this.parseBaseList(extendsList, implementsList, errorRecoverySet, false);
            }
            var membersMinChar = this.scanner.startPos;
            this.checkCurrentToken(60 /* OpenBrace */ , errorRecoverySet | 1073741824 /* TypeScriptS */ );
            var members = new TypeScript.ASTList();
            members.minChar = membersMinChar;
            var prevInInterfaceDecl = this.inInterfaceDecl;
            this.inInterfaceDecl = true;
            this.parseTypeMemberList(errorRecoverySet | 32 /* RCurly */ , members);
            this.inInterfaceDecl = prevInInterfaceDecl;
            this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
            var interfaceDecl = new TypeScript.InterfaceDeclaration(name, null, members, extendsList, null);
            if (TypeScript.hasFlag(modifiers, 1 /* Private */ )) {
                interfaceDecl.varFlags |= 2 /* Private */ ;
            }
            if (TypeScript.hasFlag(modifiers, 2 /* Public */ )) {
                interfaceDecl.varFlags |= 4 /* Public */ ;
            }
            if (this.parsingDeclareFile || this.ambientModule || TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                interfaceDecl.varFlags |= 1 /* Exported */ ;
            }
            interfaceDecl.limChar = members.limChar;
            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            return interfaceDecl;
        };
        Parser.prototype.makeVarDecl = function (id, nest) {
            var varDecl = new TypeScript.VarDecl(id, nest);
            var currentVarList = this.topVarList();
            if (currentVarList) {
                currentVarList.append(varDecl);
            }
            return varDecl;
        };
        Parser.prototype.parsePropertyDeclaration = function (errorRecoverySet, modifiers, requireSignature, isStatic, unnamedAmbientFunctionOk) {
            var text = null;
            var minChar = this.scanner.startPos;
            var nameLimChar = minChar;
            var isNew = false;
            var isIndexer = false;
            var wasAccessorID = this.prevIDTok != null;
            var isAccessor = TypeScript.hasFlag(modifiers, 32 /* Getter */ ) || TypeScript.hasFlag(modifiers, 64 /* Setter */ );
            if (this.parsingDeclareFile || this.ambientModule || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                requireSignature = true;
            }
            if (this.currentToken.tokenId == 56 /* OpenParen */  && !wasAccessorID) {
                if (!requireSignature && !isStatic) {
                    this.reportParseError("Expected identifier in property declaration");
                    if (this.errorRecovery) {
                        this.skip(errorRecoverySet);
                        text = new TypeScript.MissingIdentifier();
                    }
                }
            } else if (this.currentToken.tokenId == 31 /* New */ ) {
                if (requireSignature) {
                    this.currentToken = this.scanner.scan();
                    if (this.currentToken.tokenId == 56 /* OpenParen */ ) {
                        isNew = true;
                    }
                }
                if (!isNew) {
                    if (!requireSignature) {
                        this.currentToken = this.scanner.scan();
                    }
                    text = new TypeScript.Identifier("new");
                    text.minChar = this.scanner.pos - 3;
                    text.limChar = this.scanner.pos;
                    nameLimChar = this.scanner.pos;
                }
            } else if ((this.currentToken.tokenId == 58 /* OpenBracket */ ) && requireSignature) {
                isIndexer = true;
                text = new TypeScript.Identifier("__item");
            } else if ((this.currentToken.tokenId != 107 /* Identifier */ ) && (!TypeScript.convertTokToIDName(this.currentToken)) && !wasAccessorID) {
                this.reportParseError("Expected identifier in property declaration");
                if (this.errorRecovery) {
                    var eminChar = this.scanner.startPos;
                    var curpos = this.scanner.pos;
                    this.skip(errorRecoverySet & (~1 /* Comma */ ));
                    if (this.scanner.pos == curpos) {
                        this.currentToken = this.scanner.scan();
                    }
                    var epd = new TypeScript.VarDecl(new TypeScript.MissingIdentifier(), this.nestingLevel);
                    epd.flags |= 8 /* Error */ ;
                    epd.minChar = eminChar;
                    epd.limChar = this.scanner.lastTokenLimChar();
                    return epd;
                }
            } else {
                if (wasAccessorID) {
                    text = TypeScript.Identifier.fromToken(this.prevIDTok);
                    text.minChar = this.scanner.lastTokenLimChar() - 3;
                    text.limChar = this.scanner.lastTokenLimChar();
                    nameLimChar = text.limChar;
                    if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                    }
                    if (this.currentToken.getText() == text.actualText && this.currentToken != this.prevIDTok) {
                        this.currentToken = this.scanner.scan();
                    }
                    this.prevIDTok = null;
                } else {
                    text = TypeScript.Identifier.fromToken(this.currentToken);
                    text.minChar = this.scanner.startPos;
                    text.limChar = this.scanner.pos;
                    nameLimChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                }
            }
            if (this.currentToken.tokenId == 75 /* Question */ ) {
                if (this.inInterfaceDecl && text) {
                    text.flags |= 1024 /* OptionalName */ ;
                } else {
                    this.reportParseError("Optional properties may only be declared on interface or object types");
                }
                this.currentToken = this.scanner.scan();
            }
            if ((this.currentToken.tokenId == 56 /* OpenParen */ ) || (isIndexer && (this.currentToken.tokenId == 58 /* OpenBracket */ ))) {
                var ers = errorRecoverySet | 64 /* RParen */ ;
                if (isIndexer) {
                    ers = errorRecoverySet | 16 /* RBrack */ ;
                }
                if (!text && unnamedAmbientFunctionOk && !isIndexer) {
                    text = new TypeScript.MissingIdentifier();
                }
                var ast = this.parseFncDecl(ers, true, requireSignature, this.currentClassDefinition || this.inInterfaceDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )), modifiers, null, true, TypeScript.hasFlag(modifiers, 256 /* Inline */ ));
                var funcDecl;
                if (ast.nodeType == 106 /* Error */ ) {
                    return ast;
                } else {
                    funcDecl = ast;
                }
                if (funcDecl.name) {
                    funcDecl.name.minChar = minChar;
                    funcDecl.name.limChar = nameLimChar;
                }
                if ((modifiers & 2 /* Public */ ) != 0 /* None */ ) {
                    funcDecl.fncFlags |= 4 /* Public */ ;
                }
                if ((modifiers & 1 /* Private */ ) != 0 /* None */ ) {
                    funcDecl.fncFlags |= 2 /* Private */ ;
                }
                if (isStatic) {
                    funcDecl.fncFlags |= 16 /* Static */ ;
                }
                if (this.parsingDeclareFile || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                    funcDecl.fncFlags |= 8 /* Ambient */ ;
                }
                if (isAccessor) {
                    if (TypeScript.hasFlag(modifiers, 32 /* Getter */ )) {
                        funcDecl.fncFlags |= 64 /* GetAccessor */ ;
                        funcDecl.hint = "get" + funcDecl.name.actualText;
                    } else {
                        funcDecl.fncFlags |= 128 /* SetAccessor */ ;
                        funcDecl.hint = "set" + funcDecl.name.actualText;
                    }
                    funcDecl.fncFlags |= 131072 /* IsFunctionExpression */ ;
                    if (modifiers & 8 /* Ambient */ ) {
                        this.reportParseError("Property accessors may not be declared in ambient types");
                    }
                }
                if (text == null || (text.isMissing() && unnamedAmbientFunctionOk && !isIndexer)) {
                    if (isNew) {
                        funcDecl.fncFlags |= 8192 /* ConstructMember */ ;
                        funcDecl.hint = "_construct";
                        funcDecl.classDecl = this.currentClassDecl;
                    } else {
                        funcDecl.hint = "_call";
                        funcDecl.fncFlags |= 4096 /* CallMember */ ;
                    }
                }
                return funcDecl;
            } else {
                var varDecl = new TypeScript.VarDecl(text, this.nestingLevel);
                varDecl.preComments = this.parseComments();
                varDecl.minChar = minChar;
                if (this.currentToken.tokenId == 76 /* Colon */ ) {
                    this.currentToken = this.scanner.scan();
                    varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | 4 /* Asg */  | 1 /* Comma */ , false);
                    if (varDecl.typeExpr && varDecl.typeExpr.nodeType == 28 /* TypeRef */ ) {
                        var typeExpr = (varDecl.typeExpr);
                        if (typeExpr.term && typeExpr.term.nodeType == 73 /* FuncDecl */ ) {
                            typeExpr.term.preComments = varDecl.preComments;
                        }
                    }
                }
                if (this.currentToken.tokenId == 63 /* Equals */ ) {
                    if (requireSignature) {
                        this.reportParseError("context does not permit variable initializer");
                        if (this.errorRecovery) {
                            this.skip(errorRecoverySet);
                            varDecl.flags |= 8 /* Error */ ;
                            varDecl.limChar = this.scanner.lastTokenLimChar();
                            return varDecl;
                        }
                    }
                    this.currentToken = this.scanner.scan();
                    varDecl.init = this.parseExpr(1 /* Comma */  | errorRecoverySet, 1 /* Comma */ , true, 0 /* NoTypes */ );
                    varDecl.limChar = varDecl.init.limChar;
                    if (varDecl.init.nodeType == 73 /* FuncDecl */ ) {
                        var funcDecl = varDecl.init;
                        funcDecl.hint = varDecl.id.text;
                        funcDecl.boundToProperty = varDecl;
                    } else if (isAccessor) {
                        this.reportParseError("Accessors may only be functions");
                    }
                } else {
                    varDecl.limChar = this.scanner.pos;
                }
                if ((modifiers & 4 /* Readonly */ ) != 0 /* None */ ) {
                    varDecl.varFlags |= 1024 /* Readonly */ ;
                }
                if (isStatic) {
                    varDecl.varFlags |= 16 /* Static */ ;
                }
                if ((modifiers & 2 /* Public */ ) != 0 /* None */ ) {
                    varDecl.varFlags |= 4 /* Public */ ;
                }
                if ((modifiers & 1 /* Private */ ) != 0 /* None */ ) {
                    varDecl.varFlags |= 2 /* Private */ ;
                }
                varDecl.varFlags |= 512 /* Property */ ;
                return varDecl;
            }
        };
        Parser.prototype.parseVariableDeclaration = function (errorRecoverySet, modifiers, allowIn, isStatic) {
            var isConst = TypeScript.hasFlag(modifiers, 4 /* Readonly */ );
            var minChar = this.scanner.startPos;
            var varDecl = null;
            var declList = null;
            var multivar = false;
            this.currentToken = this.scanner.scan();
            var varDeclPreComments = this.parseComments();
            while(true) {
                if ((this.currentToken.tokenId != 107 /* Identifier */ ) && (!TypeScript.convertTokToID(this.currentToken, this.strictMode))) {
                    this.reportParseError("Expected identifier in variable declaration");
                    if (this.errorRecovery) {
                        varDecl = new TypeScript.VarDecl(new TypeScript.MissingIdentifier(), this.nestingLevel);
                        varDecl.minChar = minChar;
                        this.skip(errorRecoverySet);
                        varDecl.flags |= 8 /* Error */ ;
                        varDecl.limChar = this.scanner.lastTokenLimChar();
                        return varDecl;
                    }
                }
                var varDeclName = TypeScript.Identifier.fromToken(this.currentToken);
                if (this.strictMode && (varDeclName.text == "eval")) {
                    this.reportParseError("'eval' may not name a variable in strict mode");
                }
                varDecl = this.makeVarDecl(varDeclName, this.nestingLevel);
                varDecl.id.minChar = this.scanner.startPos;
                varDecl.id.limChar = this.scanner.pos;
                varDecl.preComments = varDeclPreComments;
                if (isStatic) {
                    varDecl.varFlags |= 16 /* Static */ ;
                }
                if (TypeScript.hasFlag(modifiers, 4 /* Readonly */ )) {
                    varDecl.varFlags |= 1024 /* Readonly */ ;
                }
                if (this.parsingDeclareFile || this.ambientModule || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                    varDecl.varFlags |= 8 /* Ambient */ ;
                }
                if (this.parsingDeclareFile || this.ambientModule || TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                    varDecl.varFlags |= 1 /* Exported */ ;
                }
                varDecl.minChar = minChar;
                if (declList) {
                    declList.append(varDecl);
                }
                this.currentToken = this.scanner.scan();
                if (this.currentToken.tokenId == 76 /* Colon */ ) {
                    this.currentToken = this.scanner.scan();
                    var prevInFncDecl = this.inFncDecl;
                    this.inFncDecl = false;
                    varDecl.typeExpr = this.parseTypeReference(errorRecoverySet | 4 /* Asg */  | 1 /* Comma */ , false);
                    this.inFncDecl = prevInFncDecl;
                }
                if (this.currentToken.tokenId == 63 /* Equals */ ) {
                    if (TypeScript.hasFlag(varDecl.varFlags, 8 /* Ambient */ )) {
                        this.reportParseError("Ambient variable can not have an initializer");
                    }
                    this.currentToken = this.scanner.scan();
                    varDecl.init = this.parseExpr(1 /* Comma */  | errorRecoverySet, 1 /* Comma */ , allowIn, 0 /* NoTypes */ );
                    varDecl.limChar = varDecl.init.limChar;
                    if (varDecl.init.nodeType == 73 /* FuncDecl */ ) {
                        var funcDecl = varDecl.init;
                        funcDecl.hint = varDecl.id.actualText;
                    }
                } else {
                    if (isConst) {
                        this.reportParseError("const declaration requires initializer");
                    }
                    varDecl.limChar = this.scanner.pos;
                }
                varDecl.postComments = this.parseCommentsForLine(this.scanner.line);
                if (this.currentToken.tokenId != 62 /* Comma */ ) {
                    if (declList) {
                        declList.limChar = varDecl.limChar;
                        return declList;
                    } else {
                        return varDecl;
                    }
                }
                if (!multivar) {
                    declList = new TypeScript.ASTList();
                    declList.minChar = varDecl.minChar;
                    declList.append(varDecl);
                    multivar = true;
                }
                this.currentToken = this.scanner.scan();
                minChar = this.scanner.startPos;
            }
        };
        Parser.prototype.parseMemberList = function (errorRecoverySet) {
            var elements = new TypeScript.ASTList();
            if (this.currentToken.tokenId == 61 /* CloseBrace */ ) {
                return elements;
            }
            var idHint = null;
            var memberName = null;
            var memberExpr = null;
            var member = null;
            var minChar = this.scanner.startPos;
            var isSet = false;
            var skippedTokenForGetSetId = false;
            var getSetTok = null;
            var getSetStartPos = 0;
            var getSetPos = 0;
            for(; ; ) {
                var accessorPattern = false;
                if (this.currentToken.tokenId == 22 /* Get */  || this.currentToken.tokenId == 39 /* Set */ ) {
                    isSet = this.currentToken.tokenId == 39 /* Set */ ;
                    getSetTok = this.currentToken;
                    getSetStartPos = this.scanner.startPos;
                    getSetPos = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                    if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToIDName(this.currentToken)) {
                        idHint = isSet ? "set" : "get";
                        idHint = idHint + this.currentToken.getText();
                        memberName = TypeScript.Identifier.fromToken(this.currentToken);
                        memberName.minChar = this.scanner.startPos;
                        accessorPattern = true;
                        if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                            this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                        }
                    } else if (this.currentToken.tokenId != 76 /* Colon */ ) {
                        this.reportParseError("Expected identifier, string or number as accessor name");
                    } else {
                        skippedTokenForGetSetId = true;
                        memberName = TypeScript.Identifier.fromToken(getSetTok);
                        memberName.minChar = getSetStartPos;
                        memberName.limChar = getSetPos;
                    }
                } else if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToIDName(this.currentToken)) {
                    idHint = this.currentToken.getText();
                    memberName = TypeScript.Identifier.fromToken(this.currentToken);
                    memberName.minChar = this.scanner.startPos;
                    memberName.limChar = this.scanner.pos;
                } else if (this.currentToken.tokenId == 108 /* StringLiteral */ ) {
                    idHint = this.currentToken.getText();
                    memberName = new TypeScript.StringLiteral(idHint);
                    memberName.minChar = this.scanner.startPos;
                    memberName.limChar = this.scanner.pos;
                } else if (this.currentToken.tokenId == 110 /* NumberLiteral */ ) {
                    var ntok = this.currentToken;
                    idHint = ntok.value.toString();
                    memberName = new TypeScript.StringLiteral(idHint);
                    memberName.minChar = this.scanner.startPos;
                    memberName.limChar = this.scanner.pos;
                } else {
                    this.reportParseError("Expected identifier, string or number as member name");
                    if (this.errorRecovery) {
                        memberName = new TypeScript.MissingIdentifier();
                        memberName.minChar = this.scanner.startPos;
                        memberName.flags |= 8 /* Error */ ;
                        this.skip(errorRecoverySet | 1 /* Comma */ );
                        memberName.limChar = this.scanner.lastTokenLimChar();
                    }
                }
                if (!skippedTokenForGetSetId) {
                    this.currentToken = this.scanner.scan();
                } else {
                    skippedTokenForGetSetId = false;
                }
                if (this.currentToken.tokenId == 75 /* Question */ ) {
                    memberName.flags |= 1024 /* OptionalName */ ;
                    this.currentToken = this.scanner.scan();
                }
                if (accessorPattern) {
                    var args = new TypeScript.ASTList();
                    this.parseFormalParameterList(errorRecoverySet | 64 /* RParen */ , args, false, true, false, !isSet, isSet, false, null, true);
                    var funcDecl = this.parseFunctionStatements(errorRecoverySet | 32 /* RCurly */ , memberName, false, true, args, 0 /* None */ , this.scanner.startPos, false, 0 /* None */ );
                    if (isSet && funcDecl.returnTypeAnnotation) {
                        this.reportParseError("Property setters may not declare a return type");
                    }
                    funcDecl.fncFlags |= isSet ? 128 /* SetAccessor */  : 64 /* GetAccessor */ ;
                    funcDecl.fncFlags |= 131072 /* IsFunctionExpression */ ;
                    funcDecl.hint = idHint;
                    memberExpr = funcDecl;
                    member = new TypeScript.BinaryExpression(74 /* Member */ , memberName, memberExpr);
                    member.minChar = memberName.minChar;
                    if (memberExpr.nodeType == 73 /* FuncDecl */ ) {
                        var funcDecl = memberExpr;
                        funcDecl.hint = idHint;
                    }
                } else if (this.currentToken.tokenId == 76 /* Colon */ ) {
                    this.currentToken = this.scanner.scan();
                    memberExpr = this.parseExpr(1 /* Comma */  | errorRecoverySet, 1 /* Comma */ , true, 0 /* NoTypes */ );
                    if (memberExpr.nodeType == 28 /* TypeRef */ ) {
                        this.reportParseError("Expected 'new' on array declaration in member definition");
                    }
                    member = new TypeScript.BinaryExpression(74 /* Member */ , memberName, memberExpr);
                    member.minChar = memberName.minChar;
                    if (memberExpr.nodeType == 73 /* FuncDecl */ ) {
                        var funcDecl = memberExpr;
                        funcDecl.hint = idHint;
                    }
                } else {
                    this.reportParseError("Expected ':' in member definition");
                    if (this.errorRecovery) {
                        this.skip(errorRecoverySet);
                        elements.flags |= 8 /* Error */ ;
                        elements.minChar = minChar;
                        elements.limChar = this.scanner.lastTokenLimChar();
                        return elements;
                    }
                }
                idHint = null;
                elements.append(member);
                member.limChar = this.scanner.lastTokenLimChar();
                if (this.currentToken.tokenId != 62 /* Comma */ ) {
                    break;
                } else {
                    this.currentToken = this.scanner.scan();
                }
                if (this.currentToken.tokenId == 61 /* CloseBrace */ ) {
                    break;
                }
            }
            if (member) {
                elements.limChar = member.limChar;
            }
            elements.minChar = minChar;
            return elements;
        };
        Parser.prototype.parseArrayList = function (errorRecoverySet) {
            var elements = null;
            if (this.currentToken.tokenId == 59 /* CloseBracket */ ) {
                return elements;
            } else {
                elements = new TypeScript.ASTList();
                elements.minChar = this.scanner.startPos;
            }
            var arg;
            for(; ; ) {
                if ((this.currentToken.tokenId == 62 /* Comma */ ) || (this.currentToken.tokenId == 59 /* CloseBracket */ )) {
                    arg = new TypeScript.AST(2 /* EmptyExpr */ );
                } else {
                    arg = this.parseExpr(1 /* Comma */  | errorRecoverySet, 1 /* Comma */ , true, 0 /* NoTypes */ );
                }
                elements.append(arg);
                if (this.currentToken.tokenId != 62 /* Comma */ ) {
                    break;
                }
                this.currentToken = this.scanner.scan();
            }
            elements.limChar = this.scanner.lastTokenLimChar();
            return elements;
        };
        Parser.prototype.parseArrayLiteral = function (errorRecoverySet) {
            var arrayLiteral = null;
            arrayLiteral = new TypeScript.UnaryExpression(10 /* ArrayLit */ , this.parseArrayList(errorRecoverySet));
            return arrayLiteral;
        };
        Parser.prototype.parseTerm = function (errorRecoverySet, allowCall, typeContext, inCast) {
            var ast = null;
            var sawId = false;
            var inNew = false;
            var minChar = this.scanner.startPos;
            var limChar = this.scanner.pos;
            var parseAsLambda = false;
            var expectlambdaRParen = false;
            switch(this.currentToken.tokenId) {
                case 32 /* Number */ :
                case 1 /* Bool */ :
                case 0 /* Any */ :
                case 42 /* String */ :
                    var tid = new TypeScript.Identifier(TypeScript.tokenTable[this.currentToken.tokenId].text);
                    if (TypeScript.hasFlag(typeContext, 2 /* Primitive */ )) {
                        ast = new TypeScript.TypeReference(tid, 0);
                        sawId = true;
                    } else {
                        ast = tid;
                        sawId = true;
                    }
                    ast.minChar = minChar;
                    this.currentToken = this.scanner.scan();
                    limChar = this.scanner.lastTokenLimChar();
                    break;
                case 45 /* This */ :
                    ast = new TypeScript.AST(5 /* This */ );
                    ast.minChar = minChar;
                    this.currentToken = this.scanner.scan();
                    limChar = this.scanner.lastTokenLimChar();
                    break;
                case 43 /* Super */ :
                    ast = new TypeScript.AST(6 /* Super */ );
                    ast.minChar = minChar;
                    this.currentToken = this.scanner.scan();
                    limChar = this.scanner.lastTokenLimChar();
                    break;
                case 47 /* True */ :
                    ast = new TypeScript.AST(3 /* True */ );
                    this.currentToken = this.scanner.scan();
                    ast.minChar = minChar;
                    break;
                case 17 /* False */ :
                    ast = new TypeScript.AST(4 /* False */ );
                    this.currentToken = this.scanner.scan();
                    ast.minChar = minChar;
                    break;
                case 33 /* Null */ :
                    ast = new TypeScript.AST(9 /* Null */ );
                    this.currentToken = this.scanner.scan();
                    ast.minChar = minChar;
                    break;
                case 31 /* New */ :
                    this.currentToken = this.scanner.scan();
                    var target = this.parseTerm(errorRecoverySet, false, TypeContext.AllSimpleTypes, inCast);
                    if (target.nodeType == 106 /* Error */  || (target.nodeType == 29 /* Index */  && (target).operand1.nodeType == 28 /* TypeRef */ )) {
                        this.reportParseError("Cannot invoke 'new' on this expression");
                    } else {
                        ast = new TypeScript.CallExpression(31 /* New */ , target, null, null);
                        ast.minChar = minChar;
                        limChar = this.currentToken.tokenId == 105 /* EndOfFile */  ? this.scanner.pos : this.scanner.lastTokenLimChar();
                        inNew = true;
                    }
                    break;
                case 41 /* Inline */ :
                    this.currentToken = this.scanner.scan();
                    ast = this.parseTerm(errorRecoverySet, allowCall, typeContext, inCast);
                    if (ast.nodeType != 73 /* FuncDecl */ ) {
                        this.reportParseError("Cannot use 'inline' with non-function expression");
                    }
                    (ast).fncFlags |= 4194304 /* Inline */ ;
                    break;
                case 20 /* Function */ :
                    minChar = this.scanner.pos;
                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, 0 /* None */ , null, true);
                    (ast).fncFlags |= 131072 /* IsFunctionExpression */ ;
                    ast.minChar = minChar;
                    limChar = this.currentToken.tokenId == 105 /* EndOfFile */  ? this.scanner.pos : this.scanner.lastTokenLimChar();
                    ast.limChar = limChar;
                    break;
            }
            if (ast == null) {
                if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                    var idText = this.currentToken.getText();
                    ast = this.createRef(idText, (this.currentToken).hasEscapeSequence, minChar);
                    sawId = true;
                    ast.minChar = minChar;
                    this.currentToken = this.scanner.scan();
                    if (this.currentToken.tokenId == 75 /* Question */ ) {
                        ast.flags |= 256 /* PossibleOptionalParameter */ ;
                    }
                    limChar = this.scanner.lastTokenLimChar();
                }
            }
            if (inCast) {
                this.checkCurrentToken(88 /* GreaterThan */ , errorRecoverySet);
            }
            if (ast == null) {
                switch(this.currentToken.tokenId) {
                    case 56 /* OpenParen */ :
                        minChar = this.scanner.pos;
                        var prevTokId = this.scanner.previousToken().tokenId;
                        this.currentToken = this.scanner.scan();
                        var couldBeLambda = prevTokId == 56 /* OpenParen */  || prevTokId == 62 /* Comma */  || prevTokId == 82 /* EqualsEquals */  || prevTokId == 76 /* Colon */ ;
                        if (couldBeLambda && this.currentToken.tokenId == 57 /* CloseParen */ ) {
                            parseAsLambda = true;
                            expectlambdaRParen = false;
                            this.currentToken = this.scanner.scan();
                        } else if (couldBeLambda && this.currentToken.tokenId == 103 /* DotDotDot */ ) {
                            parseAsLambda = true;
                            expectlambdaRParen = true;
                        } else {
                            ast = this.parseExpr(errorRecoverySet | 64 /* RParen */ , 0 /* None */ , true, 0 /* NoTypes */ , couldBeLambda);
                            limChar = this.scanner.lastTokenLimChar();
                            parseAsLambda = couldBeLambda && (ast.nodeType == 25 /* Name */  || ast.nodeType == 13 /* Comma */ ) && (this.currentToken.tokenId == 76 /* Colon */  || this.currentToken.tokenId == 75 /* Question */ );
                            expectlambdaRParen = true;
                        }
                        if ((ast && !parseAsLambda)) {
                            if (TypeScript.hasFlag(ast.flags, 2048 /* SkipNextRParen */ )) {
                                ast.flags = ast.flags & (~(2048 /* SkipNextRParen */ ));
                                break;
                            }
                            this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet);
                            ast.isParenthesized = true;
                        }
                        break;
                    case 110 /* NumberLiteral */ : {
                        var numTok = this.currentToken;
                        this.currentToken = this.scanner.scan();
                        ast = new TypeScript.NumberLiteral(numTok.value, numTok.text);
                        ast.minChar = minChar;
                        limChar = this.scanner.lastTokenLimChar();
                        break;
                    }
                    case 108 /* StringLiteral */ :
                        ast = new TypeScript.StringLiteral(this.currentToken.getText());
                        this.currentToken = this.scanner.scan();
                        ast.minChar = minChar;
                        limChar = this.scanner.lastTokenLimChar();
                        break;
                    case 109 /* RegularExpressionLiteral */ : {
                        var rtok = this.currentToken;
                        ast = new TypeScript.RegexLiteral(rtok.text);
                        this.currentToken = this.scanner.scan();
                        ast.minChar = minChar;
                        limChar = this.scanner.lastTokenLimChar();
                        break;
                    }
                    case 58 /* OpenBracket */ :
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        ast = this.parseArrayLiteral(16 /* RBrack */  | errorRecoverySet);
                        ast.minChar = minChar;
                        limChar = this.scanner.pos;
                        this.checkCurrentToken(59 /* CloseBracket */ , errorRecoverySet);
                        break;
                    case 60 /* OpenBrace */ :
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var members = this.parseMemberList(32 /* RCurly */  | errorRecoverySet);
                        this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
                        ast = new TypeScript.UnaryExpression(11 /* ObjectLit */ , members);
                        ast.minChar = minChar;
                        limChar = this.scanner.lastTokenLimChar();
                        members.minChar = minChar;
                        members.limChar = limChar;
                        break;
                    case 86 /* LessThan */ :
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var term = this.parseTypeReference(8 /* BinOp */ , false);
                        this.checkCurrentToken(88 /* GreaterThan */ , errorRecoverySet);
                        ast = new TypeScript.UnaryExpression(72 /* TypeAssertion */ , this.parseExpr(errorRecoverySet, 14 /* Unary */ , false, 0 /* NoTypes */ ));
                        (ast).castTerm = term;
                        break;
                    default:
                        if (this.prevExpr && TypeScript.hasFlag(this.prevExpr.flags, 256 /* PossibleOptionalParameter */ )) {
                            parseAsLambda = true;
                            ast = this.prevExpr;
                        } else {
                            this.reportParseError("Check format of expression term");
                            if (this.errorRecovery) {
                                var ident = new TypeScript.MissingIdentifier();
                                ident.minChar = minChar;
                                ident.flags |= 8 /* Error */ ;
                                this.skip(errorRecoverySet | TypeScript.ErrorRecoverySet.Postfix);
                                if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                                    ident.setText(this.currentToken.getText(), (this.currentToken).hasEscapeSequence);
                                    this.currentToken = this.scanner.scan();
                                    limChar = this.scanner.lastTokenLimChar();
                                } else {
                                    limChar = this.scanner.lastTokenLimChar();
                                }
                                ast = ident;
                            }
                        }
                }
            }
            if (parseAsLambda) {
                if (this.currentToken.tokenId == 76 /* Colon */  || this.currentToken.tokenId == 62 /* Comma */  || this.currentToken.tokenId == 57 /* CloseParen */  || this.currentToken.tokenId == 103 /* DotDotDot */ ) {
                    ast = this.parseLambdaExpr(errorRecoverySet, ast, true, expectlambdaRParen);
                    ast.minChar = minChar;
                    limChar = this.scanner.lastTokenLimChar();
                    ast.limChar = limChar;
                } else if (ast) {
                    ast.isParenthesized = true;
                }
            }
            if (sawId && (typeContext != 0 /* NoTypes */ )) {
                typeContext |= 1 /* ArraySuffix */ ;
            }
            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar);
            if (postFix) {
                if (sawId && (postFix.nodeType == 29 /* Index */ )) {
                    var binExpr = postFix;
                    if (binExpr.operand2 == null) {
                        postFix = this.convertToTypeReference(postFix);
                    }
                }
                postFix.minChar = minChar;
                postFix.limChar = TypeScript.max(postFix.limChar, this.scanner.lastTokenLimChar());
                return postFix;
            } else {
                return new TypeScript.AST(106 /* Error */ );
            }
        };
        Parser.prototype.parseLambdaExpr = function (errorRecoverySet, lambdaArgs, skipNextRParen, expectClosingRParen, isInline) {
            if (typeof isInline === "undefined") { isInline = false; }
            var ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, 0 /* None */ , {
                preProcessedLambdaArgs: lambdaArgs
            }, expectClosingRParen, isInline);
            (ast).fncFlags |= 131072 /* IsFunctionExpression */ ;
            (ast).fncFlags |= 32768 /* IsFatArrowFunction */ ;
            if (!skipNextRParen) {
                ast.flags |= 2048 /* SkipNextRParen */ ;
            }
            ast.limChar = this.scanner.lastTokenLimChar();
            ;
            return ast;
        };
        Parser.prototype.parseExpr = function (errorRecoverySet, minPrecedence, allowIn, typeContext, possiblyInLambda) {
            if (typeof possiblyInLambda === "undefined") { possiblyInLambda = false; }
            var ast = null;
            var tokenInfo = TypeScript.lookupToken(this.currentToken.tokenId);
            var canAssign = true;
            var idHint = null;
            var minChar = this.scanner.startPos;
            var preComments = this.parseComments();
            var exprIsAnonLambda = false;
            if ((tokenInfo != undefined) && (tokenInfo.unopNodeType != 0 /* None */ )) {
                canAssign = false;
                this.currentToken = this.scanner.scan();
                var tempExpr = this.parseExpr(8 /* BinOp */  | errorRecoverySet, tokenInfo.unopPrecedence, allowIn, 0 /* NoTypes */ );
                ast = new TypeScript.UnaryExpression(tokenInfo.unopNodeType, tempExpr);
                ast.limChar = tempExpr.limChar;
                ast.minChar = minChar;
            } else {
                ast = this.parseTerm(8 /* BinOp */  | 1024 /* AddOp */  | errorRecoverySet, true, typeContext, false);
                var id;
                var temp;
                if (ast.nodeType == 25 /* Name */ ) {
                    id = ast;
                    idHint = id.actualText;
                } else if (ast.nodeType == 19 /* Dot */ ) {
                    var subsumedExpr = false;
                    if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId == 76 /* Colon */  || this.currentToken.tokenId == 63 /* Equals */ ) && this.parsingClassConstructorDefinition && this.nestingLevel == this.currentClassDefinition.constructorNestingLevel && (ast).operand1.nodeType == 5 /* This */ ) {
                        if ((ast).operand2.nodeType == 25 /* Name */ ) {
                            var op2ID = ((ast).operand2);
                            if (!this.currentClassDefinition.knownMemberNames[op2ID.actualText]) {
                                ast = this.parseClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, 2 /* Public */ );
                                subsumedExpr = true;
                            }
                        }
                    }
                    if (!subsumedExpr) {
                        temp = ast;
                        while(temp.nodeType == 19 /* Dot */ ) {
                            var binExpr = temp;
                            temp = binExpr.operand2;
                        }
                        if (temp.nodeType == 25 /* Name */ ) {
                            id = temp;
                            idHint = id.actualText;
                        }
                    }
                }
                if ((!this.scanner.lastTokenHadNewline()) && ((this.currentToken.tokenId == 100 /* PlusPlus */ ) || (this.currentToken.tokenId == 101 /* MinusMinus */ ))) {
                    canAssign = false;
                    var operand = ast;
                    ast = new TypeScript.UnaryExpression((this.currentToken.tokenId == 100 /* PlusPlus */ ) ? 70 /* IncPost */  : 71 /* DecPost */ , operand);
                    ast.limChar = this.scanner.pos;
                    ast.minChar = operand.minChar;
                    this.currentToken = this.scanner.scan();
                }
            }
            for(; ; ) {
                tokenInfo = TypeScript.lookupToken(this.currentToken.tokenId);
                if ((tokenInfo == undefined) || (tokenInfo.binopNodeType == 0 /* None */ )) {
                    break;
                }
                if ((!allowIn) && (tokenInfo.binopNodeType == 18 /* In */ )) {
                    break;
                }
                if (tokenInfo.binopPrecedence == 2 /* Assignment */ ) {
                    if (tokenInfo.binopPrecedence < minPrecedence) {
                        break;
                    }
                    if (!canAssign) {
                        this.reportParseError("illegal assignment");
                    }
                } else if (tokenInfo.binopPrecedence <= minPrecedence) {
                    break;
                }
                if (possiblyInLambda && this.currentToken.tokenId == 62 /* Comma */  && this.scanner.getLookAheadToken().tokenId == 103 /* DotDotDot */ ) {
                    exprIsAnonLambda = true;
                    canAssign = false;
                    ast = this.parseLambdaExpr(errorRecoverySet, ast, false, true);
                    break;
                }
                this.currentToken = this.scanner.scan();
                canAssign = false;
                if (tokenInfo.binopNodeType == 44 /* ConditionalExpression */ ) {
                    if (possiblyInLambda && (this.currentToken.tokenId == 63 /* Equals */  || this.currentToken.tokenId == 76 /* Colon */  || this.currentToken.tokenId == 57 /* CloseParen */  || this.currentToken.tokenId == 62 /* Comma */ )) {
                        exprIsAnonLambda = true;
                        canAssign = true;
                    } else {
                        this.prevExpr = ast;
                        var whenTrue = this.parseExpr(errorRecoverySet | 256 /* Colon */ , 2 /* Assignment */ , allowIn, 0 /* NoTypes */ );
                        this.prevExpr = null;
                        this.checkCurrentToken(76 /* Colon */ , errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);
                        var whenFalse = this.parseExpr(errorRecoverySet | 8 /* BinOp */ , 2 /* Assignment */ , allowIn, 0 /* NoTypes */ );
                        ast = new TypeScript.ConditionalExpression(ast, whenTrue, whenFalse);
                    }
                } else {
                    var tc = 0 /* NoTypes */ ;
                    var binExpr2;
                    binExpr2 = new TypeScript.BinaryExpression(tokenInfo.binopNodeType, ast, this.parseExpr(errorRecoverySet | 8 /* BinOp */ , tokenInfo.binopPrecedence, allowIn, 0 /* NoTypes */ , possiblyInLambda));
                    if (binExpr2.operand2.nodeType == 73 /* FuncDecl */ ) {
                        var funcDecl = binExpr2.operand2;
                        funcDecl.hint = idHint;
                    }
                    binExpr2.minChar = ast.minChar;
                    binExpr2.limChar = this.scanner.lastTokenLimChar();
                    idHint = null;
                    ast = binExpr2;
                }
            }
            if (canAssign) {
                ast.flags |= 4 /* Writeable */ ;
            }
            if (!exprIsAnonLambda) {
                ast.minChar = minChar;
                ast.limChar = TypeScript.max(ast.limChar, this.scanner.lastTokenLimChar());
                if (preComments) {
                    ast.preComments = ast.preComments ? preComments.concat(ast.preComments) : preComments;
                }
                ast.postComments = this.parseCommentsForLine(this.scanner.line);
            }
            return ast;
        };
        Parser.prototype.parsePostfixOperators = function (errorRecoverySet, ast, allowCall, inNew, typeContext, lhsMinChar, lhsLimChar) {
            var count = 0;
            if (!ast) {
                ast = new TypeScript.AST(2 /* EmptyExpr */ );
                ast.isParenthesized = true;
            }
            ast.minChar = lhsMinChar;
            ast.limChar = lhsLimChar;
            for(; ; ) {
                switch(this.currentToken.tokenId) {
                    case 56 /* OpenParen */ :
                        if (inNew) {
                            var callExpr = ast;
                            callExpr.arguments = this.parseArgList(errorRecoverySet);
                            inNew = false;
                        } else {
                            if (!allowCall) {
                                return ast;
                            }
                            ast = new TypeScript.CallExpression(30 /* Call */ , ast, null, this.parseArgList(errorRecoverySet));
                            ast.minChar = lhsMinChar;
                        }
                        ast.limChar = this.scanner.pos;
                        this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet);
                        break;
                    case 58 /* OpenBracket */ :
                        this.currentToken = this.scanner.scan();
                        if (this.currentToken.tokenId == 59 /* CloseBracket */ ) {
                            if (TypeScript.hasFlag(typeContext, 1 /* ArraySuffix */ )) {
                                this.currentToken = this.scanner.scan();
                                if (ast.nodeType == 28 /* TypeRef */ ) {
                                    var typeRef = ast;
                                    typeRef.arrayCount++;
                                } else {
                                    ast = new TypeScript.BinaryExpression(29 /* Index */ , ast, null);
                                }
                                ast.limChar = this.scanner.pos;
                                break;
                            }
                        }
                        ast = new TypeScript.BinaryExpression(29 /* Index */ , ast, this.parseExpr(errorRecoverySet | 16 /* RBrack */ , 0 /* None */ , true, 0 /* NoTypes */ ));
                        ast.minChar = lhsMinChar;
                        ast.limChar = this.scanner.pos;
                        this.checkCurrentToken(59 /* CloseBracket */ , errorRecoverySet);
                        break;
                    case 102 /* Dot */ : {
                        var name = null;
                        var curpos = this.scanner.pos;
                        this.currentToken = this.scanner.scan();
                        if ((this.currentToken.tokenId == 107 /* Identifier */ ) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && TypeScript.convertTokToIDName(this.currentToken))) {
                            ast.flags |= 32 /* DotLHS */ ;
                            name = this.createRef(this.currentToken.getText(), (this.currentToken).hasEscapeSequence, this.scanner.startPos);
                            name.limChar = this.scanner.pos;
                            this.currentToken = this.scanner.scan();
                        } else {
                            this.reportParseError("Expected identifier following dot");
                            if (this.errorRecovery) {
                                this.skip(errorRecoverySet);
                                ast.flags |= (8 /* Error */  | 32 /* DotLHS */ );
                                return ast;
                            } else {
                                name = new TypeScript.MissingIdentifier();
                            }
                        }
                        ast = new TypeScript.BinaryExpression(19 /* Dot */ , ast, name);
                        ast.minChar = lhsMinChar;
                        ast.limChar = this.scanner.lastTokenLimChar();
                        break;
                    }
                    case 106 /* EqualsGreaterThan */ :
                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, 0 /* None */ , {
                            preProcessedLambdaArgs: ast
                        }, false, true);
                        (ast).fncFlags |= 131072 /* IsFunctionExpression */ ;
                        ast.minChar = lhsMinChar;
                        ast.limChar = this.scanner.lastTokenLimChar();
                        break;
                    default:
                        return ast;
                }
            }
        };
        Parser.prototype.parseTry = function (tryNode, errorRecoverySet, parentModifiers) {
            var minChar = this.scanner.startPos;
            var preComments = this.parseComments();
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId != 60 /* OpenBrace */ ) {
                this.reportParseError("Expected '{'");
                if (this.errorRecovery) {
                    var etryNode = tryNode;
                    etryNode.minChar = minChar;
                    etryNode.limChar = this.scanner.lastTokenLimChar();
                    etryNode.flags |= 8 /* Error */ ;
                    return etryNode;
                }
            }
            tryNode.body = this.parseStatement(errorRecoverySet, 0 /* None */ , parentModifiers);
            tryNode.minChar = minChar;
            tryNode.limChar = tryNode.body.limChar;
            tryNode.preComments = preComments;
            tryNode.postComments = this.parseComments();
            return tryNode;
        };
        Parser.prototype.parseCatch = function (errorRecoverySet, parentModifiers) {
            var catchMinChar = this.scanner.startPos;
            var preComments = this.parseComments();
            this.currentToken = this.scanner.scan();
            this.checkCurrentToken(56 /* OpenParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);
            if ((this.currentToken.tokenId != 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                this.reportParseError("Expected identifier in catch header");
                if (this.errorRecovery) {
                    this.skip(errorRecoverySet);
                    var ecatch = new TypeScript.Catch(new TypeScript.VarDecl(new TypeScript.MissingIdentifier(), this.nestingLevel), new TypeScript.Statement(1 /* Empty */ ));
                    ecatch.statement.minChar = catchMinChar;
                    ecatch.statement.limChar = this.scanner.pos;
                    ecatch.minChar = this.scanner.startPos;
                    ecatch.limChar = this.scanner.pos;
                    ecatch.flags |= 8 /* Error */ ;
                    return ecatch;
                }
            }
            var param = new TypeScript.VarDecl(TypeScript.Identifier.fromToken(this.currentToken), this.nestingLevel);
            param.id.minChar = this.scanner.startPos;
            param.id.limChar = this.scanner.pos;
            param.minChar = param.id.minChar;
            param.limChar = param.id.limChar;
            this.currentToken = this.scanner.scan();
            var statementPos = this.scanner.pos;
            this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);
            if (this.currentToken.tokenId != 60 /* OpenBrace */ ) {
                this.reportParseError("Expected '{' to start catch body");
                if (this.errorRecovery) {
                    this.skip(errorRecoverySet);
                    var ecatch = new TypeScript.Catch(new TypeScript.VarDecl(new TypeScript.MissingIdentifier(), this.nestingLevel), new TypeScript.Statement(1 /* Empty */ ));
                    ecatch.statement.minChar = catchMinChar;
                    ecatch.statement.limChar = statementPos;
                    ecatch.minChar = this.scanner.startPos;
                    ecatch.limChar = this.scanner.pos;
                    ecatch.flags |= 8 /* Error */ ;
                    return ecatch;
                }
            }
            var catchStmt = this.parseStatement(errorRecoverySet, 0 /* None */ , parentModifiers);
            var catchNode = new TypeScript.Catch(param, catchStmt);
            catchNode.statement.minChar = catchMinChar;
            catchNode.statement.limChar = statementPos;
            catchNode.minChar = catchMinChar;
            catchNode.limChar = catchStmt.limChar;
            catchNode.preComments = preComments;
            catchNode.postComments = this.parseComments();
            return catchNode;
        };
        Parser.prototype.parseFinally = function (errorRecoverySet, parentModifiers) {
            var finMinChar = this.scanner.startPos;
            var preComments = this.parseComments();
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId != 60 /* OpenBrace */ ) {
                this.reportParseError("Expected '{' to start body of finally statement");
                if (this.errorRecovery) {
                    this.skip(errorRecoverySet);
                    var efin = new TypeScript.Finally(new TypeScript.Statement(1 /* Empty */ ));
                    efin.flags |= 8 /* Error */ ;
                    efin.minChar = this.scanner.startPos;
                    efin.limChar = this.scanner.pos;
                    return efin;
                }
            }
            var finBody = this.parseStatement(errorRecoverySet, 0 /* None */ , parentModifiers);
            var fin = new TypeScript.Finally(finBody);
            fin.minChar = finMinChar;
            fin.limChar = fin.body.limChar;
            fin.preComments = preComments;
            fin.postComments = this.parseComments();
            return fin;
        };
        Parser.prototype.parseTryCatchFinally = function (errorRecoverySet, parentModifiers, labelList) {
            var tryPart = new TypeScript.Try(null);
            var tryMinChar = this.scanner.startPos;
            this.pushStmt(tryPart, labelList);
            this.parseTry(tryPart, errorRecoverySet | 1048576 /* Catch */ , parentModifiers);
            this.popStmt();
            var tc = null;
            var tf = null;
            if (this.currentToken.tokenId == 4 /* Catch */ ) {
                var catchPart = this.parseCatch(errorRecoverySet | 1048576 /* Catch */ , parentModifiers);
                tc = new TypeScript.TryCatch(tryPart, catchPart);
                tc.minChar = tryPart.minChar;
                tc.limChar = catchPart.limChar;
            }
            if (this.currentToken.tokenId != 18 /* Finally */ ) {
                if (tc == null) {
                    this.reportParseError("try with neither catch nor finally");
                    if (this.errorRecovery) {
                        var etf = new TypeScript.TryFinally(tryPart, new TypeScript.Finally(new TypeScript.AST(1 /* Empty */ )));
                        etf.flags |= 8 /* Error */ ;
                        etf.minChar = this.scanner.startPos;
                        etf.limChar = this.scanner.pos;
                        return etf;
                    }
                    return new TypeScript.TryFinally(tryPart, new TypeScript.Finally(new TypeScript.AST(1 /* Empty */ )));
                } else {
                    return tc;
                }
            } else {
                if (tc) {
                    tryPart = tc;
                }
                var finallyPart = this.parseFinally(errorRecoverySet, parentModifiers);
                tf = new TypeScript.TryFinally(tryPart, finallyPart);
                tf.minChar = tryMinChar;
                tf.limChar = finallyPart.limChar;
                return tf;
            }
        };
        Parser.prototype.parseStatement = function (errorRecoverySet, allowedElements, parentModifiers) {
            var ast = null;
            var labelList = null;
            var astList = null;
            var temp;
            var modifiers = 0 /* None */ ;
            var minChar = this.scanner.startPos;
            var forInOk = false;
            var needTerminator = false;
            var fnOrVar = null;
            var preComments = this.parseComments();
            function isAmbient() {
                return TypeScript.hasFlag(modifiers, 8 /* Ambient */ ) || TypeScript.hasFlag(parentModifiers, 8 /* Ambient */ );
            }
            function mayNotBeExported() {
                if (TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                    this.reportError("Statement may not be exported");
                }
            }
            for(; ; ) {
                switch(this.currentToken.tokenId) {
                    case 105 /* EndOfFile */ :
                        ast = new TypeScript.AST(106 /* Error */ );
                        ast.minChar = minChar;
                        ast.limChar = this.scanner.pos;
                        break;
                    case 20 /* Function */ :
                        if (this.parsingDeclareFile || isAmbient() || this.ambientModule) {
                            this.currentToken = this.scanner.scan();
                            fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | 2 /* SColon */ , modifiers, true, false, true);
                            if (fnOrVar.nodeType == 75 /* VarDecl */ ) {
                                this.reportParseError("function keyword can only introduce function declaration");
                            } else if ((fnOrVar.nodeType == 73 /* FuncDecl */ ) && ((fnOrVar).fncFlags, 32768 /* IsFatArrowFunction */ )) {
                                needTerminator = true;
                            }
                            ast = fnOrVar;
                            if (TypeScript.hasFlag(modifiers, 16 /* Exported */ ) || this.parsingDeclareFile || this.ambientModule && ast.nodeType == 73 /* FuncDecl */ ) {
                                (ast).fncFlags |= 1 /* Exported */ ;
                            }
                        } else {
                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, false, modifiers, null, true, TypeScript.hasFlag(modifiers, 256 /* Inline */ ));
                            if (TypeScript.hasFlag((ast).fncFlags, 32768 /* IsFatArrowFunction */ )) {
                                needTerminator = true;
                            }
                            if (this.ambientModule) {
                                this.reportParseError("function declaration not permitted within ambient module");
                            }
                            if (TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                                (ast).fncFlags |= 1 /* Exported */ ;
                            }
                        }
                        break;
                    case 30 /* Module */ :
                        if ((allowedElements & 4 /* ModuleDeclarations */ ) == 0 /* None */ ) {
                            this.reportParseError("module not allowed in this context");
                            this.currentToken = this.scanner.scan();
                            ast = new TypeScript.AST(106 /* Error */ );
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        } else {
                            ast = this.parseModuleDecl(errorRecoverySet, modifiers, preComments);
                            preComments = null;
                        }
                        break;
                    case 25 /* Import */ :
                        if ((allowedElements & 4 /* ModuleDeclarations */ ) == 0 /* None */ ) {
                            this.reportParseError("module not allowed in this context");
                            this.currentToken = this.scanner.scan();
                            ast = new TypeScript.AST(106 /* Error */ );
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        } else {
                            if (TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                                this.reportParseError("export keyword not permitted on import declaration");
                            }
                            ast = this.parseImportDeclaration(errorRecoverySet, modifiers);
                            needTerminator = true;
                        }
                        break;
                    case 14 /* Export */ :
                        if ((allowedElements & 4 /* ModuleDeclarations */ ) == 0 /* None */ ) {
                            this.reportParseError("'export' statements are only allowed at the global and module levels");
                            this.currentToken = this.scanner.scan();
                            ast = new TypeScript.AST(106 /* Error */ );
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        }
                        if (this.topLevel) {
                            this.hasTopLevelImportOrExport = true;
                        }
                        modifiers |= 16 /* Exported */ ;
                        this.currentToken = this.scanner.scan();
                        break;
                    case 35 /* Private */ :
                        modifiers |= 1 /* Private */ ;
                        this.currentToken = this.scanner.scan();
                        if (this.parsingClassConstructorDefinition) {
                            if (!this.inferPropertiesFromThisAssignment) {
                                this.reportParseError("Property declarations are not permitted within constructor bodies");
                            }
                            minChar = this.scanner.pos;
                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != 45 /* This */  || (this.currentToken = this.scanner.scan()).tokenId != 102 /* Dot */ )) {
                                this.reportParseError("Expected 'this.' for property declaration");
                                this.currentToken = this.scanner.scan();
                                ast = new TypeScript.AST(106 /* Error */ );
                                ast.minChar = minChar;
                                ast.limChar = this.scanner.lastTokenLimChar();
                            } else {
                                this.currentToken = this.scanner.scan();
                                var id = TypeScript.Identifier.fromToken(this.currentToken);
                                id.minChar = this.scanner.startPos;
                                id.limChar = this.scanner.pos;
                                this.currentToken = this.scanner.scan();
                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);
                            }
                        } else {
                            if (this.currentToken.tokenId != 28 /* Interface */ ) {
                                if (this.currentToken.tokenId == 22 /* Get */ ) {
                                    this.prevIDTok = this.currentToken;
                                    this.currentToken = this.scanner.scan();
                                    if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                                    }
                                    if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                                        modifiers |= 32 /* Getter */ ;
                                        this.prevIDTok = null;
                                    }
                                } else if (this.currentToken.tokenId == 39 /* Set */ ) {
                                    this.prevIDTok = this.currentToken;
                                    this.currentToken = this.scanner.scan();
                                    if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                                    }
                                    if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                                        modifiers |= 64 /* Setter */ ;
                                        this.prevIDTok = null;
                                    }
                                }
                                fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | 2 /* SColon */ , modifiers, isAmbient(), false);
                                if ((fnOrVar.nodeType == 75 /* VarDecl */ ) || ((fnOrVar.nodeType == 73 /* FuncDecl */ ) && (TypeScript.hasFlag((fnOrVar).fncFlags, 32768 /* IsFatArrowFunction */ )))) {
                                    needTerminator = true;
                                }
                                ast = fnOrVar;
                            }
                        }
                        break;
                    case 37 /* Public */ :
                        if (this.parsingClassConstructorDefinition) {
                            if (!this.inferPropertiesFromThisAssignment) {
                                this.reportParseError("Property declarations are not permitted within constructor bodies");
                            }
                            this.currentToken = this.scanner.scan();
                            minChar = this.scanner.pos;
                            modifiers |= 2 /* Public */ ;
                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != 45 /* This */  || (this.currentToken = this.scanner.scan()).tokenId != 102 /* Dot */ )) {
                                this.reportParseError("Expected 'this.' for property declaration");
                                this.currentToken = this.scanner.scan();
                                ast = new TypeScript.AST(106 /* Error */ );
                                ast.minChar = minChar;
                                ast.limChar = this.scanner.lastTokenLimChar();
                            } else {
                                this.currentToken = this.scanner.scan();
                                var id = TypeScript.Identifier.fromToken(this.currentToken);
                                id.minChar = this.scanner.startPos;
                                id.limChar = this.scanner.pos;
                                this.currentToken = this.scanner.scan();
                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);
                            }
                        } else {
                            if ((allowedElements & 2048 /* Properties */ ) == 0 /* None */ ) {
                                this.reportParseError("'property' statements are only allowed within classes");
                                this.currentToken = this.scanner.scan();
                                ast = new TypeScript.AST(106 /* Error */ );
                                ast.minChar = minChar;
                                ast.limChar = this.scanner.lastTokenLimChar();
                            } else {
                                modifiers |= 2 /* Public */ ;
                                this.currentToken = this.scanner.scan();
                                if (this.currentToken.tokenId == 22 /* Get */ ) {
                                    this.prevIDTok = this.currentToken;
                                    this.currentToken = this.scanner.scan();
                                    if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                                    }
                                    if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                                        modifiers |= 32 /* Getter */ ;
                                        this.prevIDTok = null;
                                    }
                                } else if (this.currentToken.tokenId == 39 /* Set */ ) {
                                    this.prevIDTok = this.currentToken;
                                    this.currentToken = this.scanner.scan();
                                    if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                                    }
                                    if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                                        modifiers |= 64 /* Setter */ ;
                                        this.prevIDTok = null;
                                    }
                                }
                                fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | 2 /* SColon */ , modifiers, isAmbient(), false);
                                if ((fnOrVar.nodeType == 75 /* VarDecl */ ) || ((fnOrVar.nodeType == 73 /* FuncDecl */ ) && TypeScript.hasFlag((fnOrVar).fncFlags, 32768 /* IsFatArrowFunction */ ))) {
                                    needTerminator = true;
                                }
                                ast = fnOrVar;
                            }
                        }
                        break;
                    case 16 /* Declare */ :
                        if (!(allowedElements & 1024 /* AmbientDeclarations */ )) {
                            this.reportParseError("Ambient declarations are only allowed at the top-level or module scopes");
                        }
                        if (!this.parsingDeclareFile && TypeScript.hasFlag(parentModifiers, 8 /* Ambient */ )) {
                            this.reportParseError("Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)");
                        }
                        modifiers |= 8 /* Ambient */ ;
                        this.currentToken = this.scanner.scan();
                        break;
                    case 5 /* Class */ :
                        if ((allowedElements & 8 /* ClassDeclarations */ ) == 0 /* None */ ) {
                            this.reportParseError("class not allowed in this context");
                            this.currentToken = this.scanner.scan();
                            ast = new TypeScript.AST(106 /* Error */ );
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        } else {
                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers);
                        }
                        break;
                    case 28 /* Interface */ :
                        if ((allowedElements & 16 /* InterfaceDeclarations */ ) == 0 /* None */ ) {
                            this.reportParseError("interface not allowed in this context");
                            this.currentToken = this.scanner.scan();
                            ast = new TypeScript.AST(106 /* Error */ );
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        } else {
                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers);
                        }
                        break;
                    case 50 /* Var */ :
                        var declAst = this.parseVariableDeclaration(errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart, modifiers, true, false);
                        if (declAst.nodeType == 75 /* VarDecl */ ) {
                            ast = declAst;
                        } else {
                            ast = new TypeScript.Block(declAst, false);
                        }
                        needTerminator = true;
                        break;
                    case 41 /* Inline */ :
                        modifiers |= 256 /* Inline */ ;
                        this.currentToken = this.scanner.scan();
                        break;
                    case 40 /* Static */ :
                        if (this.currentClassDecl == null) {
                            this.reportParseError("Statics may only be class members");
                        }
                        mayNotBeExported();
                        modifiers |= 2 /* Public */ ;
                        this.currentToken = this.scanner.scan();
                        if (this.currentToken.tokenId == 22 /* Get */ ) {
                            this.prevIDTok = this.currentToken;
                            this.currentToken = this.scanner.scan();
                            if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                            }
                            if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                                modifiers |= 32 /* Getter */ ;
                                this.prevIDTok = null;
                            }
                        } else if (this.currentToken.tokenId == 39 /* Set */ ) {
                            this.currentToken = this.scanner.scan();
                            if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                            }
                            if ((this.currentToken.tokenId == 107 /* Identifier */ ) || TypeScript.convertTokToID(this.currentToken, this.strictMode)) {
                                modifiers |= 64 /* Setter */ ;
                            }
                        }
                        if (isAmbient()) {
                            modifiers |= 8 /* Ambient */ ;
                        }
                        fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | 2 /* SColon */ , modifiers, this.parsingDeclareFile || (modifiers & 8 /* Ambient */ ) != 0 /* None */ , true);
                        var staticsList = this.topStaticsList();
                        if (staticsList && fnOrVar.nodeType == 75 /* VarDecl */ ) {
                            staticsList.append(fnOrVar);
                        }
                        if (fnOrVar.nodeType == 75 /* VarDecl */  || ((fnOrVar.nodeType == 73 /* FuncDecl */ ) && TypeScript.hasFlag((fnOrVar).fncFlags, 32768 /* IsFatArrowFunction */ ))) {
                            needTerminator = true;
                        }
                        ast = fnOrVar;
                        break;
                    case 19 /* For */ :
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("syntax error: for statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.checkNextToken(56 /* OpenParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart | 2097152 /* Var */ );
                        forInOk = true;
                        switch(this.currentToken.tokenId) {
                            case 50 /* Var */ :
                                temp = this.parseVariableDeclaration(errorRecoverySet | 2 /* SColon */  | 131072 /* In */ , 0 /* None */ , false, false);
                                break;
                            case 55 /* Semicolon */ :
                                temp = null;
                                break;
                            default:
                                temp = this.parseExpr(errorRecoverySet | 2 /* SColon */  | 131072 /* In */ , 0 /* None */ , false, 0 /* NoTypes */ );
                                break;
                        }
                        if (this.currentToken.tokenId == 26 /* In */ ) {
                            if ((temp == null) || (!forInOk)) {
                                this.reportParseError("malformed for statement");
                                if (this.errorRecovery) {
                                    this.skip(errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);
                                    ast = new TypeScript.AST(1 /* Empty */ );
                                    ast.flags |= 8 /* Error */ ;
                                }
                            } else {
                                this.currentToken = this.scanner.scan();
                                var forInStmt = new TypeScript.ForInStatement(temp, this.parseExpr(64 /* RParen */  | errorRecoverySet, 1 /* Comma */ , false, 0 /* NoTypes */ ));
                                forInStmt.limChar = this.scanner.pos;
                                forInStmt.statement.minChar = minChar;
                                forInStmt.statement.limChar = this.scanner.pos;
                                this.checkCurrentToken(57 /* CloseParen */ , TypeScript.ErrorRecoverySet.StmtStart | errorRecoverySet);
                                this.pushStmt(forInStmt, labelList);
                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                                this.popStmt();
                                forInStmt.minChar = minChar;
                                ast = forInStmt;
                            }
                        } else {
                            var forStmt = new TypeScript.ForStatement(temp);
                            forStmt.minChar = minChar;
                            this.checkCurrentToken(55 /* Semicolon */ , errorRecoverySet);
                            if (this.currentToken.tokenId == 55 /* Semicolon */ ) {
                                forStmt.cond = null;
                            } else {
                                forStmt.cond = this.parseExpr(errorRecoverySet | 2 /* SColon */  | 64 /* RParen */ , 0 /* None */ , true, 0 /* NoTypes */ );
                                if (this.currentToken.tokenId != 55 /* Semicolon */ ) {
                                    this.skip(errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);
                                    ast = forStmt;
                                    ast.flags |= 8 /* Error */ ;
                                }
                            }
                            this.currentToken = this.scanner.scan();
                            if (this.currentToken.tokenId == 57 /* CloseParen */ ) {
                                forStmt.incr = null;
                            } else {
                                forStmt.incr = this.parseExpr(errorRecoverySet | 2 /* SColon */  | 64 /* RParen */ , 0 /* None */ , true, 0 /* NoTypes */ );
                            }
                            this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet | 2048 /* LCurly */ );
                            this.pushStmt(forStmt, labelList);
                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                            this.popStmt();
                            forStmt.limChar = forStmt.body.limChar;
                            ast = forStmt;
                        }
                        break;
                    case 52 /* With */ :
 {
                            if (TypeScript.codeGenTarget < 1 /* ES5 */ ) {
                                this.reportParseError("'with' statements are only available in ES5 codegen mode or better");
                            }
                            if (this.strictMode) {
                                this.reportParseError("'with' statements are not available in strict mode");
                            }
                            mayNotBeExported();
                            if (modifiers != 0 /* None */ ) {
                                this.reportParseError("'with' statement does not take modifiers");
                            }
                            minChar = this.scanner.startPos;
                            this.checkNextToken(56 /* OpenParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart | 2097152 /* Var */ );
                            var expr = this.parseExpr(errorRecoverySet | 256 /* Colon */ , 0 /* None */ , true, 0 /* NoTypes */ );
                            this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet | 2048 /* LCurly */ );
                            var withStmt = new TypeScript.WithStatement(expr);
                            withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                            withStmt.minChar = minChar;
                            withStmt.limChar = withStmt.body.limChar;
                            ast = withStmt;
                        }
                        break;
                    case 44 /* Switch */ : {
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("'switch' statement does not take modifiers");
                        }
                        this.checkNextToken(56 /* OpenParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);
                        var switchStmt = new TypeScript.SwitchStatement(this.parseExpr(errorRecoverySet | 64 /* RParen */ , 0 /* None */ , true, 0 /* NoTypes */ ));
                        switchStmt.statement.minChar = minChar;
                        switchStmt.statement.limChar = this.scanner.pos;
                        this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet | 2048 /* LCurly */ );
                        var caseListMinChar = this.scanner.startPos;
                        this.checkCurrentToken(60 /* OpenBrace */ , errorRecoverySet | 262144 /* SCase */ );
                        switchStmt.defaultCase = null;
                        switchStmt.caseList = new TypeScript.ASTList();
                        var caseStmt = null;
                        this.pushStmt(switchStmt, labelList);
                        for(; ; ) {
                            if ((this.currentToken.tokenId == 3 /* Case */ ) || (this.currentToken.tokenId == 9 /* Default */ )) {
                                var isDefault = (this.currentToken.tokenId == 9 /* Default */ );
                                caseStmt = new TypeScript.CaseStatement();
                                caseStmt.minChar = this.scanner.startPos;
                                this.currentToken = this.scanner.scan();
                                if (isDefault) {
                                    switchStmt.defaultCase = caseStmt;
                                } else {
                                    caseStmt.expr = this.parseExpr(errorRecoverySet | 256 /* Colon */ , 0 /* None */ , true, 0 /* NoTypes */ );
                                }
                                caseStmt.colonSpan.minChar = this.scanner.startPos;
                                caseStmt.colonSpan.limChar = this.scanner.pos;
                                this.checkCurrentToken(76 /* Colon */ , errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);
                                caseStmt.body = new TypeScript.ASTList();
                                this.parseStatementList(errorRecoverySet | 32 /* RCurly */ , caseStmt.body, false, true, allowedElements, modifiers);
                                caseStmt.limChar = caseStmt.body.limChar;
                                switchStmt.caseList.append(caseStmt);
                            } else {
                                break;
                            }
                        }
                        switchStmt.caseList.minChar = caseListMinChar;
                        switchStmt.caseList.limChar = this.scanner.pos;
                        switchStmt.limChar = switchStmt.caseList.limChar;
                        this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
                        this.popStmt();
                        ast = switchStmt;
                        break;
                    }
                    case 53 /* While */ : {
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("'while' statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.checkNextToken(56 /* OpenParen */ , TypeScript.ErrorRecoverySet.ExprStart | errorRecoverySet);
                        var whileStmt = new TypeScript.WhileStatement(this.parseExpr(errorRecoverySet | 64 /* RParen */ , 0 /* None */ , true, 0 /* NoTypes */ ));
                        whileStmt.minChar = minChar;
                        this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);
                        this.pushStmt(whileStmt, labelList);
                        whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                        whileStmt.limChar = whileStmt.body.limChar;
                        this.popStmt();
                        ast = whileStmt;
                        break;
                    }
                    case 11 /* Do */ : {
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("'do' statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var doStmt = new TypeScript.DoWhileStatement();
                        doStmt.minChar = minChar;
                        this.pushStmt(doStmt, labelList);
                        doStmt.body = this.parseStatement(errorRecoverySet | 8388608 /* While */ , allowedElements, parentModifiers);
                        this.popStmt();
                        doStmt.whileAST = new TypeScript.Identifier("while");
                        doStmt.whileAST.minChar = this.scanner.startPos;
                        this.checkCurrentToken(53 /* While */ , errorRecoverySet | 16384 /* LParen */ );
                        doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;
                        this.checkCurrentToken(56 /* OpenParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);
                        doStmt.cond = this.parseExpr(errorRecoverySet | 64 /* RParen */ , 0 /* None */ , true, 0 /* NoTypes */ );
                        doStmt.limChar = this.scanner.pos;
                        this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet);
                        ast = doStmt;
                        if (this.currentToken.tokenId == 55 /* Semicolon */ ) {
                            this.currentToken = this.scanner.scan();
                        }
                        break;
                    }
                    case 23 /* If */ : {
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("if statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.checkNextToken(56 /* OpenParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.ExprStart);
                        var ifStmt = new TypeScript.IfStatement(this.parseExpr(errorRecoverySet | 16384 /* LParen */ , 0 /* None */ , true, 0 /* NoTypes */ ));
                        ifStmt.minChar = minChar;
                        ifStmt.statement.minChar = minChar;
                        ifStmt.statement.limChar = this.scanner.pos;
                        this.checkCurrentToken(57 /* CloseParen */ , errorRecoverySet | TypeScript.ErrorRecoverySet.StmtStart);
                        this.pushStmt(ifStmt, labelList);
                        ifStmt.thenBod = this.parseStatement(524288 /* Else */  | errorRecoverySet, allowedElements, parentModifiers);
                        ifStmt.limChar = ifStmt.thenBod.limChar;
                        if (this.currentToken.tokenId == 12 /* Else */ ) {
                            this.currentToken = this.scanner.scan();
                            ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                            ifStmt.limChar = ifStmt.elseBod.limChar;
                        }
                        this.popStmt();
                        ast = ifStmt;
                        break;
                    }
                    case 48 /* Try */ : {
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("try statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        ast = this.parseTryCatchFinally(errorRecoverySet, parentModifiers, labelList);
                        break;
                    }
                    case 60 /* OpenBrace */ : {
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("block does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var block = new TypeScript.Block(new TypeScript.ASTList(), true);
                        this.pushStmt(block, labelList);
                        this.parseStatementList(errorRecoverySet | 32 /* RCurly */ , block.statements, false, false, 0 /* None */ , modifiers);
                        this.popStmt();
                        block.statements.minChar = minChar;
                        block.statements.limChar = this.scanner.pos;
                        block.minChar = block.statements.minChar;
                        block.limChar = block.statements.limChar;
                        this.checkCurrentToken(61 /* CloseBrace */ , errorRecoverySet);
                        ast = block;
                        break;
                    }
                    case 55 /* Semicolon */ :
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("modifier can not appear here");
                        }
                        ast = new TypeScript.AST(1 /* Empty */ );
                        this.currentToken = this.scanner.scan();
                        break;
                    case 2 /* Break */ :
                    case 7 /* Continue */ : {
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("modifiers can not appear before jump statement");
                        }
                        var jump = new TypeScript.Jump((this.currentToken.tokenId == 2 /* Break */ ) ? 78 /* Break */  : 79 /* Continue */ );
                        this.currentToken = this.scanner.scan();
                        if ((this.currentToken.tokenId == 107 /* Identifier */ ) && (!this.scanner.lastTokenHadNewline())) {
                            jump.target = this.currentToken.getText();
                            this.currentToken = this.scanner.scan();
                        }
                        this.resolveJumpTarget(jump);
                        ast = jump;
                        needTerminator = true;
                        break;
                    }
                    case 38 /* Return */ : {
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("modifiers can not appear before return statement");
                        }
                        if (!this.inFunction) {
                            this.reportParseError("return statement outside of function body");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var retStmt = new TypeScript.ReturnStatement();
                        retStmt.minChar = minChar;
                        if ((this.currentToken.tokenId != 55 /* Semicolon */ ) && (this.currentToken.tokenId != 61 /* CloseBrace */ ) && (!(this.scanner.lastTokenHadNewline()))) {
                            retStmt.returnExpression = this.parseExpr(errorRecoverySet | 2 /* SColon */ , 0 /* None */ , true, 0 /* NoTypes */ );
                        }
                        needTerminator = true;
                        retStmt.limChar = this.scanner.lastTokenLimChar();
                        ast = retStmt;
                        break;
                    }
                    case 46 /* Throw */ :
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("modifiers can not appear before a throw statement");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        if ((this.currentToken.tokenId != 55 /* Semicolon */ ) && (this.currentToken.tokenId != 61 /* CloseBrace */ ) && (!(this.scanner.lastTokenHadNewline()))) {
                            temp = this.parseExpr(errorRecoverySet | 2 /* SColon */ , 0 /* None */ , true, 0 /* NoTypes */ );
                        } else {
                            this.reportParseError("throw with no target");
                            temp = null;
                        }
                        ast = new TypeScript.UnaryExpression(80 /* Throw */ , temp);
                        ast.limChar = this.scanner.lastTokenLimChar();
                        needTerminator = true;
                        break;
                    case 13 /* Enum */ :
                        this.currentToken = this.scanner.scan();
                        ast = this.parseEnumDecl(errorRecoverySet, modifiers);
                        ast.minChar = minChar;
                        ast.limChar = this.scanner.lastTokenLimChar();
                        if (this.parsingDeclareFile || this.ambientModule || TypeScript.hasFlag(modifiers, 8 /* Ambient */ )) {
                            (ast).modFlags |= 8 /* Ambient */ ;
                        }
                        if (this.parsingDeclareFile || this.ambientModule || TypeScript.hasFlag(modifiers, 16 /* Exported */ )) {
                            (ast).modFlags |= 1 /* Exported */ ;
                        }
                        break;
                    case 8 /* Debugger */ :
                        mayNotBeExported();
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("modifiers can not appear before debugger statement");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var debuggerStmt = new TypeScript.DebuggerStatement();
                        debuggerStmt.minChar = minChar;
                        needTerminator = true;
                        debuggerStmt.limChar = this.scanner.lastTokenLimChar();
                        ast = debuggerStmt;
                        break;
                    default:
                        if (modifiers != 0 /* None */ ) {
                            this.reportParseError("modifiers can not appear before an expression statement or label");
                        }
                        minChar = this.scanner.startPos;
                        var svPos = this.scanner.pos;
                        temp = this.parseExpr(256 /* Colon */  | TypeScript.ErrorRecoverySet.StmtStart | errorRecoverySet, 0 /* None */ , true, 0 /* NoTypes */ );
                        if (this.scanner.pos == svPos) {
                            this.currentToken = this.scanner.scan();
                            ast = temp;
                        } else if ((this.currentToken.tokenId == 76 /* Colon */ ) && (!this.scanner.lastTokenHadNewline()) && temp && (temp.nodeType == 25 /* Name */ )) {
                            if (labelList == null) {
                                labelList = new TypeScript.ASTList();
                            }
                            labelList.append(new TypeScript.Label(temp));
                            this.currentToken = this.scanner.scan();
                        } else {
                            ast = temp;
                            needTerminator = true;
                        }
                }
                if (ast) {
                    break;
                }
            }
            if (needTerminator) {
                switch(this.currentToken.tokenId) {
                    case 55 /* Semicolon */ :
                        this.currentToken = this.scanner.scan();
                        ast.flags |= 1 /* ExplicitSemicolon */ ;
                        break;
                    case 105 /* EndOfFile */ :
                        ast.limChar = this.scanner.pos;
                    case 61 /* CloseBrace */ :
                        ast.flags |= 2 /* AutomaticSemicolon */ ;
                        if (this.style_requireSemi) {
                            this.reportParseStyleError("no automatic semicolon");
                        }
                        break;
                    default:
                        if (!this.scanner.lastTokenHadNewline()) {
                            this.reportParseError("Expected ';'");
                        } else {
                            ast.flags |= 2 /* AutomaticSemicolon */ ;
                            if (this.style_requireSemi) {
                                this.reportParseStyleError("no automatic semicolon");
                            }
                        }
                        break;
                }
            }
            if (labelList) {
                ast = new TypeScript.LabeledStatement(labelList, ast);
            }
            ast.minChar = minChar;
            ast.limChar = TypeScript.max(ast.limChar, this.scanner.lastTokenLimChar());
            if (preComments) {
                ast.preComments = ast.preComments ? preComments.concat(ast.preComments) : preComments;
            }
            if (this.ambientModule && (!this.okAmbientModuleMember(ast))) {
                this.reportParseError("statement not permitted within ambient module");
            }
            ast.flags |= 64 /* IsStatement */ ;
            return ast;
        };
        Parser.prototype.okAmbientModuleMember = function (ast) {
            var nt = ast.nodeType;
            return (nt == 96 /* ClassDeclaration */ ) || (nt == 99 /* ImportDeclaration */ ) || (nt == 97 /* InterfaceDeclaration */ ) || (nt == 98 /* ModuleDeclaration */ ) || (nt == 1 /* Empty */ ) || (nt == 75 /* VarDecl */ ) || ((nt == 86 /* Block */ ) && !(ast).isStatementBlock) || ((nt == 73 /* FuncDecl */ ) && ((ast).bod == null));
        };
        Parser.prototype.parseStatementList = function (errorRecoverySet, statements, sourceElms, noLeadingCase, allowedElements, parentModifiers) {
            var directivePrologue = sourceElms;
            statements.minChar = this.scanner.startPos;
            var limChar = this.scanner.pos;
            var innerStmts = (allowedElements & 4 /* ModuleDeclarations */ ) == 0 /* None */ ;
            var classNope = (allowedElements & 8 /* ClassDeclarations */ ) == 0 /* None */ ;
            errorRecoverySet |= 1073741824 /* TypeScriptS */  | 32 /* RCurly */ ;
            var oldStrictMode = this.strictMode;
            this.nestingLevel++;
            for(; ; ) {
                if ((this.currentToken.tokenId == 61 /* CloseBrace */ ) || (noLeadingCase && ((this.currentToken.tokenId == 3 /* Case */ ) || (this.currentToken.tokenId == 9 /* Default */ ))) || (innerStmts && (this.currentToken.tokenId == 14 /* Export */ )) || (classNope && (this.currentToken.tokenId == 5 /* Class */ )) || (this.currentToken.tokenId == 105 /* EndOfFile */ )) {
                    statements.limChar = limChar;
                    if (statements.members.length == 0) {
                        statements.preComments = this.parseComments();
                    } else {
                        statements.postComments = this.parseComments();
                    }
                    this.strictMode = oldStrictMode;
                    this.nestingLevel--;
                    return;
                }
                var stmt = this.parseStatement(errorRecoverySet & (~(524288 /* Else */  | 64 /* RParen */  | 1048576 /* Catch */  | 256 /* Colon */ )), allowedElements, parentModifiers);
                if (stmt) {
                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine));
                    statements.append(stmt);
                    limChar = stmt.limChar;
                    if (directivePrologue) {
                        if (stmt.nodeType == 7 /* QString */ ) {
                            var qstring = stmt;
                            if (qstring.text == "\"use strict\"") {
                                statements.flags |= 128 /* StrictMode */ ;
                                this.strictMode = true;
                            } else {
                                directivePrologue = false;
                            }
                        } else {
                            directivePrologue = false;
                        }
                    }
                }
            }
        };
        Parser.prototype.quickParse = function (sourceText, filename, unitIndex) {
            var svGenTarget = TypeScript.moduleGenTarget;
            try  {
                TypeScript.moduleGenTarget = 2 /* Local */ ;
                var script = this.parse(sourceText, filename, unitIndex, TypeScript.AllowedElements.QuickParse);
                return new QuickParseResult(script, this.scanner.lexState);
            } finally {
                TypeScript.moduleGenTarget = svGenTarget;
            }
        };
        Parser.prototype.parse = function (sourceText, filename, unitIndex, allowedElements) {
            if (typeof allowedElements === "undefined") { allowedElements = TypeScript.AllowedElements.Global; }
            var _this = this;
            this.fname = filename;
            this.currentUnitIndex = unitIndex;
            this.currentToken = null;
            this.needTerminator = false;
            this.inFunction = false;
            this.inInterfaceDecl = false;
            this.inFncDecl = false;
            this.ambientModule = false;
            this.ambientClass = false;
            this.topLevel = true;
            this.allowImportDeclaration = true;
            this.prevIDTok = null;
            this.statementInfoStack = new Array();
            this.hasTopLevelImportOrExport = false;
            this.strictMode = false;
            this.nestingLevel = 0;
            this.prevExpr = null;
            this.currentClassDefinition = null;
            this.parsingClassConstructorDefinition = false;
            this.parsingDeclareFile = false;
            this.amdDependencies = [];
            this.inferPropertiesFromThisAssignment = false;
            this.requiresExtendsBlock = false;
            this.scanner.resetComments();
            this.scanner.setErrorHandler(function (message) {
                return _this.reportParseError(message);
            });
            this.scanner.setSourceText(sourceText, 1 /* File */ );
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;
            var minChar = this.scanner.pos;
            this.currentToken = this.scanner.scan();
            this.pushDeclLists();
            var bod = new TypeScript.ASTList();
            bod.minChar = minChar;
            this.parsingDeclareFile = TypeScript.isDSTRFile(filename) || TypeScript.isDTSFile(filename);
            while(true) {
                this.parseStatementList(536870912 /* EOF */  | 268435456 /* Func */ , bod, true, false, allowedElements, 0 /* None */ );
                if (this.currentToken.tokenId === 105 /* EndOfFile */ ) {
                    break;
                }
                var badToken = TypeScript.tokenTable[this.currentToken.tokenId];
                this.reportParseError("Unexpected statement block terminator '" + badToken.text + "'");
                this.currentToken = this.scanner.scan();
            }
            bod.limChar = this.scanner.pos;
            var topLevelMod = null;
            if (TypeScript.moduleGenTarget != 2 /* Local */  && this.hasTopLevelImportOrExport) {
                var correctedFileName = TypeScript.switchToForwardSlashes(filename);
                var id = new TypeScript.Identifier(correctedFileName);
                topLevelMod = new TypeScript.ModuleDeclaration(id, bod, this.topVarList(), null);
                topLevelMod.modFlags |= 2048 /* IsDynamic */ ;
                topLevelMod.modFlags |= 1024 /* IsWholeFile */ ;
                topLevelMod.modFlags |= 1 /* Exported */ ;
                if (this.parsingDeclareFile) {
                    topLevelMod.modFlags |= 8 /* Ambient */ ;
                }
                topLevelMod.minChar = minChar;
                topLevelMod.limChar = this.scanner.pos;
                topLevelMod.prettyName = TypeScript.getPrettyName(correctedFileName);
                topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;
                topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;
                topLevelMod.amdDependencies = this.amdDependencies;
                bod = new TypeScript.ASTList();
                bod.minChar = topLevelMod.minChar;
                bod.limChar = topLevelMod.limChar;
                bod.append(topLevelMod);
            }
            var script = new TypeScript.Script(this.topVarList(), this.topScopeList());
            script.bod = bod;
            this.popDeclLists();
            script.minChar = minChar;
            script.limChar = this.scanner.pos;
            script.locationInfo = new TypeScript.LocationInfo(filename, this.scanner.lineMap, unitIndex);
            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            script.isDeclareFile = this.parsingDeclareFile;
            script.topLevelMod = topLevelMod;
            script.containsUnicodeChar = this.scanner.seenUnicodeChar;
            script.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;
            script.requiresExtendsBlock = this.requiresExtendsBlock;
            return script;
        };
        return Parser;
    })();
    TypeScript.Parser = Parser;    
    function quickParse(logger, scopeStartAST, sourceText, minChar, limChar, errorCapture) {
        var fragment = sourceText.getText(minChar, limChar);
        logger.log("Quick parse range (" + minChar + "," + limChar + "): \"" + TypeScript.stringToLiteral(fragment, 100) + "\"");
        var quickParser = new Parser();
        quickParser.setErrorRecovery(null);
        quickParser.errorCallback = errorCapture;
        var quickClassDecl = new TypeScript.ClassDeclaration(null, null, null, null, null);
        quickParser.currentClassDecl = quickClassDecl;
        var result = quickParser.quickParse(new TypeScript.StringSourceText(fragment), "", 0);
        return result;
    }
    TypeScript.quickParse = quickParse;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PrintContext = (function () {
        function PrintContext(outfile, parser) {
            this.outfile = outfile;
            this.parser = parser;
            this.builder = "";
            this.indent1 = "  ";
            this.indentStrings = [];
            this.indentAmt = 0;
        }
        PrintContext.prototype.increaseIndent = function () {
            this.indentAmt++;
        };
        PrintContext.prototype.decreaseIndent = function () {
            this.indentAmt--;
        };
        PrintContext.prototype.startLine = function () {
            if (this.builder.length > 0) {
                TypeScript.CompilerDiagnostics.Alert(this.builder);
            }
            var indentString = this.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for(var i = 0; i < this.indentAmt; i++) {
                    indentString += this.indent1;
                }
                this.indentStrings[this.indentAmt] = indentString;
            }
            this.builder += indentString;
        };
        PrintContext.prototype.write = function (s) {
            this.builder += s;
        };
        PrintContext.prototype.writeLine = function (s) {
            this.builder += s;
            this.outfile.WriteLine(this.builder);
            this.builder = "";
        };
        return PrintContext;
    })();
    TypeScript.PrintContext = PrintContext;    
    function prePrintAST(ast, parent, walker) {
        var pc = walker.state;
        ast.print(pc);
        pc.increaseIndent();
        return ast;
    }
    TypeScript.prePrintAST = prePrintAST;
    function postPrintAST(ast, parent, walker) {
        var pc = walker.state;
        pc.decreaseIndent();
        return ast;
    }
    TypeScript.postPrintAST = postPrintAST;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.LexEOF = (-1);
    TypeScript.LexCodeNWL = 0x0A;
    TypeScript.LexCodeRET = 0x0D;
    TypeScript.LexCodeLS = 0x2028;
    TypeScript.LexCodePS = 0x2029;
    TypeScript.LexCodeTAB = 0x09;
    TypeScript.LexCodeVTAB = 0x0B;
    TypeScript.LexCode_e = 'e'.charCodeAt(0);
    TypeScript.LexCode_E = 'E'.charCodeAt(0);
    TypeScript.LexCode_x = 'x'.charCodeAt(0);
    TypeScript.LexCode_X = 'X'.charCodeAt(0);
    TypeScript.LexCode_a = 'a'.charCodeAt(0);
    TypeScript.LexCode_A = 'A'.charCodeAt(0);
    TypeScript.LexCode_f = 'f'.charCodeAt(0);
    TypeScript.LexCode_F = 'F'.charCodeAt(0);
    TypeScript.LexCode_g = 'g'.charCodeAt(0);
    TypeScript.LexCode_m = 'm'.charCodeAt(0);
    TypeScript.LexCode_i = 'i'.charCodeAt(0);
    TypeScript.LexCode_u = 'u'.charCodeAt(0);
    TypeScript.LexCode_0 = '0'.charCodeAt(0);
    TypeScript.LexCode_9 = '9'.charCodeAt(0);
    TypeScript.LexCode_8 = '8'.charCodeAt(0);
    TypeScript.LexCode_7 = '7'.charCodeAt(0);
    TypeScript.LexCodeBSL = '\\'.charCodeAt(0);
    TypeScript.LexCodeSHP = '#'.charCodeAt(0);
    TypeScript.LexCodeBNG = '!'.charCodeAt(0);
    TypeScript.LexCodeQUO = '"'.charCodeAt(0);
    TypeScript.LexCodeAPO = '\''.charCodeAt(0);
    TypeScript.LexCodePCT = '%'.charCodeAt(0);
    TypeScript.LexCodeAMP = '&'.charCodeAt(0);
    TypeScript.LexCodeLPR = '('.charCodeAt(0);
    TypeScript.LexCodeRPR = ')'.charCodeAt(0);
    TypeScript.LexCodePLS = '+'.charCodeAt(0);
    TypeScript.LexCodeMIN = '-'.charCodeAt(0);
    TypeScript.LexCodeMUL = '*'.charCodeAt(0);
    TypeScript.LexCodeSLH = '/'.charCodeAt(0);
    TypeScript.LexCodeXOR = '^'.charCodeAt(0);
    TypeScript.LexCodeCMA = ','.charCodeAt(0);
    TypeScript.LexCodeDOT = '.'.charCodeAt(0);
    TypeScript.LexCodeLT = '<'.charCodeAt(0);
    TypeScript.LexCodeEQ = '='.charCodeAt(0);
    TypeScript.LexCodeGT = '>'.charCodeAt(0);
    TypeScript.LexCodeQUE = '?'.charCodeAt(0);
    TypeScript.LexCodeLBR = '['.charCodeAt(0);
    TypeScript.LexCodeRBR = ']'.charCodeAt(0);
    TypeScript.LexCodeUSC = '_'.charCodeAt(0);
    TypeScript.LexCodeLC = '{'.charCodeAt(0);
    TypeScript.LexCodeRC = '}'.charCodeAt(0);
    TypeScript.LexCodeBAR = '|'.charCodeAt(0);
    TypeScript.LexCodeTIL = '~'.charCodeAt(0);
    TypeScript.LexCodeCOL = ':'.charCodeAt(0);
    TypeScript.LexCodeSMC = ';'.charCodeAt(0);
    TypeScript.LexCodeUnderscore = '_'.charCodeAt(0);
    TypeScript.LexCodeDollar = '$'.charCodeAt(0);
    TypeScript.LexCodeSpace = 32;
    TypeScript.LexCodeAtSign = '@'.charCodeAt(0);
    TypeScript.LexCodeASCIIChars = 128;
    TypeScript.LexKeywordTable = undefined;
    var autoToken = new Array(TypeScript.LexCodeASCIIChars);
    var lexIdStartTable = new Array(TypeScript.LexCodeASCIIChars);
    var unicodeES3IdStart = [
        170, 
        170, 
        181, 
        181, 
        186, 
        186, 
        192, 
        214, 
        216, 
        246, 
        248, 
        543, 
        546, 
        563, 
        592, 
        685, 
        688, 
        696, 
        699, 
        705, 
        720, 
        721, 
        736, 
        740, 
        750, 
        750, 
        890, 
        890, 
        902, 
        902, 
        904, 
        906, 
        908, 
        908, 
        910, 
        929, 
        931, 
        974, 
        976, 
        983, 
        986, 
        1011, 
        1024, 
        1153, 
        1164, 
        1220, 
        1223, 
        1224, 
        1227, 
        1228, 
        1232, 
        1269, 
        1272, 
        1273, 
        1329, 
        1366, 
        1369, 
        1369, 
        1377, 
        1415, 
        1488, 
        1514, 
        1520, 
        1522, 
        1569, 
        1594, 
        1600, 
        1610, 
        1649, 
        1747, 
        1749, 
        1749, 
        1765, 
        1766, 
        1786, 
        1788, 
        1808, 
        1808, 
        1810, 
        1836, 
        1920, 
        1957, 
        2309, 
        2361, 
        2365, 
        2365, 
        2384, 
        2384, 
        2392, 
        2401, 
        2437, 
        2444, 
        2447, 
        2448, 
        2451, 
        2472, 
        2474, 
        2480, 
        2482, 
        2482, 
        2486, 
        2489, 
        2524, 
        2525, 
        2527, 
        2529, 
        2544, 
        2545, 
        2565, 
        2570, 
        2575, 
        2576, 
        2579, 
        2600, 
        2602, 
        2608, 
        2610, 
        2611, 
        2613, 
        2614, 
        2616, 
        2617, 
        2649, 
        2652, 
        2654, 
        2654, 
        2674, 
        2676, 
        2693, 
        2699, 
        2701, 
        2701, 
        2703, 
        2705, 
        2707, 
        2728, 
        2730, 
        2736, 
        2738, 
        2739, 
        2741, 
        2745, 
        2749, 
        2749, 
        2768, 
        2768, 
        2784, 
        2784, 
        2821, 
        2828, 
        2831, 
        2832, 
        2835, 
        2856, 
        2858, 
        2864, 
        2866, 
        2867, 
        2870, 
        2873, 
        2877, 
        2877, 
        2908, 
        2909, 
        2911, 
        2913, 
        2949, 
        2954, 
        2958, 
        2960, 
        2962, 
        2965, 
        2969, 
        2970, 
        2972, 
        2972, 
        2974, 
        2975, 
        2979, 
        2980, 
        2984, 
        2986, 
        2990, 
        2997, 
        2999, 
        3001, 
        3077, 
        3084, 
        3086, 
        3088, 
        3090, 
        3112, 
        3114, 
        3123, 
        3125, 
        3129, 
        3168, 
        3169, 
        3205, 
        3212, 
        3214, 
        3216, 
        3218, 
        3240, 
        3242, 
        3251, 
        3253, 
        3257, 
        3294, 
        3294, 
        3296, 
        3297, 
        3333, 
        3340, 
        3342, 
        3344, 
        3346, 
        3368, 
        3370, 
        3385, 
        3424, 
        3425, 
        3461, 
        3478, 
        3482, 
        3505, 
        3507, 
        3515, 
        3517, 
        3517, 
        3520, 
        3526, 
        3585, 
        3632, 
        3634, 
        3635, 
        3648, 
        3654, 
        3713, 
        3714, 
        3716, 
        3716, 
        3719, 
        3720, 
        3722, 
        3722, 
        3725, 
        3725, 
        3732, 
        3735, 
        3737, 
        3743, 
        3745, 
        3747, 
        3749, 
        3749, 
        3751, 
        3751, 
        3754, 
        3755, 
        3757, 
        3760, 
        3762, 
        3763, 
        3773, 
        3773, 
        3776, 
        3780, 
        3782, 
        3782, 
        3804, 
        3805, 
        3840, 
        3840, 
        3904, 
        3911, 
        3913, 
        3946, 
        3976, 
        3979, 
        4096, 
        4129, 
        4131, 
        4135, 
        4137, 
        4138, 
        4176, 
        4181, 
        4256, 
        4293, 
        4304, 
        4342, 
        4352, 
        4441, 
        4447, 
        4514, 
        4520, 
        4601, 
        4608, 
        4614, 
        4616, 
        4678, 
        4680, 
        4680, 
        4682, 
        4685, 
        4688, 
        4694, 
        4696, 
        4696, 
        4698, 
        4701, 
        4704, 
        4742, 
        4744, 
        4744, 
        4746, 
        4749, 
        4752, 
        4782, 
        4784, 
        4784, 
        4786, 
        4789, 
        4792, 
        4798, 
        4800, 
        4800, 
        4802, 
        4805, 
        4808, 
        4814, 
        4816, 
        4822, 
        4824, 
        4846, 
        4848, 
        4878, 
        4880, 
        4880, 
        4882, 
        4885, 
        4888, 
        4894, 
        4896, 
        4934, 
        4936, 
        4954, 
        5024, 
        5108, 
        5121, 
        5740, 
        5743, 
        5750, 
        5761, 
        5786, 
        5792, 
        5866, 
        6016, 
        6067, 
        6176, 
        6263, 
        6272, 
        6312, 
        7680, 
        7835, 
        7840, 
        7929, 
        7936, 
        7957, 
        7960, 
        7965, 
        7968, 
        8005, 
        8008, 
        8013, 
        8016, 
        8023, 
        8025, 
        8025, 
        8027, 
        8027, 
        8029, 
        8029, 
        8031, 
        8061, 
        8064, 
        8116, 
        8118, 
        8124, 
        8126, 
        8126, 
        8130, 
        8132, 
        8134, 
        8140, 
        8144, 
        8147, 
        8150, 
        8155, 
        8160, 
        8172, 
        8178, 
        8180, 
        8182, 
        8188, 
        8319, 
        8319, 
        8450, 
        8450, 
        8455, 
        8455, 
        8458, 
        8467, 
        8469, 
        8469, 
        8473, 
        8477, 
        8484, 
        8484, 
        8486, 
        8486, 
        8488, 
        8488, 
        8490, 
        8493, 
        8495, 
        8497, 
        8499, 
        8505, 
        8544, 
        8579, 
        12293, 
        12295, 
        12321, 
        12329, 
        12337, 
        12341, 
        12344, 
        12346, 
        12353, 
        12436, 
        12445, 
        12446, 
        12449, 
        12538, 
        12540, 
        12542, 
        12549, 
        12588, 
        12593, 
        12686, 
        12704, 
        12727, 
        13312, 
        19893, 
        19968, 
        40869, 
        40960, 
        42124, 
        44032, 
        55203, 
        63744, 
        64045, 
        64256, 
        64262, 
        64275, 
        64279, 
        64285, 
        64285, 
        64287, 
        64296, 
        64298, 
        64310, 
        64312, 
        64316, 
        64318, 
        64318, 
        64320, 
        64321, 
        64323, 
        64324, 
        64326, 
        64433, 
        64467, 
        64829, 
        64848, 
        64911, 
        64914, 
        64967, 
        65008, 
        65019, 
        65136, 
        65138, 
        65140, 
        65140, 
        65142, 
        65276, 
        65313, 
        65338, 
        65345, 
        65370, 
        65382, 
        65470, 
        65474, 
        65479, 
        65482, 
        65487, 
        65490, 
        65495, 
        65498, 
        65500, 
        
    ];
    var unicodeES3IdCont = [
        768, 
        846, 
        864, 
        866, 
        1155, 
        1158, 
        1425, 
        1441, 
        1443, 
        1465, 
        1467, 
        1469, 
        1471, 
        1471, 
        1473, 
        1474, 
        1476, 
        1476, 
        1611, 
        1621, 
        1632, 
        1641, 
        1648, 
        1648, 
        1750, 
        1756, 
        1759, 
        1764, 
        1767, 
        1768, 
        1770, 
        1773, 
        1776, 
        1785, 
        1809, 
        1809, 
        1840, 
        1866, 
        1958, 
        1968, 
        2305, 
        2307, 
        2364, 
        2364, 
        2366, 
        2381, 
        2385, 
        2388, 
        2402, 
        2403, 
        2406, 
        2415, 
        2433, 
        2435, 
        2492, 
        2492, 
        2494, 
        2500, 
        2503, 
        2504, 
        2507, 
        2509, 
        2519, 
        2519, 
        2530, 
        2531, 
        2534, 
        2543, 
        2562, 
        2562, 
        2620, 
        2620, 
        2622, 
        2626, 
        2631, 
        2632, 
        2635, 
        2637, 
        2662, 
        2673, 
        2689, 
        2691, 
        2748, 
        2748, 
        2750, 
        2757, 
        2759, 
        2761, 
        2763, 
        2765, 
        2790, 
        2799, 
        2817, 
        2819, 
        2876, 
        2876, 
        2878, 
        2883, 
        2887, 
        2888, 
        2891, 
        2893, 
        2902, 
        2903, 
        2918, 
        2927, 
        2946, 
        2947, 
        3006, 
        3010, 
        3014, 
        3016, 
        3018, 
        3021, 
        3031, 
        3031, 
        3047, 
        3055, 
        3073, 
        3075, 
        3134, 
        3140, 
        3142, 
        3144, 
        3146, 
        3149, 
        3157, 
        3158, 
        3174, 
        3183, 
        3202, 
        3203, 
        3262, 
        3268, 
        3270, 
        3272, 
        3274, 
        3277, 
        3285, 
        3286, 
        3302, 
        3311, 
        3330, 
        3331, 
        3390, 
        3395, 
        3398, 
        3400, 
        3402, 
        3405, 
        3415, 
        3415, 
        3430, 
        3439, 
        3458, 
        3459, 
        3530, 
        3530, 
        3535, 
        3540, 
        3542, 
        3542, 
        3544, 
        3551, 
        3570, 
        3571, 
        3633, 
        3633, 
        3636, 
        3642, 
        3655, 
        3662, 
        3664, 
        3673, 
        3761, 
        3761, 
        3764, 
        3769, 
        3771, 
        3772, 
        3784, 
        3789, 
        3792, 
        3801, 
        3864, 
        3865, 
        3872, 
        3881, 
        3893, 
        3893, 
        3895, 
        3895, 
        3897, 
        3897, 
        3902, 
        3903, 
        3953, 
        3972, 
        3974, 
        3975, 
        3984, 
        3991, 
        3993, 
        4028, 
        4038, 
        4038, 
        4140, 
        4146, 
        4150, 
        4153, 
        4160, 
        4169, 
        4182, 
        4185, 
        4969, 
        4977, 
        6068, 
        6099, 
        6112, 
        6121, 
        6160, 
        6169, 
        6313, 
        6313, 
        8255, 
        8256, 
        8400, 
        8412, 
        8417, 
        8417, 
        12330, 
        12335, 
        12441, 
        12442, 
        12539, 
        12539, 
        64286, 
        64286, 
        65056, 
        65059, 
        65075, 
        65076, 
        65101, 
        65103, 
        65296, 
        65305, 
        65343, 
        65343, 
        65381, 
        65381, 
        
    ];
    var unicodeES5IdStart = [
        170, 
        170, 
        181, 
        181, 
        186, 
        186, 
        192, 
        214, 
        216, 
        246, 
        248, 
        705, 
        710, 
        721, 
        736, 
        740, 
        748, 
        748, 
        750, 
        750, 
        880, 
        884, 
        886, 
        887, 
        890, 
        893, 
        902, 
        902, 
        904, 
        906, 
        908, 
        908, 
        910, 
        929, 
        931, 
        1013, 
        1015, 
        1153, 
        1162, 
        1319, 
        1329, 
        1366, 
        1369, 
        1369, 
        1377, 
        1415, 
        1488, 
        1514, 
        1520, 
        1522, 
        1568, 
        1610, 
        1646, 
        1647, 
        1649, 
        1747, 
        1749, 
        1749, 
        1765, 
        1766, 
        1774, 
        1775, 
        1786, 
        1788, 
        1791, 
        1791, 
        1808, 
        1808, 
        1810, 
        1839, 
        1869, 
        1957, 
        1969, 
        1969, 
        1994, 
        2026, 
        2036, 
        2037, 
        2042, 
        2042, 
        2048, 
        2069, 
        2074, 
        2074, 
        2084, 
        2084, 
        2088, 
        2088, 
        2112, 
        2136, 
        2208, 
        2208, 
        2210, 
        2220, 
        2308, 
        2361, 
        2365, 
        2365, 
        2384, 
        2384, 
        2392, 
        2401, 
        2417, 
        2423, 
        2425, 
        2431, 
        2437, 
        2444, 
        2447, 
        2448, 
        2451, 
        2472, 
        2474, 
        2480, 
        2482, 
        2482, 
        2486, 
        2489, 
        2493, 
        2493, 
        2510, 
        2510, 
        2524, 
        2525, 
        2527, 
        2529, 
        2544, 
        2545, 
        2565, 
        2570, 
        2575, 
        2576, 
        2579, 
        2600, 
        2602, 
        2608, 
        2610, 
        2611, 
        2613, 
        2614, 
        2616, 
        2617, 
        2649, 
        2652, 
        2654, 
        2654, 
        2674, 
        2676, 
        2693, 
        2701, 
        2703, 
        2705, 
        2707, 
        2728, 
        2730, 
        2736, 
        2738, 
        2739, 
        2741, 
        2745, 
        2749, 
        2749, 
        2768, 
        2768, 
        2784, 
        2785, 
        2821, 
        2828, 
        2831, 
        2832, 
        2835, 
        2856, 
        2858, 
        2864, 
        2866, 
        2867, 
        2869, 
        2873, 
        2877, 
        2877, 
        2908, 
        2909, 
        2911, 
        2913, 
        2929, 
        2929, 
        2947, 
        2947, 
        2949, 
        2954, 
        2958, 
        2960, 
        2962, 
        2965, 
        2969, 
        2970, 
        2972, 
        2972, 
        2974, 
        2975, 
        2979, 
        2980, 
        2984, 
        2986, 
        2990, 
        3001, 
        3024, 
        3024, 
        3077, 
        3084, 
        3086, 
        3088, 
        3090, 
        3112, 
        3114, 
        3123, 
        3125, 
        3129, 
        3133, 
        3133, 
        3160, 
        3161, 
        3168, 
        3169, 
        3205, 
        3212, 
        3214, 
        3216, 
        3218, 
        3240, 
        3242, 
        3251, 
        3253, 
        3257, 
        3261, 
        3261, 
        3294, 
        3294, 
        3296, 
        3297, 
        3313, 
        3314, 
        3333, 
        3340, 
        3342, 
        3344, 
        3346, 
        3386, 
        3389, 
        3389, 
        3406, 
        3406, 
        3424, 
        3425, 
        3450, 
        3455, 
        3461, 
        3478, 
        3482, 
        3505, 
        3507, 
        3515, 
        3517, 
        3517, 
        3520, 
        3526, 
        3585, 
        3632, 
        3634, 
        3635, 
        3648, 
        3654, 
        3713, 
        3714, 
        3716, 
        3716, 
        3719, 
        3720, 
        3722, 
        3722, 
        3725, 
        3725, 
        3732, 
        3735, 
        3737, 
        3743, 
        3745, 
        3747, 
        3749, 
        3749, 
        3751, 
        3751, 
        3754, 
        3755, 
        3757, 
        3760, 
        3762, 
        3763, 
        3773, 
        3773, 
        3776, 
        3780, 
        3782, 
        3782, 
        3804, 
        3807, 
        3840, 
        3840, 
        3904, 
        3911, 
        3913, 
        3948, 
        3976, 
        3980, 
        4096, 
        4138, 
        4159, 
        4159, 
        4176, 
        4181, 
        4186, 
        4189, 
        4193, 
        4193, 
        4197, 
        4198, 
        4206, 
        4208, 
        4213, 
        4225, 
        4238, 
        4238, 
        4256, 
        4293, 
        4295, 
        4295, 
        4301, 
        4301, 
        4304, 
        4346, 
        4348, 
        4680, 
        4682, 
        4685, 
        4688, 
        4694, 
        4696, 
        4696, 
        4698, 
        4701, 
        4704, 
        4744, 
        4746, 
        4749, 
        4752, 
        4784, 
        4786, 
        4789, 
        4792, 
        4798, 
        4800, 
        4800, 
        4802, 
        4805, 
        4808, 
        4822, 
        4824, 
        4880, 
        4882, 
        4885, 
        4888, 
        4954, 
        4992, 
        5007, 
        5024, 
        5108, 
        5121, 
        5740, 
        5743, 
        5759, 
        5761, 
        5786, 
        5792, 
        5866, 
        5870, 
        5872, 
        5888, 
        5900, 
        5902, 
        5905, 
        5920, 
        5937, 
        5952, 
        5969, 
        5984, 
        5996, 
        5998, 
        6000, 
        6016, 
        6067, 
        6103, 
        6103, 
        6108, 
        6108, 
        6176, 
        6263, 
        6272, 
        6312, 
        6314, 
        6314, 
        6320, 
        6389, 
        6400, 
        6428, 
        6480, 
        6509, 
        6512, 
        6516, 
        6528, 
        6571, 
        6593, 
        6599, 
        6656, 
        6678, 
        6688, 
        6740, 
        6823, 
        6823, 
        6917, 
        6963, 
        6981, 
        6987, 
        7043, 
        7072, 
        7086, 
        7087, 
        7098, 
        7141, 
        7168, 
        7203, 
        7245, 
        7247, 
        7258, 
        7293, 
        7401, 
        7404, 
        7406, 
        7409, 
        7413, 
        7414, 
        7424, 
        7615, 
        7680, 
        7957, 
        7960, 
        7965, 
        7968, 
        8005, 
        8008, 
        8013, 
        8016, 
        8023, 
        8025, 
        8025, 
        8027, 
        8027, 
        8029, 
        8029, 
        8031, 
        8061, 
        8064, 
        8116, 
        8118, 
        8124, 
        8126, 
        8126, 
        8130, 
        8132, 
        8134, 
        8140, 
        8144, 
        8147, 
        8150, 
        8155, 
        8160, 
        8172, 
        8178, 
        8180, 
        8182, 
        8188, 
        8305, 
        8305, 
        8319, 
        8319, 
        8336, 
        8348, 
        8450, 
        8450, 
        8455, 
        8455, 
        8458, 
        8467, 
        8469, 
        8469, 
        8473, 
        8477, 
        8484, 
        8484, 
        8486, 
        8486, 
        8488, 
        8488, 
        8490, 
        8493, 
        8495, 
        8505, 
        8508, 
        8511, 
        8517, 
        8521, 
        8526, 
        8526, 
        8544, 
        8584, 
        11264, 
        11310, 
        11312, 
        11358, 
        11360, 
        11492, 
        11499, 
        11502, 
        11506, 
        11507, 
        11520, 
        11557, 
        11559, 
        11559, 
        11565, 
        11565, 
        11568, 
        11623, 
        11631, 
        11631, 
        11648, 
        11670, 
        11680, 
        11686, 
        11688, 
        11694, 
        11696, 
        11702, 
        11704, 
        11710, 
        11712, 
        11718, 
        11720, 
        11726, 
        11728, 
        11734, 
        11736, 
        11742, 
        11823, 
        11823, 
        12293, 
        12295, 
        12321, 
        12329, 
        12337, 
        12341, 
        12344, 
        12348, 
        12353, 
        12438, 
        12445, 
        12447, 
        12449, 
        12538, 
        12540, 
        12543, 
        12549, 
        12589, 
        12593, 
        12686, 
        12704, 
        12730, 
        12784, 
        12799, 
        13312, 
        19893, 
        19968, 
        40908, 
        40960, 
        42124, 
        42192, 
        42237, 
        42240, 
        42508, 
        42512, 
        42527, 
        42538, 
        42539, 
        42560, 
        42606, 
        42623, 
        42647, 
        42656, 
        42735, 
        42775, 
        42783, 
        42786, 
        42888, 
        42891, 
        42894, 
        42896, 
        42899, 
        42912, 
        42922, 
        43000, 
        43009, 
        43011, 
        43013, 
        43015, 
        43018, 
        43020, 
        43042, 
        43072, 
        43123, 
        43138, 
        43187, 
        43250, 
        43255, 
        43259, 
        43259, 
        43274, 
        43301, 
        43312, 
        43334, 
        43360, 
        43388, 
        43396, 
        43442, 
        43471, 
        43471, 
        43520, 
        43560, 
        43584, 
        43586, 
        43588, 
        43595, 
        43616, 
        43638, 
        43642, 
        43642, 
        43648, 
        43695, 
        43697, 
        43697, 
        43701, 
        43702, 
        43705, 
        43709, 
        43712, 
        43712, 
        43714, 
        43714, 
        43739, 
        43741, 
        43744, 
        43754, 
        43762, 
        43764, 
        43777, 
        43782, 
        43785, 
        43790, 
        43793, 
        43798, 
        43808, 
        43814, 
        43816, 
        43822, 
        43968, 
        44002, 
        44032, 
        55203, 
        55216, 
        55238, 
        55243, 
        55291, 
        63744, 
        64109, 
        64112, 
        64217, 
        64256, 
        64262, 
        64275, 
        64279, 
        64285, 
        64285, 
        64287, 
        64296, 
        64298, 
        64310, 
        64312, 
        64316, 
        64318, 
        64318, 
        64320, 
        64321, 
        64323, 
        64324, 
        64326, 
        64433, 
        64467, 
        64829, 
        64848, 
        64911, 
        64914, 
        64967, 
        65008, 
        65019, 
        65136, 
        65140, 
        65142, 
        65276, 
        65313, 
        65338, 
        65345, 
        65370, 
        65382, 
        65470, 
        65474, 
        65479, 
        65482, 
        65487, 
        65490, 
        65495, 
        65498, 
        65500, 
        
    ];
    var unicodeES5IdCont = [
        768, 
        879, 
        1155, 
        1159, 
        1425, 
        1469, 
        1471, 
        1471, 
        1473, 
        1474, 
        1476, 
        1477, 
        1479, 
        1479, 
        1552, 
        1562, 
        1611, 
        1641, 
        1648, 
        1648, 
        1750, 
        1756, 
        1759, 
        1764, 
        1767, 
        1768, 
        1770, 
        1773, 
        1776, 
        1785, 
        1809, 
        1809, 
        1840, 
        1866, 
        1958, 
        1968, 
        1984, 
        1993, 
        2027, 
        2035, 
        2070, 
        2073, 
        2075, 
        2083, 
        2085, 
        2087, 
        2089, 
        2093, 
        2137, 
        2139, 
        2276, 
        2302, 
        2304, 
        2307, 
        2362, 
        2364, 
        2366, 
        2383, 
        2385, 
        2391, 
        2402, 
        2403, 
        2406, 
        2415, 
        2433, 
        2435, 
        2492, 
        2492, 
        2494, 
        2500, 
        2503, 
        2504, 
        2507, 
        2509, 
        2519, 
        2519, 
        2530, 
        2531, 
        2534, 
        2543, 
        2561, 
        2563, 
        2620, 
        2620, 
        2622, 
        2626, 
        2631, 
        2632, 
        2635, 
        2637, 
        2641, 
        2641, 
        2662, 
        2673, 
        2677, 
        2677, 
        2689, 
        2691, 
        2748, 
        2748, 
        2750, 
        2757, 
        2759, 
        2761, 
        2763, 
        2765, 
        2786, 
        2787, 
        2790, 
        2799, 
        2817, 
        2819, 
        2876, 
        2876, 
        2878, 
        2884, 
        2887, 
        2888, 
        2891, 
        2893, 
        2902, 
        2903, 
        2914, 
        2915, 
        2918, 
        2927, 
        2946, 
        2946, 
        3006, 
        3010, 
        3014, 
        3016, 
        3018, 
        3021, 
        3031, 
        3031, 
        3046, 
        3055, 
        3073, 
        3075, 
        3134, 
        3140, 
        3142, 
        3144, 
        3146, 
        3149, 
        3157, 
        3158, 
        3170, 
        3171, 
        3174, 
        3183, 
        3202, 
        3203, 
        3260, 
        3260, 
        3262, 
        3268, 
        3270, 
        3272, 
        3274, 
        3277, 
        3285, 
        3286, 
        3298, 
        3299, 
        3302, 
        3311, 
        3330, 
        3331, 
        3390, 
        3396, 
        3398, 
        3400, 
        3402, 
        3405, 
        3415, 
        3415, 
        3426, 
        3427, 
        3430, 
        3439, 
        3458, 
        3459, 
        3530, 
        3530, 
        3535, 
        3540, 
        3542, 
        3542, 
        3544, 
        3551, 
        3570, 
        3571, 
        3633, 
        3633, 
        3636, 
        3642, 
        3655, 
        3662, 
        3664, 
        3673, 
        3761, 
        3761, 
        3764, 
        3769, 
        3771, 
        3772, 
        3784, 
        3789, 
        3792, 
        3801, 
        3864, 
        3865, 
        3872, 
        3881, 
        3893, 
        3893, 
        3895, 
        3895, 
        3897, 
        3897, 
        3902, 
        3903, 
        3953, 
        3972, 
        3974, 
        3975, 
        3981, 
        3991, 
        3993, 
        4028, 
        4038, 
        4038, 
        4139, 
        4158, 
        4160, 
        4169, 
        4182, 
        4185, 
        4190, 
        4192, 
        4194, 
        4196, 
        4199, 
        4205, 
        4209, 
        4212, 
        4226, 
        4237, 
        4239, 
        4253, 
        4957, 
        4959, 
        5906, 
        5908, 
        5938, 
        5940, 
        5970, 
        5971, 
        6002, 
        6003, 
        6068, 
        6099, 
        6109, 
        6109, 
        6112, 
        6121, 
        6155, 
        6157, 
        6160, 
        6169, 
        6313, 
        6313, 
        6432, 
        6443, 
        6448, 
        6459, 
        6470, 
        6479, 
        6576, 
        6592, 
        6600, 
        6601, 
        6608, 
        6617, 
        6679, 
        6683, 
        6741, 
        6750, 
        6752, 
        6780, 
        6783, 
        6793, 
        6800, 
        6809, 
        6912, 
        6916, 
        6964, 
        6980, 
        6992, 
        7001, 
        7019, 
        7027, 
        7040, 
        7042, 
        7073, 
        7085, 
        7088, 
        7097, 
        7142, 
        7155, 
        7204, 
        7223, 
        7232, 
        7241, 
        7248, 
        7257, 
        7376, 
        7378, 
        7380, 
        7400, 
        7405, 
        7405, 
        7410, 
        7412, 
        7616, 
        7654, 
        7676, 
        7679, 
        8204, 
        8205, 
        8255, 
        8256, 
        8276, 
        8276, 
        8400, 
        8412, 
        8417, 
        8417, 
        8421, 
        8432, 
        11503, 
        11505, 
        11647, 
        11647, 
        11744, 
        11775, 
        12330, 
        12335, 
        12441, 
        12442, 
        42528, 
        42537, 
        42607, 
        42607, 
        42612, 
        42621, 
        42655, 
        42655, 
        42736, 
        42737, 
        43010, 
        43010, 
        43014, 
        43014, 
        43019, 
        43019, 
        43043, 
        43047, 
        43136, 
        43137, 
        43188, 
        43204, 
        43216, 
        43225, 
        43232, 
        43249, 
        43264, 
        43273, 
        43302, 
        43309, 
        43335, 
        43347, 
        43392, 
        43395, 
        43443, 
        43456, 
        43472, 
        43481, 
        43561, 
        43574, 
        43587, 
        43587, 
        43596, 
        43597, 
        43600, 
        43609, 
        43643, 
        43643, 
        43696, 
        43696, 
        43698, 
        43700, 
        43703, 
        43704, 
        43710, 
        43711, 
        43713, 
        43713, 
        43755, 
        43759, 
        43765, 
        43766, 
        44003, 
        44010, 
        44012, 
        44013, 
        44016, 
        44025, 
        64286, 
        64286, 
        65024, 
        65039, 
        65056, 
        65062, 
        65075, 
        65076, 
        65101, 
        65103, 
        65296, 
        65305, 
        65343, 
        65343, 
        
    ];
    function LexLookUpUnicodeMap(code, map) {
        var lo = 0;
        var hi = map.length;
        var mid;
        while(lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1]) {
                return true;
            }
            if (code < map[mid]) {
                hi = mid;
            } else {
                lo = mid + 2;
            }
        }
        return false;
    }
    TypeScript.LexLookUpUnicodeMap = LexLookUpUnicodeMap;
    function LexIsUnicodeDigit(code) {
        if (TypeScript.codeGenTarget == 0 /* ES3 */ ) {
            return LexLookUpUnicodeMap(code, unicodeES3IdCont);
        } else {
            return LexLookUpUnicodeMap(code, unicodeES5IdCont);
        }
    }
    TypeScript.LexIsUnicodeDigit = LexIsUnicodeDigit;
    function LexIsUnicodeIdStart(code) {
        if (TypeScript.codeGenTarget == 0 /* ES3 */ ) {
            return LexLookUpUnicodeMap(code, unicodeES3IdStart);
        } else {
            return LexLookUpUnicodeMap(code, unicodeES5IdStart);
        }
    }
    TypeScript.LexIsUnicodeIdStart = LexIsUnicodeIdStart;
    function LexInitialize() {
        TypeScript.initializeStaticTokens();
        autoToken[TypeScript.LexCodeLPR] = TypeScript.staticTokens[56 /* OpenParen */ ];
        autoToken[TypeScript.LexCodeRPR] = TypeScript.staticTokens[57 /* CloseParen */ ];
        autoToken[TypeScript.LexCodeCMA] = TypeScript.staticTokens[62 /* Comma */ ];
        autoToken[TypeScript.LexCodeSMC] = TypeScript.staticTokens[55 /* Semicolon */ ];
        autoToken[TypeScript.LexCodeLBR] = TypeScript.staticTokens[58 /* OpenBracket */ ];
        autoToken[TypeScript.LexCodeRBR] = TypeScript.staticTokens[59 /* CloseBracket */ ];
        autoToken[TypeScript.LexCodeTIL] = TypeScript.staticTokens[98 /* Tilde */ ];
        autoToken[TypeScript.LexCodeQUE] = TypeScript.staticTokens[75 /* Question */ ];
        autoToken[TypeScript.LexCodeLC] = TypeScript.staticTokens[60 /* OpenBrace */ ];
        autoToken[TypeScript.LexCodeRC] = TypeScript.staticTokens[61 /* CloseBrace */ ];
        autoToken[TypeScript.LexCodeCOL] = TypeScript.staticTokens[76 /* Colon */ ];
        TypeScript.LexKeywordTable = new TypeScript.StringHashTable();
        for(var i in (TypeScript.TokenID)._map) {
            if ((i) <= 54 /* LimKeyword */ ) {
                TypeScript.LexKeywordTable.add((TypeScript.TokenID)._map[i].toLowerCase(), i);
            }
        }
        for(var j = 0; j < TypeScript.LexCodeASCIIChars; j++) {
            if (LexIsIdentifierStartChar(j)) {
                lexIdStartTable[j] = true;
            } else {
                lexIdStartTable[j] = false;
            }
        }
    }
    TypeScript.LexInitialize = LexInitialize;
    function LexAdjustIndent(code, indentAmt) {
        if ((code == TypeScript.LexCodeLBR) || (code == TypeScript.LexCodeLC) || (code == TypeScript.LexCodeLPR)) {
            return indentAmt + 1;
        } else if ((code == TypeScript.LexCodeRBR) || (code == TypeScript.LexCodeRC) || (code == TypeScript.LexCodeRPR)) {
            return indentAmt - 1;
        } else {
            return indentAmt;
        }
    }
    TypeScript.LexAdjustIndent = LexAdjustIndent;
    function LexIsIdentifierStartChar(code) {
        return (((code >= 97) && (code <= 122)) || ((code >= 65) && (code <= 90)) || (code == TypeScript.LexCodeDollar) || (code == TypeScript.LexCodeUnderscore));
    }
    TypeScript.LexIsIdentifierStartChar = LexIsIdentifierStartChar;
    function LexIsDigit(code) {
        return ((code >= 48) && (code <= 57));
    }
    TypeScript.LexIsDigit = LexIsDigit;
    function LexIsIdentifierChar(code) {
        return lexIdStartTable[code] || LexIsDigit(code);
    }
    TypeScript.LexIsIdentifierChar = LexIsIdentifierChar;
    function LexMatchingOpen(code) {
        if (code == TypeScript.LexCodeRBR) {
            return TypeScript.LexCodeLBR;
        } else if (code == TypeScript.LexCodeRC) {
            return TypeScript.LexCodeLC;
        } else if (code == TypeScript.LexCodeRPR) {
            return TypeScript.LexCodeLPR;
        } else {
            return 0;
        }
    }
    TypeScript.LexMatchingOpen = LexMatchingOpen;
    (function (NumberScanState) {
        NumberScanState._map = [];
        NumberScanState._map[0] = "Start";
        NumberScanState.Start = 0;
        NumberScanState._map[1] = "InFraction";
        NumberScanState.InFraction = 1;
        NumberScanState._map[2] = "InEmptyFraction";
        NumberScanState.InEmptyFraction = 2;
        NumberScanState._map[3] = "InExponent";
        NumberScanState.InExponent = 3;
    })(TypeScript.NumberScanState || (TypeScript.NumberScanState = {}));
    var NumberScanState = TypeScript.NumberScanState;
    (function (LexState) {
        LexState._map = [];
        LexState._map[0] = "Start";
        LexState.Start = 0;
        LexState._map[1] = "InMultilineComment";
        LexState.InMultilineComment = 1;
        LexState._map[2] = "InMultilineSingleQuoteString";
        LexState.InMultilineSingleQuoteString = 2;
        LexState._map[3] = "InMultilineDoubleQuoteString";
        LexState.InMultilineDoubleQuoteString = 3;
    })(TypeScript.LexState || (TypeScript.LexState = {}));
    var LexState = TypeScript.LexState;
    (function (LexMode) {
        LexMode._map = [];
        LexMode._map[0] = "Line";
        LexMode.Line = 0;
        LexMode._map[1] = "File";
        LexMode.File = 1;
    })(TypeScript.LexMode || (TypeScript.LexMode = {}));
    var LexMode = TypeScript.LexMode;
    (function (CommentStyle) {
        CommentStyle._map = [];
        CommentStyle._map[0] = "Line";
        CommentStyle.Line = 0;
        CommentStyle._map[1] = "Block";
        CommentStyle.Block = 1;
    })(TypeScript.CommentStyle || (TypeScript.CommentStyle = {}));
    var CommentStyle = TypeScript.CommentStyle;
    var SourceSimpleText = (function () {
        function SourceSimpleText(text) {
            this.text = text;
        }
        SourceSimpleText.prototype.length = function () {
            return this.text.getLength();
        };
        SourceSimpleText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
            StringUtilities.copyTo(this.text.getText(sourceIndex, sourceIndex + count), 0, destination, destinationIndex, count);
        };
        SourceSimpleText.prototype.substr = function (start, length, intern) {
            return this.text.getText(start, start + length);
        };
        SourceSimpleText.prototype.subText = function (span) {
            return TextFactory.createSimpleSubText(this, span);
        };
        return SourceSimpleText;
    })();
    TypeScript.SourceSimpleText = SourceSimpleText;    
    var StringSourceText = (function () {
        function StringSourceText(text) {
            this.text = text;
        }
        StringSourceText.prototype.getText = function (start, end) {
            return this.text.substring(start, end);
        };
        StringSourceText.prototype.getLength = function () {
            return this.text.length;
        };
        return StringSourceText;
    })();
    TypeScript.StringSourceText = StringSourceText;    
    var SourceTextSegment = (function () {
        function SourceTextSegment(segmentStart, segmentEnd, segment) {
            this.segmentStart = segmentStart;
            this.segmentEnd = segmentEnd;
            this.segment = segment;
        }
        SourceTextSegment.prototype.charCodeAt = function (index) {
            return this.segment.charCodeAt(index - this.segmentStart);
        };
        SourceTextSegment.prototype.substring = function (start, end) {
            return this.segment.substring(start - this.segmentStart, end - this.segmentStart);
        };
        return SourceTextSegment;
    })();
    TypeScript.SourceTextSegment = SourceTextSegment;    
    var AggerateSourceTextSegment = (function () {
        function AggerateSourceTextSegment(seg1, seg2) {
            this.seg1 = seg1;
            this.seg2 = seg2;
        }
        AggerateSourceTextSegment.prototype.charCodeAt = function (index) {
            if (this.seg1.segmentStart <= index && index < this.seg1.segmentEnd) {
                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart);
            }
            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart);
        };
        AggerateSourceTextSegment.prototype.substring = function (start, end) {
            if (this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd) {
                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart);
            }
            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substring(0, end - this.seg1.segmentStart);
        };
        return AggerateSourceTextSegment;
    })();
    TypeScript.AggerateSourceTextSegment = AggerateSourceTextSegment;    
    var ScannerTextStream = (function () {
        function ScannerTextStream(sourceText) {
            this.sourceText = sourceText;
            this.agg = new AggerateSourceTextSegment(ScannerTextStream.emptySegment, ScannerTextStream.emptySegment);
            this.len = this.sourceText.getLength();
        }
        ScannerTextStream.emptySegment = new SourceTextSegment(0, 0, "");
        ScannerTextStream.prototype.max = function (a, b) {
            return a >= b ? a : b;
        };
        ScannerTextStream.prototype.min = function (a, b) {
            return a <= b ? a : b;
        };
        ScannerTextStream.prototype.fetchSegment = function (start, end) {
            if (this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd) {
                return this.agg.seg1;
            }
            if (this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd) {
                return this.agg;
            }
            var prev = this.agg.seg1;
            var s = prev.segmentEnd;
            var e = TypeScript.max(s + 512, end);
            e = TypeScript.min(e, this.len);
            var src = this.sourceText.getText(s, e);
            var newSeg = new SourceTextSegment(s, e, src);
            this.agg.seg2 = prev;
            this.agg.seg1 = newSeg;
            return this.agg;
        };
        ScannerTextStream.prototype.charCodeAt = function (index) {
            return this.fetchSegment(index, index + 1).charCodeAt(index);
        };
        ScannerTextStream.prototype.substring = function (start, end) {
            return this.fetchSegment(start, end).substring(start, end);
        };
        return ScannerTextStream;
    })();
    TypeScript.ScannerTextStream = ScannerTextStream;    
    var SavedTokens = (function () {
        function SavedTokens() {
            this.prevToken = null;
            this.curSavedToken = null;
            this.prevSavedToken = null;
            this.currentToken = 0;
            this.tokens = new Array();
            this.seenUnicodeChar = false;
            this.seenUnicodeCharInComment = false;
            this.prevLine = 1;
            this.line = 1;
            this.col = 0;
            this.lexState = 0 /* Start */ ;
            this.commentStack = new Array();
            this.lineMap = [];
        }
        SavedTokens.prototype.previousToken = function () {
            return this.prevToken;
        };
        SavedTokens.prototype.addToken = function (tok, scanner) {
            this.tokens[this.currentToken++] = new TypeScript.SavedToken(tok, scanner.startPos, scanner.pos);
        };
        SavedTokens.prototype.scan = function () {
            this.startLine = this.line;
            this.startPos = this.col;
            if (this.currentTokenIndex == this.currentTokens.length) {
                if (this.line < this.lineMap.length) {
                    this.line++;
                    this.col = 0;
                    this.currentTokenIndex = 0;
                    this.currentTokens = this.tokensByLine[this.line];
                } else {
                    return TypeScript.staticTokens[105 /* EndOfFile */ ];
                }
            }
            if (this.currentTokenIndex < this.currentTokens.length) {
                this.prevToken = this.curSavedToken.tok;
                this.prevSavedToken = this.curSavedToken;
                this.curSavedToken = this.currentTokens[this.currentTokenIndex++];
                var curToken = this.curSavedToken.tok;
                this.pos = this.curSavedToken.limChar;
                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar);
                this.startPos = this.curSavedToken.minChar;
                this.prevLine = this.line;
                return curToken;
            } else {
                return TypeScript.staticTokens[105 /* EndOfFile */ ];
            }
        };
        SavedTokens.prototype.lastTokenLimChar = function () {
            if (this.prevSavedToken !== null) {
                return this.prevSavedToken.limChar;
            } else {
                return 0;
            }
        };
        SavedTokens.prototype.lastTokenHadNewline = function () {
            return this.prevLine != this.startLine;
        };
        SavedTokens.prototype.getComments = function () {
            var stack = this.commentStack;
            this.commentStack = [];
            return stack;
        };
        SavedTokens.prototype.getCommentsForLine = function (line) {
            var comments = null;
            while((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {
                if (comments == null) {
                    comments = [
                        this.commentStack.shift()
                    ];
                } else {
                    comments = comments.concat([
                        this.commentStack.shift()
                    ]);
                }
            }
            return comments;
        };
        SavedTokens.prototype.resetComments = function () {
            this.commentStack = [];
        };
        SavedTokens.prototype.setSourceText = function (newSrc, textMode) {
        };
        SavedTokens.prototype.setErrorHandler = function (reportError) {
        };
        SavedTokens.prototype.getLookAheadToken = function () {
            throw new Error("Invalid operation.");
        };
        return SavedTokens;
    })();
    TypeScript.SavedTokens = SavedTokens;    
    var Scanner = (function () {
        function Scanner() {
            this.prevLine = 1;
            this.line = 1;
            this.col = 0;
            this.pos = 0;
            this.startPos = 0;
            this.len = 0;
            this.lineMap = [];
            this.ch = TypeScript.LexEOF;
            this.lexState = 0 /* Start */ ;
            this.mode = 1 /* File */ ;
            this.scanComments = true;
            this.interveningWhitespace = false;
            this.interveningWhitespacePos = 0;
            this.leftCurlyCount = 0;
            this.rightCurlyCount = 0;
            this.commentStack = new Array();
            this.saveScan = null;
            this.seenUnicodeChar = false;
            this.seenUnicodeCharInComment = false;
            this.prevTok = TypeScript.staticTokens[105 /* EndOfFile */ ];
            this.startCol = this.col;
            this.startLine = this.line;
            this.lineMap[1] = 0;
            if (!TypeScript.LexKeywordTable) {
                LexInitialize();
            }
        }
        Scanner.prototype.previousToken = function () {
            return this.prevTok;
        };
        Scanner.prototype.setSourceText = function (newSrc, textMode) {
            this.mode = textMode;
            this.scanComments = (this.mode === 0 /* Line */ );
            this.pos = 0;
            this.interveningWhitespacePos = 0;
            this.startPos = 0;
            this.line = 1;
            this.col = 0;
            this.startCol = this.col;
            this.startLine = this.line;
            this.len = 0;
            this.src = newSrc.getText(0, newSrc.getLength());
            this.len = this.src.length;
            this.lineMap = [];
            this.lineMap[1] = 0;
            this.commentStack = [];
            this.leftCurlyCount = 0;
            this.rightCurlyCount = 0;
            this.seenUnicodeChar = false;
            this.seenUnicodeCharInComment = false;
        };
        Scanner.prototype.setErrorHandler = function (reportError) {
            this.reportError = reportError;
        };
        Scanner.prototype.setText = function (newSrc, textMode) {
            this.setSourceText(new StringSourceText(newSrc), textMode);
        };
        Scanner.prototype.setScanComments = function (value) {
            this.scanComments = value;
        };
        Scanner.prototype.tokenStart = function () {
            this.startPos = this.pos;
            this.startLine = this.line;
            this.startCol = this.col;
            this.interveningWhitespace = false;
        };
        Scanner.prototype.peekChar = function () {
            if (this.pos < this.len) {
                return this.src.charCodeAt(this.pos);
            } else {
                return TypeScript.LexEOF;
            }
        };
        Scanner.prototype.peekCharAt = function (index) {
            if (index < this.len) {
                return this.src.charCodeAt(index);
            } else {
                return TypeScript.LexEOF;
            }
        };
        Scanner.prototype.IsHexDigit = function (c) {
            return ((c >= TypeScript.LexCode_0) && (c <= TypeScript.LexCode_9)) || ((c >= TypeScript.LexCode_A) && (c <= TypeScript.LexCode_F)) || ((c >= TypeScript.LexCode_a) && (c <= TypeScript.LexCode_f));
        };
        Scanner.prototype.IsOctalDigit = function (c) {
            return ((c >= TypeScript.LexCode_0) && (c <= TypeScript.LexCode_7)) || ((c >= TypeScript.LexCode_a) && (c <= TypeScript.LexCode_f));
        };
        Scanner.prototype.scanHexDigits = function () {
            var atLeastOneDigit = false;
            for(; ; ) {
                if (this.IsHexDigit(this.ch)) {
                    this.nextChar();
                    atLeastOneDigit = true;
                } else {
                    if (atLeastOneDigit) {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new TypeScript.NumberLiteralToken(parseInt(text), text);
                    } else {
                        return null;
                    }
                }
            }
        };
        Scanner.prototype.scanOctalDigits = function () {
            var atLeastOneDigit = false;
            for(; ; ) {
                if (this.IsOctalDigit(this.ch)) {
                    this.nextChar();
                    atLeastOneDigit = true;
                } else {
                    if (atLeastOneDigit) {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new TypeScript.NumberLiteralToken(parseInt(text), text);
                    } else {
                        return null;
                    }
                }
            }
        };
        Scanner.prototype.scanDecimalNumber = function (state) {
            var atLeastOneDigit = false;
            var svPos = this.pos;
            var svCol = this.col;
            for(; ; ) {
                if (LexIsDigit(this.ch)) {
                    atLeastOneDigit = true;
                    if (this.ch != TypeScript.LexCode_0 && state == 2 /* InEmptyFraction */ ) {
                        state = 1 /* InFraction */ ;
                    }
                    this.nextChar();
                } else if (this.ch == TypeScript.LexCodeDOT) {
                    if (state == 0 /* Start */ ) {
                        this.nextChar();
                        state = 2 /* InEmptyFraction */ ;
                    } else {
                        if (atLeastOneDigit) {
                            var text = this.src.substring(this.startPos, this.pos);
                            return new TypeScript.NumberLiteralToken(parseFloat(text), text);
                        } else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                } else if ((this.ch == TypeScript.LexCode_e) || (this.ch == TypeScript.LexCode_E)) {
                    if (state == 0 /* Start */ ) {
                        if (atLeastOneDigit) {
                            atLeastOneDigit = false;
                            this.nextChar();
                            state = 3 /* InExponent */ ;
                        } else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    } else if (state == 1 /* InFraction */  || state == 2 /* InEmptyFraction */ ) {
                        this.nextChar();
                        state = 3 /* InExponent */ ;
                        atLeastOneDigit = false;
                    } else {
                        if (atLeastOneDigit) {
                            var text = this.src.substring(this.startPos, this.pos);
                            return new TypeScript.NumberLiteralToken(parseFloat(text), text);
                        } else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                } else if ((this.ch == TypeScript.LexCodePLS) || (this.ch == TypeScript.LexCodeMIN)) {
                    if (state == 3 /* InExponent */ ) {
                        if (!atLeastOneDigit) {
                            this.nextChar();
                        } else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    } else if (state == 2 /* InEmptyFraction */  || state == 1 /* InFraction */ ) {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new TypeScript.NumberLiteralToken(parseFloat(text), text);
                    } else {
                        if (!atLeastOneDigit) {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        } else {
                            var text = this.src.substring(this.startPos, this.pos);
                            return new TypeScript.NumberLiteralToken(parseFloat(text), text);
                        }
                    }
                } else {
                    if (!atLeastOneDigit) {
                        this.pos = svPos;
                        this.col = svCol;
                        return null;
                    } else {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new TypeScript.NumberLiteralToken(parseFloat(text), text);
                    }
                }
            }
        };
        Scanner.prototype.scanNumber = function () {
            if (this.peekChar() == TypeScript.LexCode_0) {
                switch(this.peekCharAt(this.pos + 1)) {
                    case TypeScript.LexCode_x:
                    case TypeScript.LexCode_X:
                        this.advanceChar(2);
                        return this.scanHexDigits();
                    case TypeScript.LexCode_8:
                    case TypeScript.LexCode_9:
                    case TypeScript.LexCodeDOT:
                        return this.scanDecimalNumber(0 /* Start */ );
                    default:
                        return this.scanOctalDigits();
                }
            } else {
                return this.scanDecimalNumber(0 /* Start */ );
            }
        };
        Scanner.prototype.scanFraction = function () {
            return this.scanDecimalNumber(1 /* InFraction */ );
        };
        Scanner.prototype.newLine = function () {
            this.col = 0;
            if (this.mode == 1 /* File */ ) {
                this.line++;
                this.lineMap[this.line] = this.pos + 1;
            }
        };
        Scanner.prototype.finishMultilineComment = function () {
            var ch2;
            this.lexState = 1 /* InMultilineComment */ ;
            while(this.pos < this.len) {
                if (this.ch == TypeScript.LexCodeMUL) {
                    ch2 = this.peekCharAt(this.pos + 1);
                    if (ch2 == TypeScript.LexCodeSLH) {
                        this.advanceChar(2);
                        if (this.mode == 1 /* File */ ) {
                            this.tokenStart();
                        }
                        this.lexState = 0 /* Start */ ;
                        return true;
                    }
                } else if (this.ch == TypeScript.LexCodeNWL) {
                    this.newLine();
                    if (this.mode == 0 /* Line */ ) {
                        this.nextChar();
                        return false;
                    }
                } else if (this.ch >= TypeScript.LexCodeASCIIChars) {
                    this.seenUnicodeCharInComment = true;
                }
                this.nextChar();
            }
            return false;
        };
        Scanner.prototype.pushComment = function (comment) {
            this.commentStack.push(comment);
        };
        Scanner.prototype.getComments = function () {
            var stack = this.commentStack;
            this.commentStack = [];
            return stack;
        };
        Scanner.prototype.getCommentsForLine = function (line) {
            var comments = null;
            while((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {
                if (comments == null) {
                    comments = [
                        this.commentStack.shift()
                    ];
                } else {
                    comments = comments.concat([
                        this.commentStack.shift()
                    ]);
                }
            }
            return comments;
        };
        Scanner.prototype.resetComments = function () {
            this.commentStack = [];
        };
        Scanner.prototype.endsLine = function (c) {
            return (c == TypeScript.LexCodeNWL) || (c == TypeScript.LexCodeRET) || (c == TypeScript.LexCodeLS) || (c == TypeScript.LexCodePS);
        };
        Scanner.prototype.finishSinglelineComment = function () {
            while(this.pos < this.len) {
                if (this.endsLine(this.ch)) {
                    break;
                }
                if (this.ch >= TypeScript.LexCodeASCIIChars) {
                    this.seenUnicodeCharInComment = true;
                }
                this.nextChar();
            }
            if (this.mode == 1 /* File */ ) {
                this.tokenStart();
            }
        };
        Scanner.prototype.findClosingSLH = function () {
            var index = this.pos;
            var ch2 = this.src.charCodeAt(index);
            var prevCh = 0;
            var liveEsc = false;
            while(!this.endsLine(ch2) && (index < this.len)) {
                if ((ch2 == TypeScript.LexCodeSLH) && (!liveEsc)) {
                    return index;
                }
                prevCh = ch2;
                index++;
                if (liveEsc) {
                    liveEsc = false;
                } else {
                    liveEsc = (prevCh == TypeScript.LexCodeBSL);
                }
                ch2 = this.src.charCodeAt(index);
            }
            return -1;
        };
        Scanner.prototype.speculateRegex = function () {
            if (TypeScript.noRegexTable[this.prevTok.tokenId] != undefined) {
                return null;
            }
            var svPos = this.pos;
            var svCol = this.col;
            var index = this.findClosingSLH();
            if (index > 0) {
                var pattern = this.src.substring(svPos, index);
                var flags = "";
                this.pos = index + 1;
                this.ch = this.peekChar();
                var flagsStart = this.pos;
                while((this.ch == TypeScript.LexCode_i) || (this.ch == TypeScript.LexCode_g) || (this.ch == TypeScript.LexCode_m)) {
                    this.nextChar();
                }
                if ((this.pos - flagsStart) > 3) {
                    return null;
                } else {
                    flags = this.src.substring(flagsStart, this.pos);
                }
                var regex = undefined;
                try  {
                    regex = new RegExp(pattern, flags);
                } catch (regexException) {
                }
                if (regex) {
                    this.col = svCol + (this.pos - this.startPos);
                    return new TypeScript.RegularExpressionLiteralToken(this.src.substring(svPos - 1, this.pos));
                }
            }
            this.pos = svPos;
            this.col = svCol;
            return null;
        };
        Scanner.prototype.lastTokenHadNewline = function () {
            return this.prevLine != this.startLine;
        };
        Scanner.prototype.lastTokenLimChar = function () {
            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;
        };
        Scanner.prototype.advanceChar = function (amt) {
            this.pos += amt;
            this.col += amt;
            this.ch = this.peekChar();
        };
        Scanner.prototype.nextChar = function () {
            this.pos++;
            this.col++;
            this.ch = this.peekChar();
        };
        Scanner.prototype.getLookAheadToken = function () {
            var prevLine = this.prevLine;
            var line = this.line;
            var col = this.col;
            var pos = this.pos;
            var startPos = this.startPos;
            var startCol = this.startCol;
            var startLine = this.startLine;
            var ch = this.ch;
            var prevTok = this.prevTok;
            var lexState = this.lexState;
            var interveningWhitespace = this.interveningWhitespace;
            var interveningWhitespacePos = this.interveningWhitespacePos;
            var leftCurlyCount = this.leftCurlyCount;
            var rightCurlyCount = this.rightCurlyCount;
            var seenUnicodeChar = this.seenUnicodeChar;
            var seenUnicodeCharInComment = this.seenUnicodeCharInComment;
            var commentStackLength = this.commentStack.length;
            var lookAheadToken = this.scan();
            this.prevLine = prevLine;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.startPos = startPos;
            this.startCol = startCol;
            this.startLine = startLine;
            this.ch = ch;
            this.prevTok = prevTok;
            this.lexState = lexState;
            this.interveningWhitespace = interveningWhitespace;
            this.interveningWhitespacePos = interveningWhitespacePos;
            this.leftCurlyCount = leftCurlyCount;
            this.rightCurlyCount = rightCurlyCount;
            this.seenUnicodeChar = seenUnicodeChar;
            this.seenUnicodeCharInComment = seenUnicodeCharInComment;
            this.commentStack.length = commentStackLength;
            return lookAheadToken;
        };
        Scanner.prototype.scanInLine = function () {
            if ((this.lexState == 1 /* InMultilineComment */ ) && (this.scanComments)) {
                this.ch = this.peekChar();
                var commentLine = this.line;
                this.finishMultilineComment();
                if (this.startPos < this.pos) {
                    var commentText = this.src.substring(this.startPos, this.pos);
                    this.tokenStart();
                    return new TypeScript.CommentToken(112 /* Comment */ , commentText, true, this.startPos, commentLine, true);
                } else {
                    return TypeScript.staticTokens[105 /* EndOfFile */ ];
                }
            } else if (this.lexState == 2 /* InMultilineSingleQuoteString */  && this.pos < this.len) {
                this.ch = this.peekChar();
                this.lexState = 0 /* Start */ ;
                return this.scanStringConstant(TypeScript.LexCodeAPO);
            } else if (this.lexState == 3 /* InMultilineDoubleQuoteString */  && this.pos < this.len) {
                this.ch = this.peekChar();
                this.lexState = 0 /* Start */ ;
                return this.scanStringConstant(TypeScript.LexCodeQUO);
            }
            this.prevLine = this.line;
            var prevTok = this.innerScan();
            if (prevTok.tokenId != 111 /* Whitespace */ ) {
                this.prevTok = prevTok;
            }
            return prevTok;
        };
        Scanner.prototype.scan = function () {
            this.prevLine = this.line;
            this.prevTok = this.innerScan();
            if (this.saveScan) {
                this.saveScan.addToken(this.prevTok, this);
            }
            return this.prevTok;
        };
        Scanner.prototype.isValidUnicodeIdentifierChar = function () {
            var valid = LexIsUnicodeIdStart(this.ch) || LexIsUnicodeDigit(this.ch);
            this.seenUnicodeChar = this.seenUnicodeChar || valid;
            return valid;
        };
        Scanner.prototype.scanStringConstant = function (endCode) {
            scanStringConstantLoop:
for(; ; ) {
                switch(this.ch) {
                    case TypeScript.LexEOF:
                        this.reportScannerError("Unterminated string constant");
                        break scanStringConstantLoop;
                    case TypeScript.LexCodeLS:
                    case TypeScript.LexCodePS:
                        this.seenUnicodeChar = true;
                    case TypeScript.LexCodeRET:
                    case TypeScript.LexCodeNWL:
                        this.reportScannerError("Unterminated string constant");
                        break scanStringConstantLoop;
                    case TypeScript.LexCodeAPO:
                    case TypeScript.LexCodeQUO:
                        if (this.ch == endCode) {
                            this.nextChar();
                            break scanStringConstantLoop;
                        }
                        break;
                    case TypeScript.LexCodeBSL:
                        this.nextChar();
                        switch(this.ch) {
                            case TypeScript.LexCodeAPO:
                            case TypeScript.LexCodeQUO:
                            case TypeScript.LexCodeBSL:
                                this.nextChar();
                                continue scanStringConstantLoop;
                            case TypeScript.LexCodeLS:
                            case TypeScript.LexCodePS:
                                this.seenUnicodeChar = true;
                            case TypeScript.LexCodeRET:
                            case TypeScript.LexCodeNWL:
                                if (this.ch == TypeScript.LexCodeRET && this.peekCharAt(this.pos + 1) == TypeScript.LexCodeNWL) {
                                    this.nextChar();
                                }
                                this.newLine();
                                if (this.mode == 0 /* Line */ ) {
                                    this.nextChar();
                                    this.lexState = endCode == TypeScript.LexCodeAPO ? 2 /* InMultilineSingleQuoteString */  : 3 /* InMultilineDoubleQuoteString */ ;
                                    break scanStringConstantLoop;
                                }
                                break;
                            case TypeScript.LexCode_x:
                            case TypeScript.LexCode_u:
                                var expectedHexDigits = this.ch == TypeScript.LexCode_x ? 2 : 4;
                                this.nextChar();
                                for(var i = 0; i < expectedHexDigits; i++) {
                                    if (this.IsHexDigit(this.ch)) {
                                        this.nextChar();
                                    } else {
                                        this.reportScannerError("Invalid Unicode escape sequence");
                                        break;
                                    }
                                }
                                continue scanStringConstantLoop;
                        }
                        break;
                }
                if (this.ch >= TypeScript.LexCodeASCIIChars) {
                    this.seenUnicodeChar = true;
                }
                this.nextChar();
            }
            return new TypeScript.StringLiteralToken(this.src.substring(this.startPos, this.pos));
        };
        Scanner.prototype.scanIdentifier = function () {
            var hasEscape = false;
            var isFirstChar = (this.ch == TypeScript.LexCodeBSL);
            var hasUnicode = false;
            for(; ; ) {
                while(lexIdStartTable[this.ch] || LexIsDigit(this.ch) || (this.ch >= TypeScript.LexCodeASCIIChars && this.isValidUnicodeIdentifierChar())) {
                    this.nextChar();
                }
                if (this.ch == TypeScript.LexCodeBSL) {
                    this.nextChar();
                    if (this.ch == TypeScript.LexCode_u) {
                        this.nextChar();
                        for(var h = 0; h < 4; h++) {
                            if (this.IsHexDigit(this.ch)) {
                                this.nextChar();
                            } else {
                                this.reportScannerError("Invalid Unicode escape sequence");
                                return TypeScript.staticTokens[104 /* Error */ ];
                            }
                        }
                        var hexChar = parseInt(this.src.substring(this.pos - 4, this.pos), 16);
                        if (lexIdStartTable[hexChar] || (!isFirstChar && LexIsDigit(hexChar)) || (hexChar >= TypeScript.LexCodeASCIIChars && (LexIsUnicodeIdStart(hexChar) || (!isFirstChar && LexIsUnicodeDigit(hexChar))))) {
                        } else {
                            this.reportScannerError("Invalid identifier character");
                            return TypeScript.staticTokens[104 /* Error */ ];
                        }
                        hasEscape = true;
                        isFirstChar = false;
                        continue;
                    }
                    this.reportScannerError("Invalid Unicode escape sequence");
                    return TypeScript.staticTokens[104 /* Error */ ];
                }
                break;
            }
            var id;
            var text = this.src.substring(this.startPos, this.pos);
            if (!hasEscape && (id = TypeScript.LexKeywordTable.lookup(text)) != null) {
                return TypeScript.staticTokens[id];
            } else {
                return new TypeScript.IdentifierToken(text, hasEscape);
            }
        };
        Scanner.prototype.innerScan = function () {
            var rtok;
            this.tokenStart();
            this.ch = this.peekChar();
            start:
while(this.pos < this.len) {
                if (lexIdStartTable[this.ch] || this.ch == TypeScript.LexCodeBSL || (this.ch >= TypeScript.LexCodeASCIIChars && LexIsUnicodeIdStart(this.ch))) {
                    return this.scanIdentifier();
                } else if (this.ch == TypeScript.LexCodeSpace) {
                    if (!this.interveningWhitespace) {
                        this.interveningWhitespacePos = this.pos;
                    }
                    do {
                        this.nextChar();
                    } while(this.ch == TypeScript.LexCodeSpace);
                    if (this.mode == 0 /* Line */ ) {
                        var whitespaceText = this.src.substring(this.startPos, this.pos);
                        return new TypeScript.WhitespaceToken(111 /* Whitespace */ , whitespaceText);
                    } else {
                        this.tokenStart();
                        this.interveningWhitespace = true;
                    }
                } else if (this.ch == TypeScript.LexCodeSLH) {
                    this.nextChar();
                    var commentText;
                    if (this.ch == TypeScript.LexCodeSLH) {
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos - 1;
                        }
                        var commentStartPos = this.pos - 1;
                        var commentStartLine = this.line;
                        this.finishSinglelineComment();
                        var commentText = this.src.substring(commentStartPos, this.pos);
                        var commentToken = new TypeScript.CommentToken(112 /* Comment */ , commentText, false, commentStartPos, commentStartLine, false);
                        if (this.scanComments) {
                            this.startPos = commentStartPos;
                            return commentToken;
                        } else {
                            this.pushComment(commentToken);
                        }
                        this.interveningWhitespace = true;
                    } else if (this.ch == TypeScript.LexCodeMUL) {
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos - 1;
                        }
                        var commentStartPos = this.pos - 1;
                        var commentStartLine = this.line;
                        this.nextChar();
                        this.finishMultilineComment();
                        var commentText = this.src.substring(commentStartPos, this.pos);
                        var endsLine = this.endsLine(this.peekChar());
                        var commentToken = new TypeScript.CommentToken(112 /* Comment */ , commentText, true, commentStartPos, commentStartLine, endsLine);
                        if (this.scanComments) {
                            this.startPos = commentStartPos;
                            return commentToken;
                        } else {
                            this.pushComment(commentToken);
                        }
                        this.interveningWhitespace = true;
                    } else {
                        var regexTok = this.speculateRegex();
                        if (regexTok) {
                            return regexTok;
                        } else {
                            if (this.peekCharAt(this.pos) == TypeScript.LexCodeEQ) {
                                this.nextChar();
                                return TypeScript.staticTokens[67 /* SlashEquals */ ];
                            } else {
                                return TypeScript.staticTokens[96 /* Slash */ ];
                            }
                        }
                    }
                } else if (this.ch == TypeScript.LexCodeSMC) {
                    this.nextChar();
                    return TypeScript.staticTokens[55 /* Semicolon */ ];
                } else if ((this.ch == TypeScript.LexCodeAPO) || (this.ch == TypeScript.LexCodeQUO)) {
                    var endCode = this.ch;
                    this.nextChar();
                    return this.scanStringConstant(endCode);
                } else if (autoToken[this.ch]) {
                    var atok = autoToken[this.ch];
                    if (atok.tokenId == 60 /* OpenBrace */ ) {
                        this.leftCurlyCount++;
                    } else if (atok.tokenId == 61 /* CloseBrace */ ) {
                        this.rightCurlyCount++;
                    }
                    this.nextChar();
                    return atok;
                } else if ((this.ch >= TypeScript.LexCode_0) && (this.ch <= TypeScript.LexCode_9)) {
                    rtok = this.scanNumber();
                    if (rtok) {
                        return rtok;
                    } else {
                        this.nextChar();
                        return TypeScript.staticTokens[104 /* Error */ ];
                    }
                } else {
                    switch(this.ch) {
                        case TypeScript.LexCodeTAB:
                        case TypeScript.LexCodeVTAB:
                            if (!this.interveningWhitespace) {
                                this.interveningWhitespacePos = this.pos;
                            }
                            if (this.mode == 0 /* Line */ ) {
                                do {
                                    this.nextChar();
                                } while((this.ch == TypeScript.LexCodeSpace) || (this.ch == 9));
                                var wsText = this.src.substring(this.startPos, this.pos);
                                return new TypeScript.WhitespaceToken(111 /* Whitespace */ , wsText);
                            } else {
                                this.interveningWhitespace = true;
                            }
                        case 0xFF:
                        case 0xFE:
                        case 0xEF:
                        case 0xBB:
                        case 0xBF:
                        case TypeScript.LexCodeLS:
                        case TypeScript.LexCodePS:
                        case TypeScript.LexCodeNWL:
                        case TypeScript.LexCodeRET:
                            if (this.ch == TypeScript.LexCodeNWL) {
                                this.newLine();
                                if (this.mode == 0 /* Line */ ) {
                                    return TypeScript.staticTokens[105 /* EndOfFile */ ];
                                }
                            }
                            if (!this.interveningWhitespace) {
                                this.interveningWhitespacePos = this.pos;
                            }
                            this.nextChar();
                            this.tokenStart();
                            this.interveningWhitespace = true;
                            break;
                        case TypeScript.LexCodeDOT: {
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeDOT) {
                                if (this.peekCharAt(this.pos + 2) == TypeScript.LexCodeDOT) {
                                    this.advanceChar(3);
                                    return TypeScript.staticTokens[103 /* DotDotDot */ ];
                                } else {
                                    this.nextChar();
                                    return TypeScript.staticTokens[102 /* Dot */ ];
                                }
                            } else {
                                this.nextChar();
                                rtok = this.scanFraction();
                                if (rtok) {
                                    return rtok;
                                } else {
                                    return TypeScript.staticTokens[102 /* Dot */ ];
                                }
                            }
                        }
                        case TypeScript.LexCodeEQ:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                if (this.peekCharAt(this.pos + 2) == TypeScript.LexCodeEQ) {
                                    this.advanceChar(3);
                                    return TypeScript.staticTokens[84 /* EqualsEqualsEquals */ ];
                                } else {
                                    this.advanceChar(2);
                                    return TypeScript.staticTokens[82 /* EqualsEquals */ ];
                                }
                            } else if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeGT) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[106 /* EqualsGreaterThan */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[63 /* Equals */ ];
                            }
                        case TypeScript.LexCodeBNG:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                if (this.peekCharAt(this.pos + 2) == TypeScript.LexCodeEQ) {
                                    this.advanceChar(3);
                                    return TypeScript.staticTokens[85 /* ExclamationEqualsEquals */ ];
                                } else {
                                    this.advanceChar(2);
                                    return TypeScript.staticTokens[83 /* ExclamationEquals */ ];
                                }
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[99 /* Exclamation */ ];
                            }
                        case TypeScript.LexCodePLS:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[64 /* PlusEquals */ ];
                            } else if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodePLS) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[100 /* PlusPlus */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[93 /* Plus */ ];
                            }
                        case TypeScript.LexCodeMIN:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[65 /* MinusEquals */ ];
                            } else if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeMIN) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[101 /* MinusMinus */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[94 /* Minus */ ];
                            }
                        case TypeScript.LexCodeMUL:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[66 /* AsteriskEquals */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[95 /* Asterisk */ ];
                            }
                        case TypeScript.LexCodePCT:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[68 /* PercentEquals */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[97 /* Percent */ ];
                            }
                        case TypeScript.LexCodeLT:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeLT) {
                                if (this.peekCharAt(this.pos + 2) == TypeScript.LexCodeEQ) {
                                    this.advanceChar(3);
                                    return TypeScript.staticTokens[72 /* LessThanLessThanEquals */ ];
                                } else {
                                    this.advanceChar(2);
                                    return TypeScript.staticTokens[90 /* LessThanLessThan */ ];
                                }
                            } else if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[87 /* LessThanEquals */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[86 /* LessThan */ ];
                            }
                        case TypeScript.LexCodeGT:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeGT) {
                                if (this.peekCharAt(this.pos + 2) == TypeScript.LexCodeEQ) {
                                    this.advanceChar(3);
                                    return TypeScript.staticTokens[73 /* GreaterThanGreaterThanEquals */ ];
                                } else if (this.peekCharAt(this.pos + 2) == TypeScript.LexCodeGT) {
                                    if (this.peekCharAt(this.pos + 3) == TypeScript.LexCodeEQ) {
                                        this.advanceChar(4);
                                        return TypeScript.staticTokens[74 /* GreaterThanGreaterThanGreaterThanEquals */ ];
                                    } else {
                                        this.advanceChar(3);
                                        return TypeScript.staticTokens[92 /* GreaterThanGreaterThanGreaterThan */ ];
                                    }
                                } else {
                                    this.advanceChar(2);
                                    return TypeScript.staticTokens[91 /* GreaterThanGreaterThan */ ];
                                }
                            } else if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[89 /* GreaterThanEquals */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[88 /* GreaterThan */ ];
                            }
                        case TypeScript.LexCodeXOR:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[70 /* CaretEquals */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[80 /* Caret */ ];
                            }
                        case TypeScript.LexCodeBAR:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[71 /* BarEquals */ ];
                            } else if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeBAR) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[77 /* BarBar */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[79 /* Bar */ ];
                            }
                        case TypeScript.LexCodeAMP:
                            if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeEQ) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[69 /* AmpersandEquals */ ];
                            } else if (this.peekCharAt(this.pos + 1) == TypeScript.LexCodeAMP) {
                                this.advanceChar(2);
                                return TypeScript.staticTokens[78 /* AmpersandAmpersand */ ];
                            } else {
                                this.nextChar();
                                return TypeScript.staticTokens[81 /* And */ ];
                            }
                        default:
                            this.reportScannerError("Invalid character");
                            this.nextChar();
                            continue start;
                    }
                }
            }
            return TypeScript.staticTokens[105 /* EndOfFile */ ];
        };
        Scanner.prototype.reportScannerError = function (message) {
            if (this.reportError) {
                this.reportError(message);
            }
        };
        return Scanner;
    })();
    TypeScript.Scanner = Scanner;    
    function convertTokToIDName(tok) {
        return convertTokToIDBase(tok, true, false);
    }
    TypeScript.convertTokToIDName = convertTokToIDName;
    function convertTokToID(tok, strictMode) {
        return convertTokToIDBase(tok, false, strictMode);
    }
    TypeScript.convertTokToID = convertTokToID;
    function convertTokToIDBase(tok, identifierName, strictMode) {
        if (tok.tokenId <= 54 /* LimKeyword */ ) {
            var tokInfo = TypeScript.lookupToken(tok.tokenId);
            if (tokInfo != undefined) {
                var resFlags = 1 /* Javascript */  | 2 /* JavascriptFuture */ ;
                if (strictMode) {
                    resFlags |= 8 /* JavascriptFutureStrict */ ;
                }
                if (identifierName || !TypeScript.hasFlag(tokInfo.reservation, resFlags)) {
                    return true;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
    function getLineNumberFromPosition(lineMap, position) {
        if (position === -1) {
            return 0;
        }
        var min = 0;
        var max = lineMap.length - 1;
        while(min < max) {
            var med = (min + max) >> 1;
            if (position < lineMap[med]) {
                max = med - 1;
            } else if (position < lineMap[med + 1]) {
                min = max = med;
            } else {
                min = med + 1;
            }
        }
        return min;
    }
    TypeScript.getLineNumberFromPosition = getLineNumberFromPosition;
    function getSourceLineColFromMap(lineCol, minChar, lineMap) {
        var line = getLineNumberFromPosition(lineMap, minChar);
        if (line > 0) {
            lineCol.line = line;
            lineCol.col = (minChar - lineMap[line]);
        }
    }
    TypeScript.getSourceLineColFromMap = getSourceLineColFromMap;
    function getLineColumnFromPosition(script, position) {
        var result = {
            line: -1,
            col: -1
        };
        getSourceLineColFromMap(result, position, script.locationInfo.lineMap);
        if (result.col >= 0) {
            result.col++;
        }
        return result;
    }
    TypeScript.getLineColumnFromPosition = getLineColumnFromPosition;
    function getPositionFromLineColumn(script, line, column) {
        return script.locationInfo.lineMap[line] + (column - 1);
    }
    TypeScript.getPositionFromLineColumn = getPositionFromLineColumn;
    function isPrimitiveTypeToken(token) {
        switch(token.tokenId) {
            case 0 /* Any */ :
            case 1 /* Bool */ :
            case 32 /* Number */ :
            case 42 /* String */ :
                return true;
        }
        return false;
    }
    TypeScript.isPrimitiveTypeToken = isPrimitiveTypeToken;
    function isModifier(token) {
        switch(token.tokenId) {
            case 37 /* Public */ :
            case 35 /* Private */ :
            case 40 /* Static */ :
            case 41 /* Inline */ :
                return true;
        }
        return false;
    }
    TypeScript.isModifier = isModifier;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AssignScopeContext = (function () {
        function AssignScopeContext(scopeChain, typeFlow, modDeclChain) {
            this.scopeChain = scopeChain;
            this.typeFlow = typeFlow;
            this.modDeclChain = modDeclChain;
        }
        return AssignScopeContext;
    })();
    TypeScript.AssignScopeContext = AssignScopeContext;    
    function pushAssignScope(scope, context, type, classType, fnc) {
        var chain = new TypeScript.ScopeChain(null, context.scopeChain, scope);
        chain.thisType = type;
        chain.classType = classType;
        chain.fnc = fnc;
        context.scopeChain = chain;
    }
    TypeScript.pushAssignScope = pushAssignScope;
    function popAssignScope(context) {
        context.scopeChain = context.scopeChain.previous;
    }
    TypeScript.popAssignScope = popAssignScope;
    function instanceCompare(a, b) {
        if (((a == null) || (!a.isInstanceProperty()))) {
            return b;
        } else {
            return a;
        }
    }
    TypeScript.instanceCompare = instanceCompare;
    function instanceFilterStop(s) {
        return s.isInstanceProperty();
    }
    TypeScript.instanceFilterStop = instanceFilterStop;
    var ScopeSearchFilter = (function () {
        function ScopeSearchFilter(select, stop) {
            this.select = select;
            this.stop = stop;
            this.result = null;
        }
        ScopeSearchFilter.prototype.reset = function () {
            this.result = null;
        };
        ScopeSearchFilter.prototype.update = function (b) {
            this.result = this.select(this.result, b);
            if (this.result) {
                return this.stop(this.result);
            } else {
                return false;
            }
        };
        return ScopeSearchFilter;
    })();
    TypeScript.ScopeSearchFilter = ScopeSearchFilter;    
    TypeScript.instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);
    function preAssignModuleScopes(ast, context) {
        var moduleDecl = ast;
        var memberScope = null;
        var aggScope = null;
        if (moduleDecl.name && moduleDecl.mod) {
            moduleDecl.name.sym = moduleDecl.mod.symbol;
        }
        var mod = moduleDecl.mod;
        if (!mod) {
            return;
        }
        memberScope = new TypeScript.SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);
        mod.memberScope = memberScope;
        context.modDeclChain.push(moduleDecl);
        context.typeFlow.checker.currentModDecl = moduleDecl;
        aggScope = new TypeScript.SymbolAggregateScope(mod.symbol);
        aggScope.addParentScope(memberScope);
        aggScope.addParentScope(context.scopeChain.scope);
        pushAssignScope(aggScope, context, null, null, null);
        mod.containedScope = aggScope;
        if (mod.symbol) {
            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);
        }
    }
    TypeScript.preAssignModuleScopes = preAssignModuleScopes;
    function preAssignClassScopes(ast, context) {
        var classDecl = ast;
        var memberScope = null;
        var aggScope = null;
        if (classDecl.name && classDecl.type) {
            classDecl.name.sym = classDecl.type.symbol;
        }
        var classType = ast.type;
        if (classType) {
            var classSym = classType.symbol;
            memberScope = context.typeFlow.checker.scopeOf(classType);
            aggScope = new TypeScript.SymbolAggregateScope(classType.symbol);
            aggScope.addParentScope(memberScope);
            aggScope.addParentScope(context.scopeChain.scope);
            classType.containedScope = aggScope;
            classType.memberScope = memberScope;
            var instanceType = classType.instanceType;
            memberScope = context.typeFlow.checker.scopeOf(instanceType);
            instanceType.memberScope = memberScope;
            aggScope = new TypeScript.SymbolAggregateScope(instanceType.symbol);
            aggScope.addParentScope(context.scopeChain.scope);
            pushAssignScope(aggScope, context, instanceType, classType, null);
            instanceType.containedScope = aggScope;
        } else {
            ast.type = context.typeFlow.anyType;
        }
    }
    TypeScript.preAssignClassScopes = preAssignClassScopes;
    function preAssignInterfaceScopes(ast, context) {
        var interfaceDecl = ast;
        var memberScope = null;
        var aggScope = null;
        if (interfaceDecl.name && interfaceDecl.type) {
            interfaceDecl.name.sym = interfaceDecl.type.symbol;
        }
        var interfaceType = ast.type;
        memberScope = context.typeFlow.checker.scopeOf(interfaceType);
        interfaceType.memberScope = memberScope;
        aggScope = new TypeScript.SymbolAggregateScope(interfaceType.symbol);
        aggScope.addParentScope(memberScope);
        aggScope.addParentScope(context.scopeChain.scope);
        pushAssignScope(aggScope, context, null, null, null);
        interfaceType.containedScope = aggScope;
    }
    TypeScript.preAssignInterfaceScopes = preAssignInterfaceScopes;
    function preAssignWithScopes(ast, context) {
        var withStmt = ast;
        var withType = withStmt.type;
        var members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
        var ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
        var withType = new TypeScript.Type();
        var withSymbol = new TypeScript.WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType);
        withType.members = members;
        withType.ambientMembers = ambientMembers;
        withType.symbol = withSymbol;
        withType.setHasImplementation();
        withStmt.type = withType;
        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);
        pushAssignScope(withScope, context, null, null, null);
        withType.containedScope = withScope;
    }
    TypeScript.preAssignWithScopes = preAssignWithScopes;
    function preAssignFuncDeclScopes(ast, context) {
        var funcDecl = ast;
        var container = null;
        var localContainer = null;
        if (funcDecl.type) {
            localContainer = ast.type.symbol;
        }
        var isStatic = TypeScript.hasFlag(funcDecl.fncFlags, 16 /* Static */ );
        var isInnerStatic = isStatic && context.scopeChain.fnc != null;
        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;
        if (context.scopeChain.thisType && (!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ ))) {
            var instType = context.scopeChain.thisType;
            if (!(instType.typeFlags & 128 /* IsClass */ ) && !TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) {
                if (!funcDecl.isMethod() || isStatic) {
                    parentScope = instType.constructorScope;
                } else {
                    parentScope = instType.containedScope;
                }
            } else {
                if (context.scopeChain.previous.scope.container && context.scopeChain.previous.scope.container.declAST && context.scopeChain.previous.scope.container.declAST.nodeType == 73 /* FuncDecl */  && (context.scopeChain.previous.scope.container.declAST).isConstructor) {
                    parentScope = instType.constructorScope;
                } else if (isStatic && context.scopeChain.classType) {
                    parentScope = context.scopeChain.classType.containedScope;
                } else {
                    parentScope = instType.containedScope;
                }
            }
            container = instType.symbol;
        } else if (funcDecl.isConstructor && context.scopeChain.thisType) {
            container = context.scopeChain.thisType.symbol;
        }
        if (funcDecl.type == null || TypeScript.hasFlag(funcDecl.type.symbol.flags, 16384 /* TypeSetDuringScopeAssignment */ )) {
            if (context.scopeChain.fnc && context.scopeChain.fnc.type) {
                container = context.scopeChain.fnc.type.symbol;
            }
            var funcScope = null;
            var outerFnc = context.scopeChain.fnc;
            var nameText = funcDecl.name ? funcDecl.name.actualText : null;
            var fgSym = null;
            if (isStatic) {
                if (outerFnc.type.members == null && container.getType().memberScope) {
                    outerFnc.type.members = ((container).type.memberScope).valueMembers;
                }
                funcScope = context.scopeChain.fnc.type.memberScope;
                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;
            } else {
                funcScope = context.scopeChain.scope;
            }
            if (nameText && nameText != "__missing" && !funcDecl.isAccessor()) {
                if (isStatic) {
                    fgSym = funcScope.findLocal(nameText, false, false);
                } else {
                    fgSym = funcScope.findLocal(nameText, false, false);
                }
            }
            context.typeFlow.checker.createFunctionSignature(funcDecl, container, funcScope, fgSym, fgSym == null);
            if (!funcDecl.accessorSymbol && (funcDecl.fncFlags & 262144 /* ClassMethod */ ) && container && ((!fgSym || fgSym.declAST.nodeType != 73 /* FuncDecl */ ) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {
                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);
            }
            funcDecl.type.symbol.flags |= 16384 /* TypeSetDuringScopeAssignment */ ;
        }
        if (funcDecl.name && funcDecl.type) {
            funcDecl.name.sym = funcDecl.type.symbol;
        }
        funcDecl.scopeType = funcDecl.type;
        if (funcDecl.isOverload) {
            return;
        }
        var funcTable = new TypeScript.StringHashTable();
        var funcMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(funcTable, new TypeScript.StringHashTable()));
        var ambientFuncTable = new TypeScript.StringHashTable();
        var ambientFuncMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(ambientFuncTable, new TypeScript.StringHashTable()));
        var funcStaticTable = new TypeScript.StringHashTable();
        var funcStaticMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(funcStaticTable, new TypeScript.StringHashTable()));
        var ambientFuncStaticTable = new TypeScript.StringHashTable();
        var ambientFuncStaticMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(ambientFuncStaticTable, new TypeScript.StringHashTable()));
        funcDecl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex;
        var locals = new TypeScript.SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);
        var statics = new TypeScript.SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);
        if (funcDecl.isConstructor && context.scopeChain.thisType) {
            context.scopeChain.thisType.constructorScope = locals;
        }
        funcDecl.symbols = funcTable;
        if (!funcDecl.isSpecialFn()) {
            var group = funcDecl.type;
            var signature = funcDecl.signature;
            if (!funcDecl.isConstructor) {
                group.containedScope = locals;
                locals.container = group.symbol;
                group.memberScope = statics;
                statics.container = group.symbol;
            }
            funcDecl.enclosingFnc = context.scopeChain.fnc;
            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;
            var fgSym = ast.type.symbol;
            if (((funcDecl.fncFlags & 512 /* Signature */ ) == 0 /* None */ ) && funcDecl.vars) {
                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars, funcTable, false);
                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics, funcStaticTable, false);
            }
            if (signature.parameters) {
                var len = signature.parameters.length;
                for(var i = 0; i < len; i++) {
                    var paramSym = signature.parameters[i];
                    context.typeFlow.checker.resolveTypeLink(locals, paramSym.parameter.typeLink, true);
                }
            }
            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType, funcDecl.isSignature());
        }
        if (!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) {
            var thisType = (funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) ? context.scopeChain.thisType : null;
            pushAssignScope(locals, context, thisType, null, funcDecl);
        }
        if (funcDecl.name && TypeScript.hasFlag(funcDecl.fncFlags, 131072 /* IsFunctionExpression */ ) && !funcDecl.isAccessor()) {
            if (funcDecl.name.sym) {
                funcTable.add(funcDecl.name.actualText, funcDecl.name.sym);
            }
        }
    }
    TypeScript.preAssignFuncDeclScopes = preAssignFuncDeclScopes;
    function preAssignCatchScopes(ast, context) {
        var catchBlock = ast;
        if (catchBlock.param) {
            var catchTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            var catchLocals = new TypeScript.SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope, context.scopeChain.scope.container);
            catchBlock.containedScope = catchLocals;
            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);
        }
    }
    TypeScript.preAssignCatchScopes = preAssignCatchScopes;
    function preAssignScopes(ast, parent, walker) {
        var context = walker.state;
        var go = true;
        if (ast) {
            if (ast.nodeType == 94 /* List */ ) {
                var list = ast;
                list.enclosingScope = context.scopeChain.scope;
            } else if (ast.nodeType == 98 /* ModuleDeclaration */ ) {
                preAssignModuleScopes(ast, context);
            } else if (ast.nodeType == 96 /* ClassDeclaration */ ) {
                preAssignClassScopes(ast, context);
            } else if (ast.nodeType == 97 /* InterfaceDeclaration */ ) {
                preAssignInterfaceScopes(ast, context);
            } else if (ast.nodeType == 100 /* With */ ) {
                preAssignWithScopes(ast, context);
            } else if (ast.nodeType == 73 /* FuncDecl */ ) {
                preAssignFuncDeclScopes(ast, context);
            } else if (ast.nodeType == 93 /* Catch */ ) {
                preAssignCatchScopes(ast, context);
            } else if (ast.nodeType == 28 /* TypeRef */ ) {
                go = false;
            }
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.preAssignScopes = preAssignScopes;
    function postAssignScopes(ast, parent, walker) {
        var context = walker.state;
        var go = true;
        if (ast) {
            if (ast.nodeType == 98 /* ModuleDeclaration */ ) {
                var prevModDecl = ast;
                popAssignScope(context);
                context.modDeclChain.pop();
                if (context.modDeclChain.length >= 1) {
                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];
                }
            } else if (ast.nodeType == 96 /* ClassDeclaration */ ) {
                popAssignScope(context);
            } else if (ast.nodeType == 97 /* InterfaceDeclaration */ ) {
                popAssignScope(context);
            } else if (ast.nodeType == 100 /* With */ ) {
                popAssignScope(context);
            } else if (ast.nodeType == 73 /* FuncDecl */ ) {
                var funcDecl = ast;
                if ((!funcDecl.isConstructor || TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) && !funcDecl.isOverload) {
                    popAssignScope(context);
                }
            } else if (ast.nodeType == 93 /* Catch */ ) {
                var catchBlock = ast;
                if (catchBlock.param) {
                    popAssignScope(context);
                }
            } else {
                go = false;
            }
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.postAssignScopes = postAssignScopes;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TypeCollectionContext = (function () {
        function TypeCollectionContext(scopeChain, checker) {
            this.scopeChain = scopeChain;
            this.checker = checker;
            this.script = null;
        }
        return TypeCollectionContext;
    })();
    TypeScript.TypeCollectionContext = TypeCollectionContext;    
    var MemberScopeContext = (function () {
        function MemberScopeContext(flow, pos, matchFlag) {
            this.flow = flow;
            this.pos = pos;
            this.matchFlag = matchFlag;
            this.type = null;
            this.ast = null;
            this.options = new TypeScript.AstWalkOptions();
        }
        return MemberScopeContext;
    })();
    TypeScript.MemberScopeContext = MemberScopeContext;    
    var EnclosingScopeContext = (function () {
        function EnclosingScopeContext(logger, script, text, pos, isMemberCompletion) {
            this.logger = logger;
            this.script = script;
            this.text = text;
            this.pos = pos;
            this.isMemberCompletion = isMemberCompletion;
            this.scopeGetter = null;
            this.objectLiteralScopeGetter = null;
            this.scopeStartAST = null;
            this.skipNextFuncDeclForClass = false;
            this.deepestModuleDecl = null;
            this.enclosingClassDecl = null;
            this.enclosingObjectLit = null;
            this.publicsOnly = true;
            this.useFullAst = false;
        }
        EnclosingScopeContext.prototype.getScope = function () {
            return this.scopeGetter();
        };
        EnclosingScopeContext.prototype.getObjectLiteralScope = function () {
            return this.objectLiteralScopeGetter();
        };
        EnclosingScopeContext.prototype.getScopeAST = function () {
            return this.scopeStartAST;
        };
        EnclosingScopeContext.prototype.getScopePosition = function () {
            return this.scopeStartAST.minChar;
        };
        EnclosingScopeContext.prototype.getScriptFragmentStartAST = function () {
            return this.scopeStartAST;
        };
        EnclosingScopeContext.prototype.getScriptFragmentPosition = function () {
            return this.getScriptFragmentStartAST().minChar;
        };
        EnclosingScopeContext.prototype.getScriptFragment = function () {
            if (this.scriptFragment == null) {
                var ast = this.getScriptFragmentStartAST();
                var minChar = ast.minChar;
                var limChar = (this.isMemberCompletion ? this.pos : this.pos + 1);
                this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null).Script;
            }
            return this.scriptFragment;
        };
        return EnclosingScopeContext;
    })();
    TypeScript.EnclosingScopeContext = EnclosingScopeContext;    
    function preFindMemberScope(ast, parent, walker) {
        var memScope = walker.state;
        if (TypeScript.hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {
            memScope.ast = ast;
            if ((ast.type == null) && (memScope.pos >= 0)) {
                memScope.flow.inScopeTypeCheck(ast, memScope.scope);
            }
            memScope.type = ast.type;
            memScope.options.stopWalk();
        }
        return ast;
    }
    TypeScript.preFindMemberScope = preFindMemberScope;
    function pushTypeCollectionScope(container, valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, context, thisType, classType, moduleDecl) {
        var builder = new TypeScript.SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);
        var chain = new TypeScript.ScopeChain(container, context.scopeChain, builder);
        chain.thisType = thisType;
        chain.classType = classType;
        chain.moduleDecl = moduleDecl;
        context.scopeChain = chain;
    }
    TypeScript.pushTypeCollectionScope = pushTypeCollectionScope;
    function popTypeCollectionScope(context) {
        context.scopeChain = context.scopeChain.previous;
    }
    TypeScript.popTypeCollectionScope = popTypeCollectionScope;
    function preFindEnclosingScope(ast, parent, walker) {
        var context = walker.state;
        var minChar = ast.minChar;
        var limChar = ast.limChar;
        if (ast.nodeType == 95 /* Script */  && context.pos > limChar) {
            limChar = context.pos;
        }
        if ((minChar <= context.pos) && (limChar >= context.pos)) {
            switch(ast.nodeType) {
                case 95 /* Script */ :
                    var script = ast;
                    context.scopeGetter = function () {
                        return script.bod === null ? null : script.bod.enclosingScope;
                    };
                    context.scopeStartAST = script;
                    break;
                case 96 /* ClassDeclaration */ :
                    context.scopeGetter = function () {
                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;
                    };
                    context.scopeStartAST = ast;
                    context.enclosingClassDecl = ast;
                    break;
                case 11 /* ObjectLit */ :
                    var objectLit = ast;
                    if (objectLit.targetType) {
                        context.scopeGetter = function () {
                            return objectLit.targetType.containedScope;
                        };
                        context.objectLiteralScopeGetter = function () {
                            return objectLit.targetType.memberScope;
                        };
                        context.enclosingObjectLit = objectLit;
                    }
                    break;
                case 98 /* ModuleDeclaration */ :
                    context.deepestModuleDecl = ast;
                    context.scopeGetter = function () {
                        return ast.type === null ? null : ast.type.containedScope;
                    };
                    context.scopeStartAST = ast;
                    break;
                case 97 /* InterfaceDeclaration */ :
                    context.scopeGetter = function () {
                        return (ast.type === null) ? null : ast.type.containedScope;
                    };
                    context.scopeStartAST = ast;
                    break;
                case 73 /* FuncDecl */ :
 {
                        var funcDecl = ast;
                        if (context.skipNextFuncDeclForClass) {
                            context.skipNextFuncDeclForClass = false;
                        } else {
                            context.scopeGetter = function () {
                                if (funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) {
                                    if (ast.type && ast.type.enclosingType) {
                                        return ast.type.enclosingType.constructorScope;
                                    }
                                }
                                if (funcDecl.scopeType) {
                                    return funcDecl.scopeType.containedScope;
                                }
                                if (funcDecl.type) {
                                    return funcDecl.type.containedScope;
                                }
                                return null;
                            };
                            context.scopeStartAST = ast;
                        }
                    }
                    break;
            }
            walker.options.goChildren = true;
        } else {
            walker.options.goChildren = false;
        }
        return ast;
    }
    TypeScript.preFindEnclosingScope = preFindEnclosingScope;
    function findEnclosingScopeAt(logger, script, text, pos, isMemberCompletion) {
        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);
        TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context);
        if (context.scopeStartAST === null) {
            return null;
        }
        return context;
    }
    TypeScript.findEnclosingScopeAt = findEnclosingScopeAt;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Signature = (function () {
        function Signature() {
            this.hasVariableArgList = false;
            this.parameters = null;
            this.declAST = null;
            this.typeCheckStatus = 0 /* NotStarted */ ;
            this.nonOptionalParameterCount = 0;
        }
        Signature.prototype.specializeType = function (pattern, replacement, checker) {
            var result = new Signature();
            if (this.hasVariableArgList) {
                result.hasVariableArgList = true;
            }
            result.returnType = new TypeScript.TypeLink();
            if (this.returnType.type) {
                result.returnType.type = this.returnType.type.specializeType(pattern, replacement, checker, false);
            } else {
                result.returnType.type = checker.anyType;
            }
            if (this.parameters) {
                result.parameters = [];
                for(var i = 0, len = this.parameters.length; i < len; i++) {
                    var oldSym = this.parameters[i];
                    var paramDef = new TypeScript.ValueLocation();
                    var paramSym = new TypeScript.ParameterSymbol(oldSym.name, oldSym.location, checker.locationInfo.unitIndex, paramDef);
                    paramSym.declAST = this.declAST;
                    paramDef.symbol = paramSym;
                    paramDef.typeLink = new TypeScript.TypeLink();
                    result.parameters[i] = paramSym;
                    var oldType = oldSym.getType();
                    if (oldType) {
                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);
                    } else {
                        paramDef.typeLink.type = checker.anyType;
                    }
                }
            }
            result.nonOptionalParameterCount = this.nonOptionalParameterCount;
            result.declAST = this.declAST;
            return result;
        };
        Signature.prototype.toString = function () {
            return this.toStringHelper(false, false, null);
        };
        Signature.prototype.toStringHelper = function (shortform, brackets, scope) {
            return this.toStringHelperEx(shortform, brackets, scope).toString();
        };
        Signature.prototype.toStringHelperEx = function (shortform, brackets, scope, prefix) {
            if (typeof prefix === "undefined") { prefix = ""; }
            var builder = new TypeScript.MemberNameArray();
            if (brackets) {
                builder.prefix = prefix + "[";
            } else {
                builder.prefix = prefix + "(";
            }
            var paramLen = this.parameters.length;
            var len = this.hasVariableArgList ? paramLen - 1 : paramLen;
            for(var i = 0; i < len; i++) {
                builder.add(TypeScript.MemberName.create(this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "") + ": "));
                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));
                if (i < paramLen - 1) {
                    builder.add(TypeScript.MemberName.create(", "));
                }
            }
            if (this.hasVariableArgList) {
                builder.add(TypeScript.MemberName.create("..." + this.parameters[i].name + ": "));
                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));
            }
            if (shortform) {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("] => "));
                } else {
                    builder.add(TypeScript.MemberName.create(") => "));
                }
            } else {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("]: "));
                } else {
                    builder.add(TypeScript.MemberName.create("): "));
                }
            }
            if (this.returnType.type) {
                builder.add(this.returnType.type.getScopedTypeNameEx(scope));
            } else {
                builder.add(TypeScript.MemberName.create("any"));
            }
            return builder;
        };
        return Signature;
    })();
    TypeScript.Signature = Signature;    
    var SignatureGroup = (function () {
        function SignatureGroup() {
            this.signatures = [];
            this.hasImplementation = true;
            this.definitionSignature = null;
            this.hasBeenTypechecked = false;
            this.flags = 0 /* None */ ;
        }
        SignatureGroup.prototype.addSignature = function (signature) {
            if (this.signatures == null) {
                this.signatures = new Array();
            }
            this.signatures[this.signatures.length] = signature;
            if (signature.declAST && !signature.declAST.isOverload && !signature.declAST.isSignature() && !TypeScript.hasFlag(signature.declAST.fncFlags, 8 /* Ambient */ ) && !TypeScript.hasFlag(signature.declAST.fncFlags, 512 /* Signature */ )) {
                this.definitionSignature = signature;
            }
        };
        SignatureGroup.prototype.toString = function () {
            return this.signatures.toString();
        };
        SignatureGroup.prototype.toStrings = function (prefix, shortform, scope, getPrettyTypeName, useSignature) {
            var _this = this;
            var result = [];
            var len = this.signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }
            var getMemberNameOfSignature = function (signature) {
                if (_this.flags & 1 /* IsIndexer */ ) {
                    return signature.toStringHelperEx(shortform, true, scope);
                } else {
                    return signature.toStringHelperEx(shortform, false, scope, prefix);
                }
            };
            if (useSignature) {
                result.push(getMemberNameOfSignature(useSignature));
            } else {
                for(var i = 0; i < len; i++) {
                    if (len > 1 && this.signatures[i] == this.definitionSignature) {
                        continue;
                    }
                    result.push(getMemberNameOfSignature(this.signatures[i]));
                    if (getPrettyTypeName) {
                        break;
                    }
                }
            }
            if (getPrettyTypeName && len > 1) {
                var lastMemberName = result[result.length - 1];
                var overloadString = " (+ " + ((this.definitionSignature != null) ? len - 2 : len - 1) + " overload(s))";
                lastMemberName.add(TypeScript.MemberName.create(overloadString));
            }
            return result;
        };
        SignatureGroup.prototype.specializeType = function (pattern, replacement, checker) {
            var result = new SignatureGroup();
            if (this.signatures) {
                for(var i = 0, len = this.signatures.length; i < len; i++) {
                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));
                }
            }
            return result;
        };
        SignatureGroup.prototype.verifySignatures = function (checker) {
            var len = 0;
            if (this.signatures && ((len = this.signatures.length) > 0)) {
                for(var i = 0; i < len; i++) {
                    for(var j = i + 1; j < len; j++) {
                        if (this.signatures[i].declAST && this.signatures[j].declAST && (TypeScript.hasFlag(this.signatures[i].declAST.fncFlags, 512 /* Signature */ ) && TypeScript.hasFlag(this.signatures[j].declAST.fncFlags, 512 /* Signature */ )) && checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? "Signature for '" + this.signatures[i].declAST.name.actualText + "' is duplicated" : "Signature is duplicated");
                        }
                    }
                    if (this.definitionSignature) {
                        if (!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition");
                        }
                    }
                }
            }
        };
        SignatureGroup.prototype.typeCheck = function (checker, ast, hasConstruct) {
            if (this.hasBeenTypechecked) {
                return;
            }
            this.hasBeenTypechecked = true;
            var len = 0;
            if (this.signatures && ((len = this.signatures.length) > 0)) {
                for(var i = 0; i < len; i++) {
                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !TypeScript.hasFlag(this.signatures[i].declAST.fncFlags, 8 /* Ambient */ )) {
                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition");
                    }
                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == 0 /* NotStarted */ ) {
                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);
                    }
                    checker.typeFlow.typeCheck(this.signatures[i].declAST);
                }
                this.verifySignatures(checker);
            }
        };
        return SignatureGroup;
    })();
    TypeScript.SignatureGroup = SignatureGroup;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TypeCheckStatus) {
        TypeCheckStatus._map = [];
        TypeCheckStatus._map[0] = "NotStarted";
        TypeCheckStatus.NotStarted = 0;
        TypeCheckStatus._map[1] = "Started";
        TypeCheckStatus.Started = 1;
        TypeCheckStatus._map[2] = "Finished";
        TypeCheckStatus.Finished = 2;
    })(TypeScript.TypeCheckStatus || (TypeScript.TypeCheckStatus = {}));
    var TypeCheckStatus = TypeScript.TypeCheckStatus;
    function aLexicallyEnclosesB(a, b) {
        if (a.declAST && b && b.declAST && a.declAST.nodeType == 73 /* FuncDecl */ ) {
            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;
        } else {
            return false;
        }
    }
    TypeScript.aLexicallyEnclosesB = aLexicallyEnclosesB;
    function aEnclosesB(a, b) {
        while(a.container) {
            if (a == b || aLexicallyEnclosesB(a.container, b)) {
                return true;
            }
            a = a.container;
        }
        return false;
    }
    TypeScript.aEnclosesB = aEnclosesB;
    var Symbol = (function () {
        function Symbol(name, location, length, unitIndex) {
            this.name = name;
            this.location = location;
            this.length = length;
            this.unitIndex = unitIndex;
            this.bound = false;
            this.flags = 0 /* None */ ;
            this.isObjectLitField = false;
            this.declAST = null;
            this.declModule = null;
            this.passSymbolCreated = TypeScript.CompilerDiagnostics.analysisPass;
        }
        Symbol.prototype.instanceScope = function () {
            return null;
        };
        Symbol.prototype.isVariable = function () {
            return false;
        };
        Symbol.prototype.isMember = function () {
            return false;
        };
        Symbol.prototype.isInferenceSymbol = function () {
            return false;
        };
        Symbol.prototype.isWith = function () {
            return false;
        };
        Symbol.prototype.writeable = function () {
            return false;
        };
        Symbol.prototype.isType = function () {
            return false;
        };
        Symbol.prototype.getType = function () {
            return null;
        };
        Symbol.prototype.isAccessor = function () {
            return false;
        };
        Symbol.prototype.isInstanceProperty = function () {
            return TypeScript.hasFlag(this.flags, 256 /* Property */ ) && (!TypeScript.hasFlag(this.flags, 1024 /* ModuleMember */ ));
        };
        Symbol.prototype.getTypeName = function (scope) {
            return this.getTypeNameEx(scope).toString();
        };
        Symbol.prototype.getTypeNameEx = function (scope) {
            return TypeScript.MemberName.create(this.toString());
        };
        Symbol.prototype.getOptionalNameString = function () {
            return TypeScript.hasFlag(this.flags, 65536 /* Optional */ ) ? "?" : "";
        };
        Symbol.prototype.pathToRoot = function () {
            var path = new Array();
            var node = this;
            while(node && (node.name != TypeScript.globalId)) {
                path[path.length] = node;
                node = node.container;
            }
            return path;
        };
        Symbol.prototype.findCommonAncestorPath = function (b) {
            if (this.container == null) {
                return new Array();
            }
            var aPath = this.container.pathToRoot();
            var bPath;
            if (b) {
                bPath = b.pathToRoot();
            } else {
                bPath = new Array();
            }
            var commonNodeIndex = -1;
            for(var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for(var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode == bNode) {
                        commonNodeIndex = i;
                        break;
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }
            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            } else {
                return aPath;
            }
        };
        Symbol.prototype.getPrettyName = function (scopeSymbol) {
            return this.name;
        };
        Symbol.prototype.scopeRelativeName = function (scope) {
            if (scope == null) {
                return this.getPrettyName(null) + this.getOptionalNameString();
            }
            var lca = this.findCommonAncestorPath(scope.container);
            var builder = "";
            for(var i = 0, len = lca.length; i < len; i++) {
                var prettyName = lca[i].getPrettyName(i == len - 1 ? scope.container : lca[i + 1]);
                builder = prettyName + "." + builder;
            }
            builder += this.getPrettyName(len == 0 ? scope.container : lca[0]) + this.getOptionalNameString();
            return builder;
        };
        Symbol.prototype.fullName = function (scope) {
            var scopeSymbol = !scope ? null : scope.container;
            var scopeRootPath = !scopeSymbol ? [] : scopeSymbol.pathToRoot();
            var dynamicModuleRoot = null;
            if (scopeRootPath.length > 0 && scopeRootPath[scopeRootPath.length - 1].declAST && scopeRootPath[scopeRootPath.length - 1].declAST.nodeType == 98 /* ModuleDeclaration */  && (scopeRootPath[scopeRootPath.length - 1].declAST).isWholeFile()) {
                dynamicModuleRoot = scopeRootPath[scopeRootPath.length - 1];
            }
            var builder = this.getPrettyName(scopeSymbol);
            var ancestor = this.container;
            while(ancestor && (ancestor.name != TypeScript.globalId) && ancestor != dynamicModuleRoot) {
                builder = ancestor.getPrettyName(scopeSymbol) + "." + builder;
                ancestor = ancestor.container;
            }
            return builder;
        };
        Symbol.prototype.isExternallyVisible = function (checker) {
            if (this == checker.gloMod) {
                return true;
            }
            if (TypeScript.hasFlag(this.flags, 2 /* Private */ )) {
                return false;
            }
            if (!TypeScript.hasFlag(this.flags, 1 /* Exported */ )) {
                return this.container == checker.gloMod;
            }
            return this.container.isExternallyVisible(checker);
        };
        Symbol.prototype.visible = function (scope, checker) {
            if (checker == null || this.container == checker.gloMod) {
                return true;
            }
            if (TypeScript.hasFlag(this.flags, 1024 /* ModuleMember */ )) {
                if (TypeScript.hasFlag(this.flags, 1 /* Exported */ )) {
                    if (!TypeScript.hasFlag(this.flags, 2 /* Private */ )) {
                        return true;
                    } else {
                        return aEnclosesB(this, scope.container);
                    }
                } else {
                    return checker && (checker.currentModDecl == this.declModule) || (checker.currentModDecl && checker.currentModDecl.mod && checker.currentModDecl.mod.symbol && this.declModule && this.declModule.mod && this.declModule.mod.symbol && aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));
                }
            } else {
                var isFunction = this.declAST && this.declAST.nodeType == 73 /* FuncDecl */ ;
                var isMethod = isFunction && (this.declAST).isMethod();
                var isStaticFunction = isFunction && TypeScript.hasFlag((this.declAST).fncFlags, 16 /* Static */ );
                var isPrivateMethod = isMethod && TypeScript.hasFlag((this.declAST).fncFlags, 2 /* Private */ );
                var isAlias = this.isType() && (this).aliasLink;
                if (this.isMember() || isMethod || isStaticFunction || isAlias) {
                    if (TypeScript.hasFlag(this.flags, 2 /* Private */ ) || isPrivateMethod) {
                        if (scope.container == null && this.container != scope.container) {
                            return false;
                        } else {
                            return this.container == null ? true : aEnclosesB(scope.container, this.container);
                        }
                    } else {
                        return true;
                    }
                } else if (this.container) {
                    return aEnclosesB(this, scope.container);
                } else {
                    return true;
                }
            }
        };
        Symbol.prototype.addRef = function (identifier) {
            if (!this.refs) {
                this.refs = [];
            }
            this.refs[this.refs.length] = identifier;
        };
        Symbol.prototype.toString = function () {
            if (this.name) {
                return this.name;
            } else {
                return "_anonymous";
            }
        };
        Symbol.prototype.print = function (outfile) {
            outfile.Write(this.toString());
        };
        Symbol.prototype.specializeType = function (pattern, replacement, checker) {
            throw new Error("please implement in derived class");
        };
        Symbol.prototype.setType = function (type) {
            throw new Error("please implement in derived class");
        };
        Symbol.prototype.kind = function () {
            throw new Error("please implement in derived class");
        };
        Symbol.prototype.getInterfaceDeclFromSymbol = function (checker) {
            if (this.declAST != null) {
                if (this.declAST.nodeType == 97 /* InterfaceDeclaration */ ) {
                    return this.declAST;
                } else if (this.container != null && this.container != checker.gloMod && this.container.declAST.nodeType == 97 /* InterfaceDeclaration */ ) {
                    return this.container.declAST;
                }
            }
            return null;
        };
        Symbol.prototype.getVarDeclFromSymbol = function () {
            if (this.declAST != null && this.declAST.nodeType == 75 /* VarDecl */ ) {
                return this.declAST;
            }
            return null;
        };
        Symbol.prototype.getDocComments = function () {
            if (this.declAST != null) {
                return this.declAST.getDocComments();
            }
            return [];
        };
        Symbol.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.flags, 16 /* Static */ );
        };
        return Symbol;
    })();
    TypeScript.Symbol = Symbol;    
    var ValueLocation = (function () {
        function ValueLocation() { }
        return ValueLocation;
    })();
    TypeScript.ValueLocation = ValueLocation;    
    var InferenceSymbol = (function (_super) {
        __extends(InferenceSymbol, _super);
        function InferenceSymbol(name, location, length, unitIndex) {
                _super.call(this, name, location, length, unitIndex);
            this.typeCheckStatus = 0 /* NotStarted */ ;
        }
        InferenceSymbol.prototype.isInferenceSymbol = function () {
            return true;
        };
        InferenceSymbol.prototype.transferVarFlags = function (varFlags) {
            if (TypeScript.hasFlag(varFlags, 8 /* Ambient */ )) {
                this.flags |= 8 /* Ambient */ ;
            }
            if (TypeScript.hasFlag(varFlags, 65536 /* Constant */ )) {
                this.flags |= 32768 /* Constant */ ;
            }
            if (TypeScript.hasFlag(varFlags, 16 /* Static */ )) {
                this.flags |= 16 /* Static */ ;
            }
            if (TypeScript.hasFlag(varFlags, 512 /* Property */ )) {
                this.flags |= 256 /* Property */ ;
            }
            if (TypeScript.hasFlag(varFlags, 2 /* Private */ )) {
                this.flags |= 2 /* Private */ ;
            }
            if (TypeScript.hasFlag(varFlags, 4 /* Public */ )) {
                this.flags |= 4 /* Public */ ;
            }
            if (TypeScript.hasFlag(varFlags, 1024 /* Readonly */ )) {
                this.flags |= 512 /* Readonly */ ;
            }
            if (TypeScript.hasFlag(varFlags, 1 /* Exported */ )) {
                this.flags |= 1 /* Exported */ ;
            }
        };
        return InferenceSymbol;
    })(Symbol);
    TypeScript.InferenceSymbol = InferenceSymbol;    
    var TypeSymbol = (function (_super) {
        __extends(TypeSymbol, _super);
        function TypeSymbol(locName, location, length, unitIndex, type) {
                _super.call(this, locName, location, length, unitIndex);
            this.type = type;
            this.expansions = [];
            this.expansionsDeclAST = [];
            this.isDynamic = false;
            this.isMethod = false;
            this.aliasLink = null;
            this.onlyReferencedAsTypeRef = TypeScript.optimizeModuleCodeGen;
            this.prettyName = this.name;
        }
        TypeSymbol.prototype.addLocation = function (loc) {
            if (this.additionalLocations == null) {
                this.additionalLocations = [];
            }
            this.additionalLocations[this.additionalLocations.length] = loc;
        };
        TypeSymbol.prototype.kind = function () {
            return 1 /* Type */ ;
        };
        TypeSymbol.prototype.isType = function () {
            return true;
        };
        TypeSymbol.prototype.getType = function () {
            return this.type;
        };
        TypeSymbol.prototype.getTypeNameEx = function (scope) {
            return this.type.getMemberTypeNameEx(this.name ? this.name + this.getOptionalNameString() : "", false, false, scope);
        };
        TypeSymbol.prototype.instanceScope = function () {
            if (!(this.type.typeFlags & 128 /* IsClass */ ) && this.type.isClass()) {
                return this.type.instanceType.constructorScope;
            } else {
                return this.type.containedScope;
            }
        };
        TypeSymbol.prototype.toString = function () {
            var result = this.type.getTypeName();
            if (this.name) {
                result = this.name + ":" + result;
            }
            return result;
        };
        TypeSymbol.prototype.isClass = function () {
            return this.instanceType != null;
        };
        TypeSymbol.prototype.isFunction = function () {
            return this.declAST != null && this.declAST.nodeType == 73 /* FuncDecl */ ;
        };
        TypeSymbol.prototype.specializeType = function (pattern, replacement, checker) {
            if (this.type == pattern) {
                return replacement.symbol;
            } else {
                var replType = this.type.specializeType(pattern, replacement, checker, false);
                if (replType != this.type) {
                    var result = new TypeSymbol(this.name, -1, 0, -1, replType);
                    return result;
                } else {
                    return this;
                }
            }
        };
        TypeSymbol.prototype.getPrettyName = function (scopeSymbol) {
            if (!!scopeSymbol && TypeScript.isQuoted(this.prettyName) && this.type.isModuleType()) {
                var symbolPath = scopeSymbol.pathToRoot();
                var prettyName = this.getPrettyNameOfDynamicModule(symbolPath);
                if (prettyName != null) {
                    return prettyName.name;
                }
            }
            return this.prettyName;
        };
        TypeSymbol.prototype.getPrettyNameOfDynamicModule = function (scopeSymbolPath) {
            var scopeSymbolPathLength = scopeSymbolPath.length;
            var externalSymbol = null;
            if (scopeSymbolPath.length > 0 && scopeSymbolPath[scopeSymbolPathLength - 1].getType().isModuleType() && (scopeSymbolPath[scopeSymbolPathLength - 1]).isDynamic) {
                if (scopeSymbolPathLength > 1 && scopeSymbolPath[scopeSymbolPathLength - 2].getType().isModuleType() && (scopeSymbolPath[scopeSymbolPathLength - 2]).isDynamic) {
                    var moduleType = scopeSymbolPath[scopeSymbolPathLength - 2].getType();
                    externalSymbol = moduleType.findDynamicModuleName(this.type);
                }
                if (externalSymbol == null) {
                    var moduleType = scopeSymbolPath[scopeSymbolPathLength - 1].getType();
                    externalSymbol = moduleType.findDynamicModuleName(this.type);
                }
            }
            return externalSymbol;
        };
        TypeSymbol.prototype.getDocComments = function () {
            var comments = [];
            if (this.declAST != null) {
                comments = comments.concat(this.declAST.getDocComments());
            }
            for(var i = 0; i < this.expansionsDeclAST.length; i++) {
                comments = comments.concat(this.expansionsDeclAST[i].getDocComments());
            }
            return comments;
        };
        return TypeSymbol;
    })(InferenceSymbol);
    TypeScript.TypeSymbol = TypeSymbol;    
    var WithSymbol = (function (_super) {
        __extends(WithSymbol, _super);
        function WithSymbol(location, unitIndex, withType) {
                _super.call(this, "with", location, 4, unitIndex, withType);
        }
        WithSymbol.prototype.isWith = function () {
            return true;
        };
        return WithSymbol;
    })(TypeSymbol);
    TypeScript.WithSymbol = WithSymbol;    
    var FieldSymbol = (function (_super) {
        __extends(FieldSymbol, _super);
        function FieldSymbol(name, location, unitIndex, canWrite, field) {
                _super.call(this, name, location, name.length, unitIndex);
            this.canWrite = canWrite;
            this.field = field;
            this.getter = null;
            this.setter = null;
            this.hasBeenEmitted = false;
            this.name = name;
            this.location = location;
        }
        FieldSymbol.prototype.kind = function () {
            return 2 /* Field */ ;
        };
        FieldSymbol.prototype.writeable = function () {
            return this.isAccessor() ? this.setter != null : this.canWrite;
        };
        FieldSymbol.prototype.getType = function () {
            return this.field.typeLink.type;
        };
        FieldSymbol.prototype.getTypeNameEx = function (scope) {
            return TypeScript.MemberName.create(this.field.typeLink.type ? this.field.typeLink.type.getScopedTypeNameEx(scope) : TypeScript.MemberName.create("any"), this.name + this.getOptionalNameString() + ": ", "");
        };
        FieldSymbol.prototype.isMember = function () {
            return true;
        };
        FieldSymbol.prototype.setType = function (type) {
            this.field.typeLink.type = type;
        };
        FieldSymbol.prototype.isAccessor = function () {
            return this.getter != null || this.setter != null;
        };
        FieldSymbol.prototype.isVariable = function () {
            return true;
        };
        FieldSymbol.prototype.toString = function () {
            return this.getTypeNameEx(null).toString();
        };
        FieldSymbol.prototype.specializeType = function (pattern, replacement, checker) {
            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);
            if (rType != this.field.typeLink.type) {
                var fieldDef = new ValueLocation();
                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex, this.canWrite, fieldDef);
                result.flags = this.flags;
                fieldDef.symbol = result;
                fieldDef.typeLink = new TypeScript.TypeLink();
                result.setType(rType);
                result.typeCheckStatus = 2 /* Finished */ ;
                return result;
            } else {
                return this;
            }
        };
        FieldSymbol.prototype.getDocComments = function () {
            if (this.getter != null || this.setter != null) {
                var comments = [];
                if (this.getter != null) {
                    comments = comments.concat(this.getter.getDocComments());
                }
                if (this.setter != null) {
                    comments = comments.concat(this.setter.getDocComments());
                }
                return comments;
            } else if (this.declAST != null) {
                return this.declAST.getDocComments();
            }
            return [];
        };
        return FieldSymbol;
    })(InferenceSymbol);
    TypeScript.FieldSymbol = FieldSymbol;    
    var ParameterSymbol = (function (_super) {
        __extends(ParameterSymbol, _super);
        function ParameterSymbol(name, location, unitIndex, parameter) {
                _super.call(this, name, location, name.length, unitIndex);
            this.parameter = parameter;
            this.paramDocComment = null;
            this.funcDecl = null;
            this.argsOffset = (-1);
            this.name = name;
            this.location = location;
        }
        ParameterSymbol.prototype.kind = function () {
            return 3 /* Parameter */ ;
        };
        ParameterSymbol.prototype.writeable = function () {
            return true;
        };
        ParameterSymbol.prototype.getType = function () {
            return this.parameter.typeLink.type;
        };
        ParameterSymbol.prototype.setType = function (type) {
            this.parameter.typeLink.type = type;
        };
        ParameterSymbol.prototype.isVariable = function () {
            return true;
        };
        ParameterSymbol.prototype.isOptional = function () {
            if (this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {
                return (this.parameter.symbol.declAST).isOptional;
            } else {
                return false;
            }
        };
        ParameterSymbol.prototype.getTypeNameEx = function (scope) {
            return TypeScript.MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + (this.isOptional() ? "?" : "") + ": ", "");
        };
        ParameterSymbol.prototype.toString = function () {
            return this.getTypeNameEx(null).toString();
        };
        ParameterSymbol.prototype.specializeType = function (pattern, replacement, checker) {
            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);
            if (this.parameter.typeLink.type != rType) {
                var paramDef = new ValueLocation();
                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex, paramDef);
                paramDef.symbol = result;
                result.setType(rType);
                return result;
            } else {
                return this;
            }
        };
        ParameterSymbol.prototype.getParameterDocComments = function () {
            if (!this.paramDocComment) {
                var parameterComments = [];
                if (this.funcDecl) {
                    var fncDocComments = this.funcDecl.getDocComments();
                    var paramComment = TypeScript.Comment.getParameterDocCommentText(this.name, fncDocComments);
                    if (paramComment != "") {
                        parameterComments.push(paramComment);
                    }
                }
                var docComments = TypeScript.Comment.getDocCommentText(this.getDocComments());
                if (docComments != "") {
                    parameterComments.push(docComments);
                }
                this.paramDocComment = parameterComments.join("\n");
            }
            return this.paramDocComment;
        };
        ParameterSymbol.prototype.fullName = function () {
            return this.name;
        };
        return ParameterSymbol;
    })(InferenceSymbol);
    TypeScript.ParameterSymbol = ParameterSymbol;    
    var VariableSymbol = (function (_super) {
        __extends(VariableSymbol, _super);
        function VariableSymbol(name, location, unitIndex, variable) {
                _super.call(this, name, location, name.length, unitIndex);
            this.variable = variable;
        }
        VariableSymbol.prototype.kind = function () {
            return 4 /* Variable */ ;
        };
        VariableSymbol.prototype.writeable = function () {
            return true;
        };
        VariableSymbol.prototype.getType = function () {
            return this.variable.typeLink.type;
        };
        VariableSymbol.prototype.getTypeNameEx = function (scope) {
            return TypeScript.MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + ": ", "");
        };
        VariableSymbol.prototype.setType = function (type) {
            this.variable.typeLink.type = type;
        };
        VariableSymbol.prototype.isVariable = function () {
            return true;
        };
        return VariableSymbol;
    })(InferenceSymbol);
    TypeScript.VariableSymbol = VariableSymbol;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScopedMembers = (function () {
        function ScopedMembers(dualMembers) {
            this.dualMembers = dualMembers;
            this.allMembers = this.dualMembers;
            this.publicMembers = this.dualMembers.primaryTable;
            this.privateMembers = this.dualMembers.secondaryTable;
        }
        ScopedMembers.prototype.addPublicMember = function (key, data) {
            return this.dualMembers.primaryTable.add(key, data);
        };
        ScopedMembers.prototype.addPrivateMember = function (key, data) {
            return this.dualMembers.secondaryTable.add(key, data);
        };
        return ScopedMembers;
    })();
    TypeScript.ScopedMembers = ScopedMembers;    
    (function (SymbolKind) {
        SymbolKind._map = [];
        SymbolKind._map[0] = "None";
        SymbolKind.None = 0;
        SymbolKind._map[1] = "Type";
        SymbolKind.Type = 1;
        SymbolKind._map[2] = "Field";
        SymbolKind.Field = 2;
        SymbolKind._map[3] = "Parameter";
        SymbolKind.Parameter = 3;
        SymbolKind._map[4] = "Variable";
        SymbolKind.Variable = 4;
    })(TypeScript.SymbolKind || (TypeScript.SymbolKind = {}));
    var SymbolKind = TypeScript.SymbolKind;
    var SymbolScope = (function () {
        function SymbolScope(container) {
            this.container = container;
        }
        SymbolScope.prototype.printLabel = function () {
            return "base";
        };
        SymbolScope.prototype.getAllSymbolNames = function (members) {
            return [
                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
            ];
        };
        SymbolScope.prototype.getAllTypeSymbolNames = function (members) {
            return [
                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
            ];
        };
        SymbolScope.prototype.getAllValueSymbolNames = function (members) {
            return [
                "please", 
                "implement", 
                "in", 
                "derived", 
                "classes"
            ];
        };
        SymbolScope.prototype.search = function (filter, name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.findLocal = function (name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.find = function (name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.findImplementation = function (name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.findAmbient = function (name, publicOnly, typespace) {
            return null;
        };
        SymbolScope.prototype.print = function (outfile) {
            if (this.container) {
                outfile.WriteLine(this.printLabel() + " scope with container: " + this.container.name + "...");
            } else {
                outfile.WriteLine(this.printLabel() + " scope...");
            }
        };
        SymbolScope.prototype.enter = function (container, ast, symbol, errorReporter, publicOnly, typespace, ambient) {
            throw new Error("please implement in derived class");
        };
        SymbolScope.prototype.getTable = function () {
            throw new Error("please implement in derived class");
        };
        return SymbolScope;
    })();
    TypeScript.SymbolScope = SymbolScope;    
    function symbolCanBeUsed(sym, publicOnly) {
        return publicOnly ? !(TypeScript.hasFlag(sym.flags, 2 /* Private */ ) || (sym.declAST && sym.declAST.nodeType == 73 /* FuncDecl */  && TypeScript.hasFlag((sym.declAST).fncFlags, 2 /* Private */ ))) : true;
    }
    var SymbolAggregateScope = (function (_super) {
        __extends(SymbolAggregateScope, _super);
        function SymbolAggregateScope(container) {
                _super.call(this, container);
            this.valueCache = null;
            this.valueImplCache = null;
            this.valueAmbientCache = null;
            this.typeCache = null;
            this.typeImplCache = null;
            this.typeAmbientCache = null;
            this.parents = null;
            this.container = container;
        }
        SymbolAggregateScope.prototype.printLabel = function () {
            return "agg";
        };
        SymbolAggregateScope.prototype.search = function (filter, name, publicOnly, typespace) {
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);
                    if (sym) {
                        if (filter.update(sym)) {
                            return sym;
                        }
                    }
                }
            }
            return filter.result;
        };
        SymbolAggregateScope.prototype.getAllSymbolNames = function (members) {
            var result = [];
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        };
        SymbolAggregateScope.prototype.getAllTypeSymbolNames = function (members) {
            var result = [];
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        };
        SymbolAggregateScope.prototype.getAllValueSymbolNames = function (members) {
            var result = [];
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllValueSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        };
        SymbolAggregateScope.prototype.print = function (outfile) {
            _super.prototype.print.call(this, outfile);
            if (this.parents) {
                for(var i = 0; i < this.parents.length; i++) {
                    this.parents[i].print(outfile);
                }
            }
        };
        SymbolAggregateScope.prototype.findImplementation = function (name, publicOnly, typespace) {
            var sym = null;
            var i = 0;
            var implCache = this.valueImplCache;
            if (typespace) {
                implCache = this.typeImplCache;
            }
            if (implCache && ((sym = implCache.lookup(name)) != null) && (publicOnly ? !(TypeScript.hasFlag(sym.flags, 2 /* Private */ ) || (sym.declAST && sym.declAST.nodeType == 73 /* FuncDecl */  && TypeScript.hasFlag((sym.declAST).fncFlags, 2 /* Private */ ))) : true)) {
                return sym;
            }
            if (this.parents) {
                for(i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (implCache) {
                if (typespace) {
                    this.typeImplCache = new TypeScript.StringHashTable();
                    implCache = this.typeImplCache;
                } else {
                    this.valueImplCache = new TypeScript.StringHashTable();
                    implCache = this.valueImplCache;
                }
            }
            implCache.add(name, sym);
            return sym;
        };
        SymbolAggregateScope.prototype.find = function (name, publicOnly, typespace) {
            var sym = null;
            var i = 0;
            var cache = this.valueCache;
            if (typespace) {
                cache = this.typeCache;
            }
            if (cache && ((sym = cache.lookup(name)) != null) && (publicOnly ? !(TypeScript.hasFlag(sym.flags, 2 /* Private */ ) || (sym.declAST && sym.declAST.nodeType == 73 /* FuncDecl */  && TypeScript.hasFlag((sym.declAST).fncFlags, 2 /* Private */ ))) : true)) {
                return sym;
            }
            if (this.parents) {
                for(i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].find(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (cache == null) {
                if (typespace) {
                    this.typeCache = new TypeScript.StringHashTable();
                    cache = this.typeCache;
                } else {
                    this.valueCache = new TypeScript.StringHashTable();
                    cache = this.valueCache;
                }
            }
            cache.add(name, sym);
            return sym;
        };
        SymbolAggregateScope.prototype.findAmbient = function (name, publicOnly, typespace) {
            var sym = null;
            var i = 0;
            var cache = this.valueAmbientCache;
            if (typespace) {
                cache = this.typeAmbientCache;
            }
            if (cache && ((sym = cache.lookup(name)) != null)) {
                return sym;
            }
            if (this.parents) {
                for(i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findAmbient(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (cache == null) {
                if (typespace) {
                    this.typeAmbientCache = new TypeScript.StringHashTable();
                    cache = this.typeAmbientCache;
                } else {
                    this.valueAmbientCache = new TypeScript.StringHashTable();
                    cache = this.valueAmbientCache;
                }
            }
            cache.add(name, sym);
            return sym;
        };
        SymbolAggregateScope.prototype.addParentScope = function (parent) {
            if (this.parents == null) {
                this.parents = new Array();
            }
            this.parents[this.parents.length] = parent;
        };
        return SymbolAggregateScope;
    })(SymbolScope);
    TypeScript.SymbolAggregateScope = SymbolAggregateScope;    
    var SymbolTableScope = (function (_super) {
        __extends(SymbolTableScope, _super);
        function SymbolTableScope(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, container) {
                _super.call(this, container);
            this.valueMembers = valueMembers;
            this.ambientValueMembers = ambientValueMembers;
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            this.container = container;
        }
        SymbolTableScope.prototype.printLabel = function () {
            return "table";
        };
        SymbolTableScope.prototype.getAllSymbolNames = function (members) {
            var result = this.getAllTypeSymbolNames(members);
            return result.concat(this.getAllValueSymbolNames(members));
        };
        SymbolTableScope.prototype.getAllTypeSymbolNames = function (members) {
            var result = [];
            if (this.ambientEnclosedTypes) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());
            }
            if (this.enclosedTypes) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());
            }
            return result;
        };
        SymbolTableScope.prototype.getAllValueSymbolNames = function (members) {
            var result = [];
            if (this.ambientValueMembers) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());
            }
            if (this.valueMembers) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys());
            }
            return result;
        };
        SymbolTableScope.prototype.search = function (filter, name, publicOnly, typespace) {
            var sym = this.find(name, publicOnly, typespace);
            filter.update(sym);
            return filter.result;
        };
        SymbolTableScope.prototype.find = function (name, publicOnly, typespace) {
            var table = null;
            var ambientTable = null;
            if (typespace) {
                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            } else {
                table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
                ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            }
            if (ambientTable) {
                var s = ambientTable.lookup(name);
                if (s) {
                    return s;
                }
            }
            if (table) {
                var s = table.lookup(name);
                if (s) {
                    return s;
                }
            }
            return null;
        };
        SymbolTableScope.prototype.findAmbient = function (name, publicOnly, typespace) {
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable) {
                var s = ambientTable.lookup(name);
                if (s) {
                    return s;
                }
            }
            return null;
        };
        SymbolTableScope.prototype.print = function (outfile) {
            _super.prototype.print.call(this, outfile);
            if (this.ambientValueMembers) {
                this.ambientValueMembers.allMembers.map(function (key, sym, context) {
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.valueMembers) {
                this.valueMembers.allMembers.map(function (key, sym, context) {
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.ambientEnclosedTypes) {
                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.enclosedTypes) {
                this.enclosedTypes.allMembers.map(function (key, sym, context) {
                    outfile.WriteLine("  " + key);
                }, null);
            }
        };
        SymbolTableScope.prototype.findImplementation = function (name, publicOnly, typespace) {
            var sym = this.find(name, publicOnly, typespace);
            if (sym) {
                if (sym.kind() == 1 /* Type */ ) {
                    var typeSym = sym;
                    if (!typeSym.type.hasImplementation()) {
                        sym = null;
                    }
                } else if (sym.container) {
                    if (sym.container.kind() == 1 /* Type */ ) {
                        var ctypeSym = sym.container;
                        if (!ctypeSym.type.hasImplementation()) {
                            sym = null;
                        }
                    }
                }
            }
            return sym;
        };
        SymbolTableScope.prototype.getTable = function () {
            return this.valueMembers.publicMembers;
        };
        return SymbolTableScope;
    })(SymbolScope);
    TypeScript.SymbolTableScope = SymbolTableScope;    
    var SymbolScopeBuilder = (function (_super) {
        __extends(SymbolScopeBuilder, _super);
        function SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, parent, container) {
                _super.call(this, container);
            this.valueMembers = valueMembers;
            this.ambientValueMembers = ambientValueMembers;
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            this.parent = parent;
            this.container = container;
        }
        SymbolScopeBuilder.prototype.printLabel = function () {
            return "builder";
        };
        SymbolScopeBuilder.prototype.getAllSymbolNames = function (members) {
            var result = this.getAllTypeSymbolNames(members);
            return result.concat(this.getAllValueSymbolNames(members));
        };
        SymbolScopeBuilder.prototype.getAllTypeSymbolNames = function (members) {
            var result = [];
            if (this.ambientEnclosedTypes) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());
            }
            if (this.enclosedTypes) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());
            }
            if (!members && this.parent) {
                var parentResult = this.parent.getAllTypeSymbolNames(members);
                if (parentResult) {
                    result = result.concat(parentResult);
                }
            }
            return result;
        };
        SymbolScopeBuilder.prototype.getAllValueSymbolNames = function (members) {
            var result = [];
            if (this.ambientValueMembers) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());
            }
            if (this.valueMembers) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys());
            }
            if (!members && this.parent) {
                var parentResult = this.parent.getAllValueSymbolNames(members);
                if (parentResult) {
                    result = result.concat(parentResult);
                }
            }
            return result;
        };
        SymbolScopeBuilder.prototype.search = function (filter, name, publicOnly, typespace) {
            var sym = null;
            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable) {
                if ((sym = ambientTable.lookup(name)) != null) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            if (table) {
                if ((sym = table.lookup(name)) != null) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            if (this.parent) {
                sym = this.parent.search(filter, name, publicOnly, typespace);
                if (sym) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            return filter.result;
        };
        SymbolScopeBuilder.prototype.print = function (outfile) {
            _super.prototype.print.call(this, outfile);
            if (this.ambientValueMembers) {
                this.ambientValueMembers.allMembers.map(function (key, s, context) {
                    var sym = s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.valueMembers) {
                this.valueMembers.allMembers.map(function (key, s, context) {
                    var sym = s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.ambientEnclosedTypes) {
                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {
                    var sym = s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.enclosedTypes) {
                this.enclosedTypes.allMembers.map(function (key, s, context) {
                    var sym = s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.parent) {
                this.parent.print(outfile);
            }
        };
        SymbolScopeBuilder.prototype.find = function (name, publicOnly, typespace) {
            var sym = null;
            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {
                return sym;
            }
            if (table && ((sym = table.lookup(name)) != null)) {
                return sym;
            }
            if (this.parent) {
                return this.parent.find(name, publicOnly, typespace);
            }
            return null;
        };
        SymbolScopeBuilder.prototype.findAmbient = function (name, publicOnly, typespace) {
            var sym = null;
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {
                return sym;
            }
            if (this.parent) {
                return this.parent.findAmbient(name, publicOnly, typespace);
            }
            return null;
        };
        SymbolScopeBuilder.prototype.findLocal = function (name, publicOnly, typespace) {
            var sym = null;
            var table = (this.valueMembers == null) ? null : publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers == null) ? null : publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes == null) ? null : publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes == null) ? null : publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (table) {
                if ((sym = table.lookup(name)) != null) {
                    if (sym) {
                        return sym;
                    }
                }
            }
            if (ambientTable) {
                if ((sym = ambientTable.lookup(name)) != null) {
                    if (sym) {
                        return sym;
                    }
                }
            }
            return null;
        };
        SymbolScopeBuilder.prototype.enter = function (container, ast, symbol, errorReporter, insertAsPublic, typespace, ambient) {
            var table = null;
            if (ambient) {
                if (typespace) {
                    table = (this.ambientEnclosedTypes == null) ? null : insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;
                } else {
                    table = (this.ambientValueMembers == null) ? null : insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;
                }
            } else {
                if (typespace) {
                    table = (this.enclosedTypes == null) ? null : insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;
                } else {
                    table = (this.valueMembers == null) ? null : insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;
                }
            }
            if (table) {
                if (!table.add(symbol.name, symbol)) {
                    errorReporter.duplicateIdentifier(ast, symbol.name);
                }
            } else {
                TypeScript.CompilerDiagnostics.Alert("YYYYY");
            }
            symbol.container = container;
        };
        SymbolScopeBuilder.prototype.getTable = function () {
            return this.valueMembers.allMembers;
        };
        return SymbolScopeBuilder;
    })(SymbolScope);
    TypeScript.SymbolScopeBuilder = SymbolScopeBuilder;    
    var FilteredSymbolScope = (function (_super) {
        __extends(FilteredSymbolScope, _super);
        function FilteredSymbolScope(scope, container, filter) {
                _super.call(this, container);
            this.scope = scope;
            this.filter = filter;
        }
        FilteredSymbolScope.prototype.print = function (outfile) {
            this.scope.print(outfile);
        };
        FilteredSymbolScope.prototype.find = function (name, publicOnly, typespace) {
            this.filter.reset();
            return this.scope.search(this.filter, name, publicOnly, typespace);
        };
        FilteredSymbolScope.prototype.findLocal = function (name, publicOnly, typespace) {
            return this.scope.findLocal(name, publicOnly, typespace);
        };
        return FilteredSymbolScope;
    })(SymbolScope);
    TypeScript.FilteredSymbolScope = FilteredSymbolScope;    
    var FilteredSymbolScopeBuilder = (function (_super) {
        __extends(FilteredSymbolScopeBuilder, _super);
        function FilteredSymbolScopeBuilder(valueMembers, parent, container, filter) {
                _super.call(this, valueMembers, null, null, null, parent, container);
            this.filter = filter;
        }
        FilteredSymbolScopeBuilder.prototype.findLocal = function (name, publicOnly, typespace) {
            var sym = _super.prototype.findLocal.call(this, name, publicOnly, typespace);
            if (sym) {
                if (!this.filter(sym)) {
                    return null;
                }
            }
            return sym;
        };
        FilteredSymbolScopeBuilder.prototype.search = function (filter, name, publicOnly, typespace) {
            throw new Error("please implement");
        };
        FilteredSymbolScopeBuilder.prototype.find = function (name, publicOnly, typespace) {
            var sym = _super.prototype.findLocal.call(this, name, publicOnly, typespace);
            if (sym) {
                if (!this.filter(sym)) {
                    return null;
                }
            }
            return _super.prototype.find.call(this, name, publicOnly, typespace);
        };
        return FilteredSymbolScopeBuilder;
    })(SymbolScopeBuilder);
    TypeScript.FilteredSymbolScopeBuilder = FilteredSymbolScopeBuilder;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TokenID) {
        TokenID._map = [];
        TokenID._map[0] = "Any";
        TokenID.Any = 0;
        TokenID._map[1] = "Bool";
        TokenID.Bool = 1;
        TokenID._map[2] = "Break";
        TokenID.Break = 2;
        TokenID._map[3] = "Case";
        TokenID.Case = 3;
        TokenID._map[4] = "Catch";
        TokenID.Catch = 4;
        TokenID._map[5] = "Class";
        TokenID.Class = 5;
        TokenID._map[6] = "Const";
        TokenID.Const = 6;
        TokenID._map[7] = "Continue";
        TokenID.Continue = 7;
        TokenID._map[8] = "Debugger";
        TokenID.Debugger = 8;
        TokenID._map[9] = "Default";
        TokenID.Default = 9;
        TokenID._map[10] = "Delete";
        TokenID.Delete = 10;
        TokenID._map[11] = "Do";
        TokenID.Do = 11;
        TokenID._map[12] = "Else";
        TokenID.Else = 12;
        TokenID._map[13] = "Enum";
        TokenID.Enum = 13;
        TokenID._map[14] = "Export";
        TokenID.Export = 14;
        TokenID._map[15] = "Extends";
        TokenID.Extends = 15;
        TokenID._map[16] = "Declare";
        TokenID.Declare = 16;
        TokenID._map[17] = "False";
        TokenID.False = 17;
        TokenID._map[18] = "Finally";
        TokenID.Finally = 18;
        TokenID._map[19] = "For";
        TokenID.For = 19;
        TokenID._map[20] = "Function";
        TokenID.Function = 20;
        TokenID._map[21] = "Constructor";
        TokenID.Constructor = 21;
        TokenID._map[22] = "Get";
        TokenID.Get = 22;
        TokenID._map[23] = "If";
        TokenID.If = 23;
        TokenID._map[24] = "Implements";
        TokenID.Implements = 24;
        TokenID._map[25] = "Import";
        TokenID.Import = 25;
        TokenID._map[26] = "In";
        TokenID.In = 26;
        TokenID._map[27] = "InstanceOf";
        TokenID.InstanceOf = 27;
        TokenID._map[28] = "Interface";
        TokenID.Interface = 28;
        TokenID._map[29] = "Let";
        TokenID.Let = 29;
        TokenID._map[30] = "Module";
        TokenID.Module = 30;
        TokenID._map[31] = "New";
        TokenID.New = 31;
        TokenID._map[32] = "Number";
        TokenID.Number = 32;
        TokenID._map[33] = "Null";
        TokenID.Null = 33;
        TokenID._map[34] = "Package";
        TokenID.Package = 34;
        TokenID._map[35] = "Private";
        TokenID.Private = 35;
        TokenID._map[36] = "Protected";
        TokenID.Protected = 36;
        TokenID._map[37] = "Public";
        TokenID.Public = 37;
        TokenID._map[38] = "Return";
        TokenID.Return = 38;
        TokenID._map[39] = "Set";
        TokenID.Set = 39;
        TokenID._map[40] = "Static";
        TokenID.Static = 40;
        TokenID._map[41] = "Inline";
        TokenID.Inline = 41;
        TokenID._map[42] = "String";
        TokenID.String = 42;
        TokenID._map[43] = "Super";
        TokenID.Super = 43;
        TokenID._map[44] = "Switch";
        TokenID.Switch = 44;
        TokenID._map[45] = "This";
        TokenID.This = 45;
        TokenID._map[46] = "Throw";
        TokenID.Throw = 46;
        TokenID._map[47] = "True";
        TokenID.True = 47;
        TokenID._map[48] = "Try";
        TokenID.Try = 48;
        TokenID._map[49] = "TypeOf";
        TokenID.TypeOf = 49;
        TokenID._map[50] = "Var";
        TokenID.Var = 50;
        TokenID._map[51] = "Void";
        TokenID.Void = 51;
        TokenID._map[52] = "With";
        TokenID.With = 52;
        TokenID._map[53] = "While";
        TokenID.While = 53;
        TokenID._map[54] = "Yield";
        TokenID.Yield = 54;
        TokenID._map[55] = "Semicolon";
        TokenID.Semicolon = 55;
        TokenID._map[56] = "OpenParen";
        TokenID.OpenParen = 56;
        TokenID._map[57] = "CloseParen";
        TokenID.CloseParen = 57;
        TokenID._map[58] = "OpenBracket";
        TokenID.OpenBracket = 58;
        TokenID._map[59] = "CloseBracket";
        TokenID.CloseBracket = 59;
        TokenID._map[60] = "OpenBrace";
        TokenID.OpenBrace = 60;
        TokenID._map[61] = "CloseBrace";
        TokenID.CloseBrace = 61;
        TokenID._map[62] = "Comma";
        TokenID.Comma = 62;
        TokenID._map[63] = "Equals";
        TokenID.Equals = 63;
        TokenID._map[64] = "PlusEquals";
        TokenID.PlusEquals = 64;
        TokenID._map[65] = "MinusEquals";
        TokenID.MinusEquals = 65;
        TokenID._map[66] = "AsteriskEquals";
        TokenID.AsteriskEquals = 66;
        TokenID._map[67] = "SlashEquals";
        TokenID.SlashEquals = 67;
        TokenID._map[68] = "PercentEquals";
        TokenID.PercentEquals = 68;
        TokenID._map[69] = "AmpersandEquals";
        TokenID.AmpersandEquals = 69;
        TokenID._map[70] = "CaretEquals";
        TokenID.CaretEquals = 70;
        TokenID._map[71] = "BarEquals";
        TokenID.BarEquals = 71;
        TokenID._map[72] = "LessThanLessThanEquals";
        TokenID.LessThanLessThanEquals = 72;
        TokenID._map[73] = "GreaterThanGreaterThanEquals";
        TokenID.GreaterThanGreaterThanEquals = 73;
        TokenID._map[74] = "GreaterThanGreaterThanGreaterThanEquals";
        TokenID.GreaterThanGreaterThanGreaterThanEquals = 74;
        TokenID._map[75] = "Question";
        TokenID.Question = 75;
        TokenID._map[76] = "Colon";
        TokenID.Colon = 76;
        TokenID._map[77] = "BarBar";
        TokenID.BarBar = 77;
        TokenID._map[78] = "AmpersandAmpersand";
        TokenID.AmpersandAmpersand = 78;
        TokenID._map[79] = "Bar";
        TokenID.Bar = 79;
        TokenID._map[80] = "Caret";
        TokenID.Caret = 80;
        TokenID._map[81] = "And";
        TokenID.And = 81;
        TokenID._map[82] = "EqualsEquals";
        TokenID.EqualsEquals = 82;
        TokenID._map[83] = "ExclamationEquals";
        TokenID.ExclamationEquals = 83;
        TokenID._map[84] = "EqualsEqualsEquals";
        TokenID.EqualsEqualsEquals = 84;
        TokenID._map[85] = "ExclamationEqualsEquals";
        TokenID.ExclamationEqualsEquals = 85;
        TokenID._map[86] = "LessThan";
        TokenID.LessThan = 86;
        TokenID._map[87] = "LessThanEquals";
        TokenID.LessThanEquals = 87;
        TokenID._map[88] = "GreaterThan";
        TokenID.GreaterThan = 88;
        TokenID._map[89] = "GreaterThanEquals";
        TokenID.GreaterThanEquals = 89;
        TokenID._map[90] = "LessThanLessThan";
        TokenID.LessThanLessThan = 90;
        TokenID._map[91] = "GreaterThanGreaterThan";
        TokenID.GreaterThanGreaterThan = 91;
        TokenID._map[92] = "GreaterThanGreaterThanGreaterThan";
        TokenID.GreaterThanGreaterThanGreaterThan = 92;
        TokenID._map[93] = "Plus";
        TokenID.Plus = 93;
        TokenID._map[94] = "Minus";
        TokenID.Minus = 94;
        TokenID._map[95] = "Asterisk";
        TokenID.Asterisk = 95;
        TokenID._map[96] = "Slash";
        TokenID.Slash = 96;
        TokenID._map[97] = "Percent";
        TokenID.Percent = 97;
        TokenID._map[98] = "Tilde";
        TokenID.Tilde = 98;
        TokenID._map[99] = "Exclamation";
        TokenID.Exclamation = 99;
        TokenID._map[100] = "PlusPlus";
        TokenID.PlusPlus = 100;
        TokenID._map[101] = "MinusMinus";
        TokenID.MinusMinus = 101;
        TokenID._map[102] = "Dot";
        TokenID.Dot = 102;
        TokenID._map[103] = "DotDotDot";
        TokenID.DotDotDot = 103;
        TokenID._map[104] = "Error";
        TokenID.Error = 104;
        TokenID._map[105] = "EndOfFile";
        TokenID.EndOfFile = 105;
        TokenID._map[106] = "EqualsGreaterThan";
        TokenID.EqualsGreaterThan = 106;
        TokenID._map[107] = "Identifier";
        TokenID.Identifier = 107;
        TokenID._map[108] = "StringLiteral";
        TokenID.StringLiteral = 108;
        TokenID._map[109] = "RegularExpressionLiteral";
        TokenID.RegularExpressionLiteral = 109;
        TokenID._map[110] = "NumberLiteral";
        TokenID.NumberLiteral = 110;
        TokenID._map[111] = "Whitespace";
        TokenID.Whitespace = 111;
        TokenID._map[112] = "Comment";
        TokenID.Comment = 112;
        TokenID._map[113] = "Lim";
        TokenID.Lim = 113;
        TokenID.LimFixed = TokenID.EqualsGreaterThan;
        TokenID.LimKeyword = TokenID.Yield;
    })(TypeScript.TokenID || (TypeScript.TokenID = {}));
    var TokenID = TypeScript.TokenID;
    TypeScript.tokenTable = new Array();
    TypeScript.nodeTypeTable = new Array();
    TypeScript.nodeTypeToTokTable = new Array();
    TypeScript.noRegexTable = new Array();
    TypeScript.noRegexTable[107 /* Identifier */ ] = true;
    TypeScript.noRegexTable[108 /* StringLiteral */ ] = true;
    TypeScript.noRegexTable[110 /* NumberLiteral */ ] = true;
    TypeScript.noRegexTable[109 /* RegularExpressionLiteral */ ] = true;
    TypeScript.noRegexTable[45 /* This */ ] = true;
    TypeScript.noRegexTable[100 /* PlusPlus */ ] = true;
    TypeScript.noRegexTable[101 /* MinusMinus */ ] = true;
    TypeScript.noRegexTable[57 /* CloseParen */ ] = true;
    TypeScript.noRegexTable[59 /* CloseBracket */ ] = true;
    TypeScript.noRegexTable[61 /* CloseBrace */ ] = true;
    TypeScript.noRegexTable[47 /* True */ ] = true;
    TypeScript.noRegexTable[17 /* False */ ] = true;
    (function (OperatorPrecedence) {
        OperatorPrecedence._map = [];
        OperatorPrecedence._map[0] = "None";
        OperatorPrecedence.None = 0;
        OperatorPrecedence._map[1] = "Comma";
        OperatorPrecedence.Comma = 1;
        OperatorPrecedence._map[2] = "Assignment";
        OperatorPrecedence.Assignment = 2;
        OperatorPrecedence._map[3] = "Conditional";
        OperatorPrecedence.Conditional = 3;
        OperatorPrecedence._map[4] = "LogicalOr";
        OperatorPrecedence.LogicalOr = 4;
        OperatorPrecedence._map[5] = "LogicalAnd";
        OperatorPrecedence.LogicalAnd = 5;
        OperatorPrecedence._map[6] = "BitwiseOr";
        OperatorPrecedence.BitwiseOr = 6;
        OperatorPrecedence._map[7] = "BitwiseExclusiveOr";
        OperatorPrecedence.BitwiseExclusiveOr = 7;
        OperatorPrecedence._map[8] = "BitwiseAnd";
        OperatorPrecedence.BitwiseAnd = 8;
        OperatorPrecedence._map[9] = "Equality";
        OperatorPrecedence.Equality = 9;
        OperatorPrecedence._map[10] = "Relational";
        OperatorPrecedence.Relational = 10;
        OperatorPrecedence._map[11] = "Shift";
        OperatorPrecedence.Shift = 11;
        OperatorPrecedence._map[12] = "Additive";
        OperatorPrecedence.Additive = 12;
        OperatorPrecedence._map[13] = "Multiplicative";
        OperatorPrecedence.Multiplicative = 13;
        OperatorPrecedence._map[14] = "Unary";
        OperatorPrecedence.Unary = 14;
        OperatorPrecedence._map[15] = "Lim";
        OperatorPrecedence.Lim = 15;
    })(TypeScript.OperatorPrecedence || (TypeScript.OperatorPrecedence = {}));
    var OperatorPrecedence = TypeScript.OperatorPrecedence;
    (function (Reservation) {
        Reservation._map = [];
        Reservation.None = 0;
        Reservation.Javascript = 1;
        Reservation.JavascriptFuture = 2;
        Reservation.TypeScript = 4;
        Reservation.JavascriptFutureStrict = 8;
        Reservation.TypeScriptAndJS = Reservation.Javascript | Reservation.TypeScript;
        Reservation.TypeScriptAndJSFuture = Reservation.JavascriptFuture | Reservation.TypeScript;
        Reservation.TypeScriptAndJSFutureStrict = Reservation.JavascriptFutureStrict | Reservation.TypeScript;
    })(TypeScript.Reservation || (TypeScript.Reservation = {}));
    var Reservation = TypeScript.Reservation;
    var TokenInfo = (function () {
        function TokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers) {
            this.tokenId = tokenId;
            this.reservation = reservation;
            this.binopPrecedence = binopPrecedence;
            this.binopNodeType = binopNodeType;
            this.unopPrecedence = unopPrecedence;
            this.unopNodeType = unopNodeType;
            this.text = text;
            this.ers = ers;
        }
        return TokenInfo;
    })();
    TypeScript.TokenInfo = TokenInfo;    
    function setTokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers) {
        if (tokenId !== undefined) {
            TypeScript.tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text, ers);
            if (binopNodeType != 0 /* None */ ) {
                TypeScript.nodeTypeTable[binopNodeType] = text;
                TypeScript.nodeTypeToTokTable[binopNodeType] = tokenId;
            }
            if (unopNodeType != 0 /* None */ ) {
                TypeScript.nodeTypeTable[unopNodeType] = text;
            }
        }
    }
    setTokenInfo(0 /* Any */ , 4 /* TypeScript */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "any", 512 /* PrimType */ );
    setTokenInfo(1 /* Bool */ , 4 /* TypeScript */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "bool", 512 /* PrimType */ );
    setTokenInfo(2 /* Break */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "break", 4194304 /* Stmt */ );
    setTokenInfo(3 /* Case */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "case", 262144 /* SCase */ );
    setTokenInfo(4 /* Catch */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "catch", 1048576 /* Catch */ );
    setTokenInfo(5 /* Class */ , Reservation.TypeScriptAndJSFuture, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "class", 1073741824 /* TypeScriptS */ );
    setTokenInfo(6 /* Const */ , Reservation.TypeScriptAndJSFuture, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "const", 2097152 /* Var */ );
    setTokenInfo(7 /* Continue */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "continue", 4194304 /* Stmt */ );
    setTokenInfo(8 /* Debugger */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 108 /* Debugger */ , "debugger", 4194304 /* Stmt */ );
    setTokenInfo(9 /* Default */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "default", 262144 /* SCase */ );
    setTokenInfo(10 /* Delete */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 14 /* Unary */ , 16 /* Delete */ , "delete", 33554432 /* Prefix */ );
    setTokenInfo(11 /* Do */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "do", 4194304 /* Stmt */ );
    setTokenInfo(12 /* Else */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "else", 524288 /* Else */ );
    setTokenInfo(13 /* Enum */ , Reservation.TypeScriptAndJSFuture, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "enum", 1073741824 /* TypeScriptS */ );
    setTokenInfo(14 /* Export */ , Reservation.TypeScriptAndJSFuture, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "export", 1073741824 /* TypeScriptS */ );
    setTokenInfo(15 /* Extends */ , Reservation.TypeScriptAndJSFuture, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "extends", 0 /* None */ );
    setTokenInfo(16 /* Declare */ , 4 /* TypeScript */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "declare", 4194304 /* Stmt */ );
    setTokenInfo(17 /* False */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "false", 134217728 /* RLit */ );
    setTokenInfo(18 /* Finally */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "finally", 1048576 /* Catch */ );
    setTokenInfo(19 /* For */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "for", 4194304 /* Stmt */ );
    setTokenInfo(20 /* Function */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "function", 268435456 /* Func */ );
    setTokenInfo(21 /* Constructor */ , Reservation.TypeScriptAndJSFutureStrict, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "constructor", 268435456 /* Func */ );
    setTokenInfo(22 /* Get */ , 4 /* TypeScript */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "get", 268435456 /* Func */ );
    setTokenInfo(39 /* Set */ , 4 /* TypeScript */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "set", 268435456 /* Func */ );
    setTokenInfo(23 /* If */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "if", 4194304 /* Stmt */ );
    setTokenInfo(24 /* Implements */ , Reservation.TypeScriptAndJSFutureStrict, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "implements", 0 /* None */ );
    setTokenInfo(25 /* Import */ , Reservation.TypeScriptAndJSFuture, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "import", 1073741824 /* TypeScriptS */ );
    setTokenInfo(26 /* In */ , Reservation.TypeScriptAndJS, 10 /* Relational */ , 18 /* In */ , 0 /* None */ , 0 /* None */ , "in", 0 /* None */ );
    setTokenInfo(27 /* InstanceOf */ , Reservation.TypeScriptAndJS, 10 /* Relational */ , 22 /* InstOf */ , 0 /* None */ , 0 /* None */ , "instanceof", 8 /* BinOp */ );
    setTokenInfo(28 /* Interface */ , Reservation.TypeScriptAndJSFutureStrict, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "interface", 1073741824 /* TypeScriptS */ );
    setTokenInfo(29 /* Let */ , 8 /* JavascriptFutureStrict */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "let", 0 /* None */ );
    setTokenInfo(30 /* Module */ , 4 /* TypeScript */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "module", 1073741824 /* TypeScriptS */ );
    setTokenInfo(31 /* New */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "new", 4096 /* PreOp */ );
    setTokenInfo(32 /* Number */ , 4 /* TypeScript */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "number", 512 /* PrimType */ );
    setTokenInfo(33 /* Null */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "null", 134217728 /* RLit */ );
    setTokenInfo(34 /* Package */ , 8 /* JavascriptFutureStrict */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "package", 0 /* None */ );
    setTokenInfo(35 /* Private */ , Reservation.TypeScriptAndJSFutureStrict, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "private", 1073741824 /* TypeScriptS */ );
    setTokenInfo(36 /* Protected */ , 8 /* JavascriptFutureStrict */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "protected", 0 /* None */ );
    setTokenInfo(37 /* Public */ , Reservation.TypeScriptAndJSFutureStrict, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "public", 1073741824 /* TypeScriptS */ );
    setTokenInfo(38 /* Return */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "return", 4194304 /* Stmt */ );
    setTokenInfo(40 /* Static */ , Reservation.TypeScriptAndJSFutureStrict, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "static", 0 /* None */ );
    setTokenInfo(41 /* Inline */ , Reservation.TypeScriptAndJSFutureStrict, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "inline", 1073741824 /* TypeScriptS */ );
    setTokenInfo(42 /* String */ , 4 /* TypeScript */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "string", 512 /* PrimType */ );
    setTokenInfo(43 /* Super */ , Reservation.TypeScriptAndJSFuture, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "super", 134217728 /* RLit */ );
    setTokenInfo(44 /* Switch */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "switch", 4194304 /* Stmt */ );
    setTokenInfo(45 /* This */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "this", 134217728 /* RLit */ );
    setTokenInfo(46 /* Throw */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "throw", 4194304 /* Stmt */ );
    setTokenInfo(47 /* True */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "true", 134217728 /* RLit */ );
    setTokenInfo(48 /* Try */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "try", 4194304 /* Stmt */ );
    setTokenInfo(49 /* TypeOf */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 14 /* Unary */ , 23 /* Typeof */ , "typeof", 33554432 /* Prefix */ );
    setTokenInfo(50 /* Var */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "var", 2097152 /* Var */ );
    setTokenInfo(51 /* Void */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 14 /* Unary */ , 12 /* Void */ , "void", 33554432 /* Prefix */ );
    setTokenInfo(52 /* With */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 100 /* With */ , "with", 4194304 /* Stmt */ );
    setTokenInfo(53 /* While */ , Reservation.TypeScriptAndJS, 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "while", 8388608 /* While */ );
    setTokenInfo(54 /* Yield */ , 8 /* JavascriptFutureStrict */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "yield", 0 /* None */ );
    setTokenInfo(107 /* Identifier */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "identifier", 16777216 /* ID */ );
    setTokenInfo(110 /* NumberLiteral */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "numberLiteral", 67108864 /* Literal */ );
    setTokenInfo(109 /* RegularExpressionLiteral */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "regex", 8192 /* RegExp */ );
    setTokenInfo(108 /* StringLiteral */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "qstring", 67108864 /* Literal */ );
    setTokenInfo(55 /* Semicolon */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , ";", 2 /* SColon */ );
    setTokenInfo(57 /* CloseParen */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , ")", 64 /* RParen */ );
    setTokenInfo(59 /* CloseBracket */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "]", 16 /* RBrack */ );
    setTokenInfo(60 /* OpenBrace */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "{", 2048 /* LCurly */ );
    setTokenInfo(61 /* CloseBrace */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "}", 32 /* RCurly */ );
    setTokenInfo(103 /* DotDotDot */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "...", 0 /* None */ );
    setTokenInfo(62 /* Comma */ , 0 /* None */ , 1 /* Comma */ , 13 /* Comma */ , 0 /* None */ , 0 /* None */ , ",", 1 /* Comma */ );
    setTokenInfo(63 /* Equals */ , 0 /* None */ , 2 /* Assignment */ , 32 /* Asg */ , 0 /* None */ , 0 /* None */ , "=", 4 /* Asg */ );
    setTokenInfo(64 /* PlusEquals */ , 0 /* None */ , 2 /* Assignment */ , 33 /* AsgAdd */ , 0 /* None */ , 0 /* None */ , "+=", 8 /* BinOp */ );
    setTokenInfo(65 /* MinusEquals */ , 0 /* None */ , 2 /* Assignment */ , 34 /* AsgSub */ , 0 /* None */ , 0 /* None */ , "-=", 8 /* BinOp */ );
    setTokenInfo(66 /* AsteriskEquals */ , 0 /* None */ , 2 /* Assignment */ , 36 /* AsgMul */ , 0 /* None */ , 0 /* None */ , "*=", 8 /* BinOp */ );
    setTokenInfo(67 /* SlashEquals */ , 0 /* None */ , 2 /* Assignment */ , 35 /* AsgDiv */ , 0 /* None */ , 0 /* None */ , "/=", 8 /* BinOp */ );
    setTokenInfo(68 /* PercentEquals */ , 0 /* None */ , 2 /* Assignment */ , 37 /* AsgMod */ , 0 /* None */ , 0 /* None */ , "%=", 8 /* BinOp */ );
    setTokenInfo(69 /* AmpersandEquals */ , 0 /* None */ , 2 /* Assignment */ , 38 /* AsgAnd */ , 0 /* None */ , 0 /* None */ , "&=", 8 /* BinOp */ );
    setTokenInfo(70 /* CaretEquals */ , 0 /* None */ , 2 /* Assignment */ , 39 /* AsgXor */ , 0 /* None */ , 0 /* None */ , "^=", 8 /* BinOp */ );
    setTokenInfo(71 /* BarEquals */ , 0 /* None */ , 2 /* Assignment */ , 40 /* AsgOr */ , 0 /* None */ , 0 /* None */ , "|=", 8 /* BinOp */ );
    setTokenInfo(72 /* LessThanLessThanEquals */ , 0 /* None */ , 2 /* Assignment */ , 41 /* AsgLsh */ , 0 /* None */ , 0 /* None */ , "<<=", 8 /* BinOp */ );
    setTokenInfo(73 /* GreaterThanGreaterThanEquals */ , 0 /* None */ , 2 /* Assignment */ , 42 /* AsgRsh */ , 0 /* None */ , 0 /* None */ , ">>=", 8 /* BinOp */ );
    setTokenInfo(74 /* GreaterThanGreaterThanGreaterThanEquals */ , 0 /* None */ , 2 /* Assignment */ , 43 /* AsgRs2 */ , 0 /* None */ , 0 /* None */ , ">>>=", 8 /* BinOp */ );
    setTokenInfo(75 /* Question */ , 0 /* None */ , 3 /* Conditional */ , 44 /* ConditionalExpression */ , 0 /* None */ , 0 /* None */ , "?", 8 /* BinOp */ );
    setTokenInfo(76 /* Colon */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , ":", 256 /* Colon */ );
    setTokenInfo(77 /* BarBar */ , 0 /* None */ , 4 /* LogicalOr */ , 45 /* LogOr */ , 0 /* None */ , 0 /* None */ , "||", 8 /* BinOp */ );
    setTokenInfo(78 /* AmpersandAmpersand */ , 0 /* None */ , 5 /* LogicalAnd */ , 46 /* LogAnd */ , 0 /* None */ , 0 /* None */ , "&&", 8 /* BinOp */ );
    setTokenInfo(79 /* Bar */ , 0 /* None */ , 6 /* BitwiseOr */ , 47 /* Or */ , 0 /* None */ , 0 /* None */ , "|", 8 /* BinOp */ );
    setTokenInfo(80 /* Caret */ , 0 /* None */ , 7 /* BitwiseExclusiveOr */ , 48 /* Xor */ , 0 /* None */ , 0 /* None */ , "^", 8 /* BinOp */ );
    setTokenInfo(81 /* And */ , 0 /* None */ , 8 /* BitwiseAnd */ , 49 /* And */ , 0 /* None */ , 0 /* None */ , "&", 8 /* BinOp */ );
    setTokenInfo(82 /* EqualsEquals */ , 0 /* None */ , 9 /* Equality */ , 50 /* Eq */ , 0 /* None */ , 0 /* None */ , "==", 8 /* BinOp */ );
    setTokenInfo(83 /* ExclamationEquals */ , 0 /* None */ , 9 /* Equality */ , 51 /* Ne */ , 0 /* None */ , 0 /* None */ , "!=", 8 /* BinOp */ );
    setTokenInfo(84 /* EqualsEqualsEquals */ , 0 /* None */ , 9 /* Equality */ , 52 /* Eqv */ , 0 /* None */ , 0 /* None */ , "===", 8 /* BinOp */ );
    setTokenInfo(85 /* ExclamationEqualsEquals */ , 0 /* None */ , 9 /* Equality */ , 53 /* NEqv */ , 0 /* None */ , 0 /* None */ , "!==", 8 /* BinOp */ );
    setTokenInfo(86 /* LessThan */ , 0 /* None */ , 10 /* Relational */ , 54 /* Lt */ , 0 /* None */ , 0 /* None */ , "<", 8 /* BinOp */ );
    setTokenInfo(87 /* LessThanEquals */ , 0 /* None */ , 10 /* Relational */ , 55 /* Le */ , 0 /* None */ , 0 /* None */ , "<=", 8 /* BinOp */ );
    setTokenInfo(88 /* GreaterThan */ , 0 /* None */ , 10 /* Relational */ , 56 /* Gt */ , 0 /* None */ , 0 /* None */ , ">", 8 /* BinOp */ );
    setTokenInfo(89 /* GreaterThanEquals */ , 0 /* None */ , 10 /* Relational */ , 57 /* Ge */ , 0 /* None */ , 0 /* None */ , ">=", 8 /* BinOp */ );
    setTokenInfo(90 /* LessThanLessThan */ , 0 /* None */ , 11 /* Shift */ , 63 /* Lsh */ , 0 /* None */ , 0 /* None */ , "<<", 8 /* BinOp */ );
    setTokenInfo(91 /* GreaterThanGreaterThan */ , 0 /* None */ , 11 /* Shift */ , 64 /* Rsh */ , 0 /* None */ , 0 /* None */ , ">>", 8 /* BinOp */ );
    setTokenInfo(92 /* GreaterThanGreaterThanGreaterThan */ , 0 /* None */ , 11 /* Shift */ , 65 /* Rs2 */ , 0 /* None */ , 0 /* None */ , ">>>", 8 /* BinOp */ );
    setTokenInfo(93 /* Plus */ , 0 /* None */ , 12 /* Additive */ , 58 /* Add */ , 14 /* Unary */ , 14 /* Pos */ , "+", 1024 /* AddOp */ );
    setTokenInfo(94 /* Minus */ , 0 /* None */ , 12 /* Additive */ , 59 /* Sub */ , 14 /* Unary */ , 15 /* Neg */ , "-", 1024 /* AddOp */ );
    setTokenInfo(95 /* Asterisk */ , 0 /* None */ , 13 /* Multiplicative */ , 60 /* Mul */ , 0 /* None */ , 0 /* None */ , "*", 8 /* BinOp */ );
    setTokenInfo(96 /* Slash */ , 0 /* None */ , 13 /* Multiplicative */ , 61 /* Div */ , 0 /* None */ , 0 /* None */ , "/", 8 /* BinOp */ );
    setTokenInfo(97 /* Percent */ , 0 /* None */ , 13 /* Multiplicative */ , 62 /* Mod */ , 0 /* None */ , 0 /* None */ , "%", 8 /* BinOp */ );
    setTokenInfo(98 /* Tilde */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 14 /* Unary */ , 66 /* Not */ , "~", 4096 /* PreOp */ );
    setTokenInfo(99 /* Exclamation */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 14 /* Unary */ , 67 /* LogNot */ , "!", 4096 /* PreOp */ );
    setTokenInfo(100 /* PlusPlus */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 14 /* Unary */ , 68 /* IncPre */ , "++", 4096 /* PreOp */ );
    setTokenInfo(101 /* MinusMinus */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 14 /* Unary */ , 69 /* DecPre */ , "--", 4096 /* PreOp */ );
    setTokenInfo(56 /* OpenParen */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "(", 16384 /* LParen */ );
    setTokenInfo(58 /* OpenBracket */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "[", 32768 /* LBrack */ );
    setTokenInfo(102 /* Dot */ , 0 /* None */ , 14 /* Unary */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , ".", 128 /* Dot */ );
    setTokenInfo(105 /* EndOfFile */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "<EOF>", 536870912 /* EOF */ );
    setTokenInfo(106 /* EqualsGreaterThan */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , 0 /* None */ , "=>", 0 /* None */ );
    function lookupToken(tokenId) {
        return TypeScript.tokenTable[tokenId];
    }
    TypeScript.lookupToken = lookupToken;
    (function (TokenClass) {
        TokenClass._map = [];
        TokenClass._map[0] = "Punctuation";
        TokenClass.Punctuation = 0;
        TokenClass._map[1] = "Keyword";
        TokenClass.Keyword = 1;
        TokenClass._map[2] = "Operator";
        TokenClass.Operator = 2;
        TokenClass._map[3] = "Comment";
        TokenClass.Comment = 3;
        TokenClass._map[4] = "Whitespace";
        TokenClass.Whitespace = 4;
        TokenClass._map[5] = "Identifier";
        TokenClass.Identifier = 5;
        TokenClass._map[6] = "NumberLiteral";
        TokenClass.NumberLiteral = 6;
        TokenClass._map[7] = "StringLiteral";
        TokenClass.StringLiteral = 7;
        TokenClass._map[8] = "RegExpLiteral";
        TokenClass.RegExpLiteral = 8;
    })(TypeScript.TokenClass || (TypeScript.TokenClass = {}));
    var TokenClass = TypeScript.TokenClass;
    var SavedToken = (function () {
        function SavedToken(tok, minChar, limChar) {
            this.tok = tok;
            this.minChar = minChar;
            this.limChar = limChar;
        }
        return SavedToken;
    })();
    TypeScript.SavedToken = SavedToken;    
    var Token = (function () {
        function Token(tokenId) {
            this.tokenId = tokenId;
        }
        Token.prototype.toString = function () {
            return "token: " + this.tokenId + " " + this.getText() + " (" + (TokenID)._map[this.tokenId] + ")";
        };
        Token.prototype.print = function (line, outfile) {
            outfile.WriteLine(this.toString() + ",on line" + line);
        };
        Token.prototype.getText = function () {
            return TypeScript.tokenTable[this.tokenId].text;
        };
        Token.prototype.classification = function () {
            if (this.tokenId <= 54 /* LimKeyword */ ) {
                return 1 /* Keyword */ ;
            } else {
                var tokenInfo = lookupToken(this.tokenId);
                if (tokenInfo != undefined) {
                    if ((tokenInfo.unopNodeType != 0 /* None */ ) || (tokenInfo.binopNodeType != 0 /* None */ )) {
                        return 2 /* Operator */ ;
                    }
                }
            }
            return 0 /* Punctuation */ ;
        };
        return Token;
    })();
    TypeScript.Token = Token;    
    var NumberLiteralToken = (function (_super) {
        __extends(NumberLiteralToken, _super);
        function NumberLiteralToken(value, text) {
                _super.call(this, 110 /* NumberLiteral */ );
            this.value = value;
            this.text = text;
        }
        NumberLiteralToken.prototype.getText = function () {
            return this.text;
        };
        NumberLiteralToken.prototype.classification = function () {
            return 6 /* NumberLiteral */ ;
        };
        return NumberLiteralToken;
    })(Token);
    TypeScript.NumberLiteralToken = NumberLiteralToken;    
    var StringLiteralToken = (function (_super) {
        __extends(StringLiteralToken, _super);
        function StringLiteralToken(value) {
                _super.call(this, 108 /* StringLiteral */ );
            this.value = value;
        }
        StringLiteralToken.prototype.getText = function () {
            return this.value;
        };
        StringLiteralToken.prototype.classification = function () {
            return 7 /* StringLiteral */ ;
        };
        return StringLiteralToken;
    })(Token);
    TypeScript.StringLiteralToken = StringLiteralToken;    
    var IdentifierToken = (function (_super) {
        __extends(IdentifierToken, _super);
        function IdentifierToken(value, hasEscapeSequence) {
                _super.call(this, 107 /* Identifier */ );
            this.value = value;
            this.hasEscapeSequence = hasEscapeSequence;
        }
        IdentifierToken.prototype.getText = function () {
            return this.value;
        };
        IdentifierToken.prototype.classification = function () {
            return 5 /* Identifier */ ;
        };
        return IdentifierToken;
    })(Token);
    TypeScript.IdentifierToken = IdentifierToken;    
    var WhitespaceToken = (function (_super) {
        __extends(WhitespaceToken, _super);
        function WhitespaceToken(tokenId, value) {
                _super.call(this, tokenId);
            this.value = value;
        }
        WhitespaceToken.prototype.getText = function () {
            return this.value;
        };
        WhitespaceToken.prototype.classification = function () {
            return 4 /* Whitespace */ ;
        };
        return WhitespaceToken;
    })(Token);
    TypeScript.WhitespaceToken = WhitespaceToken;    
    var CommentToken = (function (_super) {
        __extends(CommentToken, _super);
        function CommentToken(tokenID, value, isBlock, startPos, line, endsLine) {
                _super.call(this, tokenID);
            this.value = value;
            this.isBlock = isBlock;
            this.startPos = startPos;
            this.line = line;
            this.endsLine = endsLine;
        }
        CommentToken.prototype.getText = function () {
            return this.value;
        };
        CommentToken.prototype.classification = function () {
            return 3 /* Comment */ ;
        };
        return CommentToken;
    })(Token);
    TypeScript.CommentToken = CommentToken;    
    var RegularExpressionLiteralToken = (function (_super) {
        __extends(RegularExpressionLiteralToken, _super);
        function RegularExpressionLiteralToken(text) {
                _super.call(this, 109 /* RegularExpressionLiteral */ );
            this.text = text;
        }
        RegularExpressionLiteralToken.prototype.getText = function () {
            return this.text;
        };
        RegularExpressionLiteralToken.prototype.classification = function () {
            return 8 /* RegExpLiteral */ ;
        };
        return RegularExpressionLiteralToken;
    })(Token);
    TypeScript.RegularExpressionLiteralToken = RegularExpressionLiteralToken;    
    TypeScript.staticTokens = new Array();
    function initializeStaticTokens() {
        for(var i = 0; i <= 106 /* LimFixed */ ; i++) {
            TypeScript.staticTokens[i] = new Token(i);
        }
    }
    TypeScript.initializeStaticTokens = initializeStaticTokens;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ArrayCache = (function () {
        function ArrayCache() {
            this.arrayBase = null;
        }
        ArrayCache.prototype.specialize = function (arrInstType, checker) {
            if (this.arrayBase == null) {
                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType, checker, true);
            }
            return this.arrayBase;
        };
        return ArrayCache;
    })();
    TypeScript.ArrayCache = ArrayCache;    
    var TypeComparisonInfo = (function () {
        function TypeComparisonInfo() {
            this.onlyCaptureFirstError = false;
            this.flags = 0 /* SuccessfulComparison */ ;
            this.message = "";
        }
        TypeComparisonInfo.prototype.addMessageToFront = function (message) {
            if (!this.onlyCaptureFirstError) {
                this.message = this.message ? message + ":\n\t" + this.message : message;
            } else {
                this.setMessage(message);
            }
        };
        TypeComparisonInfo.prototype.setMessage = function (message) {
            this.message = message;
        };
        return TypeComparisonInfo;
    })();
    TypeScript.TypeComparisonInfo = TypeComparisonInfo;    
    (function (TypeCheckCollectionMode) {
        TypeCheckCollectionMode._map = [];
        TypeCheckCollectionMode._map[0] = "Resident";
        TypeCheckCollectionMode.Resident = 0;
        TypeCheckCollectionMode._map[1] = "Transient";
        TypeCheckCollectionMode.Transient = 1;
    })(TypeScript.TypeCheckCollectionMode || (TypeScript.TypeCheckCollectionMode = {}));
    var TypeCheckCollectionMode = TypeScript.TypeCheckCollectionMode;
    var PersistentGlobalTypeState = (function () {
        function PersistentGlobalTypeState(errorReporter) {
            this.errorReporter = errorReporter;
            this.importedGlobalsTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            this.importedGlobalsTypeTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            this.globals = null;
            this.globalTypes = null;
            this.ambientGlobals = null;
            this.ambientGlobalTypes = null;
            this.residentGlobalValues = new TypeScript.StringHashTable();
            this.residentGlobalTypes = new TypeScript.StringHashTable();
            this.residentGlobalAmbientValues = new TypeScript.StringHashTable();
            this.residentGlobalAmbientTypes = new TypeScript.StringHashTable();
            this.residentTypeCheck = true;
            this.mod = null;
            this.gloMod = null;
            this.wildElm = null;
            this.importedGlobals = new TypeScript.SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);
            this.dualGlobalValues = new TypeScript.DualStringHashTable(this.residentGlobalValues, new TypeScript.StringHashTable());
            this.dualGlobalTypes = new TypeScript.DualStringHashTable(this.residentGlobalTypes, new TypeScript.StringHashTable());
            this.dualAmbientGlobalValues = new TypeScript.DualStringHashTable(this.residentGlobalAmbientValues, new TypeScript.StringHashTable());
            this.dualAmbientGlobalTypes = new TypeScript.DualStringHashTable(this.residentGlobalAmbientTypes, new TypeScript.StringHashTable());
            var dualGlobalScopedMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualGlobalValues, new TypeScript.StringHashTable()));
            var dualGlobalScopedAmbientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualAmbientGlobalValues, new TypeScript.StringHashTable()));
            var dualGlobalScopedEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualGlobalTypes, new TypeScript.StringHashTable()));
            var dualGlobalScopedAmbientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(this.dualAmbientGlobalTypes, new TypeScript.StringHashTable()));
            this.globalScope = new TypeScript.SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);
            this.voidType = this.enterPrimitive(1 /* Void */ , "void");
            this.booleanType = this.enterPrimitive(8 /* Boolean */ , "bool");
            this.doubleType = this.enterPrimitive(2 /* Double */ , "number");
            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol);
            this.stringType = this.enterPrimitive(4 /* String */ , "string");
            this.anyType = this.enterPrimitive(16 /* Any */ , "any");
            this.nullType = this.enterPrimitive(32 /* Null */ , "null");
            this.undefinedType = this.enterPrimitive(64 /* Undefined */ , "undefined");
            this.setCollectionMode(0 /* Resident */ );
            this.wildElm = new TypeScript.TypeSymbol("_element", -1, 0, -1, new TypeScript.Type());
            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);
            this.mod = new TypeScript.ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);
            this.mod.members = dualGlobalScopedMembers;
            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;
            this.mod.containedScope = this.globalScope;
            this.gloMod = new TypeScript.TypeSymbol(TypeScript.globalId, -1, 0, -1, this.mod);
            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);
            this.defineGlobalValue("undefined", this.undefinedType);
        }
        PersistentGlobalTypeState.prototype.enterPrimitive = function (flags, name) {
            var primitive = new TypeScript.Type();
            primitive.primitiveTypeClass = flags;
            var symbol = new TypeScript.TypeSymbol(name, -1, name.length, -1, primitive);
            symbol.typeCheckStatus = 2 /* Finished */ ;
            primitive.symbol = symbol;
            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);
            return primitive;
        };
        PersistentGlobalTypeState.prototype.setCollectionMode = function (mode) {
            this.residentTypeCheck = this.dualGlobalValues.insertPrimary = this.dualGlobalTypes.insertPrimary = this.dualAmbientGlobalValues.insertPrimary = this.dualAmbientGlobalTypes.insertPrimary = mode == 0 /* Resident */ ;
        };
        PersistentGlobalTypeState.prototype.refreshPersistentState = function () {
            this.globals = new TypeScript.StringHashTable();
            this.globalTypes = new TypeScript.StringHashTable();
            this.ambientGlobals = new TypeScript.StringHashTable();
            this.ambientGlobalTypes = new TypeScript.StringHashTable();
            this.globalTypes.add(this.voidType.symbol.name, this.voidType.symbol);
            this.globalTypes.add(this.booleanType.symbol.name, this.booleanType.symbol);
            this.globalTypes.add(this.doubleType.symbol.name, this.doubleType.symbol);
            this.globalTypes.add("number", this.doubleType.symbol);
            this.globalTypes.add(this.stringType.symbol.name, this.stringType.symbol);
            this.globalTypes.add(this.anyType.symbol.name, this.anyType.symbol);
            this.globalTypes.add(this.nullType.symbol.name, this.nullType.symbol);
            this.globalTypes.add(this.undefinedType.symbol.name, this.undefinedType.symbol);
            this.dualGlobalValues.secondaryTable = this.globals;
            this.dualGlobalTypes.secondaryTable = this.globalTypes;
            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;
            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;
        };
        PersistentGlobalTypeState.prototype.defineGlobalValue = function (name, type) {
            var valueLocation = new TypeScript.ValueLocation();
            valueLocation.typeLink = new TypeScript.TypeLink();
            var sym = new TypeScript.VariableSymbol(name, 0, -1, valueLocation);
            sym.setType(type);
            sym.typeCheckStatus = 2 /* Finished */ ;
            sym.container = this.gloMod;
            this.importedGlobalsTable.addPublicMember(name, sym);
        };
        return PersistentGlobalTypeState;
    })();
    TypeScript.PersistentGlobalTypeState = PersistentGlobalTypeState;    
    var ContextualTypeContext = (function () {
        function ContextualTypeContext(contextualType, provisional, contextID) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.contextID = contextID;
            this.targetSig = null;
            this.targetThis = null;
            this.targetAccessorType = null;
        }
        return ContextualTypeContext;
    })();
    TypeScript.ContextualTypeContext = ContextualTypeContext;    
    var ContextualTypingContextStack = (function () {
        function ContextualTypingContextStack(checker) {
            this.checker = checker;
            this.contextStack = [];
            this.hadProvisionalErrors = false;
        }
        ContextualTypingContextStack.contextID = 2 /* Finished */  + 1;
        ContextualTypingContextStack.prototype.pushContextualType = function (type, provisional) {
            this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++));
            this.checker.errorReporter.pushToErrorSink = provisional;
        };
        ContextualTypingContextStack.prototype.popContextualType = function () {
            var tc = this.contextStack.pop();
            this.checker.errorReporter.pushToErrorSink = this.isProvisional();
            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));
            this.checker.errorReporter.freeCapturedErrors();
            return tc;
        };
        ContextualTypingContextStack.prototype.getContextualType = function () {
            return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]);
        };
        ContextualTypingContextStack.prototype.getContextID = function () {
            return (!this.contextStack.length ? 2 /* Finished */  : this.contextStack[this.contextStack.length - 1].contextID);
        };
        ContextualTypingContextStack.prototype.isProvisional = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };
        return ContextualTypingContextStack;
    })();
    TypeScript.ContextualTypingContextStack = ContextualTypingContextStack;    
    var TypeChecker = (function () {
        function TypeChecker(persistentState) {
            this.persistentState = persistentState;
            this.errorReporter = null;
            this.checkControlFlow = false;
            this.printControlFlowGraph = false;
            this.checkControlFlowUseDef = false;
            this.styleSettings = null;
            this.units = null;
            this.anon = "_anonymous";
            this.locationInfo = null;
            this.typeFlow = null;
            this.currentCompareA = null;
            this.currentCompareB = null;
            this.currentModDecl = null;
            this.inBind = false;
            this.inWith = false;
            this.errorsOnWith = true;
            this.currentContextualTypeContext = null;
            this.resolvingBases = false;
            this.canCallDefinitionSignature = false;
            this.assignableCache = {};
            this.subtypeCache = {};
            this.identicalCache = {};
            this.provisionalStartedTypecheckObjects = [];
            this.mustCaptureGlobalThis = false;
            this.voidType = this.persistentState.voidType;
            this.booleanType = this.persistentState.booleanType;
            this.numberType = this.persistentState.doubleType;
            this.stringType = this.persistentState.stringType;
            this.anyType = this.persistentState.anyType;
            this.nullType = this.persistentState.nullType;
            this.undefinedType = this.persistentState.undefinedType;
            this.globals = this.persistentState.dualGlobalValues;
            this.globalTypes = this.persistentState.dualGlobalTypes;
            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;
            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;
            this.gloModType = this.persistentState.mod;
            this.gloMod = this.persistentState.gloMod;
            this.wildElm = this.persistentState.wildElm;
            this.globalScope = this.persistentState.globalScope;
            this.typingContextStack = new ContextualTypingContextStack(this);
        }
        TypeChecker.prototype.setStyleOptions = function (style) {
            this.styleSettings = style;
        };
        TypeChecker.prototype.setContextualType = function (type, provisional) {
            this.typingContextStack.pushContextualType(type, provisional);
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
        };
        TypeChecker.prototype.unsetContextualType = function () {
            var lastTC = this.typingContextStack.popContextualType();
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
            return lastTC;
        };
        TypeChecker.prototype.hadProvisionalErrors = function () {
            return this.typingContextStack.hadProvisionalErrors;
        };
        TypeChecker.prototype.resetProvisionalErrors = function () {
            if (!this.typingContextStack.getContextualType()) {
                this.typingContextStack.hadProvisionalErrors = false;
            }
        };
        TypeChecker.prototype.typeCheckWithContextualType = function (contextType, provisional, condition, ast) {
            if (condition) {
                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);
            }
            this.typeFlow.typeCheck(ast);
            if (condition) {
                this.unsetContextualType();
            }
        };
        TypeChecker.prototype.resetTargetType = function () {
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
        };
        TypeChecker.prototype.killCurrentContextualType = function () {
            this.currentContextualTypeContext = null;
            this.errorReporter.pushToErrorSink = false;
        };
        TypeChecker.prototype.hasTargetType = function () {
            return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType;
        };
        TypeChecker.prototype.getTargetTypeContext = function () {
            return this.currentContextualTypeContext;
        };
        TypeChecker.prototype.inProvisionalTypecheckMode = function () {
            return this.typingContextStack.isProvisional();
        };
        TypeChecker.prototype.getTypeCheckFinishedStatus = function () {
            if (this.inProvisionalTypecheckMode()) {
                return this.typingContextStack.getContextID();
            }
            return 2 /* Finished */ ;
        };
        TypeChecker.prototype.typeStatusIsFinished = function (status) {
            return status == 2 /* Finished */  || (this.inProvisionalTypecheckMode() && status == this.typingContextStack.getContextID());
        };
        TypeChecker.prototype.addStartedPTO = function (pto) {
            if (this.inProvisionalTypecheckMode()) {
                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;
            }
        };
        TypeChecker.prototype.cleanStartedPTO = function () {
            for(var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {
                if (this.provisionalStartedTypecheckObjects[i].typeCheckStatus >= this.typingContextStack.getContextID()) {
                    this.provisionalStartedTypecheckObjects[i].typeCheckStatus = 0 /* NotStarted */ ;
                }
            }
            this.provisionalStartedTypecheckObjects = [];
        };
        TypeChecker.prototype.collectTypes = function (ast) {
            if (ast.nodeType == 95 /* Script */ ) {
                var script = ast;
                this.locationInfo = script.locationInfo;
            }
            var globalChain = new TypeScript.ScopeChain(this.gloMod, null, this.globalScope);
            var context = new TypeScript.TypeCollectionContext(globalChain, this);
            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.preCollectTypes, TypeScript.postCollectTypes, null, context);
        };
        TypeChecker.prototype.makeArrayType = function (type) {
            if (type.arrayCache == null) {
                type.arrayCache = new ArrayCache();
                type.arrayCache.arrayType = new TypeScript.Type();
                type.arrayCache.arrayType.elementType = type;
                type.arrayCache.arrayType.symbol = type.symbol;
            }
            return type.arrayCache.arrayType;
        };
        TypeChecker.prototype.getParameterList = function (funcDecl, container) {
            var args = funcDecl.arguments;
            var parameterTable = null;
            var parameterBuilder = null;
            var len = args.members.length;
            var nonOptionalParams = 0;
            var result = [];
            if (len > 0) {
                parameterTable = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                parameterBuilder = new TypeScript.SymbolScopeBuilder(parameterTable, null, null, null, null, container);
                for(var i = 0; i < len; i++) {
                    var parameter = args.members[i];
                    var paramDef = new TypeScript.ValueLocation();
                    var parameterSymbol = new TypeScript.ParameterSymbol(parameter.id.text, parameter.minChar, this.locationInfo.unitIndex, paramDef);
                    parameterSymbol.declAST = parameter;
                    parameterSymbol.funcDecl = funcDecl;
                    parameter.id.sym = parameterSymbol;
                    parameter.sym = parameterSymbol;
                    paramDef.symbol = parameterSymbol;
                    paramDef.typeLink = TypeScript.getTypeLink(parameter.typeExpr, this, false);
                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false);
                    result[result.length] = parameterSymbol;
                    if (!parameter.isOptionalArg()) {
                        nonOptionalParams++;
                    }
                }
            }
            return {
                parameters: result,
                nonOptionalParameterCount: nonOptionalParams
            };
        };
        TypeChecker.prototype.createFunctionSignature = function (funcDecl, container, scope, overloadGroupSym, addToScope) {
            var isExported = TypeScript.hasFlag(funcDecl.fncFlags, 1 /* Exported */  | 524288 /* ClassPropertyMethodExported */ ) || container == this.gloMod;
            var isStatic = TypeScript.hasFlag(funcDecl.fncFlags, 16 /* Static */ );
            var isPrivate = TypeScript.hasFlag(funcDecl.fncFlags, 2 /* Private */ );
            var isDefinition = !TypeScript.hasFlag(funcDecl.fncFlags, 512 /* Signature */ );
            var isAmbient = TypeScript.hasFlag(funcDecl.fncFlags, 8 /* Ambient */ );
            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;
            var isGlobal = container == this.gloMod;
            var signature = new TypeScript.Signature();
            var isLambda = funcDecl.fncFlags & 131072 /* IsFunctionExpression */ ;
            if (funcDecl.returnTypeAnnotation || isDefinition) {
                signature.returnType = TypeScript.getTypeLink(funcDecl.returnTypeAnnotation, this, false);
            } else {
                signature.returnType = new TypeScript.TypeLink();
                signature.returnType.type = this.anyType;
            }
            signature.hasVariableArgList = funcDecl.variableArgList;
            var sigData = this.getParameterList(funcDecl, container);
            signature.parameters = sigData.parameters;
            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;
            funcDecl.signature = signature;
            signature.declAST = funcDecl;
            var useOverloadGroupSym = overloadGroupSym && overloadGroupSym.getType() && !overloadGroupSym.isAccessor() && (funcDecl.isSignature() || (isAmbient == TypeScript.hasFlag(overloadGroupSym.flags, 8 /* Ambient */ )));
            if (useOverloadGroupSym && isPrivate != TypeScript.hasFlag(overloadGroupSym.flags, 2 /* Private */ )) {
                this.errorReporter.simpleError(funcDecl, "Public/Private visibility of overloads does not agree");
            }
            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new TypeScript.Type();
            if (isConstructor) {
                if (groupType.construct == null) {
                    groupType.construct = new TypeScript.SignatureGroup();
                }
                groupType.construct.addSignature(signature);
                groupType.construct.hasImplementation = !(funcDecl.isSignature());
                if (groupType.construct.hasImplementation) {
                    groupType.setHasImplementation();
                }
            } else if (funcDecl.isIndexerMember()) {
                if (groupType.index == null) {
                    groupType.index = new TypeScript.SignatureGroup();
                    groupType.index.flags |= 1 /* IsIndexer */ ;
                }
                groupType.index.addSignature(signature);
                groupType.index.hasImplementation = !(funcDecl.isSignature());
                if (groupType.index.hasImplementation) {
                    groupType.setHasImplementation();
                }
            } else {
                if (groupType.call == null) {
                    groupType.call = new TypeScript.SignatureGroup();
                }
                groupType.call.addSignature(signature);
                groupType.call.hasImplementation = !(funcDecl.isSignature());
                if (groupType.call.hasImplementation) {
                    groupType.setHasImplementation();
                }
            }
            var instanceType = groupType.instanceType;
            var funcName = null;
            var usedHint = false;
            if (funcDecl.name && !funcDecl.name.isMissing()) {
                funcName = funcDecl.name.text;
            } else if (funcDecl.hint) {
                funcName = funcDecl.hint;
                usedHint = true;
            }
            if (groupType.symbol == null) {
                groupType.symbol = new TypeScript.TypeSymbol(funcName ? funcName : this.anon, funcDecl.minChar, funcDecl.limChar - funcDecl.minChar, this.locationInfo.unitIndex, groupType);
                if (!useOverloadGroupSym) {
                    groupType.symbol.declAST = funcDecl;
                }
            }
            if (isStatic) {
                groupType.symbol.flags |= 16 /* Static */ ;
            }
            if (isAmbient) {
                groupType.symbol.flags |= 8 /* Ambient */ ;
            }
            if (isPrivate) {
                groupType.symbol.flags |= 2 /* Private */ ;
            }
            groupType.symbol.isMethod = funcDecl.isMethod();
            if (groupType.symbol.isMethod) {
                groupType.symbol.flags |= 256 /* Property */ ;
            }
            funcDecl.type = groupType;
            if (!isConstructor) {
                if (funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {
                    if (addToScope) {
                        if (funcDecl.isMethod() && isStatic) {
                            if (!(container).type.members.publicMembers.add(funcName, groupType.symbol)) {
                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);
                            }
                            groupType.symbol.container = container;
                        } else if (overloadGroupSym == null || (overloadGroupSym.declAST && !(overloadGroupSym.declAST).isOverload && (container.isType()))) {
                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);
                        }
                    } else if (!funcDecl.isSpecialFn()) {
                        groupType.symbol.container = container;
                    }
                } else if (!funcDecl.isSpecialFn()) {
                    groupType.symbol.container = container;
                }
            }
            if (useOverloadGroupSym) {
                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;
                var classType = groupType;
                if (classType != overloadGroupType) {
                    if (classType.construct == null) {
                        if (overloadGroupType && overloadGroupType.construct) {
                            classType.construct = overloadGroupType.construct;
                        } else {
                            classType.construct = new TypeScript.SignatureGroup();
                        }
                    } else if (overloadGroupType) {
                        if (overloadGroupType.construct) {
                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);
                        }
                    }
                    if (overloadGroupType) {
                        if (classType.call == null) {
                            classType.call = overloadGroupType.call;
                        } else if (overloadGroupType.call) {
                            classType.call.signatures.concat(overloadGroupType.call.signatures);
                        }
                        if (!isStatic) {
                            if (classType.instanceType == null) {
                                classType.instanceType = overloadGroupType.instanceType;
                            }
                            var instanceType = classType.instanceType;
                            if (instanceType) {
                                if (instanceType.call == null) {
                                    instanceType.call = overloadGroupType.call;
                                } else if (overloadGroupType.call) {
                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);
                                }
                            }
                        }
                        if (classType.index == null) {
                            classType.index = overloadGroupType.index;
                        } else if (overloadGroupType.index) {
                            classType.index.signatures.concat(overloadGroupType.index.signatures);
                        }
                    }
                }
            }
            return signature;
        };
        TypeChecker.prototype.createAccessorSymbol = function (funcDecl, fgSym, enclosingClass, addToMembers, isClassProperty, scope, container) {
            var accessorSym = null;
            var sig = funcDecl.signature;
            var nameText = funcDecl.name.text;
            var isStatic = TypeScript.hasFlag(funcDecl.fncFlags, 16 /* Static */ );
            var isPrivate = TypeScript.hasFlag(funcDecl.fncFlags, 2 /* Private */ );
            if (fgSym == null) {
                var field = new TypeScript.ValueLocation();
                accessorSym = new TypeScript.FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field);
                field.symbol = accessorSym;
                accessorSym.declAST = funcDecl;
                if (TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ )) {
                    if (accessorSym.getter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");
                    }
                    accessorSym.getter = sig.declAST.type.symbol;
                } else {
                    if (accessorSym.setter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");
                    }
                    accessorSym.setter = sig.declAST.type.symbol;
                }
                field.typeLink = TypeScript.getTypeLink(null, this, false);
                if (addToMembers) {
                    if (enclosingClass) {
                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {
                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);
                        }
                        accessorSym.container = enclosingClass.symbol;
                    } else {
                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context");
                    }
                } else {
                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);
                }
                if (isClassProperty) {
                    accessorSym.flags |= 256 /* Property */ ;
                }
                if (isStatic) {
                    accessorSym.flags |= 16 /* Static */ ;
                }
                if (isPrivate) {
                    accessorSym.flags |= 2 /* Private */ ;
                } else {
                    accessorSym.flags |= 4 /* Public */ ;
                }
            } else {
                accessorSym = (fgSym);
                if (isPrivate != TypeScript.hasFlag(accessorSym.flags, 2 /* Private */ )) {
                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility");
                }
                if (TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ )) {
                    if (accessorSym.getter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");
                    }
                    accessorSym.getter = funcDecl.type.symbol;
                } else {
                    if (accessorSym.setter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");
                    }
                    accessorSym.setter = funcDecl.type.symbol;
                }
            }
            return accessorSym;
        };
        TypeChecker.prototype.addBases = function (resultScope, type, baseContext) {
            resultScope.addParentScope(new TypeScript.SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));
            var i = 0;
            var parent;
            if (type.extendsList) {
                for(var len = type.extendsList.length; i < len; i++) {
                    parent = type.extendsList[i];
                    if (baseContext.baseId == parent.typeID) {
                        this.errorReporter.reportErrorFromSym(parent.symbol, "Type '" + baseContext.base + "' is recursively referenced as a base class of itself");
                        parent.symbol.flags |= 131072 /* RecursivelyReferenced */ ;
                        break;
                    }
                    this.addBases(resultScope, parent, baseContext);
                }
            }
        };
        TypeChecker.prototype.scopeOf = function (type) {
            var resultScope = new TypeScript.SymbolAggregateScope(type.symbol);
            var baseContext = {
                base: type.symbol && type.symbol.name ? type.symbol.name : "{}",
                baseId: type.typeID
            };
            this.addBases(resultScope, type, baseContext);
            return resultScope;
        };
        TypeChecker.prototype.lookupMemberTypeSymbol = function (containingType, name) {
            var symbol = null;
            if (containingType.containedScope) {
                symbol = containingType.containedScope.find(name, false, true);
            } else if (containingType.members) {
                symbol = containingType.members.allMembers.lookup(name);
                if (symbol == null && containingType.ambientMembers) {
                    symbol = containingType.ambientMembers.allMembers.lookup(name);
                }
            }
            if (symbol == null || !symbol.isType()) {
                var typeMembers = containingType.getAllEnclosedTypes();
                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();
                if (typeMembers) {
                    symbol = typeMembers.allMembers.lookup(name);
                    if (symbol == null && ambientTypeMembers) {
                        symbol = ambientTypeMembers.allMembers.lookup(name);
                    }
                }
            }
            if (symbol && symbol.isType()) {
                return symbol;
            } else {
                return null;
            }
        };
        TypeChecker.prototype.findSymbolForDynamicModule = function (idText, currentFileName, search) {
            var originalIdText = idText;
            var symbol = search(idText);
            if (symbol == null) {
                if (!symbol) {
                    idText = TypeScript.swapQuotes(originalIdText);
                    symbol = search(idText);
                }
                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".ts";
                    symbol = search(idText);
                }
                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".str";
                    symbol = search(idText);
                }
                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".d.ts";
                    symbol = search(idText);
                }
                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".d.str";
                    symbol = search(idText);
                }
                if (!symbol && !TypeScript.isRelative(originalIdText)) {
                    idText = originalIdText;
                    var strippedIdText = TypeScript.stripQuotes(idText);
                    var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));
                    while(symbol == null && path != "") {
                        idText = TypeScript.normalizePath(path + strippedIdText + ".ts");
                        symbol = search(idText);
                        if (symbol == null) {
                            idText = TypeScript.changePathToSTR(idText);
                            symbol = search(idText);
                        }
                        if (symbol == null) {
                            idText = TypeScript.changePathToDTS(idText);
                            symbol = search(idText);
                        }
                        if (symbol == null) {
                            idText = TypeScript.changePathToDSTR(idText);
                            symbol = search(idText);
                        }
                        if (symbol == null) {
                            if (path === '/') {
                                path = '';
                            } else {
                                path = TypeScript.normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }
            return symbol;
        };
        TypeChecker.prototype.resolveTypeMember = function (scope, dotNode) {
            var lhs = dotNode.operand1;
            var rhs = dotNode.operand2;
            var resultType = this.anyType;
            var lhsType = this.anyType;
            if (lhs && rhs && (rhs.nodeType == 25 /* Name */ )) {
                if (lhs.nodeType == 19 /* Dot */ ) {
                    lhsType = this.resolveTypeMember(scope, lhs);
                } else if (lhs.nodeType == 25 /* Name */ ) {
                    var identifier = lhs;
                    var symbol = scope.find(identifier.text, false, true);
                    if (symbol == null) {
                        this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);
                    } else if (symbol.isType()) {
                        var typeSymbol = symbol;
                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == 25 /* Name */ ) {
                            var modPath = (typeSymbol.aliasLink.alias).text;
                            var modSym = this.findSymbolForDynamicModule(modPath, this.locationInfo.filename, function (id) {
                                return scope.find(id, false, true);
                            });
                            if (modSym) {
                                typeSymbol.type = modSym.getType();
                            }
                        }
                        if (TypeScript.optimizeModuleCodeGen && symbol) {
                            var symType = symbol.getType();
                            if (symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {
                                var modDecl = symType.symbol.declAST;
                                if (modDecl && TypeScript.hasFlag(modDecl.modFlags, 2048 /* IsDynamic */ )) {
                                    typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;
                                }
                            }
                        }
                        if (!symbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, "The symbol '" + identifier.actualText + "' is not visible at this point");
                        }
                        lhsType = symbol.getType();
                        identifier.sym = symbol;
                    } else {
                        this.errorReporter.simpleError(lhs, "Expected type");
                    }
                }
                if (!lhsType) {
                    lhsType = this.anyType;
                }
                if (lhsType != this.anyType) {
                    var rhsIdentifier = rhs;
                    var resultSymbol = this.lookupMemberTypeSymbol(lhsType, rhsIdentifier.text);
                    if (resultSymbol == null) {
                        resultType = this.anyType;
                        this.errorReporter.simpleError(dotNode, "Expected type");
                    } else {
                        resultType = resultSymbol.getType();
                        if (!resultSymbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, "The symbol '" + (rhs).actualText + "' is not visible at this point");
                        }
                    }
                    rhsIdentifier.sym = resultType.symbol;
                }
            }
            if (resultType.isClass()) {
                resultType = resultType.instanceType;
            }
            return resultType;
        };
        TypeChecker.prototype.resolveFuncDecl = function (funcDecl, scope, fgSym) {
            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;
            var signatures;
            if (funcDecl.isConstructMember()) {
                signatures = functionGroupSymbol.type.construct.signatures;
            } else if (funcDecl.isIndexerMember()) {
                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;
            } else {
                signatures = functionGroupSymbol.type.call.signatures;
            }
            var signature = signatures[signatures.length - 1];
            var len = signature.parameters.length;
            for(var i = 0; i < len; i++) {
                var paramSym = signature.parameters[i];
                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);
            }
            if (len && funcDecl.variableArgList) {
                if (!signature.parameters[len - 1].parameter.typeLink.type.elementType) {
                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, "... parameter must have array type");
                    signature.parameters[len - 1].parameter.typeLink.type = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);
                }
            }
            this.resolveTypeLink(scope, signature.returnType, funcDecl.isSignature());
            return functionGroupSymbol;
        };
        TypeChecker.prototype.resolveVarDecl = function (varDecl, scope) {
            var field = new TypeScript.ValueLocation();
            var fieldSymbol = new TypeScript.FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex, (varDecl.varFlags & 1024 /* Readonly */ ) == 0 /* None */ , field);
            fieldSymbol.transferVarFlags(varDecl.varFlags);
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = varDecl;
            field.typeLink = TypeScript.getTypeLink(varDecl.typeExpr, this, varDecl.init == null);
            this.resolveTypeLink(scope, field.typeLink, true);
            varDecl.sym = fieldSymbol;
            varDecl.type = field.typeLink.type;
            return fieldSymbol;
        };
        TypeChecker.prototype.resolveTypeLink = function (scope, typeLink, supplyVar) {
            var arrayCount = 0;
            if (typeLink.type == null) {
                var ast = typeLink.ast;
                if (ast) {
                    while(typeLink.type == null) {
                        switch(ast.nodeType) {
                            case 25 /* Name */ :
                                var identifier = ast;
                                var symbol = scope.find(identifier.text, false, true);
                                if (symbol == null) {
                                    typeLink.type = this.anyType;
                                    this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);
                                } else if (symbol.isType()) {
                                    if (!symbol.visible(scope, this)) {
                                        this.errorReporter.simpleError(ast, "The symbol '" + identifier.actualText + "' is not visible at this point");
                                    }
                                    identifier.sym = symbol;
                                    typeLink.type = symbol.getType();
                                    if (typeLink.type) {
                                        if (typeLink.type.isClass()) {
                                            typeLink.type = typeLink.type.instanceType;
                                        }
                                    } else {
                                        typeLink.type = this.anyType;
                                    }
                                } else {
                                    typeLink.type = this.anyType;
                                    this.errorReporter.simpleError(ast, "Expected type");
                                }
                                break;
                            case 19 /* Dot */ :
                                typeLink.type = this.resolveTypeMember(scope, ast);
                                break;
                            case 28 /* TypeRef */ :
                                var typeRef = ast;
                                arrayCount = typeRef.arrayCount;
                                ast = typeRef.term;
                                if (ast == null) {
                                    typeLink.type = this.anyType;
                                }
                                break;
                            case 97 /* InterfaceDeclaration */ :
                                var interfaceDecl = ast;
                                var interfaceType = new TypeScript.Type();
                                var interfaceSymbol = new TypeScript.TypeSymbol((interfaceDecl.name).text, ast.minChar, ast.limChar - ast.minChar, this.locationInfo.unitIndex, interfaceType);
                                interfaceType.symbol = interfaceSymbol;
                                interfaceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                                interfaceType.containedScope = new TypeScript.SymbolTableScope(interfaceType.members, null, null, null, interfaceSymbol);
                                interfaceType.containedScope.container = interfaceSymbol;
                                interfaceType.memberScope = interfaceType.containedScope;
                                var memberList = interfaceDecl.members;
                                var props = memberList.members;
                                var propsLen = props.length;
                                for(var j = 0; j < propsLen; j++) {
                                    var propDecl = props[j];
                                    var propSym = null;
                                    var addMember = true;
                                    var id = null;
                                    if (propDecl.nodeType == 73 /* FuncDecl */ ) {
                                        var funcDecl = propDecl;
                                        id = funcDecl.name;
                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());
                                        addMember = (propSym == null);
                                        if (funcDecl.isSpecialFn()) {
                                            addMember = false;
                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);
                                        } else {
                                            propSym = this.resolveFuncDecl(funcDecl, scope, propSym);
                                        }
                                        funcDecl.type = (propSym).type;
                                    } else {
                                        id = (propDecl).id;
                                        propSym = this.resolveVarDecl(propDecl, scope);
                                        addMember = !id.isMissing();
                                    }
                                    if (addMember) {
                                        if (id && TypeScript.hasFlag(id.flags, 1024 /* OptionalName */ )) {
                                            propSym.flags |= 65536 /* Optional */ ;
                                        }
                                        if (!interfaceType.members.allMembers.add(propSym.name, propSym)) {
                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);
                                        }
                                    }
                                }
                                ast.type = interfaceType;
                                typeLink.type = interfaceType;
                                break;
                            case 73 /* FuncDecl */ :
                                var tsym = this.resolveFuncDecl(ast, scope, null);
                                typeLink.type = tsym.type;
                                break;
                            default:
                                typeLink.type = this.anyType;
                                this.errorReporter.simpleError(ast, "Expected type");
                                break;
                        }
                    }
                }
                for(var count = arrayCount; count > 0; count--) {
                    typeLink.type = this.makeArrayType(typeLink.type);
                }
                if (supplyVar && (typeLink.type == null)) {
                    typeLink.type = this.anyType;
                }
                if (typeLink.ast) {
                    typeLink.ast.type = typeLink.type;
                }
            }
        };
        TypeChecker.prototype.resolveBaseTypeLink = function (typeLink, scope) {
            this.resolvingBases = true;
            this.resolveTypeLink(scope, typeLink, true);
            this.resolvingBases = false;
            var extendsType = null;
            if (typeLink.type.isClass()) {
                extendsType = typeLink.type.instanceType;
            } else {
                extendsType = typeLink.type;
            }
            return extendsType;
        };
        TypeChecker.prototype.findMostApplicableSignature = function (signatures, args) {
            if (signatures.length == 1) {
                return {
                    sig: signatures[0].signature,
                    ambiguous: false
                };
            }
            var best = signatures[0];
            var Q = null;
            var AType = null;
            var PType = null;
            var QType = null;
            var ambiguous = false;
            for(var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];
                var i = 0;
                for(i = 0; args && i < args.members.length; i++) {
                    AType = args.members[i].type;
                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;
                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;
                    if (this.typesAreIdentical(PType, QType)) {
                        continue;
                    } else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    } else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(PType, QType)) {
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(QType, PType)) {
                        best = Q;
                        break;
                    } else if (Q.hadProvisionalErrors) {
                        break;
                    } else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }
                if (!args || i == args.members.length) {
                    var collection = {
                        getLength: function () {
                            return 2;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return index ? Q.signature.returnType.type : best.signature.returnType.type;
                        }
                    };
                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection, true);
                    ambiguous = !bct;
                } else {
                    ambiguous = false;
                }
            }
            return {
                sig: best.signature,
                ambiguous: ambiguous
            };
        };
        TypeChecker.prototype.getApplicableSignatures = function (signatures, args, comparisonInfo) {
            var applicableSigs = [];
            var memberType = null;
            var miss = false;
            var cxt = null;
            var hadProvisionalErrors = false;
            for(var i = 0; i < signatures.length; i++) {
                miss = false;
                for(var j = 0; j < args.members.length; j++) {
                    if (j >= signatures[i].parameters.length) {
                        continue;
                    }
                    memberType = signatures[i].parameters[j].getType();
                    if (signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {
                        memberType = memberType.elementType;
                    }
                    if (memberType == this.anyType) {
                        continue;
                    } else if (args.members[j].nodeType == 73 /* FuncDecl */ ) {
                        if (this.typeFlow.functionInterfaceType && memberType == this.typeFlow.functionInterfaceType) {
                            continue;
                        }
                        if (!this.canContextuallyTypeFunction(memberType, args.members[j], true)) {
                            if (this.canContextuallyTypeFunction(memberType, args.members[j], false)) {
                                this.typeFlow.typeCheck(args.members[j]);
                                if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        } else {
                            this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                            this.cleanStartedPTO();
                            hadProvisionalErrors = this.hadProvisionalErrors();
                            if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                                }
                                miss = true;
                            }
                            this.resetProvisionalErrors();
                            if (miss) {
                                break;
                            }
                        }
                    } else if (args.members[j].nodeType == 11 /* ObjectLit */ ) {
                        if (this.typeFlow.objectInterfaceType && memberType == this.typeFlow.objectInterfaceType) {
                            continue;
                        }
                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                        this.cleanStartedPTO();
                        hadProvisionalErrors = this.hadProvisionalErrors();
                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            miss = true;
                        }
                        this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    } else if (args.members[j].nodeType == 10 /* ArrayLit */ ) {
                        if (this.typeFlow.arrayInterfaceType && memberType == this.typeFlow.arrayInterfaceType) {
                            continue;
                        }
                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                        this.cleanStartedPTO();
                        hadProvisionalErrors = this.hadProvisionalErrors();
                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            break;
                        }
                        this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                }
                if (j == args.members.length) {
                    applicableSigs[applicableSigs.length] = {
                        signature: signatures[i],
                        hadProvisionalErrors: hadProvisionalErrors
                    };
                }
                hadProvisionalErrors = false;
            }
            return applicableSigs;
        };
        TypeChecker.prototype.canContextuallyTypeFunction = function (candidateType, funcDecl, beStringent) {
            if (funcDecl.isParenthesized || funcDecl.isMethod() || beStringent && funcDecl.returnTypeAnnotation || funcDecl.isInlineCallLiteral) {
                return false;
            }
            beStringent = beStringent || (this.typeFlow.functionInterfaceType == candidateType);
            if (!beStringent) {
                return true;
            }
            if (!funcDecl.signature) {
                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);
                this.typeFlow.typeCheck(funcDecl);
            }
            var signature = funcDecl.signature;
            var paramLen = signature.parameters.length;
            for(var i = 0; i < paramLen; i++) {
                var param = signature.parameters[i];
                var symbol = param;
                var argDecl = symbol.declAST;
                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }
            if (candidateType.construct && candidateType.call) {
                return false;
            }
            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;
            if (!candidateSigs || candidateSigs.signatures.length > 1) {
                return false;
            }
            return true;
        };
        TypeChecker.prototype.canContextuallyTypeObjectLiteral = function (targetType, objectLit) {
            if (targetType == this.typeFlow.objectInterfaceType) {
                return true;
            }
            var memberDecls = objectLit.operand;
            if (!(memberDecls && targetType.memberScope)) {
                return false;
            }
            var id = null;
            var targetMember = null;
            var text = "";
            var foundSyms = {};
            for(var i = 0; i < memberDecls.members.length; i++) {
                id = (memberDecls.members[i]).operand1;
                if (id.nodeType == 25 /* Name */ ) {
                    text = (id).text;
                } else if (id.nodeType == 7 /* QString */ ) {
                    var idText = (id).text;
                    text = idText.substring(1, idText.length - 1);
                } else {
                    return false;
                }
                targetMember = targetType.memberScope.find(text, true, false);
                if (!targetMember) {
                    return false;
                }
                foundSyms[text] = true;
            }
            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);
            for(var i = 0; i < targetMembers.length; i++) {
                var memberName = targetMembers[i];
                var memberSym = targetType.memberScope.find(memberName, true, false);
                if (!foundSyms[targetMembers[i]] && !TypeScript.hasFlag(memberSym.flags, 65536 /* Optional */ )) {
                    return false;
                }
            }
            return true;
        };
        TypeChecker.prototype.widenType = function (t) {
            if (t == this.undefinedType || t == this.nullType) {
                return this.anyType;
            }
            return t;
        };
        TypeChecker.prototype.isNullOrUndefinedType = function (t) {
            return t == this.undefinedType || t == this.nullType;
        };
        TypeChecker.prototype.findBestCommonType = function (initialType, targetType, collection, acceptVoid, comparisonInfo) {
            var i = 0;
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;
            if (targetType) {
                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this, acceptVoid) : targetType;
            }
            var convergenceType = bestCommonType;
            while(nlastChecked < len) {
                for(i = 0; i < len; i++) {
                    if (i == nlastChecked) {
                        continue;
                    }
                    if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, acceptVoid, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }
                    if (bestCommonType == this.anyType || bestCommonType == null) {
                        break;
                    } else if (targetType) {
                        collection.setTypeAtIndex(i, targetType);
                    }
                }
                if (convergenceType && bestCommonType) {
                    break;
                }
                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }
            return acceptVoid ? bestCommonType : (bestCommonType == this.voidType ? null : bestCommonType);
        };
        TypeChecker.prototype.typesAreIdentical = function (t1, t2) {
            if (t1 == t2) {
                return true;
            }
            if (!t1 || !t2) {
                return false;
            }
            if (t1.isClass() || t1.isClassInstance()) {
                return false;
            }
            var comboId = (t2.typeID << 16) | t1.typeID;
            if (this.identicalCache[comboId]) {
                return true;
            }
            if ((t1.typeFlags & 8 /* IsEnum */ ) || (t2.typeFlags & 8 /* IsEnum */ )) {
                return false;
            }
            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);
                if (ret) {
                    this.subtypeCache[comboId] = true;
                } else {
                    this.subtypeCache[comboId] = undefined;
                }
                return ret;
            }
            if (t1.primitiveTypeClass != t2.primitiveTypeClass) {
                return false;
            }
            this.identicalCache[comboId] = false;
            if (t1.memberScope && t2.memberScope) {
                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();
                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();
                if (t1MemberKeys.length != t2MemberKeys.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }
                var t1MemberSymbol = null;
                var t2MemberSymbol = null;
                var t1MemberType = null;
                var t2MemberType = null;
                for(var iMember = 0; iMember < t1MemberKeys.length; iMember++) {
                    if (t1MemberKeys[iMember] != t2MemberKeys[iMember]) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                    t1MemberSymbol = t1.memberScope.find(t1MemberKeys[iMember], false, false);
                    t2MemberSymbol = t2.memberScope.find(t2MemberKeys[iMember], false, false);
                    if ((t1MemberSymbol.flags & 65536 /* Optional */ ) != (t2MemberSymbol.flags & 65536 /* Optional */ )) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();
                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {
                        continue;
                    }
                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            } else if (t1.memberScope || t2.memberScope) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1.call, t2.call)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1.index, t2.index)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            this.identicalCache[comboId] = true;
            return true;
        };
        TypeChecker.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {
            if (sg1 == sg2) {
                return true;
            }
            if (!sg1 || !sg2) {
                return false;
            }
            if (sg1.signatures.length != sg2.signatures.length) {
                return false;
            }
            var sig1 = null;
            var sig2 = null;
            var sigsMatch = false;
            for(var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {
                sig1 = sg1.signatures[iSig1];
                for(var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {
                    sig2 = sg2.signatures[iSig2];
                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }
                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        TypeChecker.prototype.signaturesAreIdentical = function (s1, s2) {
            if (s1.hasVariableArgList != s2.hasVariableArgList) {
                return false;
            }
            if (s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {
                return false;
            }
            if (s1.parameters.length != s2.parameters.length) {
                return false;
            }
            if (!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {
                return false;
            }
            for(var iParam = 0; iParam < s1.parameters.length; iParam++) {
                if (!this.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {
                    return false;
                }
            }
            return true;
        };
        TypeChecker.prototype.sourceIsSubtypeOfTarget = function (source, target, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo);
        };
        TypeChecker.prototype.signatureGroupIsSubtypeOfTarget = function (sg1, sg2, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo);
        };
        TypeChecker.prototype.signatureIsSubtypeOfTarget = function (s1, s2, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo);
        };
        TypeChecker.prototype.sourceIsAssignableToTarget = function (source, target, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo);
        };
        TypeChecker.prototype.signatureGroupIsAssignableToTarget = function (sg1, sg2, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo);
        };
        TypeChecker.prototype.signatureIsAssignableToTarget = function (s1, s2, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo);
        };
        TypeChecker.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, comparisonInfo) {
            if (source == target) {
                return true;
            }
            if (!(source && target)) {
                return true;
            }
            var comboId = (source.typeID << 16) | target.typeID;
            if (comparisonCache[comboId] != undefined) {
                return true;
            }
            if (assignableTo) {
                if (source == this.anyType || target == this.anyType) {
                    return true;
                }
            } else {
                if (target == this.anyType) {
                    return true;
                }
            }
            if (source == this.undefinedType) {
                return true;
            }
            if ((source == this.nullType) && (target != this.undefinedType && target != this.voidType)) {
                return true;
            }
            if (target == this.numberType && (source.typeFlags & 8 /* IsEnum */ )) {
                return true;
            }
            if (source == this.numberType && (target.typeFlags & 8 /* IsEnum */ )) {
                return true;
            }
            if ((source.typeFlags & 8 /* IsEnum */ ) || (target.typeFlags & 8 /* IsEnum */ )) {
                return false;
            }
            if (source.isArray() || target.isArray()) {
                if (!(source.isArray() && target.isArray())) {
                    return false;
                }
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                } else {
                    comparisonCache[comboId] = undefined;
                }
                return ret;
            }
            if (source.primitiveTypeClass != target.primitiveTypeClass) {
                if (target.primitiveTypeClass == 0 /* None */ ) {
                    if (source == this.numberType && this.typeFlow.numberInterfaceType) {
                        source = this.typeFlow.numberInterfaceType;
                    } else if (source == this.stringType && this.typeFlow.stringInterfaceType) {
                        source = this.typeFlow.stringInterfaceType;
                    } else if (source == this.booleanType && this.typeFlow.booleanInterfaceType) {
                        source = this.typeFlow.booleanInterfaceType;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            comparisonCache[comboId] = false;
            if (source.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }
            if (this.typeFlow.objectInterfaceType && target == this.typeFlow.objectInterfaceType) {
                return true;
            }
            if (this.typeFlow.functionInterfaceType && (source.call || source.construct) && target == this.typeFlow.functionInterfaceType) {
                return true;
            }
            if (target.isClass() || target.isClassInstance()) {
                comparisonCache[comboId] = undefined;
                return false;
            }
            if (target.memberScope && source.memberScope) {
                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);
                var mProp = null;
                var nProp = null;
                var mPropType = null;
                var nPropType = null;
                var inferenceSymbol = null;
                for(var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {
                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);
                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);
                    if (mProp.name == "arguments" && this.typeFlow.iargumentsInterfaceType && (this.typeFlow.iargumentsInterfaceType.symbol.flags & 524288 /* CompilerGenerated */ ) && mProp.kind() == 4 /* Variable */  && (mProp).variable.typeLink.type == this.typeFlow.iargumentsInterfaceType) {
                        continue;
                    }
                    if (mProp.isInferenceSymbol()) {
                        inferenceSymbol = mProp;
                        if (inferenceSymbol.typeCheckStatus == 0 /* NotStarted */ ) {
                            this.typeFlow.typeCheck(mProp.declAST);
                        }
                    }
                    mPropType = mProp.getType();
                    if (!nProp) {
                        if (this.typeFlow.objectInterfaceType) {
                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);
                        }
                        if (!nProp) {
                            if (this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {
                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);
                            }
                            if (!nProp) {
                                if (!(mProp.flags & 65536 /* Optional */ )) {
                                    comparisonCache[comboId] = undefined;
                                    if (comparisonInfo) {
                                        comparisonInfo.flags |= 2 /* RequiredPropertyIsMissing */ ;
                                        comparisonInfo.addMessageToFront("Type '" + source.getTypeName() + "' is missing property '" + mPropKeys[iMProp] + "' from type '" + target.getTypeName() + "'");
                                    }
                                    return false;
                                } else {
                                    continue;
                                }
                            }
                        }
                    }
                    if (nProp.isInferenceSymbol()) {
                        inferenceSymbol = nProp;
                        if (inferenceSymbol.typeCheckStatus == 0 /* NotStarted */ ) {
                            this.typeFlow.typeCheck(nProp.declAST);
                        }
                    }
                    nPropType = nProp.getType();
                    if (mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {
                        continue;
                    }
                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {
                        comparisonCache[comboId] = undefined;
                        if (comparisonInfo) {
                            comparisonInfo.flags |= 32 /* IncompatiblePropertyTypes */ ;
                            comparisonInfo.addMessageToFront("Types of property '" + mProp.name + "' of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        }
                        return false;
                    }
                }
            }
            if (source.call || target.call) {
                if (!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (source.call && target.call) {
                            comparisonInfo.addMessageToFront("Call signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        } else {
                            var hasSig = target.call ? target.getTypeName() : source.getTypeName();
                            var lacksSig = !target.call ? target.getTypeName() : source.getTypeName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a call signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */ ;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            if (source.construct || target.construct) {
                if (!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (source.construct && target.construct) {
                            comparisonInfo.addMessageToFront("Construct signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        } else {
                            var hasSig = target.construct ? target.getTypeName() : source.getTypeName();
                            var lacksSig = !target.construct ? target.getTypeName() : source.getTypeName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a construct signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */ ;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            if (target.index) {
                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;
                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;
                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.addMessageToFront("Index signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */ ;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            comparisonCache[comboId] = true;
            return true;
        };
        TypeChecker.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, comparisonInfo) {
            if (sourceSG == targetSG) {
                return true;
            }
            if (!(sourceSG && targetSG)) {
                return false;
            }
            var mSig = null;
            var nSig = null;
            var foundMatch = false;
            for(var iMSig = 0; iMSig < targetSG.signatures.length; iMSig++) {
                mSig = targetSG.signatures[iMSig];
                for(var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {
                    nSig = sourceSG.signatures[iNSig];
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }
                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        TypeChecker.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, comparisonInfo) {
            if (!sourceSig.parameters || !targetSig.parameters) {
                return false;
            }
            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;
            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;
            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= 3 /* SourceSignatureHasTooManyParameters */ ;
                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");
                }
                return false;
            }
            var sourceReturnType = sourceSig.returnType.type;
            var targetReturnType = targetSig.returnType.type;
            if (targetReturnType != this.voidType) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 16 /* IncompatibleReturnTypes */ ;
                    }
                    return false;
                }
            }
            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType = null;
            var targetParamType = null;
            var sourceParamName = "";
            var targetParamName = "";
            for(var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {
                if (!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {
                    sourceParamType = (sourceSig.parameters[iSource]).parameter.typeLink.type;
                    sourceParamName = (sourceSig.parameters[iSource]).parameter.symbol.name;
                } else if (iSource == sourceVarArgCount) {
                    sourceParamType = (sourceSig.parameters[iSource]).parameter.typeLink.type;
                    if (sourceParamType.elementType) {
                        sourceParamType = sourceParamType.elementType;
                    }
                    sourceParamName = (sourceSig.parameters[iSource]).parameter.symbol.name;
                }
                if (iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {
                    targetParamType = (targetSig.parameters[iTarget]).parameter.typeLink.type;
                    targetParamName = (targetSig.parameters[iTarget]).parameter.symbol.name;
                } else if (targetSig.hasVariableArgList && iTarget == targetVarArgCount) {
                    targetParamType = (targetSig.parameters[iTarget]).parameter.typeLink.type;
                    if (targetParamType.elementType) {
                        targetParamType = targetParamType.elementType;
                    }
                    targetParamName = (targetSig.parameters[iTarget]).parameter.symbol.name;
                }
                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) || this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 64 /* IncompatibleParameterTypes */ ;
                    }
                    return false;
                }
            }
            return true;
        };
        return TypeChecker;
    })();
    TypeScript.TypeChecker = TypeChecker;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Continuation = (function () {
        function Continuation(normalBlock) {
            this.normalBlock = normalBlock;
            this.exceptionBlock = -1;
        }
        return Continuation;
    })();
    TypeScript.Continuation = Continuation;    
    function getBaseTypeLinks(bases, baseTypeLinks) {
        if (bases) {
            var len = bases.members.length;
            if (baseTypeLinks == null) {
                baseTypeLinks = new Array();
            }
            for(var i = 0; i < len; i++) {
                var baseExpr = bases.members[i];
                var name = baseExpr;
                var typeLink = new TypeScript.TypeLink();
                typeLink.ast = name;
                baseTypeLinks[baseTypeLinks.length] = typeLink;
            }
        }
        return baseTypeLinks;
    }
    function getBases(type, typeDecl) {
        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);
        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);
    }
    function addPrototypeField(classType, ast, context) {
        var field = new TypeScript.ValueLocation();
        field.typeLink = new TypeScript.TypeLink();
        field.typeLink.ast = ast;
        field.typeLink.type = classType.instanceType;
        var fieldSymbol = new TypeScript.FieldSymbol("prototype", ast.minChar, context.checker.locationInfo.unitIndex, true, field);
        fieldSymbol.flags |= (256 /* Property */  | 8192 /* BuiltIn */ );
        field.symbol = fieldSymbol;
        fieldSymbol.declAST = ast;
        classType.members.addPublicMember("prototype", fieldSymbol);
    }
    function createNewConstructGroupForType(type) {
        var signature = new TypeScript.Signature();
        signature.returnType = new TypeScript.TypeLink();
        signature.returnType.type = type.instanceType;
        signature.parameters = [];
        type.construct = new TypeScript.SignatureGroup();
        type.construct.addSignature(signature);
    }
    TypeScript.createNewConstructGroupForType = createNewConstructGroupForType;
    function cloneParentConstructGroupForChildType(child, parent) {
        child.construct = new TypeScript.SignatureGroup();
        var sig = null;
        if (!parent.construct) {
            createNewConstructGroupForType(parent);
        }
        for(var i = 0; i < parent.construct.signatures.length; i++) {
            sig = new TypeScript.Signature();
            sig.parameters = parent.construct.signatures[i].parameters;
            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;
            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;
            sig.declAST = parent.construct.signatures[i].declAST;
            sig.returnType = new TypeScript.TypeLink();
            sig.returnType.type = child.instanceType;
            child.construct.addSignature(sig);
        }
    }
    TypeScript.cloneParentConstructGroupForChildType = cloneParentConstructGroupForChildType;
    TypeScript.globalId = "__GLO";
    function findTypeSymbolInScopeChain(name, scopeChain) {
        var symbol = scopeChain.scope.find(name, false, true);
        if (symbol == null && scopeChain.previous) {
            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);
        }
        return symbol;
    }
    function findSymbolFromAlias(alias, context) {
        var symbol = null;
        switch(alias.nodeType) {
            case 25 /* Name */ :
                var name = (alias).text;
                var isDynamic = TypeScript.isQuoted(name);
                var findSym = function (id) {
                    if (context.members) {
                        return context.members.lookup(name);
                    } else {
                        return findTypeSymbolInScopeChain(name, context.topLevelScope);
                    }
                };
                if (isDynamic) {
                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, context.tcContext.script.locationInfo.filename, findSym);
                } else {
                    symbol = findSym(name);
                }
                break;
            case 19 /* Dot */ :
                var dottedExpr = alias;
                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);
                if (op1Sym && op1Sym.getType()) {
                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);
                }
                break;
            default:
                break;
        }
        if (symbol) {
            var symType = symbol.getType();
            if (symType) {
                var members = symType.members;
                if (members) {
                    context.members = members.publicMembers;
                }
            }
        }
        return symbol;
    }
    function preCollectImportTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var typeSymbol = null;
        var modType = null;
        var importDecl = ast;
        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, {
            topLevelScope: scopeChain,
            members: null,
            tcContext: context
        });
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        if (aliasedModSymbol) {
            var aliasedModType = aliasedModSymbol.getType();
            if (aliasedModType) {
                modType = aliasedModType;
            }
        }
        typeSymbol = new TypeScript.TypeSymbol(importDecl.id.text, importDecl.id.minChar, importDecl.limChar - importDecl.minChar, context.checker.locationInfo.unitIndex, modType);
        typeSymbol.aliasLink = importDecl;
        if (context.scopeChain.moduleDecl) {
            typeSymbol.flags |= 1024 /* ModuleMember */ ;
            typeSymbol.declModule = context.scopeChain.moduleDecl;
        }
        typeSymbol.declAST = importDecl;
        importDecl.id.sym = typeSymbol;
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isGlobal, true, false);
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isGlobal, false, false);
        return true;
    }
    TypeScript.preCollectImportTypes = preCollectImportTypes;
    function preCollectModuleTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var moduleDecl = ast;
        var isAmbient = TypeScript.hasFlag(moduleDecl.modFlags, 8 /* Ambient */ );
        var isEnum = TypeScript.hasFlag(moduleDecl.modFlags, 256 /* IsEnum */ );
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        var isExported = TypeScript.hasFlag(moduleDecl.modFlags, 1 /* Exported */ );
        var modName = (moduleDecl.name).text;
        var isDynamic = TypeScript.isQuoted(modName);
        var symbol = scopeChain.scope.findLocal(modName, false, false);
        var typeSymbol = null;
        var modType = null;
        if (symbol && symbol.declAST && symbol.declAST.nodeType != 98 /* ModuleDeclaration */ ) {
            context.checker.errorReporter.simpleError(moduleDecl, "Conflicting symbol name for module '" + modName + "'");
            symbol = null;
            modName = "";
        }
        if (symbol) {
            var modDeclAST = symbol.declAST;
            var modDeclASTIsExported = TypeScript.hasFlag(modDeclAST.modFlags, 1 /* Exported */ );
            if ((modDeclASTIsExported && !isExported) || (!modDeclASTIsExported && isExported)) {
                context.checker.errorReporter.simpleError(moduleDecl, 'All contributions to a module must be "export" or none');
            }
        }
        if ((symbol == null) || (symbol.kind() != 1 /* Type */ )) {
            if (modType == null) {
                var enclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                var ambientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                modType = new TypeScript.ModuleType(enclosedTypes, ambientEnclosedTypes);
                if (isEnum) {
                    modType.typeFlags |= 8 /* IsEnum */ ;
                }
                modType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                modType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                modType.setHasImplementation();
            }
            typeSymbol = new TypeScript.TypeSymbol(modName, moduleDecl.name.minChar, modName.length, context.checker.locationInfo.unitIndex, modType);
            typeSymbol.isDynamic = TypeScript.isQuoted(moduleDecl.prettyName);
            if (context.scopeChain.moduleDecl) {
                typeSymbol.declModule = context.scopeChain.moduleDecl;
            }
            typeSymbol.declAST = moduleDecl;
            typeSymbol.prettyName = moduleDecl.prettyName;
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient);
            modType.symbol = typeSymbol;
        } else {
            typeSymbol = symbol;
            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;
            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new TypeScript.StringHashTable() : publicEnclosedTypes;
            var enclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicEnclosedTypesTable, new TypeScript.StringHashTable()));
            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;
            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new TypeScript.StringHashTable() : publicEnclosedAmbientTypes;
            var ambientEnclosedTypes = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicAmbientEnclosedTypesTable, new TypeScript.StringHashTable()));
            var publicMembers = typeSymbol.type.members.publicMembers;
            var publicMembersTable = (publicMembers == null) ? new TypeScript.StringHashTable() : publicMembers;
            var members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicMembersTable, new TypeScript.StringHashTable()));
            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;
            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new TypeScript.StringHashTable() : publicAmbientMembers;
            var ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(publicAmbientMembersTable, new TypeScript.StringHashTable()));
            modType = new TypeScript.ModuleType(enclosedTypes, ambientEnclosedTypes);
            if (isEnum) {
                modType.typeFlags |= 8 /* IsEnum */ ;
            }
            modType.members = members;
            modType.ambientMembers = ambientMembers;
            modType.setHasImplementation();
            modType.symbol = typeSymbol;
            typeSymbol.addLocation(moduleDecl.minChar);
            typeSymbol.expansions.push(modType);
            typeSymbol.expansionsDeclAST.push(moduleDecl);
        }
        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }
        if (isExported) {
            typeSymbol.flags |= 1 /* Exported */ ;
        }
        if ((context.scopeChain.moduleDecl) || (context.scopeChain.container == context.checker.gloMod)) {
            typeSymbol.flags |= 1024 /* ModuleMember */ ;
        }
        moduleDecl.mod = modType;
        TypeScript.pushTypeCollectionScope(typeSymbol, modType.members, modType.ambientMembers, modType.enclosedTypes, modType.ambientEnclosedTypes, context, null, null, moduleDecl);
        return true;
    }
    TypeScript.preCollectModuleTypes = preCollectModuleTypes;
    function preCollectClassTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var classDecl = ast;
        var classType;
        var instanceType;
        var typeSymbol = null;
        var className = (classDecl.name).text;
        var alreadyInScope = false;
        var isAmbient = TypeScript.hasFlag(classDecl.varFlags, 8 /* Ambient */ );
        var isExported = TypeScript.hasFlag(classDecl.varFlags, 1 /* Exported */ );
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        var containerMod = scopeChain.container;
        var foundValSymbol = false;
        typeSymbol = scopeChain.scope.findLocal(className, false, true);
        if (!typeSymbol) {
            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);
            if (valTypeSymbol && valTypeSymbol.isType() && valTypeSymbol.declAST && valTypeSymbol.declAST.nodeType == 73 /* FuncDecl */  && (valTypeSymbol.declAST).isSignature()) {
                typeSymbol = valTypeSymbol;
                foundValSymbol = true;
                if (isExported) {
                    typeSymbol.flags |= 1 /* Exported */ ;
                }
                if (isAmbient) {
                    typeSymbol.flags |= 8 /* Ambient */ ;
                }
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);
            }
        }
        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl)) {
            typeSymbol = null;
        }
        if (typeSymbol == null) {
            var valueSymbol = scopeChain.scope.findLocal(className, false, false);
            classType = new TypeScript.Type();
            classType.setHasImplementation();
            instanceType = new TypeScript.Type();
            instanceType.setHasImplementation();
            classType.instanceType = instanceType;
            classType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            classType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            addPrototypeField(classType, classDecl, context);
            instanceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            instanceType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            typeSymbol = new TypeScript.TypeSymbol(className, classDecl.name.minChar, className.length, context.checker.locationInfo.unitIndex, classType);
            typeSymbol.declAST = classDecl;
            typeSymbol.instanceType = instanceType;
            classType.symbol = typeSymbol;
            instanceType.symbol = typeSymbol;
            if (context.scopeChain.moduleDecl) {
                context.scopeChain.moduleDecl.recordNonInterface();
                typeSymbol.declModule = context.scopeChain.moduleDecl;
                typeSymbol.flags |= 1024 /* ModuleMember */ ;
            }
            if (isExported) {
                typeSymbol.flags |= 1 /* Exported */ ;
            }
            if (isAmbient) {
                typeSymbol.flags |= 8 /* Ambient */ ;
            }
            ast.type = classType;
            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, true, isAmbient);
            if (valueSymbol == null) {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol, context.checker.errorReporter, isExported || isGlobal, false, isAmbient);
            }
        } else {
            classType = typeSymbol.type;
            if (classType.instanceType == null) {
                classType.instanceType = new TypeScript.Type();
                classType.instanceType.setHasImplementation();
                classType.instanceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                classType.instanceType.symbol = classType.symbol;
                classType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                classType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            }
            instanceType = classType.instanceType;
            ast.type = classType;
        }
        if (!classDecl.constructorDecl) {
            if (typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call && !(typeSymbol.declAST).isOverload) {
                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);
            }
            createNewConstructGroupForType(classDecl.type);
        }
        classType.typeFlags |= 128 /* IsClass */ ;
        instanceType.typeFlags |= 128 /* IsClass */ ;
        getBases(instanceType, classDecl);
        TypeScript.pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null, context, instanceType, classType, null);
        return true;
    }
    TypeScript.preCollectClassTypes = preCollectClassTypes;
    function preCollectInterfaceTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var interfaceDecl = ast;
        var interfaceSymbol = null;
        var interfaceType = null;
        var isExported = TypeScript.hasFlag(interfaceDecl.varFlags, 1 /* Exported */ );
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        var alreadyInScope = true;
        alreadyInScope = false;
        var interfaceName = (interfaceDecl.name).text;
        interfaceSymbol = scopeChain.scope.findLocal(interfaceName, false, true);
        if (interfaceSymbol == null) {
            interfaceType = new TypeScript.Type();
            interfaceSymbol = new TypeScript.TypeSymbol(interfaceName, interfaceDecl.name.minChar, interfaceName.length, context.checker.locationInfo.unitIndex, interfaceType);
            interfaceType.symbol = interfaceSymbol;
            interfaceType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            interfaceType.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            interfaceSymbol.declAST = interfaceDecl;
            interfaceSymbol.declModule = context.scopeChain.moduleDecl;
        } else {
            alreadyInScope = true;
            interfaceType = interfaceSymbol.type;
        }
        if (!interfaceType) {
            interfaceType = context.checker.anyType;
        }
        ast.type = interfaceType;
        getBases(interfaceType, interfaceDecl);
        if (isExported) {
            interfaceSymbol.flags |= 1 /* Exported */ ;
        }
        if (context.scopeChain.moduleDecl) {
            interfaceSymbol.flags |= 1024 /* ModuleMember */ ;
        }
        if (!alreadyInScope) {
            context.scopeChain.scope.enter(context.scopeChain.container, ast, interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false);
        }
        TypeScript.pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null, context, interfaceType, null, null);
        return true;
    }
    TypeScript.preCollectInterfaceTypes = preCollectInterfaceTypes;
    function preCollectArgDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var argDecl = ast;
        if (TypeScript.hasFlag(argDecl.varFlags, 4 /* Public */  | 2 /* Private */ )) {
            var field = new TypeScript.ValueLocation();
            var isPrivate = TypeScript.hasFlag(argDecl.varFlags, 2 /* Private */ );
            var fieldSymbol = new TypeScript.FieldSymbol(argDecl.id.text, argDecl.id.minChar, context.checker.locationInfo.unitIndex, !TypeScript.hasFlag(argDecl.varFlags, 1024 /* Readonly */ ), field);
            fieldSymbol.transferVarFlags(argDecl.varFlags);
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = ast;
            argDecl.parameterPropertySym = fieldSymbol;
            context.scopeChain.scope.enter(context.scopeChain.container, ast, fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);
            field.typeLink = TypeScript.getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null);
            argDecl.sym = fieldSymbol;
        }
        return false;
    }
    TypeScript.preCollectArgDeclTypes = preCollectArgDeclTypes;
    function preCollectVarDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        var varDecl = ast;
        var isAmbient = TypeScript.hasFlag(varDecl.varFlags, 8 /* Ambient */ );
        var isExported = TypeScript.hasFlag(varDecl.varFlags, 1 /* Exported */ );
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        var isProperty = TypeScript.hasFlag(varDecl.varFlags, 512 /* Property */ );
        var isStatic = TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ );
        var isPrivate = TypeScript.hasFlag(varDecl.varFlags, 2 /* Private */ );
        var isOptional = TypeScript.hasFlag(varDecl.id.flags, 1024 /* OptionalName */ );
        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }
        if (isProperty || isExported || (context.scopeChain.container == context.checker.gloMod) || context.scopeChain.moduleDecl) {
            if (isAmbient) {
                var existingSym = scopeChain.scope.findLocal(varDecl.id.text, false, false);
                if (existingSym) {
                    varDecl.sym = existingSym;
                    return false;
                }
            }
            if (varDecl.id == null) {
                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location");
                return false;
            }
            var field = new TypeScript.ValueLocation();
            var fieldSymbol = new TypeScript.FieldSymbol(varDecl.id.text, varDecl.id.minChar, context.checker.locationInfo.unitIndex, (varDecl.varFlags & 1024 /* Readonly */ ) == 0 /* None */ , field);
            fieldSymbol.transferVarFlags(varDecl.varFlags);
            if (isOptional) {
                fieldSymbol.flags |= 65536 /* Optional */ ;
            }
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = ast;
            if ((context.scopeChain.moduleDecl) || (context.scopeChain.container == context.checker.gloMod)) {
                fieldSymbol.flags |= 1024 /* ModuleMember */ ;
                fieldSymbol.declModule = context.scopeChain.moduleDecl;
            }
            if (TypeScript.hasFlag(varDecl.varFlags, 512 /* Property */ ) && isStatic && context.scopeChain.classType) {
                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {
                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);
                }
                fieldSymbol.container = context.scopeChain.classType.symbol;
            } else {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, fieldSymbol, context.checker.errorReporter, !isPrivate && (isProperty || isExported || isGlobal || isStatic), false, isAmbient);
            }
            if (TypeScript.hasFlag(varDecl.varFlags, 1 /* Exported */ )) {
                fieldSymbol.flags |= 1 /* Exported */ ;
            }
            field.typeLink = TypeScript.getTypeLink(varDecl.typeExpr, context.checker, varDecl.init == null);
            varDecl.sym = fieldSymbol;
        }
        return false;
    }
    TypeScript.preCollectVarDeclTypes = preCollectVarDeclTypes;
    function preCollectFuncDeclTypes(ast, parent, context) {
        var scopeChain = context.scopeChain;
        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }
        var funcDecl = ast;
        var fgSym = null;
        var nameText = funcDecl.getNameText();
        var isExported = TypeScript.hasFlag(funcDecl.fncFlags, 1 /* Exported */  | 524288 /* ClassPropertyMethodExported */ );
        var isStatic = TypeScript.hasFlag(funcDecl.fncFlags, 16 /* Static */ );
        var isPrivate = TypeScript.hasFlag(funcDecl.fncFlags, 2 /* Private */ );
        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;
        var containerSym = (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);
        var containerScope = context.scopeChain.scope;
        var isGlobal = containerSym == context.checker.gloMod;
        var isOptional = funcDecl.name && TypeScript.hasFlag(funcDecl.name.flags, 1024 /* OptionalName */ );
        var go = false;
        var foundSymbol = false;
        if (isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) {
            containerSym = containerSym.container;
            containerScope = scopeChain.previous.scope;
        }
        funcDecl.unitIndex = context.checker.locationInfo.unitIndex;
        if (!funcDecl.isConstructor && containerSym && containerSym.declAST && containerSym.declAST.nodeType == 73 /* FuncDecl */  && (containerSym.declAST).isConstructor && !funcDecl.isMethod()) {
            return go;
        }
        if (TypeScript.hasFlag(funcDecl.fncFlags, 512 /* Signature */ )) {
            var instType = context.scopeChain.thisType;
            if (nameText && nameText != "__missing") {
                if (isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText);
                } else {
                    fgSym = containerScope.findLocal(nameText, false, false);
                    if (fgSym == null) {
                        fgSym = containerScope.findLocal(nameText, false, true);
                    }
                }
                if (fgSym) {
                    foundSymbol = true;
                    if (!funcDecl.isSignature() && (TypeScript.hasFlag(funcDecl.fncFlags, 8 /* Ambient */ ) != TypeScript.hasFlag(fgSym.flags, 8 /* Ambient */ ))) {
                        fgSym = null;
                    }
                }
            }
            if (fgSym == null) {
                if (!(funcDecl.isSpecialFn())) {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;
                } else {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;
                }
                if (fgSym.declAST == null || !funcDecl.isSpecialFn()) {
                    fgSym.declAST = ast;
                }
            } else {
                if ((fgSym.kind() == 1 /* Type */ )) {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;
                } else {
                    context.checker.errorReporter.simpleError(funcDecl, "Function or method '" + funcDecl.name.actualText + "' already declared as a property");
                }
            }
            if (funcDecl.isSpecialFn() && !isStatic) {
                funcDecl.type = instType ? instType : fgSym.type;
            } else {
                funcDecl.type = fgSym.type;
            }
        } else {
            if (nameText) {
                if (isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText);
                } else {
                    if (funcDecl.isConstructor && context.scopeChain.previous) {
                        fgSym = context.scopeChain.previous.scope.findLocal(nameText, false, false);
                    }
                    if (fgSym == null) {
                        fgSym = containerScope.findLocal(nameText, false, false);
                    }
                }
                if (fgSym) {
                    foundSymbol = true;
                    if (!isConstructor && fgSym.declAST.nodeType == 73 /* FuncDecl */  && !(fgSym.declAST).isAccessor() && !(fgSym.declAST).isSignature()) {
                        fgSym = null;
                        foundSymbol = false;
                    }
                }
            }
            if (fgSym && !fgSym.isAccessor() && fgSym.type && fgSym.type.construct && fgSym.type.construct.signatures != [] && (fgSym.type.construct.signatures[0].declAST == null || !TypeScript.hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, 8 /* Ambient */ )) && !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Functions may not have class overloads");
            }
            if (fgSym && !(fgSym.kind() == 1 /* Type */ ) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Function or method '" + funcDecl.name.actualText + "' already declared as a property");
                fgSym.type = context.checker.anyType;
            }
            if (fgSym && !fgSym.isAccessor() && funcDecl.isAccessor()) {
                fgSym = null;
            }
            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);
            if (((!fgSym || fgSym.declAST.nodeType != 73 /* FuncDecl */ ) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {
                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);
            }
            funcDecl.type.symbol.declAST = ast;
            if (funcDecl.isConstructor) {
                go = true;
            }
            ;
        }
        if (isExported) {
            if (funcDecl.type.call) {
                funcDecl.type.symbol.flags |= 1 /* Exported */ ;
            }
            if (fgSym && !fgSym.isAccessor() && fgSym.kind() == 1 /* Type */  && fgSym.type.call) {
                fgSym.flags |= 1 /* Exported */ ;
            }
        }
        if (context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {
            funcDecl.type.symbol.flags |= 1024 /* ModuleMember */ ;
            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;
        }
        if (fgSym && isOptional) {
            fgSym.flags |= 65536 /* Optional */ ;
        }
        return go;
    }
    TypeScript.preCollectFuncDeclTypes = preCollectFuncDeclTypes;
    function preCollectTypes(ast, parent, walker) {
        var context = walker.state;
        var go = false;
        var scopeChain = context.scopeChain;
        if (ast.nodeType == 95 /* Script */ ) {
            var script = ast;
            context.script = script;
            go = true;
        } else if (ast.nodeType == 94 /* List */ ) {
            go = true;
        } else if (ast.nodeType == 99 /* ImportDeclaration */ ) {
            go = preCollectImportTypes(ast, parent, context);
        } else if (ast.nodeType == 100 /* With */ ) {
            go = false;
        } else if (ast.nodeType == 98 /* ModuleDeclaration */ ) {
            go = preCollectModuleTypes(ast, parent, context);
        } else if (ast.nodeType == 96 /* ClassDeclaration */ ) {
            go = preCollectClassTypes(ast, parent, context);
        } else if (ast.nodeType == 86 /* Block */ ) {
            go = true;
        } else if (ast.nodeType == 97 /* InterfaceDeclaration */ ) {
            go = preCollectInterfaceTypes(ast, parent, context);
        } else if (ast.nodeType == 76 /* ArgDecl */ ) {
            go = preCollectArgDeclTypes(ast, parent, context);
        } else if (ast.nodeType == 75 /* VarDecl */ ) {
            go = preCollectVarDeclTypes(ast, parent, context);
        } else if (ast.nodeType == 73 /* FuncDecl */ ) {
            go = preCollectFuncDeclTypes(ast, parent, context);
        } else {
            if (ast.isStatementOrExpression() && context.scopeChain.moduleDecl) {
                context.scopeChain.moduleDecl.recordNonInterface();
            }
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.preCollectTypes = preCollectTypes;
    function postCollectTypes(ast, parent, walker) {
        var context = walker.state;
        if (ast.nodeType == 98 /* ModuleDeclaration */ ) {
            TypeScript.popTypeCollectionScope(context);
        } else if (ast.nodeType == 96 /* ClassDeclaration */ ) {
            TypeScript.popTypeCollectionScope(context);
        } else if (ast.nodeType == 97 /* InterfaceDeclaration */ ) {
            TypeScript.popTypeCollectionScope(context);
        }
        return ast;
    }
    TypeScript.postCollectTypes = postCollectTypes;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScopeChain = (function () {
        function ScopeChain(container, previous, scope) {
            this.container = container;
            this.previous = previous;
            this.scope = scope;
        }
        return ScopeChain;
    })();
    TypeScript.ScopeChain = ScopeChain;    
    var BBUseDefInfo = (function () {
        function BBUseDefInfo(bb) {
            this.bb = bb;
            this.defsBySymbol = new Array();
            this.useIndexBySymbol = new Array();
        }
        BBUseDefInfo.prototype.updateTop = function () {
            var temp = new BitVector(this.top.bitCount);
            for(var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {
                var succ = this.bb.successors[i];
                if (succ.useDef) {
                    temp.union(succ.useDef.top);
                }
            }
            temp.difference(this.kill);
            temp.union(this.gen);
            var changed = temp.notEq(this.top);
            this.top = temp;
            return changed;
        };
        BBUseDefInfo.prototype.initialize = function (useDefContext) {
            var _this = this;
            var defSym = function (sym, context) {
                if (context.isLocalSym(sym)) {
                    var index = context.getSymbolIndex(sym);
                    _this.useIndexBySymbol[index] = new Array();
                    _this.defsBySymbol[index] = true;
                }
            };
            var useSym = function (sym, context, ast) {
                if (context.isLocalSym(sym)) {
                    var symIndex = context.getSymbolIndex(sym);
                    if (_this.useIndexBySymbol[symIndex] == undefined) {
                        _this.useIndexBySymbol[symIndex] = new Array();
                    }
                    var symUses = _this.useIndexBySymbol[symIndex];
                    var astIndex = context.getUseIndex(ast);
                    context.addUse(symIndex, astIndex);
                    symUses.push(astIndex);
                }
            };
            function initUseDefPre(cur, parent, walker) {
                var context = walker.state;
                if (cur == null) {
                    cur = null;
                }
                if (cur.nodeType == 75 /* VarDecl */ ) {
                    var varDecl = cur;
                    if (varDecl.init || TypeScript.hasFlag(varDecl.varFlags, 256 /* AutoInit */ )) {
                        defSym(varDecl.sym, context);
                    }
                } else if (cur.nodeType == 25 /* Name */ ) {
                    if (parent) {
                        if (parent.nodeType == 32 /* Asg */ ) {
                            var asg = parent;
                            if (asg.operand1 == cur) {
                                return cur;
                            }
                        } else if (parent.nodeType == 75 /* VarDecl */ ) {
                            var parentDecl = parent;
                            if (parentDecl.id == cur) {
                                return cur;
                            }
                        }
                    }
                    var id = cur;
                    useSym(id.sym, context, cur);
                } else if ((cur.nodeType >= 32 /* Asg */ ) && (cur.nodeType <= 43 /* LastAsg */ )) {
                    var asg = cur;
                    if (asg.operand1 && (asg.operand1.nodeType == 25 /* Name */ )) {
                        var id = asg.operand1;
                        defSym(id.sym, context);
                    }
                } else if (cur.nodeType == 73 /* FuncDecl */ ) {
                    walker.options.goChildren = false;
                }
                return cur;
            }
            var options = new TypeScript.AstWalkOptions();
            options.reverseSiblings = true;
            TypeScript.getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);
        };
        BBUseDefInfo.prototype.initializeGen = function (useDefContext) {
            var symbolLen = this.useIndexBySymbol.length;
            var bitCount = useDefContext.uses.length;
            this.gen = new BitVector(bitCount);
            for(var s = 0; s < symbolLen; s++) {
                var symUses = this.useIndexBySymbol[s];
                if ((symUses != undefined) && (symUses.length > 0)) {
                    for(var u = 0, uLen = symUses.length; u < uLen; u++) {
                        this.gen.set(symUses[u], true);
                    }
                }
            }
            this.top = this.gen;
        };
        BBUseDefInfo.prototype.initializeKill = function (useDefContext) {
            this.kill = new BitVector(this.gen.bitCount);
            for(var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {
                if (this.defsBySymbol[s]) {
                    var globalSymUses = useDefContext.useIndexBySymbol[s];
                    if (globalSymUses) {
                        for(var u = 0, useLen = globalSymUses.length; u < useLen; u++) {
                            this.kill.set(globalSymUses[u], true);
                        }
                    }
                }
            }
        };
        return BBUseDefInfo;
    })();
    TypeScript.BBUseDefInfo = BBUseDefInfo;    
    var UseDefContext = (function () {
        function UseDefContext() {
            this.useIndexBySymbol = new Array();
            this.uses = new Array();
            this.symbols = new Array();
            this.symbolMap = new TypeScript.StringHashTable();
            this.symbolCount = 0;
        }
        UseDefContext.prototype.getSymbolIndex = function (sym) {
            var name = sym.name;
            var index = (this.symbolMap.lookup(name));
            if (index == null) {
                index = this.symbolCount++;
                this.symbols[index] = sym;
                this.symbolMap.add(name, index);
            }
            return index;
        };
        UseDefContext.prototype.addUse = function (symIndex, astIndex) {
            var useBySym = this.useIndexBySymbol[symIndex];
            if (useBySym == undefined) {
                useBySym = new Array();
                this.useIndexBySymbol[symIndex] = useBySym;
            }
            useBySym[useBySym.length] = astIndex;
        };
        UseDefContext.prototype.getUseIndex = function (ast) {
            this.uses[this.uses.length] = ast;
            return this.uses.length - 1;
        };
        UseDefContext.prototype.isLocalSym = function (sym) {
            return (sym && (sym.container == this.func) && (sym.kind() == 4 /* Variable */ ));
        };
        UseDefContext.prototype.killSymbol = function (sym, bbUses) {
            var index = this.symbolMap.lookup(sym.name);
            var usesOfSym = this.useIndexBySymbol[index];
            for(var k = 0, len = usesOfSym.length; k < len; k++) {
                bbUses.set(usesOfSym[k], true);
            }
        };
        return UseDefContext;
    })();
    TypeScript.UseDefContext = UseDefContext;    
    var BitVector = (function () {
        function BitVector(bitCount) {
            this.bitCount = bitCount;
            this.firstBits = 0;
            this.restOfBits = null;
            if (this.bitCount > BitVector.packBits) {
                this.restOfBits = new Array();
                var len = Math.floor(this.bitCount / BitVector.packBits);
                for(var i = 0; i < len; i++) {
                    this.restOfBits[i] = 0;
                }
            }
        }
        BitVector.packBits = 30;
        BitVector.prototype.set = function (bitIndex, value) {
            if (bitIndex < BitVector.packBits) {
                if (value) {
                    this.firstBits |= (1 << bitIndex);
                } else {
                    this.firstBits &= (~(1 << bitIndex));
                }
            } else {
                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;
                var localIndex = bitIndex % BitVector.packBits;
                if (value) {
                    this.restOfBits[offset] |= (1 << localIndex);
                } else {
                    this.restOfBits[offset] &= (~(1 << localIndex));
                }
            }
        };
        BitVector.prototype.map = function (fn) {
            var k;
            for(k = 0; k < BitVector.packBits; k++) {
                if (k == this.bitCount) {
                    return;
                }
                if (((1 << k) & this.firstBits) != 0) {
                    fn(k);
                }
            }
            if (this.restOfBits) {
                var len;
                var cumu = BitVector.packBits;
                for(k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    for(var j = 0; j < BitVector.packBits; j++) {
                        if (((1 << j) & myBits) != 0) {
                            fn(cumu);
                        }
                        cumu++;
                        if (cumu == this.bitCount) {
                            return;
                        }
                    }
                }
            }
        };
        BitVector.prototype.union = function (b) {
            this.firstBits |= b.firstBits;
            if (this.restOfBits) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] = myBits | bBits;
                }
            }
        };
        BitVector.prototype.intersection = function (b) {
            this.firstBits &= b.firstBits;
            if (this.restOfBits) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] = myBits & bBits;
                }
            }
        };
        BitVector.prototype.notEq = function (b) {
            if (this.firstBits != b.firstBits) {
                return true;
            }
            if (this.restOfBits) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    if (myBits != bBits) {
                        return true;
                    }
                }
            }
            return false;
        };
        BitVector.prototype.difference = function (b) {
            var oldFirstBits = this.firstBits;
            this.firstBits &= (~b.firstBits);
            if (this.restOfBits) {
                for(var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] &= (~bBits);
                }
            }
        };
        return BitVector;
    })();
    TypeScript.BitVector = BitVector;    
    var BasicBlock = (function () {
        function BasicBlock() {
            this.predecessors = new Array();
            this.index = -1;
            this.markValue = 0;
            this.successors = new Array();
            this.useDef = null;
            this.content = new TypeScript.ASTList();
        }
        BasicBlock.prototype.marked = function (markBase) {
            return this.markValue > markBase;
        };
        BasicBlock.prototype.mark = function () {
            this.markValue++;
        };
        BasicBlock.prototype.addSuccessor = function (successor) {
            this.successors[this.successors.length] = successor;
            successor.predecessors[successor.predecessors.length] = this;
        };
        return BasicBlock;
    })();
    TypeScript.BasicBlock = BasicBlock;    
    var ControlFlowContext = (function () {
        function ControlFlowContext(current, exit) {
            this.current = current;
            this.exit = exit;
            this.entry = null;
            this.unreachable = null;
            this.noContinuation = false;
            this.statementStack = new Array();
            this.currentSwitch = new Array();
            this.markBase = 0;
            this.linearBBs = new Array();
            this.entry = this.current;
        }
        ControlFlowContext.prototype.walk = function (ast, parent) {
            return this.walker.walk(ast, parent);
        };
        ControlFlowContext.prototype.pushSwitch = function (bb) {
            this.currentSwitch.push(bb);
        };
        ControlFlowContext.prototype.popSwitch = function () {
            return this.currentSwitch.pop();
        };
        ControlFlowContext.prototype.reportUnreachable = function (er) {
            if (this.unreachable && (this.unreachable.length > 0)) {
                var len = this.unreachable.length;
                for(var i = 0; i < len; i++) {
                    var unreachableAST = this.unreachable[i];
                    if (unreachableAST.nodeType != 105 /* EndCode */ ) {
                        er.simpleError(unreachableAST, "unreachable code");
                    }
                }
            }
        };
        ControlFlowContext.prototype.printAST = function (ast, outfile) {
            var printContext = new TypeScript.PrintContext(outfile, null);
            printContext.increaseIndent();
            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.prePrintAST, TypeScript.postPrintAST, null, printContext);
            printContext.decreaseIndent();
        };
        ControlFlowContext.prototype.printBlockContent = function (bb, outfile) {
            var content = bb.content;
            for(var i = 0, len = content.members.length; i < len; i++) {
                var ast = content.members[i];
                this.printAST(ast, outfile);
            }
        };
        ControlFlowContext.prototype.bfs = function (nodeFunc, edgeFunc, preEdges, postEdges) {
            var markValue = this.markBase++;
            var q = new Array();
            q[q.length] = this.entry;
            while(q.length > 0) {
                var bb = q.pop();
                if (!(bb.marked(markValue))) {
                    bb.mark();
                    if (nodeFunc) {
                        nodeFunc(bb);
                    }
                    var succLen = bb.successors.length;
                    if (succLen > 0) {
                        if (preEdges) {
                            preEdges();
                        }
                        for(var j = succLen - 1; j >= 0; j--) {
                            var successor = bb.successors[j];
                            if (!(successor.marked(this.markBase))) {
                                if (edgeFunc) {
                                    edgeFunc(bb, successor);
                                }
                                q[q.length] = successor;
                            }
                        }
                        if (postEdges) {
                            postEdges();
                        }
                    }
                }
            }
        };
        ControlFlowContext.prototype.useDef = function (er, funcSym) {
            var _this = this;
            var useDefContext = new UseDefContext();
            useDefContext.func = funcSym;
            var useDefInit = function (bb) {
                bb.useDef = new BBUseDefInfo(bb);
                bb.useDef.initialize(useDefContext);
                _this.linearBBs[_this.linearBBs.length] = bb;
            };
            this.bfs(useDefInit, null, null, null);
            var i, bbLen;
            for(i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {
                this.linearBBs[i].useDef.initializeGen(useDefContext);
                this.linearBBs[i].useDef.initializeKill(useDefContext);
            }
            var changed = true;
            while(changed) {
                changed = false;
                for(i = 0; i < bbLen; i++) {
                    changed = this.linearBBs[i].useDef.updateTop() || changed;
                }
            }
            var top = this.entry.useDef.top;
            top.map(function (index) {
                var ast = useDefContext.uses[index];
                er.simpleError(ast, "use of variable '" + ast.actualText + "' that is not definitely assigned");
            });
        };
        ControlFlowContext.prototype.print = function (outfile) {
            var _this = this;
            var index = 0;
            var node = function (bb) {
                if (bb.index < 0) {
                    bb.index = index++;
                }
                if (bb == _this.exit) {
                    outfile.WriteLine("Exit block with index " + bb.index);
                } else {
                    outfile.WriteLine("Basic block with index " + bb.index);
                    _this.printBlockContent(bb, outfile);
                }
            };
            function preEdges() {
                outfile.Write("  Branches to ");
            }
            function postEdges() {
                outfile.WriteLine("");
            }
            function edge(node1, node2) {
                if (node2.index < 0) {
                    node2.index = index++;
                }
                outfile.Write(node2.index + " ");
            }
            this.bfs(node, edge, preEdges, postEdges);
            if (this.unreachable != null) {
                for(var i = 0, len = this.unreachable.length; i < len; i++) {
                    outfile.WriteLine("Unreachable basic block ...");
                    this.printAST(this.unreachable[i], outfile);
                }
            }
        };
        ControlFlowContext.prototype.pushStatement = function (stmt, continueBB, breakBB) {
            this.statementStack.push({
                stmt: stmt,
                continueBB: continueBB,
                breakBB: breakBB
            });
        };
        ControlFlowContext.prototype.popStatement = function () {
            return this.statementStack.pop();
        };
        ControlFlowContext.prototype.returnStmt = function () {
            this.current.addSuccessor(this.exit);
            this.setUnreachable();
        };
        ControlFlowContext.prototype.setUnreachable = function () {
            this.current = null;
            this.noContinuation = true;
        };
        ControlFlowContext.prototype.addUnreachable = function (ast) {
            if (this.unreachable === null) {
                this.unreachable = new Array();
            }
            this.unreachable[this.unreachable.length] = ast;
        };
        ControlFlowContext.prototype.unconditionalBranch = function (target, isContinue) {
            var targetBB = null;
            for(var i = 0, len = this.statementStack.length; i < len; i++) {
                var targetInfo = this.statementStack[i];
                if (targetInfo.stmt == target) {
                    if (isContinue) {
                        targetBB = targetInfo.continueBB;
                    } else {
                        targetBB = targetInfo.breakBB;
                    }
                    break;
                }
            }
            if (targetBB) {
                this.current.addSuccessor(targetBB);
            }
            this.setUnreachable();
        };
        ControlFlowContext.prototype.addContent = function (ast) {
            if (this.current) {
                this.current.content.append(ast);
            }
        };
        return ControlFlowContext;
    })();
    TypeScript.ControlFlowContext = ControlFlowContext;    
    var ResolutionDataCache = (function () {
        function ResolutionDataCache() {
            this.cacheSize = 16;
            this.rdCache = [];
            this.nextUp = 0;
            for(var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: new Array(),
                    exactCandidates: new Array(),
                    conversionCandidates: new Array(),
                    id: i
                };
            }
        }
        ResolutionDataCache.prototype.getResolutionData = function () {
            var rd = null;
            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }
            if (rd == null) {
                this.cacheSize++;
                rd = {
                    actuals: new Array(),
                    exactCandidates: new Array(),
                    conversionCandidates: new Array(),
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }
            this.nextUp++;
            return rd;
        };
        ResolutionDataCache.prototype.returnResolutionData = function (rd) {
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;
            this.nextUp = rd.id;
        };
        return ResolutionDataCache;
    })();
    TypeScript.ResolutionDataCache = ResolutionDataCache;    
    var TypeFlow = (function () {
        function TypeFlow(logger, initScope, parser, checker) {
            this.logger = logger;
            this.initScope = initScope;
            this.parser = parser;
            this.checker = checker;
            this.thisFnc = null;
            this.thisClassNode = null;
            this.enclosingFncIsMethod = false;
            this.arrayInterfaceType = null;
            this.stringInterfaceType = null;
            this.objectInterfaceType = null;
            this.functionInterfaceType = null;
            this.numberInterfaceType = null;
            this.booleanInterfaceType = null;
            this.iargumentsInterfaceType = null;
            this.currentScript = null;
            this.inImportTypeCheck = false;
            this.inTypeRefTypeCheck = false;
            this.inArrayElementTypeCheck = false;
            this.resolutionDataCache = new ResolutionDataCache();
            this.nestingLevel = 0;
            this.inSuperCall = false;
            this.checker.typeFlow = this;
            this.scope = this.initScope;
            this.globalScope = this.initScope;
            this.doubleType = this.checker.numberType;
            this.booleanType = this.checker.booleanType;
            this.stringType = this.checker.stringType;
            this.anyType = this.checker.anyType;
            this.regexType = this.anyType;
            this.nullType = this.checker.nullType;
            this.voidType = this.checker.voidType;
            this.arrayAnyType = this.checker.makeArrayType(this.anyType);
        }
        TypeFlow.prototype.initLibs = function () {
            var arraySym = this.globalScope.find("Array", false, true);
            if (arraySym && (arraySym.kind() == 1 /* Type */ )) {
                this.arrayInterfaceType = (arraySym).type;
            }
            var stringSym = this.globalScope.find("String", false, true);
            if (stringSym && (stringSym.kind() == 1 /* Type */ )) {
                this.stringInterfaceType = (stringSym).type;
            }
            var objectSym = this.globalScope.find("Object", false, true);
            if (objectSym && (objectSym.kind() == 1 /* Type */ )) {
                this.objectInterfaceType = (objectSym).type;
            }
            var fnSym = this.globalScope.find("Function", false, true);
            if (fnSym && (fnSym.kind() == 1 /* Type */ )) {
                this.functionInterfaceType = (fnSym).type;
            }
            var numberSym = this.globalScope.find("Number", false, true);
            if (numberSym && (numberSym.kind() == 1 /* Type */ )) {
                this.numberInterfaceType = (numberSym).type;
            }
            var booleanSym = this.globalScope.find("Boolean", false, true);
            if (booleanSym && (booleanSym.kind() == 1 /* Type */ )) {
                this.booleanInterfaceType = (booleanSym).type;
            }
            var regexSym = this.globalScope.find("RegExp", false, true);
            if (regexSym && (regexSym.kind() == 1 /* Type */ )) {
                this.regexType = (regexSym).type;
            }
        };
        TypeFlow.prototype.cast = function (ast, type) {
            return this.castWithCoercion(ast, type, true, false);
        };
        TypeFlow.prototype.castWithCoercion = function (ast, type, applyCoercion, typeAssertion) {
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            if (this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {
                if (applyCoercion) {
                    if (type == null) {
                        ast.type = this.anyType;
                    } else if (type.isClass()) {
                        ast.type = type.instanceType;
                    } else {
                        ast.type = type;
                    }
                }
                return ast;
            } else {
                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);
                return ast;
            }
        };
        TypeFlow.prototype.inScopeTypeCheck = function (ast, enclosingScope) {
            var prevScope = this.scope;
            this.scope = enclosingScope;
            var svThisFnc = this.thisFnc;
            var svThisType = this.thisType;
            var svThisClassNode = this.thisClassNode;
            var svCurrentModDecl = this.checker.currentModDecl;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var container = this.scope.container;
            var fnc = null;
            while(container) {
                if (container.kind() == 1 /* Type */ ) {
                    var typeSym = container;
                    var type = typeSym.type;
                    if (type.call) {
                        if (fnc == null) {
                            this.enclosingFncIsMethod = typeSym.isMethod;
                            fnc = container.declAST;
                        }
                    }
                    if (type.isClass()) {
                        this.thisType = type.instanceType;
                        if (typeSym.declAST && (typeSym.declAST.nodeType == 96 /* ClassDeclaration */ )) {
                            this.thisClassNode = typeSym.declAST;
                        }
                        break;
                    }
                    if (type.isModuleType()) {
                        this.checker.currentModDecl = typeSym.declAST;
                        break;
                    }
                }
                container = container.container;
            }
            this.thisFnc = fnc;
            var updated = this.typeCheck(ast);
            this.thisFnc = svThisFnc;
            this.thisType = svThisType;
            this.thisClassNode = svThisClassNode;
            this.checker.currentModDecl = svCurrentModDecl;
            this.enclosingFncIsMethod = prevMethodStatus;
            this.scope = prevScope;
            return updated;
        };
        TypeFlow.prototype.typeCheck = function (ast) {
            if (ast) {
                return ast.typeCheck(this);
            } else {
                return null;
            }
        };
        TypeFlow.prototype.inScopeTypeCheckDecl = function (ast) {
            if (ast.nodeType == 75 /* VarDecl */  || ast.nodeType == 76 /* ArgDecl */ ) {
                this.inScopeTypeCheckBoundDecl(ast);
            } else if (ast.nodeType == 73 /* FuncDecl */ ) {
                var funcDecl = ast;
                if (funcDecl.isAccessor()) {
                    this.typeCheckFunction(funcDecl);
                }
            }
        };
        TypeFlow.prototype.inScopeTypeCheckBoundDecl = function (varDecl) {
            var sym = varDecl.sym;
            var svThisFnc = this.thisFnc;
            var svThisType = this.thisType;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var prevLocationInfo = this.checker.locationInfo;
            if (sym && sym.container) {
                var instanceScope = TypeScript.hasFlag(varDecl.varFlags, 16384 /* ClassConstructorProperty */ ) ? sym.container.getType().constructorScope : sym.container.instanceScope();
                if (TypeScript.hasFlag(varDecl.varFlags, 512 /* Property */ ) && sym.container.declAST.nodeType == 73 /* FuncDecl */ ) {
                    this.thisFnc = sym.container.declAST;
                }
                if (instanceScope) {
                    var prevScope = this.scope;
                    this.scope = instanceScope;
                    var container = sym.container;
                    var svCurrentModDecl = this.checker.currentModDecl;
                    if (this.checker.units && (sym.unitIndex >= 0) && (sym.unitIndex < this.checker.units.length)) {
                        this.checker.locationInfo = this.checker.units[sym.unitIndex];
                    } else {
                        this.checker.locationInfo = TypeScript.unknownLocationInfo;
                    }
                    while(container) {
                        if (container.kind() == 1 /* Type */ ) {
                            var typeSym = container;
                            var type = typeSym.type;
                            if (type.call) {
                                this.enclosingFncIsMethod = typeSym.isMethod;
                            }
                            if (type.isClass()) {
                                this.thisType = type.instanceType;
                            }
                            if (type.isModuleType()) {
                                this.checker.currentModDecl = container.declAST;
                                break;
                            }
                        }
                        container = container.container;
                    }
                    this.typeCheckBoundDecl(varDecl);
                    this.checker.currentModDecl = svCurrentModDecl;
                    this.scope = prevScope;
                }
            }
            this.thisFnc = svThisFnc;
            this.thisType = svThisType;
            this.checker.locationInfo = prevLocationInfo;
            this.enclosingFncIsMethod = prevMethodStatus;
        };
        TypeFlow.prototype.resolveBoundDecl = function (varDecl) {
            if (varDecl.typeExpr) {
                if (varDecl.typeExpr.type == null || (varDecl.typeExpr.type && varDecl.typeExpr.type == this.anyType && this.scope) || varDecl.typeExpr.type.symbol == null || !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {
                    this.typeCheck(varDecl.typeExpr);
                }
                varDecl.type = varDecl.typeExpr.type;
                if (varDecl.sym) {
                    varDecl.sym.setType(varDecl.type);
                }
            } else if (varDecl.init == null) {
                if (this.checker.styleSettings.implicitAny) {
                    this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                }
                varDecl.type = this.anyType;
                if (varDecl.sym) {
                    if (varDecl.sym.isType()) {
                        var tsym = varDecl.sym;
                        if (tsym.isMethod) {
                            this.checker.errorReporter.simpleError(varDecl, "Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)");
                            return;
                        } else {
                            this.checker.errorReporter.simpleError(varDecl, "Cannot bind type to variable");
                            return;
                        }
                    }
                    varDecl.sym.setType(varDecl.type);
                }
            }
        };
        TypeFlow.prototype.typeCheckBoundDecl = function (varDecl) {
            var _this = this;
            var infSym = varDecl.sym;
            if (infSym == null) {
                if (varDecl.init) {
                    varDecl.init = this.typeCheck(varDecl.init);
                    varDecl.type = this.checker.widenType(varDecl.init.type);
                } else {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                    }
                    varDecl.type = this.anyType;
                }
            } else {
                if (infSym.typeCheckStatus == 1 /* Started */ ) {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                    }
                    varDecl.type = this.anyType;
                    infSym.setType(this.anyType);
                } else if (infSym.typeCheckStatus == 0 /* NotStarted */ ) {
                    infSym.typeCheckStatus = 1 /* Started */ ;
                    this.checker.addStartedPTO(infSym);
                    var resolved = false;
                    if (varDecl.type == null) {
                        if (varDecl.typeExpr) {
                            this.resolveBoundDecl(varDecl);
                            resolved = true;
                            varDecl.type = varDecl.typeExpr.type;
                            infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                        }
                    }
                    if (varDecl.init) {
                        var isLocalStatic = TypeScript.hasFlag(varDecl.varFlags, 32 /* LocalStatic */ );
                        var prevScope = this.scope;
                        var applyTargetType = !varDecl.init.isParenthesized;
                        if (isLocalStatic) {
                            this.scope = varDecl.sym.container.getType().memberScope;
                        }
                        if (TypeScript.hasFlag(varDecl.varFlags, 512 /* Property */ ) && this.thisClassNode) {
                            TypeScript.getAstWalkerFactory().walk(varDecl.init, function (ast, parent, walker) {
                                if (ast && ast.nodeType == 73 /* FuncDecl */ ) {
                                    if (TypeScript.hasFlag((ast).fncFlags, 32768 /* IsFatArrowFunction */ )) {
                                        (ast).fncFlags |= 2097152 /* IsPropertyBound */ ;
                                    }
                                    walker.options.goChildren = false;
                                }
                                return ast;
                            });
                        }
                        this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);
                        this.scope = prevScope;
                        if (varDecl.type) {
                            var preserveScope = false;
                            var preservedContainedScope = null;
                            if (varDecl.init.type) {
                                preservedContainedScope = varDecl.init.type.containedScope;
                                preserveScope = true;
                                if (varDecl.init.type == this.voidType) {
                                    this.checker.errorReporter.simpleError(varDecl, "Cannot assign type 'void' to variable '" + varDecl.id.actualText + "'");
                                }
                            }
                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);
                            if (preserveScope && varDecl.init.type.containedScope == null) {
                                varDecl.init.type.containedScope = preservedContainedScope;
                            }
                        } else {
                            varDecl.type = this.checker.widenType(varDecl.init.type);
                            if (varDecl.type == this.voidType) {
                                this.checker.errorReporter.simpleError(varDecl, "Cannot assign type 'void' to variable '" + varDecl.id.actualText + "'");
                                varDecl.type = this.anyType;
                            }
                        }
                        infSym.setType(varDecl.type);
                    } else {
                        if (!resolved) {
                            this.resolveBoundDecl(varDecl);
                        }
                    }
                    infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                } else if (this.checker.typeStatusIsFinished(infSym.typeCheckStatus) && (infSym.declAST != varDecl)) {
                    if (varDecl.init) {
                        varDecl.init = this.typeCheck(varDecl.init);
                        varDecl.type = infSym.getType();
                        varDecl.init = this.cast(varDecl.init, varDecl.type);
                    }
                }
            }
            if (varDecl.id && varDecl.sym) {
                varDecl.id.sym = varDecl.sym;
            }
            if (varDecl.sym && varDecl.sym.container) {
                this.checkTypePrivacy(varDecl.sym.getType(), varDecl.sym, function (typeName, isModuleName) {
                    return _this.varPrivacyErrorReporter(varDecl, typeName, isModuleName);
                });
            }
            return varDecl;
        };
        TypeFlow.prototype.varPrivacyErrorReporter = function (varDecl, typeName, isModuleName) {
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!TypeScript.isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }
            if (TypeScript.hasFlag(varDecl.varFlags, 4 /* Public */ )) {
                if (varDecl.sym.container.declAST.nodeType == 97 /* InterfaceDeclaration */ ) {
                    this.checker.errorReporter.simpleError(varDecl, "property '" + varDecl.sym.name + "' of exported interface" + typestring);
                } else {
                    this.checker.errorReporter.simpleError(varDecl, "public member '" + varDecl.sym.name + "' of exported class" + typestring);
                }
            } else {
                this.checker.errorReporter.simpleError(varDecl, "exported variable '" + varDecl.sym.name + "'" + typestring);
            }
        };
        TypeFlow.prototype.typeCheckSuper = function (ast) {
            if (this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {
                ast.type = this.thisType.baseClass();
            } else {
                if (!this.enclosingFncIsMethod && this.thisType && this.thisType.baseClass() && this.thisFnc && TypeScript.hasFlag(this.thisFnc.fncFlags, 32768 /* IsFatArrowFunction */ )) {
                    var enclosingFnc = this.thisFnc.enclosingFnc;
                    while(TypeScript.hasFlag(enclosingFnc.fncFlags, 32768 /* IsFatArrowFunction */ )) {
                        enclosingFnc = enclosingFnc.enclosingFnc;
                    }
                    if (enclosingFnc && (enclosingFnc.isMethod() || enclosingFnc.isConstructor) && !enclosingFnc.isStatic()) {
                        ast.type = this.thisType.baseClass();
                        enclosingFnc.setHasSuperReferenceInFatArrowFunction();
                        return ast;
                    }
                }
                ast.type = this.anyType;
                this.checker.errorReporter.invalidSuperReference(ast);
            }
            return ast;
        };
        TypeFlow.prototype.typeCheckThis = function (ast) {
            ast.type = this.anyType;
            var illegalThisRef = false;
            if (this.thisFnc == null) {
                if (this.thisType) {
                    if (this.thisClassNode && this.thisClassNode.nodeType == 96 /* ClassDeclaration */ ) {
                        illegalThisRef = true;
                    } else {
                        ast.type = this.thisType;
                    }
                } else if (this.checker.currentModDecl) {
                    this.checker.errorReporter.simpleError(ast, "'this' may not be referenced within module bodies");
                }
            } else {
                if (this.thisClassNode && (TypeScript.hasFlag(this.thisFnc.fncFlags, 2097152 /* IsPropertyBound */ ) || (this.inSuperCall && TypeScript.hasFlag((this.thisClassNode).varFlags, 32768 /* ClassSuperMustBeFirstCallInConstructor */ )))) {
                    illegalThisRef = true;
                }
                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor) {
                    if (this.thisType && !(this.thisFnc.fncFlags & 16 /* Static */ )) {
                        ast.type = this.thisType;
                    }
                }
            }
            if (!this.enclosingFncIsMethod && this.thisFnc && TypeScript.hasFlag(this.thisFnc.fncFlags, 32768 /* IsFatArrowFunction */ )) {
                if (this.thisFnc.boundToProperty) {
                    var container = this.thisFnc.boundToProperty.sym.container;
                    if (container.declAST.nodeType == 73 /* FuncDecl */ ) {
                        (container.declAST).setHasSelfReference();
                    }
                } else {
                    var encFnc = this.thisFnc.enclosingFnc;
                    var firstEncFnc = encFnc;
                    while(encFnc) {
                        if (this.thisClassNode && TypeScript.hasFlag(encFnc.fncFlags, 2097152 /* IsPropertyBound */ )) {
                            illegalThisRef = true;
                        }
                        if (!TypeScript.hasFlag(encFnc.fncFlags, 32768 /* IsFatArrowFunction */ ) || encFnc.hasSelfReference()) {
                            encFnc.setHasSelfReference();
                            break;
                        }
                        encFnc = encFnc.enclosingFnc;
                    }
                    if (!encFnc && firstEncFnc) {
                        encFnc = firstEncFnc;
                        encFnc.setHasSelfReference();
                    } else if (!encFnc) {
                        if (this.thisClassNode) {
                            (this.thisClassNode).varFlags |= 131072 /* MustCaptureThis */ ;
                        } else if (this.checker.currentModDecl) {
                            this.checker.currentModDecl.modFlags |= 4096 /* MustCaptureThis */ ;
                        } else {
                            this.checker.mustCaptureGlobalThis = true;
                        }
                    }
                    if (encFnc && (encFnc.isMethod() || encFnc.isConstructor) && this.thisType && !TypeScript.hasFlag(encFnc.fncFlags, 16 /* Static */ )) {
                        ast.type = this.thisType;
                    }
                }
            }
            if (illegalThisRef) {
                this.checker.errorReporter.simpleError(ast, "Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls");
            }
            return ast;
        };
        TypeFlow.prototype.setTypeFromSymbol = function (ast, symbol) {
            if (symbol.isVariable()) {
                if (symbol.isInferenceSymbol()) {
                    var infSym = symbol;
                    if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {
                        if (infSym.typeCheckStatus == 1 /* Started */ ) {
                            infSym.declAST.type = this.anyType;
                            infSym.setType(this.anyType);
                        } else {
                            this.inScopeTypeCheckDecl(infSym.declAST);
                        }
                    }
                    if (!this.checker.styleSettings.innerScopeDeclEscape) {
                        if (infSym.declAST && (infSym.declAST.nodeType == 75 /* VarDecl */ )) {
                            if (this.nestingLevel < (infSym.declAST).nestingLevel) {
                                this.checker.errorReporter.styleError(ast, "Illegal reference to a variable defined in more nested scope");
                            }
                        }
                    }
                }
                ast.type = symbol.getType();
                if (!symbol.writeable()) {
                    ast.flags = ast.flags & (~(4 /* Writeable */ ));
                }
            } else if (symbol.isType()) {
                ast.type = symbol.getType();
                ast.flags = ast.flags & (~(4 /* Writeable */ ));
            } else {
                ast.type = this.anyType;
                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);
            }
        };
        TypeFlow.prototype.typeCheckName = function (ast) {
            var _this = this;
            var identifier = ast;
            if (this.checker.inWith) {
                identifier.type = this.anyType;
            } else {
                var typespace = this.inTypeRefTypeCheck;
                var idText = identifier.text;
                var originalIdText = idText;
                var isDynamicModuleName = TypeScript.isQuoted(identifier.text);
                var symbol = this.scope.find(idText, false, typespace);
                if (symbol == null && isDynamicModuleName) {
                    symbol = this.checker.findSymbolForDynamicModule(idText, this.currentScript.locationInfo.filename, function (id) {
                        return _this.scope.find(id, false, typespace);
                    });
                }
                if (!symbol) {
                    if (!identifier.isMissing()) {
                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);
                    }
                    identifier.type = this.anyType;
                } else {
                    if (TypeScript.optimizeModuleCodeGen && symbol && symbol.isType()) {
                        var symType = symbol.getType();
                        if (symType && (symbol).aliasLink && (symbol).onlyReferencedAsTypeRef) {
                            var modDecl = symType.symbol.declAST;
                            if (modDecl && TypeScript.hasFlag(modDecl.modFlags, 2048 /* IsDynamic */ )) {
                                (symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;
                            }
                        }
                    }
                    if (symbol.declAST && symbol.declAST.nodeType == 73 /* FuncDecl */  && !(symbol.declAST).returnTypeAnnotation && (symbol.declAST).signature.typeCheckStatus == 1 /* Started */ ) {
                        (symbol.declAST).type.symbol.flags |= 131072 /* RecursivelyReferenced */ ;
                        (symbol.declAST).signature.returnType.type = this.anyType;
                    }
                    this.setTypeFromSymbol(ast, symbol);
                    identifier.sym = symbol;
                    if (this.thisFnc) {
                        if (this.thisFnc.type && symbol.container != this.thisFnc.type.symbol) {
                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;
                        }
                    }
                }
            }
            return ast;
        };
        TypeFlow.prototype.typeCheckScript = function (script) {
            this.checker.locationInfo = script.locationInfo;
            this.scope = this.checker.globalScope;
            if (!script.topLevelMod) {
                this.addLocalsFromScope(this.scope, this.checker.gloMod, script.vars, this.checker.globals, true);
            }
            this.currentScript = script;
            script.bod = this.typeCheck(script.bod);
            this.currentScript = null;
            return script;
        };
        TypeFlow.prototype.typeCheckBitNot = function (ast) {
            var unex = ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.doubleType;
            return unex;
        };
        TypeFlow.prototype.typeCheckUnaryNumberOperator = function (ast) {
            var unex = ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.doubleType;
            return ast;
        };
        TypeFlow.prototype.typeCheckLogNot = function (ast) {
            var unex = ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.booleanType;
            return unex;
        };
        TypeFlow.prototype.astIsWriteable = function (ast) {
            return TypeScript.hasFlag(ast.flags, 4 /* Writeable */ );
        };
        TypeFlow.prototype.typeCheckIncOrDec = function (ast) {
            var unex = ast;
            var lval = unex.operand;
            if (!this.astIsWriteable(unex)) {
                this.checker.errorReporter.valueCannotBeModified(unex);
                unex.type = this.doubleType;
            } else {
                unex = this.typeCheckUnaryNumberOperator(ast);
                if (unex.operand.type != this.checker.numberType && unex.operand.type != this.checker.anyType && !(unex.operand.type.typeFlags & 8 /* IsEnum */ )) {
                    this.checker.errorReporter.simpleError(ast, "'++' and '--' may only be applied to operands of type 'number' or 'any'");
                }
            }
            return unex;
        };
        TypeFlow.prototype.typeCheckBitwiseOperator = function (ast, assignment) {
            var binex = ast;
            var resultType = null;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if (assignment && (!this.astIsWriteable(binex))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }
            if (this.checker.styleSettings.bitwise) {
                this.checker.errorReporter.styleError(ast, "use of " + TypeScript.nodeTypeTable[binex.nodeType]);
            }
            if (this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {
                resultType = this.doubleType;
            } else if ((leftType == this.booleanType) && (rightType == this.booleanType)) {
                resultType = this.booleanType;
            } else if (leftType == this.anyType) {
                if ((rightType == this.anyType) || (rightType == this.doubleType) || (rightType == this.booleanType)) {
                    resultType = this.anyType;
                }
            } else if (rightType == this.anyType) {
                if ((leftType == this.anyType) || (leftType == this.doubleType) || (leftType == this.booleanType)) {
                    resultType = this.anyType;
                }
            }
            if (resultType == null) {
                resultType = this.anyType;
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
            }
            binex.type = resultType;
            return binex;
        };
        TypeFlow.prototype.typeCheckArithmeticOperator = function (ast, assignment) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if (assignment && (!this.astIsWriteable(binex.operand1))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }
            if (this.checker.styleSettings.bitwise && ((binex.nodeType == 49 /* And */ ) || (binex.nodeType == 47 /* Or */ ) || (binex.nodeType == 38 /* AsgAnd */ ) || (binex.nodeType == 40 /* AsgOr */ ))) {
                this.checker.errorReporter.styleError(ast, "use of " + TypeScript.nodeTypeTable[binex.nodeType]);
            }
            if (leftType == null || rightType == null) {
                this.checker.errorReporter.simpleError(binex, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?");
                binex.type = this.anyType;
                return binex;
            }
            var nodeType = binex.nodeType;
            if (this.checker.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.checker.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }
            leftType = this.checker.widenType(leftType);
            rightType = this.checker.widenType(rightType);
            if (nodeType == 58 /* Add */  || nodeType == 33 /* AsgAdd */ ) {
                if (leftType == this.checker.stringType || rightType == this.checker.stringType) {
                    binex.type = this.checker.stringType;
                } else if (leftType == this.checker.numberType && rightType == this.checker.numberType) {
                    binex.type = this.checker.numberType;
                } else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {
                    binex.type = this.checker.numberType;
                } else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {
                    binex.type = this.checker.anyType;
                } else {
                    binex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
                }
            } else {
                if (leftType == this.checker.numberType && rightType == this.checker.numberType) {
                    binex.type = this.checker.numberType;
                } else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {
                    binex.type = this.checker.numberType;
                } else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {
                    binex.type = this.checker.numberType;
                } else {
                    binex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
                }
            }
            return binex;
        };
        TypeFlow.prototype.typeCheckDotOperator = function (ast) {
            var binex = ast;
            var leftIsFnc = false;
            binex.operand1 = this.typeCheck(binex.operand1);
            var leftType = binex.operand1.type;
            var leftScope = null;
            if (leftType) {
                if (leftType == this.anyType) {
                    binex.type = this.anyType;
                    return binex;
                } else if (leftType == this.stringType) {
                    if (this.stringInterfaceType) {
                        leftScope = this.stringInterfaceType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else if (leftType == this.doubleType) {
                    if (this.numberInterfaceType) {
                        leftScope = this.numberInterfaceType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else if (leftType == this.booleanType) {
                    if (this.booleanInterfaceType) {
                        leftScope = this.booleanInterfaceType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else if ((leftType.call || leftType.construct) && leftType.members == null) {
                    if (this.functionInterfaceType) {
                        leftScope = this.functionInterfaceType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else if (leftType.elementType) {
                    if (this.arrayInterfaceType) {
                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);
                        leftScope = arrInstType.memberScope;
                    } else {
                        binex.type = this.anyType;
                        return binex;
                    }
                } else {
                    leftScope = leftType.memberScope;
                }
            }
            if (leftScope == null) {
                this.checker.errorReporter.expectedClassOrInterface(binex);
                binex.type = this.anyType;
            } else {
                var propertyName = binex.operand2;
                var lhsIsEnclosingType = (this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType) || this.inTypeRefTypeCheck;
                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck);
                if (!symbol) {
                    if (this.objectInterfaceType && leftType) {
                        if (leftType.isReferenceType()) {
                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);
                        }
                        if (!symbol) {
                            if (this.functionInterfaceType && (leftType.call || leftType.construct)) {
                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);
                            }
                        }
                    }
                }
                if (!symbol || (!symbol.visible(leftScope, this.checker))) {
                    binex.type = this.anyType;
                    if (symbol == null) {
                        this.checker.errorReporter.simpleError(propertyName, "The property '" + propertyName.actualText + "' does not exist on value of type '" + leftType.getScopedTypeName(this.scope) + "'");
                    } else if (!this.inTypeRefTypeCheck) {
                        this.checker.errorReporter.simpleError(binex, "The property '" + propertyName.actualText + " on type '" + leftType.getScopedTypeName(this.scope) + "' is not visible");
                    }
                } else {
                    if (symbol.isVariable()) {
                        if (symbol.isInferenceSymbol()) {
                            var infSym = symbol;
                            if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {
                                this.inScopeTypeCheckDecl(infSym.declAST);
                            }
                        }
                    }
                    propertyName.sym = symbol;
                    binex.type = symbol.getType();
                }
            }
            if (binex.type == null) {
                binex.type = this.anyType;
            }
            return binex;
        };
        TypeFlow.prototype.typeCheckBooleanOperator = function (ast) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if ((!(this.checker.sourceIsAssignableToTarget(leftType, rightType))) && (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
            }
            binex.type = this.booleanType;
            return binex;
        };
        TypeFlow.prototype.typeCheckAsgOperator = function (ast) {
            var binex = ast;
            var applyTargetType = !binex.operand2.isParenthesized;
            binex.operand1 = this.typeCheck(binex.operand1);
            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if (!(this.astIsWriteable(binex.operand1))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }
            if (binex.operand1.nodeType == 30 /* Call */ ) {
                var callEx = binex.operand1;
            }
            var preserveScope = false;
            var preservedContainedScope = null;
            if (binex.operand2.type) {
                preservedContainedScope = binex.operand2.type.containedScope;
                preserveScope = true;
            }
            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);
            if (preserveScope && binex.operand2.type.containedScope == null) {
                binex.operand2.type.containedScope = preservedContainedScope;
            }
            binex.type = rightType;
            return binex;
        };
        TypeFlow.prototype.typeCheckIndex = function (ast) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            if (!this.checker.styleSettings.literalSubscript) {
                if (binex.operand2.nodeType == 7 /* QString */ ) {
                    this.checker.errorReporter.styleError(ast, "use literal subscript ('.') notation instead)");
                }
            }
            var objExprType = binex.operand1.type;
            var indexExprType = binex.operand2.type;
            if (objExprType.elementType) {
                if (indexExprType == this.checker.anyType || indexExprType == this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, 8 /* IsEnum */ )) {
                    binex.type = objExprType.elementType;
                } else if (indexExprType == this.checker.stringType) {
                    binex.type = this.checker.anyType;
                } else {
                    this.checker.errorReporter.simpleError(binex, "Illegal property access");
                    binex.type = this.checker.anyType;
                }
            } else if (objExprType.index) {
                if (indexExprType == this.checker.anyType || !((objExprType.index.flags & 2 /* IsStringIndexer */ ) || (objExprType.index.flags & 4 /* IsNumberIndexer */ )) || ((objExprType.index.flags & 2 /* IsStringIndexer */ ) && indexExprType == this.checker.stringType) || ((objExprType.index.flags & 4 /* IsNumberIndexer */ ) && (indexExprType == this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, 8 /* IsEnum */ )))) {
                    var sig = this.resolveOverload(ast, objExprType.index);
                    if (sig) {
                        binex.type = sig.returnType.type;
                    } else {
                        binex.type = this.checker.anyType;
                    }
                } else if (indexExprType == this.checker.stringType) {
                    binex.type = this.checker.anyType;
                } else {
                    this.checker.errorReporter.simpleError(binex, "Illegal property access");
                    binex.type = this.checker.anyType;
                }
            } else if ((objExprType == this.checker.anyType || objExprType == this.checker.stringType || objExprType == this.checker.numberType || objExprType == this.checker.booleanType || objExprType.isReferenceType()) && (indexExprType == this.checker.anyType || indexExprType == this.checker.stringType || (indexExprType == this.checker.numberType || TypeScript.hasFlag(indexExprType.typeFlags, 8 /* IsEnum */ )))) {
                binex.type = this.checker.anyType;
            } else {
                this.checker.errorReporter.simpleError(binex, "Illegal property access");
                binex.type = this.checker.anyType;
            }
            return binex;
        };
        TypeFlow.prototype.typeCheckInOperator = function (binex) {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);
            binex.operand2 = this.typeCheck(binex.operand2);
            if (!((binex.operand1.type == this.checker.anyType || binex.operand1.type == this.checker.stringType) && (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {
                this.checker.errorReporter.simpleError(binex, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");
            }
            binex.type = this.booleanType;
            return binex;
        };
        TypeFlow.prototype.typeCheckShift = function (binex, assignment) {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);
            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);
            if (assignment && (!(this.astIsWriteable(binex.operand1)))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }
            binex.type = this.doubleType;
            return binex;
        };
        TypeFlow.prototype.typeCheckQMark = function (trinex) {
            trinex.operand1 = this.typeCheck(trinex.operand1);
            trinex.operand2 = this.typeCheck(trinex.operand2);
            trinex.operand3 = this.typeCheck(trinex.operand3);
            var leftType = trinex.operand2.type;
            var rightType = trinex.operand3.type;
            if (leftType == rightType) {
                trinex.type = leftType;
            } else {
                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {
                    trinex.type = rightType;
                } else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {
                    trinex.type = leftType;
                } else {
                    trinex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);
                }
            }
            return trinex;
        };
        TypeFlow.prototype.addFormals = function (container, signature, table) {
            var len = signature.parameters.length;
            for(var i = 0; i < len; i++) {
                var symbol = signature.parameters[i];
                symbol.container = container;
                table.add(symbol.name, symbol);
            }
        };
        TypeFlow.prototype.addLocalsFromScope = function (scope, container, vars, table, isModContainer) {
            var len = vars.members.length;
            var hasArgsDef = false;
            for(var i = 0; i < len; i++) {
                var local = vars.members[i];
                if (((local.sym == null) || (local.sym.kind() != 2 /* Field */ ))) {
                    var result = null;
                    if ((result = table.lookup(local.id.text)) == null) {
                        var localVar = new TypeScript.ValueLocation();
                        localVar.typeLink = new TypeScript.TypeLink();
                        var varSym = null;
                        if (TypeScript.hasFlag(local.varFlags, 16 /* Static */ )) {
                            local.varFlags |= 32 /* LocalStatic */ ;
                            varSym = new TypeScript.FieldSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, true, localVar);
                        } else {
                            varSym = new TypeScript.VariableSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, localVar);
                        }
                        varSym.transferVarFlags(local.varFlags);
                        localVar.symbol = varSym;
                        varSym.declAST = local;
                        localVar.typeLink.ast = local.typeExpr;
                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);
                        if ((local.type == null) && (local.init == null)) {
                            local.type = this.anyType;
                        }
                        localVar.typeLink.type = local.type;
                        localVar.symbol.container = container;
                        local.sym = localVar.symbol;
                        table.add(local.id.text, varSym);
                        if (local.id.text == "arguments") {
                            hasArgsDef = true;
                        }
                    } else {
                        local.type = result.getType();
                        local.sym = result;
                    }
                }
            }
            if (!isModContainer) {
                if (!hasArgsDef) {
                    var argLoc = new TypeScript.ValueLocation();
                    argLoc.typeLink = new TypeScript.TypeLink();
                    var theArgSym = new TypeScript.VariableSymbol("arguments", vars.minChar, this.checker.locationInfo.unitIndex, argLoc);
                    if (!this.iargumentsInterfaceType) {
                        var argumentsSym = scope.find("IArguments", false, true);
                        if (argumentsSym) {
                            argumentsSym.flags |= 524288 /* CompilerGenerated */ ;
                            this.iargumentsInterfaceType = argumentsSym.getType();
                        } else {
                            this.iargumentsInterfaceType = this.anyType;
                        }
                    }
                    argLoc.typeLink.type = this.iargumentsInterfaceType;
                    table.add("arguments", theArgSym);
                }
            }
        };
        TypeFlow.prototype.addConstructorLocalArgs = function (constructorDecl, table, isClass) {
            var container = constructorDecl.type.symbol;
            var args = constructorDecl.arguments;
            if (args) {
                var len = args.members.length;
                for(var i = 0; i < len; i++) {
                    var local = args.members[i];
                    if ((local.sym == null) || (isClass || (local.sym.kind() != 2 /* Field */ ))) {
                        var result = null;
                        if ((result = table.lookup(local.id.text)) == null) {
                            this.resolveBoundDecl(local);
                            var localVar = new TypeScript.ValueLocation();
                            localVar.typeLink = new TypeScript.TypeLink();
                            var varSym = new TypeScript.ParameterSymbol(local.id.text, local.minChar, this.checker.locationInfo.unitIndex, localVar);
                            varSym.funcDecl = constructorDecl;
                            varSym.declAST = local;
                            localVar.symbol = varSym;
                            localVar.typeLink.type = local.type;
                            localVar.symbol.container = container;
                            local.sym = localVar.symbol;
                            table.add(local.id.text, varSym);
                        } else {
                            local.type = result.getType();
                            local.sym = result;
                        }
                    }
                }
            }
        };
        TypeFlow.prototype.checkInitSelf = function (funcDecl) {
            if (!funcDecl.isMethod()) {
                var freeVars = funcDecl.freeVariables;
                for(var k = 0, len = freeVars.length; k < len; k++) {
                    var sym = freeVars[k];
                    if (sym.isInstanceProperty()) {
                        return true;
                    }
                }
            }
            var fns = funcDecl.scopes;
            var fnsLen = fns.members.length;
            for(var j = 0; j < fnsLen; j++) {
                var fn = fns.members[j];
                if (this.checkInitSelf(fn)) {
                    return true;
                }
            }
            return false;
        };
        TypeFlow.prototype.checkPromoteFreeVars = function (funcDecl, constructorSym) {
            var freeVars = funcDecl.freeVariables;
            for(var k = 0, len = freeVars.length; k < len; k++) {
                var sym = freeVars[k];
                if ((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {
                    TypeScript.instanceFilter.reset();
                    if (this.scope.search(TypeScript.instanceFilter, sym.name, false, false)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variable shadows class property '" + sym.name + "'. To access the class property, use 'self." + sym.name + "'");
                    }
                    this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '" + sym.name + "' to a class property");
                }
            }
        };
        TypeFlow.prototype.allReturnsAreVoid = function (funcDecl) {
            var allReturnsAreVoid = true;
            if (funcDecl.signature.returnType.type == null) {
                var preFindReturnExpressionTypes = function (ast, parent, walker) {
                    var go = true;
                    switch(ast.nodeType) {
                        case 73 /* FuncDecl */ :
                            go = false;
                            break;
                        case 77 /* Return */ :
                            var returnStmt = ast;
                            if (returnStmt.returnExpression) {
                                allReturnsAreVoid = false;
                                go = false;
                            }
                        default:
                            break;
                    }
                    walker.options.goChildren = go;
                    walker.options.goNextSibling = go;
                    return ast;
                };
                TypeScript.getAstWalkerFactory().walk(funcDecl.bod, preFindReturnExpressionTypes);
            }
            return allReturnsAreVoid;
        };
        TypeFlow.prototype.classConstructorHasSuperCall = function (funcDecl) {
            var foundSuper = false;
            var preFindSuperCall = function (ast, parent, walker) {
                var go = true;
                switch(ast.nodeType) {
                    case 73 /* FuncDecl */ :
                        go = false;
                        break;
                    case 30 /* Call */ :
                        var call = ast;
                        if (call.target.nodeType == 6 /* Super */ ) {
                            go = false;
                            foundSuper = true;
                            break;
                        }
                        break;
                    default:
                        break;
                }
                walker.options.goChildren = go;
                return ast;
            };
            TypeScript.getAstWalkerFactory().walk(funcDecl.bod, preFindSuperCall);
            return foundSuper;
        };
        TypeFlow.prototype.baseListPrivacyErrorReporter = function (bases, i, declSymbol, extendsList, typeName, isModuleName) {
            var baseSymbol = bases.members[i].type.symbol;
            var declTypeString = (declSymbol.declAST.nodeType == 97 /* InterfaceDeclaration */ ) ? "interface" : "class";
            var baseListTypeString = extendsList ? "extends" : "implements";
            var baseTypeString = (baseSymbol.declAST.nodeType == 97 /* InterfaceDeclaration */ ) ? "interface" : "class";
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!TypeScript.isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module ";
                baseTypeString = " " + baseTypeString + " from private module " + quotestring + typeName + quotestring;
            } else {
                baseTypeString = " private " + baseTypeString + " '" + typeName + "'";
            }
            this.checker.errorReporter.simpleError(bases.members[i], "exported " + declTypeString + " '" + declSymbol.name + "' " + baseListTypeString + baseTypeString);
        };
        TypeFlow.prototype.typeCheckBaseListPrivacy = function (bases, declSymbol, extendsList) {
            var _this = this;
            if (bases) {
                var basesLen = bases.members.length;
                for(var i = 0; i < basesLen; i++) {
                    if (!bases.members[i].type || bases.members[i].type == this.checker.anyType) {
                        continue;
                    }
                    this.checkSymbolPrivacy(bases.members[i].type.symbol, declSymbol, function (typeName, isModuleName) {
                        return _this.baseListPrivacyErrorReporter(bases, i, declSymbol, extendsList, typeName, isModuleName);
                    });
                }
            }
        };
        TypeFlow.prototype.checkSymbolPrivacy = function (typeSymbol, declSymbol, errorCallback) {
            var externalModuleSymbol = null;
            var declSymbolPath = null;
            if (typeSymbol.isExternallyVisible(this.checker)) {
                var typeSymbolPath = typeSymbol.pathToRoot();
                declSymbolPath = declSymbol.pathToRoot();
                var typeSymbolLength = typeSymbolPath.length;
                var declSymbolPathLength = declSymbolPath.length;
                if (typeSymbolLength > 0) {
                    if (typeSymbolPath[typeSymbolLength - 1].getType().isModuleType() && (typeSymbolPath[typeSymbolLength - 1]).isDynamic && typeSymbolPath[typeSymbolLength - 1] != declSymbolPath[declSymbolPathLength - 1]) {
                        externalModuleSymbol = typeSymbolPath[typeSymbolLength - 1];
                    } else if (typeSymbolLength > 1) {
                        if (typeSymbolPath[typeSymbolLength - 2].getType().isModuleType() && (typeSymbolPath[typeSymbolLength - 2]).isDynamic && (declSymbolPathLength == 1 || typeSymbolPath[typeSymbolLength - 2] != declSymbolPath[declSymbolPathLength - 2])) {
                            externalModuleSymbol = typeSymbolPath[typeSymbolLength - 2];
                        }
                    }
                }
                if (externalModuleSymbol == null) {
                    return;
                }
            }
            var interfaceDecl = declSymbol.getInterfaceDeclFromSymbol(this.checker);
            if (interfaceDecl && !TypeScript.hasFlag(interfaceDecl.varFlags, 1 /* Exported */ )) {
                return;
            }
            var checkVisibilitySymbol = declSymbol;
            var varDecl = declSymbol.getVarDeclFromSymbol();
            if (varDecl) {
                if (TypeScript.hasFlag(varDecl.varFlags, 2 /* Private */ )) {
                    return;
                } else if (TypeScript.hasFlag(varDecl.varFlags, 4 /* Public */ )) {
                    checkVisibilitySymbol = declSymbol.container;
                }
            }
            if (checkVisibilitySymbol.isExternallyVisible(this.checker)) {
                var privateSymbolName = typeSymbol.name;
                if (externalModuleSymbol != null) {
                    var prettyName = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);
                    if (prettyName != null) {
                        this.currentScript.AddExternallyVisibleImportedSymbol(prettyName.symbol, this.checker);
                        return;
                    } else {
                        privateSymbolName = externalModuleSymbol.prettyName;
                    }
                }
                errorCallback(privateSymbolName, typeSymbol.name != privateSymbolName);
            }
        };
        TypeFlow.prototype.checkTypePrivacy = function (type, declSymbol, errorCallback) {
            var _this = this;
            if (!(type && type.primitiveTypeClass == 0 /* None */ )) {
                return;
            }
            if (type.isArray()) {
                return this.checkTypePrivacy(type.elementType, declSymbol, errorCallback);
            }
            if (type.symbol && type.symbol.name && type.symbol.name != "_anonymous" && (((type.call == null) && (type.construct == null) && (type.index == null)) || (type.members && (!type.isClass())))) {
                return this.checkSymbolPrivacy(type.symbol, declSymbol, errorCallback);
            }
            if (type.members) {
                type.members.allMembers.map(function (key, s, unused) {
                    var sym = s;
                    if (!TypeScript.hasFlag(sym.flags, 8192 /* BuiltIn */ )) {
                        _this.checkTypePrivacy(sym.getType(), declSymbol, errorCallback);
                    }
                }, null);
            }
            this.checkSignatureGroupPrivacy(type.call, declSymbol, errorCallback);
            this.checkSignatureGroupPrivacy(type.construct, declSymbol, errorCallback);
            this.checkSignatureGroupPrivacy(type.index, declSymbol, errorCallback);
        };
        TypeFlow.prototype.checkSignatureGroupPrivacy = function (sgroup, declSymbol, errorCallback) {
            if (sgroup) {
                var len = sgroup.signatures.length;
                for(var i = 0; i < sgroup.signatures.length; i++) {
                    var signature = sgroup.signatures[i];
                    if (len > 1 && signature == sgroup.definitionSignature) {
                        continue;
                    }
                    if (signature.returnType) {
                        this.checkTypePrivacy(signature.returnType.type, declSymbol, errorCallback);
                    }
                    var paramLen = signature.parameters.length;
                    for(var j = 0; j < paramLen; j++) {
                        var param = signature.parameters[j];
                        this.checkTypePrivacy(param.getType(), declSymbol, errorCallback);
                    }
                }
            }
        };
        TypeFlow.prototype.functionArgumentPrivacyErrorReporter = function (funcDecl, p, paramSymbol, typeName, isModuleName) {
            var isGetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ );
            var isSetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.fncFlags, 128 /* SetAccessor */ );
            var isPublicFunc = TypeScript.hasFlag(funcDecl.fncFlags, 4 /* Public */ );
            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!TypeScript.isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }
            if (!isContainerInterface) {
                if (funcDecl.isConstructor) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported class's constructor parameter '" + paramSymbol.name + "'" + typestring);
                } else if (isSetter) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " setter parameter '" + paramSymbol.name + "'" + typestring);
                } else if (!isGetter) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " function parameter '" + paramSymbol.name + "'" + typestring);
                }
            } else {
                if (funcDecl.isConstructMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's constructor parameter '" + paramSymbol.name + "'" + typestring);
                } else if (funcDecl.isCallMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's call parameter '" + paramSymbol.name + "'" + typestring);
                } else if (!funcDecl.isIndexerMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's function parameter '" + paramSymbol.name + "'" + typestring);
                }
            }
        };
        TypeFlow.prototype.returnTypePrivacyError = function (astError, funcDecl, typeName, isModuleName) {
            var isGetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ );
            var isSetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.fncFlags, 128 /* SetAccessor */ );
            var isPublicFunc = TypeScript.hasFlag(funcDecl.fncFlags, 4 /* Public */ );
            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!TypeScript.isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }
            if (!isContainerInterface) {
                if (isGetter) {
                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " getter return type" + typestring);
                } else if (!isSetter) {
                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " function return type" + typestring);
                }
            } else {
                if (funcDecl.isConstructMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's constructor return type" + typestring);
                } else if (funcDecl.isCallMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's call return type" + typestring);
                } else if (funcDecl.isIndexerMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's indexer return type" + typestring);
                } else {
                    this.checker.errorReporter.simpleError(astError, "exported interface's function return type" + typestring);
                }
            }
        };
        TypeFlow.prototype.functionReturnTypePrivacyErrorReporter = function (funcDecl, signature, typeName, isModuleName) {
            var reportOnFuncDecl = false;
            if (funcDecl.returnTypeAnnotation != null && funcDecl.returnTypeAnnotation.type == signature.returnType.type) {
                this.returnTypePrivacyError(funcDecl.returnTypeAnnotation, funcDecl, typeName, isModuleName);
            }
            for(var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {
                if (funcDecl.returnStatementsWithExpressions[i].type == signature.returnType.type) {
                    this.returnTypePrivacyError(funcDecl.returnStatementsWithExpressions[i], funcDecl, typeName, isModuleName);
                } else {
                    reportOnFuncDecl = true;
                }
            }
            if (reportOnFuncDecl) {
                this.returnTypePrivacyError(funcDecl, funcDecl, typeName, isModuleName);
            }
        };
        TypeFlow.prototype.typeCheckFunction = function (funcDecl) {
            var _this = this;
            this.nestingLevel = 0;
            var fnType = funcDecl.type;
            var fgSym = fnType.symbol;
            var signature = funcDecl.signature;
            if (this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {
                return funcDecl;
            } else if (signature.typeCheckStatus == 1 /* Started */ ) {
                if (!funcDecl.returnTypeAnnotation && funcDecl.bod && !funcDecl.isSignature() && !(funcDecl.isConstructor) && this.allReturnsAreVoid(funcDecl)) {
                    signature.returnType.type = this.voidType;
                    return funcDecl;
                } else {
                    if (funcDecl.returnTypeAnnotation == null) {
                        if (this.checker.styleSettings.implicitAny) {
                            this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'");
                        }
                        signature.returnType.type = this.anyType;
                        fgSym.flags |= 131072 /* RecursivelyReferenced */ ;
                    }
                    return funcDecl;
                }
            }
            signature.typeCheckStatus = 1 /* Started */ ;
            this.checker.addStartedPTO(signature);
            var prevScope = this.scope;
            var prevFnc = this.thisFnc;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var prevClassNode = this.thisClassNode;
            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;
            this.thisFnc = funcDecl;
            var container = funcDecl.type.symbol;
            var prevThisType = this.thisType;
            var prevLocationInfo = this.checker.locationInfo;
            var funcTable = null;
            var acceptedContextualType = false;
            var targetParams = null;
            var targetReturnType = null;
            var isGetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ );
            var isSetter = funcDecl.isAccessor() && TypeScript.hasFlag(funcDecl.fncFlags, 128 /* SetAccessor */ );
            var accessorType = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;
            var prevModDecl = this.checker.currentModDecl;
            if (funcDecl.isConstructor && !funcDecl.isOverload) {
                if (fnType.instanceType == null) {
                    this.checker.errorReporter.simpleError(funcDecl, "Malformed function body (is this a class named the same as an existing interface?)");
                    return funcDecl;
                }
                if (funcDecl.classDecl.type.construct == null) {
                    this.checker.errorReporter.simpleError(funcDecl, "Malformed constructor (is this a class named the same as an existing class?)");
                    return funcDecl;
                }
                this.scope = fnType.instanceType.constructorScope;
                var ssb = this.scope;
                funcTable = ssb.valueMembers.allMembers;
            } else if ((funcDecl.isSpecialFn() && !(funcDecl.fncFlags & 512 /* Signature */ )) || funcDecl.isOverload) {
                funcTable = funcDecl.symbols;
                if (!TypeScript.hasFlag(funcDecl.fncFlags, 16 /* Static */ ) && fnType.containedScope) {
                    this.scope = fnType.containedScope;
                }
            } else {
                if (funcDecl.bod) {
                    this.scope = fnType.containedScope;
                }
                var ssb = this.scope;
                if (ssb && ssb.valueMembers) {
                    funcTable = ssb.valueMembers.allMembers;
                }
            }
            if (funcDecl.isConstructor && funcDecl.bod && TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) {
                var hasBaseType = TypeScript.hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, 32 /* HasBaseType */ );
                var noSuperCallAllowed = !hasBaseType || TypeScript.hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, 64 /* HasBaseTypeOfObject */ );
                var superCallMustBeFirst = TypeScript.hasFlag((funcDecl.classDecl).varFlags, 32768 /* ClassSuperMustBeFirstCallInConstructor */ );
                if (noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {
                    this.checker.errorReporter.simpleError(funcDecl, "Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class");
                } else if (hasBaseType) {
                    if (superCallMustBeFirst) {
                        if (!funcDecl.bod || !funcDecl.bod.members.length || !((funcDecl.bod.members[0].nodeType == 30 /* Call */  && (funcDecl.bod.members[0]).target.nodeType == 6 /* Super */ ) || (TypeScript.hasFlag(funcDecl.bod.flags, 128 /* StrictMode */ ) && funcDecl.bod.members.length > 1 && funcDecl.bod.members[1].nodeType == 30 /* Call */  && (funcDecl.bod.members[1]).target.nodeType == 6 /* Super */ ))) {
                            this.checker.errorReporter.simpleError(funcDecl, "If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor");
                        }
                    } else if (!this.classConstructorHasSuperCall(funcDecl)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Constructors for derived classes must contain a call to the class's 'super' constructor");
                    }
                }
            }
            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {
                var enclosingClassNode = null;
                if (funcDecl.type.enclosingType.symbol.declAST.nodeType == 73 /* FuncDecl */ ) {
                    enclosingClassNode = (funcDecl.type.enclosingType.symbol.declAST).classDecl;
                } else if (funcDecl.type.enclosingType.symbol.declAST.nodeType == 96 /* ClassDeclaration */ ) {
                    enclosingClassNode = funcDecl.type.enclosingType.symbol.declAST;
                }
                if (enclosingClassNode) {
                    this.thisClassNode = enclosingClassNode;
                }
            }
            if (fnType.enclosingType) {
                ;
                var enclosingSym = fnType.symbol.container;
                if (enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {
                    enclosingSym = enclosingSym.container;
                }
                if (enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType == 98 /* ModuleDeclaration */ ) {
                    this.checker.currentModDecl = enclosingSym.declAST;
                }
            }
            if (funcDecl.unitIndex > 0) {
                if (this.checker.units && (funcDecl.unitIndex < this.checker.units.length)) {
                    this.checker.locationInfo = this.checker.units[funcDecl.unitIndex];
                } else {
                    this.checker.locationInfo = TypeScript.unknownLocationInfo;
                }
            }
            if (fnType.enclosingType) {
                this.thisType = fnType.enclosingType;
            } else {
                this.thisType = prevThisType;
            }
            var paramLen = signature.parameters.length;
            if (!funcDecl.isConstructor && funcDecl.bod && !funcDecl.isSignature()) {
                var tmpParamScope = this.scope;
                var ssb = this.scope;
                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {
                    if (prevScope && funcDecl.name && !funcDecl.name.isMissing()) {
                        var considerSym = prevScope.findAmbient(funcDecl.name.text, false, false);
                        if (considerSym && considerSym.declAST && considerSym.declAST.type) {
                            this.checker.setContextualType(considerSym.declAST.type, false);
                        }
                    }
                    if (this.checker.hasTargetType()) {
                        var candidateTypeContext = this.checker.getTargetTypeContext();
                        var candidateType = candidateTypeContext.contextualType;
                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {
                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;
                            candidateTypeContext.targetSig = candidateSigs.signatures[0];
                            var candidateParams = candidateTypeContext.targetSig.parameters;
                            targetParams = candidateParams;
                            targetReturnType = candidateTypeContext.targetSig.returnType.type;
                            fgSym.type = candidateTypeContext.contextualType;
                            acceptedContextualType = true;
                        } else if (candidateType && funcDecl.isAccessor()) {
                            accessorType = candidateType;
                            candidateTypeContext.targetAccessorType = accessorType;
                        } else {
                            this.checker.killCurrentContextualType();
                        }
                    }
                }
                var paramTable = ssb.valueMembers;
                this.scope = new TypeScript.SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);
                for(var p = 0; p < paramLen; p++) {
                    var symbol = signature.parameters[p];
                    var ast = symbol.declAST;
                    if (this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {
                        var candidateTypeContext = this.checker.getTargetTypeContext();
                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;
                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();
                        ast.sym.setType(ast.type);
                        (ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                    } else {
                        this.typeCheck(ast);
                    }
                    if (isSetter && accessorType) {
                        ast = this.cast(ast, accessorType);
                    }
                    symbol.container = container;
                    this.checkTypePrivacy(symbol.getType(), container, function (typeName, isModuleName) {
                        return _this.functionArgumentPrivacyErrorReporter(funcDecl, p, symbol, typeName, isModuleName);
                    });
                    paramTable.publicMembers.add(symbol.name, symbol);
                }
                this.scope = tmpParamScope;
            } else {
                this.typeCheck(funcDecl.arguments);
                for(var p = 0; p < paramLen; p++) {
                    signature.parameters[p].parameter.typeLink.type = funcDecl.arguments.members[p].type;
                    this.checkTypePrivacy(signature.parameters[p].getType(), container, function (typeName, isModuleName) {
                        return _this.functionArgumentPrivacyErrorReporter(funcDecl, p, signature.parameters[p], typeName, isModuleName);
                    });
                    if ((funcDecl.arguments.members[p]).parameterPropertySym) {
                        (funcDecl.arguments.members[p]).parameterPropertySym.setType(funcDecl.arguments.members[p].type);
                    }
                }
                if ((funcDecl.fncFlags & 65536 /* IndexerMember */ )) {
                    if (!paramLen || paramLen > 1) {
                        this.checker.errorReporter.simpleError(funcDecl, "Index signatures may take one and only one parameter");
                    } else if (funcDecl.arguments.members[0].type == this.checker.numberType) {
                        fnType.index.flags |= 4 /* IsNumberIndexer */ ;
                    } else if (funcDecl.arguments.members[0].type == this.checker.stringType) {
                        fnType.index.flags |= 2 /* IsStringIndexer */ ;
                    } else {
                        this.checker.errorReporter.simpleError(funcDecl.arguments.members[0], "Index signatures may only take 'string' or 'number' as their parameter");
                    }
                }
            }
            if (funcDecl.bod && (!funcDecl.isSignature())) {
                if (!(funcDecl.isConstructor)) {
                    this.addFormals(container, signature, funcTable);
                } else {
                    this.addConstructorLocalArgs(funcDecl, funcTable, TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ ));
                    if (this.thisClassNode && this.thisClassNode.extendsList) {
                        var tmpScope = this.scope;
                        var funcMembers = new TypeScript.ScopedMembers(funcTable);
                        this.scope = new TypeScript.FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol, function (sym) {
                            return sym.kind() == 3 /* Parameter */ ;
                        });
                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);
                        this.scope = tmpScope;
                    }
                }
                var prevMod = this.checker.currentModDecl;
                if (funcDecl.type && funcDecl.type.symbol && !funcDecl.isMethod() && funcDecl.type.symbol.declModule) {
                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;
                }
                if (acceptedContextualType) {
                    this.checker.setContextualType(null, this.checker.inProvisionalTypecheckMode());
                }
                this.typeCheck(funcDecl.bod);
                if (acceptedContextualType) {
                    this.checker.unsetContextualType();
                }
                this.checker.currentModDecl = prevMod;
                if (this.checker.checkControlFlow) {
                    var cfg = funcDecl.buildControlFlow();
                    if (this.checker.printControlFlowGraph) {
                        cfg.print(this.checker.errorReporter.outfile);
                    }
                    cfg.reportUnreachable(this.checker.errorReporter);
                    if (this.checker.checkControlFlowUseDef) {
                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);
                    }
                }
                if (funcDecl.isConstructor) {
                    var fns = funcDecl.scopes;
                    var fnsLen = fns.members.length;
                    var freeVars;
                    var sym;
                    var j = 0;
                    for(; j < fnsLen; j++) {
                        var fn = fns.members[j];
                        if (!fn.isSignature()) {
                            if (TypeScript.hasFlag(fn.fncFlags, 1024 /* Method */ ) && (!TypeScript.hasFlag(fn.fncFlags, 16 /* Static */ ))) {
                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);
                            }
                        }
                    }
                }
            }
            this.scope = prevScope;
            this.thisFnc = prevFnc;
            this.thisClassNode = prevClassNode;
            this.enclosingFncIsMethod = prevMethodStatus;
            this.thisType = prevThisType;
            this.checker.locationInfo = prevLocationInfo;
            this.checker.currentModDecl = prevModDecl;
            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
            if (funcDecl.returnTypeAnnotation) {
                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);
                if (signature.returnType.type == null) {
                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);
                }
            } else if (targetReturnType) {
                signature.returnType.type = targetReturnType;
            }
            if (!(fgSym.flags & 131072 /* RecursivelyReferenced */ ) && funcDecl.returnStatementsWithExpressions.length > 0) {
                var collection = {
                    getLength: function () {
                        return funcDecl.returnStatementsWithExpressions.length;
                    },
                    setTypeAtIndex: function (index, type) {
                        funcDecl.returnStatementsWithExpressions[index].type = type;
                    },
                    getTypeAtIndex: function (index) {
                        return funcDecl.returnStatementsWithExpressions[index].type;
                    }
                };
                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;
                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection, true);
                if (bestCommonReturnType) {
                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);
                } else {
                    for(var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {
                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], "Incompatible return type");
                    }
                    signature.returnType.type = this.anyType;
                }
            }
            var onlyHasThrow = false;
            if (signature.returnType.type == null) {
                if (TypeScript.hasFlag(funcDecl.fncFlags, 2048 /* HasReturnExpression */ )) {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'");
                    }
                    signature.returnType.type = this.anyType;
                } else {
                    signature.returnType.type = this.voidType;
                }
            } else if (signature.returnType.type == this.nullType || signature.returnType.type == this.checker.undefinedType) {
                signature.returnType.type = this.anyType;
            } else if ((signature.returnType.type != this.voidType && signature.returnType.type != this.checker.undefinedType && signature.returnType.type != this.anyType)) {
                if (!funcDecl.isSignature() && !funcDecl.isConstructor && !TypeScript.hasFlag(funcDecl.fncFlags, 2048 /* HasReturnExpression */ ) && !TypeScript.hasFlag(funcDecl.fncFlags, 32768 /* IsFatArrowFunction */ )) {
                    onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == 80 /* Throw */ );
                    if (!onlyHasThrow) {
                        this.checker.errorReporter.simpleError(funcDecl.returnTypeAnnotation || funcDecl, "Function declared a non-void return type, but has no return expression");
                    }
                }
                this.checkTypePrivacy(signature.returnType.type, container, function (typeName, isModuleName) {
                    return _this.functionReturnTypePrivacyErrorReporter(funcDecl, signature, typeName, isModuleName);
                });
            }
            if (funcDecl.accessorSymbol) {
                var accessorType = funcDecl.accessorSymbol.getType();
                if (!onlyHasThrow && TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ ) && !TypeScript.hasFlag(funcDecl.fncFlags, 2048 /* HasReturnExpression */ )) {
                    this.checker.errorReporter.simpleError(funcDecl, "Getters must return a value");
                }
                if (accessorType) {
                    if ((TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ ) && accessorType != signature.returnType.type) || (funcDecl.arguments.members.length > 0 && accessorType != funcDecl.arguments.members[0].type)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Getter and setter types do not agree");
                    }
                } else {
                    if (TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ )) {
                        funcDecl.accessorSymbol.setType(signature.returnType.type);
                    } else {
                        if (funcDecl.arguments.members.length != 1) {
                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument");
                        } else {
                            funcDecl.accessorSymbol.setType(funcDecl.arguments.members[0].type);
                        }
                    }
                }
            }
            this.typeCheckOverloadSignatures(fnType, funcDecl);
            return funcDecl;
        };
        TypeFlow.prototype.typeCheckBases = function (type) {
            var seenInterface = false;
            var bases = type.extendsList;
            var baseLinks = type.extendsTypeLinks;
            if (bases) {
                var len = bases.length;
                if (len > 0) {
                    type.typeFlags |= 32 /* HasBaseType */ ;
                }
                for(var i = 0; i < len; i++) {
                    if (bases[i] == this.checker.anyType) {
                        baseLinks[i].type = null;
                        var oldErrors = this.checker.errorReporter.getCapturedErrors();
                        TypeScript.CompilerDiagnostics.assert(oldErrors.length == 0, "There shouldnt be any contextual errors when typechecking base type names");
                        this.checker.errorReporter.pushToErrorSink = true;
                        bases[i] = this.checker.resolveBaseTypeLink(baseLinks[i], type.containedScope);
                        this.checker.errorReporter.pushToErrorSink = false;
                        this.checker.errorReporter.freeCapturedErrors();
                    }
                    var base = bases[i];
                    var baseRef = baseLinks[i].ast;
                    var baseTypeOfObject = base.symbol && base.symbol.name == "Object" && base.symbol.container == this.checker.gloMod;
                    if (baseTypeOfObject) {
                        type.typeFlags |= 64 /* HasBaseTypeOfObject */ ;
                    }
                    if (base.isClassInstance()) {
                        if (!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");
                        } else {
                            if (seenInterface) {
                                this.checker.errorReporter.simpleError(baseRef, "Class may not follow interface as base type");
                            }
                        }
                    } else if (base.isModuleType()) {
                        this.checker.errorReporter.simpleError(baseRef, "Types may not be derived from module types");
                    } else if (base.members) {
                        if (!seenInterface) {
                            seenInterface = true;
                        }
                    } else {
                        if (!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");
                        } else {
                            this.checker.errorReporter.simpleError(baseRef, "Base type must be interface or class");
                        }
                        break;
                    }
                }
            }
        };
        TypeFlow.prototype.checkMembersImplementInterfaces = function (implementingType) {
            var instanceType = implementingType.getInstanceType();
            if (instanceType.implementsList) {
                var len = instanceType.implementsList.length;
                for(var i = 0; i < len; i++) {
                    var interfaceType = instanceType.implementsList[i];
                    var comparisonInfo = new TypeScript.TypeComparisonInfo();
                    if (!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {
                        var emsg = "Class '" + instanceType.getTypeName() + "' declares interface '" + interfaceType.getTypeName() + "' but does not implement it";
                        if (!comparisonInfo.message) {
                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);
                        } else {
                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + ": " + comparisonInfo.message);
                        }
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckBaseCalls = function (bases) {
            if (bases == null) {
                return;
            }
            var basesLen = bases.members.length;
            for(var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol = null;
                if (baseExpr.nodeType == 30 /* Call */ ) {
                    this.typeCheckNew(baseExpr);
                }
            }
        };
        TypeFlow.prototype.assertUniqueNamesInBaseTypes = function (names, type, classDecl, checkUnique) {
            var _this = this;
            if (type) {
                if (type.members) {
                    type.members.publicMembers.map(function (key, s, c) {
                        var sym = s;
                        var dup = names.lookup(sym.name);
                        if (dup) {
                            if (checkUnique) {
                                _this.checker.errorReporter.simpleError(classDecl, "duplicate member name in bases for " + classDecl.name.actualText + ": " + type.symbol.name + " and " + dup.container.name + " both contain member with name " + sym.name);
                            }
                        } else {
                            names.add(sym.name, sym);
                        }
                    }, null);
                }
                if (type.extendsList) {
                    var len = type.extendsList.length;
                    for(var i = 0; i < len; i++) {
                        if (!(type.extendsList[i].symbol.flags & 131072 /* RecursivelyReferenced */ )) {
                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);
                        }
                    }
                }
            }
        };
        TypeFlow.prototype.checkBaseTypeMemberInheritance = function (derivedType, derivedTypeDecl) {
            var _this = this;
            var instanceType = derivedType.getInstanceType();
            if (instanceType.extendsList == null) {
                return;
            }
            var len = instanceType.extendsList.length;
            if (len > 0) {
                var names = new TypeScript.StringHashTable();
                if (instanceType.isClassInstance()) {
                    for(var i = 0; i < len; i++) {
                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], derivedTypeDecl, i > 0);
                    }
                }
                if (instanceType.members) {
                    instanceType.members.publicMembers.map(function (key, s, c) {
                        var sym = s;
                        for(var j = 0; j < len; j++) {
                            var base = instanceType.extendsList[j];
                            if (base.memberScope == null) {
                                _this.checker.errorReporter.simpleError(derivedTypeDecl, "Base type '" + base.symbol.name + "' lacks an implementation.");
                            } else {
                                var bSym = base.memberScope.find(sym.name, false, false);
                                if (bSym) {
                                    var aType = sym.getType();
                                    var bType = bSym.getType();
                                    if (!(_this.checker.sourceIsSubtypeOfTarget(aType, bType))) {
                                        _this.checker.errorReporter.simpleErrorFromSym(sym, "Type of overridden member '" + sym.name + "' is not subtype of original member defined by type '" + bSym.container.name + "'");
                                    } else if ((sym.kind() == 1 /* Type */ ) && (bSym.kind() == 2 /* Field */ )) {
                                        _this.checker.errorReporter.simpleErrorFromSym(sym, "Cannot override field '" + sym.name + "' with method");
                                    }
                                }
                            }
                        }
                    }, null);
                }
            }
        };
        TypeFlow.prototype.typeCheckClass = function (classDecl) {
            var typeSymbol = classDecl.type.symbol;
            if (typeSymbol.typeCheckStatus == 2 /* Finished */ ) {
                return classDecl;
            } else if (typeSymbol.typeCheckStatus == 1 /* Started */ ) {
                return classDecl;
            } else {
                typeSymbol.typeCheckStatus = 1 /* Started */ ;
                this.checker.addStartedPTO(typeSymbol);
            }
            var prevScope = this.scope;
            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var classType = classDecl.type;
            this.typeCheckBases(classType.instanceType);
            this.typeCheckBaseListPrivacy(classDecl.extendsList, typeSymbol, true);
            this.typeCheckBaseListPrivacy(classDecl.implementsList, typeSymbol, false);
            var prevThisType = this.thisType;
            this.thisType = classType.instanceType;
            this.scope = classType.instanceType.containedScope;
            if (classDecl.constructorDecl) {
                this.scope = classType.instanceType.constructorScope;
                var ssb = this.scope;
                var funcTable = ssb.valueMembers.allMembers;
                this.addConstructorLocalArgs(classDecl.constructorDecl, funcTable, true);
            }
            this.typeCheck(classDecl.members);
            typeSymbol.typeCheckStatus = 2 /* Finished */ ;
            this.checkBaseTypeMemberInheritance(classType, classDecl);
            this.checkMembersImplementInterfaces(classType);
            this.typeCheckOverloadSignatures(classType, classDecl);
            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);
            if (!classDecl.constructorDecl) {
                if (classDecl.extendsList && classDecl.extendsList.members.length && classDecl.extendsList.members[0].type && classDecl.extendsList.members[0].type.symbol.type.isClass()) {
                    TypeScript.cloneParentConstructGroupForChildType(classDecl.type, classDecl.extendsList.members[0].type.symbol.type);
                }
            }
            this.thisType = prevThisType;
            this.thisClassNode = svClassNode;
            this.scope = prevScope;
            return classDecl;
        };
        TypeFlow.prototype.typeCheckOverloadSignatures = function (type, ast) {
            if (type.call) {
                type.call.typeCheck(this.checker, ast, type.construct != null);
            }
            if (type.construct) {
                type.construct.typeCheck(this.checker, ast, false);
            }
            if (type.index) {
                type.index.typeCheck(this.checker, ast, false);
            }
        };
        TypeFlow.prototype.typeCheckInterface = function (interfaceDecl) {
            this.typeCheckBases(interfaceDecl.type);
            this.typeCheckBaseListPrivacy(interfaceDecl.extendsList, interfaceDecl.type.symbol, true);
            this.typeCheck(interfaceDecl.members);
            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);
            if (interfaceDecl.extendsList) {
                for(var i = 0; i < interfaceDecl.extendsList.members.length; i++) {
                    if (interfaceDecl.extendsList.members[i].type.call) {
                        if (interfaceDecl.type.call) {
                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);
                        } else {
                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;
                        }
                    }
                    if (interfaceDecl.extendsList.members[i].type.construct) {
                        if (interfaceDecl.type.construct) {
                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);
                        } else {
                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;
                        }
                    }
                    if (interfaceDecl.extendsList.members[i].type.index) {
                        if (interfaceDecl.type.index) {
                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);
                        } else {
                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;
                        }
                    }
                }
            }
            return interfaceDecl;
        };
        TypeFlow.prototype.typeCheckImportDecl = function (importDecl) {
            var mod = importDecl.alias.type;
            var sym = null;
            var prevInImportTC = this.inImportTypeCheck;
            this.inImportTypeCheck = true;
            this.typeCheck(importDecl.alias);
            mod = importDecl.alias.type;
            if (mod == null) {
                this.checker.errorReporter.simpleError(importDecl.alias, "Could not resolve module alias '" + importDecl.id.actualText + "'");
                mod = this.checker.anyType;
                (importDecl.id.sym).type = mod;
            }
            importDecl.id.type = mod;
            sym = mod.symbol;
            if (!mod.isModuleType()) {
                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type");
            } else {
                sym.type = mod;
                if (this.checker.typeFlow.currentScript && this.checker.typeFlow.currentScript.topLevelMod && this.checker.typeFlow.currentScript.topLevelMod.mod) {
                    this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules.push(importDecl);
                }
                (importDecl.id.sym).type = mod;
                if (mod.symbol && mod.symbol.declAST) {
                    (mod.symbol.declAST).modFlags &= ~512 /* ShouldEmitModuleDecl */ ;
                }
            }
            this.inImportTypeCheck = prevInImportTC;
            return importDecl;
        };
        TypeFlow.prototype.typeCheckModule = function (moduleDecl) {
            if (!moduleDecl.mod) {
                return moduleDecl;
            }
            if (this.currentScript) {
                this.currentScript.requiresGlobal = true;
            }
            var mod = moduleDecl.mod;
            var sym = null;
            var prevScope = this.scope;
            var prevThisType = this.thisType;
            var prevCurrentModDecl = this.checker.currentModDecl;
            this.checker.currentModDecl = moduleDecl;
            this.thisType = null;
            this.scope = mod.containedScope;
            this.typeCheck(moduleDecl.members);
            sym = mod.symbol;
            this.checker.currentModDecl = prevCurrentModDecl;
            this.thisType = prevThisType;
            this.scope = prevScope;
            moduleDecl.type = mod;
            if (sym) {
                sym.typeCheckStatus = 2 /* Finished */ ;
            }
            return moduleDecl;
        };
        TypeFlow.prototype.typeCheckFor = function (forStmt) {
            forStmt.init = this.typeCheck(forStmt.init);
            this.nestingLevel++;
            forStmt.cond = this.typeCheck(forStmt.cond);
            this.typeCheckCondExpr(forStmt.cond);
            forStmt.incr = this.typeCheck(forStmt.incr);
            this.nestingLevel--;
            forStmt.body = this.typeCheck(forStmt.body);
            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement");
            forStmt.type = this.voidType;
            return forStmt;
        };
        TypeFlow.prototype.typeCheckWith = function (withStmt) {
            if (this.checker.errorsOnWith) {
                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a 'with' block will be typed as 'any'");
            }
            withStmt.expr = this.typeCheck(withStmt.expr);
            this.checker.inWith = true;
            withStmt.body = this.typeCheck(withStmt.body);
            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement");
            this.checker.inWith = false;
            return withStmt;
        };
        TypeFlow.prototype.typeCheckForIn = function (forInStmt) {
            forInStmt.obj = this.typeCheck(forInStmt.obj);
            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);
            if (forInStmt.lval.nodeType == 75 /* VarDecl */ ) {
                var varDecl = forInStmt.lval;
                if (varDecl.typeExpr) {
                    this.checker.errorReporter.simpleError(varDecl, "Variable declarations for for/in expressions may not contain a type annotation");
                }
                if (varDecl.sym) {
                    varDecl.sym.setType(this.checker.stringType);
                }
            }
            forInStmt.body = this.typeCheck(forInStmt.body);
            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement");
            return forInStmt;
        };
        TypeFlow.prototype.typeCheckWhile = function (whileStmt) {
            whileStmt.cond = this.typeCheck(whileStmt.cond);
            this.typeCheckCondExpr(whileStmt.cond);
            whileStmt.body = this.typeCheck(whileStmt.body);
            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement");
            whileStmt.type = this.voidType;
            return whileStmt;
        };
        TypeFlow.prototype.typeCheckDoWhile = function (doWhileStmt) {
            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);
            this.typeCheckCondExpr(doWhileStmt.cond);
            doWhileStmt.body = this.typeCheck(doWhileStmt.body);
            this.typeCheckCompoundStmtBlock(doWhileStmt.body, "do while statement");
            doWhileStmt.type = this.voidType;
            return doWhileStmt;
        };
        TypeFlow.prototype.typeCheckCondExpr = function (cond) {
            if (this.checker.styleSettings.assignmentInCond) {
                if ((cond !== null) && (cond.nodeType >= 32 /* Asg */ ) && (cond.nodeType <= 43 /* LastAsg */ )) {
                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression");
                }
            }
        };
        TypeFlow.prototype.typeCheckCompoundStmtBlock = function (stmts, stmtType) {
            if (this.checker.styleSettings.blockInCompoundStmt && stmts) {
                if (stmts.nodeType != 86 /* Block */ ) {
                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block");
                }
            }
        };
        TypeFlow.prototype.typeCheckIf = function (ifStmt) {
            ifStmt.cond = this.typeCheck(ifStmt.cond);
            this.typeCheckCondExpr(ifStmt.cond);
            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);
            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);
            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement");
            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement");
            ifStmt.type = this.voidType;
            return ifStmt;
        };
        TypeFlow.prototype.typeFromAccessorFuncDecl = function (funcDecl) {
            if (!funcDecl.isAccessor()) {
                return null;
            }
            if (TypeScript.hasFlag(funcDecl.fncFlags, 64 /* GetAccessor */ )) {
                return funcDecl.type.call.signatures[0].returnType.type;
            } else {
                return funcDecl.type.call.signatures[0].parameters[0].getType();
            }
        };
        TypeFlow.prototype.typeCheckObjectLit = function (objectLit) {
            var resultType = new TypeScript.Type();
            resultType.symbol = new TypeScript.TypeSymbol(this.checker.anon, objectLit.minChar, objectLit.limChar - objectLit.minChar, this.checker.locationInfo.unitIndex, resultType);
            resultType.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
            resultType.memberScope = new TypeScript.SymbolTableScope(resultType.members, null, null, null, null);
            var aggScope = new TypeScript.SymbolAggregateScope(resultType.symbol);
            aggScope.addParentScope(resultType.memberScope);
            aggScope.addParentScope(this.scope);
            resultType.containedScope = aggScope;
            var memberDecls = objectLit.operand;
            var prevThisType = this.thisType;
            var acceptTargetType = false;
            var targetType = null;
            if (this.checker.hasTargetType()) {
                targetType = this.checker.getTargetTypeContext().contextualType;
                if (targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {
                    if (targetType.symbol.declAST) {
                        this.typeCheck(targetType.symbol.declAST);
                    }
                }
                acceptTargetType = true;
            }
            if (memberDecls) {
                for(var i = 0, len = memberDecls.members.length; i < len; i++) {
                    var binex = memberDecls.members[i];
                    var id = binex.operand1;
                    var text;
                    var targetMember = null;
                    var fieldSymbol = null;
                    if (id.nodeType == 25 /* Name */ ) {
                        text = (id).text;
                    } else if (id.nodeType == 7 /* QString */ ) {
                        var idText = (id).text;
                        text = idText.substring(1, idText.length - 1);
                    } else {
                        this.checker.errorReporter.simpleError(objectLit, "malformed object literal");
                        resultType = this.anyType;
                        break;
                    }
                    if (acceptTargetType && targetType.memberScope) {
                        targetMember = targetType.memberScope.find(text, false, false);
                    }
                    if (binex.operand2.nodeType == 73 /* FuncDecl */  && (binex.operand2).isAccessor()) {
                        var funcDecl = binex.operand2;
                        var accessorSym = resultType.members.publicMembers.lookup(text);
                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);
                        funcDecl.accessorSymbol = accessorSym;
                        fieldSymbol = accessorSym;
                        if (id.nodeType == 25 /* Name */ ) {
                            (id).sym = accessorSym;
                        }
                    }
                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);
                    if (acceptTargetType && targetMember) {
                        if ((binex.operand2.type == this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) || (binex.operand2.nodeType == 73 /* FuncDecl */  && (binex.operand2).isAccessor() && this.typeFromAccessorFuncDecl(binex.operand2) == targetMember.getType())) {
                            binex.operand1.type = targetMember.getType();
                        }
                    } else {
                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type;
                    }
                    if (fieldSymbol == null) {
                        var memberType = binex.operand2.type;
                        var field = new TypeScript.ValueLocation();
                        fieldSymbol = new TypeScript.FieldSymbol(text, id.minChar, this.checker.locationInfo.unitIndex, true, field);
                        fieldSymbol.flags |= 256 /* Property */ ;
                        field.symbol = fieldSymbol;
                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                        field.typeLink = new TypeScript.TypeLink();
                        field.typeLink.type = memberType;
                        resultType.members.publicMembers.add(text, fieldSymbol);
                    }
                    fieldSymbol.isObjectLitField = true;
                }
            }
            this.thisType = prevThisType;
            objectLit.type = resultType;
            if (targetType) {
                objectLit.targetType = targetType;
            }
        };
        TypeFlow.prototype.typeCheckArrayLit = function (arrayLit) {
            var elements = arrayLit.operand;
            var elementType = this.anyType;
            var targetElementType = null;
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            comparisonInfo.onlyCaptureFirstError = true;
            if (this.checker.hasTargetType()) {
                var targetType = this.checker.getTargetTypeContext().contextualType;
                if (targetType.elementType) {
                    targetElementType = targetType.elementType;
                }
            }
            if (elements) {
                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;
                this.inArrayElementTypeCheck = true;
                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType != null, elements);
                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;
                elementType = elements.members[0].type;
                var collection = {
                    getLength: function () {
                        return elements.members.length;
                    },
                    setTypeAtIndex: function (index, type) {
                        elements.members[index].type = type;
                    },
                    getTypeAtIndex: function (index) {
                        return elements.members[index].type;
                    }
                };
                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, false, comparisonInfo);
                if (elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {
                    elementType = this.anyType;
                }
            }
            if (!elementType) {
                var emsg = "Incompatible types in array literal expression";
                if (!comparisonInfo.message) {
                    this.checker.errorReporter.simpleError(arrayLit, emsg);
                } else {
                    this.checker.errorReporter.simpleError(arrayLit, emsg + ": " + comparisonInfo.message);
                }
                elementType = this.anyType;
            } else if (targetElementType) {
                if (this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {
                    elementType = targetElementType;
                }
            }
            arrayLit.type = this.checker.makeArrayType(elementType);
        };
        TypeFlow.prototype.checkForVoidConstructor = function (type, ast) {
            if (type && type.construct && type.construct.signatures.length > 0) {
                for(var i = 0; i < type.construct.signatures.length; i++) {
                    if (type.construct.signatures[i].returnType.type == this.checker.voidType) {
                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of 'void'");
                        break;
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckReturn = function (returnStmt) {
            if (this.thisFnc) {
                var targetType = null;
                if (this.checker.hasTargetType()) {
                    var tcContext = this.checker.getTargetTypeContext();
                    var accessorType = tcContext.targetAccessorType;
                    if (accessorType) {
                        targetType = accessorType;
                    } else {
                        var targetSig = this.checker.getTargetTypeContext().targetSig;
                        if (targetSig && targetSig.returnType.type != this.voidType) {
                            targetType = targetSig.returnType.type;
                        }
                    }
                }
                if (returnStmt.returnExpression) {
                    this.thisFnc.fncFlags |= 2048 /* HasReturnExpression */ ;
                    if (targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {
                        targetType = this.thisFnc.returnTypeAnnotation.type;
                    }
                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType != null, returnStmt.returnExpression);
                    var expectedReturnType = (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : targetType;
                    if (expectedReturnType) {
                        if (expectedReturnType == this.voidType && returnStmt.returnExpression.type != this.voidType) {
                            this.checker.errorReporter.simpleError(returnStmt, "Return with value expression in void function");
                            returnStmt.type = returnStmt.returnExpression.type;
                        } else {
                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);
                            returnStmt.type = expectedReturnType;
                        }
                    } else {
                        if (targetType) {
                            if (returnStmt.returnExpression.type != this.voidType) {
                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);
                            } else {
                                returnStmt.returnExpression.type = targetType;
                            }
                        }
                        returnStmt.type = returnStmt.returnExpression.type;
                    }
                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;
                } else {
                    returnStmt.type = targetType == null ? this.checker.voidType : targetType;
                }
            }
            return returnStmt;
        };
        TypeFlow.prototype.typeCheckInstOf = function (ast) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            if (!((binex.operand1.type == this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) && (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {
                this.checker.errorReporter.simpleError(ast, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");
            }
            binex.type = this.booleanType;
            return binex;
        };
        TypeFlow.prototype.typeCheckCommaOperator = function (ast) {
            var binex = ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            binex.type = binex.operand2.type;
            return binex;
        };
        TypeFlow.prototype.typeCheckLogOr = function (binex) {
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if (leftType == this.checker.anyType || rightType == this.checker.anyType) {
                binex.type = this.checker.anyType;
            } else if (leftType == this.checker.booleanType) {
                if (rightType == this.checker.booleanType) {
                    binex.type = this.checker.booleanType;
                } else {
                    binex.type = this.checker.anyType;
                }
            } else if (leftType == this.checker.numberType) {
                if (rightType == this.checker.numberType) {
                    binex.type = this.checker.numberType;
                } else {
                    binex.type = this.checker.anyType;
                }
            } else if (leftType == this.checker.stringType) {
                if (rightType == this.checker.stringType) {
                    binex.type = this.checker.stringType;
                } else {
                    binex.type = this.checker.anyType;
                }
            } else {
                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {
                    binex.type = rightType;
                } else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {
                    binex.type = leftType;
                } else {
                    binex.type = this.checker.anyType;
                }
            }
            return binex;
        };
        TypeFlow.prototype.typeCheckLogAnd = function (binex) {
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            binex.type = binex.operand2.type;
            return binex;
        };
        TypeFlow.prototype.tryAddCandidates = function (signature, actuals, exactCandidates, conversionCandidates, comparisonInfo) {
            var lowerBound = signature.nonOptionalParameterCount;
            var upperBound = signature.parameters.length;
            var formalLen = lowerBound;
            var acceptable = false;
            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);
                acceptable = true;
            }
            var repeatType = null;
            if (acceptable || signature.hasVariableArgList) {
                if (signature.hasVariableArgList) {
                    formalLen -= 1;
                    repeatType = (signature.parameters[formalLen]).parameter.typeLink.type;
                    repeatType = repeatType.elementType;
                    acceptable = actuals.length >= formalLen;
                }
                var len = actuals.length;
                var exact = acceptable;
                var convert = acceptable;
                for(var i = 0; i < len; i++) {
                    var typeA;
                    if (i < formalLen) {
                        typeA = (signature.parameters[i]).parameter.typeLink.type;
                    } else {
                        typeA = repeatType;
                    }
                    var typeB = actuals[i];
                    if (!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {
                        exact = false;
                    }
                    if (!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {
                        convert = false;
                    }
                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                } else if (convert && (exactCandidates.length == 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }
            }
        };
        TypeFlow.prototype.resolveOverload = function (application, group) {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate = null;
            var hasOverloads = group.signatures.length > 1;
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var args = null;
            var target = null;
            if (application.nodeType == 30 /* Call */  || application.nodeType == 31 /* New */ ) {
                var callEx = application;
                args = callEx.arguments;
                target = callEx.target;
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    for(var i = 0; i < len; i++) {
                        actuals[i] = callEx.arguments.members[i].type;
                    }
                }
            } else if (application.nodeType == 29 /* Index */ ) {
                var binExp = application;
                target = binExp.operand1;
                args = new TypeScript.ASTList();
                args.members[0] = binExp.operand2;
                actuals[0] = binExp.operand2.type;
            }
            for(var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {
                var signature = group.signatures[j];
                if (hasOverloads && signature == group.definitionSignature && !this.checker.canCallDefinitionSignature) {
                    continue;
                }
                if (!signature.returnType.type && signature.declAST && (signature.typeCheckStatus != 2 /* Finished */ )) {
                    this.typeCheckFunction(signature.declAST);
                }
                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);
            }
            var apparentTarget = target.nodeType == 19 /* Dot */  ? (target).operand2 : target;
            if (exactCandidates.length == 0) {
                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);
                if (applicableCandidates.length > 0) {
                    var candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);
                    if (candidateInfo.ambiguous) {
                        this.checker.errorReporter.simpleError(apparentTarget, "Ambiguous call expression - could not choose overload");
                    }
                    candidate = candidateInfo.sig;
                } else {
                    var emsg = "Supplied parameters do not match any signature of call target";
                    if (comparisonInfo.message) {
                        this.checker.errorReporter.simpleError(apparentTarget, emsg + ":\n\t" + comparisonInfo.message);
                    } else {
                        this.checker.errorReporter.simpleError(apparentTarget, emsg);
                    }
                }
            } else {
                if (exactCandidates.length > 1) {
                    var applicableSigs = [];
                    for(var i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = {
                            signature: exactCandidates[i],
                            hadProvisionalErrors: false
                        };
                    }
                    var candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);
                    if (candidateInfo.ambiguous) {
                        this.checker.errorReporter.simpleError(apparentTarget, "Ambiguous call expression - could not choose overload");
                    }
                    candidate = candidateInfo.sig;
                } else {
                    candidate = exactCandidates[0];
                }
            }
            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        };
        TypeFlow.prototype.typeCheckNew = function (ast) {
            var callEx = ast;
            callEx.target = this.typeCheck(callEx.target);
            var target = callEx.target;
            if (target.type.construct || target.type.call) {
                this.preTypeCheckCallArgs(callEx.arguments);
            } else {
                callEx.arguments = this.typeCheck(callEx.arguments);
            }
            if (target.type == this.anyType) {
                callEx.type = this.anyType;
                callEx.arguments = this.typeCheck(callEx.arguments);
            } else {
                if (target.type.construct) {
                    var signature = this.resolveOverload(callEx, target.type.construct);
                    if (signature == null) {
                        callEx.type = this.anyType;
                    } else if (signature.returnType.type == this.voidType) {
                        callEx.type = this.anyType;
                        callEx.signature = signature;
                    } else {
                        callEx.type = signature.returnType.type;
                        callEx.signature = signature;
                    }
                } else if (target.type.call) {
                    var signature = this.resolveOverload(callEx, target.type.call);
                    if (signature == null) {
                        callEx.type = this.anyType;
                    } else if ((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {
                        callEx.type = this.anyType;
                        callEx.signature = signature;
                    } else {
                        this.checker.errorReporter.simpleError(callEx.target, "new expression only valid on constructors");
                    }
                } else if (target.type.elementType) {
                    callEx.type = target.type;
                } else {
                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);
                    callEx.type = this.anyType;
                }
            }
            this.postTypeCheckCallArgs(callEx);
            return callEx;
        };
        TypeFlow.prototype.preTypeCheckCallArgs = function (args) {
            if (!args) {
                return;
            }
            for(var i = 0; i < args.members.length; i++) {
                switch(args.members[i].nodeType) {
                    case 73 /* FuncDecl */ :
                    case 11 /* ObjectLit */ :
                    case 10 /* ArrayLit */ :
                        continue;
                    default:
                        this.typeCheck(args.members[i]);
                        break;
                }
            }
        };
        TypeFlow.prototype.postTypeCheckCallArgs = function (callEx) {
            var acceptedTargetType = false;
            var i = 0;
            if (callEx.target && callEx.target.type && callEx.signature && callEx.arguments) {
                var sig = callEx.signature;
                if (sig && callEx.arguments.members.length >= sig.nonOptionalParameterCount) {
                    acceptedTargetType = true;
                    var targetType = null;
                    var nonVarArgFormalParamLength = sig.hasVariableArgList ? sig.parameters.length - 1 : sig.parameters.length;
                    var nonVarArgActualParamLength = callEx.arguments.members.length < nonVarArgFormalParamLength ? callEx.arguments.members.length : nonVarArgFormalParamLength;
                    for(i = 0; i < nonVarArgActualParamLength; i++) {
                        targetType = sig.parameters[i].getType();
                        switch(callEx.arguments.members[i].nodeType) {
                            case 73 /* FuncDecl */ :
                            case 11 /* ObjectLit */ :
                            case 10 /* ArrayLit */ :
                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), !sig.parameters[i].declAST.isParenthesized, callEx.arguments.members[i]);
                                break;
                        }
                    }
                    if (sig.hasVariableArgList) {
                        var varArgParamIndex = sig.nonOptionalParameterCount - 1;
                        targetType = sig.parameters[varArgParamIndex].getType();
                        if (targetType) {
                            targetType = targetType.elementType;
                        }
                        var isParenthesized = !sig.parameters[varArgParamIndex].declAST.isParenthesized;
                        for(i = nonVarArgActualParamLength; i < callEx.arguments.members.length; i++) {
                            switch(callEx.arguments.members[i].nodeType) {
                                case 73 /* FuncDecl */ :
                                case 11 /* ObjectLit */ :
                                case 10 /* ArrayLit */ :
                                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), isParenthesized, callEx.arguments.members[i]);
                                    break;
                            }
                        }
                    }
                }
            }
            if (!acceptedTargetType && callEx.arguments) {
                this.checker.killCurrentContextualType();
                for(i = 0; i < callEx.arguments.members.length; i++) {
                    switch(callEx.arguments.members[i].nodeType) {
                        case 73 /* FuncDecl */ :
                        case 11 /* ObjectLit */ :
                        case 10 /* ArrayLit */ :
                            this.typeCheck(callEx.arguments.members[i]);
                            break;
                        default:
                            continue;
                    }
                }
            }
        };
        TypeFlow.prototype.typeCheckCall = function (ast) {
            var callEx = ast;
            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType == 31 /* New */ )) {
                if (TypeScript.hasFlag(ast.flags, 64 /* IsStatement */ )) {
                    this.checker.errorReporter.styleError(ast, "use of new expression as a statement");
                }
            } else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType == 30 /* Call */ )) {
                if ((callEx.target.nodeType == 25 /* Name */ ) && ((callEx.target).text == "eval")) {
                    this.checker.errorReporter.styleError(callEx, "eval not permitted");
                }
            }
            if (callEx.target.nodeType == 73 /* FuncDecl */ ) {
                (callEx.target).isInlineCallLiteral = true;
            }
            var prevInSuperCall = this.inSuperCall;
            if (callEx.target.nodeType == 6 /* Super */ ) {
                this.inSuperCall = true;
            }
            callEx.target = this.typeCheck(callEx.target);
            this.preTypeCheckCallArgs(callEx.arguments);
            var target = callEx.target;
            if ((target.type == null) || (target.type == this.anyType) || (this.functionInterfaceType && target.type == this.functionInterfaceType)) {
                callEx.type = this.anyType;
            } else {
                var fnType = target.type;
                if (fnType.call) {
                    var signature = this.resolveOverload(callEx, fnType.call);
                    if (signature == null) {
                        callEx.type = this.anyType;
                    } else {
                        callEx.type = signature.returnType.type;
                        callEx.signature = signature;
                    }
                } else {
                    if (callEx.target.nodeType == 6 /* Super */  && this.thisFnc && this.thisFnc.isConstructor && TypeScript.hasFlag(this.thisFnc.fncFlags, 262144 /* ClassMethod */ )) {
                        var signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;
                        if (signature == null) {
                            callEx.type = this.anyType;
                        } else {
                            callEx.flags |= 512 /* ClassBaseConstructorCall */ ;
                            callEx.type = signature.returnType.type;
                            callEx.signature = signature;
                        }
                    } else {
                        callEx.type = this.anyType;
                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);
                    }
                }
            }
            this.postTypeCheckCallArgs(callEx);
            this.inSuperCall = prevInSuperCall;
            return callEx;
        };
        TypeFlow.prototype.assignScopes = function (ast) {
            var script = ast;
            this.checker.locationInfo = script.locationInfo;
            var globalChain = new ScopeChain(this.checker.gloMod, null, this.globalScope);
            var context = new TypeScript.AssignScopeContext(globalChain, this, [
                this.checker.currentModDecl
            ]);
            TypeScript.getAstWalkerFactory().walk(ast, TypeScript.preAssignScopes, TypeScript.postAssignScopes, null, context);
        };
        TypeFlow.prototype.findMemberScope = function (enclosingScopeContext, matchFlag) {
            var enclosingScope = enclosingScopeContext.getScope();
            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScriptFragmentPosition();
            var scriptFragment = enclosingScopeContext.getScriptFragment();
            var memContext = new TypeScript.MemberScopeContext(this, pos, matchFlag);
            memContext.scope = enclosingScope;
            if (scriptFragment.nodeType == 25 /* Name */ ) {
                return scriptFragment.type.getMemberScope(this);
            } else {
                TypeScript.getAstWalkerFactory().walk(scriptFragment, TypeScript.preFindMemberScope, null, null, memContext);
                if (memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {
                    enclosingScopeContext.publicsOnly = false;
                }
                if (memContext.type) {
                    return memContext.type.getMemberScope(this);
                } else {
                    return null;
                }
            }
        };
        TypeFlow.prototype.findMemberScopeAt = function (enclosingScopeContext) {
            return this.findMemberScope(enclosingScopeContext, 32 /* DotLHS */ );
        };
        TypeFlow.prototype.findMemberScopeAtFullAst = function (enclosingScopeContext) {
            var matchFlag = 32 /* DotLHS */ ;
            var pos = enclosingScopeContext.pos;
            var astResult = null;
            var preFindMemberScopeFullAst = function (ast, parent, walker) {
                if (TypeScript.isValidAstNode(ast)) {
                    if (TypeScript.hasFlag(ast.flags, matchFlag) && (pos == ast.limChar || (pos - 1) == ast.limChar)) {
                        astResult = ast;
                        walker.options.stopWalk();
                    }
                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);
                }
                return ast;
            };
            var preFindMemberScopeFullAstFuzy = function (ast, parent, walker) {
                if (TypeScript.isValidAstNode(ast)) {
                    if (TypeScript.hasFlag(ast.flags, matchFlag) && ((ast.minChar < pos) && (pos <= ast.limChar))) {
                        astResult = ast;
                    }
                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);
                }
                return ast;
            };
            TypeScript.getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAst);
            if (astResult == null) {
                TypeScript.getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAstFuzy);
            }
            if (astResult && enclosingScopeContext.enclosingClassDecl && astResult.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {
                enclosingScopeContext.publicsOnly = false;
            }
            if (astResult && astResult.type) {
                return astResult.type.getMemberScope(this);
            } else {
                return null;
            }
        };
        return TypeFlow;
    })();
    TypeScript.TypeFlow = TypeFlow;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Primitive) {
        Primitive._map = [];
        Primitive.None = 0;
        Primitive.Void = 1;
        Primitive.Double = 2;
        Primitive.String = 4;
        Primitive.Boolean = 8;
        Primitive.Any = 16;
        Primitive.Null = 32;
        Primitive.Undefined = 64;
    })(TypeScript.Primitive || (TypeScript.Primitive = {}));
    var Primitive = TypeScript.Primitive;
    var MemberName = (function () {
        function MemberName() {
            this.prefix = "";
            this.suffix = "";
        }
        MemberName.prototype.isString = function () {
            return false;
        };
        MemberName.prototype.isArray = function () {
            return false;
        };
        MemberName.prototype.toString = function () {
            return MemberName.memberNameToString(this);
        };
        MemberName.memberNameToString = function memberNameToString(memberName) {
            var result = memberName.prefix;
            if (memberName.isString()) {
                result += (memberName).text;
            } else {
                var ar = memberName;
                for(var index = 0; index < ar.entries.length; index++) {
                    result += MemberName.memberNameToString(ar.entries[index]);
                    result += ar.delim;
                }
            }
            result += memberName.suffix;
            return result;
        };
        MemberName.create = function create(arg1, arg2, arg3) {
            if (typeof arg1 == "string") {
                return new MemberNameString(arg1);
            } else {
                var result = new MemberNameArray();
                if (arg2) {
                    result.prefix = arg2;
                }
                if (arg3) {
                    result.suffix = arg3;
                }
                result.entries.push(arg1);
                return result;
            }
        };
        return MemberName;
    })();
    TypeScript.MemberName = MemberName;    
    var MemberNameString = (function (_super) {
        __extends(MemberNameString, _super);
        function MemberNameString(text) {
                _super.call(this);
            this.text = text;
        }
        MemberNameString.prototype.isString = function () {
            return true;
        };
        return MemberNameString;
    })(MemberName);
    TypeScript.MemberNameString = MemberNameString;    
    var MemberNameArray = (function (_super) {
        __extends(MemberNameArray, _super);
        function MemberNameArray() {
            _super.apply(this, arguments);

            this.delim = "";
            this.entries = [];
        }
        MemberNameArray.prototype.isArray = function () {
            return true;
        };
        MemberNameArray.prototype.add = function (entry) {
            this.entries.push(entry);
        };
        MemberNameArray.prototype.addAll = function (entries) {
            for(var i = 0; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        };
        return MemberNameArray;
    })(MemberName);
    TypeScript.MemberNameArray = MemberNameArray;    
    var currentTypeID = -1;
    var Type = (function () {
        function Type() {
            this.typeID = currentTypeID++;
            this.construct = null;
            this.call = null;
            this.index = null;
            this.passTypeCreated = TypeScript.CompilerDiagnostics.analysisPass;
            this.primitiveTypeClass = 0 /* None */ ;
            this.typeFlags = 0 /* None */ ;
        }
        Type.prototype.baseClass = function () {
            if (this.extendsList && (this.extendsList.length > 0)) {
                return this.extendsList[0];
            } else {
                return null;
            }
        };
        Type.prototype.getArrayBase = function (arrInstType, checker) {
            return this.arrayCache.specialize(arrInstType, checker);
        };
        Type.prototype.isClass = function () {
            return this.instanceType != null;
        };
        Type.prototype.isArray = function () {
            return this.elementType != null;
        };
        Type.prototype.isClassInstance = function () {
            return this.symbol && !this.elementType && (this.symbol).type.isClass();
        };
        Type.prototype.getInstanceType = function () {
            if (this.isClass()) {
                return this.instanceType;
            } else {
                return this;
            }
        };
        Type.prototype.hasImplementation = function () {
            return TypeScript.hasFlag(this.typeFlags, 1 /* HasImplementation */ );
        };
        Type.prototype.setHasImplementation = function () {
            this.typeFlags |= 1 /* HasImplementation */ ;
        };
        Type.prototype.isDouble = function () {
            return TypeScript.hasFlag(this.primitiveTypeClass, 2 /* Double */ );
        };
        Type.prototype.isString = function () {
            return TypeScript.hasFlag(this.primitiveTypeClass, 4 /* String */ );
        };
        Type.prototype.isBoolean = function () {
            return TypeScript.hasFlag(this.primitiveTypeClass, 8 /* Boolean */ );
        };
        Type.prototype.isNull = function () {
            return TypeScript.hasFlag(this.primitiveTypeClass, 32 /* Null */ );
        };
        Type.prototype.getTypeName = function () {
            return this.getMemberTypeName("", true, false, null);
        };
        Type.prototype.getScopedTypeName = function (scope, getPrettyTypeName) {
            return this.getMemberTypeName("", true, false, scope, getPrettyTypeName);
        };
        Type.prototype.getScopedTypeNameEx = function (scope, getPrettyTypeName) {
            return this.getMemberTypeNameEx("", true, false, scope, getPrettyTypeName);
        };
        Type.prototype.callCount = function () {
            var total = 0;
            if (this.call) {
                total += this.call.signatures.length;
            }
            if (this.construct) {
                total += this.construct.signatures.length;
            }
            if (this.index) {
                total += this.index.signatures.length;
            }
            return total;
        };
        Type.prototype.getMemberTypeName = function (prefix, topLevel, isElementType, scope, getPrettyTypeName) {
            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope, getPrettyTypeName);
            return memberName.toString();
        };
        Type.prototype.getMemberTypeNameEx = function (prefix, topLevel, isElementType, scope, getPrettyTypeName) {
            if (this.elementType) {
                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), "", "[]");
            } else if (this.symbol && this.symbol.name && this.symbol.name != "_anonymous" && (((this.call == null) && (this.construct == null) && (this.index == null)) || (TypeScript.hasFlag(this.typeFlags, 16 /* BuildingName */ )) || (this.members && (!this.isClass())))) {
                var tn = this.symbol.scopeRelativeName(scope);
                return MemberName.create(tn == "null" ? "any" : tn);
            } else {
                if (this.members || this.call || this.construct) {
                    if (TypeScript.hasFlag(this.typeFlags, 16 /* BuildingName */ )) {
                        return MemberName.create("this");
                    }
                    this.typeFlags |= 16 /* BuildingName */ ;
                    var builder = "";
                    var allMemberNames = new MemberNameArray();
                    var curlies = isElementType || this.index != null;
                    var memCount = 0;
                    var delim = "; ";
                    if (this.members) {
                        this.members.allMembers.map(function (key, s, unused) {
                            var sym = s;
                            if (!TypeScript.hasFlag(sym.flags, 8192 /* BuiltIn */ )) {
                                var typeNameMember = sym.getTypeNameEx(scope);
                                if (typeNameMember.isArray() && (typeNameMember).delim == delim) {
                                    allMemberNames.addAll((typeNameMember).entries);
                                } else {
                                    allMemberNames.add(typeNameMember);
                                }
                                memCount++;
                                curlies = true;
                            }
                        }, null);
                    }
                    var signatureCount = this.callCount();
                    var j;
                    var len = 0;
                    var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.call && this.call.signatures.length > 1 && !this.members && !this.construct;
                    var shortform = !curlies && (signatureCount == 1 || getPrettyFunctionOverload) && topLevel;
                    if (this.call) {
                        allMemberNames.addAll(this.call.toStrings(prefix, shortform, scope, getPrettyFunctionOverload));
                    }
                    if (this.construct) {
                        allMemberNames.addAll(this.construct.toStrings("new", shortform, scope));
                    }
                    if (this.index) {
                        allMemberNames.addAll(this.index.toStrings("", shortform, scope));
                    }
                    if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                        allMemberNames.prefix = "{ ";
                        allMemberNames.suffix = "}";
                        allMemberNames.delim = delim;
                    } else if (allMemberNames.entries.length > 1) {
                        allMemberNames.delim = delim;
                    }
                    this.typeFlags &= (~16 /* BuildingName */ );
                    if ((signatureCount == 0) && (memCount == 0)) {
                        return MemberName.create("{}");
                    } else {
                        return allMemberNames;
                    }
                } else {
                    return MemberName.create("{}");
                }
            }
        };
        Type.prototype.checkDecl = function (checker) {
            if (this.isClassInstance() || this.isClass()) {
                if (this.symbol.declAST) {
                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);
                }
            }
        };
        Type.prototype.getMemberScope = function (flow) {
            if (this == flow.anyType) {
                return null;
            } else if (this.isDouble()) {
                if (flow.numberInterfaceType) {
                    return flow.numberInterfaceType.memberScope;
                } else {
                    return null;
                }
            } else if (this.isBoolean()) {
                if (flow.booleanInterfaceType) {
                    return flow.booleanInterfaceType.memberScope;
                } else {
                    return null;
                }
            } else if (this == flow.stringType) {
                if (flow.stringInterfaceType) {
                    return flow.stringInterfaceType.memberScope;
                } else {
                    return null;
                }
            } else if (this.elementType) {
                if (flow.arrayInterfaceType) {
                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);
                    return arrInstType.memberScope;
                } else {
                    return null;
                }
            } else {
                return this.memberScope;
            }
        };
        Type.prototype.isReferenceType = function () {
            return this.members || this.extendsList || this.construct || this.call || this.index || this.elementType;
        };
        Type.prototype.specializeType = function (pattern, replacement, checker, membersOnly) {
            if (pattern == this) {
                return replacement;
            }
            var result = this;
            if (membersOnly) {
                if (this.isReferenceType()) {
                    result = new Type();
                    if (this.members) {
                        result.members = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                        this.members.publicMembers.map(function (key, s, unused) {
                            var sym = s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.members.addPublicMember(bSym.name, bSym);
                        }, null);
                        this.members.privateMembers.map(function (key, s, unused) {
                            var sym = s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.members.addPrivateMember(bSym.name, bSym);
                        }, null);
                    }
                    if (this.ambientMembers) {
                        result.ambientMembers = new TypeScript.ScopedMembers(new TypeScript.DualStringHashTable(new TypeScript.StringHashTable(), new TypeScript.StringHashTable()));
                        this.ambientMembers.publicMembers.map(function (key, s, unused) {
                            var sym = s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.ambientMembers.addPublicMember(bSym.name, bSym);
                        }, null);
                        this.ambientMembers.privateMembers.map(function (key, s, unused) {
                            var sym = s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.ambientMembers.addPrivateMember(bSym.name, bSym);
                        }, null);
                    }
                    result.containedScope = checker.scopeOf(result);
                    result.memberScope = result.containedScope;
                }
            } else {
                if (this.elementType) {
                    if (this.elementType == pattern) {
                        result = checker.makeArrayType(replacement);
                    } else {
                        if (this.elementType.elementType == pattern) {
                            result = checker.makeArrayType(checker.makeArrayType(replacement));
                        }
                    }
                } else if (this.call) {
                    result = new Type();
                    result.call = this.call.specializeType(pattern, replacement, checker);
                }
            }
            return result;
        };
        Type.prototype.hasBase = function (baseType) {
            if (baseType == this) {
                return true;
            } else {
                if (this.extendsList) {
                    for(var i = 0, len = this.extendsList.length; i < len; i++) {
                        if (this.extendsList[i].hasBase(baseType)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        Type.prototype.mergeOrdered = function (b, checker, acceptVoid, comparisonInfo) {
            if ((this == checker.anyType) || (b == checker.anyType)) {
                return checker.anyType;
            } else if (this == b) {
                return this;
            } else if ((b == checker.nullType) && this != checker.nullType) {
                return this;
            } else if ((this == checker.nullType) && (b != checker.nullType)) {
                return b;
            } else if (acceptVoid && (b == checker.voidType) && this != checker.voidType) {
                return this;
            } else if (acceptVoid && (this == checker.voidType) && (b != checker.voidType)) {
                return b;
            } else if ((b == checker.undefinedType) && this != checker.undefinedType) {
                return this;
            } else if ((this == checker.undefinedType) && (b != checker.undefinedType)) {
                return b;
            } else if (this.elementType && b.elementType) {
                if (this.elementType == b.elementType) {
                    return this;
                } else {
                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, acceptVoid, comparisonInfo);
                    if (mergedET == null) {
                        return checker.makeArrayType(checker.anyType);
                    } else {
                        return checker.makeArrayType(mergedET);
                    }
                }
            } else if (checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {
                return b;
            } else if (checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {
                return this;
            } else {
                return null;
            }
        };
        Type.prototype.isModuleType = function () {
            return false;
        };
        Type.prototype.hasMembers = function () {
            return this.members != null;
        };
        Type.prototype.getAllEnclosedTypes = function () {
            return null;
        };
        Type.prototype.getAllAmbientEnclosedTypes = function () {
            return null;
        };
        Type.prototype.getPublicEnclosedTypes = function () {
            return null;
        };
        Type.prototype.getpublicAmbientEnclosedTypes = function () {
            return null;
        };
        Type.prototype.getDocComments = function () {
            if (this.elementType || !this.symbol) {
                return [];
            }
            if (this.isClassInstance() || this.isClass()) {
                if (this.symbol.declAST.nodeType == 73 /* FuncDecl */ ) {
                    return (this.symbol.declAST).classDecl.getDocComments();
                } else {
                    return this.symbol.getDocComments();
                }
            }
            if (this.symbol.name && this.symbol.name != "_anonymous" && (((this.call == null) && (this.construct == null) && (this.index == null)) || this.members)) {
                return this.symbol.getDocComments();
            }
            return [];
        };
        return Type;
    })();
    TypeScript.Type = Type;    
    var ModuleType = (function (_super) {
        __extends(ModuleType, _super);
        function ModuleType(enclosedTypes, ambientEnclosedTypes) {
                _super.call(this);
            this.enclosedTypes = enclosedTypes;
            this.ambientEnclosedTypes = ambientEnclosedTypes;
            this.importedModules = [];
        }
        ModuleType.prototype.isModuleType = function () {
            return true;
        };
        ModuleType.prototype.hasMembers = function () {
            return this.members != null || this.enclosedTypes != null;
        };
        ModuleType.prototype.getAllEnclosedTypes = function () {
            return this.enclosedTypes;
        };
        ModuleType.prototype.getAllAmbientEnclosedTypes = function () {
            return this.ambientEnclosedTypes;
        };
        ModuleType.prototype.getPublicEnclosedTypes = function () {
            return null;
        };
        ModuleType.prototype.getpublicAmbientEnclosedTypes = function () {
            return null;
        };
        ModuleType.findDynamicModuleNameInHashTable = function findDynamicModuleNameInHashTable(moduleType, members) {
            var moduleName = null;
            members.map(function (key, s, c) {
                if (moduleName == null && !TypeScript.isQuoted(key)) {
                    var symbol = s;
                    var type = symbol.getType();
                    if (type == moduleType) {
                        moduleName = {
                            name: key,
                            symbol: symbol
                        };
                    }
                }
            }, null);
            return moduleName;
        };
        ModuleType.prototype.findDynamicModuleName = function (moduleType) {
            var moduleName = null;
            moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.members.allMembers);
            if (moduleName == null) {
                moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.ambientMembers.allMembers);
            }
            return moduleName;
        };
        return ModuleType;
    })(Type);
    TypeScript.ModuleType = ModuleType;    
    var TypeLink = (function () {
        function TypeLink() {
            this.type = null;
            this.ast = null;
        }
        return TypeLink;
    })();
    TypeScript.TypeLink = TypeLink;    
    function getTypeLink(ast, checker, autoVar) {
        var result = new TypeLink();
        result.ast = ast;
        if ((ast == null) && (autoVar)) {
            result.type = checker.anyType;
        } else {
            result.type = null;
        }
        return result;
    }
    TypeScript.getTypeLink = getTypeLink;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function stripQuotes(str) {
        return str.replace("\"", "").replace("'", "").replace("'", "").replace("\"", "");
    }
    TypeScript.stripQuotes = stripQuotes;
    function isSingleQuoted(str) {
        return str.indexOf("'") != -1;
    }
    TypeScript.isSingleQuoted = isSingleQuoted;
    function isQuoted(str) {
        return str.indexOf("\"") != -1 || isSingleQuoted(str);
    }
    TypeScript.isQuoted = isQuoted;
    function quoteStr(str) {
        return "\"" + str + "\"";
    }
    TypeScript.quoteStr = quoteStr;
    function swapQuotes(str) {
        if (str.indexOf("\"") != -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        } else {
            str = str.replace("'", "\"");
            str = str.replace("'", "\"");
        }
        return str;
    }
    TypeScript.swapQuotes = swapQuotes;
    function changeToSingleQuote(str) {
        if (str.indexOf("\"") != -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        }
        return str;
    }
    TypeScript.changeToSingleQuote = changeToSingleQuote;
    function switchToForwardSlashes(path) {
        return path.replace(/\\/g, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;
    function trimModName(modName) {
        if (modName.length > 6 && modName.substring(modName.length - 6, modName.length) == ".d.str") {
            return modName.substring(0, modName.length - 6);
        }
        if (modName.length > 4 && modName.substring(modName.length - 4, modName.length) == ".str") {
            return modName.substring(0, modName.length - 4);
        }
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) == ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".ts") {
            return modName.substring(0, modName.length - 3);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".js") {
            return modName.substring(0, modName.length - 3);
        }
        return modName;
    }
    TypeScript.trimModName = trimModName;
    function getDeclareFilePath(fname) {
        return isSTRFile(fname) ? changePathToDSTR(fname) : isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }
    TypeScript.getDeclareFilePath = getDeclareFilePath;
    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) == invariantExt;
    }
    function isJSFile(fname) {
        return isFileOfExtension(fname, ".js");
    }
    TypeScript.isJSFile = isJSFile;
    function isSTRFile(fname) {
        return isFileOfExtension(fname, ".str");
    }
    TypeScript.isSTRFile = isSTRFile;
    function isTSFile(fname) {
        return isFileOfExtension(fname, ".ts");
    }
    TypeScript.isTSFile = isTSFile;
    function isDSTRFile(fname) {
        return isFileOfExtension(fname, ".d.str");
    }
    TypeScript.isDSTRFile = isDSTRFile;
    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;
    function getPrettyName(modPath, quote, treatAsFileName) {
        if (typeof quote === "undefined") { quote = true; }
        if (typeof treatAsFileName === "undefined") { treatAsFileName = false; }
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }
    TypeScript.getPrettyName = getPrettyName;
    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;
    function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath) {
        absoluteModPath = switchToForwardSlashes(absoluteModPath);
        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);
        var joinStartIndex = 0;
        for(; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] != modComponents[joinStartIndex]) {
                break;
            }
        }
        if (joinStartIndex != 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for(; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] != "") {
                    relativePath = relativePath + "../";
                }
            }
            return relativePath + relativePathComponents.join("/");
        }
        return absoluteModPath;
    }
    TypeScript.getRelativePathToFixedPath = getRelativePathToFixedPath;
    function quoteBaseName(modPath) {
        var modName = trimModName(stripQuotes(modPath));
        var path = getRootFilePath(modName);
        if (path == "") {
            return modPath;
        } else {
            var components = modName.split(path);
            var fileIndex = components.length > 1 ? 1 : 0;
            return quoteStr(components[fileIndex]);
        }
    }
    TypeScript.quoteBaseName = quoteBaseName;
    function changePathToSTR(modPath) {
        return trimModName(stripQuotes(modPath)) + ".str";
    }
    TypeScript.changePathToSTR = changePathToSTR;
    function changePathToDSTR(modPath) {
        return trimModName(stripQuotes(modPath)) + ".d.str";
    }
    TypeScript.changePathToDSTR = changePathToDSTR;
    function changePathToTS(modPath) {
        return trimModName(stripQuotes(modPath)) + ".ts";
    }
    TypeScript.changePathToTS = changePathToTS;
    function changePathToDTS(modPath) {
        return trimModName(stripQuotes(modPath)) + ".d.ts";
    }
    TypeScript.changePathToDTS = changePathToDTS;
    function isRelative(path) {
        return path.charAt(0) == ".";
    }
    TypeScript.isRelative = isRelative;
    function isRooted(path) {
        return path.charAt(0) == "\\" || path.charAt(0) == "/" || (path.indexOf(":\\") != -1) || (path.indexOf(":/") != -1);
    }
    TypeScript.isRooted = isRooted;
    function getRootFilePath(outFname) {
        if (outFname == "") {
            return outFname;
        } else {
            var isPath = outFname.indexOf("/") != -1;
            return isPath ? filePath(outFname) : "";
        }
    }
    TypeScript.getRootFilePath = getRootFilePath;
    function filePathComponents(fullPath) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }
    TypeScript.filePathComponents = filePathComponents;
    function filePath(fullPath) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }
    TypeScript.filePath = filePath;
    function normalizeURL(url) {
        var hostDomainAndPortRegex = /^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i;
        var matches = hostDomainAndPortRegex.exec(url);
        if (matches) {
            var hostDomainAndPort = matches[1];
            var actualPath = matches[3];
            return hostDomainAndPort + normalizePath(actualPath);
        }
        return normalizePath(url);
    }
    TypeScript.normalizeURL = normalizeURL;
    TypeScript.pathNormalizeRegExp = /\//g;
    function normalizePath(path) {
        path = switchToForwardSlashes(path);
        var startedWithSep = path.charAt(0) === "/";
        var parts = this.getPathComponents(path);
        for(var i = 0; i < parts.length; i++) {
            if (parts[i] === "." || parts[i] === "") {
                parts.splice(i, 1);
                i--;
            }
            if (i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {
                parts.splice(i - 1, 2);
                i -= 2;
            }
        }
        return (startedWithSep ? "/" : "") + parts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
    function normalizeImportPath(path) {
        return normalizePath(path);
    }
    TypeScript.normalizeImportPath = normalizeImportPath;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceUnit = (function () {
        function SourceUnit(path, content) {
            this.path = path;
            this.content = content;
            this.referencedFiles = null;
        }
        SourceUnit.prototype.getText = function (start, end) {
            return this.content.substring(start, end);
        };
        SourceUnit.prototype.getLength = function () {
            return this.content.length;
        };
        return SourceUnit;
    })();
    TypeScript.SourceUnit = SourceUnit;    
    var CompilationEnvironment = (function () {
        function CompilationEnvironment(compilationSettings, ioHost) {
            this.compilationSettings = compilationSettings;
            this.ioHost = ioHost;
            this.residentCode = [];
            this.code = [];
            this.inputOutputMap = [];
        }
        return CompilationEnvironment;
    })();
    TypeScript.CompilationEnvironment = CompilationEnvironment;    
    var CodeResolver = (function () {
        function CodeResolver(environment) {
            this.environment = environment;
            this.visited = {};
        }
        CodeResolver.prototype.resolveCode = function (referencePath, parentPath, performSearch, resolutionDispatcher) {
            var resolvedFile = {
                content: null,
                path: referencePath
            };
            var ioHost = this.environment.ioHost;
            var isRelativePath = TypeScript.isRelative(referencePath);
            var isRootedPath = isRelativePath ? false : TypeScript.isRooted(referencePath);
            var normalizedPath = isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);
            if (!TypeScript.isSTRFile(normalizedPath) && !TypeScript.isTSFile(normalizedPath)) {
                normalizedPath += ".ts";
            }
            normalizedPath = TypeScript.switchToForwardSlashes(TypeScript.stripQuotes(normalizedPath));
            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();
            if (!this.visited[absoluteModuleID]) {
                if (isRelativePath || isRootedPath || !performSearch) {
                    try  {
                        TypeScript.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                        try  {
                            resolvedFile.content = ioHost.readFile(normalizedPath);
                        } catch (err) {
                            try  {
                                if (TypeScript.isSTRFile(normalizedPath)) {
                                    normalizedPath = TypeScript.changePathToTS(normalizedPath);
                                } else if (TypeScript.isTSFile(normalizedPath)) {
                                    normalizedPath = TypeScript.changePathToSTR(normalizedPath);
                                }
                                TypeScript.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                                resolvedFile.content = ioHost.readFile(normalizedPath);
                            } catch (err) {
                                normalizedPath = TypeScript.changePathToDSTR(normalizedPath);
                                TypeScript.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                                try  {
                                    resolvedFile.content = ioHost.readFile(normalizedPath);
                                } catch (err) {
                                    normalizedPath = TypeScript.changePathToDTS(normalizedPath);
                                    TypeScript.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                                    resolvedFile.content = ioHost.readFile(normalizedPath);
                                }
                            }
                        }
                        TypeScript.CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);
                        resolvedFile.path = normalizedPath;
                        this.visited[absoluteModuleID] = true;
                    } catch (err) {
                        TypeScript.CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);
                        return false;
                    }
                } else {
                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                    if (!resolvedFile) {
                        if (TypeScript.isSTRFile(normalizedPath)) {
                            normalizedPath = TypeScript.changePathToTS(normalizedPath);
                        } else if (TypeScript.isTSFile(normalizedPath)) {
                            normalizedPath = TypeScript.changePathToSTR(normalizedPath);
                        }
                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                    }
                    if (!resolvedFile) {
                        normalizedPath = TypeScript.changePathToDTS(normalizedPath);
                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                        if (!resolvedFile) {
                            normalizedPath = TypeScript.changePathToDSTR(normalizedPath);
                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                        }
                    }
                    if (resolvedFile) {
                        resolvedFile.path = TypeScript.switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));
                        TypeScript.CompilerDiagnostics.debugPrint(referencePath + " resolved to: " + resolvedFile.path);
                        resolvedFile.content = resolvedFile.content;
                        this.visited[absoluteModuleID] = true;
                    } else {
                        TypeScript.CompilerDiagnostics.debugPrint("Could not find " + referencePath);
                    }
                }
                if (resolvedFile && resolvedFile.content != null) {
                    var rootDir = ioHost.dirName(resolvedFile.path);
                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);
                    var preProcessedFileInfo = TypeScript.preProcessFile(sourceUnit, this.environment.compilationSettings);
                    var resolvedFilePath = ioHost.resolvePath(resolvedFile.path);
                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;
                    for(var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {
                        var fileReference = preProcessedFileInfo.referencedFiles[i];
                        var normalizedPath = TypeScript.isRooted(fileReference.path) ? fileReference.path : rootDir + "/" + fileReference.path;
                        normalizedPath = ioHost.resolvePath(normalizedPath);
                        if (resolvedFilePath == normalizedPath) {
                            resolutionDispatcher.postResolutionError(normalizedPath, fileReference.startLine, fileReference.startCol, "Incorrect reference: File contains reference to itself.");
                            continue;
                        }
                        var resolutionResult = this.resolveCode(fileReference.path, rootDir, false, resolutionDispatcher);
                        if (!resolutionResult) {
                            resolutionDispatcher.postResolutionError(resolvedFilePath, fileReference.startLine, fileReference.startCol, "Incorrect reference: referenced file: \"" + fileReference.path + "\" cannot be resolved.");
                        }
                    }
                    for(var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {
                        var fileImport = preProcessedFileInfo.importedFiles[i];
                        var resolutionResult = this.resolveCode(fileImport.path, rootDir, true, resolutionDispatcher);
                        if (!resolutionResult) {
                            resolutionDispatcher.postResolutionError(resolvedFilePath, fileImport.startLine, fileImport.startCol, "Incorrect reference: imported file: \"" + fileImport.path + "\" cannot be resolved.");
                        }
                    }
                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);
                }
            }
            return true;
        };
        return CodeResolver;
    })();
    TypeScript.CodeResolver = CodeResolver;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var StyleSettings = (function () {
        function StyleSettings() {
            this.bitwise = false;
            this.blockInCompoundStmt = false;
            this.eqeqeq = false;
            this.forin = false;
            this.emptyBlocks = true;
            this.newMustBeUsed = false;
            this.requireSemi = false;
            this.assignmentInCond = false;
            this.eqnull = false;
            this.evalOK = true;
            this.innerScopeDeclEscape = true;
            this.funcInLoop = true;
            this.reDeclareLocal = true;
            this.literalSubscript = true;
            this.implicitAny = false;
        }
        StyleSettings.prototype.setOption = function (opt, val) {
            var optExists = this[opt];
            if (optExists !== undefined) {
                this[opt] = val;
                return true;
            } else {
                return false;
            }
        };
        StyleSettings.prototype.parseOptions = function (str) {
            var opts = str.split(";");
            for(var i = 0, len = opts.length; i < len; i++) {
                var opt = opts[i];
                var val = true;
                var colonIndex = opt.lastIndexOf(":");
                if (colonIndex >= 0) {
                    var valStr = opt.substring(colonIndex + 1);
                    opt = opt.substring(0, colonIndex);
                    if (valStr == "off") {
                        val = false;
                    }
                }
                if (!this.setOption(opt, val)) {
                    return false;
                }
            }
            return true;
        };
        return StyleSettings;
    })();
    TypeScript.StyleSettings = StyleSettings;    
    var CompilationSettings = (function () {
        function CompilationSettings() {
            this.styleSettings = new StyleSettings();
            this.propagateConstants = false;
            this.minWhitespace = false;
            this.errorRecovery = false;
            this.emitComments = false;
            this.watch = false;
            this.exec = false;
            this.resolve = true;
            this.controlFlow = false;
            this.printControlFlow = false;
            this.controlFlowUseDef = false;
            this.errorOnWith = true;
            this.preprocess = true;
            this.canCallDefinitionSignature = false;
            this.inferPropertiesFromThisAssignment = false;
            this.useDefaultLib = true;
            this.codeGenTarget = 0 /* ES3 */ ;
            this.moduleGenTarget = 0 /* Synchronous */ ;
            this.outputOption = "";
            this.mapSourceFiles = false;
            this.emitFullSourceMapPath = false;
            this.generateDeclarationFiles = false;
            this.useCaseSensitiveFileResolution = false;
            this.useFidelity = false;
            this.usePull = false;
            this.gatherDiagnostics = false;
        }
        CompilationSettings.prototype.setStyleOptions = function (str) {
            this.styleSettings.parseOptions(str);
        };
        return CompilationSettings;
    })();
    TypeScript.CompilationSettings = CompilationSettings;    
    function getFileReferenceFromReferencePath(comment) {
        var referencesRegEx = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = referencesRegEx.exec(comment);
        if (match) {
            var path = TypeScript.normalizePath(match[3]);
            var adjustedPath = TypeScript.normalizePath(path);
            var isResident = match.length >= 7 && match[6] == "true";
            if (isResident) {
                TypeScript.CompilerDiagnostics.debugPrint(path + " is resident");
            }
            return {
                minChar: 0,
                limChar: 0,
                startLine: 0,
                startCol: 0,
                path: TypeScript.switchToForwardSlashes(adjustedPath),
                isResident: isResident
            };
        } else {
            return null;
        }
    }
    function getAdditionalDependencyPath(comment) {
        var amdDependencyRegEx = /^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = amdDependencyRegEx.exec(comment);
        if (match) {
            var path = match[3];
            return path;
        } else {
            return null;
        }
    }
    TypeScript.getAdditionalDependencyPath = getAdditionalDependencyPath;
    function getImplicitImport(comment) {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(comment);
        if (match) {
            return true;
        }
        return false;
    }
    TypeScript.getImplicitImport = getImplicitImport;
    function getStyleSettings(comment, styleSettings) {
        var styleRegEx = /^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/gim;
        var settings = styleRegEx.exec(comment);
        if (settings) {
            var settingsRegEx = /^([a-zA-Z]+=['"]on['|"])/gim;
            settings = settingsRegEx.exec(settings[2]);
            if (settings) {
                for(var i = 0; i < settings.length; i++) {
                    var setting = (settings[i]).split("=");
                    var on = "\"on\"";
                    switch(setting[0]) {
                        case "blockInCompoundStmt":
                            styleSettings.blockInCompoundStmt = setting[1] == on;
                            break;
                        case "eqeqeq":
                            styleSettings.eqeqeq = setting[1] == on;
                            break;
                        case "forin":
                            styleSettings.forin = setting[1] == on;
                            break;
                        case "emptyBlocks":
                            styleSettings.emptyBlocks = setting[1] == on;
                            break;
                        case "newMustBeUsed":
                            styleSettings.newMustBeUsed = setting[1] == on;
                            break;
                        case "requireSemi":
                            styleSettings.requireSemi = setting[1] == on;
                            break;
                        case "assignmentInCond":
                            styleSettings.assignmentInCond = setting[1] == on;
                            break;
                        case "eqnull":
                            styleSettings.eqnull = setting[1] == on;
                            break;
                        case "evalOK":
                            styleSettings.evalOK = setting[1] == on;
                            break;
                        case "innerScopeDeclEscape":
                            styleSettings.innerScopeDeclEscape = setting[1] == on;
                            break;
                        case "funcInLoop":
                            styleSettings.funcInLoop = setting[1] == on;
                            break;
                        case "reDeclareLocal":
                            styleSettings.reDeclareLocal = setting[1] == on;
                            break;
                        case "literalSubscript":
                            styleSettings.literalSubscript = setting[1] == on;
                            break;
                        case "implicitAny":
                            styleSettings.implicitAny = setting[1] == on;
                            break;
                    }
                }
            }
        }
    }
    TypeScript.getStyleSettings = getStyleSettings;
    function getReferencedFiles(sourceText) {
        var preProcessInfo = preProcessFile(sourceText, null, false);
        return preProcessInfo.referencedFiles;
    }
    TypeScript.getReferencedFiles = getReferencedFiles;
    function preProcessFile(sourceText, options, readImportFiles) {
        if (typeof options === "undefined") { options = new CompilationSettings(); }
        if (typeof readImportFiles === "undefined") { readImportFiles = true; }
        var scanner = new TypeScript.Scanner();
        scanner.resetComments();
        scanner.setSourceText(sourceText, 1 /* File */ );
        var tok = scanner.scan();
        var comments = [];
        var comment = null;
        var leftCurlies = [];
        var settings = options;
        var referencedFiles = [];
        var importedFiles = [];
        var isLibFile = false;
        while(tok.tokenId != 105 /* EndOfFile */ ) {
            if (readImportFiles && tok.tokenId == 25 /* Import */ ) {
                tok = scanner.scan();
                if (tok.tokenId == 107 /* Identifier */  || TypeScript.convertTokToID(tok, false)) {
                    tok = scanner.scan();
                    if (tok.tokenId == 63 /* Equals */ ) {
                        tok = scanner.scan();
                        if (tok.tokenId == 30 /* Module */ ) {
                            tok = scanner.scan();
                            if (tok.tokenId == 56 /* OpenParen */ ) {
                                tok = scanner.scan();
                                if (tok.tokenId == 108 /* StringLiteral */ ) {
                                    var ref = {
                                        minChar: scanner.startPos,
                                        limChar: scanner.pos,
                                        startLine: scanner.line,
                                        startCol: scanner.col,
                                        path: TypeScript.stripQuotes(TypeScript.switchToForwardSlashes(tok.getText())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }
            if (tok.tokenId == 60 /* OpenBrace */ ) {
                leftCurlies.push(tok);
            }
            if (tok.tokenId == 61 /* CloseBrace */ ) {
                leftCurlies.pop();
            }
            tok = scanner.scan();
        }
        comments = scanner.getComments();
        for(var iComment = 0; iComment < comments.length; iComment++) {
            comment = comments[iComment];
            if (!comment.isBlock) {
                var referencedCode = getFileReferenceFromReferencePath(comment.getText());
                if (referencedCode) {
                    referencedCode.minChar = comment.startPos;
                    referencedCode.limChar = referencedCode.minChar + comment.value.length;
                    var result = {
                        line: -1,
                        col: -1
                    };
                    TypeScript.getSourceLineColFromMap(result, comment.startPos, scanner.lineMap);
                    if (result.col >= 0) {
                        result.col++;
                    }
                    referencedCode.startLine = result.line;
                    referencedCode.startCol = result.col;
                    referencedFiles.push(referencedCode);
                }
                if (settings) {
                    getStyleSettings(comment.getText(), settings.styleSettings);
                    var isNoLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
                    var isNoLibMatch = isNoLibRegex.exec(comment.getText());
                    if (isNoLibMatch) {
                        isLibFile = (isNoLibMatch[3] == "true");
                    }
                }
            }
        }
        return {
            settings: settings,
            referencedFiles: referencedFiles,
            importedFiles: importedFiles,
            isLibFile: isLibFile
        };
    }
    TypeScript.preProcessFile = preProcessFile;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IncrementalParser = (function () {
        function IncrementalParser(logger) {
            this.logger = logger;
            this.astLogger = new TypeScript.AstLogger(this.logger);
        }
        IncrementalParser.prototype.getEnclosingScopeContextIfSingleScopeEdit = function (previousScript, scriptId, newSourceText, editRange) {
            this.logger.log("checkEditsInsideSingleScope(\"" + scriptId + "\")");
            if (editRange === null) {
                throw new Error("editRange should be valid");
            }
            if (editRange.isUnknown()) {
                this.logger.log("  Bailing out because edit range is unknown");
                return null;
            }
            var scope1 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false);
            var scope2 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false);
            if (scope1 == null || scope2 == null) {
                this.logger.log("  Bailing out because containing scopes cannot be determined");
                return null;
            }
            if (scope1.scopeStartAST !== scope2.scopeStartAST) {
                this.logger.log("  Bailing out because edit overlaps 2 disctint scopes");
                return null;
            }
            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;
            if (newScopeLength <= 0) {
                this.logger.log("  Bailing out because scope has been entirely removed from new source text");
                return null;
            }
            return scope1;
        };
        IncrementalParser.prototype.attemptIncrementalUpdateUnit = function (previousScript, scriptId, newSourceText, editRange) {
            this.logger.log("attemptIncrementalUpdateUnit(\"" + scriptId + "\")");
            if (editRange === null) {
                throw new Error("editRange should be valid");
            }
            var scope1 = this.getEnclosingScopeContextIfSingleScopeEdit(previousScript, scriptId, newSourceText, editRange);
            if (scope1 === null) {
                return null;
            }
            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;
            if (newScopeLength >= newSourceText.getLength() / 2) {
                this.logger.log("  Bailing out because range of scope to reparse (" + newScopeLength + " characters) is greater than half the size of the source text");
                return null;
            }
            var parseErrors = [];
            var errorCapture = function (minChar, charLen, message, unitIndex) {
                parseErrors.push(new TypeScript.ErrorEntry(unitIndex, minChar, minChar + charLen, message));
            };
            var quickParseResult = TypeScript.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture);
            if (quickParseResult.endLexState != 0 /* Start */ ) {
                this.logger.log("  Bailing out because scope contains unterminated comment");
                return null;
            }
            var scriptFragment = quickParseResult.Script;
            if (scriptFragment.vars.members.length !== 0) {
                this.logger.log("  Bailing out because new source text defines variables");
                return null;
            }
            if (scriptFragment.bod.members.length !== 1) {
                this.logger.log("  Bailing out because new source text defines more than one scope (or none)");
                return null;
            }
            var oldScope = scope1.scopeStartAST;
            var newScope = scriptFragment.bod.members[0];
            if (oldScope.nodeType != newScope.nodeType) {
                this.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope");
                return null;
            }
            if (!(oldScope).leftCurlyCount || !(oldScope).rightCurlyCount) {
                this.logger.log("  Bailing out because sopce doesn't have left/right curly count");
                return null;
            }
            if ((oldScope).leftCurlyCount !== (newScope).leftCurlyCount) {
                this.logger.log("  Bailing out because new source text contains more (or fewer) left curly braces");
                return null;
            }
            if ((oldScope).rightCurlyCount !== (newScope).rightCurlyCount) {
                this.logger.log("  Bailing out because new source text contains more (or fewer) right curly braces");
                return null;
            }
            if (newScope.minChar !== 0) {
                this.logger.log("  Bailing out because new function declaration does not start at position 0");
                return null;
            }
            if (newScope.limChar !== newScopeLength) {
                this.logger.log("  Bailing out because new function declaration does not end at the new end position");
                return null;
            }
            return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors);
        };
        IncrementalParser.prototype.mergeTrees = function (updateResult) {
            var _this = this;
            TypeScript.timeFunction(this.logger, "mergeTrees()", function () {
                var editRange = new TypeScript.ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta);
                _this.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta);
                _this.applyDeltaPosition(updateResult.script2, 0, editRange.minChar);
                _this.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange);
                _this.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2);
            });
        };
        IncrementalParser.prototype.replaceAST = function (script, oldAst, newAst) {
            var _this = this;
            var pre = function (cur, parent, walker) {
                if (cur === oldAst) {
                    newAst.preComments = cur.preComments;
                    newAst.postComments = cur.postComments;
                    _this.logger.log("replaced old AST node with new one in script AST");
                    walker.options.stopWalk();
                    return newAst;
                }
                if (TypeScript.isValidAstNode(cur)) {
                    if (cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {
                        walker.options.goChildren = false;
                    }
                }
                return cur;
            };
            TypeScript.getAstWalkerFactory().walk(script, pre);
        };
        IncrementalParser.prototype.mergeLocationInfo = function (script, partial, editRange) {
            var lineMap1 = script.locationInfo.lineMap;
            var lineMap2 = partial.locationInfo.lineMap;
            if (this.logger.information()) {
                this.logger.log("lineMap1 (before):");
                this.astLogger.logLinemap(lineMap1);
                this.logger.log("lineMap2 (quick parse):");
                this.astLogger.logLinemap(lineMap2);
                this.logger.log("EditRange=" + editRange);
            }
            var i1 = 2;
            var i2 = 2;
            var len1 = lineMap1.length;
            var len2 = lineMap2.length;
            while(i1 < len1) {
                if (lineMap1[i1] <= editRange.minChar) {
                    i1++;
                } else if (lineMap1[i1] >= editRange.limChar) {
                    lineMap1[i1] += editRange.delta;
                    i1++;
                } else {
                    if (i2 < len2) {
                        lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);
                        i1++;
                        len1++;
                        i2++;
                    } else {
                        lineMap1.splice(i1, 1);
                        len1--;
                    }
                }
            }
            if (i2 < len2) {
                if (lineMap1[len1 - 1] >= (lineMap2[i2] + editRange.minChar)) {
                    i1 = 2;
                    while(i1 < len1 && i2 < len2) {
                        if (lineMap1[i1] < (lineMap2[i2] + editRange.minChar)) {
                            i1++;
                        } else {
                            lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);
                            i1++;
                            len1++;
                            i2++;
                        }
                    }
                }
                for(; i2 < len2; i2++) {
                    lineMap1.push(lineMap2[i2] + editRange.minChar);
                }
            }
            if (this.logger.information()) {
                this.logger.log("lineMap1 (after merge):");
                this.astLogger.logLinemap(lineMap1);
            }
        };
        IncrementalParser.prototype.applyDeltaPosition = function (ast, start, delta) {
            var applyDelta = function (ast) {
                if (ast.minChar !== -1 && ast.minChar >= start) {
                    ast.minChar += delta;
                }
                if (ast.limChar !== -1 && ast.limChar >= start) {
                    ast.limChar += delta;
                }
            };
            var applyDeltaToComments = function (comments) {
                if (comments && comments.length > 0) {
                    for(var i = 0; i < comments.length; i++) {
                        applyDelta(comments[i]);
                    }
                }
            };
            var pre = function (cur, parent, walker) {
                if (cur.limChar !== -1 && cur.limChar < start) {
                    walker.options.goChildren = false;
                }
                applyDelta(cur);
                applyDeltaToComments(cur.preComments);
                applyDeltaToComments(cur.postComments);
                return cur;
            };
            TypeScript.getAstWalkerFactory().walk(ast, pre);
        };
        return IncrementalParser;
    })();
    TypeScript.IncrementalParser = IncrementalParser;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DeclFileWriter = (function () {
        function DeclFileWriter(declFile) {
            this.declFile = declFile;
            this.onNewLine = true;
        }
        DeclFileWriter.prototype.Write = function (s) {
            this.declFile.Write(s);
            this.onNewLine = false;
        };
        DeclFileWriter.prototype.WriteLine = function (s) {
            this.declFile.WriteLine(s);
            this.onNewLine = true;
        };
        DeclFileWriter.prototype.Close = function () {
            this.declFile.Close();
        };
        return DeclFileWriter;
    })();
    TypeScript.DeclFileWriter = DeclFileWriter;    
    var DeclarationEmitter = (function () {
        function DeclarationEmitter(checker, emitOptions, errorReporter) {
            this.checker = checker;
            this.emitOptions = emitOptions;
            this.errorReporter = errorReporter;
            this.declFile = null;
            this.indenter = new TypeScript.Indenter();
            this.declarationContainerStack = [];
            this.isDottedModuleName = [];
            this.ignoreCallbackAst = null;
            this.singleDeclFile = null;
            this.varListCount = 0;
        }
        DeclarationEmitter.prototype.getAstDeclarationContainer = function () {
            return this.declarationContainerStack[this.declarationContainerStack.length - 1];
        };
        DeclarationEmitter.prototype.emitDottedModuleName = function () {
            return (this.isDottedModuleName.length == 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];
        };
        DeclarationEmitter.prototype.setDeclarationFile = function (file) {
            this.declFile = new DeclFileWriter(file);
        };
        DeclarationEmitter.prototype.Close = function () {
            try  {
                this.declFile.Close();
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        };
        DeclarationEmitter.prototype.emitDeclarations = function (script) {
            TypeScript.AstWalkerWithDetailCallback.walk(script, this);
        };
        DeclarationEmitter.prototype.getIndentString = function (declIndent) {
            if (typeof declIndent === "undefined") { declIndent = false; }
            if (this.emitOptions.minWhitespace) {
                return "";
            } else {
                return this.indenter.getIndent();
            }
        };
        DeclarationEmitter.prototype.emitIndent = function () {
            this.declFile.Write(this.getIndentString());
        };
        DeclarationEmitter.prototype.canEmitSignature = function (declFlags, canEmitGlobalAmbientDecl, useDeclarationContainerTop) {
            if (typeof canEmitGlobalAmbientDecl === "undefined") { canEmitGlobalAmbientDecl = true; }
            if (typeof useDeclarationContainerTop === "undefined") { useDeclarationContainerTop = true; }
            var container;
            if (useDeclarationContainerTop) {
                container = this.getAstDeclarationContainer();
            } else {
                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];
            }
            if (container.nodeType == 98 /* ModuleDeclaration */  && !TypeScript.hasFlag(declFlags, 1 /* Exported */ )) {
                return false;
            }
            if (!canEmitGlobalAmbientDecl && container.nodeType == 95 /* Script */  && TypeScript.hasFlag(declFlags, 8 /* Ambient */ )) {
                return false;
            }
            return true;
        };
        DeclarationEmitter.prototype.canEmitPrePostAstSignature = function (declFlags, astWithPrePostCallback, preCallback) {
            if (this.ignoreCallbackAst) {
                TypeScript.CompilerDiagnostics.assert(this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch");
                this.ignoreCallbackAst = null;
                return false;
            } else if (preCallback && !this.canEmitSignature(declFlags, true, preCallback)) {
                this.ignoreCallbackAst = astWithPrePostCallback;
                return false;
            }
            return true;
        };
        DeclarationEmitter.prototype.getDeclFlagsString = function (declFlags, typeString) {
            var result = this.getIndentString();
            var accessorString = "";
            if (TypeScript.hasFlag(declFlags, 64 /* GetAccessor */ )) {
                accessorString = "get ";
            } else if (TypeScript.hasFlag(declFlags, 128 /* SetAccessor */ )) {
                accessorString = "set ";
            }
            var container = this.getAstDeclarationContainer();
            if (container.nodeType == 98 /* ModuleDeclaration */  && TypeScript.hasFlag((container).modFlags, 1024 /* IsWholeFile */ ) && TypeScript.hasFlag(declFlags, 1 /* Exported */ )) {
                result += "export ";
            }
            if (TypeScript.hasFlag(declFlags, 32 /* LocalStatic */ ) || TypeScript.hasFlag(declFlags, 16 /* Static */ )) {
                if (TypeScript.hasFlag(declFlags, 2 /* Private */ )) {
                    result += "private ";
                }
                result += "static " + accessorString;
            } else {
                if (TypeScript.hasFlag(declFlags, 2 /* Private */ )) {
                    result += "private " + accessorString;
                } else if (TypeScript.hasFlag(declFlags, 4 /* Public */ )) {
                    result += "public " + accessorString;
                } else {
                    if (accessorString == "") {
                        result += typeString + " ";
                    } else {
                        result += accessorString;
                    }
                }
            }
            return result;
        };
        DeclarationEmitter.prototype.emitDeclFlags = function (declFlags, typeString) {
            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));
        };
        DeclarationEmitter.prototype.canEmitTypeAnnotationSignature = function (declFlag) {
            if (typeof declFlag === "undefined") { declFlag = 0 /* None */ ; }
            return !TypeScript.hasFlag(declFlag, 2 /* Private */ );
        };
        DeclarationEmitter.prototype.pushDeclarationContainer = function (ast) {
            this.declarationContainerStack.push(ast);
        };
        DeclarationEmitter.prototype.popDeclarationContainer = function (ast) {
            TypeScript.CompilerDiagnostics.assert(ast != this.getAstDeclarationContainer(), 'Declaration container mismatch');
            this.declarationContainerStack.pop();
        };
        DeclarationEmitter.prototype.emitTypeNamesMember = function (memberName, emitIndent) {
            if (typeof emitIndent === "undefined") { emitIndent = false; }
            if (memberName.prefix == "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            } else if (memberName.prefix != "") {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }
            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.Write((memberName).text);
            } else {
                var ar = memberName;
                for(var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim == "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }
            if (memberName.suffix == "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            } else {
                this.declFile.Write(memberName.suffix);
            }
        };
        DeclarationEmitter.prototype.emitTypeSignature = function (type) {
            var containingScope = null;
            var declarationContainerAst = this.getAstDeclarationContainer();
            switch(declarationContainerAst.nodeType) {
                case 98 /* ModuleDeclaration */ :
                case 97 /* InterfaceDeclaration */ :
                case 73 /* FuncDecl */ :
                    if (declarationContainerAst.type) {
                        containingScope = declarationContainerAst.type.containedScope;
                    }
                    break;
                case 95 /* Script */ :
                    var script = declarationContainerAst;
                    if (script.bod) {
                        containingScope = script.bod.enclosingScope;
                    }
                    break;
                case 96 /* ClassDeclaration */ :
                    if (declarationContainerAst.type) {
                        containingScope = declarationContainerAst.type.instanceType.containedScope;
                    }
                    break;
                default:
                    TypeScript.CompilerDiagnostics.debugPrint("Unknown containing scope");
            }
            var typeNameMembers = type.getScopedTypeNameEx(containingScope);
            this.emitTypeNamesMember(typeNameMembers);
        };
        DeclarationEmitter.prototype.emitComment = function (comment) {
            var text = comment.getText();
            if (this.declFile.onNewLine) {
                this.emitIndent();
            } else if (!comment.isBlockComment) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }
            this.declFile.Write(text[0]);
            for(var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }
            if (comment.endsLine || !comment.isBlockComment) {
                this.declFile.WriteLine("");
            } else {
                this.declFile.Write(" ");
            }
        };
        DeclarationEmitter.prototype.emitDeclarationComments = function (astOrSymbol, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (!this.emitOptions.emitComments) {
                return;
            }
            var declComments = astOrSymbol.getDocComments();
            if (declComments.length > 0) {
                for(var i = 0; i < declComments.length; i++) {
                    this.emitComment(declComments[i]);
                }
                if (endLine) {
                    if (!this.declFile.onNewLine) {
                        this.declFile.WriteLine("");
                    }
                } else {
                    if (this.declFile.onNewLine) {
                        this.emitIndent();
                    }
                }
            }
        };
        DeclarationEmitter.prototype.VarDeclCallback = function (pre, varDecl) {
            if (pre && this.canEmitSignature(TypeScript.ToDeclFlags(varDecl.varFlags), false)) {
                var interfaceMember = (this.getAstDeclarationContainer().nodeType == 97 /* InterfaceDeclaration */ );
                this.emitDeclarationComments(varDecl);
                if (!interfaceMember) {
                    if (this.varListCount >= 0) {
                        this.emitDeclFlags(TypeScript.ToDeclFlags(varDecl.varFlags), "var");
                        this.varListCount = -this.varListCount;
                    }
                    this.declFile.Write(varDecl.id.text);
                } else {
                    this.emitIndent();
                    this.declFile.Write(varDecl.id.text);
                    if (TypeScript.hasFlag(varDecl.id.flags, 1024 /* OptionalName */ )) {
                        this.declFile.Write("?");
                    }
                }
                var type = null;
                if (varDecl.typeExpr && varDecl.typeExpr.type) {
                    type = varDecl.typeExpr.type;
                } else if (varDecl.sym) {
                    type = (varDecl.sym).getType();
                    if (type == this.checker.anyType) {
                        type = null;
                    }
                }
                if (type && this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(varDecl.varFlags))) {
                    this.declFile.Write(": ");
                    this.emitTypeSignature(type);
                }
                if (this.varListCount > 0) {
                    this.varListCount--;
                } else if (this.varListCount < 0) {
                    this.varListCount++;
                }
                if (this.varListCount < 0) {
                    this.declFile.Write(", ");
                } else {
                    this.declFile.WriteLine(";");
                }
            }
            return false;
        };
        DeclarationEmitter.prototype.BlockCallback = function (pre, block) {
            if (!block.isStatementBlock) {
                if (pre) {
                    this.varListCount = block.statements.members.length;
                } else {
                    this.varListCount = 0;
                }
                return true;
            }
            return false;
        };
        DeclarationEmitter.prototype.emitArgDecl = function (argDecl, funcDecl) {
            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(argDecl.id.text);
            if (argDecl.isOptionalArg()) {
                this.declFile.Write("?");
            }
            if ((argDecl.typeExpr || argDecl.type != this.checker.anyType) && this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.fncFlags))) {
                this.declFile.Write(": ");
                this.emitTypeSignature(argDecl.type);
            }
        };
        DeclarationEmitter.prototype.FuncDeclCallback = function (pre, funcDecl) {
            if (!pre) {
                return false;
            }
            if (funcDecl.isAccessor()) {
                return this.emitPropertyAccessorSignature(funcDecl);
            }
            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType == 97 /* InterfaceDeclaration */ );
            if (funcDecl.bod) {
                if (funcDecl.isConstructor) {
                    if (funcDecl.type.construct && funcDecl.type.construct.signatures.length > 1) {
                        return false;
                    }
                } else {
                    if (funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {
                        return false;
                    }
                }
            } else if (!isInterfaceMember && TypeScript.hasFlag(funcDecl.fncFlags, 2 /* Private */ ) && funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {
                var signatures = funcDecl.type.call.signatures;
                var firstSignature = signatures[0].declAST;
                if (firstSignature.bod) {
                    firstSignature = signatures[1].declAST;
                }
                if (firstSignature != funcDecl) {
                    return false;
                }
            }
            if (!this.canEmitSignature(TypeScript.ToDeclFlags(funcDecl.fncFlags), false)) {
                return false;
            }
            this.emitDeclarationComments(funcDecl);
            if (funcDecl.isConstructor) {
                this.emitIndent();
                this.declFile.Write("constructor");
            } else {
                var id = funcDecl.getNameText();
                if (!isInterfaceMember) {
                    this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.fncFlags), "function");
                    if (id != "__missing" || !funcDecl.name || !funcDecl.name.isMissing()) {
                        this.declFile.Write(id);
                    } else if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    }
                } else {
                    this.emitIndent();
                    if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {
                        this.declFile.Write(id);
                        if (TypeScript.hasFlag(funcDecl.name.flags, 1024 /* OptionalName */ )) {
                            this.declFile.Write("? ");
                        }
                    }
                }
            }
            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write("(");
            } else {
                this.declFile.Write("[");
            }
            this.indenter.increaseIndent();
            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }
                for(var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.arguments.members[i];
                    this.emitArgDecl(argDecl, funcDecl);
                    if (i < (argsLen - 1)) {
                        this.declFile.Write(", ");
                    }
                }
            }
            if (funcDecl.variableArgList) {
                var lastArg = funcDecl.arguments.members[funcDecl.arguments.members.length - 1];
                if (funcDecl.arguments.members.length > 1) {
                    this.declFile.Write(", ...");
                } else {
                    this.declFile.Write("...");
                }
                this.emitArgDecl(lastArg, funcDecl);
            }
            this.indenter.decreaseIndent();
            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write(")");
            } else {
                this.declFile.Write("]");
            }
            if (!funcDecl.isConstructor && (funcDecl.returnTypeAnnotation || funcDecl.signature.returnType.type != this.checker.anyType) && this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.fncFlags))) {
                this.declFile.Write(": ");
                this.emitTypeSignature(funcDecl.signature.returnType.type);
            }
            this.declFile.WriteLine(";");
            return false;
        };
        DeclarationEmitter.prototype.emitBaseList = function (bases, qual) {
            if (bases && (bases.members.length > 0)) {
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.members.length;
                for(var i = 0; i < basesLen; i++) {
                    var baseExpr = bases.members[i];
                    var baseSymbol = baseExpr.type.symbol;
                    var baseType = baseExpr.type;
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    this.emitTypeSignature(baseType);
                }
            }
        };
        DeclarationEmitter.prototype.emitPropertyAccessorSignature = function (funcDecl) {
            var accessorSymbol = funcDecl.accessorSymbol;
            if (accessorSymbol.getter && accessorSymbol.getter.declAST != funcDecl) {
                return false;
            }
            this.emitDeclarationComments(accessorSymbol);
            this.emitDeclFlags(TypeScript.ToDeclFlags(accessorSymbol.flags), "var");
            this.declFile.Write(funcDecl.name.text);
            var propertyType = accessorSymbol.getType();
            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(accessorSymbol.flags))) {
                this.declFile.Write(" : ");
                this.emitTypeSignature(propertyType);
            }
            this.declFile.WriteLine(";");
            return false;
        };
        DeclarationEmitter.prototype.emitClassMembersFromConstructorDefinition = function (funcDecl) {
            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }
                for(var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.arguments.members[i];
                    if (TypeScript.hasFlag(argDecl.varFlags, 512 /* Property */ )) {
                        this.emitDeclarationComments(argDecl);
                        this.emitDeclFlags(TypeScript.ToDeclFlags(argDecl.varFlags), "var");
                        this.declFile.Write(argDecl.id.text);
                        if (argDecl.typeExpr && this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(argDecl.varFlags))) {
                            this.declFile.Write(": ");
                            this.emitTypeSignature(argDecl.type);
                        }
                        this.declFile.WriteLine(";");
                    }
                }
            }
        };
        DeclarationEmitter.prototype.ClassDeclarationCallback = function (pre, classDecl) {
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(classDecl.varFlags), classDecl, pre)) {
                return false;
            }
            if (pre) {
                var className = classDecl.name.text;
                this.emitDeclarationComments(classDecl);
                this.emitDeclFlags(TypeScript.ToDeclFlags(classDecl.varFlags), "class");
                this.declFile.Write(className);
                this.emitBaseList(classDecl.extendsList, "extends");
                this.emitBaseList(classDecl.implementsList, "implements");
                this.declFile.WriteLine(" {");
                this.pushDeclarationContainer(classDecl);
                this.indenter.increaseIndent();
                if (classDecl.constructorDecl) {
                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);
                }
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(classDecl);
                this.emitIndent();
                this.declFile.WriteLine("}");
            }
            return true;
        };
        DeclarationEmitter.prototype.InterfaceDeclarationCallback = function (pre, interfaceDecl) {
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(interfaceDecl.varFlags), interfaceDecl, pre)) {
                return false;
            }
            if (pre) {
                var interfaceName = interfaceDecl.name.text;
                this.emitDeclarationComments(interfaceDecl);
                this.emitDeclFlags(TypeScript.ToDeclFlags(interfaceDecl.varFlags), "interface");
                this.declFile.Write(interfaceName);
                this.emitBaseList(interfaceDecl.extendsList, "extends");
                this.declFile.WriteLine(" {");
                this.indenter.increaseIndent();
                this.pushDeclarationContainer(interfaceDecl);
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(interfaceDecl);
                this.emitIndent();
                this.declFile.WriteLine("}");
            }
            return true;
        };
        DeclarationEmitter.prototype.ImportDeclarationCallback = function (pre, importDecl) {
            if (pre) {
                if ((this.declarationContainerStack[0]).isExternallyVisibleSymbol(importDecl.id.sym)) {
                    this.emitDeclarationComments(importDecl);
                    this.emitIndent();
                    this.declFile.Write("import ");
                    this.declFile.Write(importDecl.id.text + " = ");
                    if (importDecl.isDynamicImport) {
                        this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");
                    } else {
                        this.declFile.WriteLine(importDecl.getAliasName() + ";");
                    }
                }
            }
            return false;
        };
        DeclarationEmitter.prototype.emitEnumSignature = function (moduleDecl) {
            if (!this.canEmitSignature(TypeScript.ToDeclFlags(moduleDecl.modFlags))) {
                return false;
            }
            this.emitDeclarationComments(moduleDecl);
            this.emitDeclFlags(TypeScript.ToDeclFlags(moduleDecl.modFlags), "enum");
            this.declFile.WriteLine(moduleDecl.name.text + " {");
            this.indenter.increaseIndent();
            var membersLen = moduleDecl.members.members.length;
            for(var j = 1; j < membersLen; j++) {
                var memberDecl = moduleDecl.members.members[j];
                if (memberDecl.nodeType == 75 /* VarDecl */ ) {
                    this.emitDeclarationComments(memberDecl);
                    this.emitIndent();
                    this.declFile.WriteLine((memberDecl).id.text + ",");
                } else {
                    TypeScript.CompilerDiagnostics.assert(memberDecl.nodeType != 32 /* Asg */ , "We want to catch this");
                }
            }
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.declFile.WriteLine("}");
            return false;
        };
        DeclarationEmitter.prototype.ModuleDeclarationCallback = function (pre, moduleDecl) {
            if (TypeScript.hasFlag(moduleDecl.modFlags, 1024 /* IsWholeFile */ )) {
                if (TypeScript.hasFlag(moduleDecl.modFlags, 2048 /* IsDynamic */ )) {
                    if (pre) {
                        if (!this.emitOptions.outputMany) {
                            this.singleDeclFile = this.declFile;
                            TypeScript.CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");
                            var declareFileName = this.emitOptions.mapOutputFileName(TypeScript.stripQuotes(moduleDecl.name.sym.name), TypeScript.TypeScriptCompiler.mapToDTSFileName);
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);
                            try  {
                                this.declFile = new DeclFileWriter(this.emitOptions.ioHost.createFile(declareFileName, useUTF8InOutputfile));
                            } catch (ex) {
                                this.errorReporter.emitterError(null, ex.message);
                            }
                        }
                        this.pushDeclarationContainer(moduleDecl);
                    } else {
                        if (!this.emitOptions.outputMany) {
                            TypeScript.CompilerDiagnostics.assert(this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");
                            TypeScript.CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");
                            try  {
                                this.declFile.Close();
                            } catch (ex) {
                                this.errorReporter.emitterError(null, ex.message);
                            }
                            this.declFile = this.singleDeclFile;
                        }
                        this.popDeclarationContainer(moduleDecl);
                    }
                }
                return true;
            }
            if (moduleDecl.isEnum()) {
                if (pre) {
                    this.emitEnumSignature(moduleDecl);
                }
                return false;
            }
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(moduleDecl.modFlags), moduleDecl, pre)) {
                return false;
            }
            if (pre) {
                if (this.emitDottedModuleName()) {
                    this.dottedModuleEmit += ".";
                } else {
                    this.dottedModuleEmit = this.getDeclFlagsString(TypeScript.ToDeclFlags(moduleDecl.modFlags), "module");
                }
                this.dottedModuleEmit += moduleDecl.name.text;
                var isCurrentModuleDotted = (moduleDecl.members.members.length == 1 && moduleDecl.members.members[0].nodeType == 98 /* ModuleDeclaration */  && !(moduleDecl.members.members[0]).isEnum() && TypeScript.hasFlag((moduleDecl.members.members[0]).modFlags, 1 /* Exported */ ));
                var moduleDeclComments = moduleDecl.getDocComments();
                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments == null || moduleDeclComments.length == 0);
                this.isDottedModuleName.push(isCurrentModuleDotted);
                this.pushDeclarationContainer(moduleDecl);
                if (!isCurrentModuleDotted) {
                    this.emitDeclarationComments(moduleDecl);
                    this.declFile.Write(this.dottedModuleEmit);
                    this.declFile.WriteLine(" {");
                    this.indenter.increaseIndent();
                }
            } else {
                if (!this.emitDottedModuleName()) {
                    this.indenter.decreaseIndent();
                    this.emitIndent();
                    this.declFile.WriteLine("}");
                }
                this.popDeclarationContainer(moduleDecl);
                this.isDottedModuleName.pop();
            }
            return true;
        };
        DeclarationEmitter.prototype.ScriptCallback = function (pre, script) {
            if (pre) {
                if (this.emitOptions.outputMany) {
                    for(var i = 0; i < script.referencedFiles.length; i++) {
                        var referencePath = script.referencedFiles[i].path;
                        var declareFileName;
                        if (TypeScript.isRooted(referencePath)) {
                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScript.TypeScriptCompiler.mapToDTSFileName);
                        } else {
                            declareFileName = TypeScript.getDeclareFilePath(script.referencedFiles[i].path);
                        }
                        this.declFile.WriteLine('/// <reference path="' + declareFileName + '" />');
                    }
                }
                this.pushDeclarationContainer(script);
            } else {
                this.popDeclarationContainer(script);
            }
            return true;
        };
        DeclarationEmitter.prototype.DefaultCallback = function (pre, ast) {
            return !TypeScript.hasFlag(ast.flags, 64 /* IsStatement */ );
        };
        return DeclarationEmitter;
    })();
    TypeScript.DeclarationEmitter = DeclarationEmitter;    
})(TypeScript || (TypeScript = {}));
var SyntaxKind;
(function (SyntaxKind) {
    SyntaxKind._map = [];
    SyntaxKind._map[0] = "None";
    SyntaxKind.None = 0;
    SyntaxKind._map[1] = "List";
    SyntaxKind.List = 1;
    SyntaxKind._map[2] = "SeparatedList";
    SyntaxKind.SeparatedList = 2;
    SyntaxKind._map[3] = "TriviaList";
    SyntaxKind.TriviaList = 3;
    SyntaxKind._map[4] = "WhitespaceTrivia";
    SyntaxKind.WhitespaceTrivia = 4;
    SyntaxKind._map[5] = "NewLineTrivia";
    SyntaxKind.NewLineTrivia = 5;
    SyntaxKind._map[6] = "MultiLineCommentTrivia";
    SyntaxKind.MultiLineCommentTrivia = 6;
    SyntaxKind._map[7] = "SingleLineCommentTrivia";
    SyntaxKind.SingleLineCommentTrivia = 7;
    SyntaxKind._map[8] = "SkippedTextTrivia";
    SyntaxKind.SkippedTextTrivia = 8;
    SyntaxKind._map[9] = "ErrorToken";
    SyntaxKind.ErrorToken = 9;
    SyntaxKind._map[10] = "EndOfFileToken";
    SyntaxKind.EndOfFileToken = 10;
    SyntaxKind._map[11] = "IdentifierName";
    SyntaxKind.IdentifierName = 11;
    SyntaxKind._map[12] = "RegularExpressionLiteral";
    SyntaxKind.RegularExpressionLiteral = 12;
    SyntaxKind._map[13] = "NumericLiteral";
    SyntaxKind.NumericLiteral = 13;
    SyntaxKind._map[14] = "StringLiteral";
    SyntaxKind.StringLiteral = 14;
    SyntaxKind._map[15] = "BreakKeyword";
    SyntaxKind.BreakKeyword = 15;
    SyntaxKind._map[16] = "CaseKeyword";
    SyntaxKind.CaseKeyword = 16;
    SyntaxKind._map[17] = "CatchKeyword";
    SyntaxKind.CatchKeyword = 17;
    SyntaxKind._map[18] = "ContinueKeyword";
    SyntaxKind.ContinueKeyword = 18;
    SyntaxKind._map[19] = "DebuggerKeyword";
    SyntaxKind.DebuggerKeyword = 19;
    SyntaxKind._map[20] = "DefaultKeyword";
    SyntaxKind.DefaultKeyword = 20;
    SyntaxKind._map[21] = "DeleteKeyword";
    SyntaxKind.DeleteKeyword = 21;
    SyntaxKind._map[22] = "DoKeyword";
    SyntaxKind.DoKeyword = 22;
    SyntaxKind._map[23] = "ElseKeyword";
    SyntaxKind.ElseKeyword = 23;
    SyntaxKind._map[24] = "FalseKeyword";
    SyntaxKind.FalseKeyword = 24;
    SyntaxKind._map[25] = "FinallyKeyword";
    SyntaxKind.FinallyKeyword = 25;
    SyntaxKind._map[26] = "ForKeyword";
    SyntaxKind.ForKeyword = 26;
    SyntaxKind._map[27] = "FunctionKeyword";
    SyntaxKind.FunctionKeyword = 27;
    SyntaxKind._map[28] = "IfKeyword";
    SyntaxKind.IfKeyword = 28;
    SyntaxKind._map[29] = "InKeyword";
    SyntaxKind.InKeyword = 29;
    SyntaxKind._map[30] = "InstanceOfKeyword";
    SyntaxKind.InstanceOfKeyword = 30;
    SyntaxKind._map[31] = "NewKeyword";
    SyntaxKind.NewKeyword = 31;
    SyntaxKind._map[32] = "NullKeyword";
    SyntaxKind.NullKeyword = 32;
    SyntaxKind._map[33] = "ReturnKeyword";
    SyntaxKind.ReturnKeyword = 33;
    SyntaxKind._map[34] = "SwitchKeyword";
    SyntaxKind.SwitchKeyword = 34;
    SyntaxKind._map[35] = "ThisKeyword";
    SyntaxKind.ThisKeyword = 35;
    SyntaxKind._map[36] = "ThrowKeyword";
    SyntaxKind.ThrowKeyword = 36;
    SyntaxKind._map[37] = "TrueKeyword";
    SyntaxKind.TrueKeyword = 37;
    SyntaxKind._map[38] = "TryKeyword";
    SyntaxKind.TryKeyword = 38;
    SyntaxKind._map[39] = "TypeOfKeyword";
    SyntaxKind.TypeOfKeyword = 39;
    SyntaxKind._map[40] = "VarKeyword";
    SyntaxKind.VarKeyword = 40;
    SyntaxKind._map[41] = "VoidKeyword";
    SyntaxKind.VoidKeyword = 41;
    SyntaxKind._map[42] = "WhileKeyword";
    SyntaxKind.WhileKeyword = 42;
    SyntaxKind._map[43] = "WithKeyword";
    SyntaxKind.WithKeyword = 43;
    SyntaxKind._map[44] = "ClassKeyword";
    SyntaxKind.ClassKeyword = 44;
    SyntaxKind._map[45] = "ConstKeyword";
    SyntaxKind.ConstKeyword = 45;
    SyntaxKind._map[46] = "EnumKeyword";
    SyntaxKind.EnumKeyword = 46;
    SyntaxKind._map[47] = "ExportKeyword";
    SyntaxKind.ExportKeyword = 47;
    SyntaxKind._map[48] = "ExtendsKeyword";
    SyntaxKind.ExtendsKeyword = 48;
    SyntaxKind._map[49] = "ImportKeyword";
    SyntaxKind.ImportKeyword = 49;
    SyntaxKind._map[50] = "SuperKeyword";
    SyntaxKind.SuperKeyword = 50;
    SyntaxKind._map[51] = "ImplementsKeyword";
    SyntaxKind.ImplementsKeyword = 51;
    SyntaxKind._map[52] = "InterfaceKeyword";
    SyntaxKind.InterfaceKeyword = 52;
    SyntaxKind._map[53] = "LetKeyword";
    SyntaxKind.LetKeyword = 53;
    SyntaxKind._map[54] = "PackageKeyword";
    SyntaxKind.PackageKeyword = 54;
    SyntaxKind._map[55] = "PrivateKeyword";
    SyntaxKind.PrivateKeyword = 55;
    SyntaxKind._map[56] = "ProtectedKeyword";
    SyntaxKind.ProtectedKeyword = 56;
    SyntaxKind._map[57] = "PublicKeyword";
    SyntaxKind.PublicKeyword = 57;
    SyntaxKind._map[58] = "StaticKeyword";
    SyntaxKind.StaticKeyword = 58;
    SyntaxKind._map[59] = "YieldKeyword";
    SyntaxKind.YieldKeyword = 59;
    SyntaxKind._map[60] = "AnyKeyword";
    SyntaxKind.AnyKeyword = 60;
    SyntaxKind._map[61] = "BooleanKeyword";
    SyntaxKind.BooleanKeyword = 61;
    SyntaxKind._map[62] = "BoolKeyword";
    SyntaxKind.BoolKeyword = 62;
    SyntaxKind._map[63] = "ConstructorKeyword";
    SyntaxKind.ConstructorKeyword = 63;
    SyntaxKind._map[64] = "DeclareKeyword";
    SyntaxKind.DeclareKeyword = 64;
    SyntaxKind._map[65] = "GetKeyword";
    SyntaxKind.GetKeyword = 65;
    SyntaxKind._map[66] = "ModuleKeyword";
    SyntaxKind.ModuleKeyword = 66;
    SyntaxKind._map[67] = "NumberKeyword";
    SyntaxKind.NumberKeyword = 67;
    SyntaxKind._map[68] = "SetKeyword";
    SyntaxKind.SetKeyword = 68;
    SyntaxKind._map[69] = "StringKeyword";
    SyntaxKind.StringKeyword = 69;
    SyntaxKind._map[70] = "OpenBraceToken";
    SyntaxKind.OpenBraceToken = 70;
    SyntaxKind._map[71] = "CloseBraceToken";
    SyntaxKind.CloseBraceToken = 71;
    SyntaxKind._map[72] = "OpenParenToken";
    SyntaxKind.OpenParenToken = 72;
    SyntaxKind._map[73] = "CloseParenToken";
    SyntaxKind.CloseParenToken = 73;
    SyntaxKind._map[74] = "OpenBracketToken";
    SyntaxKind.OpenBracketToken = 74;
    SyntaxKind._map[75] = "CloseBracketToken";
    SyntaxKind.CloseBracketToken = 75;
    SyntaxKind._map[76] = "DotToken";
    SyntaxKind.DotToken = 76;
    SyntaxKind._map[77] = "DotDotDotToken";
    SyntaxKind.DotDotDotToken = 77;
    SyntaxKind._map[78] = "SemicolonToken";
    SyntaxKind.SemicolonToken = 78;
    SyntaxKind._map[79] = "CommaToken";
    SyntaxKind.CommaToken = 79;
    SyntaxKind._map[80] = "LessThanToken";
    SyntaxKind.LessThanToken = 80;
    SyntaxKind._map[81] = "GreaterThanToken";
    SyntaxKind.GreaterThanToken = 81;
    SyntaxKind._map[82] = "LessThanEqualsToken";
    SyntaxKind.LessThanEqualsToken = 82;
    SyntaxKind._map[83] = "GreaterThanEqualsToken";
    SyntaxKind.GreaterThanEqualsToken = 83;
    SyntaxKind._map[84] = "EqualsEqualsToken";
    SyntaxKind.EqualsEqualsToken = 84;
    SyntaxKind._map[85] = "EqualsGreaterThanToken";
    SyntaxKind.EqualsGreaterThanToken = 85;
    SyntaxKind._map[86] = "ExclamationEqualsToken";
    SyntaxKind.ExclamationEqualsToken = 86;
    SyntaxKind._map[87] = "EqualsEqualsEqualsToken";
    SyntaxKind.EqualsEqualsEqualsToken = 87;
    SyntaxKind._map[88] = "ExclamationEqualsEqualsToken";
    SyntaxKind.ExclamationEqualsEqualsToken = 88;
    SyntaxKind._map[89] = "PlusToken";
    SyntaxKind.PlusToken = 89;
    SyntaxKind._map[90] = "MinusToken";
    SyntaxKind.MinusToken = 90;
    SyntaxKind._map[91] = "AsteriskToken";
    SyntaxKind.AsteriskToken = 91;
    SyntaxKind._map[92] = "PercentToken";
    SyntaxKind.PercentToken = 92;
    SyntaxKind._map[93] = "PlusPlusToken";
    SyntaxKind.PlusPlusToken = 93;
    SyntaxKind._map[94] = "MinusMinusToken";
    SyntaxKind.MinusMinusToken = 94;
    SyntaxKind._map[95] = "LessThanLessThanToken";
    SyntaxKind.LessThanLessThanToken = 95;
    SyntaxKind._map[96] = "GreaterThanGreaterThanToken";
    SyntaxKind.GreaterThanGreaterThanToken = 96;
    SyntaxKind._map[97] = "GreaterThanGreaterThanGreaterThanToken";
    SyntaxKind.GreaterThanGreaterThanGreaterThanToken = 97;
    SyntaxKind._map[98] = "AmpersandToken";
    SyntaxKind.AmpersandToken = 98;
    SyntaxKind._map[99] = "BarToken";
    SyntaxKind.BarToken = 99;
    SyntaxKind._map[100] = "CaretToken";
    SyntaxKind.CaretToken = 100;
    SyntaxKind._map[101] = "ExclamationToken";
    SyntaxKind.ExclamationToken = 101;
    SyntaxKind._map[102] = "TildeToken";
    SyntaxKind.TildeToken = 102;
    SyntaxKind._map[103] = "AmpersandAmpersandToken";
    SyntaxKind.AmpersandAmpersandToken = 103;
    SyntaxKind._map[104] = "BarBarToken";
    SyntaxKind.BarBarToken = 104;
    SyntaxKind._map[105] = "QuestionToken";
    SyntaxKind.QuestionToken = 105;
    SyntaxKind._map[106] = "ColonToken";
    SyntaxKind.ColonToken = 106;
    SyntaxKind._map[107] = "EqualsToken";
    SyntaxKind.EqualsToken = 107;
    SyntaxKind._map[108] = "PlusEqualsToken";
    SyntaxKind.PlusEqualsToken = 108;
    SyntaxKind._map[109] = "MinusEqualsToken";
    SyntaxKind.MinusEqualsToken = 109;
    SyntaxKind._map[110] = "AsteriskEqualsToken";
    SyntaxKind.AsteriskEqualsToken = 110;
    SyntaxKind._map[111] = "PercentEqualsToken";
    SyntaxKind.PercentEqualsToken = 111;
    SyntaxKind._map[112] = "LessThanLessThanEqualsToken";
    SyntaxKind.LessThanLessThanEqualsToken = 112;
    SyntaxKind._map[113] = "GreaterThanGreaterThanEqualsToken";
    SyntaxKind.GreaterThanGreaterThanEqualsToken = 113;
    SyntaxKind._map[114] = "GreaterThanGreaterThanGreaterThanEqualsToken";
    SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken = 114;
    SyntaxKind._map[115] = "AmpersandEqualsToken";
    SyntaxKind.AmpersandEqualsToken = 115;
    SyntaxKind._map[116] = "BarEqualsToken";
    SyntaxKind.BarEqualsToken = 116;
    SyntaxKind._map[117] = "CaretEqualsToken";
    SyntaxKind.CaretEqualsToken = 117;
    SyntaxKind._map[118] = "SlashToken";
    SyntaxKind.SlashToken = 118;
    SyntaxKind._map[119] = "SlashEqualsToken";
    SyntaxKind.SlashEqualsToken = 119;
    SyntaxKind._map[120] = "SourceUnit";
    SyntaxKind.SourceUnit = 120;
    SyntaxKind._map[121] = "QualifiedName";
    SyntaxKind.QualifiedName = 121;
    SyntaxKind._map[122] = "ObjectType";
    SyntaxKind.ObjectType = 122;
    SyntaxKind._map[123] = "FunctionType";
    SyntaxKind.FunctionType = 123;
    SyntaxKind._map[124] = "ArrayType";
    SyntaxKind.ArrayType = 124;
    SyntaxKind._map[125] = "ConstructorType";
    SyntaxKind.ConstructorType = 125;
    SyntaxKind._map[126] = "GenericType";
    SyntaxKind.GenericType = 126;
    SyntaxKind._map[127] = "InterfaceDeclaration";
    SyntaxKind.InterfaceDeclaration = 127;
    SyntaxKind._map[128] = "FunctionDeclaration";
    SyntaxKind.FunctionDeclaration = 128;
    SyntaxKind._map[129] = "ModuleDeclaration";
    SyntaxKind.ModuleDeclaration = 129;
    SyntaxKind._map[130] = "ClassDeclaration";
    SyntaxKind.ClassDeclaration = 130;
    SyntaxKind._map[131] = "EnumDeclaration";
    SyntaxKind.EnumDeclaration = 131;
    SyntaxKind._map[132] = "ImportDeclaration";
    SyntaxKind.ImportDeclaration = 132;
    SyntaxKind._map[133] = "MemberFunctionDeclaration";
    SyntaxKind.MemberFunctionDeclaration = 133;
    SyntaxKind._map[134] = "MemberVariableDeclaration";
    SyntaxKind.MemberVariableDeclaration = 134;
    SyntaxKind._map[135] = "ConstructorDeclaration";
    SyntaxKind.ConstructorDeclaration = 135;
    SyntaxKind._map[136] = "GetMemberAccessorDeclaration";
    SyntaxKind.GetMemberAccessorDeclaration = 136;
    SyntaxKind._map[137] = "SetMemberAccessorDeclaration";
    SyntaxKind.SetMemberAccessorDeclaration = 137;
    SyntaxKind._map[138] = "PropertySignature";
    SyntaxKind.PropertySignature = 138;
    SyntaxKind._map[139] = "CallSignature";
    SyntaxKind.CallSignature = 139;
    SyntaxKind._map[140] = "ConstructSignature";
    SyntaxKind.ConstructSignature = 140;
    SyntaxKind._map[141] = "IndexSignature";
    SyntaxKind.IndexSignature = 141;
    SyntaxKind._map[142] = "FunctionSignature";
    SyntaxKind.FunctionSignature = 142;
    SyntaxKind._map[143] = "Block";
    SyntaxKind.Block = 143;
    SyntaxKind._map[144] = "IfStatement";
    SyntaxKind.IfStatement = 144;
    SyntaxKind._map[145] = "VariableStatement";
    SyntaxKind.VariableStatement = 145;
    SyntaxKind._map[146] = "ExpressionStatement";
    SyntaxKind.ExpressionStatement = 146;
    SyntaxKind._map[147] = "ReturnStatement";
    SyntaxKind.ReturnStatement = 147;
    SyntaxKind._map[148] = "SwitchStatement";
    SyntaxKind.SwitchStatement = 148;
    SyntaxKind._map[149] = "BreakStatement";
    SyntaxKind.BreakStatement = 149;
    SyntaxKind._map[150] = "ContinueStatement";
    SyntaxKind.ContinueStatement = 150;
    SyntaxKind._map[151] = "ForStatement";
    SyntaxKind.ForStatement = 151;
    SyntaxKind._map[152] = "ForInStatement";
    SyntaxKind.ForInStatement = 152;
    SyntaxKind._map[153] = "EmptyStatement";
    SyntaxKind.EmptyStatement = 153;
    SyntaxKind._map[154] = "ThrowStatement";
    SyntaxKind.ThrowStatement = 154;
    SyntaxKind._map[155] = "WhileStatement";
    SyntaxKind.WhileStatement = 155;
    SyntaxKind._map[156] = "TryStatement";
    SyntaxKind.TryStatement = 156;
    SyntaxKind._map[157] = "LabeledStatement";
    SyntaxKind.LabeledStatement = 157;
    SyntaxKind._map[158] = "DoStatement";
    SyntaxKind.DoStatement = 158;
    SyntaxKind._map[159] = "DebuggerStatement";
    SyntaxKind.DebuggerStatement = 159;
    SyntaxKind._map[160] = "WithStatement";
    SyntaxKind.WithStatement = 160;
    SyntaxKind._map[161] = "PlusExpression";
    SyntaxKind.PlusExpression = 161;
    SyntaxKind._map[162] = "NegateExpression";
    SyntaxKind.NegateExpression = 162;
    SyntaxKind._map[163] = "BitwiseNotExpression";
    SyntaxKind.BitwiseNotExpression = 163;
    SyntaxKind._map[164] = "LogicalNotExpression";
    SyntaxKind.LogicalNotExpression = 164;
    SyntaxKind._map[165] = "PreIncrementExpression";
    SyntaxKind.PreIncrementExpression = 165;
    SyntaxKind._map[166] = "PreDecrementExpression";
    SyntaxKind.PreDecrementExpression = 166;
    SyntaxKind._map[167] = "DeleteExpression";
    SyntaxKind.DeleteExpression = 167;
    SyntaxKind._map[168] = "TypeOfExpression";
    SyntaxKind.TypeOfExpression = 168;
    SyntaxKind._map[169] = "VoidExpression";
    SyntaxKind.VoidExpression = 169;
    SyntaxKind._map[170] = "CommaExpression";
    SyntaxKind.CommaExpression = 170;
    SyntaxKind._map[171] = "AssignmentExpression";
    SyntaxKind.AssignmentExpression = 171;
    SyntaxKind._map[172] = "AddAssignmentExpression";
    SyntaxKind.AddAssignmentExpression = 172;
    SyntaxKind._map[173] = "SubtractAssignmentExpression";
    SyntaxKind.SubtractAssignmentExpression = 173;
    SyntaxKind._map[174] = "MultiplyAssignmentExpression";
    SyntaxKind.MultiplyAssignmentExpression = 174;
    SyntaxKind._map[175] = "DivideAssignmentExpression";
    SyntaxKind.DivideAssignmentExpression = 175;
    SyntaxKind._map[176] = "ModuloAssignmentExpression";
    SyntaxKind.ModuloAssignmentExpression = 176;
    SyntaxKind._map[177] = "AndAssignmentExpression";
    SyntaxKind.AndAssignmentExpression = 177;
    SyntaxKind._map[178] = "ExclusiveOrAssignmentExpression";
    SyntaxKind.ExclusiveOrAssignmentExpression = 178;
    SyntaxKind._map[179] = "OrAssignmentExpression";
    SyntaxKind.OrAssignmentExpression = 179;
    SyntaxKind._map[180] = "LeftShiftAssignmentExpression";
    SyntaxKind.LeftShiftAssignmentExpression = 180;
    SyntaxKind._map[181] = "SignedRightShiftAssignmentExpression";
    SyntaxKind.SignedRightShiftAssignmentExpression = 181;
    SyntaxKind._map[182] = "UnsignedRightShiftAssignmentExpression";
    SyntaxKind.UnsignedRightShiftAssignmentExpression = 182;
    SyntaxKind._map[183] = "ConditionalExpression";
    SyntaxKind.ConditionalExpression = 183;
    SyntaxKind._map[184] = "LogicalOrExpression";
    SyntaxKind.LogicalOrExpression = 184;
    SyntaxKind._map[185] = "LogicalAndExpression";
    SyntaxKind.LogicalAndExpression = 185;
    SyntaxKind._map[186] = "BitwiseOrExpression";
    SyntaxKind.BitwiseOrExpression = 186;
    SyntaxKind._map[187] = "BitwiseExclusiveOrExpression";
    SyntaxKind.BitwiseExclusiveOrExpression = 187;
    SyntaxKind._map[188] = "BitwiseAndExpression";
    SyntaxKind.BitwiseAndExpression = 188;
    SyntaxKind._map[189] = "EqualsWithTypeConversionExpression";
    SyntaxKind.EqualsWithTypeConversionExpression = 189;
    SyntaxKind._map[190] = "NotEqualsWithTypeConversionExpression";
    SyntaxKind.NotEqualsWithTypeConversionExpression = 190;
    SyntaxKind._map[191] = "EqualsExpression";
    SyntaxKind.EqualsExpression = 191;
    SyntaxKind._map[192] = "NotEqualsExpression";
    SyntaxKind.NotEqualsExpression = 192;
    SyntaxKind._map[193] = "LessThanExpression";
    SyntaxKind.LessThanExpression = 193;
    SyntaxKind._map[194] = "GreaterThanExpression";
    SyntaxKind.GreaterThanExpression = 194;
    SyntaxKind._map[195] = "LessThanOrEqualExpression";
    SyntaxKind.LessThanOrEqualExpression = 195;
    SyntaxKind._map[196] = "GreaterThanOrEqualExpression";
    SyntaxKind.GreaterThanOrEqualExpression = 196;
    SyntaxKind._map[197] = "InstanceOfExpression";
    SyntaxKind.InstanceOfExpression = 197;
    SyntaxKind._map[198] = "InExpression";
    SyntaxKind.InExpression = 198;
    SyntaxKind._map[199] = "LeftShiftExpression";
    SyntaxKind.LeftShiftExpression = 199;
    SyntaxKind._map[200] = "SignedRightShiftExpression";
    SyntaxKind.SignedRightShiftExpression = 200;
    SyntaxKind._map[201] = "UnsignedRightShiftExpression";
    SyntaxKind.UnsignedRightShiftExpression = 201;
    SyntaxKind._map[202] = "MultiplyExpression";
    SyntaxKind.MultiplyExpression = 202;
    SyntaxKind._map[203] = "DivideExpression";
    SyntaxKind.DivideExpression = 203;
    SyntaxKind._map[204] = "ModuloExpression";
    SyntaxKind.ModuloExpression = 204;
    SyntaxKind._map[205] = "AddExpression";
    SyntaxKind.AddExpression = 205;
    SyntaxKind._map[206] = "SubtractExpression";
    SyntaxKind.SubtractExpression = 206;
    SyntaxKind._map[207] = "PostIncrementExpression";
    SyntaxKind.PostIncrementExpression = 207;
    SyntaxKind._map[208] = "PostDecrementExpression";
    SyntaxKind.PostDecrementExpression = 208;
    SyntaxKind._map[209] = "MemberAccessExpression";
    SyntaxKind.MemberAccessExpression = 209;
    SyntaxKind._map[210] = "InvocationExpression";
    SyntaxKind.InvocationExpression = 210;
    SyntaxKind._map[211] = "ArrayLiteralExpression";
    SyntaxKind.ArrayLiteralExpression = 211;
    SyntaxKind._map[212] = "ObjectLiteralExpression";
    SyntaxKind.ObjectLiteralExpression = 212;
    SyntaxKind._map[213] = "ObjectCreationExpression";
    SyntaxKind.ObjectCreationExpression = 213;
    SyntaxKind._map[214] = "ParenthesizedExpression";
    SyntaxKind.ParenthesizedExpression = 214;
    SyntaxKind._map[215] = "ParenthesizedArrowFunctionExpression";
    SyntaxKind.ParenthesizedArrowFunctionExpression = 215;
    SyntaxKind._map[216] = "SimpleArrowFunctionExpression";
    SyntaxKind.SimpleArrowFunctionExpression = 216;
    SyntaxKind._map[217] = "CastExpression";
    SyntaxKind.CastExpression = 217;
    SyntaxKind._map[218] = "ElementAccessExpression";
    SyntaxKind.ElementAccessExpression = 218;
    SyntaxKind._map[219] = "FunctionExpression";
    SyntaxKind.FunctionExpression = 219;
    SyntaxKind._map[220] = "OmittedExpression";
    SyntaxKind.OmittedExpression = 220;
    SyntaxKind._map[221] = "VariableDeclaration";
    SyntaxKind.VariableDeclaration = 221;
    SyntaxKind._map[222] = "VariableDeclarator";
    SyntaxKind.VariableDeclarator = 222;
    SyntaxKind._map[223] = "ArgumentList";
    SyntaxKind.ArgumentList = 223;
    SyntaxKind._map[224] = "ParameterList";
    SyntaxKind.ParameterList = 224;
    SyntaxKind._map[225] = "TypeArgumentList";
    SyntaxKind.TypeArgumentList = 225;
    SyntaxKind._map[226] = "TypeParameterList";
    SyntaxKind.TypeParameterList = 226;
    SyntaxKind._map[227] = "ImplementsClause";
    SyntaxKind.ImplementsClause = 227;
    SyntaxKind._map[228] = "ExtendsClause";
    SyntaxKind.ExtendsClause = 228;
    SyntaxKind._map[229] = "EqualsValueClause";
    SyntaxKind.EqualsValueClause = 229;
    SyntaxKind._map[230] = "CaseSwitchClause";
    SyntaxKind.CaseSwitchClause = 230;
    SyntaxKind._map[231] = "DefaultSwitchClause";
    SyntaxKind.DefaultSwitchClause = 231;
    SyntaxKind._map[232] = "ElseClause";
    SyntaxKind.ElseClause = 232;
    SyntaxKind._map[233] = "CatchClause";
    SyntaxKind.CatchClause = 233;
    SyntaxKind._map[234] = "FinallyClause";
    SyntaxKind.FinallyClause = 234;
    SyntaxKind._map[235] = "TypeParameter";
    SyntaxKind.TypeParameter = 235;
    SyntaxKind._map[236] = "Constraint";
    SyntaxKind.Constraint = 236;
    SyntaxKind._map[237] = "Parameter";
    SyntaxKind.Parameter = 237;
    SyntaxKind._map[238] = "TypeAnnotation";
    SyntaxKind.TypeAnnotation = 238;
    SyntaxKind._map[239] = "SimplePropertyAssignment";
    SyntaxKind.SimplePropertyAssignment = 239;
    SyntaxKind._map[240] = "ExternalModuleReference";
    SyntaxKind.ExternalModuleReference = 240;
    SyntaxKind._map[241] = "ModuleNameModuleReference";
    SyntaxKind.ModuleNameModuleReference = 241;
    SyntaxKind._map[242] = "GetAccessorPropertyAssignment";
    SyntaxKind.GetAccessorPropertyAssignment = 242;
    SyntaxKind._map[243] = "SetAccessorPropertyAssignment";
    SyntaxKind.SetAccessorPropertyAssignment = 243;
    SyntaxKind.FirstStandardKeyword = SyntaxKind.BreakKeyword;
    SyntaxKind.LastStandardKeyword = SyntaxKind.WithKeyword;
    SyntaxKind.FirstFutureReservedKeyword = SyntaxKind.ClassKeyword;
    SyntaxKind.LastFutureReservedKeyword = SyntaxKind.SuperKeyword;
    SyntaxKind.FirstFutureReservedStrictKeyword = SyntaxKind.ImplementsKeyword;
    SyntaxKind.LastFutureReservedStrictKeyword = SyntaxKind.YieldKeyword;
    SyntaxKind.FirstTypeScriptKeyword = SyntaxKind.AnyKeyword;
    SyntaxKind.LastTypeScriptKeyword = SyntaxKind.StringKeyword;
    SyntaxKind.FirstKeyword = SyntaxKind.FirstStandardKeyword;
    SyntaxKind.LastKeyword = SyntaxKind.LastTypeScriptKeyword;
    SyntaxKind.FirstToken = SyntaxKind.ErrorToken;
    SyntaxKind.LastToken = SyntaxKind.SlashEqualsToken;
    SyntaxKind.FirstPunctuation = SyntaxKind.OpenBraceToken;
    SyntaxKind.LastPunctuation = SyntaxKind.SlashEqualsToken;
    SyntaxKind.FirstFixedWidth = SyntaxKind.FirstKeyword;
    SyntaxKind.LastFixedWidth = SyntaxKind.LastPunctuation;
})(SyntaxKind || (SyntaxKind = {}));
var SyntaxRewriter = (function () {
    function SyntaxRewriter() { }
    SyntaxRewriter.prototype.visitToken = function (token) {
        return token;
    };
    SyntaxRewriter.prototype.visitNode = function (node) {
        return node.accept(this);
    };
    SyntaxRewriter.prototype.visitNodeOrToken = function (node) {
        return node.isToken() ? this.visitToken(node) : this.visitNode(node);
    };
    SyntaxRewriter.prototype.visitList = function (list) {
        var newItems = null;
        for(var i = 0, n = list.childCount(); i < n; i++) {
            var item = list.childAt(i);
            var newItem = this.visitNodeOrToken(item);
            if (item !== newItem && newItems === null) {
                newItems = [];
                for(var j = 0; j < i; j++) {
                    newItems.push(list.childAt(j));
                }
            }
            if (newItems) {
                newItems.push(newItem);
            }
        }
        return newItems === null ? list : Syntax.list(newItems);
    };
    SyntaxRewriter.prototype.visitSeparatedList = function (list) {
        var newItems = null;
        for(var i = 0, n = list.childCount(); i < n; i++) {
            var item = list.childAt(i);
            var newItem = item.isToken() ? this.visitToken(item) : this.visitNode(item);
            if (item !== newItem && newItems === null) {
                newItems = [];
                for(var j = 0; j < i; j++) {
                    newItems.push(list.childAt(j));
                }
            }
            if (newItems) {
                newItems.push(newItem);
            }
        }
        return newItems === null ? list : Syntax.separatedList(newItems);
    };
    SyntaxRewriter.prototype.visitSourceUnit = function (node) {
        return node.update(this.visitList(node.moduleElements), this.visitToken(node.endOfFileToken));
    };
    SyntaxRewriter.prototype.visitExternalModuleReference = function (node) {
        return node.update(this.visitToken(node.moduleKeyword), this.visitToken(node.openParenToken), this.visitToken(node.stringLiteral), this.visitToken(node.closeParenToken));
    };
    SyntaxRewriter.prototype.visitModuleNameModuleReference = function (node) {
        return node.update(this.visitNodeOrToken(node.moduleName));
    };
    SyntaxRewriter.prototype.visitImportDeclaration = function (node) {
        return node.update(this.visitToken(node.importKeyword), this.visitToken(node.identifier), this.visitToken(node.equalsToken), this.visitNode(node.moduleReference), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitClassDeclaration = function (node) {
        return node.update(node.exportKeyword === null ? null : this.visitToken(node.exportKeyword), node.declareKeyword === null ? null : this.visitToken(node.declareKeyword), this.visitToken(node.classKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), node.extendsClause === null ? null : this.visitNode(node.extendsClause), node.implementsClause === null ? null : this.visitNode(node.implementsClause), this.visitToken(node.openBraceToken), this.visitList(node.classElements), this.visitToken(node.closeBraceToken));
    };
    SyntaxRewriter.prototype.visitInterfaceDeclaration = function (node) {
        return node.update(node.exportKeyword === null ? null : this.visitToken(node.exportKeyword), this.visitToken(node.interfaceKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), node.extendsClause === null ? null : this.visitNode(node.extendsClause), this.visitNode(node.body));
    };
    SyntaxRewriter.prototype.visitExtendsClause = function (node) {
        return node.update(this.visitToken(node.extendsKeyword), this.visitSeparatedList(node.typeNames));
    };
    SyntaxRewriter.prototype.visitImplementsClause = function (node) {
        return node.update(this.visitToken(node.implementsKeyword), this.visitSeparatedList(node.typeNames));
    };
    SyntaxRewriter.prototype.visitModuleDeclaration = function (node) {
        return node.update(node.exportKeyword === null ? null : this.visitToken(node.exportKeyword), node.declareKeyword === null ? null : this.visitToken(node.declareKeyword), this.visitToken(node.moduleKeyword), node.moduleName === null ? null : this.visitNodeOrToken(node.moduleName), node.stringLiteral === null ? null : this.visitToken(node.stringLiteral), this.visitToken(node.openBraceToken), this.visitList(node.moduleElements), this.visitToken(node.closeBraceToken));
    };
    SyntaxRewriter.prototype.visitFunctionDeclaration = function (node) {
        return node.update(node.exportKeyword === null ? null : this.visitToken(node.exportKeyword), node.declareKeyword === null ? null : this.visitToken(node.declareKeyword), this.visitToken(node.functionKeyword), this.visitNode(node.functionSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitVariableStatement = function (node) {
        return node.update(node.exportKeyword === null ? null : this.visitToken(node.exportKeyword), node.declareKeyword === null ? null : this.visitToken(node.declareKeyword), this.visitNode(node.variableDeclaration), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitVariableDeclaration = function (node) {
        return node.update(this.visitToken(node.varKeyword), this.visitSeparatedList(node.variableDeclarators));
    };
    SyntaxRewriter.prototype.visitVariableDeclarator = function (node) {
        return node.update(this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
    };
    SyntaxRewriter.prototype.visitEqualsValueClause = function (node) {
        return node.update(this.visitToken(node.equalsToken), this.visitNodeOrToken(node.value));
    };
    SyntaxRewriter.prototype.visitPrefixUnaryExpression = function (node) {
        return node.update(node.kind(), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.operand));
    };
    SyntaxRewriter.prototype.visitArrayLiteralExpression = function (node) {
        return node.update(this.visitToken(node.openBracketToken), this.visitSeparatedList(node.expressions), this.visitToken(node.closeBracketToken));
    };
    SyntaxRewriter.prototype.visitOmittedExpression = function (node) {
        return node;
    };
    SyntaxRewriter.prototype.visitParenthesizedExpression = function (node) {
        return node.update(this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken));
    };
    SyntaxRewriter.prototype.visitSimpleArrowFunctionExpression = function (node) {
        return node.update(this.visitToken(node.identifier), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
    };
    SyntaxRewriter.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
        return node.update(this.visitNode(node.callSignature), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
    };
    SyntaxRewriter.prototype.visitQualifiedName = function (node) {
        return node.update(this.visitNodeOrToken(node.left), this.visitToken(node.dotToken), this.visitToken(node.right));
    };
    SyntaxRewriter.prototype.visitTypeArgumentList = function (node) {
        return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeArguments), this.visitToken(node.greaterThanToken));
    };
    SyntaxRewriter.prototype.visitConstructorType = function (node) {
        return node.update(this.visitToken(node.newKeyword), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
    };
    SyntaxRewriter.prototype.visitFunctionType = function (node) {
        return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
    };
    SyntaxRewriter.prototype.visitObjectType = function (node) {
        return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.typeMembers), this.visitToken(node.closeBraceToken));
    };
    SyntaxRewriter.prototype.visitArrayType = function (node) {
        return node.update(this.visitNodeOrToken(node.type), this.visitToken(node.openBracketToken), this.visitToken(node.closeBracketToken));
    };
    SyntaxRewriter.prototype.visitGenericType = function (node) {
        return node.update(this.visitNodeOrToken(node.name), this.visitNode(node.typeArgumentList));
    };
    SyntaxRewriter.prototype.visitTypeAnnotation = function (node) {
        return node.update(this.visitToken(node.colonToken), this.visitNodeOrToken(node.type));
    };
    SyntaxRewriter.prototype.visitBlock = function (node) {
        return node.update(this.visitToken(node.openBraceToken), this.visitList(node.statements), this.visitToken(node.closeBraceToken));
    };
    SyntaxRewriter.prototype.visitParameter = function (node) {
        return node.update(node.dotDotDotToken === null ? null : this.visitToken(node.dotDotDotToken), node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), this.visitToken(node.identifier), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
    };
    SyntaxRewriter.prototype.visitMemberAccessExpression = function (node) {
        return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.dotToken), this.visitToken(node.name));
    };
    SyntaxRewriter.prototype.visitPostfixUnaryExpression = function (node) {
        return node.update(node.kind(), this.visitNodeOrToken(node.operand), this.visitToken(node.operatorToken));
    };
    SyntaxRewriter.prototype.visitElementAccessExpression = function (node) {
        return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.openBracketToken), this.visitNodeOrToken(node.argumentExpression), this.visitToken(node.closeBracketToken));
    };
    SyntaxRewriter.prototype.visitInvocationExpression = function (node) {
        return node.update(this.visitNodeOrToken(node.expression), this.visitNode(node.argumentList));
    };
    SyntaxRewriter.prototype.visitArgumentList = function (node) {
        return node.update(node.typeArgumentList === null ? null : this.visitNode(node.typeArgumentList), this.visitToken(node.openParenToken), this.visitSeparatedList(node.arguments), this.visitToken(node.closeParenToken));
    };
    SyntaxRewriter.prototype.visitBinaryExpression = function (node) {
        return node.update(node.kind(), this.visitNodeOrToken(node.left), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.right));
    };
    SyntaxRewriter.prototype.visitConditionalExpression = function (node) {
        return node.update(this.visitNodeOrToken(node.condition), this.visitToken(node.questionToken), this.visitNodeOrToken(node.whenTrue), this.visitToken(node.colonToken), this.visitNodeOrToken(node.whenFalse));
    };
    SyntaxRewriter.prototype.visitConstructSignature = function (node) {
        return node.update(this.visitToken(node.newKeyword), this.visitNode(node.callSignature));
    };
    SyntaxRewriter.prototype.visitFunctionSignature = function (node) {
        return node.update(this.visitToken(node.identifier), node.questionToken === null ? null : this.visitToken(node.questionToken), this.visitNode(node.callSignature));
    };
    SyntaxRewriter.prototype.visitIndexSignature = function (node) {
        return node.update(this.visitToken(node.openBracketToken), this.visitNode(node.parameter), this.visitToken(node.closeBracketToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
    };
    SyntaxRewriter.prototype.visitPropertySignature = function (node) {
        return node.update(this.visitToken(node.identifier), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
    };
    SyntaxRewriter.prototype.visitParameterList = function (node) {
        return node.update(this.visitToken(node.openParenToken), this.visitSeparatedList(node.parameters), this.visitToken(node.closeParenToken));
    };
    SyntaxRewriter.prototype.visitCallSignature = function (node) {
        return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
    };
    SyntaxRewriter.prototype.visitTypeParameterList = function (node) {
        return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeParameters), this.visitToken(node.greaterThanToken));
    };
    SyntaxRewriter.prototype.visitTypeParameter = function (node) {
        return node.update(this.visitToken(node.identifier), node.constraint === null ? null : this.visitNode(node.constraint));
    };
    SyntaxRewriter.prototype.visitConstraint = function (node) {
        return node.update(this.visitToken(node.extendsKeyword), this.visitNodeOrToken(node.type));
    };
    SyntaxRewriter.prototype.visitElseClause = function (node) {
        return node.update(this.visitToken(node.elseKeyword), this.visitNodeOrToken(node.statement));
    };
    SyntaxRewriter.prototype.visitIfStatement = function (node) {
        return node.update(this.visitToken(node.ifKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement), node.elseClause === null ? null : this.visitNode(node.elseClause));
    };
    SyntaxRewriter.prototype.visitExpressionStatement = function (node) {
        return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitConstructorDeclaration = function (node) {
        return node.update(this.visitToken(node.constructorKeyword), this.visitNode(node.parameterList), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitMemberFunctionDeclaration = function (node) {
        return node.update(node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), node.staticKeyword === null ? null : this.visitToken(node.staticKeyword), this.visitNode(node.functionSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitGetMemberAccessorDeclaration = function (node) {
        return node.update(node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), node.staticKeyword === null ? null : this.visitToken(node.staticKeyword), this.visitToken(node.getKeyword), this.visitToken(node.identifier), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
    };
    SyntaxRewriter.prototype.visitSetMemberAccessorDeclaration = function (node) {
        return node.update(node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), node.staticKeyword === null ? null : this.visitToken(node.staticKeyword), this.visitToken(node.setKeyword), this.visitToken(node.identifier), this.visitNode(node.parameterList), this.visitNode(node.block));
    };
    SyntaxRewriter.prototype.visitMemberVariableDeclaration = function (node) {
        return node.update(node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), node.staticKeyword === null ? null : this.visitToken(node.staticKeyword), this.visitNode(node.variableDeclarator), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitThrowStatement = function (node) {
        return node.update(this.visitToken(node.throwKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitReturnStatement = function (node) {
        return node.update(this.visitToken(node.returnKeyword), node.expression === null ? null : this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitObjectCreationExpression = function (node) {
        return node.update(this.visitToken(node.newKeyword), this.visitNodeOrToken(node.expression), node.argumentList === null ? null : this.visitNode(node.argumentList));
    };
    SyntaxRewriter.prototype.visitSwitchStatement = function (node) {
        return node.update(this.visitToken(node.switchKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitToken(node.openBraceToken), this.visitList(node.switchClauses), this.visitToken(node.closeBraceToken));
    };
    SyntaxRewriter.prototype.visitCaseSwitchClause = function (node) {
        return node.update(this.visitToken(node.caseKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.colonToken), this.visitList(node.statements));
    };
    SyntaxRewriter.prototype.visitDefaultSwitchClause = function (node) {
        return node.update(this.visitToken(node.defaultKeyword), this.visitToken(node.colonToken), this.visitList(node.statements));
    };
    SyntaxRewriter.prototype.visitBreakStatement = function (node) {
        return node.update(this.visitToken(node.breakKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitContinueStatement = function (node) {
        return node.update(this.visitToken(node.continueKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitForStatement = function (node) {
        return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.initializer === null ? null : this.visitNodeOrToken(node.initializer), this.visitToken(node.firstSemicolonToken), node.condition === null ? null : this.visitNodeOrToken(node.condition), this.visitToken(node.secondSemicolonToken), node.incrementor === null ? null : this.visitNodeOrToken(node.incrementor), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
    };
    SyntaxRewriter.prototype.visitForInStatement = function (node) {
        return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.left === null ? null : this.visitNodeOrToken(node.left), this.visitToken(node.inKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
    };
    SyntaxRewriter.prototype.visitWhileStatement = function (node) {
        return node.update(this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
    };
    SyntaxRewriter.prototype.visitWithStatement = function (node) {
        return node.update(this.visitToken(node.withKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
    };
    SyntaxRewriter.prototype.visitEnumDeclaration = function (node) {
        return node.update(node.exportKeyword === null ? null : this.visitToken(node.exportKeyword), this.visitToken(node.enumKeyword), this.visitToken(node.identifier), this.visitToken(node.openBraceToken), this.visitSeparatedList(node.variableDeclarators), this.visitToken(node.closeBraceToken));
    };
    SyntaxRewriter.prototype.visitCastExpression = function (node) {
        return node.update(this.visitToken(node.lessThanToken), this.visitNodeOrToken(node.type), this.visitToken(node.greaterThanToken), this.visitNodeOrToken(node.expression));
    };
    SyntaxRewriter.prototype.visitObjectLiteralExpression = function (node) {
        return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.propertyAssignments), this.visitToken(node.closeBraceToken));
    };
    SyntaxRewriter.prototype.visitSimplePropertyAssignment = function (node) {
        return node.update(this.visitToken(node.propertyName), this.visitToken(node.colonToken), this.visitNodeOrToken(node.expression));
    };
    SyntaxRewriter.prototype.visitGetAccessorPropertyAssignment = function (node) {
        return node.update(this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitToken(node.closeParenToken), this.visitNode(node.block));
    };
    SyntaxRewriter.prototype.visitSetAccessorPropertyAssignment = function (node) {
        return node.update(this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitToken(node.parameterName), this.visitToken(node.closeParenToken), this.visitNode(node.block));
    };
    SyntaxRewriter.prototype.visitFunctionExpression = function (node) {
        return node.update(this.visitToken(node.functionKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitNode(node.callSignature), this.visitNode(node.block));
    };
    SyntaxRewriter.prototype.visitEmptyStatement = function (node) {
        return node.update(this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitTryStatement = function (node) {
        return node.update(this.visitToken(node.tryKeyword), this.visitNode(node.block), node.catchClause === null ? null : this.visitNode(node.catchClause), node.finallyClause === null ? null : this.visitNode(node.finallyClause));
    };
    SyntaxRewriter.prototype.visitCatchClause = function (node) {
        return node.update(this.visitToken(node.catchKeyword), this.visitToken(node.openParenToken), this.visitToken(node.identifier), this.visitToken(node.closeParenToken), this.visitNode(node.block));
    };
    SyntaxRewriter.prototype.visitFinallyClause = function (node) {
        return node.update(this.visitToken(node.finallyKeyword), this.visitNode(node.block));
    };
    SyntaxRewriter.prototype.visitLabeledStatement = function (node) {
        return node.update(this.visitToken(node.identifier), this.visitToken(node.colonToken), this.visitNodeOrToken(node.statement));
    };
    SyntaxRewriter.prototype.visitDoStatement = function (node) {
        return node.update(this.visitToken(node.doKeyword), this.visitNodeOrToken(node.statement), this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitToken(node.semicolonToken));
    };
    SyntaxRewriter.prototype.visitTypeOfExpression = function (node) {
        return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.expression));
    };
    SyntaxRewriter.prototype.visitDeleteExpression = function (node) {
        return node.update(this.visitToken(node.deleteKeyword), this.visitNodeOrToken(node.expression));
    };
    SyntaxRewriter.prototype.visitVoidExpression = function (node) {
        return node.update(this.visitToken(node.voidKeyword), this.visitNodeOrToken(node.expression));
    };
    SyntaxRewriter.prototype.visitDebuggerStatement = function (node) {
        return node.update(this.visitToken(node.debuggerKeyword), this.visitToken(node.semicolonToken));
    };
    return SyntaxRewriter;
})();
var Errors = (function () {
    function Errors() { }
    Errors.argument = function argument(argument, message) {
        return new Error("Invalid argument: " + argument + "." + (message ? (" " + message) : ""));
    };
    Errors.argumentOutOfRange = function argumentOutOfRange(argument) {
        return new Error("Argument out of range: " + argument + ".");
    };
    Errors.argumentNull = function argumentNull(argument) {
        return new Error("Argument null: " + argument + ".");
    };
    Errors.abstract = function abstract() {
        return new Error("Operation not implemented properly by subclass.");
    };
    Errors.notYetImplemented = function notYetImplemented() {
        return new Error("Not yet implemented.");
    };
    Errors.invalidOperation = function invalidOperation(message) {
        return new Error(message ? ("Invalid operation: " + message) : "Invalid operation.");
    };
    return Errors;
})();
var SyntaxTokenReplacer = (function (_super) {
    __extends(SyntaxTokenReplacer, _super);
    function SyntaxTokenReplacer(token1, token2) {
        _super.call(this);
        this.token1 = token1;
        this.token2 = token2;
    }
    SyntaxTokenReplacer.prototype.visitToken = function (token) {
        if (token === this.token1) {
            var result = this.token2;
            this.token1 = null;
            this.token2 = null;
            return result;
        }
        return token;
    };
    SyntaxTokenReplacer.prototype.visitNode = function (node) {
        if (this.token1 === null) {
            return node;
        }
        return _super.prototype.visitNode.call(this, node);
    };
    SyntaxTokenReplacer.prototype.visitList = function (list) {
        if (this.token1 === null) {
            return list;
        }
        return _super.prototype.visitList.call(this, list);
    };
    SyntaxTokenReplacer.prototype.visitSeparatedList = function (list) {
        if (this.token1 === null) {
            return list;
        }
        return _super.prototype.visitSeparatedList.call(this, list);
    };
    return SyntaxTokenReplacer;
})(SyntaxRewriter);
var SyntaxNode = (function () {
    function SyntaxNode(parsedInStrictMode) {
        this._data = parsedInStrictMode ? 8 /* NodeParsedInStrictModeMask */  : 0;
    }
    SyntaxNode.prototype.isNode = function () {
        return true;
    };
    SyntaxNode.prototype.isToken = function () {
        return false;
    };
    SyntaxNode.prototype.isList = function () {
        return false;
    };
    SyntaxNode.prototype.isSeparatedList = function () {
        return false;
    };
    SyntaxNode.prototype.kind = function () {
        throw Errors.abstract();
    };
    SyntaxNode.prototype.childCount = function () {
        throw Errors.abstract();
    };
    SyntaxNode.prototype.childAt = function (slot) {
        throw Errors.abstract();
    };
    SyntaxNode.prototype.firstToken = function () {
        for(var i = 0, n = this.childCount(); i < n; i++) {
            var element = this.childAt(i);
            if (element != null) {
                if (element.fullWidth() > 0 || element.kind() === 10 /* EndOfFileToken */ ) {
                    return element.firstToken();
                }
            }
        }
        return null;
    };
    SyntaxNode.prototype.lastToken = function () {
        for(var i = this.childCount() - 1; i >= 0; i--) {
            var element = this.childAt(i);
            if (element != null) {
                if (element.fullWidth() > 0 || element.kind() === 10 /* EndOfFileToken */ ) {
                    return element.lastToken();
                }
            }
        }
        return null;
    };
    SyntaxNode.prototype.insertChildrenInto = function (array, index) {
        for(var i = this.childCount() - 1; i >= 0; i--) {
            var element = this.childAt(i);
            if (element !== null) {
                if (element.isNode() || element.isToken()) {
                    array.splice(index, 0, element);
                } else if (element.isList()) {
                    (element).insertChildrenInto(array, index);
                } else if (element.isSeparatedList()) {
                    (element).insertChildrenInto(array, index);
                } else {
                    throw Errors.invalidOperation();
                }
            }
        }
    };
    SyntaxNode.prototype.leadingTrivia = function () {
        return this.firstToken().leadingTrivia();
    };
    SyntaxNode.prototype.trailingTrivia = function () {
        return this.lastToken().trailingTrivia();
    };
    SyntaxNode.prototype.toJSON = function (key) {
        var result = {
            kind: (SyntaxKind)._map[this.kind()],
            fullWidth: this.fullWidth()
        };
        if (this.hasSkippedText()) {
            result.hasSkippedText = true;
        }
        if (this.hasZeroWidthToken()) {
            result.hasZeroWidthToken = true;
        }
        if (this.hasRegularExpressionToken()) {
            result.hasRegularExpressionToken = true;
        }
        if (this.parsedInStrictMode()) {
            result.parsedInStrictMode = true;
        }
        for(var i = 0, n = this.childCount(); i < n; i++) {
            var value = this.childAt(i);
            if (value) {
                for(var name in this) {
                    if (value === this[name]) {
                        result[name] = value;
                        break;
                    }
                }
            }
        }
        return result;
    };
    SyntaxNode.prototype.accept = function (visitor) {
        throw Errors.abstract();
    };
    SyntaxNode.prototype.fullText = function () {
        var elements = [];
        this.collectTextElements(elements);
        return elements.join("");
    };
    SyntaxNode.prototype.collectTextElements = function (elements) {
        for(var i = 0, n = this.childCount(); i < n; i++) {
            var element = this.childAt(i);
            if (element !== null) {
                element.collectTextElements(elements);
            }
        }
    };
    SyntaxNode.prototype.replaceToken = function (token1, token2) {
        if (token1 === token2) {
            return this;
        }
        return this.accept(new SyntaxTokenReplacer(token1, token2));
    };
    SyntaxNode.prototype.withLeadingTrivia = function (trivia) {
        return this.replaceToken(this.firstToken(), this.firstToken().withLeadingTrivia(trivia));
    };
    SyntaxNode.prototype.withTrailingTrivia = function (trivia) {
        return this.replaceToken(this.lastToken(), this.lastToken().withTrailingTrivia(trivia));
    };
    SyntaxNode.prototype.hasLeadingTrivia = function () {
        return this.lastToken().hasLeadingTrivia();
    };
    SyntaxNode.prototype.hasTrailingTrivia = function () {
        return this.lastToken().hasTrailingTrivia();
    };
    SyntaxNode.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    SyntaxNode.prototype.hasSkippedText = function () {
        return (this.data() & 1 /* NodeSkippedTextMask */ ) !== 0;
    };
    SyntaxNode.prototype.hasZeroWidthToken = function () {
        return (this.data() & 2 /* NodeZeroWidthTokenMask */ ) !== 0;
    };
    SyntaxNode.prototype.hasRegularExpressionToken = function () {
        return (this.data() & 4 /* NodeRegularExpressionTokenMask */ ) !== 0;
    };
    SyntaxNode.prototype.parsedInStrictMode = function () {
        return (this.data() & 8 /* NodeParsedInStrictModeMask */ ) !== 0;
    };
    SyntaxNode.prototype.fullWidth = function () {
        return this.data() >>> 4 /* NodeFullWidthShift */ ;
    };
    SyntaxNode.prototype.computeData = function () {
        var slotCount = this.childCount();
        var fullWidth = 0;
        var childWidth = 0;
        var hasSkippedText = false;
        var hasZeroWidthToken = slotCount === 0;
        var hasRegularExpressionToken = false;
        for(var i = 0, n = slotCount; i < n; i++) {
            var element = this.childAt(i);
            if (element !== null) {
                var childWidth = element.fullWidth();
                fullWidth += childWidth;
                if (!hasSkippedText) {
                    hasSkippedText = element.hasSkippedText();
                }
                if (!hasZeroWidthToken) {
                    hasZeroWidthToken = element.hasZeroWidthToken();
                }
                if (!hasRegularExpressionToken) {
                    hasRegularExpressionToken = element.hasRegularExpressionToken();
                }
            }
        }
        return (fullWidth << 4 /* NodeFullWidthShift */ ) | (hasSkippedText ? 1 /* NodeSkippedTextMask */  : 0) | (hasZeroWidthToken ? 2 /* NodeZeroWidthTokenMask */  : 0) | (hasRegularExpressionToken ? 4 /* NodeRegularExpressionTokenMask */  : 0);
    };
    SyntaxNode.prototype.data = function () {
        if (this._data === 0 || this._data === 8 /* NodeParsedInStrictModeMask */ ) {
            this._data |= this.computeData();
        }
        return this._data;
    };
    SyntaxNode.prototype.findToken = function (position) {
        var endOfFileToken = this.tryGetEndOfFileAt(position);
        if (endOfFileToken !== null) {
            return endOfFileToken;
        }
        if (position < 0 || position >= this.fullWidth()) {
            throw Errors.argumentOutOfRange("position");
        }
        return this.findTokenInternal(null, position, 0);
    };
    SyntaxNode.prototype.tryGetEndOfFileAt = function (position) {
        if (this.kind() === 120 /* SourceUnit */  && position === this.fullWidth()) {
            var sourceUnit = this;
            return new PositionedToken(new PositionedNode(null, sourceUnit, 0), sourceUnit.endOfFileToken, sourceUnit.moduleElements.fullWidth());
        }
        return null;
    };
    SyntaxNode.prototype.findTokenInternal = function (parent, position, fullStart) {
        parent = new PositionedNode(parent, this, fullStart);
        for(var i = 0, n = this.childCount(); i < n; i++) {
            var element = this.childAt(i);
            if (element !== null) {
                var childWidth = element.fullWidth();
                if (position < childWidth) {
                    return (element).findTokenInternal(parent, position, fullStart);
                }
                position -= childWidth;
                fullStart += childWidth;
            }
        }
        throw Errors.invalidOperation();
    };
    SyntaxNode.prototype.findTokenOnLeft = function (position) {
        var positionedToken = this.findToken(position);
        var start = positionedToken.start();
        if (position > start) {
            return positionedToken;
        }
        if (positionedToken.fullStart() === 0) {
            return null;
        }
        var previousToken = this.findToken(positionedToken.fullStart() - 1);
        return previousToken;
    };
    SyntaxNode.prototype.isModuleElement = function () {
        return false;
    };
    SyntaxNode.prototype.isClassElement = function () {
        return false;
    };
    SyntaxNode.prototype.isTypeMember = function () {
        return false;
    };
    SyntaxNode.prototype.isStatement = function () {
        return false;
    };
    SyntaxNode.prototype.isSwitchClause = function () {
        return false;
    };
    SyntaxNode.prototype.structuralEquals = function (node) {
        if (this === node) {
            return true;
        }
        if (node === null) {
            return false;
        }
        if (this.kind() !== node.kind()) {
            return false;
        }
        for(var i = 0, n = this.childCount(); i < n; i++) {
            var element1 = this.childAt(i);
            var element2 = node.childAt(i);
            if (!Syntax.elementStructuralEquals(element1, element2)) {
                return false;
            }
        }
        return true;
    };
    SyntaxNode.prototype.width = function () {
        return this.fullWidth() - this.leadingTriviaWidth() - this.trailingTriviaWidth();
    };
    SyntaxNode.prototype.leadingTriviaWidth = function () {
        var firstToken = this.firstToken();
        return firstToken === null ? 0 : firstToken.leadingTriviaWidth();
    };
    SyntaxNode.prototype.trailingTriviaWidth = function () {
        var lastToken = this.lastToken();
        return lastToken === null ? 0 : lastToken.trailingTriviaWidth();
    };
    return SyntaxNode;
})();
var IntegerUtilities = (function () {
    function IntegerUtilities() { }
    IntegerUtilities.integerDivide = function integerDivide(numerator, denominator) {
        return (numerator / denominator) >> 0;
    };
    IntegerUtilities.integerMultiplyLow32Bits = function integerMultiplyLow32Bits(n1, n2) {
        var n1Low16 = n1 & 0x0000ffff;
        var n1High16 = n1 >>> 16;
        var n2Low16 = n2 & 0x0000ffff;
        var n2High16 = n2 >>> 16;
        var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
        return resultLow32;
    };
    IntegerUtilities.integerMultiplyHigh32Bits = function integerMultiplyHigh32Bits(n1, n2) {
        var n1Low16 = n1 & 0x0000ffff;
        var n1High16 = n1 >>> 16;
        var n2Low16 = n2 & 0x0000ffff;
        var n2High16 = n2 >>> 16;
        var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
        return resultHigh32;
    };
    return IntegerUtilities;
})();
var PositionedElement = (function () {
    function PositionedElement(parent, element, fullStart) {
        this._parent = parent;
        this._element = element;
        this._fullStart = fullStart;
    }
    PositionedElement.create = function create(parent, element, fullStart) {
        if (element === null) {
            return null;
        }
        if (element.isNode()) {
            return new PositionedNode(parent, element, fullStart);
        } else if (element.isToken()) {
            return new PositionedToken(parent, element, fullStart);
        } else if (element.isList()) {
            return new PositionedList(parent, element, fullStart);
        } else if (element.isSeparatedList()) {
            return new PositionedSeparatedList(parent, element, fullStart);
        } else {
            throw Errors.invalidOperation();
        }
    };
    PositionedElement.prototype.parent = function () {
        return this._parent;
    };
    PositionedElement.prototype.parentElement = function () {
        return this._parent && this._parent._element;
    };
    PositionedElement.prototype.element = function () {
        return this._element;
    };
    PositionedElement.prototype.kind = function () {
        return this.element().kind();
    };
    PositionedElement.prototype.childCount = function () {
        return this.element().childCount();
    };
    PositionedElement.prototype.childAt = function (index) {
        var offset = 0;
        for(var i = 0; i < index; i++) {
            offset += this.element().childAt(i).fullWidth();
        }
        return PositionedElement.create(this, this.element().childAt(index), offset);
    };
    PositionedElement.prototype.getPositionedChild = function (child) {
        var offset = Syntax.childOffset(this.element(), child);
        return PositionedElement.create(this, child, offset);
    };
    PositionedElement.prototype.fullStart = function () {
        return this._fullStart;
    };
    PositionedElement.prototype.fullEnd = function () {
        return this.fullStart() + this.element().fullWidth();
    };
    PositionedElement.prototype.fullWidth = function () {
        return this.element().fullWidth();
    };
    PositionedElement.prototype.start = function () {
        return this.fullStart() + this.element().leadingTriviaWidth();
    };
    PositionedElement.prototype.end = function () {
        return this.fullStart() + this.element().leadingTriviaWidth() + this.element().width();
    };
    PositionedElement.prototype.root = function () {
        var current = this;
        while(current.parent() !== null) {
            current = current.parent();
        }
        return current;
    };
    PositionedElement.prototype.containingNode = function () {
        var current = this.parent();
        while(current !== null && !current.element().isNode()) {
            current = current.parent();
        }
        return current;
    };
    return PositionedElement;
})();
var PositionedNodeOrToken = (function (_super) {
    __extends(PositionedNodeOrToken, _super);
    function PositionedNodeOrToken(parent, nodeOrToken, fullStart) {
        _super.call(this, parent, nodeOrToken, fullStart);
    }
    PositionedNodeOrToken.prototype.nodeOrToken = function () {
        return this.element();
    };
    return PositionedNodeOrToken;
})(PositionedElement);
var PositionedNode = (function (_super) {
    __extends(PositionedNode, _super);
    function PositionedNode(parent, node, fullStart) {
        _super.call(this, parent, node, fullStart);
    }
    PositionedNode.prototype.node = function () {
        return this.element();
    };
    return PositionedNode;
})(PositionedNodeOrToken);
var PositionedToken = (function (_super) {
    __extends(PositionedToken, _super);
    function PositionedToken(parent, token, fullStart) {
        _super.call(this, parent, token, fullStart);
    }
    PositionedToken.prototype.token = function () {
        return this.element();
    };
    PositionedToken.prototype.previousToken = function () {
        var fullStart = this.fullStart();
        if (fullStart === 0) {
            return null;
        }
        return this.root().node().findToken(fullStart - 1);
    };
    PositionedToken.prototype.nextToken = function () {
        if (this.token().tokenKind === 10 /* EndOfFileToken */ ) {
            return null;
        }
        return this.root().node().findToken(this.fullEnd());
    };
    return PositionedToken;
})(PositionedNodeOrToken);
var PositionedList = (function (_super) {
    __extends(PositionedList, _super);
    function PositionedList(parent, list, fullStart) {
        _super.call(this, parent, list, fullStart);
    }
    PositionedList.prototype.list = function () {
        return this.element();
    };
    return PositionedList;
})(PositionedElement);
var PositionedSeparatedList = (function (_super) {
    __extends(PositionedSeparatedList, _super);
    function PositionedSeparatedList(parent, list, fullStart) {
        _super.call(this, parent, list, fullStart);
    }
    PositionedSeparatedList.prototype.list = function () {
        return this.element();
    };
    return PositionedSeparatedList;
})(PositionedElement);
var Debug = (function () {
    function Debug() { }
    Debug.assert = function assert(expression) {
        if (!expression) {
            throw new Error("Debug Failure. False expression.");
        }
    };
    return Debug;
})();
var SyntaxFacts;
(function (SyntaxFacts) {
    var textToKeywordKind = {
        "any": 60 /* AnyKeyword */ ,
        "bool": 62 /* BoolKeyword */ ,
        "boolean": 61 /* BooleanKeyword */ ,
        "break": 15 /* BreakKeyword */ ,
        "case": 16 /* CaseKeyword */ ,
        "catch": 17 /* CatchKeyword */ ,
        "class": 44 /* ClassKeyword */ ,
        "continue": 18 /* ContinueKeyword */ ,
        "const": 45 /* ConstKeyword */ ,
        "constructor": 63 /* ConstructorKeyword */ ,
        "debugger": 19 /* DebuggerKeyword */ ,
        "declare": 64 /* DeclareKeyword */ ,
        "default": 20 /* DefaultKeyword */ ,
        "delete": 21 /* DeleteKeyword */ ,
        "do": 22 /* DoKeyword */ ,
        "else": 23 /* ElseKeyword */ ,
        "enum": 46 /* EnumKeyword */ ,
        "export": 47 /* ExportKeyword */ ,
        "extends": 48 /* ExtendsKeyword */ ,
        "false": 24 /* FalseKeyword */ ,
        "finally": 25 /* FinallyKeyword */ ,
        "for": 26 /* ForKeyword */ ,
        "function": 27 /* FunctionKeyword */ ,
        "get": 65 /* GetKeyword */ ,
        "if": 28 /* IfKeyword */ ,
        "implements": 51 /* ImplementsKeyword */ ,
        "import": 49 /* ImportKeyword */ ,
        "in": 29 /* InKeyword */ ,
        "instanceof": 30 /* InstanceOfKeyword */ ,
        "interface": 52 /* InterfaceKeyword */ ,
        "let": 53 /* LetKeyword */ ,
        "module": 66 /* ModuleKeyword */ ,
        "new": 31 /* NewKeyword */ ,
        "null": 32 /* NullKeyword */ ,
        "number": 67 /* NumberKeyword */ ,
        "package": 54 /* PackageKeyword */ ,
        "private": 55 /* PrivateKeyword */ ,
        "protected": 56 /* ProtectedKeyword */ ,
        "public": 57 /* PublicKeyword */ ,
        "return": 33 /* ReturnKeyword */ ,
        "set": 68 /* SetKeyword */ ,
        "static": 58 /* StaticKeyword */ ,
        "string": 69 /* StringKeyword */ ,
        "super": 50 /* SuperKeyword */ ,
        "switch": 34 /* SwitchKeyword */ ,
        "this": 35 /* ThisKeyword */ ,
        "throw": 36 /* ThrowKeyword */ ,
        "true": 37 /* TrueKeyword */ ,
        "try": 38 /* TryKeyword */ ,
        "typeof": 39 /* TypeOfKeyword */ ,
        "var": 40 /* VarKeyword */ ,
        "void": 41 /* VoidKeyword */ ,
        "while": 42 /* WhileKeyword */ ,
        "with": 43 /* WithKeyword */ ,
        "yield": 59 /* YieldKeyword */ ,
        "{": 70 /* OpenBraceToken */ ,
        "}": 71 /* CloseBraceToken */ ,
        "(": 72 /* OpenParenToken */ ,
        ")": 73 /* CloseParenToken */ ,
        "[": 74 /* OpenBracketToken */ ,
        "]": 75 /* CloseBracketToken */ ,
        ".": 76 /* DotToken */ ,
        "...": 77 /* DotDotDotToken */ ,
        ";": 78 /* SemicolonToken */ ,
        ",": 79 /* CommaToken */ ,
        "<": 80 /* LessThanToken */ ,
        ">": 81 /* GreaterThanToken */ ,
        "<=": 82 /* LessThanEqualsToken */ ,
        ">=": 83 /* GreaterThanEqualsToken */ ,
        "==": 84 /* EqualsEqualsToken */ ,
        "=>": 85 /* EqualsGreaterThanToken */ ,
        "!=": 86 /* ExclamationEqualsToken */ ,
        "===": 87 /* EqualsEqualsEqualsToken */ ,
        "!==": 88 /* ExclamationEqualsEqualsToken */ ,
        "+": 89 /* PlusToken */ ,
        "-": 90 /* MinusToken */ ,
        "*": 91 /* AsteriskToken */ ,
        "%": 92 /* PercentToken */ ,
        "++": 93 /* PlusPlusToken */ ,
        "--": 94 /* MinusMinusToken */ ,
        "<<": 95 /* LessThanLessThanToken */ ,
        ">>": 96 /* GreaterThanGreaterThanToken */ ,
        ">>>": 97 /* GreaterThanGreaterThanGreaterThanToken */ ,
        "&": 98 /* AmpersandToken */ ,
        "|": 99 /* BarToken */ ,
        "^": 100 /* CaretToken */ ,
        "!": 101 /* ExclamationToken */ ,
        "~": 102 /* TildeToken */ ,
        "&&": 103 /* AmpersandAmpersandToken */ ,
        "||": 104 /* BarBarToken */ ,
        "?": 105 /* QuestionToken */ ,
        ":": 106 /* ColonToken */ ,
        "=": 107 /* EqualsToken */ ,
        "+=": 108 /* PlusEqualsToken */ ,
        "-=": 109 /* MinusEqualsToken */ ,
        "*=": 110 /* AsteriskEqualsToken */ ,
        "%=": 111 /* PercentEqualsToken */ ,
        "<<=": 112 /* LessThanLessThanEqualsToken */ ,
        ">>=": 113 /* GreaterThanGreaterThanEqualsToken */ ,
        ">>>=": 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */ ,
        "&=": 115 /* AmpersandEqualsToken */ ,
        "|=": 116 /* BarEqualsToken */ ,
        "^=": 117 /* CaretEqualsToken */ ,
        "/": 118 /* SlashToken */ ,
        "/=": 119 /* SlashEqualsToken */ 
    };
    var kindToText = [];
    for(var name in textToKeywordKind) {
        if (textToKeywordKind.hasOwnProperty(name)) {
            kindToText[textToKeywordKind[name]] = name;
        }
    }
    kindToText[63 /* ConstructorKeyword */ ] = "constructor";
    function getTokenKind(text) {
        if (textToKeywordKind.hasOwnProperty(text)) {
            return textToKeywordKind[text];
        }
        return 0 /* None */ ;
    }
    SyntaxFacts.getTokenKind = getTokenKind;
    function getText(kind) {
        var result = kindToText[kind];
        return result !== undefined ? result : null;
    }
    SyntaxFacts.getText = getText;
    function isTokenKind(kind) {
        return kind >= 9 /* FirstToken */  && kind <= 119 /* LastToken */ ;
    }
    SyntaxFacts.isTokenKind = isTokenKind;
    function isAnyKeyword(kind) {
        return kind >= 15 /* FirstKeyword */  && kind <= 69 /* LastKeyword */ ;
    }
    SyntaxFacts.isAnyKeyword = isAnyKeyword;
    function isStandardKeyword(kind) {
        return kind >= 15 /* FirstStandardKeyword */  && kind <= 43 /* LastStandardKeyword */ ;
    }
    SyntaxFacts.isStandardKeyword = isStandardKeyword;
    function isFutureReservedKeyword(kind) {
        return kind >= 44 /* FirstFutureReservedKeyword */  && kind <= 50 /* LastFutureReservedKeyword */ ;
    }
    SyntaxFacts.isFutureReservedKeyword = isFutureReservedKeyword;
    function isFutureReservedStrictKeyword(kind) {
        return kind >= 51 /* FirstFutureReservedStrictKeyword */  && kind <= 59 /* LastFutureReservedStrictKeyword */ ;
    }
    SyntaxFacts.isFutureReservedStrictKeyword = isFutureReservedStrictKeyword;
    function isAnyPunctuation(kind) {
        return kind >= 70 /* FirstPunctuation */  && kind <= 119 /* LastPunctuation */ ;
    }
    SyntaxFacts.isAnyPunctuation = isAnyPunctuation;
    function isPrefixUnaryExpressionOperatorToken(tokenKind) {
        return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */ ;
    }
    SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;
    function isBinaryExpressionOperatorToken(tokenKind) {
        return getBinaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */ ;
    }
    SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;
    function getPrefixUnaryExpressionFromOperatorToken(tokenKind) {
        switch(tokenKind) {
            case 89 /* PlusToken */ :
                return 161 /* PlusExpression */ ;
            case 90 /* MinusToken */ :
                return 162 /* NegateExpression */ ;
            case 102 /* TildeToken */ :
                return 163 /* BitwiseNotExpression */ ;
            case 101 /* ExclamationToken */ :
                return 164 /* LogicalNotExpression */ ;
            case 93 /* PlusPlusToken */ :
                return 165 /* PreIncrementExpression */ ;
            case 94 /* MinusMinusToken */ :
                return 166 /* PreDecrementExpression */ ;
            default:
                return 0 /* None */ ;
        }
    }
    SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken = getPrefixUnaryExpressionFromOperatorToken;
    function getPostfixUnaryExpressionFromOperatorToken(tokenKind) {
        switch(tokenKind) {
            case 93 /* PlusPlusToken */ :
                return 207 /* PostIncrementExpression */ ;
            case 94 /* MinusMinusToken */ :
                return 208 /* PostDecrementExpression */ ;
            default:
                return 0 /* None */ ;
        }
    }
    SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken = getPostfixUnaryExpressionFromOperatorToken;
    function getBinaryExpressionFromOperatorToken(tokenKind) {
        switch(tokenKind) {
            case 91 /* AsteriskToken */ :
                return 202 /* MultiplyExpression */ ;
            case 118 /* SlashToken */ :
                return 203 /* DivideExpression */ ;
            case 92 /* PercentToken */ :
                return 204 /* ModuloExpression */ ;
            case 89 /* PlusToken */ :
                return 205 /* AddExpression */ ;
            case 90 /* MinusToken */ :
                return 206 /* SubtractExpression */ ;
            case 95 /* LessThanLessThanToken */ :
                return 199 /* LeftShiftExpression */ ;
            case 96 /* GreaterThanGreaterThanToken */ :
                return 200 /* SignedRightShiftExpression */ ;
            case 97 /* GreaterThanGreaterThanGreaterThanToken */ :
                return 201 /* UnsignedRightShiftExpression */ ;
            case 80 /* LessThanToken */ :
                return 193 /* LessThanExpression */ ;
            case 81 /* GreaterThanToken */ :
                return 194 /* GreaterThanExpression */ ;
            case 82 /* LessThanEqualsToken */ :
                return 195 /* LessThanOrEqualExpression */ ;
            case 83 /* GreaterThanEqualsToken */ :
                return 196 /* GreaterThanOrEqualExpression */ ;
            case 30 /* InstanceOfKeyword */ :
                return 197 /* InstanceOfExpression */ ;
            case 29 /* InKeyword */ :
                return 198 /* InExpression */ ;
            case 84 /* EqualsEqualsToken */ :
                return 189 /* EqualsWithTypeConversionExpression */ ;
            case 86 /* ExclamationEqualsToken */ :
                return 190 /* NotEqualsWithTypeConversionExpression */ ;
            case 87 /* EqualsEqualsEqualsToken */ :
                return 191 /* EqualsExpression */ ;
            case 88 /* ExclamationEqualsEqualsToken */ :
                return 192 /* NotEqualsExpression */ ;
            case 98 /* AmpersandToken */ :
                return 188 /* BitwiseAndExpression */ ;
            case 100 /* CaretToken */ :
                return 187 /* BitwiseExclusiveOrExpression */ ;
            case 99 /* BarToken */ :
                return 186 /* BitwiseOrExpression */ ;
            case 103 /* AmpersandAmpersandToken */ :
                return 185 /* LogicalAndExpression */ ;
            case 104 /* BarBarToken */ :
                return 184 /* LogicalOrExpression */ ;
            case 116 /* BarEqualsToken */ :
                return 179 /* OrAssignmentExpression */ ;
            case 115 /* AmpersandEqualsToken */ :
                return 177 /* AndAssignmentExpression */ ;
            case 117 /* CaretEqualsToken */ :
                return 178 /* ExclusiveOrAssignmentExpression */ ;
            case 112 /* LessThanLessThanEqualsToken */ :
                return 180 /* LeftShiftAssignmentExpression */ ;
            case 113 /* GreaterThanGreaterThanEqualsToken */ :
                return 181 /* SignedRightShiftAssignmentExpression */ ;
            case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */ :
                return 182 /* UnsignedRightShiftAssignmentExpression */ ;
            case 108 /* PlusEqualsToken */ :
                return 172 /* AddAssignmentExpression */ ;
            case 109 /* MinusEqualsToken */ :
                return 173 /* SubtractAssignmentExpression */ ;
            case 110 /* AsteriskEqualsToken */ :
                return 174 /* MultiplyAssignmentExpression */ ;
            case 119 /* SlashEqualsToken */ :
                return 175 /* DivideAssignmentExpression */ ;
            case 111 /* PercentEqualsToken */ :
                return 176 /* ModuloAssignmentExpression */ ;
            case 107 /* EqualsToken */ :
                return 171 /* AssignmentExpression */ ;
            case 79 /* CommaToken */ :
                return 170 /* CommaExpression */ ;
            default:
                return 0 /* None */ ;
        }
    }
    SyntaxFacts.getBinaryExpressionFromOperatorToken = getBinaryExpressionFromOperatorToken;
    function isAnyDivideToken(kind) {
        switch(kind) {
            case 118 /* SlashToken */ :
            case 119 /* SlashEqualsToken */ :
                return true;
            default:
                return false;
        }
    }
    SyntaxFacts.isAnyDivideToken = isAnyDivideToken;
    function isAnyDivideOrRegularExpressionToken(kind) {
        switch(kind) {
            case 118 /* SlashToken */ :
            case 119 /* SlashEqualsToken */ :
            case 12 /* RegularExpressionLiteral */ :
                return true;
            default:
                return false;
        }
    }
    SyntaxFacts.isAnyDivideOrRegularExpressionToken = isAnyDivideOrRegularExpressionToken;
    function isParserGenerated(kind) {
        switch(kind) {
            case 96 /* GreaterThanGreaterThanToken */ :
            case 97 /* GreaterThanGreaterThanGreaterThanToken */ :
            case 83 /* GreaterThanEqualsToken */ :
            case 113 /* GreaterThanGreaterThanEqualsToken */ :
            case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */ :
                return true;
            default:
                return false;
        }
    }
    SyntaxFacts.isParserGenerated = isParserGenerated;
    function isIdentifierName(kind) {
        return kind === 11 /* IdentifierName */  || isAnyKeyword(kind);
    }
    SyntaxFacts.isIdentifierName = isIdentifierName;
    function isAnyBinaryExpression(kind) {
        switch(kind) {
            case 170 /* CommaExpression */ :
            case 171 /* AssignmentExpression */ :
            case 172 /* AddAssignmentExpression */ :
            case 173 /* SubtractAssignmentExpression */ :
            case 174 /* MultiplyAssignmentExpression */ :
            case 175 /* DivideAssignmentExpression */ :
            case 176 /* ModuloAssignmentExpression */ :
            case 177 /* AndAssignmentExpression */ :
            case 178 /* ExclusiveOrAssignmentExpression */ :
            case 179 /* OrAssignmentExpression */ :
            case 180 /* LeftShiftAssignmentExpression */ :
            case 181 /* SignedRightShiftAssignmentExpression */ :
            case 182 /* UnsignedRightShiftAssignmentExpression */ :
            case 184 /* LogicalOrExpression */ :
            case 185 /* LogicalAndExpression */ :
            case 186 /* BitwiseOrExpression */ :
            case 187 /* BitwiseExclusiveOrExpression */ :
            case 188 /* BitwiseAndExpression */ :
            case 189 /* EqualsWithTypeConversionExpression */ :
            case 190 /* NotEqualsWithTypeConversionExpression */ :
            case 191 /* EqualsExpression */ :
            case 192 /* NotEqualsExpression */ :
            case 193 /* LessThanExpression */ :
            case 194 /* GreaterThanExpression */ :
            case 195 /* LessThanOrEqualExpression */ :
            case 196 /* GreaterThanOrEqualExpression */ :
            case 197 /* InstanceOfExpression */ :
            case 198 /* InExpression */ :
            case 199 /* LeftShiftExpression */ :
            case 200 /* SignedRightShiftExpression */ :
            case 201 /* UnsignedRightShiftExpression */ :
            case 202 /* MultiplyExpression */ :
            case 203 /* DivideExpression */ :
            case 204 /* ModuloExpression */ :
            case 205 /* AddExpression */ :
            case 206 /* SubtractExpression */ :
                return true;
        }
        return false;
    }
    SyntaxFacts.isAnyBinaryExpression = isAnyBinaryExpression;
})(SyntaxFacts || (SyntaxFacts = {}));
var Syntax;
(function (Syntax) {
    Syntax.emptySeparatedList = {
        kind: function () {
            return 2 /* SeparatedList */ ;
        },
        isNode: function () {
            return false;
        },
        isToken: function () {
            return false;
        },
        isList: function () {
            return false;
        },
        isSeparatedList: function () {
            return true;
        },
        toJSON: function (key) {
            return [];
        },
        childCount: function () {
            return 0;
        },
        nonSeparatorCount: function () {
            return 0;
        },
        separatorCount: function () {
            return 0;
        },
        toArray: function () {
            return [];
        },
        toNonSeparatorArray: function () {
            return [];
        },
        childAt: function (index) {
            throw Errors.argumentOutOfRange("index");
        },
        nonSeparatorAt: function (index) {
            throw Errors.argumentOutOfRange("index");
        },
        separatorAt: function (index) {
            throw Errors.argumentOutOfRange("index");
        },
        collectTextElements: function (elements) {
        },
        firstToken: function () {
            return null;
        },
        lastToken: function () {
            return null;
        },
        fullWidth: function () {
            return 0;
        },
        fullText: function () {
            return "";
        },
        width: function () {
            return 0;
        },
        isTypeScriptSpecific: function () {
            return false;
        },
        hasSkippedText: function () {
            return false;
        },
        hasZeroWidthToken: function () {
            return false;
        },
        hasRegularExpressionToken: function () {
            return false;
        },
        findTokenInternal: function (parent, position, fullStart) {
            throw Errors.invalidOperation();
        },
        insertChildrenInto: function (array, index) {
        },
        leadingTrivia: function () {
            return Syntax.emptyTriviaList;
        },
        trailingTrivia: function () {
            return Syntax.emptyTriviaList;
        },
        leadingTriviaWidth: function () {
            return 0;
        },
        trailingTriviaWidth: function () {
            return 0;
        }
    };
    var SingletonSeparatedSyntaxList = (function () {
        function SingletonSeparatedSyntaxList(item) {
            this.item = item;
        }
        SingletonSeparatedSyntaxList.prototype.toJSON = function (key) {
            return [
                this.item
            ];
        };
        SingletonSeparatedSyntaxList.prototype.kind = function () {
            return 2 /* SeparatedList */ ;
        };
        SingletonSeparatedSyntaxList.prototype.isNode = function () {
            return false;
        };
        SingletonSeparatedSyntaxList.prototype.isToken = function () {
            return false;
        };
        SingletonSeparatedSyntaxList.prototype.isList = function () {
            return false;
        };
        SingletonSeparatedSyntaxList.prototype.isSeparatedList = function () {
            return true;
        };
        SingletonSeparatedSyntaxList.prototype.childCount = function () {
            return 1;
        };
        SingletonSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
            return 1;
        };
        SingletonSeparatedSyntaxList.prototype.separatorCount = function () {
            return 0;
        };
        SingletonSeparatedSyntaxList.prototype.toArray = function () {
            return [
                this.item
            ];
        };
        SingletonSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
            return [
                this.item
            ];
        };
        SingletonSeparatedSyntaxList.prototype.childAt = function (index) {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.item;
        };
        SingletonSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.item;
        };
        SingletonSeparatedSyntaxList.prototype.separatorAt = function (index) {
            throw Errors.argumentOutOfRange("index");
        };
        SingletonSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
            this.item.collectTextElements(elements);
        };
        SingletonSeparatedSyntaxList.prototype.firstToken = function () {
            return this.item.firstToken();
        };
        SingletonSeparatedSyntaxList.prototype.lastToken = function () {
            return this.item.lastToken();
        };
        SingletonSeparatedSyntaxList.prototype.fullWidth = function () {
            return this.item.fullWidth();
        };
        SingletonSeparatedSyntaxList.prototype.width = function () {
            return this.item.width();
        };
        SingletonSeparatedSyntaxList.prototype.fullText = function () {
            return this.item.fullText();
        };
        SingletonSeparatedSyntaxList.prototype.leadingTrivia = function () {
            return this.item.leadingTrivia();
        };
        SingletonSeparatedSyntaxList.prototype.trailingTrivia = function () {
            return this.item.trailingTrivia();
        };
        SingletonSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
            return this.item.leadingTriviaWidth();
        };
        SingletonSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
            return this.item.trailingTriviaWidth();
        };
        SingletonSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
            return this.item.isTypeScriptSpecific();
        };
        SingletonSeparatedSyntaxList.prototype.hasSkippedText = function () {
            return this.item.hasSkippedText();
        };
        SingletonSeparatedSyntaxList.prototype.hasZeroWidthToken = function () {
            return this.item.hasZeroWidthToken();
        };
        SingletonSeparatedSyntaxList.prototype.hasRegularExpressionToken = function () {
            return this.item.hasRegularExpressionToken();
        };
        SingletonSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
            return (this.item).findTokenInternal(new PositionedSeparatedList(parent, this, fullStart), position, fullStart);
        };
        SingletonSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
            array.splice(index, 0, this.item);
        };
        return SingletonSeparatedSyntaxList;
    })();    
    var NormalSeparatedSyntaxList = (function () {
        function NormalSeparatedSyntaxList(elements) {
            this._data = -1;
            this.elements = elements;
        }
        NormalSeparatedSyntaxList.prototype.kind = function () {
            return 2 /* SeparatedList */ ;
        };
        NormalSeparatedSyntaxList.prototype.isToken = function () {
            return false;
        };
        NormalSeparatedSyntaxList.prototype.isNode = function () {
            return false;
        };
        NormalSeparatedSyntaxList.prototype.isList = function () {
            return false;
        };
        NormalSeparatedSyntaxList.prototype.isSeparatedList = function () {
            return true;
        };
        NormalSeparatedSyntaxList.prototype.toJSON = function (key) {
            return this.elements;
        };
        NormalSeparatedSyntaxList.prototype.childCount = function () {
            return this.elements.length;
        };
        NormalSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
            return IntegerUtilities.integerDivide(this.elements.length + 1, 2);
        };
        NormalSeparatedSyntaxList.prototype.separatorCount = function () {
            return IntegerUtilities.integerDivide(this.elements.length, 2);
        };
        NormalSeparatedSyntaxList.prototype.toArray = function () {
            return this.elements.slice(0);
        };
        NormalSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
            var result = [];
            for(var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                result.push(this.nonSeparatorAt(i));
            }
            return result;
        };
        NormalSeparatedSyntaxList.prototype.childAt = function (index) {
            if (index < 0 || index >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.elements[index];
        };
        NormalSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
            var value = index * 2;
            if (value < 0 || value >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.elements[value];
        };
        NormalSeparatedSyntaxList.prototype.separatorAt = function (index) {
            var value = index * 2 + 1;
            if (value < 0 || value >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.elements[value];
        };
        NormalSeparatedSyntaxList.prototype.firstToken = function () {
            var token;
            for(var i = 0, n = this.elements.length; i < n; i++) {
                if (i % 2 === 0) {
                    var nodeOrToken = this.elements[i];
                    token = nodeOrToken.firstToken();
                    if (token !== null) {
                        return token;
                    }
                } else {
                    token = this.elements[i];
                    if (token.width() > 0) {
                        return token;
                    }
                }
            }
            return null;
        };
        NormalSeparatedSyntaxList.prototype.lastToken = function () {
            var token;
            for(var i = this.elements.length - 1; i >= 0; i--) {
                if (i % 2 === 0) {
                    var nodeOrToken = this.elements[i];
                    token = nodeOrToken.lastToken();
                    if (token !== null) {
                        return token;
                    }
                } else {
                    token = this.elements[i];
                    if (token.width() > 0) {
                        return token;
                    }
                }
            }
            return null;
        };
        NormalSeparatedSyntaxList.prototype.fullText = function () {
            var elements = [];
            this.collectTextElements(elements);
            return elements.join("");
        };
        NormalSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
            for(var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                if (this.nonSeparatorAt(i).isTypeScriptSpecific()) {
                    return true;
                }
            }
            return false;
        };
        NormalSeparatedSyntaxList.prototype.hasSkippedText = function () {
            return (this.data() & 1 /* NodeSkippedTextMask */ ) !== 0;
        };
        NormalSeparatedSyntaxList.prototype.hasZeroWidthToken = function () {
            return (this.data() & 2 /* NodeZeroWidthTokenMask */ ) !== 0;
        };
        NormalSeparatedSyntaxList.prototype.hasRegularExpressionToken = function () {
            return (this.data() & 4 /* NodeRegularExpressionTokenMask */ ) !== 0;
        };
        NormalSeparatedSyntaxList.prototype.fullWidth = function () {
            return this.data() >>> 4 /* NodeFullWidthShift */ ;
        };
        NormalSeparatedSyntaxList.prototype.width = function () {
            var fullWidth = this.fullWidth();
            return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        };
        NormalSeparatedSyntaxList.prototype.leadingTrivia = function () {
            return this.firstToken().leadingTrivia();
        };
        NormalSeparatedSyntaxList.prototype.trailingTrivia = function () {
            return this.lastToken().trailingTrivia();
        };
        NormalSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
            return this.firstToken().leadingTriviaWidth();
        };
        NormalSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
            return this.lastToken().trailingTriviaWidth();
        };
        NormalSeparatedSyntaxList.prototype.computeData = function () {
            var fullWidth = 0;
            var hasSkippedText = false;
            var hasZeroWidthToken = false;
            var hasRegularExpressionToken = false;
            for(var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];
                var childWidth = element.fullWidth();
                fullWidth += childWidth;
                if (i % 2 === 0) {
                    var nodeOrToken = element;
                    hasSkippedText = hasSkippedText || nodeOrToken.hasSkippedText();
                    hasZeroWidthToken = hasZeroWidthToken || nodeOrToken.hasZeroWidthToken();
                    hasRegularExpressionToken = hasRegularExpressionToken || nodeOrToken.hasRegularExpressionToken();
                } else {
                    var token = element;
                    hasSkippedText = hasSkippedText || token.hasSkippedText();
                    hasZeroWidthToken = hasZeroWidthToken || (childWidth === 0);
                }
            }
            return (fullWidth << 4 /* NodeFullWidthShift */ ) | (hasSkippedText ? 1 /* NodeSkippedTextMask */  : 0) | (hasZeroWidthToken ? 2 /* NodeZeroWidthTokenMask */  : 0) | (hasRegularExpressionToken ? 4 /* NodeRegularExpressionTokenMask */  : 0);
        };
        NormalSeparatedSyntaxList.prototype.data = function () {
            if (this._data === -1) {
                this._data = this.computeData();
            }
            return this._data;
        };
        NormalSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
            parent = new PositionedSeparatedList(parent, this, fullStart);
            for(var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];
                var childWidth = element.fullWidth();
                if (position < childWidth) {
                    return (element).findTokenInternal(parent, position, fullStart);
                }
                position -= childWidth;
                fullStart += childWidth;
            }
            throw Errors.invalidOperation();
        };
        NormalSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
            for(var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];
                element.collectTextElements(elements);
            }
        };
        NormalSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
            if (index === 0) {
                array.unshift.apply(array, this.elements);
            } else {
                array.splice.apply(array, [
                    index, 
                    0
                ].concat(this.elements));
            }
        };
        return NormalSeparatedSyntaxList;
    })();    
    function separatedList(nodes) {
        return separatedListAndValidate(nodes, false);
    }
    Syntax.separatedList = separatedList;
    function separatedListAndValidate(nodes, validate) {
        if (nodes === undefined || nodes === null || nodes.length === 0) {
            return Syntax.emptySeparatedList;
        }
        if (validate) {
            for(var i = 0; i < nodes.length; i++) {
                var item = nodes[i];
                if (i % 2 === 1) {
                }
            }
        }
        if (nodes.length === 1) {
            return new SingletonSeparatedSyntaxList(nodes[0]);
        }
        return new NormalSeparatedSyntaxList(nodes);
    }
})(Syntax || (Syntax = {}));
var Syntax;
(function (Syntax) {
    var EmptySyntaxList = (function () {
        function EmptySyntaxList() { }
        EmptySyntaxList.prototype.kind = function () {
            return 1 /* List */ ;
        };
        EmptySyntaxList.prototype.isNode = function () {
            return false;
        };
        EmptySyntaxList.prototype.isToken = function () {
            return false;
        };
        EmptySyntaxList.prototype.isList = function () {
            return true;
        };
        EmptySyntaxList.prototype.isSeparatedList = function () {
            return false;
        };
        EmptySyntaxList.prototype.toJSON = function (key) {
            return [];
        };
        EmptySyntaxList.prototype.childCount = function () {
            return 0;
        };
        EmptySyntaxList.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange("index");
        };
        EmptySyntaxList.prototype.toArray = function () {
            return [];
        };
        EmptySyntaxList.prototype.collectTextElements = function (elements) {
        };
        EmptySyntaxList.prototype.firstToken = function () {
            return null;
        };
        EmptySyntaxList.prototype.lastToken = function () {
            return null;
        };
        EmptySyntaxList.prototype.fullWidth = function () {
            return 0;
        };
        EmptySyntaxList.prototype.width = function () {
            return 0;
        };
        EmptySyntaxList.prototype.leadingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        EmptySyntaxList.prototype.trailingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        EmptySyntaxList.prototype.leadingTriviaWidth = function () {
            return 0;
        };
        EmptySyntaxList.prototype.trailingTriviaWidth = function () {
            return 0;
        };
        EmptySyntaxList.prototype.fullText = function () {
            return "";
        };
        EmptySyntaxList.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        EmptySyntaxList.prototype.hasSkippedText = function () {
            return false;
        };
        EmptySyntaxList.prototype.hasZeroWidthToken = function () {
            return false;
        };
        EmptySyntaxList.prototype.hasRegularExpressionToken = function () {
            return false;
        };
        EmptySyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
            throw Errors.invalidOperation();
        };
        EmptySyntaxList.prototype.insertChildrenInto = function (array, index) {
        };
        return EmptySyntaxList;
    })();    
    Syntax.emptyList = new EmptySyntaxList();
    var SingletonSyntaxList = (function () {
        function SingletonSyntaxList(item) {
            this.item = item;
        }
        SingletonSyntaxList.prototype.kind = function () {
            return 1 /* List */ ;
        };
        SingletonSyntaxList.prototype.isToken = function () {
            return false;
        };
        SingletonSyntaxList.prototype.isNode = function () {
            return false;
        };
        SingletonSyntaxList.prototype.isList = function () {
            return true;
        };
        SingletonSyntaxList.prototype.isSeparatedList = function () {
            return false;
        };
        SingletonSyntaxList.prototype.toJSON = function (key) {
            return [
                this.item
            ];
        };
        SingletonSyntaxList.prototype.childCount = function () {
            return 1;
        };
        SingletonSyntaxList.prototype.childAt = function (index) {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.item;
        };
        SingletonSyntaxList.prototype.toArray = function () {
            return [
                this.item
            ];
        };
        SingletonSyntaxList.prototype.collectTextElements = function (elements) {
            this.item.collectTextElements(elements);
        };
        SingletonSyntaxList.prototype.firstToken = function () {
            return this.item.firstToken();
        };
        SingletonSyntaxList.prototype.lastToken = function () {
            return this.item.lastToken();
        };
        SingletonSyntaxList.prototype.fullWidth = function () {
            return this.item.fullWidth();
        };
        SingletonSyntaxList.prototype.width = function () {
            return this.item.width();
        };
        SingletonSyntaxList.prototype.leadingTrivia = function () {
            return this.item.leadingTrivia();
        };
        SingletonSyntaxList.prototype.trailingTrivia = function () {
            return this.item.trailingTrivia();
        };
        SingletonSyntaxList.prototype.leadingTriviaWidth = function () {
            return this.item.leadingTriviaWidth();
        };
        SingletonSyntaxList.prototype.trailingTriviaWidth = function () {
            return this.item.trailingTriviaWidth();
        };
        SingletonSyntaxList.prototype.fullText = function () {
            return this.item.fullText();
        };
        SingletonSyntaxList.prototype.isTypeScriptSpecific = function () {
            return this.item.isTypeScriptSpecific();
        };
        SingletonSyntaxList.prototype.hasSkippedText = function () {
            return this.item.hasSkippedText();
        };
        SingletonSyntaxList.prototype.hasZeroWidthToken = function () {
            return this.item.hasZeroWidthToken();
        };
        SingletonSyntaxList.prototype.hasRegularExpressionToken = function () {
            return this.item.hasRegularExpressionToken();
        };
        SingletonSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
            return (this.item).findTokenInternal(new PositionedList(parent, this, fullStart), position, fullStart);
        };
        SingletonSyntaxList.prototype.insertChildrenInto = function (array, index) {
            array.splice(index, 0, this.item);
        };
        return SingletonSyntaxList;
    })();    
    var NormalSyntaxList = (function () {
        function NormalSyntaxList(nodeOrTokens) {
            this._data = -1;
            this.nodeOrTokens = nodeOrTokens;
        }
        NormalSyntaxList.prototype.kind = function () {
            return 1 /* List */ ;
        };
        NormalSyntaxList.prototype.isNode = function () {
            return false;
        };
        NormalSyntaxList.prototype.isToken = function () {
            return false;
        };
        NormalSyntaxList.prototype.isList = function () {
            return true;
        };
        NormalSyntaxList.prototype.isSeparatedList = function () {
            return false;
        };
        NormalSyntaxList.prototype.toJSON = function (key) {
            return this.nodeOrTokens;
        };
        NormalSyntaxList.prototype.childCount = function () {
            return this.nodeOrTokens.length;
        };
        NormalSyntaxList.prototype.childAt = function (index) {
            if (index < 0 || index >= this.nodeOrTokens.length) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.nodeOrTokens[index];
        };
        NormalSyntaxList.prototype.toArray = function () {
            return this.nodeOrTokens.slice(0);
        };
        NormalSyntaxList.prototype.collectTextElements = function (elements) {
            for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var element = this.nodeOrTokens[i];
                element.collectTextElements(elements);
            }
        };
        NormalSyntaxList.prototype.firstToken = function () {
            for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var token = this.nodeOrTokens[i].firstToken();
                if (token !== null) {
                    return token;
                }
            }
            return null;
        };
        NormalSyntaxList.prototype.lastToken = function () {
            for(var i = this.nodeOrTokens.length - 1; i >= 0; i--) {
                var token = this.nodeOrTokens[i].lastToken();
                if (token !== null) {
                    return token;
                }
            }
            return null;
        };
        NormalSyntaxList.prototype.fullText = function () {
            var elements = [];
            this.collectTextElements(elements);
            return elements.join("");
        };
        NormalSyntaxList.prototype.isTypeScriptSpecific = function () {
            for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                if (this.nodeOrTokens[i].isTypeScriptSpecific()) {
                    return true;
                }
            }
            return false;
        };
        NormalSyntaxList.prototype.hasSkippedText = function () {
            return (this.data() & 1 /* NodeSkippedTextMask */ ) !== 0;
        };
        NormalSyntaxList.prototype.hasZeroWidthToken = function () {
            return (this.data() & 2 /* NodeZeroWidthTokenMask */ ) !== 0;
        };
        NormalSyntaxList.prototype.hasRegularExpressionToken = function () {
            return (this.data() & 4 /* NodeRegularExpressionTokenMask */ ) !== 0;
        };
        NormalSyntaxList.prototype.fullWidth = function () {
            return this.data() >>> 4 /* NodeFullWidthShift */ ;
        };
        NormalSyntaxList.prototype.width = function () {
            var fullWidth = this.fullWidth();
            return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        };
        NormalSyntaxList.prototype.leadingTrivia = function () {
            return this.firstToken().leadingTrivia();
        };
        NormalSyntaxList.prototype.trailingTrivia = function () {
            return this.lastToken().trailingTrivia();
        };
        NormalSyntaxList.prototype.leadingTriviaWidth = function () {
            return this.firstToken().leadingTriviaWidth();
        };
        NormalSyntaxList.prototype.trailingTriviaWidth = function () {
            return this.lastToken().trailingTriviaWidth();
        };
        NormalSyntaxList.prototype.computeData = function () {
            var fullWidth = 0;
            var hasSkippedText = false;
            var hasZeroWidthToken = false;
            var hasRegularExpressionToken = false;
            for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var node = this.nodeOrTokens[i];
                fullWidth += node.fullWidth();
                hasSkippedText = hasSkippedText || node.hasSkippedText();
                hasZeroWidthToken = hasZeroWidthToken || node.hasZeroWidthToken();
                hasRegularExpressionToken = hasRegularExpressionToken || node.hasRegularExpressionToken();
            }
            return (fullWidth << 4 /* NodeFullWidthShift */ ) | (hasSkippedText ? 1 /* NodeSkippedTextMask */  : 0) | (hasZeroWidthToken ? 2 /* NodeZeroWidthTokenMask */  : 0) | (hasRegularExpressionToken ? 4 /* NodeRegularExpressionTokenMask */  : 0);
        };
        NormalSyntaxList.prototype.data = function () {
            if (this._data === -1) {
                this._data = this.computeData();
            }
            return this._data;
        };
        NormalSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
            parent = new PositionedList(parent, this, fullStart);
            for(var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var nodeOrToken = this.nodeOrTokens[i];
                var childWidth = nodeOrToken.fullWidth();
                if (position < childWidth) {
                    return (nodeOrToken).findTokenInternal(parent, position, fullStart);
                }
                position -= childWidth;
                fullStart += childWidth;
            }
            throw Errors.invalidOperation();
        };
        NormalSyntaxList.prototype.insertChildrenInto = function (array, index) {
            if (index === 0) {
                array.unshift.apply(array, this.nodeOrTokens);
            } else {
                array.splice.apply(array, [
                    index, 
                    0
                ].concat(this.nodeOrTokens));
            }
        };
        return NormalSyntaxList;
    })();    
    function list(nodes) {
        if (nodes === undefined || nodes === null || nodes.length === 0) {
            return Syntax.emptyList;
        }
        if (nodes.length === 1) {
            var item = nodes[0];
            return new SingletonSyntaxList(item);
        }
        return new NormalSyntaxList(nodes);
    }
    Syntax.list = list;
})(Syntax || (Syntax = {}));
var Hash = (function () {
    function Hash() { }
    Hash.FNV_BASE = 2166136261;
    Hash.FNV_PRIME = 16777619;
    Hash.computeFnv1aCharArrayHashCode = function computeFnv1aCharArrayHashCode(text, start, len) {
        var hashCode = Hash.FNV_BASE;
        var end = start + len;
        for(var i = start; i < end; i++) {
            hashCode = (hashCode ^ text[i]) * Hash.FNV_PRIME;
        }
        return hashCode;
    };
    Hash.computeSimple31BitCharArrayHashCode = function computeSimple31BitCharArrayHashCode(key, start, len) {
        var hash = 0;
        for(var i = 0; i < len; i++) {
            var ch = key[start + i];
            hash = (((hash << 5) + hash) + ch) | 0;
        }
        return hash & 0x7FFFFFFF;
    };
    Hash.computeSimple31BitStringHashCode = function computeSimple31BitStringHashCode(key) {
        var hash = 0;
        var start = 0;
        var len = key.length;
        for(var i = 0; i < len; i++) {
            var ch = key.charCodeAt(start + i);
            hash = (((hash << 5) + hash) + ch) | 0;
        }
        return hash & 0x7FFFFFFF;
    };
    Hash.computeMurmur2CharArrayHashCode = function computeMurmur2CharArrayHashCode(key, start, len) {
        var m = 0x5bd1e995;
        var r = 24;
        var numberOfCharsLeft = len;
        var h = (0 ^ numberOfCharsLeft);
        var index = start;
        while(numberOfCharsLeft >= 2) {
            var c1 = key[index];
            var c2 = key[index + 1];
            var k = c1 | (c2 << 16);
            k *= m;
            k ^= k >> r;
            k *= m;
            h *= m;
            h ^= k;
            index += 2;
            numberOfCharsLeft -= 2;
        }
        if (numberOfCharsLeft === 1) {
            h ^= key[index];
            h *= m;
        }
        h ^= h >> 13;
        h *= m;
        h ^= h >> 15;
        return h;
    };
    Hash.computeMurmur2StringHashCode = function computeMurmur2StringHashCode(key) {
        var m = 0x5bd1e995;
        var r = 24;
        var start = 0;
        var len = key.length;
        var numberOfCharsLeft = len;
        var h = (0 ^ numberOfCharsLeft);
        var index = start;
        while(numberOfCharsLeft >= 2) {
            var c1 = key.charCodeAt(index);
            var c2 = key.charCodeAt(index + 1);
            var k = c1 | (c2 << 16);
            k *= m;
            k ^= k >> r;
            k *= m;
            h *= m;
            h ^= k;
            index += 2;
            numberOfCharsLeft -= 2;
        }
        if (numberOfCharsLeft === 1) {
            h ^= key.charCodeAt(index);
            h *= m;
        }
        h ^= h >> 13;
        h *= m;
        h ^= h >> 15;
        return h;
    };
    Hash.primes = [
        3, 
        7, 
        11, 
        17, 
        23, 
        29, 
        37, 
        47, 
        59, 
        71, 
        89, 
        107, 
        131, 
        163, 
        197, 
        239, 
        293, 
        353, 
        431, 
        521, 
        631, 
        761, 
        919, 
        1103, 
        1327, 
        1597, 
        1931, 
        2333, 
        2801, 
        3371, 
        4049, 
        4861, 
        5839, 
        7013, 
        8419, 
        10103, 
        12143, 
        14591, 
        17519, 
        21023, 
        25229, 
        30293, 
        36353, 
        43627, 
        52361, 
        62851, 
        75431, 
        90523, 
        108631, 
        130363, 
        156437, 
        187751, 
        225307, 
        270371, 
        324449, 
        389357, 
        467237, 
        560689, 
        672827, 
        807403, 
        968897, 
        1162687, 
        1395263, 
        1674319, 
        2009191, 
        2411033, 
        2893249, 
        3471899, 
        4166287, 
        4999559, 
        5999471, 
        7199369
    ];
    Hash.getPrime = function getPrime(min) {
        for(var i = 0; i < Hash.primes.length; i++) {
            var num = Hash.primes[i];
            if (num >= min) {
                return num;
            }
        }
        throw Errors.notYetImplemented();
    };
    Hash.expandPrime = function expandPrime(oldSize) {
        var num = oldSize << 1;
        if (num > 2146435069 && 2146435069 > oldSize) {
            return 2146435069;
        }
        return Hash.getPrime(num);
    };
    Hash.combine = function combine(value, currentHash) {
        return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
    };
    return Hash;
})();
var ArrayUtilities = (function () {
    function ArrayUtilities() { }
    ArrayUtilities.isArray = function isArray(value) {
        return Object.prototype.toString.apply(value, []) === '[object Array]';
    };
    ArrayUtilities.sequenceEquals = function sequenceEquals(array1, array2, equals) {
        if (array1 === array2) {
            return true;
        }
        if (array1 === null || array2 === null) {
            return false;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for(var i = 0, n = array1.length; i < n; i++) {
            if (!equals(array1[i], array2[i])) {
                return false;
            }
        }
        return true;
    };
    ArrayUtilities.contains = function contains(array, value) {
        for(var i = 0; i < array.length; i++) {
            if (array[i] === value) {
                return true;
            }
        }
        return false;
    };
    ArrayUtilities.groupBy = function groupBy(array, func) {
        var result = {};
        for(var i = 0, n = array.length; i < n; i++) {
            var v = array[i];
            var k = func(v);
            var list = result[k] || [];
            list.push(v);
            result[k] = list;
        }
        return result;
    };
    ArrayUtilities.min = function min(array, func) {
        var min = func(array[0]);
        for(var i = 1; i < array.length; i++) {
            var next = func(array[i]);
            if (next < min) {
                min = next;
            }
        }
        return min;
    };
    ArrayUtilities.max = function max(array, func) {
        var max = func(array[0]);
        for(var i = 1; i < array.length; i++) {
            var next = func(array[i]);
            if (next > max) {
                max = next;
            }
        }
        return max;
    };
    ArrayUtilities.last = function last(array) {
        if (array.length === 0) {
            throw Errors.argumentOutOfRange('array');
        }
        return array[array.length - 1];
    };
    ArrayUtilities.firstOrDefault = function firstOrDefault(array, func) {
        for(var i = 0, n = array.length; i < n; i++) {
            var value = array[i];
            if (func(value)) {
                return value;
            }
        }
        return null;
    };
    ArrayUtilities.sum = function sum(array, func) {
        var result = 0;
        for(var i = 0, n = array.length; i < n; i++) {
            result += func(array[i]);
        }
        return result;
    };
    ArrayUtilities.whereNotNull = function whereNotNull(array) {
        var result = [];
        for(var i = 0; i < array.length; i++) {
            var value = array[i];
            if (value !== null) {
                result.push(value);
            }
        }
        return result;
    };
    ArrayUtilities.select = function select(values, func) {
        var result = [];
        for(var i = 0; i < values.length; i++) {
            result.push(func(values[i]));
        }
        return result;
    };
    ArrayUtilities.where = function where(values, func) {
        var result = [];
        for(var i = 0; i < values.length; i++) {
            if (func(values[i])) {
                result.push(values[i]);
            }
        }
        return result;
    };
    ArrayUtilities.any = function any(array, func) {
        for(var i = 0, n = array.length; i < n; i++) {
            if (func(array[i])) {
                return true;
            }
        }
        return false;
    };
    ArrayUtilities.all = function all(array, func) {
        for(var i = 0, n = array.length; i < n; i++) {
            if (!func(array[i])) {
                return false;
            }
        }
        return true;
    };
    ArrayUtilities.binarySearch = function binarySearch(array, value) {
        var low = 0;
        var high = array.length - 1;
        while(low <= high) {
            var middle = low + ((high - low) >> 1);
            var midValue = array[middle];
            if (midValue === value) {
                return middle;
            } else if (midValue > value) {
                high = middle - 1;
            } else {
                low = middle + 1;
            }
        }
        return ~low;
    };
    ArrayUtilities.createArray = function createArray(length, defaultvalue) {
        var result = [];
        for(var i = 0; i < length; i++) {
            result.push(defaultvalue);
        }
        return result;
    };
    ArrayUtilities.grow = function grow(array, length, defaultValue) {
        var count = length - array.length;
        for(var i = 0; i < count; i++) {
            array.push(defaultValue);
        }
    };
    ArrayUtilities.copy = function copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for(var i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    };
    return ArrayUtilities;
})();
var SlidingWindow = (function () {
    function SlidingWindow(source, window, defaultValue, sourceLength) {
        if (typeof sourceLength === "undefined") { sourceLength = -1; }
        this.source = source;
        this.window = window;
        this.defaultValue = defaultValue;
        this.sourceLength = sourceLength;
        this.windowCount = 0;
        this.windowAbsoluteStartIndex = 0;
        this.currentRelativeItemIndex = 0;
        this._pinCount = 0;
        this.firstPinnedAbsoluteIndex = -1;
    }
    SlidingWindow.prototype.windowAbsoluteEndIndex = function () {
        return this.windowAbsoluteStartIndex + this.windowCount;
    };
    SlidingWindow.prototype.addMoreItemsToWindow = function (argument) {
        if (this.sourceLength >= 0 && this.absoluteIndex() >= this.sourceLength) {
            return false;
        }
        if (this.windowCount >= this.window.length) {
            this.tryShiftOrGrowWindow();
        }
        var spaceAvailable = this.window.length - this.windowCount;
        var amountFetched = this.source.fetchMoreItems(argument, this.windowAbsoluteEndIndex(), this.window, this.windowCount, spaceAvailable);
        this.windowCount += amountFetched;
        return amountFetched > 0;
    };
    SlidingWindow.prototype.tryShiftOrGrowWindow = function () {
        var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);
        var isAllowedToShift = this.firstPinnedAbsoluteIndex === -1 || this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;
        if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
            var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1 ? this.currentRelativeItemIndex : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;
            var shiftCount = this.windowCount - shiftStartIndex;
            if (shiftCount > 0) {
                ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
            }
            this.windowAbsoluteStartIndex += shiftStartIndex;
            this.windowCount -= shiftStartIndex;
            this.currentRelativeItemIndex -= shiftStartIndex;
        } else {
            ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
        }
    };
    SlidingWindow.prototype.absoluteIndex = function () {
        return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
    };
    SlidingWindow.prototype.isAtEndOfSource = function () {
        return this.absoluteIndex() >= this.sourceLength;
    };
    SlidingWindow.prototype.getAndPinAbsoluteIndex = function () {
        var absoluteIndex = this.absoluteIndex();
        var pinCount = this._pinCount++;
        if (pinCount === 0) {
            this.firstPinnedAbsoluteIndex = absoluteIndex;
        }
        return absoluteIndex;
    };
    SlidingWindow.prototype.releaseAndUnpinAbsoluteIndex = function (absoluteIndex) {
        this._pinCount--;
        if (this._pinCount === 0) {
            this.firstPinnedAbsoluteIndex = -1;
        }
    };
    SlidingWindow.prototype.rewindToPinnedIndex = function (absoluteIndex) {
        var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;
        this.currentRelativeItemIndex = relativeIndex;
    };
    SlidingWindow.prototype.currentItem = function (argument) {
        if (this.currentRelativeItemIndex >= this.windowCount) {
            if (!this.addMoreItemsToWindow(argument)) {
                return this.defaultValue;
            }
        }
        return this.window[this.currentRelativeItemIndex];
    };
    SlidingWindow.prototype.peekItemN = function (n) {
        while(this.currentRelativeItemIndex + n >= this.windowCount) {
            if (!this.addMoreItemsToWindow(null)) {
                return this.defaultValue;
            }
        }
        return this.window[this.currentRelativeItemIndex + n];
    };
    SlidingWindow.prototype.moveToNextItem = function () {
        this.currentRelativeItemIndex++;
    };
    SlidingWindow.prototype.disgardAllItemsFromCurrentIndexOnwards = function () {
        this.windowCount = this.currentRelativeItemIndex;
    };
    SlidingWindow.prototype.setAbsoluteIndex = function (absoluteIndex) {
        if (this.absoluteIndex() === absoluteIndex) {
            return;
        }
        if (this._pinCount > 0) {
        }
        if (absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex()) {
            this.currentRelativeItemIndex = (absoluteIndex - this.windowAbsoluteStartIndex);
        } else {
            this.windowAbsoluteStartIndex = absoluteIndex;
            this.windowCount = 0;
            this.currentRelativeItemIndex = 0;
        }
    };
    SlidingWindow.prototype.pinCount = function () {
        return this._pinCount;
    };
    return SlidingWindow;
})();
var CharacterCodes;
(function (CharacterCodes) {
    CharacterCodes._map = [];
    CharacterCodes.nullCharacter = 0;
    CharacterCodes.maxAsciiCharacter = 127;
    CharacterCodes.lineFeed = 10;
    CharacterCodes.carriageReturn = 13;
    CharacterCodes.lineSeparator = 0x2028;
    CharacterCodes.paragraphSeparator = 0x2029;
    CharacterCodes.space = 32;
    CharacterCodes.nextLine = 0x0085;
    CharacterCodes.nonBreakingSpace = 0x00A0;
    CharacterCodes._ = 95;
    CharacterCodes.$ = 36;
    CharacterCodes._0 = 48;
    CharacterCodes._9 = 57;
    CharacterCodes.a = 97;
    CharacterCodes.b = 98;
    CharacterCodes.c = 99;
    CharacterCodes.d = 100;
    CharacterCodes.e = 101;
    CharacterCodes.f = 102;
    CharacterCodes.g = 103;
    CharacterCodes.h = 104;
    CharacterCodes.i = 105;
    CharacterCodes.k = 107;
    CharacterCodes.l = 108;
    CharacterCodes.m = 109;
    CharacterCodes.n = 110;
    CharacterCodes.o = 111;
    CharacterCodes.p = 112;
    CharacterCodes.r = 114;
    CharacterCodes.s = 115;
    CharacterCodes.t = 116;
    CharacterCodes.u = 117;
    CharacterCodes.v = 118;
    CharacterCodes.w = 119;
    CharacterCodes.x = 120;
    CharacterCodes.y = 121;
    CharacterCodes.z = 122;
    CharacterCodes.A = 65;
    CharacterCodes.E = 69;
    CharacterCodes.F = 70;
    CharacterCodes.X = 88;
    CharacterCodes.Z = 90;
    CharacterCodes.ampersand = 38;
    CharacterCodes.asterisk = 42;
    CharacterCodes.backslash = 92;
    CharacterCodes.bar = 124;
    CharacterCodes.caret = 94;
    CharacterCodes.closeBrace = 125;
    CharacterCodes.closeBracket = 93;
    CharacterCodes.closeParen = 41;
    CharacterCodes.colon = 58;
    CharacterCodes.comma = 44;
    CharacterCodes.dot = 46;
    CharacterCodes.doubleQuote = 34;
    CharacterCodes.equals = 61;
    CharacterCodes.exclamation = 33;
    CharacterCodes.greaterThan = 62;
    CharacterCodes.lessThan = 60;
    CharacterCodes.minus = 45;
    CharacterCodes.openBrace = 123;
    CharacterCodes.openBracket = 91;
    CharacterCodes.openParen = 40;
    CharacterCodes.percent = 37;
    CharacterCodes.plus = 43;
    CharacterCodes.question = 63;
    CharacterCodes.semicolon = 59;
    CharacterCodes.singleQuote = 39;
    CharacterCodes.slash = 47;
    CharacterCodes.tilde = 126;
    CharacterCodes.backspace = 8;
    CharacterCodes.formFeed = 12;
    CharacterCodes.byteOrderMark = 0xFEFF;
    CharacterCodes.tab = 9;
    CharacterCodes.verticalTab = 11;
})(CharacterCodes || (CharacterCodes = {}));
var CharacterInfo = (function () {
    function CharacterInfo() { }
    CharacterInfo.isDecimalDigit = function isDecimalDigit(c) {
        return c >= 48 /* _0 */  && c <= 57 /* _9 */ ;
    };
    CharacterInfo.isHexDigit = function isHexDigit(c) {
        return CharacterInfo.isDecimalDigit(c) || (c >= 65 /* A */  && c <= 70 /* F */ ) || (c >= 97 /* a */  && c <= 102 /* f */ );
    };
    CharacterInfo.hexValue = function hexValue(c) {
        return CharacterInfo.isDecimalDigit(c) ? (c - 48 /* _0 */ ) : (c >= 65 /* A */  && c <= 70 /* F */ ) ? c - 65 /* A */  + 10 : c - 97 /* a */  + 10;
    };
    CharacterInfo.isWhitespace = function isWhitespace(ch) {
        switch(ch) {
            case 32 /* space */ :
            case 9 /* tab */ :
            case 11 /* verticalTab */ :
            case 12 /* formFeed */ :
            case 160 /* nonBreakingSpace */ :
            case 65279 /* byteOrderMark */ :
                return true;
        }
        return false;
    };
    CharacterInfo.isLineTerminator = function isLineTerminator(ch) {
        switch(ch) {
            case 13 /* carriageReturn */ :
            case 10 /* lineFeed */ :
            case 8233 /* paragraphSeparator */ :
            case 8232 /* lineSeparator */ :
                return true;
        }
        return false;
    };
    return CharacterInfo;
})();
var SyntaxConstants;
(function (SyntaxConstants) {
    SyntaxConstants._map = [];
    SyntaxConstants.TriviaNewLineMask = 0x00000001;
    SyntaxConstants.TriviaCommentMask = 0x00000002;
    SyntaxConstants.TriviaFullWidthShift = 2;
    SyntaxConstants.NodeSkippedTextMask = 0x00000001;
    SyntaxConstants.NodeZeroWidthTokenMask = 0x00000002;
    SyntaxConstants.NodeRegularExpressionTokenMask = 0x00000004;
    SyntaxConstants.NodeParsedInStrictModeMask = 0x00000008;
    SyntaxConstants.NodeFullWidthShift = 4;
})(SyntaxConstants || (SyntaxConstants = {}));
var LanguageVersion;
(function (LanguageVersion) {
    LanguageVersion._map = [];
    LanguageVersion._map[0] = "EcmaScript3";
    LanguageVersion.EcmaScript3 = 0;
    LanguageVersion._map[1] = "EcmaScript5";
    LanguageVersion.EcmaScript5 = 1;
})(LanguageVersion || (LanguageVersion = {}));
var Contract = (function () {
    function Contract() { }
    Contract.requires = function requires(expression) {
        if (!expression) {
            throw new Error("Contract violated. False expression.");
        }
    };
    Contract.throwIfFalse = function throwIfFalse(expression) {
        if (!expression) {
            throw new Error("Contract violated. False expression.");
        }
    };
    Contract.throwIfNull = function throwIfNull(value) {
        if (value === null) {
            throw new Error("Contract violated. Null value.");
        }
    };
    return Contract;
})();
var MathPrototype = (function () {
    function MathPrototype() { }
    MathPrototype.max = function max(a, b) {
        return a >= b ? a : b;
    };
    MathPrototype.min = function min(a, b) {
        return a <= b ? a : b;
    };
    return MathPrototype;
})();
var TextSpan = (function () {
    function TextSpan(start, length) {
        if (start < 0) {
            Errors.argument("start");
        }
        if (start + length < start) {
            throw new Error("length");
        }
        this._start = start;
        this._length = length;
    }
    TextSpan.prototype.start = function () {
        return this._start;
    };
    TextSpan.prototype.length = function () {
        return this._length;
    };
    TextSpan.prototype.end = function () {
        return this._start + this._length;
    };
    TextSpan.prototype.isEmpty = function () {
        return this._length === 0;
    };
    TextSpan.prototype.containsPosition = function (position) {
        return position >= this._start && position < this.end();
    };
    TextSpan.prototype.containsTextSpan = function (span) {
        return span._start >= this._start && span.end() <= this.end();
    };
    TextSpan.prototype.overlapsWith = function (span) {
        var overlapStart = MathPrototype.max(this._start, span._start);
        var overlapEnd = MathPrototype.min(this.end(), span.end());
        return overlapStart < overlapEnd;
    };
    TextSpan.prototype.overlap = function (span) {
        var overlapStart = MathPrototype.max(this._start, span._start);
        var overlapEnd = MathPrototype.min(this.end(), span.end());
        if (overlapStart < overlapEnd) {
            return TextSpan.fromBounds(overlapStart, overlapEnd);
        }
        return null;
    };
    TextSpan.prototype.intersectsWithTextSpan = function (span) {
        return span._start <= this.end() && span.end() >= this._start;
    };
    TextSpan.prototype.intersectsWith = function (start, length) {
        var end = start + length;
        return start <= this.end() && end >= this._start;
    };
    TextSpan.prototype.intersectsWithPosition = function (position) {
        return position <= this.end() && position >= this._start;
    };
    TextSpan.prototype.intersection = function (span) {
        var intersectStart = MathPrototype.max(this._start, span._start);
        var intersectEnd = MathPrototype.min(this.end(), span.end());
        if (intersectStart <= intersectEnd) {
            return TextSpan.fromBounds(intersectStart, intersectEnd);
        }
        return null;
    };
    TextSpan.fromBounds = function fromBounds(start, end) {
        Contract.requires(start >= 0);
        Contract.requires(end - start >= 0);
        return new TextSpan(start, end - start);
    };
    return TextSpan;
})();
var LinePosition = (function () {
    function LinePosition(line, character) {
        this._line = 0;
        this._character = 0;
        if (line < 0) {
            throw Errors.argumentOutOfRange("line");
        }
        if (character < 0) {
            throw Errors.argumentOutOfRange("character");
        }
        this._line = line;
        this._character = character;
    }
    LinePosition.prototype.line = function () {
        return this._line;
    };
    LinePosition.prototype.character = function () {
        return this._character;
    };
    return LinePosition;
})();
var ScannerUtilities = (function () {
    function ScannerUtilities() { }
    ScannerUtilities.identifierKind = function identifierKind(array, startIndex, length) {
        switch(length) {
            case 2:
                switch(array[startIndex]) {
                    case 100 /* d */ :
                        return (array[startIndex + 1] === 111 /* o */ ) ? 22 /* DoKeyword */  : 11 /* IdentifierName */ ;
                    case 105 /* i */ :
                        switch(array[startIndex + 1]) {
                            case 102 /* f */ :
                                return 28 /* IfKeyword */ ;
                            case 110 /* n */ :
                                return 29 /* InKeyword */ ;
                            default:
                                return 11 /* IdentifierName */ ;
                        }
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 3:
                switch(array[startIndex]) {
                    case 102 /* f */ :
                        return (array[startIndex + 1] === 111 /* o */  && array[startIndex + 2] === 114 /* r */ ) ? 26 /* ForKeyword */  : 11 /* IdentifierName */ ;
                    case 110 /* n */ :
                        return (array[startIndex + 1] === 101 /* e */  && array[startIndex + 2] === 119 /* w */ ) ? 31 /* NewKeyword */  : 11 /* IdentifierName */ ;
                    case 116 /* t */ :
                        return (array[startIndex + 1] === 114 /* r */  && array[startIndex + 2] === 121 /* y */ ) ? 38 /* TryKeyword */  : 11 /* IdentifierName */ ;
                    case 118 /* v */ :
                        return (array[startIndex + 1] === 97 /* a */  && array[startIndex + 2] === 114 /* r */ ) ? 40 /* VarKeyword */  : 11 /* IdentifierName */ ;
                    case 108 /* l */ :
                        return (array[startIndex + 1] === 101 /* e */  && array[startIndex + 2] === 116 /* t */ ) ? 53 /* LetKeyword */  : 11 /* IdentifierName */ ;
                    case 97 /* a */ :
                        return (array[startIndex + 1] === 110 /* n */  && array[startIndex + 2] === 121 /* y */ ) ? 60 /* AnyKeyword */  : 11 /* IdentifierName */ ;
                    case 103 /* g */ :
                        return (array[startIndex + 1] === 101 /* e */  && array[startIndex + 2] === 116 /* t */ ) ? 65 /* GetKeyword */  : 11 /* IdentifierName */ ;
                    case 115 /* s */ :
                        return (array[startIndex + 1] === 101 /* e */  && array[startIndex + 2] === 116 /* t */ ) ? 68 /* SetKeyword */  : 11 /* IdentifierName */ ;
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 4:
                switch(array[startIndex]) {
                    case 99 /* c */ :
                        return (array[startIndex + 1] === 97 /* a */  && array[startIndex + 2] === 115 /* s */  && array[startIndex + 3] === 101 /* e */ ) ? 16 /* CaseKeyword */  : 11 /* IdentifierName */ ;
                    case 101 /* e */ :
                        switch(array[startIndex + 1]) {
                            case 108 /* l */ :
                                return (array[startIndex + 2] === 115 /* s */  && array[startIndex + 3] === 101 /* e */ ) ? 23 /* ElseKeyword */  : 11 /* IdentifierName */ ;
                            case 110 /* n */ :
                                return (array[startIndex + 2] === 117 /* u */  && array[startIndex + 3] === 109 /* m */ ) ? 46 /* EnumKeyword */  : 11 /* IdentifierName */ ;
                            default:
                                return 11 /* IdentifierName */ ;
                        }
                    case 110 /* n */ :
                        return (array[startIndex + 1] === 117 /* u */  && array[startIndex + 2] === 108 /* l */  && array[startIndex + 3] === 108 /* l */ ) ? 32 /* NullKeyword */  : 11 /* IdentifierName */ ;
                    case 116 /* t */ :
                        switch(array[startIndex + 1]) {
                            case 104 /* h */ :
                                return (array[startIndex + 2] === 105 /* i */  && array[startIndex + 3] === 115 /* s */ ) ? 35 /* ThisKeyword */  : 11 /* IdentifierName */ ;
                            case 114 /* r */ :
                                return (array[startIndex + 2] === 117 /* u */  && array[startIndex + 3] === 101 /* e */ ) ? 37 /* TrueKeyword */  : 11 /* IdentifierName */ ;
                            default:
                                return 11 /* IdentifierName */ ;
                        }
                    case 118 /* v */ :
                        return (array[startIndex + 1] === 111 /* o */  && array[startIndex + 2] === 105 /* i */  && array[startIndex + 3] === 100 /* d */ ) ? 41 /* VoidKeyword */  : 11 /* IdentifierName */ ;
                    case 119 /* w */ :
                        return (array[startIndex + 1] === 105 /* i */  && array[startIndex + 2] === 116 /* t */  && array[startIndex + 3] === 104 /* h */ ) ? 43 /* WithKeyword */  : 11 /* IdentifierName */ ;
                    case 98 /* b */ :
                        return (array[startIndex + 1] === 111 /* o */  && array[startIndex + 2] === 111 /* o */  && array[startIndex + 3] === 108 /* l */ ) ? 62 /* BoolKeyword */  : 11 /* IdentifierName */ ;
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 5:
                switch(array[startIndex]) {
                    case 98 /* b */ :
                        return (array[startIndex + 1] === 114 /* r */  && array[startIndex + 2] === 101 /* e */  && array[startIndex + 3] === 97 /* a */  && array[startIndex + 4] === 107 /* k */ ) ? 15 /* BreakKeyword */  : 11 /* IdentifierName */ ;
                    case 99 /* c */ :
                        switch(array[startIndex + 1]) {
                            case 97 /* a */ :
                                return (array[startIndex + 2] === 116 /* t */  && array[startIndex + 3] === 99 /* c */  && array[startIndex + 4] === 104 /* h */ ) ? 17 /* CatchKeyword */  : 11 /* IdentifierName */ ;
                            case 108 /* l */ :
                                return (array[startIndex + 2] === 97 /* a */  && array[startIndex + 3] === 115 /* s */  && array[startIndex + 4] === 115 /* s */ ) ? 44 /* ClassKeyword */  : 11 /* IdentifierName */ ;
                            case 111 /* o */ :
                                return (array[startIndex + 2] === 110 /* n */  && array[startIndex + 3] === 115 /* s */  && array[startIndex + 4] === 116 /* t */ ) ? 45 /* ConstKeyword */  : 11 /* IdentifierName */ ;
                            default:
                                return 11 /* IdentifierName */ ;
                        }
                    case 102 /* f */ :
                        return (array[startIndex + 1] === 97 /* a */  && array[startIndex + 2] === 108 /* l */  && array[startIndex + 3] === 115 /* s */  && array[startIndex + 4] === 101 /* e */ ) ? 24 /* FalseKeyword */  : 11 /* IdentifierName */ ;
                    case 116 /* t */ :
                        return (array[startIndex + 1] === 104 /* h */  && array[startIndex + 2] === 114 /* r */  && array[startIndex + 3] === 111 /* o */  && array[startIndex + 4] === 119 /* w */ ) ? 36 /* ThrowKeyword */  : 11 /* IdentifierName */ ;
                    case 119 /* w */ :
                        return (array[startIndex + 1] === 104 /* h */  && array[startIndex + 2] === 105 /* i */  && array[startIndex + 3] === 108 /* l */  && array[startIndex + 4] === 101 /* e */ ) ? 42 /* WhileKeyword */  : 11 /* IdentifierName */ ;
                    case 115 /* s */ :
                        return (array[startIndex + 1] === 117 /* u */  && array[startIndex + 2] === 112 /* p */  && array[startIndex + 3] === 101 /* e */  && array[startIndex + 4] === 114 /* r */ ) ? 50 /* SuperKeyword */  : 11 /* IdentifierName */ ;
                    case 121 /* y */ :
                        return (array[startIndex + 1] === 105 /* i */  && array[startIndex + 2] === 101 /* e */  && array[startIndex + 3] === 108 /* l */  && array[startIndex + 4] === 100 /* d */ ) ? 59 /* YieldKeyword */  : 11 /* IdentifierName */ ;
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 6:
                switch(array[startIndex]) {
                    case 100 /* d */ :
                        return (array[startIndex + 1] === 101 /* e */  && array[startIndex + 2] === 108 /* l */  && array[startIndex + 3] === 101 /* e */  && array[startIndex + 4] === 116 /* t */  && array[startIndex + 5] === 101 /* e */ ) ? 21 /* DeleteKeyword */  : 11 /* IdentifierName */ ;
                    case 114 /* r */ :
                        return (array[startIndex + 1] === 101 /* e */  && array[startIndex + 2] === 116 /* t */  && array[startIndex + 3] === 117 /* u */  && array[startIndex + 4] === 114 /* r */  && array[startIndex + 5] === 110 /* n */ ) ? 33 /* ReturnKeyword */  : 11 /* IdentifierName */ ;
                    case 115 /* s */ :
                        switch(array[startIndex + 1]) {
                            case 119 /* w */ :
                                return (array[startIndex + 2] === 105 /* i */  && array[startIndex + 3] === 116 /* t */  && array[startIndex + 4] === 99 /* c */  && array[startIndex + 5] === 104 /* h */ ) ? 34 /* SwitchKeyword */  : 11 /* IdentifierName */ ;
                            case 116 /* t */ :
                                switch(array[startIndex + 2]) {
                                    case 97 /* a */ :
                                        return (array[startIndex + 3] === 116 /* t */  && array[startIndex + 4] === 105 /* i */  && array[startIndex + 5] === 99 /* c */ ) ? 58 /* StaticKeyword */  : 11 /* IdentifierName */ ;
                                    case 114 /* r */ :
                                        return (array[startIndex + 3] === 105 /* i */  && array[startIndex + 4] === 110 /* n */  && array[startIndex + 5] === 103 /* g */ ) ? 69 /* StringKeyword */  : 11 /* IdentifierName */ ;
                                    default:
                                        return 11 /* IdentifierName */ ;
                                }
                            default:
                                return 11 /* IdentifierName */ ;
                        }
                    case 116 /* t */ :
                        return (array[startIndex + 1] === 121 /* y */  && array[startIndex + 2] === 112 /* p */  && array[startIndex + 3] === 101 /* e */  && array[startIndex + 4] === 111 /* o */  && array[startIndex + 5] === 102 /* f */ ) ? 39 /* TypeOfKeyword */  : 11 /* IdentifierName */ ;
                    case 101 /* e */ :
                        return (array[startIndex + 1] === 120 /* x */  && array[startIndex + 2] === 112 /* p */  && array[startIndex + 3] === 111 /* o */  && array[startIndex + 4] === 114 /* r */  && array[startIndex + 5] === 116 /* t */ ) ? 47 /* ExportKeyword */  : 11 /* IdentifierName */ ;
                    case 105 /* i */ :
                        return (array[startIndex + 1] === 109 /* m */  && array[startIndex + 2] === 112 /* p */  && array[startIndex + 3] === 111 /* o */  && array[startIndex + 4] === 114 /* r */  && array[startIndex + 5] === 116 /* t */ ) ? 49 /* ImportKeyword */  : 11 /* IdentifierName */ ;
                    case 112 /* p */ :
                        return (array[startIndex + 1] === 117 /* u */  && array[startIndex + 2] === 98 /* b */  && array[startIndex + 3] === 108 /* l */  && array[startIndex + 4] === 105 /* i */  && array[startIndex + 5] === 99 /* c */ ) ? 57 /* PublicKeyword */  : 11 /* IdentifierName */ ;
                    case 109 /* m */ :
                        return (array[startIndex + 1] === 111 /* o */  && array[startIndex + 2] === 100 /* d */  && array[startIndex + 3] === 117 /* u */  && array[startIndex + 4] === 108 /* l */  && array[startIndex + 5] === 101 /* e */ ) ? 66 /* ModuleKeyword */  : 11 /* IdentifierName */ ;
                    case 110 /* n */ :
                        return (array[startIndex + 1] === 117 /* u */  && array[startIndex + 2] === 109 /* m */  && array[startIndex + 3] === 98 /* b */  && array[startIndex + 4] === 101 /* e */  && array[startIndex + 5] === 114 /* r */ ) ? 67 /* NumberKeyword */  : 11 /* IdentifierName */ ;
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 7:
                switch(array[startIndex]) {
                    case 100 /* d */ :
                        switch(array[startIndex + 1]) {
                            case 101 /* e */ :
                                switch(array[startIndex + 2]) {
                                    case 102 /* f */ :
                                        return (array[startIndex + 3] === 97 /* a */  && array[startIndex + 4] === 117 /* u */  && array[startIndex + 5] === 108 /* l */  && array[startIndex + 6] === 116 /* t */ ) ? 20 /* DefaultKeyword */  : 11 /* IdentifierName */ ;
                                    case 99 /* c */ :
                                        return (array[startIndex + 3] === 108 /* l */  && array[startIndex + 4] === 97 /* a */  && array[startIndex + 5] === 114 /* r */  && array[startIndex + 6] === 101 /* e */ ) ? 64 /* DeclareKeyword */  : 11 /* IdentifierName */ ;
                                    default:
                                        return 11 /* IdentifierName */ ;
                                }
                            default:
                                return 11 /* IdentifierName */ ;
                        }
                    case 102 /* f */ :
                        return (array[startIndex + 1] === 105 /* i */  && array[startIndex + 2] === 110 /* n */  && array[startIndex + 3] === 97 /* a */  && array[startIndex + 4] === 108 /* l */  && array[startIndex + 5] === 108 /* l */  && array[startIndex + 6] === 121 /* y */ ) ? 25 /* FinallyKeyword */  : 11 /* IdentifierName */ ;
                    case 101 /* e */ :
                        return (array[startIndex + 1] === 120 /* x */  && array[startIndex + 2] === 116 /* t */  && array[startIndex + 3] === 101 /* e */  && array[startIndex + 4] === 110 /* n */  && array[startIndex + 5] === 100 /* d */  && array[startIndex + 6] === 115 /* s */ ) ? 48 /* ExtendsKeyword */  : 11 /* IdentifierName */ ;
                    case 112 /* p */ :
                        switch(array[startIndex + 1]) {
                            case 97 /* a */ :
                                return (array[startIndex + 2] === 99 /* c */  && array[startIndex + 3] === 107 /* k */  && array[startIndex + 4] === 97 /* a */  && array[startIndex + 5] === 103 /* g */  && array[startIndex + 6] === 101 /* e */ ) ? 54 /* PackageKeyword */  : 11 /* IdentifierName */ ;
                            case 114 /* r */ :
                                return (array[startIndex + 2] === 105 /* i */  && array[startIndex + 3] === 118 /* v */  && array[startIndex + 4] === 97 /* a */  && array[startIndex + 5] === 116 /* t */  && array[startIndex + 6] === 101 /* e */ ) ? 55 /* PrivateKeyword */  : 11 /* IdentifierName */ ;
                            default:
                                return 11 /* IdentifierName */ ;
                        }
                    case 98 /* b */ :
                        return (array[startIndex + 1] === 111 /* o */  && array[startIndex + 2] === 111 /* o */  && array[startIndex + 3] === 108 /* l */  && array[startIndex + 4] === 101 /* e */  && array[startIndex + 5] === 97 /* a */  && array[startIndex + 6] === 110 /* n */ ) ? 61 /* BooleanKeyword */  : 11 /* IdentifierName */ ;
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 8:
                switch(array[startIndex]) {
                    case 99 /* c */ :
                        return (array[startIndex + 1] === 111 /* o */  && array[startIndex + 2] === 110 /* n */  && array[startIndex + 3] === 116 /* t */  && array[startIndex + 4] === 105 /* i */  && array[startIndex + 5] === 110 /* n */  && array[startIndex + 6] === 117 /* u */  && array[startIndex + 7] === 101 /* e */ ) ? 18 /* ContinueKeyword */  : 11 /* IdentifierName */ ;
                    case 100 /* d */ :
                        return (array[startIndex + 1] === 101 /* e */  && array[startIndex + 2] === 98 /* b */  && array[startIndex + 3] === 117 /* u */  && array[startIndex + 4] === 103 /* g */  && array[startIndex + 5] === 103 /* g */  && array[startIndex + 6] === 101 /* e */  && array[startIndex + 7] === 114 /* r */ ) ? 19 /* DebuggerKeyword */  : 11 /* IdentifierName */ ;
                    case 102 /* f */ :
                        return (array[startIndex + 1] === 117 /* u */  && array[startIndex + 2] === 110 /* n */  && array[startIndex + 3] === 99 /* c */  && array[startIndex + 4] === 116 /* t */  && array[startIndex + 5] === 105 /* i */  && array[startIndex + 6] === 111 /* o */  && array[startIndex + 7] === 110 /* n */ ) ? 27 /* FunctionKeyword */  : 11 /* IdentifierName */ ;
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 9:
                switch(array[startIndex]) {
                    case 105 /* i */ :
                        return (array[startIndex + 1] === 110 /* n */  && array[startIndex + 2] === 116 /* t */  && array[startIndex + 3] === 101 /* e */  && array[startIndex + 4] === 114 /* r */  && array[startIndex + 5] === 102 /* f */  && array[startIndex + 6] === 97 /* a */  && array[startIndex + 7] === 99 /* c */  && array[startIndex + 8] === 101 /* e */ ) ? 52 /* InterfaceKeyword */  : 11 /* IdentifierName */ ;
                    case 112 /* p */ :
                        return (array[startIndex + 1] === 114 /* r */  && array[startIndex + 2] === 111 /* o */  && array[startIndex + 3] === 116 /* t */  && array[startIndex + 4] === 101 /* e */  && array[startIndex + 5] === 99 /* c */  && array[startIndex + 6] === 116 /* t */  && array[startIndex + 7] === 101 /* e */  && array[startIndex + 8] === 100 /* d */ ) ? 56 /* ProtectedKeyword */  : 11 /* IdentifierName */ ;
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 10:
                switch(array[startIndex]) {
                    case 105 /* i */ :
                        switch(array[startIndex + 1]) {
                            case 110 /* n */ :
                                return (array[startIndex + 2] === 115 /* s */  && array[startIndex + 3] === 116 /* t */  && array[startIndex + 4] === 97 /* a */  && array[startIndex + 5] === 110 /* n */  && array[startIndex + 6] === 99 /* c */  && array[startIndex + 7] === 101 /* e */  && array[startIndex + 8] === 111 /* o */  && array[startIndex + 9] === 102 /* f */ ) ? 30 /* InstanceOfKeyword */  : 11 /* IdentifierName */ ;
                            case 109 /* m */ :
                                return (array[startIndex + 2] === 112 /* p */  && array[startIndex + 3] === 108 /* l */  && array[startIndex + 4] === 101 /* e */  && array[startIndex + 5] === 109 /* m */  && array[startIndex + 6] === 101 /* e */  && array[startIndex + 7] === 110 /* n */  && array[startIndex + 8] === 116 /* t */  && array[startIndex + 9] === 115 /* s */ ) ? 51 /* ImplementsKeyword */  : 11 /* IdentifierName */ ;
                            default:
                                return 11 /* IdentifierName */ ;
                        }
                    default:
                        return 11 /* IdentifierName */ ;
                }
            case 11:
                return (array[startIndex] === 99 /* c */  && array[startIndex + 1] === 111 /* o */  && array[startIndex + 2] === 110 /* n */  && array[startIndex + 3] === 115 /* s */  && array[startIndex + 4] === 116 /* t */  && array[startIndex + 5] === 114 /* r */  && array[startIndex + 6] === 117 /* u */  && array[startIndex + 7] === 99 /* c */  && array[startIndex + 8] === 116 /* t */  && array[startIndex + 9] === 111 /* o */  && array[startIndex + 10] === 114 /* r */ ) ? 63 /* ConstructorKeyword */  : 11 /* IdentifierName */ ;
            default:
                return 11 /* IdentifierName */ ;
        }
    };
    return ScannerUtilities;
})();
var StringUtilities = (function () {
    function StringUtilities() { }
    StringUtilities.fromCharCodeArray = function fromCharCodeArray(array) {
        return String.fromCharCode.apply(null, array);
    };
    StringUtilities.endsWith = function endsWith(string, value) {
        return string.substring(string.length - value.length, string.length) === value;
    };
    StringUtilities.startsWith = function startsWith(string, value) {
        return string.substr(0, value.length) === value;
    };
    StringUtilities.copyTo = function copyTo(source, sourceIndex, destination, destinationIndex, count) {
        for(var i = 0; i < count; i++) {
            destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
        }
    };
    StringUtilities.repeat = function repeat(value, count) {
        return Array(count + 1).join(value);
    };
    return StringUtilities;
})();
var Collections;
(function (Collections) {
    Collections.DefaultStringTableCapacity = 256;
    var StringTableEntry = (function () {
        function StringTableEntry(Text, HashCode, Next) {
            this.Text = Text;
            this.HashCode = HashCode;
            this.Next = Next;
        }
        return StringTableEntry;
    })();    
    var StringTable = (function () {
        function StringTable(capacity) {
            this.entries = [];
            this.count = 0;
            var size = Hash.getPrime(capacity);
            this.entries = ArrayUtilities.createArray(size, null);
        }
        StringTable.prototype.addCharArray = function (key, start, len) {
            var hashCode = Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;
            var entry = this.findCharArrayEntry(key, start, len, hashCode);
            if (entry !== null) {
                return entry.Text;
            }
            var slice = key.slice(start, start + len);
            return this.addEntry(StringUtilities.fromCharCodeArray(slice), hashCode);
        };
        StringTable.prototype.findCharArrayEntry = function (key, start, len, hashCode) {
            for(var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                    return e;
                }
            }
            return null;
        };
        StringTable.prototype.addEntry = function (text, hashCode) {
            var index = hashCode % this.entries.length;
            var e = new StringTableEntry(text, hashCode, this.entries[index]);
            this.entries[index] = e;
            if (this.count === this.entries.length) {
                this.grow();
            }
            this.count++;
            return e.Text;
        };
        StringTable.prototype.grow = function () {
            var newSize = Hash.expandPrime(this.entries.length);
            var oldEntries = this.entries;
            var newEntries = ArrayUtilities.createArray(newSize, null);
            this.entries = newEntries;
            for(var i = 0; i < oldEntries.length; i++) {
                var e = oldEntries[i];
                while(e !== null) {
                    var newIndex = e.HashCode % newSize;
                    var tmp = e.Next;
                    e.Next = newEntries[newIndex];
                    newEntries[newIndex] = e;
                    e = tmp;
                }
            }
        };
        StringTable.textCharArrayEquals = function textCharArrayEquals(text, array, start, length) {
            if (text.length !== length) {
                return false;
            }
            var s = start;
            for(var i = 0; i < length; i++) {
                if (text.charCodeAt(i) !== array[s]) {
                    return false;
                }
                s++;
            }
            return true;
        };
        return StringTable;
    })();
    Collections.StringTable = StringTable;    
    function createStringTable(capacity) {
        if (typeof capacity === "undefined") { capacity = Collections.DefaultStringTableCapacity; }
        return new StringTable(capacity);
    }
    Collections.createStringTable = createStringTable;
})(Collections || (Collections = {}));
var DiagnosticCode;
(function (DiagnosticCode) {
    DiagnosticCode._map = [];
    DiagnosticCode._map[0] = "Unrecognized_escape_sequence";
    DiagnosticCode.Unrecognized_escape_sequence = 0;
    DiagnosticCode._map[1] = "Unexpected_character_0";
    DiagnosticCode.Unexpected_character_0 = 1;
    DiagnosticCode._map[2] = "Missing_closing_quote_character";
    DiagnosticCode.Missing_closing_quote_character = 2;
    DiagnosticCode._map[3] = "Identifier_expected";
    DiagnosticCode.Identifier_expected = 3;
    DiagnosticCode._map[4] = "_0_keyword_expected";
    DiagnosticCode._0_keyword_expected = 4;
    DiagnosticCode._map[5] = "_0_expected";
    DiagnosticCode._0_expected = 5;
    DiagnosticCode._map[6] = "Identifier_expected__0_is_a_keyword";
    DiagnosticCode.Identifier_expected__0_is_a_keyword = 6;
    DiagnosticCode._map[7] = "Automatic_semicolon_insertion_not_allowed";
    DiagnosticCode.Automatic_semicolon_insertion_not_allowed = 7;
    DiagnosticCode._map[8] = "Unexpected_token__0_expected";
    DiagnosticCode.Unexpected_token__0_expected = 8;
    DiagnosticCode._map[9] = "Trailing_separator_not_allowed";
    DiagnosticCode.Trailing_separator_not_allowed = 9;
    DiagnosticCode._map[10] = "_StarSlash__expected";
    DiagnosticCode._StarSlash__expected = 10;
})(DiagnosticCode || (DiagnosticCode = {}));
var DiagnosticMessages = (function () {
    function DiagnosticMessages() { }
    DiagnosticMessages.codeToFormatString = [];
    DiagnosticMessages.initializeStaticData = function initializeStaticData() {
        if (DiagnosticMessages.codeToFormatString.length === 0) {
            DiagnosticMessages.codeToFormatString[0 /* Unrecognized_escape_sequence */ ] = "Unrecognized escape sequence.";
            DiagnosticMessages.codeToFormatString[1 /* Unexpected_character_0 */ ] = "Unexpected character {0}.";
            DiagnosticMessages.codeToFormatString[2 /* Missing_closing_quote_character */ ] = "Missing close quote character.";
            DiagnosticMessages.codeToFormatString[3 /* Identifier_expected */ ] = "Identifier expected.";
            DiagnosticMessages.codeToFormatString[4 /* _0_keyword_expected */ ] = "'{0}' keyword expected.";
            DiagnosticMessages.codeToFormatString[5 /* _0_expected */ ] = "'{0}' expected.";
            DiagnosticMessages.codeToFormatString[6 /* Identifier_expected__0_is_a_keyword */ ] = "Identifier expected; '{0}' is a keyword.";
            DiagnosticMessages.codeToFormatString[7 /* Automatic_semicolon_insertion_not_allowed */ ] = "Automatic semicolon insertion not allowed.";
            DiagnosticMessages.codeToFormatString[8 /* Unexpected_token__0_expected */ ] = "Unexpected token; '{0}' expected.";
            DiagnosticMessages.codeToFormatString[9 /* Trailing_separator_not_allowed */ ] = "Trailing separator not allowed.";
            DiagnosticMessages.codeToFormatString[10 /* _StarSlash__expected */ ] = "'*/' expected.";
        }
    };
    DiagnosticMessages.getFormatString = function getFormatString(code) {
        DiagnosticMessages.initializeStaticData();
        return DiagnosticMessages.codeToFormatString[code];
    };
    DiagnosticMessages.getDiagnosticMessage = function getDiagnosticMessage(code, args) {
        var formatString = DiagnosticMessages.getFormatString(code);
        var result = formatString.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });
        return result;
    };
    return DiagnosticMessages;
})();
var Diagnostic = (function () {
    function Diagnostic(diagnosticCode, arguments) {
        this._diagnosticCode = diagnosticCode;
        this._arguments = (arguments && arguments.length > 0) ? arguments : null;
    }
    Diagnostic.prototype.diagnosticCode = function () {
        return this._diagnosticCode;
    };
    Diagnostic.prototype.additionalLocations = function () {
        return [];
    };
    Diagnostic.prototype.message = function () {
        return DiagnosticMessages.getDiagnosticMessage(this._diagnosticCode, this._arguments);
    };
    Diagnostic.equals = function equals(diagnostic1, diagnostic2) {
        return diagnostic1._diagnosticCode === diagnostic2._diagnosticCode && ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) {
            return v1 === v2;
        });
    };
    return Diagnostic;
})();
var SyntaxDiagnostic = (function (_super) {
    __extends(SyntaxDiagnostic, _super);
    function SyntaxDiagnostic(position, width, code, args) {
        _super.call(this, code, args);
        if (width < 0) {
            throw Errors.argumentOutOfRange("width");
        }
        this._position = position;
        this._width = width;
    }
    SyntaxDiagnostic.prototype.toJSON = function (key) {
        var result = {};
        result._position = this._position;
        result._width = this._width;
        result._diagnosticCode = (DiagnosticCode)._map[this.diagnosticCode()];
        var arguments = (this)._arguments;
        if (arguments && arguments.length > 0) {
            result._arguments = arguments;
        }
        return result;
    };
    SyntaxDiagnostic.prototype.position = function () {
        return this._position;
    };
    SyntaxDiagnostic.prototype.width = function () {
        return this._width;
    };
    SyntaxDiagnostic.equals = function equals(diagnostic1, diagnostic2) {
        return diagnostic1._position === diagnostic2._position && diagnostic1._width === diagnostic2._width && Diagnostic.equals(diagnostic1, diagnostic2);
    };
    return SyntaxDiagnostic;
})(Diagnostic);
var Syntax;
(function (Syntax) {
    var VariableWidthTokenWithNoTrivia = (function () {
        function VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, textOrWidth) {
            this._value = null;
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._textOrWidth = textOrWidth;
        }
        VariableWidthTokenWithNoTrivia.prototype.clone = function () {
            return new VariableWidthTokenWithNoTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth);
        };
        VariableWidthTokenWithNoTrivia.prototype.isNode = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.isToken = function () {
            return true;
        };
        VariableWidthTokenWithNoTrivia.prototype.isList = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.kind = function () {
            return this.tokenKind;
        };
        VariableWidthTokenWithNoTrivia.prototype.childCount = function () {
            return 0;
        };
        VariableWidthTokenWithNoTrivia.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange('index');
        };
        VariableWidthTokenWithNoTrivia.prototype.fullWidth = function () {
            return this.width();
        };
        VariableWidthTokenWithNoTrivia.prototype.start = function () {
            return this._fullStart;
        };
        VariableWidthTokenWithNoTrivia.prototype.end = function () {
            return this.start() + this.width();
        };
        VariableWidthTokenWithNoTrivia.prototype.width = function () {
            return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
        };
        VariableWidthTokenWithNoTrivia.prototype.text = function () {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */ );
            }
            return this._textOrWidth;
        };
        VariableWidthTokenWithNoTrivia.prototype.fullText = function () {
            return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
        };
        VariableWidthTokenWithNoTrivia.prototype.value = function () {
            return this._value || (this._value = Syntax.value(this));
        };
        VariableWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
            return 0;
        };
        VariableWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
            return 0;
        };
        VariableWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
            return Syntax.tokenToJSON(this);
        };
        VariableWidthTokenWithNoTrivia.prototype.firstToken = function () {
            return this;
        };
        VariableWidthTokenWithNoTrivia.prototype.lastToken = function () {
            return this;
        };
        VariableWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        VariableWidthTokenWithNoTrivia.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        VariableWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        VariableWidthTokenWithNoTrivia.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        VariableWidthTokenWithNoTrivia.prototype.realize = function () {
            return Syntax.realize(this);
        };
        VariableWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
            collectTokenTextElements(this, elements);
        };
        VariableWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        VariableWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        VariableWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return VariableWidthTokenWithNoTrivia;
    })();
    Syntax.VariableWidthTokenWithNoTrivia = VariableWidthTokenWithNoTrivia;    
    var VariableWidthTokenWithLeadingTrivia = (function () {
        function VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth) {
            this._value = null;
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._textOrWidth = textOrWidth;
        }
        VariableWidthTokenWithLeadingTrivia.prototype.clone = function () {
            return new VariableWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.isNode = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.isToken = function () {
            return true;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.isList = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.kind = function () {
            return this.tokenKind;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.childCount = function () {
            return 0;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange('index');
        };
        VariableWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
            return getTriviaWidth(this._leadingTriviaInfo) + this.width();
        };
        VariableWidthTokenWithLeadingTrivia.prototype.start = function () {
            return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.end = function () {
            return this.start() + this.width();
        };
        VariableWidthTokenWithLeadingTrivia.prototype.width = function () {
            return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.text = function () {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */ );
            }
            return this._textOrWidth;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.fullText = function () {
            return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.value = function () {
            return this._value || (this._value = Syntax.value(this));
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
            return true;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
            return hasTriviaComment(this._leadingTriviaInfo);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
            return hasTriviaNewLine(this._leadingTriviaInfo);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
            return getTriviaWidth(this._leadingTriviaInfo);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
            return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
            return 0;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
            return Syntax.tokenToJSON(this);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
            return this;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
            return this;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        VariableWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.realize = function () {
            return Syntax.realize(this);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
            collectTokenTextElements(this, elements);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        VariableWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return VariableWidthTokenWithLeadingTrivia;
    })();
    Syntax.VariableWidthTokenWithLeadingTrivia = VariableWidthTokenWithLeadingTrivia;    
    var VariableWidthTokenWithTrailingTrivia = (function () {
        function VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, textOrWidth, trailingTriviaInfo) {
            this._value = null;
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._textOrWidth = textOrWidth;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }
        VariableWidthTokenWithTrailingTrivia.prototype.clone = function () {
            return new VariableWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth, this._trailingTriviaInfo);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.isNode = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.isToken = function () {
            return true;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.isList = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.kind = function () {
            return this.tokenKind;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.childCount = function () {
            return 0;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange('index');
        };
        VariableWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
            return this.width() + getTriviaWidth(this._trailingTriviaInfo);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.start = function () {
            return this._fullStart;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.end = function () {
            return this.start() + this.width();
        };
        VariableWidthTokenWithTrailingTrivia.prototype.width = function () {
            return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.text = function () {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */ );
            }
            return this._textOrWidth;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.fullText = function () {
            return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.value = function () {
            return this._value || (this._value = Syntax.value(this));
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
            return 0;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
            return true;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
            return hasTriviaComment(this._trailingTriviaInfo);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
            return hasTriviaNewLine(this._trailingTriviaInfo);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
            return getTriviaWidth(this._trailingTriviaInfo);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
            return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
            return Syntax.tokenToJSON(this);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
            return this;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
            return this;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        VariableWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.realize = function () {
            return Syntax.realize(this);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
            collectTokenTextElements(this, elements);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        VariableWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return VariableWidthTokenWithTrailingTrivia;
    })();
    Syntax.VariableWidthTokenWithTrailingTrivia = VariableWidthTokenWithTrailingTrivia;    
    var VariableWidthTokenWithLeadingAndTrailingTrivia = (function () {
        function VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth, trailingTriviaInfo) {
            this._value = null;
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._textOrWidth = textOrWidth;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
            return new VariableWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth, this._trailingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
            return false;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
            return true;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
            return false;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
            return false;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
            return this.tokenKind;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
            return 0;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange('index');
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
            return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
            return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
            return this.start() + this.width();
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
            return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */ );
            }
            return this._textOrWidth;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
            return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
            return this._value || (this._value = Syntax.value(this));
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
            return true;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
            return hasTriviaComment(this._leadingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
            return hasTriviaNewLine(this._leadingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
            return getTriviaWidth(this._leadingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
            return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
            return true;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
            return hasTriviaComment(this._trailingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
            return hasTriviaNewLine(this._trailingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
            return getTriviaWidth(this._trailingTriviaInfo);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
            return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedText = function () {
            return false;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
            return Syntax.tokenToJSON(this);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
            return this;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
            return this;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
            return Syntax.realize(this);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
            collectTokenTextElements(this, elements);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return VariableWidthTokenWithLeadingAndTrailingTrivia;
    })();
    Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia = VariableWidthTokenWithLeadingAndTrailingTrivia;    
    var FixedWidthTokenWithNoTrivia = (function () {
        function FixedWidthTokenWithNoTrivia(kind) {
            this.tokenKind = kind;
        }
        FixedWidthTokenWithNoTrivia.prototype.clone = function () {
            return new FixedWidthTokenWithNoTrivia(this.tokenKind);
        };
        FixedWidthTokenWithNoTrivia.prototype.isNode = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.isToken = function () {
            return true;
        };
        FixedWidthTokenWithNoTrivia.prototype.isList = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.kind = function () {
            return this.tokenKind;
        };
        FixedWidthTokenWithNoTrivia.prototype.childCount = function () {
            return 0;
        };
        FixedWidthTokenWithNoTrivia.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange('index');
        };
        FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () {
            return this.width();
        };
        FixedWidthTokenWithNoTrivia.prototype.width = function () {
            return this.text().length;
        };
        FixedWidthTokenWithNoTrivia.prototype.text = function () {
            return SyntaxFacts.getText(this.tokenKind);
        };
        FixedWidthTokenWithNoTrivia.prototype.fullText = function () {
            return this.text();
        };
        FixedWidthTokenWithNoTrivia.prototype.value = function () {
            return null;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
            return 0;
        };
        FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
            return 0;
        };
        FixedWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
            return Syntax.tokenToJSON(this);
        };
        FixedWidthTokenWithNoTrivia.prototype.firstToken = function () {
            return this;
        };
        FixedWidthTokenWithNoTrivia.prototype.lastToken = function () {
            return this;
        };
        FixedWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        FixedWidthTokenWithNoTrivia.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        FixedWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        FixedWidthTokenWithNoTrivia.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        FixedWidthTokenWithNoTrivia.prototype.realize = function () {
            return Syntax.realize(this);
        };
        FixedWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
            collectTokenTextElements(this, elements);
        };
        FixedWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        FixedWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        FixedWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return FixedWidthTokenWithNoTrivia;
    })();
    Syntax.FixedWidthTokenWithNoTrivia = FixedWidthTokenWithNoTrivia;    
    var FixedWidthTokenWithLeadingTrivia = (function () {
        function FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
        }
        FixedWidthTokenWithLeadingTrivia.prototype.clone = function () {
            return new FixedWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.isNode = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.isToken = function () {
            return true;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.isList = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.kind = function () {
            return this.tokenKind;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.childCount = function () {
            return 0;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange('index');
        };
        FixedWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
            return getTriviaWidth(this._leadingTriviaInfo) + this.width();
        };
        FixedWidthTokenWithLeadingTrivia.prototype.start = function () {
            return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.end = function () {
            return this.start() + this.width();
        };
        FixedWidthTokenWithLeadingTrivia.prototype.width = function () {
            return this.text().length;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.text = function () {
            return SyntaxFacts.getText(this.tokenKind);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.fullText = function () {
            return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.value = function () {
            return null;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
            return true;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
            return hasTriviaComment(this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
            return hasTriviaNewLine(this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
            return getTriviaWidth(this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
            return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
            return 0;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
            return Syntax.tokenToJSON(this);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
            return this;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
            return this;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        FixedWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.realize = function () {
            return Syntax.realize(this);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
            collectTokenTextElements(this, elements);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        FixedWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return FixedWidthTokenWithLeadingTrivia;
    })();
    Syntax.FixedWidthTokenWithLeadingTrivia = FixedWidthTokenWithLeadingTrivia;    
    var FixedWidthTokenWithTrailingTrivia = (function () {
        function FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }
        FixedWidthTokenWithTrailingTrivia.prototype.clone = function () {
            return new FixedWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._trailingTriviaInfo);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.isNode = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.isToken = function () {
            return true;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.isList = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.kind = function () {
            return this.tokenKind;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.childCount = function () {
            return 0;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange('index');
        };
        FixedWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
            return this.width() + getTriviaWidth(this._trailingTriviaInfo);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.start = function () {
            return this._fullStart;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.end = function () {
            return this.start() + this.width();
        };
        FixedWidthTokenWithTrailingTrivia.prototype.width = function () {
            return this.text().length;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.text = function () {
            return SyntaxFacts.getText(this.tokenKind);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.fullText = function () {
            return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.value = function () {
            return null;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
            return 0;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
            return true;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
            return hasTriviaComment(this._trailingTriviaInfo);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
            return hasTriviaNewLine(this._trailingTriviaInfo);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
            return getTriviaWidth(this._trailingTriviaInfo);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
            return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
            return Syntax.tokenToJSON(this);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
            return this;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
            return this;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        FixedWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.realize = function () {
            return Syntax.realize(this);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
            collectTokenTextElements(this, elements);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        FixedWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return FixedWidthTokenWithTrailingTrivia;
    })();
    Syntax.FixedWidthTokenWithTrailingTrivia = FixedWidthTokenWithTrailingTrivia;    
    var FixedWidthTokenWithLeadingAndTrailingTrivia = (function () {
        function FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
            return new FixedWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._trailingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
            return false;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
            return true;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
            return false;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
            return false;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
            return this.tokenKind;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
            return 0;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange('index');
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
            return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
            return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
            return this.start() + this.width();
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
            return this.text().length;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
            return SyntaxFacts.getText(this.tokenKind);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
            return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
            return null;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
            return true;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
            return hasTriviaComment(this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
            return hasTriviaNewLine(this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
            return getTriviaWidth(this._leadingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
            return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
            return true;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
            return hasTriviaComment(this._trailingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
            return hasTriviaNewLine(this._trailingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
            return getTriviaWidth(this._trailingTriviaInfo);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
            return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedText = function () {
            return false;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
            return Syntax.tokenToJSON(this);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
            return this;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
            return this;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
            return Syntax.realize(this);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
            collectTokenTextElements(this, elements);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return FixedWidthTokenWithLeadingAndTrailingTrivia;
    })();
    Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia = FixedWidthTokenWithLeadingAndTrailingTrivia;    
    function collectTokenTextElements(token, elements) {
        token.leadingTrivia().collectTextElements(elements);
        elements.push(token.text());
        token.trailingTrivia().collectTextElements(elements);
    }
    function fixedWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
        if (leadingTriviaInfo === 0) {
            if (trailingTriviaInfo === 0) {
                return new FixedWidthTokenWithNoTrivia(kind);
            } else {
                return new FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo);
            }
        } else if (trailingTriviaInfo === 0) {
            return new FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo);
        } else {
            return new FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
        }
    }
    Syntax.fixedWidthToken = fixedWidthToken;
    function variableWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo) {
        if (leadingTriviaInfo === 0) {
            if (trailingTriviaInfo === 0) {
                return new VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, width);
            } else {
                return new VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, width, trailingTriviaInfo);
            }
        } else if (trailingTriviaInfo === 0) {
            return new VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width);
        } else {
            return new VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
        }
    }
    Syntax.variableWidthToken = variableWidthToken;
    function getTriviaWidth(value) {
        return value >>> 2 /* TriviaFullWidthShift */ ;
    }
    function hasTriviaComment(value) {
        return (value & 2 /* TriviaCommentMask */ ) !== 0;
    }
    function hasTriviaNewLine(value) {
        return (value & 1 /* TriviaNewLineMask */ ) !== 0;
    }
})(Syntax || (Syntax = {}));
var Syntax;
(function (Syntax) {
    var SyntaxTrivia = (function () {
        function SyntaxTrivia(kind, text) {
            this._kind = kind;
            this._text = text;
        }
        SyntaxTrivia.prototype.toJSON = function (key) {
            var result = {};
            result.kind = (SyntaxKind)._map[this._kind];
            result.text = this._text;
            return result;
        };
        SyntaxTrivia.prototype.kind = function () {
            return this._kind;
        };
        SyntaxTrivia.prototype.fullWidth = function () {
            return this._text.length;
        };
        SyntaxTrivia.prototype.fullText = function () {
            return this._text;
        };
        SyntaxTrivia.prototype.isWhitespace = function () {
            return this.kind() === 4 /* WhitespaceTrivia */ ;
        };
        SyntaxTrivia.prototype.isComment = function () {
            return this.kind() === 7 /* SingleLineCommentTrivia */  || this.kind() === 6 /* MultiLineCommentTrivia */ ;
        };
        SyntaxTrivia.prototype.isNewLine = function () {
            return this.kind() === 5 /* NewLineTrivia */ ;
        };
        SyntaxTrivia.prototype.isSkippedText = function () {
            return this.kind() === 8 /* SkippedTextTrivia */ ;
        };
        SyntaxTrivia.prototype.collectTextElements = function (elements) {
            elements.push(this.fullText());
        };
        return SyntaxTrivia;
    })();    
    function trivia(kind, text) {
        return new SyntaxTrivia(kind, text);
    }
    Syntax.trivia = trivia;
    function spaces(count) {
        return trivia(4 /* WhitespaceTrivia */ , StringUtilities.repeat(" ", count));
    }
    Syntax.spaces = spaces;
    function whitespace(text) {
        return trivia(4 /* WhitespaceTrivia */ , text);
    }
    Syntax.whitespace = whitespace;
    function multiLineComment(text) {
        return trivia(6 /* MultiLineCommentTrivia */ , text);
    }
    Syntax.multiLineComment = multiLineComment;
    function singleLineComment(text) {
        return trivia(7 /* SingleLineCommentTrivia */ , text);
    }
    Syntax.singleLineComment = singleLineComment;
    Syntax.spaceTrivia = spaces(1);
    Syntax.lineFeedTrivia = trivia(5 /* NewLineTrivia */ , "\n");
    Syntax.carriageReturnTrivia = trivia(5 /* NewLineTrivia */ , "\r");
    Syntax.carriageReturnLineFeedTrivia = trivia(5 /* NewLineTrivia */ , "\r\n");
    function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
        var result = [];
        var triviaText = trivia.fullText();
        var currentIndex = 0;
        for(var i = 0; i < triviaText.length; i++) {
            var ch = triviaText.charCodeAt(i);
            var isCarriageReturnLineFeed = false;
            switch(ch) {
                case 13 /* carriageReturn */ :
                    if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === 10 /* lineFeed */ ) {
                        i++;
                    }
                case 10 /* lineFeed */ :
                case 8233 /* paragraphSeparator */ :
                case 8232 /* lineSeparator */ :
                    result.push(triviaText.substring(currentIndex, i + 1));
                    currentIndex = i + 1;
                    continue;
            }
        }
        result.push(triviaText.substring(currentIndex));
        return result;
    }
    Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
})(Syntax || (Syntax = {}));
var Syntax;
(function (Syntax) {
    Syntax.emptyTriviaList = {
        kind: function () {
            return 3 /* TriviaList */ ;
        },
        count: function () {
            return 0;
        },
        syntaxTriviaAt: function (index) {
            throw Errors.argumentOutOfRange("index");
        },
        last: function () {
            throw Errors.argumentOutOfRange("index");
        },
        fullWidth: function () {
            return 0;
        },
        fullText: function () {
            return "";
        },
        hasComment: function () {
            return false;
        },
        hasNewLine: function () {
            return false;
        },
        hasSkippedText: function () {
            return false;
        },
        toJSON: function (key) {
            return [];
        },
        collectTextElements: function (elements) {
        },
        toArray: function () {
            return [];
        },
        concat: function (trivia) {
            return trivia;
        }
    };
    function concatTrivia(list1, list2) {
        if (list1.count() === 0) {
            return list2;
        }
        if (list2.count() === 0) {
            return list1;
        }
        var trivia = list1.toArray();
        trivia.push.apply(trivia, list2.toArray());
        return triviaList(trivia);
    }
    function isComment(trivia) {
        return trivia.kind() === 6 /* MultiLineCommentTrivia */  || trivia.kind() === 7 /* SingleLineCommentTrivia */ ;
    }
    var SingletonSyntaxTriviaList = (function () {
        function SingletonSyntaxTriviaList(item) {
            this.item = item;
        }
        SingletonSyntaxTriviaList.prototype.kind = function () {
            return 3 /* TriviaList */ ;
        };
        SingletonSyntaxTriviaList.prototype.count = function () {
            return 1;
        };
        SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.item;
        };
        SingletonSyntaxTriviaList.prototype.last = function () {
            return this.item;
        };
        SingletonSyntaxTriviaList.prototype.fullWidth = function () {
            return this.item.fullWidth();
        };
        SingletonSyntaxTriviaList.prototype.fullText = function () {
            return this.item.fullText();
        };
        SingletonSyntaxTriviaList.prototype.hasComment = function () {
            return isComment(this.item);
        };
        SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
            return this.item.kind() === 5 /* NewLineTrivia */ ;
        };
        SingletonSyntaxTriviaList.prototype.hasSkippedText = function () {
            return this.item.kind() === 8 /* SkippedTextTrivia */ ;
        };
        SingletonSyntaxTriviaList.prototype.toJSON = function (key) {
            return [
                this.item
            ];
        };
        SingletonSyntaxTriviaList.prototype.collectTextElements = function (elements) {
            (this.item).collectTextElements(elements);
        };
        SingletonSyntaxTriviaList.prototype.toArray = function () {
            return [
                this.item
            ];
        };
        SingletonSyntaxTriviaList.prototype.concat = function (trivia) {
            return concatTrivia(this, trivia);
        };
        return SingletonSyntaxTriviaList;
    })();    
    var NormalSyntaxTriviaList = (function () {
        function NormalSyntaxTriviaList(trivia) {
            this.trivia = trivia;
        }
        NormalSyntaxTriviaList.prototype.kind = function () {
            return 3 /* TriviaList */ ;
        };
        NormalSyntaxTriviaList.prototype.count = function () {
            return this.trivia.length;
        };
        NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
            if (index < 0 || index >= this.trivia.length) {
                throw Errors.argumentOutOfRange("index");
            }
            return this.trivia[index];
        };
        NormalSyntaxTriviaList.prototype.last = function () {
            return this.trivia[this.trivia.length - 1];
        };
        NormalSyntaxTriviaList.prototype.fullWidth = function () {
            return ArrayUtilities.sum(this.trivia, function (t) {
                return t.fullWidth();
            });
        };
        NormalSyntaxTriviaList.prototype.fullText = function () {
            var result = "";
            for(var i = 0, n = this.trivia.length; i < n; i++) {
                result += this.trivia[i].fullText();
            }
            return result;
        };
        NormalSyntaxTriviaList.prototype.hasComment = function () {
            for(var i = 0; i < this.trivia.length; i++) {
                if (isComment(this.trivia[i])) {
                    return true;
                }
            }
            return false;
        };
        NormalSyntaxTriviaList.prototype.hasNewLine = function () {
            for(var i = 0; i < this.trivia.length; i++) {
                if (this.trivia[i].kind() === 5 /* NewLineTrivia */ ) {
                    return true;
                }
            }
            return false;
        };
        NormalSyntaxTriviaList.prototype.hasSkippedText = function () {
            for(var i = 0; i < this.trivia.length; i++) {
                if (this.trivia[i].kind() === 8 /* SkippedTextTrivia */ ) {
                    return true;
                }
            }
            return false;
        };
        NormalSyntaxTriviaList.prototype.toJSON = function (key) {
            return this.trivia;
        };
        NormalSyntaxTriviaList.prototype.collectTextElements = function (elements) {
            for(var i = 0; i < this.trivia.length; i++) {
                (this.trivia[i]).collectTextElements(elements);
            }
        };
        NormalSyntaxTriviaList.prototype.toArray = function () {
            return this.trivia.slice(0);
        };
        NormalSyntaxTriviaList.prototype.concat = function (trivia) {
            return concatTrivia(this, trivia);
        };
        return NormalSyntaxTriviaList;
    })();    
    function triviaList(trivia) {
        if (trivia === undefined || trivia === null || trivia.length === 0) {
            return Syntax.emptyTriviaList;
        }
        if (trivia.length === 1) {
            return new SingletonSyntaxTriviaList(trivia[0]);
        }
        return new NormalSyntaxTriviaList(trivia);
    }
    Syntax.triviaList = triviaList;
    Syntax.spaceTriviaList = triviaList([
        Syntax.spaceTrivia
    ]);
})(Syntax || (Syntax = {}));
var Unicode = (function () {
    function Unicode() { }
    Unicode.unicodeES3IdentifierStart = [
        170, 
        170, 
        181, 
        181, 
        186, 
        186, 
        192, 
        214, 
        216, 
        246, 
        248, 
        543, 
        546, 
        563, 
        592, 
        685, 
        688, 
        696, 
        699, 
        705, 
        720, 
        721, 
        736, 
        740, 
        750, 
        750, 
        890, 
        890, 
        902, 
        902, 
        904, 
        906, 
        908, 
        908, 
        910, 
        929, 
        931, 
        974, 
        976, 
        983, 
        986, 
        1011, 
        1024, 
        1153, 
        1164, 
        1220, 
        1223, 
        1224, 
        1227, 
        1228, 
        1232, 
        1269, 
        1272, 
        1273, 
        1329, 
        1366, 
        1369, 
        1369, 
        1377, 
        1415, 
        1488, 
        1514, 
        1520, 
        1522, 
        1569, 
        1594, 
        1600, 
        1610, 
        1649, 
        1747, 
        1749, 
        1749, 
        1765, 
        1766, 
        1786, 
        1788, 
        1808, 
        1808, 
        1810, 
        1836, 
        1920, 
        1957, 
        2309, 
        2361, 
        2365, 
        2365, 
        2384, 
        2384, 
        2392, 
        2401, 
        2437, 
        2444, 
        2447, 
        2448, 
        2451, 
        2472, 
        2474, 
        2480, 
        2482, 
        2482, 
        2486, 
        2489, 
        2524, 
        2525, 
        2527, 
        2529, 
        2544, 
        2545, 
        2565, 
        2570, 
        2575, 
        2576, 
        2579, 
        2600, 
        2602, 
        2608, 
        2610, 
        2611, 
        2613, 
        2614, 
        2616, 
        2617, 
        2649, 
        2652, 
        2654, 
        2654, 
        2674, 
        2676, 
        2693, 
        2699, 
        2701, 
        2701, 
        2703, 
        2705, 
        2707, 
        2728, 
        2730, 
        2736, 
        2738, 
        2739, 
        2741, 
        2745, 
        2749, 
        2749, 
        2768, 
        2768, 
        2784, 
        2784, 
        2821, 
        2828, 
        2831, 
        2832, 
        2835, 
        2856, 
        2858, 
        2864, 
        2866, 
        2867, 
        2870, 
        2873, 
        2877, 
        2877, 
        2908, 
        2909, 
        2911, 
        2913, 
        2949, 
        2954, 
        2958, 
        2960, 
        2962, 
        2965, 
        2969, 
        2970, 
        2972, 
        2972, 
        2974, 
        2975, 
        2979, 
        2980, 
        2984, 
        2986, 
        2990, 
        2997, 
        2999, 
        3001, 
        3077, 
        3084, 
        3086, 
        3088, 
        3090, 
        3112, 
        3114, 
        3123, 
        3125, 
        3129, 
        3168, 
        3169, 
        3205, 
        3212, 
        3214, 
        3216, 
        3218, 
        3240, 
        3242, 
        3251, 
        3253, 
        3257, 
        3294, 
        3294, 
        3296, 
        3297, 
        3333, 
        3340, 
        3342, 
        3344, 
        3346, 
        3368, 
        3370, 
        3385, 
        3424, 
        3425, 
        3461, 
        3478, 
        3482, 
        3505, 
        3507, 
        3515, 
        3517, 
        3517, 
        3520, 
        3526, 
        3585, 
        3632, 
        3634, 
        3635, 
        3648, 
        3654, 
        3713, 
        3714, 
        3716, 
        3716, 
        3719, 
        3720, 
        3722, 
        3722, 
        3725, 
        3725, 
        3732, 
        3735, 
        3737, 
        3743, 
        3745, 
        3747, 
        3749, 
        3749, 
        3751, 
        3751, 
        3754, 
        3755, 
        3757, 
        3760, 
        3762, 
        3763, 
        3773, 
        3773, 
        3776, 
        3780, 
        3782, 
        3782, 
        3804, 
        3805, 
        3840, 
        3840, 
        3904, 
        3911, 
        3913, 
        3946, 
        3976, 
        3979, 
        4096, 
        4129, 
        4131, 
        4135, 
        4137, 
        4138, 
        4176, 
        4181, 
        4256, 
        4293, 
        4304, 
        4342, 
        4352, 
        4441, 
        4447, 
        4514, 
        4520, 
        4601, 
        4608, 
        4614, 
        4616, 
        4678, 
        4680, 
        4680, 
        4682, 
        4685, 
        4688, 
        4694, 
        4696, 
        4696, 
        4698, 
        4701, 
        4704, 
        4742, 
        4744, 
        4744, 
        4746, 
        4749, 
        4752, 
        4782, 
        4784, 
        4784, 
        4786, 
        4789, 
        4792, 
        4798, 
        4800, 
        4800, 
        4802, 
        4805, 
        4808, 
        4814, 
        4816, 
        4822, 
        4824, 
        4846, 
        4848, 
        4878, 
        4880, 
        4880, 
        4882, 
        4885, 
        4888, 
        4894, 
        4896, 
        4934, 
        4936, 
        4954, 
        5024, 
        5108, 
        5121, 
        5740, 
        5743, 
        5750, 
        5761, 
        5786, 
        5792, 
        5866, 
        6016, 
        6067, 
        6176, 
        6263, 
        6272, 
        6312, 
        7680, 
        7835, 
        7840, 
        7929, 
        7936, 
        7957, 
        7960, 
        7965, 
        7968, 
        8005, 
        8008, 
        8013, 
        8016, 
        8023, 
        8025, 
        8025, 
        8027, 
        8027, 
        8029, 
        8029, 
        8031, 
        8061, 
        8064, 
        8116, 
        8118, 
        8124, 
        8126, 
        8126, 
        8130, 
        8132, 
        8134, 
        8140, 
        8144, 
        8147, 
        8150, 
        8155, 
        8160, 
        8172, 
        8178, 
        8180, 
        8182, 
        8188, 
        8319, 
        8319, 
        8450, 
        8450, 
        8455, 
        8455, 
        8458, 
        8467, 
        8469, 
        8469, 
        8473, 
        8477, 
        8484, 
        8484, 
        8486, 
        8486, 
        8488, 
        8488, 
        8490, 
        8493, 
        8495, 
        8497, 
        8499, 
        8505, 
        8544, 
        8579, 
        12293, 
        12295, 
        12321, 
        12329, 
        12337, 
        12341, 
        12344, 
        12346, 
        12353, 
        12436, 
        12445, 
        12446, 
        12449, 
        12538, 
        12540, 
        12542, 
        12549, 
        12588, 
        12593, 
        12686, 
        12704, 
        12727, 
        13312, 
        13312, 
        19893, 
        19893, 
        19968, 
        19968, 
        40869, 
        40869, 
        40960, 
        42124, 
        44032, 
        44032, 
        55203, 
        55203, 
        63744, 
        64045, 
        64256, 
        64262, 
        64275, 
        64279, 
        64285, 
        64285, 
        64287, 
        64296, 
        64298, 
        64310, 
        64312, 
        64316, 
        64318, 
        64318, 
        64320, 
        64321, 
        64323, 
        64324, 
        64326, 
        64433, 
        64467, 
        64829, 
        64848, 
        64911, 
        64914, 
        64967, 
        65008, 
        65019, 
        65136, 
        65138, 
        65140, 
        65140, 
        65142, 
        65276, 
        65313, 
        65338, 
        65345, 
        65370, 
        65382, 
        65470, 
        65474, 
        65479, 
        65482, 
        65487, 
        65490, 
        65495, 
        65498, 
        65500
    ];
    Unicode.unicodeES3IdentifierPart = [
        768, 
        846, 
        864, 
        866, 
        1155, 
        1158, 
        1425, 
        1441, 
        1443, 
        1465, 
        1467, 
        1469, 
        1471, 
        1471, 
        1473, 
        1474, 
        1476, 
        1476, 
        1611, 
        1621, 
        1632, 
        1641, 
        1648, 
        1648, 
        1750, 
        1756, 
        1759, 
        1764, 
        1767, 
        1768, 
        1770, 
        1773, 
        1776, 
        1785, 
        1809, 
        1809, 
        1840, 
        1866, 
        1958, 
        1968, 
        2305, 
        2307, 
        2364, 
        2364, 
        2366, 
        2381, 
        2385, 
        2388, 
        2402, 
        2403, 
        2406, 
        2415, 
        2433, 
        2435, 
        2492, 
        2492, 
        2494, 
        2500, 
        2503, 
        2504, 
        2507, 
        2509, 
        2519, 
        2519, 
        2530, 
        2531, 
        2534, 
        2543, 
        2562, 
        2562, 
        2620, 
        2620, 
        2622, 
        2626, 
        2631, 
        2632, 
        2635, 
        2637, 
        2662, 
        2673, 
        2689, 
        2691, 
        2748, 
        2748, 
        2750, 
        2757, 
        2759, 
        2761, 
        2763, 
        2765, 
        2790, 
        2799, 
        2817, 
        2819, 
        2876, 
        2876, 
        2878, 
        2883, 
        2887, 
        2888, 
        2891, 
        2893, 
        2902, 
        2903, 
        2918, 
        2927, 
        2946, 
        2947, 
        3006, 
        3010, 
        3014, 
        3016, 
        3018, 
        3021, 
        3031, 
        3031, 
        3047, 
        3055, 
        3073, 
        3075, 
        3134, 
        3140, 
        3142, 
        3144, 
        3146, 
        3149, 
        3157, 
        3158, 
        3174, 
        3183, 
        3202, 
        3203, 
        3262, 
        3268, 
        3270, 
        3272, 
        3274, 
        3277, 
        3285, 
        3286, 
        3302, 
        3311, 
        3330, 
        3331, 
        3390, 
        3395, 
        3398, 
        3400, 
        3402, 
        3405, 
        3415, 
        3415, 
        3430, 
        3439, 
        3458, 
        3459, 
        3530, 
        3530, 
        3535, 
        3540, 
        3542, 
        3542, 
        3544, 
        3551, 
        3570, 
        3571, 
        3633, 
        3633, 
        3636, 
        3642, 
        3655, 
        3662, 
        3664, 
        3673, 
        3761, 
        3761, 
        3764, 
        3769, 
        3771, 
        3772, 
        3784, 
        3789, 
        3792, 
        3801, 
        3864, 
        3865, 
        3872, 
        3881, 
        3893, 
        3893, 
        3895, 
        3895, 
        3897, 
        3897, 
        3902, 
        3903, 
        3953, 
        3972, 
        3974, 
        3975, 
        3984, 
        3991, 
        3993, 
        4028, 
        4038, 
        4038, 
        4140, 
        4146, 
        4150, 
        4153, 
        4160, 
        4169, 
        4182, 
        4185, 
        4969, 
        4977, 
        6068, 
        6099, 
        6112, 
        6121, 
        6160, 
        6169, 
        6313, 
        6313, 
        8255, 
        8256, 
        8400, 
        8412, 
        8417, 
        8417, 
        12330, 
        12335, 
        12441, 
        12442, 
        12539, 
        12539, 
        64286, 
        64286, 
        65056, 
        65059, 
        65075, 
        65076, 
        65101, 
        65103, 
        65296, 
        65305, 
        65343, 
        65343, 
        65381, 
        65381
    ];
    Unicode.unicodeES5IdentifierStart = [
        170, 
        170, 
        181, 
        181, 
        186, 
        186, 
        192, 
        214, 
        216, 
        246, 
        248, 
        705, 
        710, 
        721, 
        736, 
        740, 
        748, 
        748, 
        750, 
        750, 
        880, 
        884, 
        886, 
        887, 
        890, 
        893, 
        902, 
        902, 
        904, 
        906, 
        908, 
        908, 
        910, 
        929, 
        931, 
        1013, 
        1015, 
        1153, 
        1162, 
        1319, 
        1329, 
        1366, 
        1369, 
        1369, 
        1377, 
        1415, 
        1488, 
        1514, 
        1520, 
        1522, 
        1568, 
        1610, 
        1646, 
        1647, 
        1649, 
        1747, 
        1749, 
        1749, 
        1765, 
        1766, 
        1774, 
        1775, 
        1786, 
        1788, 
        1791, 
        1791, 
        1808, 
        1808, 
        1810, 
        1839, 
        1869, 
        1957, 
        1969, 
        1969, 
        1994, 
        2026, 
        2036, 
        2037, 
        2042, 
        2042, 
        2048, 
        2069, 
        2074, 
        2074, 
        2084, 
        2084, 
        2088, 
        2088, 
        2112, 
        2136, 
        2208, 
        2208, 
        2210, 
        2220, 
        2308, 
        2361, 
        2365, 
        2365, 
        2384, 
        2384, 
        2392, 
        2401, 
        2417, 
        2423, 
        2425, 
        2431, 
        2437, 
        2444, 
        2447, 
        2448, 
        2451, 
        2472, 
        2474, 
        2480, 
        2482, 
        2482, 
        2486, 
        2489, 
        2493, 
        2493, 
        2510, 
        2510, 
        2524, 
        2525, 
        2527, 
        2529, 
        2544, 
        2545, 
        2565, 
        2570, 
        2575, 
        2576, 
        2579, 
        2600, 
        2602, 
        2608, 
        2610, 
        2611, 
        2613, 
        2614, 
        2616, 
        2617, 
        2649, 
        2652, 
        2654, 
        2654, 
        2674, 
        2676, 
        2693, 
        2701, 
        2703, 
        2705, 
        2707, 
        2728, 
        2730, 
        2736, 
        2738, 
        2739, 
        2741, 
        2745, 
        2749, 
        2749, 
        2768, 
        2768, 
        2784, 
        2785, 
        2821, 
        2828, 
        2831, 
        2832, 
        2835, 
        2856, 
        2858, 
        2864, 
        2866, 
        2867, 
        2869, 
        2873, 
        2877, 
        2877, 
        2908, 
        2909, 
        2911, 
        2913, 
        2929, 
        2929, 
        2947, 
        2947, 
        2949, 
        2954, 
        2958, 
        2960, 
        2962, 
        2965, 
        2969, 
        2970, 
        2972, 
        2972, 
        2974, 
        2975, 
        2979, 
        2980, 
        2984, 
        2986, 
        2990, 
        3001, 
        3024, 
        3024, 
        3077, 
        3084, 
        3086, 
        3088, 
        3090, 
        3112, 
        3114, 
        3123, 
        3125, 
        3129, 
        3133, 
        3133, 
        3160, 
        3161, 
        3168, 
        3169, 
        3205, 
        3212, 
        3214, 
        3216, 
        3218, 
        3240, 
        3242, 
        3251, 
        3253, 
        3257, 
        3261, 
        3261, 
        3294, 
        3294, 
        3296, 
        3297, 
        3313, 
        3314, 
        3333, 
        3340, 
        3342, 
        3344, 
        3346, 
        3386, 
        3389, 
        3389, 
        3406, 
        3406, 
        3424, 
        3425, 
        3450, 
        3455, 
        3461, 
        3478, 
        3482, 
        3505, 
        3507, 
        3515, 
        3517, 
        3517, 
        3520, 
        3526, 
        3585, 
        3632, 
        3634, 
        3635, 
        3648, 
        3654, 
        3713, 
        3714, 
        3716, 
        3716, 
        3719, 
        3720, 
        3722, 
        3722, 
        3725, 
        3725, 
        3732, 
        3735, 
        3737, 
        3743, 
        3745, 
        3747, 
        3749, 
        3749, 
        3751, 
        3751, 
        3754, 
        3755, 
        3757, 
        3760, 
        3762, 
        3763, 
        3773, 
        3773, 
        3776, 
        3780, 
        3782, 
        3782, 
        3804, 
        3807, 
        3840, 
        3840, 
        3904, 
        3911, 
        3913, 
        3948, 
        3976, 
        3980, 
        4096, 
        4138, 
        4159, 
        4159, 
        4176, 
        4181, 
        4186, 
        4189, 
        4193, 
        4193, 
        4197, 
        4198, 
        4206, 
        4208, 
        4213, 
        4225, 
        4238, 
        4238, 
        4256, 
        4293, 
        4295, 
        4295, 
        4301, 
        4301, 
        4304, 
        4346, 
        4348, 
        4680, 
        4682, 
        4685, 
        4688, 
        4694, 
        4696, 
        4696, 
        4698, 
        4701, 
        4704, 
        4744, 
        4746, 
        4749, 
        4752, 
        4784, 
        4786, 
        4789, 
        4792, 
        4798, 
        4800, 
        4800, 
        4802, 
        4805, 
        4808, 
        4822, 
        4824, 
        4880, 
        4882, 
        4885, 
        4888, 
        4954, 
        4992, 
        5007, 
        5024, 
        5108, 
        5121, 
        5740, 
        5743, 
        5759, 
        5761, 
        5786, 
        5792, 
        5866, 
        5870, 
        5872, 
        5888, 
        5900, 
        5902, 
        5905, 
        5920, 
        5937, 
        5952, 
        5969, 
        5984, 
        5996, 
        5998, 
        6000, 
        6016, 
        6067, 
        6103, 
        6103, 
        6108, 
        6108, 
        6176, 
        6263, 
        6272, 
        6312, 
        6314, 
        6314, 
        6320, 
        6389, 
        6400, 
        6428, 
        6480, 
        6509, 
        6512, 
        6516, 
        6528, 
        6571, 
        6593, 
        6599, 
        6656, 
        6678, 
        6688, 
        6740, 
        6823, 
        6823, 
        6917, 
        6963, 
        6981, 
        6987, 
        7043, 
        7072, 
        7086, 
        7087, 
        7098, 
        7141, 
        7168, 
        7203, 
        7245, 
        7247, 
        7258, 
        7293, 
        7401, 
        7404, 
        7406, 
        7409, 
        7413, 
        7414, 
        7424, 
        7615, 
        7680, 
        7957, 
        7960, 
        7965, 
        7968, 
        8005, 
        8008, 
        8013, 
        8016, 
        8023, 
        8025, 
        8025, 
        8027, 
        8027, 
        8029, 
        8029, 
        8031, 
        8061, 
        8064, 
        8116, 
        8118, 
        8124, 
        8126, 
        8126, 
        8130, 
        8132, 
        8134, 
        8140, 
        8144, 
        8147, 
        8150, 
        8155, 
        8160, 
        8172, 
        8178, 
        8180, 
        8182, 
        8188, 
        8305, 
        8305, 
        8319, 
        8319, 
        8336, 
        8348, 
        8450, 
        8450, 
        8455, 
        8455, 
        8458, 
        8467, 
        8469, 
        8469, 
        8473, 
        8477, 
        8484, 
        8484, 
        8486, 
        8486, 
        8488, 
        8488, 
        8490, 
        8493, 
        8495, 
        8505, 
        8508, 
        8511, 
        8517, 
        8521, 
        8526, 
        8526, 
        8544, 
        8584, 
        11264, 
        11310, 
        11312, 
        11358, 
        11360, 
        11492, 
        11499, 
        11502, 
        11506, 
        11507, 
        11520, 
        11557, 
        11559, 
        11559, 
        11565, 
        11565, 
        11568, 
        11623, 
        11631, 
        11631, 
        11648, 
        11670, 
        11680, 
        11686, 
        11688, 
        11694, 
        11696, 
        11702, 
        11704, 
        11710, 
        11712, 
        11718, 
        11720, 
        11726, 
        11728, 
        11734, 
        11736, 
        11742, 
        11823, 
        11823, 
        12293, 
        12295, 
        12321, 
        12329, 
        12337, 
        12341, 
        12344, 
        12348, 
        12353, 
        12438, 
        12445, 
        12447, 
        12449, 
        12538, 
        12540, 
        12543, 
        12549, 
        12589, 
        12593, 
        12686, 
        12704, 
        12730, 
        12784, 
        12799, 
        13312, 
        13312, 
        19893, 
        19893, 
        19968, 
        19968, 
        40908, 
        40908, 
        40960, 
        42124, 
        42192, 
        42237, 
        42240, 
        42508, 
        42512, 
        42527, 
        42538, 
        42539, 
        42560, 
        42606, 
        42623, 
        42647, 
        42656, 
        42735, 
        42775, 
        42783, 
        42786, 
        42888, 
        42891, 
        42894, 
        42896, 
        42899, 
        42912, 
        42922, 
        43000, 
        43009, 
        43011, 
        43013, 
        43015, 
        43018, 
        43020, 
        43042, 
        43072, 
        43123, 
        43138, 
        43187, 
        43250, 
        43255, 
        43259, 
        43259, 
        43274, 
        43301, 
        43312, 
        43334, 
        43360, 
        43388, 
        43396, 
        43442, 
        43471, 
        43471, 
        43520, 
        43560, 
        43584, 
        43586, 
        43588, 
        43595, 
        43616, 
        43638, 
        43642, 
        43642, 
        43648, 
        43695, 
        43697, 
        43697, 
        43701, 
        43702, 
        43705, 
        43709, 
        43712, 
        43712, 
        43714, 
        43714, 
        43739, 
        43741, 
        43744, 
        43754, 
        43762, 
        43764, 
        43777, 
        43782, 
        43785, 
        43790, 
        43793, 
        43798, 
        43808, 
        43814, 
        43816, 
        43822, 
        43968, 
        44002, 
        44032, 
        44032, 
        55203, 
        55203, 
        55216, 
        55238, 
        55243, 
        55291, 
        63744, 
        64109, 
        64112, 
        64217, 
        64256, 
        64262, 
        64275, 
        64279, 
        64285, 
        64285, 
        64287, 
        64296, 
        64298, 
        64310, 
        64312, 
        64316, 
        64318, 
        64318, 
        64320, 
        64321, 
        64323, 
        64324, 
        64326, 
        64433, 
        64467, 
        64829, 
        64848, 
        64911, 
        64914, 
        64967, 
        65008, 
        65019, 
        65136, 
        65140, 
        65142, 
        65276, 
        65313, 
        65338, 
        65345, 
        65370, 
        65382, 
        65470, 
        65474, 
        65479, 
        65482, 
        65487, 
        65490, 
        65495, 
        65498, 
        65500
    ];
    Unicode.unicodeES5IdentifierPart = [
        768, 
        879, 
        1155, 
        1159, 
        1425, 
        1469, 
        1471, 
        1471, 
        1473, 
        1474, 
        1476, 
        1477, 
        1479, 
        1479, 
        1552, 
        1562, 
        1611, 
        1641, 
        1648, 
        1648, 
        1750, 
        1756, 
        1759, 
        1764, 
        1767, 
        1768, 
        1770, 
        1773, 
        1776, 
        1785, 
        1809, 
        1809, 
        1840, 
        1866, 
        1958, 
        1968, 
        1984, 
        1993, 
        2027, 
        2035, 
        2070, 
        2073, 
        2075, 
        2083, 
        2085, 
        2087, 
        2089, 
        2093, 
        2137, 
        2139, 
        2276, 
        2302, 
        2304, 
        2307, 
        2362, 
        2364, 
        2366, 
        2383, 
        2385, 
        2391, 
        2402, 
        2403, 
        2406, 
        2415, 
        2433, 
        2435, 
        2492, 
        2492, 
        2494, 
        2500, 
        2503, 
        2504, 
        2507, 
        2509, 
        2519, 
        2519, 
        2530, 
        2531, 
        2534, 
        2543, 
        2561, 
        2563, 
        2620, 
        2620, 
        2622, 
        2626, 
        2631, 
        2632, 
        2635, 
        2637, 
        2641, 
        2641, 
        2662, 
        2673, 
        2677, 
        2677, 
        2689, 
        2691, 
        2748, 
        2748, 
        2750, 
        2757, 
        2759, 
        2761, 
        2763, 
        2765, 
        2786, 
        2787, 
        2790, 
        2799, 
        2817, 
        2819, 
        2876, 
        2876, 
        2878, 
        2884, 
        2887, 
        2888, 
        2891, 
        2893, 
        2902, 
        2903, 
        2914, 
        2915, 
        2918, 
        2927, 
        2946, 
        2946, 
        3006, 
        3010, 
        3014, 
        3016, 
        3018, 
        3021, 
        3031, 
        3031, 
        3046, 
        3055, 
        3073, 
        3075, 
        3134, 
        3140, 
        3142, 
        3144, 
        3146, 
        3149, 
        3157, 
        3158, 
        3170, 
        3171, 
        3174, 
        3183, 
        3202, 
        3203, 
        3260, 
        3260, 
        3262, 
        3268, 
        3270, 
        3272, 
        3274, 
        3277, 
        3285, 
        3286, 
        3298, 
        3299, 
        3302, 
        3311, 
        3330, 
        3331, 
        3390, 
        3396, 
        3398, 
        3400, 
        3402, 
        3405, 
        3415, 
        3415, 
        3426, 
        3427, 
        3430, 
        3439, 
        3458, 
        3459, 
        3530, 
        3530, 
        3535, 
        3540, 
        3542, 
        3542, 
        3544, 
        3551, 
        3570, 
        3571, 
        3633, 
        3633, 
        3636, 
        3642, 
        3655, 
        3662, 
        3664, 
        3673, 
        3761, 
        3761, 
        3764, 
        3769, 
        3771, 
        3772, 
        3784, 
        3789, 
        3792, 
        3801, 
        3864, 
        3865, 
        3872, 
        3881, 
        3893, 
        3893, 
        3895, 
        3895, 
        3897, 
        3897, 
        3902, 
        3903, 
        3953, 
        3972, 
        3974, 
        3975, 
        3981, 
        3991, 
        3993, 
        4028, 
        4038, 
        4038, 
        4139, 
        4158, 
        4160, 
        4169, 
        4182, 
        4185, 
        4190, 
        4192, 
        4194, 
        4196, 
        4199, 
        4205, 
        4209, 
        4212, 
        4226, 
        4237, 
        4239, 
        4253, 
        4957, 
        4959, 
        5906, 
        5908, 
        5938, 
        5940, 
        5970, 
        5971, 
        6002, 
        6003, 
        6068, 
        6099, 
        6109, 
        6109, 
        6112, 
        6121, 
        6155, 
        6157, 
        6160, 
        6169, 
        6313, 
        6313, 
        6432, 
        6443, 
        6448, 
        6459, 
        6470, 
        6479, 
        6576, 
        6592, 
        6600, 
        6601, 
        6608, 
        6617, 
        6679, 
        6683, 
        6741, 
        6750, 
        6752, 
        6780, 
        6783, 
        6793, 
        6800, 
        6809, 
        6912, 
        6916, 
        6964, 
        6980, 
        6992, 
        7001, 
        7019, 
        7027, 
        7040, 
        7042, 
        7073, 
        7085, 
        7088, 
        7097, 
        7142, 
        7155, 
        7204, 
        7223, 
        7232, 
        7241, 
        7248, 
        7257, 
        7376, 
        7378, 
        7380, 
        7400, 
        7405, 
        7405, 
        7410, 
        7412, 
        7616, 
        7654, 
        7676, 
        7679, 
        8204, 
        8205, 
        8255, 
        8256, 
        8276, 
        8276, 
        8400, 
        8412, 
        8417, 
        8417, 
        8421, 
        8432, 
        11503, 
        11505, 
        11647, 
        11647, 
        11744, 
        11775, 
        12330, 
        12335, 
        12441, 
        12442, 
        42528, 
        42537, 
        42607, 
        42607, 
        42612, 
        42621, 
        42655, 
        42655, 
        42736, 
        42737, 
        43010, 
        43010, 
        43014, 
        43014, 
        43019, 
        43019, 
        43043, 
        43047, 
        43136, 
        43137, 
        43188, 
        43204, 
        43216, 
        43225, 
        43232, 
        43249, 
        43264, 
        43273, 
        43302, 
        43309, 
        43335, 
        43347, 
        43392, 
        43395, 
        43443, 
        43456, 
        43472, 
        43481, 
        43561, 
        43574, 
        43587, 
        43587, 
        43596, 
        43597, 
        43600, 
        43609, 
        43643, 
        43643, 
        43696, 
        43696, 
        43698, 
        43700, 
        43703, 
        43704, 
        43710, 
        43711, 
        43713, 
        43713, 
        43755, 
        43759, 
        43765, 
        43766, 
        44003, 
        44010, 
        44012, 
        44013, 
        44016, 
        44025, 
        64286, 
        64286, 
        65024, 
        65039, 
        65056, 
        65062, 
        65075, 
        65076, 
        65101, 
        65103, 
        65296, 
        65305, 
        65343, 
        65343
    ];
    Unicode.lookupInUnicodeMap = function lookupInUnicodeMap(code, map) {
        if (code < map[0]) {
            return false;
        }
        var lo = 0;
        var hi = map.length;
        var mid;
        while(lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1]) {
                return true;
            }
            if (code < map[mid]) {
                hi = mid;
            } else {
                lo = mid + 2;
            }
        }
        return false;
    };
    Unicode.isIdentifierStart = function isIdentifierStart(code, languageVersion) {
        if (languageVersion === 0 /* EcmaScript3 */ ) {
            return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
        } else if (languageVersion === 1 /* EcmaScript5 */ ) {
            return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
        } else {
            throw Errors.argumentOutOfRange("languageVersion");
        }
    };
    Unicode.isIdentifierPart = function isIdentifierPart(code, languageVersion) {
        if (languageVersion === 0 /* EcmaScript3 */ ) {
            return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
        } else if (languageVersion === 1 /* EcmaScript5 */ ) {
            return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
        } else {
            throw Errors.argumentOutOfRange("languageVersion");
        }
    };
    return Unicode;
})();
var Scanner = (function () {
    function Scanner(text, languageVersion, stringTable, window) {
        if (typeof window === "undefined") { window = ArrayUtilities.createArray(2048, 0); }
        Scanner.initializeStaticData();
        this.slidingWindow = new SlidingWindow(this, window, 0, text.length());
        this.text = text;
        this.stringTable = stringTable;
        this.languageVersion = languageVersion;
    }
    Scanner.isKeywordStartCharacter = [];
    Scanner.isIdentifierStartCharacter = [];
    Scanner.isIdentifierPartCharacter = [];
    Scanner.isNumericLiteralStart = [];
    Scanner.initializeStaticData = function initializeStaticData() {
        if (Scanner.isKeywordStartCharacter.length === 0) {
            Scanner.isKeywordStartCharacter = ArrayUtilities.createArray(127 /* maxAsciiCharacter */ , false);
            Scanner.isIdentifierStartCharacter = ArrayUtilities.createArray(127 /* maxAsciiCharacter */ , false);
            Scanner.isIdentifierPartCharacter = ArrayUtilities.createArray(127 /* maxAsciiCharacter */ , false);
            Scanner.isNumericLiteralStart = ArrayUtilities.createArray(127 /* maxAsciiCharacter */ , false);
            for(var character = 0; character < 127 /* maxAsciiCharacter */ ; character++) {
                if (character >= 97 /* a */  && character <= 122 /* z */ ) {
                    Scanner.isIdentifierStartCharacter[character] = true;
                    Scanner.isIdentifierPartCharacter[character] = true;
                } else if ((character >= 65 /* A */  && character <= 90 /* Z */ ) || character === 95 /* _ */  || character === 36 /* $ */ ) {
                    Scanner.isIdentifierStartCharacter[character] = true;
                    Scanner.isIdentifierPartCharacter[character] = true;
                } else if (character >= 48 /* _0 */  && character <= 57 /* _9 */ ) {
                    Scanner.isIdentifierPartCharacter[character] = true;
                    Scanner.isNumericLiteralStart[character] = true;
                }
            }
            Scanner.isNumericLiteralStart[46 /* dot */ ] = true;
            for(var keywordKind = 15 /* FirstKeyword */ ; keywordKind <= 69 /* LastKeyword */ ; keywordKind++) {
                var keyword = SyntaxFacts.getText(keywordKind);
                Scanner.isKeywordStartCharacter[keyword.charCodeAt(0)] = true;
            }
        }
    };
    Scanner.prototype.fetchMoreItems = function (argument, sourceIndex, window, destinationIndex, spaceAvailable) {
        var charactersRemaining = this.text.length() - sourceIndex;
        var amountToRead = MathPrototype.min(charactersRemaining, spaceAvailable);
        this.text.copyTo(sourceIndex, window, destinationIndex, amountToRead);
        return amountToRead;
    };
    Scanner.prototype.currentCharCode = function () {
        return this.slidingWindow.currentItem(null);
    };
    Scanner.prototype.setAbsoluteIndex = function (index) {
        this.slidingWindow.setAbsoluteIndex(index);
    };
    Scanner.prototype.scan = function (diagnostics, allowRegularExpression) {
        var fullStart = this.slidingWindow.absoluteIndex();
        var leadingTriviaInfo = this.scanTriviaInfo(diagnostics, false);
        var start = this.slidingWindow.absoluteIndex();
        var kind = this.scanSyntaxToken(diagnostics, allowRegularExpression);
        var end = this.slidingWindow.absoluteIndex();
        var trailingTriviaInfo = this.scanTriviaInfo(diagnostics, true);
        if (kind >= 15 /* FirstFixedWidth */ ) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new Syntax.FixedWidthTokenWithNoTrivia(kind);
                } else {
                    return new Syntax.FixedWidthTokenWithTrailingTrivia(this.text, fullStart, kind, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new Syntax.FixedWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo);
            } else {
                return new Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
            }
        } else {
            var width = end - start;
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new Syntax.VariableWidthTokenWithNoTrivia(this.text, fullStart, kind, width);
                } else {
                    return new Syntax.VariableWidthTokenWithTrailingTrivia(this.text, fullStart, kind, width, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new Syntax.VariableWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width);
            } else {
                return new Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
            }
        }
    };
    Scanner.triviaWindow = ArrayUtilities.createArray(2048, 0);
    Scanner.scanTrivia = function scanTrivia(text, start, length, isTrailing) {
        var scanner = new Scanner(text.subText(new TextSpan(start, length)), 1 /* EcmaScript5 */ , null, Scanner.triviaWindow);
        return scanner.scanTrivia(isTrailing);
    };
    Scanner.prototype.scanTrivia = function (isTrailing) {
        var trivia = [];
        while(true) {
            if (!this.slidingWindow.isAtEndOfSource()) {
                var ch = this.currentCharCode();
                switch(ch) {
                    case 32 /* space */ :
                    case 9 /* tab */ :
                    case 11 /* verticalTab */ :
                    case 12 /* formFeed */ :
                    case 160 /* nonBreakingSpace */ :
                    case 65279 /* byteOrderMark */ :
                        trivia.push(this.scanWhitespaceTrivia());
                        continue;
                    case 47 /* slash */ :
                        var ch2 = this.slidingWindow.peekItemN(1);
                        if (ch2 === 47 /* slash */ ) {
                            trivia.push(this.scanSingleLineCommentTrivia());
                            continue;
                        }
                        if (ch2 === 42 /* asterisk */ ) {
                            trivia.push(this.scanMultiLineCommentTrivia());
                            continue;
                        }
                        throw Errors.invalidOperation();
                    case 13 /* carriageReturn */ :
                    case 10 /* lineFeed */ :
                    case 8233 /* paragraphSeparator */ :
                    case 8232 /* lineSeparator */ :
                        trivia.push(this.scanLineTerminatorSequenceTrivia(ch));
                        if (!isTrailing) {
                            continue;
                        }
                        break;
                    default:
                        throw Errors.invalidOperation();
                }
            }
            return Syntax.triviaList(trivia);
        }
    };
    Scanner.prototype.scanTriviaInfo = function (diagnostics, isTrailing) {
        var width = 0;
        var hasCommentOrNewLine = 0;
        while(true) {
            var ch = this.currentCharCode();
            switch(ch) {
                case 32 /* space */ :
                case 9 /* tab */ :
                case 11 /* verticalTab */ :
                case 12 /* formFeed */ :
                case 160 /* nonBreakingSpace */ :
                case 65279 /* byteOrderMark */ :
                    this.slidingWindow.moveToNextItem();
                    width++;
                    continue;
                case 47 /* slash */ :
                    var ch2 = this.slidingWindow.peekItemN(1);
                    if (ch2 === 47 /* slash */ ) {
                        hasCommentOrNewLine |= 2 /* TriviaCommentMask */ ;
                        width += this.scanSingleLineCommentTriviaLength();
                        continue;
                    }
                    if (ch2 === 42 /* asterisk */ ) {
                        hasCommentOrNewLine |= 2 /* TriviaCommentMask */ ;
                        width += this.scanMultiLineCommentTriviaLength(diagnostics);
                        continue;
                    }
                    break;
                case 13 /* carriageReturn */ :
                case 10 /* lineFeed */ :
                case 8233 /* paragraphSeparator */ :
                case 8232 /* lineSeparator */ :
                    hasCommentOrNewLine |= 1 /* TriviaNewLineMask */ ;
                    width += this.scanLineTerminatorSequenceLength(ch);
                    if (!isTrailing) {
                        continue;
                    }
                    break;
            }
            return (width << 2 /* TriviaFullWidthShift */ ) | hasCommentOrNewLine;
        }
    };
    Scanner.prototype.isNewLineCharacter = function (ch) {
        switch(ch) {
            case 13 /* carriageReturn */ :
            case 10 /* lineFeed */ :
            case 8233 /* paragraphSeparator */ :
            case 8232 /* lineSeparator */ :
                return true;
            default:
                return false;
        }
    };
    Scanner.prototype.scanWhitespaceTrivia = function () {
        var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        var width = 0;
        while(true) {
            var ch = this.currentCharCode();
            switch(ch) {
                case 32 /* space */ :
                case 9 /* tab */ :
                case 11 /* verticalTab */ :
                case 12 /* formFeed */ :
                case 160 /* nonBreakingSpace */ :
                case 65279 /* byteOrderMark */ :
                    this.slidingWindow.moveToNextItem();
                    width++;
                    continue;
            }
            break;
        }
        var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);
        return Syntax.whitespace(text);
    };
    Scanner.prototype.scanSingleLineCommentTrivia = function () {
        var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        var width = this.scanSingleLineCommentTriviaLength();
        var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);
        return Syntax.singleLineComment(text);
    };
    Scanner.prototype.scanSingleLineCommentTriviaLength = function () {
        this.slidingWindow.moveToNextItem();
        this.slidingWindow.moveToNextItem();
        var width = 2;
        while(true) {
            if (this.slidingWindow.isAtEndOfSource() || this.isNewLineCharacter(this.currentCharCode())) {
                return width;
            }
            this.slidingWindow.moveToNextItem();
            width++;
        }
    };
    Scanner.prototype.scanMultiLineCommentTrivia = function () {
        var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        var width = this.scanMultiLineCommentTriviaLength(null);
        var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);
        return Syntax.multiLineComment(text);
    };
    Scanner.prototype.scanMultiLineCommentTriviaLength = function (diagnostics) {
        this.slidingWindow.moveToNextItem();
        this.slidingWindow.moveToNextItem();
        var width = 2;
        while(true) {
            if (this.slidingWindow.isAtEndOfSource()) {
                if (diagnostics !== null) {
                    diagnostics.push(new SyntaxDiagnostic(this.slidingWindow.absoluteIndex(), 0, 10 /* _StarSlash__expected */ , null));
                }
                return width;
            }
            var ch = this.currentCharCode();
            if (ch === 42 /* asterisk */  && this.slidingWindow.peekItemN(1) === 47 /* slash */ ) {
                this.slidingWindow.moveToNextItem();
                this.slidingWindow.moveToNextItem();
                width += 2;
                return width;
            }
            this.slidingWindow.moveToNextItem();
            width++;
        }
    };
    Scanner.prototype.scanLineTerminatorSequenceTrivia = function (ch) {
        var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        var width = this.scanLineTerminatorSequenceLength(ch);
        var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);
        return Syntax.trivia(5 /* NewLineTrivia */ , text);
    };
    Scanner.prototype.scanLineTerminatorSequenceLength = function (ch) {
        this.slidingWindow.moveToNextItem();
        if (ch === 13 /* carriageReturn */  && this.currentCharCode() === 10 /* lineFeed */ ) {
            this.slidingWindow.moveToNextItem();
            return 2;
        } else {
            return 1;
        }
    };
    Scanner.prototype.scanSyntaxToken = function (diagnostics, allowRegularExpression) {
        if (this.slidingWindow.isAtEndOfSource()) {
            return 10 /* EndOfFileToken */ ;
        }
        var character = this.currentCharCode();
        switch(character) {
            case 34 /* doubleQuote */ :
            case 39 /* singleQuote */ :
                return this.scanStringLiteral(diagnostics);
            case 47 /* slash */ :
                return this.scanSlashToken(allowRegularExpression);
            case 46 /* dot */ :
                return this.scanDotToken();
            case 45 /* minus */ :
                return this.scanMinusToken();
            case 33 /* exclamation */ :
                return this.scanExclamationToken();
            case 61 /* equals */ :
                return this.scanEqualsToken();
            case 124 /* bar */ :
                return this.scanBarToken();
            case 42 /* asterisk */ :
                return this.scanAsteriskToken();
            case 43 /* plus */ :
                return this.scanPlusToken();
            case 37 /* percent */ :
                return this.scanPercentToken();
            case 38 /* ampersand */ :
                return this.scanAmpersandToken();
            case 94 /* caret */ :
                return this.scanCaretToken();
            case 60 /* lessThan */ :
                return this.scanLessThanToken();
            case 62 /* greaterThan */ :
                return this.advanceAndSetTokenKind(81 /* GreaterThanToken */ );
            case 44 /* comma */ :
                return this.advanceAndSetTokenKind(79 /* CommaToken */ );
            case 58 /* colon */ :
                return this.advanceAndSetTokenKind(106 /* ColonToken */ );
            case 59 /* semicolon */ :
                return this.advanceAndSetTokenKind(78 /* SemicolonToken */ );
            case 126 /* tilde */ :
                return this.advanceAndSetTokenKind(102 /* TildeToken */ );
            case 40 /* openParen */ :
                return this.advanceAndSetTokenKind(72 /* OpenParenToken */ );
            case 41 /* closeParen */ :
                return this.advanceAndSetTokenKind(73 /* CloseParenToken */ );
            case 123 /* openBrace */ :
                return this.advanceAndSetTokenKind(70 /* OpenBraceToken */ );
            case 125 /* closeBrace */ :
                return this.advanceAndSetTokenKind(71 /* CloseBraceToken */ );
            case 91 /* openBracket */ :
                return this.advanceAndSetTokenKind(74 /* OpenBracketToken */ );
            case 93 /* closeBracket */ :
                return this.advanceAndSetTokenKind(75 /* CloseBracketToken */ );
            case 63 /* question */ :
                return this.advanceAndSetTokenKind(105 /* QuestionToken */ );
        }
        if (Scanner.isNumericLiteralStart[character]) {
            return this.scanNumericLiteral();
        }
        if (Scanner.isIdentifierStartCharacter[character]) {
            var result = this.tryFastScanIdentifierOrKeyword(character);
            if (result !== 0 /* None */ ) {
                return result;
            }
        }
        if (this.isIdentifierStart(this.peekCharOrUnicodeEscape())) {
            return this.slowScanIdentifier(diagnostics);
        }
        return this.scanDefaultCharacter(character, diagnostics);
    };
    Scanner.prototype.isIdentifierStart = function (interpretedChar) {
        if (Scanner.isIdentifierStartCharacter[interpretedChar]) {
            return true;
        }
        return interpretedChar > 127 /* maxAsciiCharacter */  && Unicode.isIdentifierStart(interpretedChar, this.languageVersion);
    };
    Scanner.prototype.isIdentifierPart = function (interpretedChar) {
        if (Scanner.isIdentifierPartCharacter[interpretedChar]) {
            return true;
        }
        return interpretedChar > 127 /* maxAsciiCharacter */  && Unicode.isIdentifierPart(interpretedChar, this.languageVersion);
    };
    Scanner.prototype.tryFastScanIdentifierOrKeyword = function (firstCharacter) {
        var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        while(true) {
            var character = this.currentCharCode();
            if (Scanner.isIdentifierPartCharacter[character]) {
                this.slidingWindow.moveToNextItem();
            } else if (character === 92 /* backslash */  || character > 127 /* maxAsciiCharacter */ ) {
                this.slidingWindow.rewindToPinnedIndex(startIndex);
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                return 0 /* None */ ;
            } else {
                var endIndex = this.slidingWindow.absoluteIndex();
                var kind;
                if (Scanner.isKeywordStartCharacter[firstCharacter]) {
                    var offset = startIndex - this.slidingWindow.windowAbsoluteStartIndex;
                    kind = ScannerUtilities.identifierKind(this.slidingWindow.window, offset, endIndex - startIndex);
                } else {
                    kind = 11 /* IdentifierName */ ;
                }
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                return kind;
            }
        }
    };
    Scanner.prototype.slowScanIdentifier = function (diagnostics) {
        var startIndex = this.slidingWindow.absoluteIndex();
        do {
            this.scanCharOrUnicodeEscape(diagnostics);
        } while(this.isIdentifierPart(this.peekCharOrUnicodeEscape()));
        return 11 /* IdentifierName */ ;
    };
    Scanner.prototype.scanNumericLiteral = function () {
        if (this.isHexNumericLiteral()) {
            return this.scanHexNumericLiteral();
        } else {
            return this.scanDecimalNumericLiteral();
        }
    };
    Scanner.prototype.scanDecimalNumericLiteral = function () {
        while(CharacterInfo.isDecimalDigit(this.currentCharCode())) {
            this.slidingWindow.moveToNextItem();
        }
        if (this.currentCharCode() === 46 /* dot */ ) {
            this.slidingWindow.moveToNextItem();
        }
        while(CharacterInfo.isDecimalDigit(this.currentCharCode())) {
            this.slidingWindow.moveToNextItem();
        }
        var ch = this.currentCharCode();
        if (ch === 101 /* e */  || ch === 69 /* E */ ) {
            this.slidingWindow.moveToNextItem();
            ch = this.currentCharCode();
            if (ch === 45 /* minus */  || ch === 43 /* plus */ ) {
                if (CharacterInfo.isDecimalDigit(this.slidingWindow.peekItemN(1))) {
                    this.slidingWindow.moveToNextItem();
                }
            }
        }
        while(CharacterInfo.isDecimalDigit(this.currentCharCode())) {
            this.slidingWindow.moveToNextItem();
        }
        return 13 /* NumericLiteral */ ;
    };
    Scanner.prototype.scanHexNumericLiteral = function () {
        this.slidingWindow.moveToNextItem();
        this.slidingWindow.moveToNextItem();
        while(CharacterInfo.isHexDigit(this.currentCharCode())) {
            this.slidingWindow.moveToNextItem();
        }
        return 13 /* NumericLiteral */ ;
    };
    Scanner.prototype.isHexNumericLiteral = function () {
        if (this.currentCharCode() === 48 /* _0 */ ) {
            var ch = this.slidingWindow.peekItemN(1);
            if (ch === 120 /* x */  || ch === 88 /* X */ ) {
                ch = this.slidingWindow.peekItemN(2);
                return CharacterInfo.isHexDigit(ch);
            }
        }
        return false;
    };
    Scanner.prototype.advanceAndSetTokenKind = function (kind) {
        this.slidingWindow.moveToNextItem();
        return kind;
    };
    Scanner.prototype.scanLessThanToken = function () {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 82 /* LessThanEqualsToken */ ;
        } else if (this.currentCharCode() === 60 /* lessThan */ ) {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */ ) {
                this.slidingWindow.moveToNextItem();
                return 112 /* LessThanLessThanEqualsToken */ ;
            } else {
                return 95 /* LessThanLessThanToken */ ;
            }
        } else {
            return 80 /* LessThanToken */ ;
        }
    };
    Scanner.prototype.scanBarToken = function () {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 116 /* BarEqualsToken */ ;
        } else if (this.currentCharCode() === 124 /* bar */ ) {
            this.slidingWindow.moveToNextItem();
            return 104 /* BarBarToken */ ;
        } else {
            return 99 /* BarToken */ ;
        }
    };
    Scanner.prototype.scanCaretToken = function () {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 117 /* CaretEqualsToken */ ;
        } else {
            return 100 /* CaretToken */ ;
        }
    };
    Scanner.prototype.scanAmpersandToken = function () {
        this.slidingWindow.moveToNextItem();
        var character = this.currentCharCode();
        if (character === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 115 /* AmpersandEqualsToken */ ;
        } else if (this.currentCharCode() === 38 /* ampersand */ ) {
            this.slidingWindow.moveToNextItem();
            return 103 /* AmpersandAmpersandToken */ ;
        } else {
            return 98 /* AmpersandToken */ ;
        }
    };
    Scanner.prototype.scanPercentToken = function () {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 111 /* PercentEqualsToken */ ;
        } else {
            return 92 /* PercentToken */ ;
        }
    };
    Scanner.prototype.scanMinusToken = function () {
        this.slidingWindow.moveToNextItem();
        var character = this.currentCharCode();
        if (character === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 109 /* MinusEqualsToken */ ;
        } else if (character === 45 /* minus */ ) {
            this.slidingWindow.moveToNextItem();
            return 94 /* MinusMinusToken */ ;
        } else {
            return 90 /* MinusToken */ ;
        }
    };
    Scanner.prototype.scanPlusToken = function () {
        this.slidingWindow.moveToNextItem();
        var character = this.currentCharCode();
        if (character === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 108 /* PlusEqualsToken */ ;
        } else if (character === 43 /* plus */ ) {
            this.slidingWindow.moveToNextItem();
            return 93 /* PlusPlusToken */ ;
        } else {
            return 89 /* PlusToken */ ;
        }
    };
    Scanner.prototype.scanAsteriskToken = function () {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 110 /* AsteriskEqualsToken */ ;
        } else {
            return 91 /* AsteriskToken */ ;
        }
    };
    Scanner.prototype.scanEqualsToken = function () {
        this.slidingWindow.moveToNextItem();
        var character = this.currentCharCode();
        if (character === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */ ) {
                this.slidingWindow.moveToNextItem();
                return 87 /* EqualsEqualsEqualsToken */ ;
            } else {
                return 84 /* EqualsEqualsToken */ ;
            }
        } else if (character === 62 /* greaterThan */ ) {
            this.slidingWindow.moveToNextItem();
            return 85 /* EqualsGreaterThanToken */ ;
        } else {
            return 107 /* EqualsToken */ ;
        }
    };
    Scanner.prototype.isDotPrefixedNumericLiteral = function () {
        if (this.currentCharCode() === 46 /* dot */ ) {
            var ch = this.slidingWindow.peekItemN(1);
            return CharacterInfo.isDecimalDigit(ch);
        }
        return false;
    };
    Scanner.prototype.scanDotToken = function () {
        if (this.isDotPrefixedNumericLiteral()) {
            return this.scanNumericLiteral();
        }
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === 46 /* dot */  && this.slidingWindow.peekItemN(1) === 46 /* dot */ ) {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();
            return 77 /* DotDotDotToken */ ;
        } else {
            return 76 /* DotToken */ ;
        }
    };
    Scanner.prototype.scanSlashToken = function (allowRegularExpression) {
        if (allowRegularExpression) {
            var result = this.tryScanRegularExpressionToken();
            if (result !== 0 /* None */ ) {
                return result;
            }
        }
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            return 119 /* SlashEqualsToken */ ;
        } else {
            return 118 /* SlashToken */ ;
        }
    };
    Scanner.prototype.tryScanRegularExpressionToken = function () {
        var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        try  {
            this.slidingWindow.moveToNextItem();
            var inEscape = false;
            var inCharacterClass = false;
            while(true) {
                var ch = this.currentCharCode();
                if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                    this.slidingWindow.rewindToPinnedIndex(startIndex);
                    return 0 /* None */ ;
                }
                this.slidingWindow.moveToNextItem();
                if (inEscape) {
                    inEscape = false;
                    continue;
                }
                switch(ch) {
                    case 92 /* backslash */ :
                        inEscape = true;
                        continue;
                    case 91 /* openBracket */ :
                        inCharacterClass = true;
                        continue;
                    case 93 /* closeBracket */ :
                        inCharacterClass = false;
                        continue;
                    case 47 /* slash */ :
                        if (inCharacterClass) {
                            continue;
                        }
                        break;
                    default:
                        continue;
                }
                break;
            }
            while(Scanner.isIdentifierPartCharacter[this.currentCharCode()]) {
                this.slidingWindow.moveToNextItem();
            }
            return 12 /* RegularExpressionLiteral */ ;
        } finally {
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
        }
    };
    Scanner.prototype.scanExclamationToken = function () {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === 61 /* equals */ ) {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */ ) {
                this.slidingWindow.moveToNextItem();
                return 88 /* ExclamationEqualsEqualsToken */ ;
            } else {
                return 86 /* ExclamationEqualsToken */ ;
            }
        } else {
            return 101 /* ExclamationToken */ ;
        }
    };
    Scanner.prototype.scanDefaultCharacter = function (character, diagnostics) {
        var position = this.slidingWindow.absoluteIndex();
        this.slidingWindow.moveToNextItem();
        var text = String.fromCharCode(character);
        var messageText = this.getErrorMessageText(text);
        diagnostics.push(new SyntaxDiagnostic(position, 1, 1 /* Unexpected_character_0 */ , [
            messageText
        ]));
        return 9 /* ErrorToken */ ;
    };
    Scanner.prototype.getErrorMessageText = function (text) {
        if (text === "\\") {
            return '"\\"';
        }
        return JSON2.stringify(text);
    };
    Scanner.prototype.skipEscapeSequence = function (diagnostics) {
        var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
        try  {
            this.slidingWindow.moveToNextItem();
            var ch = this.currentCharCode();
            this.slidingWindow.moveToNextItem();
            switch(ch) {
                case 120 /* x */ :
                case 117 /* u */ :
                    this.slidingWindow.rewindToPinnedIndex(rewindPoint);
                    var value = this.scanUnicodeOrHexEscape(diagnostics);
                    return;
                case 13 /* carriageReturn */ :
                    if (this.currentCharCode() === 10 /* lineFeed */ ) {
                        this.slidingWindow.moveToNextItem();
                    }
                    return;
                default:
                    return;
            }
        } finally {
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint);
        }
    };
    Scanner.prototype.scanStringLiteral = function (diagnostics) {
        var quoteCharacter = this.currentCharCode();
        this.slidingWindow.moveToNextItem();
        while(true) {
            var ch = this.currentCharCode();
            if (ch === 92 /* backslash */ ) {
                this.skipEscapeSequence(diagnostics);
            } else if (ch === quoteCharacter) {
                this.slidingWindow.moveToNextItem();
                break;
            } else if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                diagnostics.push(new SyntaxDiagnostic(this.slidingWindow.absoluteIndex(), 1, 2 /* Missing_closing_quote_character */ , null));
                break;
            } else {
                this.slidingWindow.moveToNextItem();
            }
        }
        return 14 /* StringLiteral */ ;
    };
    Scanner.prototype.isUnicodeOrHexEscape = function (character) {
        return this.isUnicodeEscape(character) || this.isHexEscape(character);
    };
    Scanner.prototype.isUnicodeEscape = function (character) {
        if (character === 92 /* backslash */ ) {
            var ch2 = this.slidingWindow.peekItemN(1);
            if (ch2 === 117 /* u */ ) {
                return true;
            }
        }
        return false;
    };
    Scanner.prototype.isHexEscape = function (character) {
        if (character === 92 /* backslash */ ) {
            var ch2 = this.slidingWindow.peekItemN(1);
            if (ch2 === 120 /* x */ ) {
                return true;
            }
        }
        return false;
    };
    Scanner.prototype.peekCharOrUnicodeOrHexEscape = function () {
        var character = this.currentCharCode();
        if (this.isUnicodeOrHexEscape(character)) {
            return this.peekUnicodeOrHexEscape();
        } else {
            return character;
        }
    };
    Scanner.prototype.peekCharOrUnicodeEscape = function () {
        var character = this.currentCharCode();
        if (this.isUnicodeEscape(character)) {
            return this.peekUnicodeOrHexEscape();
        } else {
            return character;
        }
    };
    Scanner.prototype.peekUnicodeOrHexEscape = function () {
        var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        var ch = this.scanUnicodeOrHexEscape(null);
        this.slidingWindow.rewindToPinnedIndex(startIndex);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
        return ch;
    };
    Scanner.prototype.scanCharOrUnicodeEscape = function (errors) {
        var ch = this.currentCharCode();
        if (ch === 92 /* backslash */ ) {
            var ch2 = this.slidingWindow.peekItemN(1);
            if (ch2 === 117 /* u */ ) {
                return this.scanUnicodeOrHexEscape(errors);
            }
        }
        this.slidingWindow.moveToNextItem();
        return ch;
    };
    Scanner.prototype.scanCharOrUnicodeOrHexEscape = function (errors) {
        var ch = this.currentCharCode();
        if (ch === 92 /* backslash */ ) {
            var ch2 = this.slidingWindow.peekItemN(1);
            if (ch2 === 117 /* u */  || ch2 === 120 /* x */ ) {
                return this.scanUnicodeOrHexEscape(errors);
            }
        }
        this.slidingWindow.moveToNextItem();
        return ch;
    };
    Scanner.prototype.scanUnicodeOrHexEscape = function (errors) {
        var start = this.slidingWindow.absoluteIndex();
        var character = this.currentCharCode();
        this.slidingWindow.moveToNextItem();
        character = this.currentCharCode();
        var intChar = 0;
        this.slidingWindow.moveToNextItem();
        var count = character === 117 /* u */  ? 4 : 2;
        for(var i = 0; i < count; i++) {
            var ch2 = this.currentCharCode();
            if (!CharacterInfo.isHexDigit(ch2)) {
                if (errors !== null) {
                    var end = this.slidingWindow.absoluteIndex();
                    var info = this.createIllegalEscapeDiagnostic(start, end);
                    errors.push(info);
                }
                break;
            }
            intChar = (intChar << 4) + CharacterInfo.hexValue(ch2);
            this.slidingWindow.moveToNextItem();
        }
        return intChar;
    };
    Scanner.prototype.substring = function (start, end, intern) {
        var length = end - start;
        var offset = start - this.slidingWindow.windowAbsoluteStartIndex;
        if (intern) {
            return this.stringTable.addCharArray(this.slidingWindow.window, offset, length);
        } else {
            return StringUtilities.fromCharCodeArray(this.slidingWindow.window.slice(offset, offset + length));
        }
    };
    Scanner.prototype.createIllegalEscapeDiagnostic = function (start, end) {
        return new SyntaxDiagnostic(start, end - start, 0 /* Unrecognized_escape_sequence */ , null);
    };
    return Scanner;
})();
var Syntax;
(function (Syntax) {
    function realize(token) {
        return new RealizedToken(token.tokenKind, token.leadingTrivia(), token.text(), token.value(), token.trailingTrivia());
    }
    Syntax.realize = realize;
    function tokenToJSON(token) {
        var result = {};
        result.kind = (SyntaxKind)._map[token.kind()];
        result.width = token.width();
        if (token.fullWidth() !== token.width()) {
            result.fullWidth = token.fullWidth();
        }
        result.text = token.text();
        if (token.value() !== null) {
            result.valueText = token.value();
        }
        if (token.hasLeadingTrivia()) {
            result.hasLeadingTrivia = true;
        }
        if (token.hasLeadingComment()) {
            result.hasLeadingComment = true;
        }
        if (token.hasLeadingNewLine()) {
            result.hasLeadingNewLine = true;
        }
        if (token.hasLeadingSkippedText()) {
            result.hasLeadingSkippedText = true;
        }
        if (token.hasTrailingTrivia()) {
            result.hasTrailingTrivia = true;
        }
        if (token.hasTrailingComment()) {
            result.hasTrailingComment = true;
        }
        if (token.hasTrailingNewLine()) {
            result.hasTrailingNewLine = true;
        }
        if (token.hasTrailingSkippedText()) {
            result.hasTrailingSkippedText = true;
        }
        var trivia = token.leadingTrivia();
        if (trivia.count() > 0) {
            result.leadingTrivia = trivia;
        }
        trivia = token.trailingTrivia();
        if (trivia.count() > 0) {
            result.trailingTrivia = trivia;
        }
        return result;
    }
    Syntax.tokenToJSON = tokenToJSON;
    function value(token) {
        if (token.tokenKind === 11 /* IdentifierName */ ) {
            var text = token.text();
            for(var i = 0; i < text.length; i++) {
                if (!Scanner.isIdentifierPartCharacter[text.charCodeAt(i)]) {
                    return null;
                }
            }
            return text;
        } else if (token.tokenKind === 13 /* NumericLiteral */ ) {
            return null;
        } else if (token.tokenKind === 14 /* StringLiteral */ ) {
            return null;
        } else if (token.tokenKind === 12 /* RegularExpressionLiteral */ ) {
            return null;
        } else if (token.tokenKind === 10 /* EndOfFileToken */  || token.tokenKind === 9 /* ErrorToken */ ) {
            return null;
        } else {
            throw Errors.invalidOperation();
        }
    }
    Syntax.value = value;
    var EmptyToken = (function () {
        function EmptyToken(kind) {
            this.tokenKind = kind;
        }
        EmptyToken.prototype.clone = function () {
            return new EmptyToken(this.tokenKind);
        };
        EmptyToken.prototype.kind = function () {
            return this.tokenKind;
        };
        EmptyToken.prototype.isToken = function () {
            return true;
        };
        EmptyToken.prototype.isNode = function () {
            return false;
        };
        EmptyToken.prototype.isList = function () {
            return false;
        };
        EmptyToken.prototype.isSeparatedList = function () {
            return false;
        };
        EmptyToken.prototype.childCount = function () {
            return 0;
        };
        EmptyToken.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange("index");
        };
        EmptyToken.prototype.toJSON = function (key) {
            return tokenToJSON(this);
        };
        EmptyToken.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        EmptyToken.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        EmptyToken.prototype.firstToken = function () {
            return this;
        };
        EmptyToken.prototype.lastToken = function () {
            return this;
        };
        EmptyToken.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        EmptyToken.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        EmptyToken.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
        };
        EmptyToken.prototype.fullWidth = function () {
            return 0;
        };
        EmptyToken.prototype.width = function () {
            return 0;
        };
        EmptyToken.prototype.text = function () {
            return "";
        };
        EmptyToken.prototype.fullText = function () {
            return "";
        };
        EmptyToken.prototype.value = function () {
            return null;
        };
        EmptyToken.prototype.hasLeadingTrivia = function () {
            return false;
        };
        EmptyToken.prototype.hasLeadingComment = function () {
            return false;
        };
        EmptyToken.prototype.hasLeadingNewLine = function () {
            return false;
        };
        EmptyToken.prototype.hasLeadingSkippedText = function () {
            return false;
        };
        EmptyToken.prototype.leadingTriviaWidth = function () {
            return 0;
        };
        EmptyToken.prototype.hasTrailingTrivia = function () {
            return false;
        };
        EmptyToken.prototype.hasTrailingComment = function () {
            return false;
        };
        EmptyToken.prototype.hasTrailingNewLine = function () {
            return false;
        };
        EmptyToken.prototype.hasTrailingSkippedText = function () {
            return false;
        };
        EmptyToken.prototype.hasSkippedText = function () {
            return false;
        };
        EmptyToken.prototype.trailingTriviaWidth = function () {
            return 0;
        };
        EmptyToken.prototype.leadingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        EmptyToken.prototype.trailingTrivia = function () {
            return Syntax.emptyTriviaList;
        };
        EmptyToken.prototype.realize = function () {
            return realize(this);
        };
        EmptyToken.prototype.collectTextElements = function (elements) {
        };
        EmptyToken.prototype.withLeadingTrivia = function (leadingTrivia) {
            return this.realize().withLeadingTrivia(leadingTrivia);
        };
        EmptyToken.prototype.withTrailingTrivia = function (trailingTrivia) {
            return this.realize().withTrailingTrivia(trailingTrivia);
        };
        return EmptyToken;
    })();    
    function emptyToken(kind) {
        return new EmptyToken(kind);
    }
    Syntax.emptyToken = emptyToken;
    var RealizedToken = (function () {
        function RealizedToken(tokenKind, leadingTrivia, text, value, trailingTrivia) {
            this.tokenKind = tokenKind;
            this._leadingTrivia = leadingTrivia;
            this._text = text;
            this._value = value;
            this._trailingTrivia = trailingTrivia;
        }
        RealizedToken.prototype.clone = function () {
            return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._trailingTrivia);
        };
        RealizedToken.prototype.kind = function () {
            return this.tokenKind;
        };
        RealizedToken.prototype.toJSON = function (key) {
            return tokenToJSON(this);
        };
        RealizedToken.prototype.firstToken = function () {
            return this;
        };
        RealizedToken.prototype.lastToken = function () {
            return this;
        };
        RealizedToken.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        RealizedToken.prototype.hasZeroWidthToken = function () {
            return this.fullWidth() === 0;
        };
        RealizedToken.prototype.hasRegularExpressionToken = function () {
            return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.kind());
        };
        RealizedToken.prototype.accept = function (visitor) {
            return visitor.visitToken(this);
        };
        RealizedToken.prototype.childCount = function () {
            return 0;
        };
        RealizedToken.prototype.childAt = function (index) {
            throw Errors.argumentOutOfRange("index");
        };
        RealizedToken.prototype.isToken = function () {
            return true;
        };
        RealizedToken.prototype.isNode = function () {
            return false;
        };
        RealizedToken.prototype.isList = function () {
            return false;
        };
        RealizedToken.prototype.isSeparatedList = function () {
            return false;
        };
        RealizedToken.prototype.isTrivia = function () {
            return false;
        };
        RealizedToken.prototype.isTriviaList = function () {
            return false;
        };
        RealizedToken.prototype.fullWidth = function () {
            return this._leadingTrivia.fullWidth() + this.width() + this._trailingTrivia.fullWidth();
        };
        RealizedToken.prototype.width = function () {
            return this.text().length;
        };
        RealizedToken.prototype.text = function () {
            return this._text;
        };
        RealizedToken.prototype.fullText = function () {
            return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText();
        };
        RealizedToken.prototype.value = function () {
            return this._value;
        };
        RealizedToken.prototype.hasLeadingTrivia = function () {
            return this._leadingTrivia.count() > 0;
        };
        RealizedToken.prototype.hasLeadingComment = function () {
            return this._leadingTrivia.hasComment();
        };
        RealizedToken.prototype.hasLeadingNewLine = function () {
            return this._leadingTrivia.hasNewLine();
        };
        RealizedToken.prototype.hasLeadingSkippedText = function () {
            return this._leadingTrivia.hasSkippedText();
        };
        RealizedToken.prototype.leadingTriviaWidth = function () {
            return this._leadingTrivia.fullWidth();
        };
        RealizedToken.prototype.hasTrailingTrivia = function () {
            return this._trailingTrivia.count() > 0;
        };
        RealizedToken.prototype.hasTrailingComment = function () {
            return this._trailingTrivia.hasComment();
        };
        RealizedToken.prototype.hasTrailingNewLine = function () {
            return this._trailingTrivia.hasNewLine();
        };
        RealizedToken.prototype.hasTrailingSkippedText = function () {
            return this._trailingTrivia.hasSkippedText();
        };
        RealizedToken.prototype.trailingTriviaWidth = function () {
            return this._trailingTrivia.fullWidth();
        };
        RealizedToken.prototype.hasSkippedText = function () {
            return this.hasLeadingSkippedText() || this.hasTrailingSkippedText();
        };
        RealizedToken.prototype.leadingTrivia = function () {
            return this._leadingTrivia;
        };
        RealizedToken.prototype.trailingTrivia = function () {
            return this._trailingTrivia;
        };
        RealizedToken.prototype.findTokenInternal = function (parent, position, fullStart) {
            return new PositionedToken(parent, this, fullStart);
        };
        RealizedToken.prototype.collectTextElements = function (elements) {
            this.leadingTrivia().collectTextElements(elements);
            elements.push(this.text());
            this.trailingTrivia().collectTextElements(elements);
        };
        RealizedToken.prototype.withLeadingTrivia = function (leadingTrivia) {
            return new RealizedToken(this.tokenKind, leadingTrivia, this._text, this._value, this._trailingTrivia);
        };
        RealizedToken.prototype.withTrailingTrivia = function (trailingTrivia) {
            return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, trailingTrivia);
        };
        return RealizedToken;
    })();    
    function token(kind, info) {
        if (typeof info === "undefined") { info = null; }
        var text = (info !== null && info.text !== undefined) ? info.text : SyntaxFacts.getText(kind);
        var value = (info !== null && info.value !== undefined) ? info.value : null;
        return new RealizedToken(kind, Syntax.triviaList(info === null ? null : info.leadingTrivia), text, value, Syntax.triviaList(info === null ? null : info.trailingTrivia));
    }
    Syntax.token = token;
    function identifier(text, info) {
        if (typeof info === "undefined") { info = null; }
        info = info || {};
        info.text = text;
        return token(11 /* IdentifierName */ , info);
    }
    Syntax.identifier = identifier;
})(Syntax || (Syntax = {}));
var Syntax;
(function (Syntax) {
    var NormalModeFactory = (function () {
        function NormalModeFactory() { }
        NormalModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
            return new SourceUnitSyntax(moduleElements, endOfFileToken, false);
        };
        NormalModeFactory.prototype.externalModuleReference = function (moduleKeyword, openParenToken, stringLiteral, closeParenToken) {
            return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, false);
        };
        NormalModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
            return new ModuleNameModuleReferenceSyntax(moduleName, false);
        };
        NormalModeFactory.prototype.importDeclaration = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
        };
        NormalModeFactory.prototype.classDeclaration = function (exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken) {
            return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, false);
        };
        NormalModeFactory.prototype.interfaceDeclaration = function (exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body) {
            return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, false);
        };
        NormalModeFactory.prototype.extendsClause = function (extendsKeyword, typeNames) {
            return new ExtendsClauseSyntax(extendsKeyword, typeNames, false);
        };
        NormalModeFactory.prototype.implementsClause = function (implementsKeyword, typeNames) {
            return new ImplementsClauseSyntax(implementsKeyword, typeNames, false);
        };
        NormalModeFactory.prototype.moduleDeclaration = function (exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
            return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, false);
        };
        NormalModeFactory.prototype.functionDeclaration = function (exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken) {
            return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken, false);
        };
        NormalModeFactory.prototype.variableStatement = function (exportKeyword, declareKeyword, variableDeclaration, semicolonToken) {
            return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, false);
        };
        NormalModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, false);
        };
        NormalModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, false);
        };
        NormalModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
            return new EqualsValueClauseSyntax(equalsToken, value, false);
        };
        NormalModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, false);
        };
        NormalModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, false);
        };
        NormalModeFactory.prototype.omittedExpression = function () {
            return new OmittedExpressionSyntax(false);
        };
        NormalModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, false);
        };
        NormalModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, false);
        };
        NormalModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, false);
        };
        NormalModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
            return new QualifiedNameSyntax(left, dotToken, right, false);
        };
        NormalModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, false);
        };
        NormalModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, false);
        };
        NormalModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, false);
        };
        NormalModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, false);
        };
        NormalModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, false);
        };
        NormalModeFactory.prototype.genericType = function (name, typeArgumentList) {
            return new GenericTypeSyntax(name, typeArgumentList, false);
        };
        NormalModeFactory.prototype.typeAnnotation = function (colonToken, type) {
            return new TypeAnnotationSyntax(colonToken, type, false);
        };
        NormalModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
            return new BlockSyntax(openBraceToken, statements, closeBraceToken, false);
        };
        NormalModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, false);
        };
        NormalModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
            return new MemberAccessExpressionSyntax(expression, dotToken, name, false);
        };
        NormalModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, false);
        };
        NormalModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, false);
        };
        NormalModeFactory.prototype.invocationExpression = function (expression, argumentList) {
            return new InvocationExpressionSyntax(expression, argumentList, false);
        };
        NormalModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, false);
        };
        NormalModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
            return new BinaryExpressionSyntax(kind, left, operatorToken, right, false);
        };
        NormalModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, false);
        };
        NormalModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
            return new ConstructSignatureSyntax(newKeyword, callSignature, false);
        };
        NormalModeFactory.prototype.functionSignature = function (identifier, questionToken, callSignature) {
            return new FunctionSignatureSyntax(identifier, questionToken, callSignature, false);
        };
        NormalModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, false);
        };
        NormalModeFactory.prototype.propertySignature = function (identifier, questionToken, typeAnnotation) {
            return new PropertySignatureSyntax(identifier, questionToken, typeAnnotation, false);
        };
        NormalModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, false);
        };
        NormalModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, false);
        };
        NormalModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, false);
        };
        NormalModeFactory.prototype.typeParameter = function (identifier, constraint) {
            return new TypeParameterSyntax(identifier, constraint, false);
        };
        NormalModeFactory.prototype.constraint = function (extendsKeyword, type) {
            return new ConstraintSyntax(extendsKeyword, type, false);
        };
        NormalModeFactory.prototype.elseClause = function (elseKeyword, statement) {
            return new ElseClauseSyntax(elseKeyword, statement, false);
        };
        NormalModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, false);
        };
        NormalModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
            return new ExpressionStatementSyntax(expression, semicolonToken, false);
        };
        NormalModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, false);
        };
        NormalModeFactory.prototype.memberFunctionDeclaration = function (publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken) {
            return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken, false);
        };
        NormalModeFactory.prototype.getMemberAccessorDeclaration = function (publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block) {
            return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, false);
        };
        NormalModeFactory.prototype.setMemberAccessorDeclaration = function (publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block) {
            return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, false);
        };
        NormalModeFactory.prototype.memberVariableDeclaration = function (publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken) {
            return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, false);
        };
        NormalModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, false);
        };
        NormalModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, false);
        };
        NormalModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, false);
        };
        NormalModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, false);
        };
        NormalModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, false);
        };
        NormalModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, false);
        };
        NormalModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, false);
        };
        NormalModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, false);
        };
        NormalModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, false);
        };
        NormalModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, false);
        };
        NormalModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, false);
        };
        NormalModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, false);
        };
        NormalModeFactory.prototype.enumDeclaration = function (exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken) {
            return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken, false);
        };
        NormalModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, false);
        };
        NormalModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, false);
        };
        NormalModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, false);
        };
        NormalModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, block) {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, block, false);
        };
        NormalModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block) {
            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block, false);
        };
        NormalModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, false);
        };
        NormalModeFactory.prototype.emptyStatement = function (semicolonToken) {
            return new EmptyStatementSyntax(semicolonToken, false);
        };
        NormalModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, false);
        };
        NormalModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, closeParenToken, block) {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, closeParenToken, block, false);
        };
        NormalModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
            return new FinallyClauseSyntax(finallyKeyword, block, false);
        };
        NormalModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
            return new LabeledStatementSyntax(identifier, colonToken, statement, false);
        };
        NormalModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, false);
        };
        NormalModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
            return new TypeOfExpressionSyntax(typeOfKeyword, expression, false);
        };
        NormalModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
            return new DeleteExpressionSyntax(deleteKeyword, expression, false);
        };
        NormalModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
            return new VoidExpressionSyntax(voidKeyword, expression, false);
        };
        NormalModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, false);
        };
        return NormalModeFactory;
    })();    
    var StrictModeFactory = (function () {
        function StrictModeFactory() { }
        StrictModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
            return new SourceUnitSyntax(moduleElements, endOfFileToken, true);
        };
        StrictModeFactory.prototype.externalModuleReference = function (moduleKeyword, openParenToken, stringLiteral, closeParenToken) {
            return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, true);
        };
        StrictModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
            return new ModuleNameModuleReferenceSyntax(moduleName, true);
        };
        StrictModeFactory.prototype.importDeclaration = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, true);
        };
        StrictModeFactory.prototype.classDeclaration = function (exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken) {
            return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, true);
        };
        StrictModeFactory.prototype.interfaceDeclaration = function (exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body) {
            return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, true);
        };
        StrictModeFactory.prototype.extendsClause = function (extendsKeyword, typeNames) {
            return new ExtendsClauseSyntax(extendsKeyword, typeNames, true);
        };
        StrictModeFactory.prototype.implementsClause = function (implementsKeyword, typeNames) {
            return new ImplementsClauseSyntax(implementsKeyword, typeNames, true);
        };
        StrictModeFactory.prototype.moduleDeclaration = function (exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
            return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, true);
        };
        StrictModeFactory.prototype.functionDeclaration = function (exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken) {
            return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken, true);
        };
        StrictModeFactory.prototype.variableStatement = function (exportKeyword, declareKeyword, variableDeclaration, semicolonToken) {
            return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, true);
        };
        StrictModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, true);
        };
        StrictModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, true);
        };
        StrictModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
            return new EqualsValueClauseSyntax(equalsToken, value, true);
        };
        StrictModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, true);
        };
        StrictModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, true);
        };
        StrictModeFactory.prototype.omittedExpression = function () {
            return new OmittedExpressionSyntax(true);
        };
        StrictModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, true);
        };
        StrictModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, true);
        };
        StrictModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, true);
        };
        StrictModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
            return new QualifiedNameSyntax(left, dotToken, right, true);
        };
        StrictModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, true);
        };
        StrictModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, true);
        };
        StrictModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, true);
        };
        StrictModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, true);
        };
        StrictModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, true);
        };
        StrictModeFactory.prototype.genericType = function (name, typeArgumentList) {
            return new GenericTypeSyntax(name, typeArgumentList, true);
        };
        StrictModeFactory.prototype.typeAnnotation = function (colonToken, type) {
            return new TypeAnnotationSyntax(colonToken, type, true);
        };
        StrictModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
            return new BlockSyntax(openBraceToken, statements, closeBraceToken, true);
        };
        StrictModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, true);
        };
        StrictModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
            return new MemberAccessExpressionSyntax(expression, dotToken, name, true);
        };
        StrictModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, true);
        };
        StrictModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, true);
        };
        StrictModeFactory.prototype.invocationExpression = function (expression, argumentList) {
            return new InvocationExpressionSyntax(expression, argumentList, true);
        };
        StrictModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, true);
        };
        StrictModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
            return new BinaryExpressionSyntax(kind, left, operatorToken, right, true);
        };
        StrictModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, true);
        };
        StrictModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
            return new ConstructSignatureSyntax(newKeyword, callSignature, true);
        };
        StrictModeFactory.prototype.functionSignature = function (identifier, questionToken, callSignature) {
            return new FunctionSignatureSyntax(identifier, questionToken, callSignature, true);
        };
        StrictModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, true);
        };
        StrictModeFactory.prototype.propertySignature = function (identifier, questionToken, typeAnnotation) {
            return new PropertySignatureSyntax(identifier, questionToken, typeAnnotation, true);
        };
        StrictModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, true);
        };
        StrictModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, true);
        };
        StrictModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, true);
        };
        StrictModeFactory.prototype.typeParameter = function (identifier, constraint) {
            return new TypeParameterSyntax(identifier, constraint, true);
        };
        StrictModeFactory.prototype.constraint = function (extendsKeyword, type) {
            return new ConstraintSyntax(extendsKeyword, type, true);
        };
        StrictModeFactory.prototype.elseClause = function (elseKeyword, statement) {
            return new ElseClauseSyntax(elseKeyword, statement, true);
        };
        StrictModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, true);
        };
        StrictModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
            return new ExpressionStatementSyntax(expression, semicolonToken, true);
        };
        StrictModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, true);
        };
        StrictModeFactory.prototype.memberFunctionDeclaration = function (publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken) {
            return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken, true);
        };
        StrictModeFactory.prototype.getMemberAccessorDeclaration = function (publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block) {
            return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, true);
        };
        StrictModeFactory.prototype.setMemberAccessorDeclaration = function (publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block) {
            return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, true);
        };
        StrictModeFactory.prototype.memberVariableDeclaration = function (publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken) {
            return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, true);
        };
        StrictModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, true);
        };
        StrictModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, true);
        };
        StrictModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, true);
        };
        StrictModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, true);
        };
        StrictModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, true);
        };
        StrictModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, true);
        };
        StrictModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, true);
        };
        StrictModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, true);
        };
        StrictModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, true);
        };
        StrictModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, true);
        };
        StrictModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, true);
        };
        StrictModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, true);
        };
        StrictModeFactory.prototype.enumDeclaration = function (exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken) {
            return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken, true);
        };
        StrictModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, true);
        };
        StrictModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, true);
        };
        StrictModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, true);
        };
        StrictModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, block) {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, block, true);
        };
        StrictModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block) {
            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block, true);
        };
        StrictModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, true);
        };
        StrictModeFactory.prototype.emptyStatement = function (semicolonToken) {
            return new EmptyStatementSyntax(semicolonToken, true);
        };
        StrictModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, true);
        };
        StrictModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, closeParenToken, block) {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, closeParenToken, block, true);
        };
        StrictModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
            return new FinallyClauseSyntax(finallyKeyword, block, true);
        };
        StrictModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
            return new LabeledStatementSyntax(identifier, colonToken, statement, true);
        };
        StrictModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, true);
        };
        StrictModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
            return new TypeOfExpressionSyntax(typeOfKeyword, expression, true);
        };
        StrictModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
            return new DeleteExpressionSyntax(deleteKeyword, expression, true);
        };
        StrictModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
            return new VoidExpressionSyntax(voidKeyword, expression, true);
        };
        StrictModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, true);
        };
        return StrictModeFactory;
    })();    
    Syntax.normalModeFactory = new NormalModeFactory();
    Syntax.strictModeFactory = new StrictModeFactory();
})(Syntax || (Syntax = {}));
var Syntax;
(function (Syntax) {
    function emptySourceUnit() {
        return Syntax.normalModeFactory.sourceUnit(Syntax.emptyList, Syntax.token(10 /* EndOfFileToken */ , {
            text: ""
        }));
    }
    Syntax.emptySourceUnit = emptySourceUnit;
    function getStandaloneExpression(positionedToken) {
        var token = positionedToken.token();
        if (positionedToken !== null && positionedToken.kind() === 11 /* IdentifierName */ ) {
            var parentPositionedNode = positionedToken.containingNode();
            var parentNode = parentPositionedNode.node();
            if (parentNode.kind() === 121 /* QualifiedName */  && (parentNode).right === token) {
                return parentPositionedNode;
            } else if (parentNode.kind() === 209 /* MemberAccessExpression */  && (parentNode).name === token) {
                return parentPositionedNode;
            }
        }
        return positionedToken;
    }
    Syntax.getStandaloneExpression = getStandaloneExpression;
    function isInModuleOrTypeContext(positionedToken) {
        if (positionedToken !== null) {
            var positionedNodeOrToken = Syntax.getStandaloneExpression(positionedToken);
            var parent = positionedNodeOrToken.containingNode();
            if (parent !== null) {
                switch(parent.kind()) {
                    case 241 /* ModuleNameModuleReference */ :
                        return true;
                    case 121 /* QualifiedName */ :
                        return true;
                    default:
                        return isInTypeOnlyContext(positionedToken);
                }
            }
        }
        return false;
    }
    Syntax.isInModuleOrTypeContext = isInModuleOrTypeContext;
    function isInTypeOnlyContext(positionedToken) {
        var positionedNodeOrToken = Syntax.getStandaloneExpression(positionedToken);
        var positionedParent = positionedNodeOrToken.containingNode();
        var parent = positionedParent.node();
        var nodeOrToken = positionedNodeOrToken.nodeOrToken();
        if (parent !== null) {
            switch(parent.kind()) {
                case 124 /* ArrayType */ :
                    return (parent).type === nodeOrToken;
                case 217 /* CastExpression */ :
                    return (parent).type === nodeOrToken;
                case 238 /* TypeAnnotation */ :
                case 228 /* ExtendsClause */ :
                case 227 /* ImplementsClause */ :
                case 225 /* TypeArgumentList */ :
                    return true;
            }
        }
        return false;
    }
    Syntax.isInTypeOnlyContext = isInTypeOnlyContext;
    function childOffset(parent, child) {
        var offset = 0;
        for(var i = 0, n = parent.childCount(); i < n; i++) {
            var current = parent.childAt(i);
            if (current === child) {
                return offset;
            }
            if (current !== null) {
                offset += current.fullWidth();
            }
        }
        throw Errors.invalidOperation();
    }
    Syntax.childOffset = childOffset;
    function nodeStructuralEquals(node1, node2) {
        if (node1 === null) {
            return node2 === null;
        }
        return node1.structuralEquals(node2);
    }
    Syntax.nodeStructuralEquals = nodeStructuralEquals;
    function nodeOrTokenStructuralEquals(node1, node2) {
        if (node1 === node2) {
            return true;
        }
        if (node1 === null || node2 === null) {
            return false;
        }
        if (node1.isToken()) {
            return node2.isToken() ? tokenStructuralEquals(node1, node2) : false;
        }
        return node2.isNode() ? nodeStructuralEquals(node1, node2) : false;
    }
    Syntax.nodeOrTokenStructuralEquals = nodeOrTokenStructuralEquals;
    function tokenStructuralEquals(token1, token2) {
        if (token1 === token2) {
            return true;
        }
        if (token1 === null || token2 === null) {
            return false;
        }
        return token1.kind() === token2.kind() && token1.width() === token2.width() && token1.fullWidth() === token2.fullWidth() && token1.text() === token2.text() && Syntax.triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) && Syntax.triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
    }
    Syntax.tokenStructuralEquals = tokenStructuralEquals;
    function triviaListStructuralEquals(triviaList1, triviaList2) {
        if (triviaList1.count() !== triviaList2.count()) {
            return false;
        }
        for(var i = 0, n = triviaList1.count(); i < n; i++) {
            if (!Syntax.triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                return false;
            }
        }
        return true;
    }
    Syntax.triviaListStructuralEquals = triviaListStructuralEquals;
    function triviaStructuralEquals(trivia1, trivia2) {
        return trivia1.kind() === trivia2.kind() && trivia1.fullWidth() === trivia2.fullWidth() && trivia1.fullText() === trivia2.fullText();
    }
    Syntax.triviaStructuralEquals = triviaStructuralEquals;
    function listStructuralEquals(list1, list2) {
        if (list1.childCount() !== list2.childCount()) {
            return false;
        }
        for(var i = 0, n = list1.childCount(); i < n; i++) {
            if (!Syntax.nodeOrTokenStructuralEquals(list1.childAt(i), list2.childAt(i))) {
                return false;
            }
        }
        return true;
    }
    Syntax.listStructuralEquals = listStructuralEquals;
    function separatedListStructuralEquals(list1, list2) {
        if (list1.childCount() !== list2.childCount()) {
            return false;
        }
        for(var i = 0, n = list1.childCount(); i < n; i++) {
            var element1 = list1.childAt(i);
            var element2 = list2.childAt(i);
            if (!Syntax.nodeOrTokenStructuralEquals(element1, element2)) {
                return false;
            }
        }
        return true;
    }
    Syntax.separatedListStructuralEquals = separatedListStructuralEquals;
    function elementStructuralEquals(element1, element2) {
        if (element1 === element2) {
            return true;
        }
        if (element1 === null || element2 === null) {
            return false;
        }
        if (element2.kind() !== element2.kind()) {
            return false;
        }
        if (element1.isToken()) {
            return tokenStructuralEquals(element1, element2);
        } else if (element1.isNode()) {
            return nodeStructuralEquals(element1, element2);
        } else if (element1.isList()) {
            return listStructuralEquals(element1, element2);
        } else if (element1.isSeparatedList()) {
            return separatedListStructuralEquals(element1, element2);
        }
        throw Errors.invalidOperation();
    }
    Syntax.elementStructuralEquals = elementStructuralEquals;
    function identifierName(text, info) {
        if (typeof info === "undefined") { info = null; }
        return Syntax.identifier(text);
    }
    Syntax.identifierName = identifierName;
    function trueExpression() {
        return Syntax.token(37 /* TrueKeyword */ );
    }
    Syntax.trueExpression = trueExpression;
    function falseExpression() {
        return Syntax.token(24 /* FalseKeyword */ );
    }
    Syntax.falseExpression = falseExpression;
    function numericLiteralExpression(text) {
        return Syntax.token(13 /* NumericLiteral */ , {
            text: text
        });
    }
    Syntax.numericLiteralExpression = numericLiteralExpression;
    function stringLiteralExpression(text) {
        return Syntax.token(14 /* StringLiteral */ , {
            text: text
        });
    }
    Syntax.stringLiteralExpression = stringLiteralExpression;
    function isSuperInvocationExpression(node) {
        return node.kind() === 210 /* InvocationExpression */  && (node).expression.kind() === 50 /* SuperKeyword */ ;
    }
    Syntax.isSuperInvocationExpression = isSuperInvocationExpression;
    function isSuperInvocationExpressionStatement(node) {
        return node.kind() === 146 /* ExpressionStatement */  && isSuperInvocationExpression((node).expression);
    }
    Syntax.isSuperInvocationExpressionStatement = isSuperInvocationExpressionStatement;
    function isSuperMemberAccessExpression(node) {
        return node.kind() === 209 /* MemberAccessExpression */  && (node).expression.kind() === 50 /* SuperKeyword */ ;
    }
    Syntax.isSuperMemberAccessExpression = isSuperMemberAccessExpression;
    function isSuperMemberAccessInvocationExpression(node) {
        return node.kind() === 210 /* InvocationExpression */  && isSuperMemberAccessExpression((node).expression);
    }
    Syntax.isSuperMemberAccessInvocationExpression = isSuperMemberAccessInvocationExpression;
    function assignmentExpression(left, token, right) {
        return Syntax.normalModeFactory.binaryExpression(171 /* AssignmentExpression */ , left, token, right);
    }
    Syntax.assignmentExpression = assignmentExpression;
})(Syntax || (Syntax = {}));
var SourceUnitSyntax = (function (_super) {
    __extends(SourceUnitSyntax, _super);
    function SourceUnitSyntax(moduleElements, endOfFileToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.moduleElements = moduleElements;
        this.endOfFileToken = endOfFileToken;
    }
    SourceUnitSyntax.prototype.accept = function (visitor) {
        return visitor.visitSourceUnit(this);
    };
    SourceUnitSyntax.prototype.kind = function () {
        return 120 /* SourceUnit */ ;
    };
    SourceUnitSyntax.prototype.childCount = function () {
        return 2;
    };
    SourceUnitSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.moduleElements;
            case 1:
                return this.endOfFileToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    SourceUnitSyntax.prototype.update = function (moduleElements, endOfFileToken) {
        if (this.moduleElements === moduleElements && this.endOfFileToken === endOfFileToken) {
            return this;
        }
        return new SourceUnitSyntax(moduleElements, endOfFileToken, this.parsedInStrictMode());
    };
    SourceUnitSyntax.create = function create(endOfFileToken) {
        return new SourceUnitSyntax(Syntax.emptyList, endOfFileToken, false);
    };
    SourceUnitSyntax.create1 = function create1(endOfFileToken) {
        return new SourceUnitSyntax(Syntax.emptyList, endOfFileToken, false);
    };
    SourceUnitSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    SourceUnitSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    SourceUnitSyntax.prototype.withModuleElements = function (moduleElements) {
        return this.update(moduleElements, this.endOfFileToken);
    };
    SourceUnitSyntax.prototype.withModuleElement = function (moduleElement) {
        return this.withModuleElements(Syntax.list([
            moduleElement
        ]));
    };
    SourceUnitSyntax.prototype.withEndOfFileToken = function (endOfFileToken) {
        return this.update(this.moduleElements, endOfFileToken);
    };
    SourceUnitSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.moduleElements.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return SourceUnitSyntax;
})(SyntaxNode);
var ModuleReferenceSyntax = (function (_super) {
    __extends(ModuleReferenceSyntax, _super);
    function ModuleReferenceSyntax(parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
    }
    ModuleReferenceSyntax.prototype.isModuleReference = function () {
        return true;
    };
    ModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ModuleReferenceSyntax;
})(SyntaxNode);
var ExternalModuleReferenceSyntax = (function (_super) {
    __extends(ExternalModuleReferenceSyntax, _super);
    function ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.moduleKeyword = moduleKeyword;
        this.openParenToken = openParenToken;
        this.stringLiteral = stringLiteral;
        this.closeParenToken = closeParenToken;
    }
    ExternalModuleReferenceSyntax.prototype.accept = function (visitor) {
        return visitor.visitExternalModuleReference(this);
    };
    ExternalModuleReferenceSyntax.prototype.kind = function () {
        return 240 /* ExternalModuleReference */ ;
    };
    ExternalModuleReferenceSyntax.prototype.childCount = function () {
        return 4;
    };
    ExternalModuleReferenceSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.moduleKeyword;
            case 1:
                return this.openParenToken;
            case 2:
                return this.stringLiteral;
            case 3:
                return this.closeParenToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ExternalModuleReferenceSyntax.prototype.update = function (moduleKeyword, openParenToken, stringLiteral, closeParenToken) {
        if (this.moduleKeyword === moduleKeyword && this.openParenToken === openParenToken && this.stringLiteral === stringLiteral && this.closeParenToken === closeParenToken) {
            return this;
        }
        return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, this.parsedInStrictMode());
    };
    ExternalModuleReferenceSyntax.create1 = function create1(stringLiteral) {
        return new ExternalModuleReferenceSyntax(Syntax.token(66 /* ModuleKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), stringLiteral, Syntax.token(73 /* CloseParenToken */ ), false);
    };
    ExternalModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ExternalModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ExternalModuleReferenceSyntax.prototype.withModuleKeyword = function (moduleKeyword) {
        return this.update(moduleKeyword, this.openParenToken, this.stringLiteral, this.closeParenToken);
    };
    ExternalModuleReferenceSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.moduleKeyword, openParenToken, this.stringLiteral, this.closeParenToken);
    };
    ExternalModuleReferenceSyntax.prototype.withStringLiteral = function (stringLiteral) {
        return this.update(this.moduleKeyword, this.openParenToken, stringLiteral, this.closeParenToken);
    };
    ExternalModuleReferenceSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.moduleKeyword, this.openParenToken, this.stringLiteral, closeParenToken);
    };
    ExternalModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ExternalModuleReferenceSyntax;
})(ModuleReferenceSyntax);
var ModuleNameModuleReferenceSyntax = (function (_super) {
    __extends(ModuleNameModuleReferenceSyntax, _super);
    function ModuleNameModuleReferenceSyntax(moduleName, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.moduleName = moduleName;
    }
    ModuleNameModuleReferenceSyntax.prototype.accept = function (visitor) {
        return visitor.visitModuleNameModuleReference(this);
    };
    ModuleNameModuleReferenceSyntax.prototype.kind = function () {
        return 241 /* ModuleNameModuleReference */ ;
    };
    ModuleNameModuleReferenceSyntax.prototype.childCount = function () {
        return 1;
    };
    ModuleNameModuleReferenceSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.moduleName;
            default:
                throw Errors.invalidOperation();
        }
    };
    ModuleNameModuleReferenceSyntax.prototype.update = function (moduleName) {
        if (this.moduleName === moduleName) {
            return this;
        }
        return new ModuleNameModuleReferenceSyntax(moduleName, this.parsedInStrictMode());
    };
    ModuleNameModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ModuleNameModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ModuleNameModuleReferenceSyntax.prototype.withModuleName = function (moduleName) {
        return this.update(moduleName);
    };
    ModuleNameModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ModuleNameModuleReferenceSyntax;
})(ModuleReferenceSyntax);
var ImportDeclarationSyntax = (function (_super) {
    __extends(ImportDeclarationSyntax, _super);
    function ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.importKeyword = importKeyword;
        this.identifier = identifier;
        this.equalsToken = equalsToken;
        this.moduleReference = moduleReference;
        this.semicolonToken = semicolonToken;
    }
    ImportDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitImportDeclaration(this);
    };
    ImportDeclarationSyntax.prototype.kind = function () {
        return 132 /* ImportDeclaration */ ;
    };
    ImportDeclarationSyntax.prototype.childCount = function () {
        return 5;
    };
    ImportDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.importKeyword;
            case 1:
                return this.identifier;
            case 2:
                return this.equalsToken;
            case 3:
                return this.moduleReference;
            case 4:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ImportDeclarationSyntax.prototype.isModuleElement = function () {
        return true;
    };
    ImportDeclarationSyntax.prototype.update = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
        if (this.importKeyword === importKeyword && this.identifier === identifier && this.equalsToken === equalsToken && this.moduleReference === moduleReference && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, this.parsedInStrictMode());
    };
    ImportDeclarationSyntax.create1 = function create1(identifier, moduleReference) {
        return new ImportDeclarationSyntax(Syntax.token(49 /* ImportKeyword */ ), identifier, Syntax.token(107 /* EqualsToken */ ), moduleReference, Syntax.token(78 /* SemicolonToken */ ), false);
    };
    ImportDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ImportDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ImportDeclarationSyntax.prototype.withImportKeyword = function (importKeyword) {
        return this.update(importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
    };
    ImportDeclarationSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.importKeyword, identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
    };
    ImportDeclarationSyntax.prototype.withEqualsToken = function (equalsToken) {
        return this.update(this.importKeyword, this.identifier, equalsToken, this.moduleReference, this.semicolonToken);
    };
    ImportDeclarationSyntax.prototype.withModuleReference = function (moduleReference) {
        return this.update(this.importKeyword, this.identifier, this.equalsToken, moduleReference, this.semicolonToken);
    };
    ImportDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, semicolonToken);
    };
    ImportDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ImportDeclarationSyntax;
})(SyntaxNode);
var ClassDeclarationSyntax = (function (_super) {
    __extends(ClassDeclarationSyntax, _super);
    function ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.exportKeyword = exportKeyword;
        this.declareKeyword = declareKeyword;
        this.classKeyword = classKeyword;
        this.identifier = identifier;
        this.typeParameterList = typeParameterList;
        this.extendsClause = extendsClause;
        this.implementsClause = implementsClause;
        this.openBraceToken = openBraceToken;
        this.classElements = classElements;
        this.closeBraceToken = closeBraceToken;
    }
    ClassDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitClassDeclaration(this);
    };
    ClassDeclarationSyntax.prototype.kind = function () {
        return 130 /* ClassDeclaration */ ;
    };
    ClassDeclarationSyntax.prototype.childCount = function () {
        return 10;
    };
    ClassDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.exportKeyword;
            case 1:
                return this.declareKeyword;
            case 2:
                return this.classKeyword;
            case 3:
                return this.identifier;
            case 4:
                return this.typeParameterList;
            case 5:
                return this.extendsClause;
            case 6:
                return this.implementsClause;
            case 7:
                return this.openBraceToken;
            case 8:
                return this.classElements;
            case 9:
                return this.closeBraceToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ClassDeclarationSyntax.prototype.isModuleElement = function () {
        return true;
    };
    ClassDeclarationSyntax.prototype.update = function (exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken) {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.classKeyword === classKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.extendsClause === extendsClause && this.implementsClause === implementsClause && this.openBraceToken === openBraceToken && this.classElements === classElements && this.closeBraceToken === closeBraceToken) {
            return this;
        }
        return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, this.parsedInStrictMode());
    };
    ClassDeclarationSyntax.create = function create(classKeyword, identifier, openBraceToken, closeBraceToken) {
        return new ClassDeclarationSyntax(null, null, classKeyword, identifier, null, null, null, openBraceToken, Syntax.emptyList, closeBraceToken, false);
    };
    ClassDeclarationSyntax.create1 = function create1(identifier) {
        return new ClassDeclarationSyntax(null, null, Syntax.token(44 /* ClassKeyword */ ), identifier, null, null, null, Syntax.token(70 /* OpenBraceToken */ ), Syntax.emptyList, Syntax.token(71 /* CloseBraceToken */ ), false);
    };
    ClassDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ClassDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ClassDeclarationSyntax.prototype.withExportKeyword = function (exportKeyword) {
        return this.update(exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withDeclareKeyword = function (declareKeyword) {
        return this.update(this.exportKeyword, declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withClassKeyword = function (classKeyword) {
        return this.update(this.exportKeyword, this.declareKeyword, classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withExtendsClause = function (extendsClause) {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withImplementsClause = function (implementsClause) {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, openBraceToken, this.classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withClassElements = function (classElements) {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, classElements, this.closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.withClassElement = function (classElement) {
        return this.withClassElements(Syntax.list([
            classElement
        ]));
    };
    ClassDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, closeBraceToken);
    };
    ClassDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ClassDeclarationSyntax;
})(SyntaxNode);
var InterfaceDeclarationSyntax = (function (_super) {
    __extends(InterfaceDeclarationSyntax, _super);
    function InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.exportKeyword = exportKeyword;
        this.interfaceKeyword = interfaceKeyword;
        this.identifier = identifier;
        this.typeParameterList = typeParameterList;
        this.extendsClause = extendsClause;
        this.body = body;
    }
    InterfaceDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitInterfaceDeclaration(this);
    };
    InterfaceDeclarationSyntax.prototype.kind = function () {
        return 127 /* InterfaceDeclaration */ ;
    };
    InterfaceDeclarationSyntax.prototype.childCount = function () {
        return 6;
    };
    InterfaceDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.exportKeyword;
            case 1:
                return this.interfaceKeyword;
            case 2:
                return this.identifier;
            case 3:
                return this.typeParameterList;
            case 4:
                return this.extendsClause;
            case 5:
                return this.body;
            default:
                throw Errors.invalidOperation();
        }
    };
    InterfaceDeclarationSyntax.prototype.isModuleElement = function () {
        return true;
    };
    InterfaceDeclarationSyntax.prototype.update = function (exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body) {
        if (this.exportKeyword === exportKeyword && this.interfaceKeyword === interfaceKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.extendsClause === extendsClause && this.body === body) {
            return this;
        }
        return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, this.parsedInStrictMode());
    };
    InterfaceDeclarationSyntax.create = function create(interfaceKeyword, identifier, body) {
        return new InterfaceDeclarationSyntax(null, interfaceKeyword, identifier, null, null, body, false);
    };
    InterfaceDeclarationSyntax.create1 = function create1(identifier) {
        return new InterfaceDeclarationSyntax(null, Syntax.token(52 /* InterfaceKeyword */ ), identifier, null, null, ObjectTypeSyntax.create1(), false);
    };
    InterfaceDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    InterfaceDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    InterfaceDeclarationSyntax.prototype.withExportKeyword = function (exportKeyword) {
        return this.update(exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.body);
    };
    InterfaceDeclarationSyntax.prototype.withInterfaceKeyword = function (interfaceKeyword) {
        return this.update(this.exportKeyword, interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.body);
    };
    InterfaceDeclarationSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.exportKeyword, this.interfaceKeyword, identifier, this.typeParameterList, this.extendsClause, this.body);
    };
    InterfaceDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, typeParameterList, this.extendsClause, this.body);
    };
    InterfaceDeclarationSyntax.prototype.withExtendsClause = function (extendsClause) {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, extendsClause, this.body);
    };
    InterfaceDeclarationSyntax.prototype.withBody = function (body) {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, body);
    };
    InterfaceDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return InterfaceDeclarationSyntax;
})(SyntaxNode);
var ExtendsClauseSyntax = (function (_super) {
    __extends(ExtendsClauseSyntax, _super);
    function ExtendsClauseSyntax(extendsKeyword, typeNames, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.extendsKeyword = extendsKeyword;
        this.typeNames = typeNames;
    }
    ExtendsClauseSyntax.prototype.accept = function (visitor) {
        return visitor.visitExtendsClause(this);
    };
    ExtendsClauseSyntax.prototype.kind = function () {
        return 228 /* ExtendsClause */ ;
    };
    ExtendsClauseSyntax.prototype.childCount = function () {
        return 2;
    };
    ExtendsClauseSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.extendsKeyword;
            case 1:
                return this.typeNames;
            default:
                throw Errors.invalidOperation();
        }
    };
    ExtendsClauseSyntax.prototype.update = function (extendsKeyword, typeNames) {
        if (this.extendsKeyword === extendsKeyword && this.typeNames === typeNames) {
            return this;
        }
        return new ExtendsClauseSyntax(extendsKeyword, typeNames, this.parsedInStrictMode());
    };
    ExtendsClauseSyntax.create1 = function create1(typeNames) {
        return new ExtendsClauseSyntax(Syntax.token(48 /* ExtendsKeyword */ ), typeNames, false);
    };
    ExtendsClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ExtendsClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ExtendsClauseSyntax.prototype.withExtendsKeyword = function (extendsKeyword) {
        return this.update(extendsKeyword, this.typeNames);
    };
    ExtendsClauseSyntax.prototype.withTypeNames = function (typeNames) {
        return this.update(this.extendsKeyword, typeNames);
    };
    ExtendsClauseSyntax.prototype.withTypeName = function (typeName) {
        return this.withTypeNames(Syntax.separatedList([
            typeName
        ]));
    };
    ExtendsClauseSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ExtendsClauseSyntax;
})(SyntaxNode);
var ImplementsClauseSyntax = (function (_super) {
    __extends(ImplementsClauseSyntax, _super);
    function ImplementsClauseSyntax(implementsKeyword, typeNames, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.implementsKeyword = implementsKeyword;
        this.typeNames = typeNames;
    }
    ImplementsClauseSyntax.prototype.accept = function (visitor) {
        return visitor.visitImplementsClause(this);
    };
    ImplementsClauseSyntax.prototype.kind = function () {
        return 227 /* ImplementsClause */ ;
    };
    ImplementsClauseSyntax.prototype.childCount = function () {
        return 2;
    };
    ImplementsClauseSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.implementsKeyword;
            case 1:
                return this.typeNames;
            default:
                throw Errors.invalidOperation();
        }
    };
    ImplementsClauseSyntax.prototype.update = function (implementsKeyword, typeNames) {
        if (this.implementsKeyword === implementsKeyword && this.typeNames === typeNames) {
            return this;
        }
        return new ImplementsClauseSyntax(implementsKeyword, typeNames, this.parsedInStrictMode());
    };
    ImplementsClauseSyntax.create1 = function create1(typeNames) {
        return new ImplementsClauseSyntax(Syntax.token(51 /* ImplementsKeyword */ ), typeNames, false);
    };
    ImplementsClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ImplementsClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ImplementsClauseSyntax.prototype.withImplementsKeyword = function (implementsKeyword) {
        return this.update(implementsKeyword, this.typeNames);
    };
    ImplementsClauseSyntax.prototype.withTypeNames = function (typeNames) {
        return this.update(this.implementsKeyword, typeNames);
    };
    ImplementsClauseSyntax.prototype.withTypeName = function (typeName) {
        return this.withTypeNames(Syntax.separatedList([
            typeName
        ]));
    };
    ImplementsClauseSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ImplementsClauseSyntax;
})(SyntaxNode);
var ModuleDeclarationSyntax = (function (_super) {
    __extends(ModuleDeclarationSyntax, _super);
    function ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.exportKeyword = exportKeyword;
        this.declareKeyword = declareKeyword;
        this.moduleKeyword = moduleKeyword;
        this.moduleName = moduleName;
        this.stringLiteral = stringLiteral;
        this.openBraceToken = openBraceToken;
        this.moduleElements = moduleElements;
        this.closeBraceToken = closeBraceToken;
    }
    ModuleDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitModuleDeclaration(this);
    };
    ModuleDeclarationSyntax.prototype.kind = function () {
        return 129 /* ModuleDeclaration */ ;
    };
    ModuleDeclarationSyntax.prototype.childCount = function () {
        return 8;
    };
    ModuleDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.exportKeyword;
            case 1:
                return this.declareKeyword;
            case 2:
                return this.moduleKeyword;
            case 3:
                return this.moduleName;
            case 4:
                return this.stringLiteral;
            case 5:
                return this.openBraceToken;
            case 6:
                return this.moduleElements;
            case 7:
                return this.closeBraceToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ModuleDeclarationSyntax.prototype.isModuleElement = function () {
        return true;
    };
    ModuleDeclarationSyntax.prototype.update = function (exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.moduleKeyword === moduleKeyword && this.moduleName === moduleName && this.stringLiteral === stringLiteral && this.openBraceToken === openBraceToken && this.moduleElements === moduleElements && this.closeBraceToken === closeBraceToken) {
            return this;
        }
        return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, this.parsedInStrictMode());
    };
    ModuleDeclarationSyntax.create = function create(moduleKeyword, openBraceToken, closeBraceToken) {
        return new ModuleDeclarationSyntax(null, null, moduleKeyword, null, null, openBraceToken, Syntax.emptyList, closeBraceToken, false);
    };
    ModuleDeclarationSyntax.create1 = function create1() {
        return new ModuleDeclarationSyntax(null, null, Syntax.token(66 /* ModuleKeyword */ ), null, null, Syntax.token(70 /* OpenBraceToken */ ), Syntax.emptyList, Syntax.token(71 /* CloseBraceToken */ ), false);
    };
    ModuleDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ModuleDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ModuleDeclarationSyntax.prototype.withExportKeyword = function (exportKeyword) {
        return this.update(exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    };
    ModuleDeclarationSyntax.prototype.withDeclareKeyword = function (declareKeyword) {
        return this.update(this.exportKeyword, declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    };
    ModuleDeclarationSyntax.prototype.withModuleKeyword = function (moduleKeyword) {
        return this.update(this.exportKeyword, this.declareKeyword, moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    };
    ModuleDeclarationSyntax.prototype.withModuleName = function (moduleName) {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    };
    ModuleDeclarationSyntax.prototype.withStringLiteral = function (stringLiteral) {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    };
    ModuleDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, openBraceToken, this.moduleElements, this.closeBraceToken);
    };
    ModuleDeclarationSyntax.prototype.withModuleElements = function (moduleElements) {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, moduleElements, this.closeBraceToken);
    };
    ModuleDeclarationSyntax.prototype.withModuleElement = function (moduleElement) {
        return this.withModuleElements(Syntax.list([
            moduleElement
        ]));
    };
    ModuleDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, closeBraceToken);
    };
    ModuleDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ModuleDeclarationSyntax;
})(SyntaxNode);
var FunctionDeclarationSyntax = (function (_super) {
    __extends(FunctionDeclarationSyntax, _super);
    function FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.exportKeyword = exportKeyword;
        this.declareKeyword = declareKeyword;
        this.functionKeyword = functionKeyword;
        this.functionSignature = functionSignature;
        this.block = block;
        this.semicolonToken = semicolonToken;
    }
    FunctionDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitFunctionDeclaration(this);
    };
    FunctionDeclarationSyntax.prototype.kind = function () {
        return 128 /* FunctionDeclaration */ ;
    };
    FunctionDeclarationSyntax.prototype.childCount = function () {
        return 6;
    };
    FunctionDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.exportKeyword;
            case 1:
                return this.declareKeyword;
            case 2:
                return this.functionKeyword;
            case 3:
                return this.functionSignature;
            case 4:
                return this.block;
            case 5:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    FunctionDeclarationSyntax.prototype.isStatement = function () {
        return true;
    };
    FunctionDeclarationSyntax.prototype.isModuleElement = function () {
        return true;
    };
    FunctionDeclarationSyntax.prototype.update = function (exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken) {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.functionKeyword === functionKeyword && this.functionSignature === functionSignature && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken, this.parsedInStrictMode());
    };
    FunctionDeclarationSyntax.create = function create(functionKeyword, functionSignature) {
        return new FunctionDeclarationSyntax(null, null, functionKeyword, functionSignature, null, null, false);
    };
    FunctionDeclarationSyntax.create1 = function create1(functionSignature) {
        return new FunctionDeclarationSyntax(null, null, Syntax.token(27 /* FunctionKeyword */ ), functionSignature, null, null, false);
    };
    FunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    FunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    FunctionDeclarationSyntax.prototype.withExportKeyword = function (exportKeyword) {
        return this.update(exportKeyword, this.declareKeyword, this.functionKeyword, this.functionSignature, this.block, this.semicolonToken);
    };
    FunctionDeclarationSyntax.prototype.withDeclareKeyword = function (declareKeyword) {
        return this.update(this.exportKeyword, declareKeyword, this.functionKeyword, this.functionSignature, this.block, this.semicolonToken);
    };
    FunctionDeclarationSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
        return this.update(this.exportKeyword, this.declareKeyword, functionKeyword, this.functionSignature, this.block, this.semicolonToken);
    };
    FunctionDeclarationSyntax.prototype.withFunctionSignature = function (functionSignature) {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, functionSignature, this.block, this.semicolonToken);
    };
    FunctionDeclarationSyntax.prototype.withBlock = function (block) {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, this.functionSignature, block, this.semicolonToken);
    };
    FunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, this.functionSignature, this.block, semicolonToken);
    };
    FunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.exportKeyword !== null) {
            return true;
        }
        if (this.declareKeyword !== null) {
            return true;
        }
        if (this.functionSignature.isTypeScriptSpecific()) {
            return true;
        }
        if (this.block !== null && this.block.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return FunctionDeclarationSyntax;
})(SyntaxNode);
var VariableStatementSyntax = (function (_super) {
    __extends(VariableStatementSyntax, _super);
    function VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.exportKeyword = exportKeyword;
        this.declareKeyword = declareKeyword;
        this.variableDeclaration = variableDeclaration;
        this.semicolonToken = semicolonToken;
    }
    VariableStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitVariableStatement(this);
    };
    VariableStatementSyntax.prototype.kind = function () {
        return 145 /* VariableStatement */ ;
    };
    VariableStatementSyntax.prototype.childCount = function () {
        return 4;
    };
    VariableStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.exportKeyword;
            case 1:
                return this.declareKeyword;
            case 2:
                return this.variableDeclaration;
            case 3:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    VariableStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    VariableStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    VariableStatementSyntax.prototype.update = function (exportKeyword, declareKeyword, variableDeclaration, semicolonToken) {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.variableDeclaration === variableDeclaration && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, this.parsedInStrictMode());
    };
    VariableStatementSyntax.create = function create(variableDeclaration, semicolonToken) {
        return new VariableStatementSyntax(null, null, variableDeclaration, semicolonToken, false);
    };
    VariableStatementSyntax.create1 = function create1(variableDeclaration) {
        return new VariableStatementSyntax(null, null, variableDeclaration, Syntax.token(78 /* SemicolonToken */ ), false);
    };
    VariableStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    VariableStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    VariableStatementSyntax.prototype.withExportKeyword = function (exportKeyword) {
        return this.update(exportKeyword, this.declareKeyword, this.variableDeclaration, this.semicolonToken);
    };
    VariableStatementSyntax.prototype.withDeclareKeyword = function (declareKeyword) {
        return this.update(this.exportKeyword, declareKeyword, this.variableDeclaration, this.semicolonToken);
    };
    VariableStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
        return this.update(this.exportKeyword, this.declareKeyword, variableDeclaration, this.semicolonToken);
    };
    VariableStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.exportKeyword, this.declareKeyword, this.variableDeclaration, semicolonToken);
    };
    VariableStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.exportKeyword !== null) {
            return true;
        }
        if (this.declareKeyword !== null) {
            return true;
        }
        if (this.variableDeclaration.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return VariableStatementSyntax;
})(SyntaxNode);
var VariableDeclarationSyntax = (function (_super) {
    __extends(VariableDeclarationSyntax, _super);
    function VariableDeclarationSyntax(varKeyword, variableDeclarators, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.varKeyword = varKeyword;
        this.variableDeclarators = variableDeclarators;
    }
    VariableDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitVariableDeclaration(this);
    };
    VariableDeclarationSyntax.prototype.kind = function () {
        return 221 /* VariableDeclaration */ ;
    };
    VariableDeclarationSyntax.prototype.childCount = function () {
        return 2;
    };
    VariableDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.varKeyword;
            case 1:
                return this.variableDeclarators;
            default:
                throw Errors.invalidOperation();
        }
    };
    VariableDeclarationSyntax.prototype.update = function (varKeyword, variableDeclarators) {
        if (this.varKeyword === varKeyword && this.variableDeclarators === variableDeclarators) {
            return this;
        }
        return new VariableDeclarationSyntax(varKeyword, variableDeclarators, this.parsedInStrictMode());
    };
    VariableDeclarationSyntax.create1 = function create1(variableDeclarators) {
        return new VariableDeclarationSyntax(Syntax.token(40 /* VarKeyword */ ), variableDeclarators, false);
    };
    VariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    VariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    VariableDeclarationSyntax.prototype.withVarKeyword = function (varKeyword) {
        return this.update(varKeyword, this.variableDeclarators);
    };
    VariableDeclarationSyntax.prototype.withVariableDeclarators = function (variableDeclarators) {
        return this.update(this.varKeyword, variableDeclarators);
    };
    VariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
        return this.withVariableDeclarators(Syntax.separatedList([
            variableDeclarator
        ]));
    };
    VariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.variableDeclarators.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return VariableDeclarationSyntax;
})(SyntaxNode);
var VariableDeclaratorSyntax = (function (_super) {
    __extends(VariableDeclaratorSyntax, _super);
    function VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.identifier = identifier;
        this.typeAnnotation = typeAnnotation;
        this.equalsValueClause = equalsValueClause;
    }
    VariableDeclaratorSyntax.prototype.accept = function (visitor) {
        return visitor.visitVariableDeclarator(this);
    };
    VariableDeclaratorSyntax.prototype.kind = function () {
        return 222 /* VariableDeclarator */ ;
    };
    VariableDeclaratorSyntax.prototype.childCount = function () {
        return 3;
    };
    VariableDeclaratorSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.identifier;
            case 1:
                return this.typeAnnotation;
            case 2:
                return this.equalsValueClause;
            default:
                throw Errors.invalidOperation();
        }
    };
    VariableDeclaratorSyntax.prototype.update = function (identifier, typeAnnotation, equalsValueClause) {
        if (this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
            return this;
        }
        return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
    };
    VariableDeclaratorSyntax.create = function create(identifier) {
        return new VariableDeclaratorSyntax(identifier, null, null, false);
    };
    VariableDeclaratorSyntax.create1 = function create1(identifier) {
        return new VariableDeclaratorSyntax(identifier, null, null, false);
    };
    VariableDeclaratorSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    VariableDeclaratorSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    VariableDeclaratorSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(identifier, this.typeAnnotation, this.equalsValueClause);
    };
    VariableDeclaratorSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
        return this.update(this.identifier, typeAnnotation, this.equalsValueClause);
    };
    VariableDeclaratorSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
        return this.update(this.identifier, this.typeAnnotation, equalsValueClause);
    };
    VariableDeclaratorSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.typeAnnotation !== null) {
            return true;
        }
        if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return VariableDeclaratorSyntax;
})(SyntaxNode);
var EqualsValueClauseSyntax = (function (_super) {
    __extends(EqualsValueClauseSyntax, _super);
    function EqualsValueClauseSyntax(equalsToken, value, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.equalsToken = equalsToken;
        this.value = value;
    }
    EqualsValueClauseSyntax.prototype.accept = function (visitor) {
        return visitor.visitEqualsValueClause(this);
    };
    EqualsValueClauseSyntax.prototype.kind = function () {
        return 229 /* EqualsValueClause */ ;
    };
    EqualsValueClauseSyntax.prototype.childCount = function () {
        return 2;
    };
    EqualsValueClauseSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.equalsToken;
            case 1:
                return this.value;
            default:
                throw Errors.invalidOperation();
        }
    };
    EqualsValueClauseSyntax.prototype.update = function (equalsToken, value) {
        if (this.equalsToken === equalsToken && this.value === value) {
            return this;
        }
        return new EqualsValueClauseSyntax(equalsToken, value, this.parsedInStrictMode());
    };
    EqualsValueClauseSyntax.create1 = function create1(value) {
        return new EqualsValueClauseSyntax(Syntax.token(107 /* EqualsToken */ ), value, false);
    };
    EqualsValueClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    EqualsValueClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    EqualsValueClauseSyntax.prototype.withEqualsToken = function (equalsToken) {
        return this.update(equalsToken, this.value);
    };
    EqualsValueClauseSyntax.prototype.withValue = function (value) {
        return this.update(this.equalsToken, value);
    };
    EqualsValueClauseSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.value.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return EqualsValueClauseSyntax;
})(SyntaxNode);
var PrefixUnaryExpressionSyntax = (function (_super) {
    __extends(PrefixUnaryExpressionSyntax, _super);
    function PrefixUnaryExpressionSyntax(kind, operatorToken, operand, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.operatorToken = operatorToken;
        this.operand = operand;
        this._kind = kind;
    }
    PrefixUnaryExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitPrefixUnaryExpression(this);
    };
    PrefixUnaryExpressionSyntax.prototype.childCount = function () {
        return 2;
    };
    PrefixUnaryExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.operatorToken;
            case 1:
                return this.operand;
            default:
                throw Errors.invalidOperation();
        }
    };
    PrefixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    PrefixUnaryExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    PrefixUnaryExpressionSyntax.prototype.kind = function () {
        return this._kind;
    };
    PrefixUnaryExpressionSyntax.prototype.update = function (kind, operatorToken, operand) {
        if (this._kind === kind && this.operatorToken === operatorToken && this.operand === operand) {
            return this;
        }
        return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.parsedInStrictMode());
    };
    PrefixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    PrefixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    PrefixUnaryExpressionSyntax.prototype.withKind = function (kind) {
        return this.update(kind, this.operatorToken, this.operand);
    };
    PrefixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
        return this.update(this._kind, operatorToken, this.operand);
    };
    PrefixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
        return this.update(this._kind, this.operatorToken, operand);
    };
    PrefixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.operand.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return PrefixUnaryExpressionSyntax;
})(SyntaxNode);
var ArrayLiteralExpressionSyntax = (function (_super) {
    __extends(ArrayLiteralExpressionSyntax, _super);
    function ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.openBracketToken = openBracketToken;
        this.expressions = expressions;
        this.closeBracketToken = closeBracketToken;
    }
    ArrayLiteralExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitArrayLiteralExpression(this);
    };
    ArrayLiteralExpressionSyntax.prototype.kind = function () {
        return 211 /* ArrayLiteralExpression */ ;
    };
    ArrayLiteralExpressionSyntax.prototype.childCount = function () {
        return 3;
    };
    ArrayLiteralExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.openBracketToken;
            case 1:
                return this.expressions;
            case 2:
                return this.closeBracketToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ArrayLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ArrayLiteralExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    ArrayLiteralExpressionSyntax.prototype.update = function (openBracketToken, expressions, closeBracketToken) {
        if (this.openBracketToken === openBracketToken && this.expressions === expressions && this.closeBracketToken === closeBracketToken) {
            return this;
        }
        return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, this.parsedInStrictMode());
    };
    ArrayLiteralExpressionSyntax.create = function create(openBracketToken, closeBracketToken) {
        return new ArrayLiteralExpressionSyntax(openBracketToken, Syntax.emptySeparatedList, closeBracketToken, false);
    };
    ArrayLiteralExpressionSyntax.create1 = function create1() {
        return new ArrayLiteralExpressionSyntax(Syntax.token(74 /* OpenBracketToken */ ), Syntax.emptySeparatedList, Syntax.token(75 /* CloseBracketToken */ ), false);
    };
    ArrayLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ArrayLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ArrayLiteralExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
        return this.update(openBracketToken, this.expressions, this.closeBracketToken);
    };
    ArrayLiteralExpressionSyntax.prototype.withExpressions = function (expressions) {
        return this.update(this.openBracketToken, expressions, this.closeBracketToken);
    };
    ArrayLiteralExpressionSyntax.prototype.withExpression = function (expression) {
        return this.withExpressions(Syntax.separatedList([
            expression
        ]));
    };
    ArrayLiteralExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
        return this.update(this.openBracketToken, this.expressions, closeBracketToken);
    };
    ArrayLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expressions.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ArrayLiteralExpressionSyntax;
})(SyntaxNode);
var OmittedExpressionSyntax = (function (_super) {
    __extends(OmittedExpressionSyntax, _super);
    function OmittedExpressionSyntax(parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
    }
    OmittedExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitOmittedExpression(this);
    };
    OmittedExpressionSyntax.prototype.kind = function () {
        return 220 /* OmittedExpression */ ;
    };
    OmittedExpressionSyntax.prototype.childCount = function () {
        return 0;
    };
    OmittedExpressionSyntax.prototype.childAt = function (slot) {
        throw Errors.invalidOperation();
    };
    OmittedExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    OmittedExpressionSyntax.prototype.update = function () {
        return this;
    };
    OmittedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    OmittedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    OmittedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return OmittedExpressionSyntax;
})(SyntaxNode);
var ParenthesizedExpressionSyntax = (function (_super) {
    __extends(ParenthesizedExpressionSyntax, _super);
    function ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.openParenToken = openParenToken;
        this.expression = expression;
        this.closeParenToken = closeParenToken;
    }
    ParenthesizedExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitParenthesizedExpression(this);
    };
    ParenthesizedExpressionSyntax.prototype.kind = function () {
        return 214 /* ParenthesizedExpression */ ;
    };
    ParenthesizedExpressionSyntax.prototype.childCount = function () {
        return 3;
    };
    ParenthesizedExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.openParenToken;
            case 1:
                return this.expression;
            case 2:
                return this.closeParenToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ParenthesizedExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ParenthesizedExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    ParenthesizedExpressionSyntax.prototype.update = function (openParenToken, expression, closeParenToken) {
        if (this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken) {
            return this;
        }
        return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, this.parsedInStrictMode());
    };
    ParenthesizedExpressionSyntax.create1 = function create1(expression) {
        return new ParenthesizedExpressionSyntax(Syntax.token(72 /* OpenParenToken */ ), expression, Syntax.token(73 /* CloseParenToken */ ), false);
    };
    ParenthesizedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ParenthesizedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ParenthesizedExpressionSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(openParenToken, this.expression, this.closeParenToken);
    };
    ParenthesizedExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(this.openParenToken, expression, this.closeParenToken);
    };
    ParenthesizedExpressionSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.openParenToken, this.expression, closeParenToken);
    };
    ParenthesizedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ParenthesizedExpressionSyntax;
})(SyntaxNode);
var ArrowFunctionExpressionSyntax = (function (_super) {
    __extends(ArrowFunctionExpressionSyntax, _super);
    function ArrowFunctionExpressionSyntax(equalsGreaterThanToken, body, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.equalsGreaterThanToken = equalsGreaterThanToken;
        this.body = body;
    }
    ArrowFunctionExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ArrowFunctionExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    ArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ArrowFunctionExpressionSyntax;
})(SyntaxNode);
var SimpleArrowFunctionExpressionSyntax = (function (_super) {
    __extends(SimpleArrowFunctionExpressionSyntax, _super);
    function SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, parsedInStrictMode) {
        _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
        this.identifier = identifier;
    }
    SimpleArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitSimpleArrowFunctionExpression(this);
    };
    SimpleArrowFunctionExpressionSyntax.prototype.kind = function () {
        return 216 /* SimpleArrowFunctionExpression */ ;
    };
    SimpleArrowFunctionExpressionSyntax.prototype.childCount = function () {
        return 3;
    };
    SimpleArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.identifier;
            case 1:
                return this.equalsGreaterThanToken;
            case 2:
                return this.body;
            default:
                throw Errors.invalidOperation();
        }
    };
    SimpleArrowFunctionExpressionSyntax.prototype.update = function (identifier, equalsGreaterThanToken, body) {
        if (this.identifier === identifier && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
            return this;
        }
        return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, this.parsedInStrictMode());
    };
    SimpleArrowFunctionExpressionSyntax.create1 = function create1(identifier, body) {
        return new SimpleArrowFunctionExpressionSyntax(identifier, Syntax.token(85 /* EqualsGreaterThanToken */ ), body, false);
    };
    SimpleArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    SimpleArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    SimpleArrowFunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(identifier, this.equalsGreaterThanToken, this.body);
    };
    SimpleArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
        return this.update(this.identifier, equalsGreaterThanToken, this.body);
    };
    SimpleArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
        return this.update(this.identifier, this.equalsGreaterThanToken, body);
    };
    SimpleArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return SimpleArrowFunctionExpressionSyntax;
})(ArrowFunctionExpressionSyntax);
var ParenthesizedArrowFunctionExpressionSyntax = (function (_super) {
    __extends(ParenthesizedArrowFunctionExpressionSyntax, _super);
    function ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, parsedInStrictMode) {
        _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
        this.callSignature = callSignature;
    }
    ParenthesizedArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitParenthesizedArrowFunctionExpression(this);
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.kind = function () {
        return 215 /* ParenthesizedArrowFunctionExpression */ ;
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.childCount = function () {
        return 3;
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.callSignature;
            case 1:
                return this.equalsGreaterThanToken;
            case 2:
                return this.body;
            default:
                throw Errors.invalidOperation();
        }
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.update = function (callSignature, equalsGreaterThanToken, body) {
        if (this.callSignature === callSignature && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
            return this;
        }
        return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, this.parsedInStrictMode());
    };
    ParenthesizedArrowFunctionExpressionSyntax.create1 = function create1(body) {
        return new ParenthesizedArrowFunctionExpressionSyntax(CallSignatureSyntax.create1(), Syntax.token(85 /* EqualsGreaterThanToken */ ), body, false);
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
        return this.update(callSignature, this.equalsGreaterThanToken, this.body);
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
        return this.update(this.callSignature, equalsGreaterThanToken, this.body);
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
        return this.update(this.callSignature, this.equalsGreaterThanToken, body);
    };
    ParenthesizedArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ParenthesizedArrowFunctionExpressionSyntax;
})(ArrowFunctionExpressionSyntax);
var QualifiedNameSyntax = (function (_super) {
    __extends(QualifiedNameSyntax, _super);
    function QualifiedNameSyntax(left, dotToken, right, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.left = left;
        this.dotToken = dotToken;
        this.right = right;
    }
    QualifiedNameSyntax.prototype.accept = function (visitor) {
        return visitor.visitQualifiedName(this);
    };
    QualifiedNameSyntax.prototype.kind = function () {
        return 121 /* QualifiedName */ ;
    };
    QualifiedNameSyntax.prototype.childCount = function () {
        return 3;
    };
    QualifiedNameSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.left;
            case 1:
                return this.dotToken;
            case 2:
                return this.right;
            default:
                throw Errors.invalidOperation();
        }
    };
    QualifiedNameSyntax.prototype.isName = function () {
        return true;
    };
    QualifiedNameSyntax.prototype.isType = function () {
        return true;
    };
    QualifiedNameSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    QualifiedNameSyntax.prototype.isExpression = function () {
        return true;
    };
    QualifiedNameSyntax.prototype.update = function (left, dotToken, right) {
        if (this.left === left && this.dotToken === dotToken && this.right === right) {
            return this;
        }
        return new QualifiedNameSyntax(left, dotToken, right, this.parsedInStrictMode());
    };
    QualifiedNameSyntax.create1 = function create1(left, right) {
        return new QualifiedNameSyntax(left, Syntax.token(76 /* DotToken */ ), right, false);
    };
    QualifiedNameSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    QualifiedNameSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    QualifiedNameSyntax.prototype.withLeft = function (left) {
        return this.update(left, this.dotToken, this.right);
    };
    QualifiedNameSyntax.prototype.withDotToken = function (dotToken) {
        return this.update(this.left, dotToken, this.right);
    };
    QualifiedNameSyntax.prototype.withRight = function (right) {
        return this.update(this.left, this.dotToken, right);
    };
    QualifiedNameSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return QualifiedNameSyntax;
})(SyntaxNode);
var TypeArgumentListSyntax = (function (_super) {
    __extends(TypeArgumentListSyntax, _super);
    function TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.lessThanToken = lessThanToken;
        this.typeArguments = typeArguments;
        this.greaterThanToken = greaterThanToken;
    }
    TypeArgumentListSyntax.prototype.accept = function (visitor) {
        return visitor.visitTypeArgumentList(this);
    };
    TypeArgumentListSyntax.prototype.kind = function () {
        return 225 /* TypeArgumentList */ ;
    };
    TypeArgumentListSyntax.prototype.childCount = function () {
        return 3;
    };
    TypeArgumentListSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.lessThanToken;
            case 1:
                return this.typeArguments;
            case 2:
                return this.greaterThanToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    TypeArgumentListSyntax.prototype.update = function (lessThanToken, typeArguments, greaterThanToken) {
        if (this.lessThanToken === lessThanToken && this.typeArguments === typeArguments && this.greaterThanToken === greaterThanToken) {
            return this;
        }
        return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, this.parsedInStrictMode());
    };
    TypeArgumentListSyntax.create = function create(lessThanToken, greaterThanToken) {
        return new TypeArgumentListSyntax(lessThanToken, Syntax.emptySeparatedList, greaterThanToken, false);
    };
    TypeArgumentListSyntax.create1 = function create1() {
        return new TypeArgumentListSyntax(Syntax.token(80 /* LessThanToken */ ), Syntax.emptySeparatedList, Syntax.token(81 /* GreaterThanToken */ ), false);
    };
    TypeArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    TypeArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    TypeArgumentListSyntax.prototype.withLessThanToken = function (lessThanToken) {
        return this.update(lessThanToken, this.typeArguments, this.greaterThanToken);
    };
    TypeArgumentListSyntax.prototype.withTypeArguments = function (typeArguments) {
        return this.update(this.lessThanToken, typeArguments, this.greaterThanToken);
    };
    TypeArgumentListSyntax.prototype.withTypeArgument = function (typeArgument) {
        return this.withTypeArguments(Syntax.separatedList([
            typeArgument
        ]));
    };
    TypeArgumentListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
        return this.update(this.lessThanToken, this.typeArguments, greaterThanToken);
    };
    TypeArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return TypeArgumentListSyntax;
})(SyntaxNode);
var ConstructorTypeSyntax = (function (_super) {
    __extends(ConstructorTypeSyntax, _super);
    function ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.newKeyword = newKeyword;
        this.typeParameterList = typeParameterList;
        this.parameterList = parameterList;
        this.equalsGreaterThanToken = equalsGreaterThanToken;
        this.type = type;
    }
    ConstructorTypeSyntax.prototype.accept = function (visitor) {
        return visitor.visitConstructorType(this);
    };
    ConstructorTypeSyntax.prototype.kind = function () {
        return 125 /* ConstructorType */ ;
    };
    ConstructorTypeSyntax.prototype.childCount = function () {
        return 5;
    };
    ConstructorTypeSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.newKeyword;
            case 1:
                return this.typeParameterList;
            case 2:
                return this.parameterList;
            case 3:
                return this.equalsGreaterThanToken;
            case 4:
                return this.type;
            default:
                throw Errors.invalidOperation();
        }
    };
    ConstructorTypeSyntax.prototype.isType = function () {
        return true;
    };
    ConstructorTypeSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ConstructorTypeSyntax.prototype.isExpression = function () {
        return true;
    };
    ConstructorTypeSyntax.prototype.update = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
        if (this.newKeyword === newKeyword && this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
            return this;
        }
        return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
    };
    ConstructorTypeSyntax.create = function create(newKeyword, parameterList, equalsGreaterThanToken, type) {
        return new ConstructorTypeSyntax(newKeyword, null, parameterList, equalsGreaterThanToken, type, false);
    };
    ConstructorTypeSyntax.create1 = function create1(type) {
        return new ConstructorTypeSyntax(Syntax.token(31 /* NewKeyword */ ), null, ParameterListSyntax.create1(), Syntax.token(85 /* EqualsGreaterThanToken */ ), type, false);
    };
    ConstructorTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ConstructorTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ConstructorTypeSyntax.prototype.withNewKeyword = function (newKeyword) {
        return this.update(newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    };
    ConstructorTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
        return this.update(this.newKeyword, typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    };
    ConstructorTypeSyntax.prototype.withParameterList = function (parameterList) {
        return this.update(this.newKeyword, this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
    };
    ConstructorTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
        return this.update(this.newKeyword, this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
    };
    ConstructorTypeSyntax.prototype.withType = function (type) {
        return this.update(this.newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
    };
    ConstructorTypeSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ConstructorTypeSyntax;
})(SyntaxNode);
var FunctionTypeSyntax = (function (_super) {
    __extends(FunctionTypeSyntax, _super);
    function FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.typeParameterList = typeParameterList;
        this.parameterList = parameterList;
        this.equalsGreaterThanToken = equalsGreaterThanToken;
        this.type = type;
    }
    FunctionTypeSyntax.prototype.accept = function (visitor) {
        return visitor.visitFunctionType(this);
    };
    FunctionTypeSyntax.prototype.kind = function () {
        return 123 /* FunctionType */ ;
    };
    FunctionTypeSyntax.prototype.childCount = function () {
        return 4;
    };
    FunctionTypeSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.typeParameterList;
            case 1:
                return this.parameterList;
            case 2:
                return this.equalsGreaterThanToken;
            case 3:
                return this.type;
            default:
                throw Errors.invalidOperation();
        }
    };
    FunctionTypeSyntax.prototype.isType = function () {
        return true;
    };
    FunctionTypeSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    FunctionTypeSyntax.prototype.isExpression = function () {
        return true;
    };
    FunctionTypeSyntax.prototype.update = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
        if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
            return this;
        }
        return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
    };
    FunctionTypeSyntax.create = function create(parameterList, equalsGreaterThanToken, type) {
        return new FunctionTypeSyntax(null, parameterList, equalsGreaterThanToken, type, false);
    };
    FunctionTypeSyntax.create1 = function create1(type) {
        return new FunctionTypeSyntax(null, ParameterListSyntax.create1(), Syntax.token(85 /* EqualsGreaterThanToken */ ), type, false);
    };
    FunctionTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    FunctionTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    FunctionTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
        return this.update(typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    };
    FunctionTypeSyntax.prototype.withParameterList = function (parameterList) {
        return this.update(this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
    };
    FunctionTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
        return this.update(this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
    };
    FunctionTypeSyntax.prototype.withType = function (type) {
        return this.update(this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
    };
    FunctionTypeSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return FunctionTypeSyntax;
})(SyntaxNode);
var ObjectTypeSyntax = (function (_super) {
    __extends(ObjectTypeSyntax, _super);
    function ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.openBraceToken = openBraceToken;
        this.typeMembers = typeMembers;
        this.closeBraceToken = closeBraceToken;
    }
    ObjectTypeSyntax.prototype.accept = function (visitor) {
        return visitor.visitObjectType(this);
    };
    ObjectTypeSyntax.prototype.kind = function () {
        return 122 /* ObjectType */ ;
    };
    ObjectTypeSyntax.prototype.childCount = function () {
        return 3;
    };
    ObjectTypeSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.openBraceToken;
            case 1:
                return this.typeMembers;
            case 2:
                return this.closeBraceToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ObjectTypeSyntax.prototype.isType = function () {
        return true;
    };
    ObjectTypeSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ObjectTypeSyntax.prototype.isExpression = function () {
        return true;
    };
    ObjectTypeSyntax.prototype.update = function (openBraceToken, typeMembers, closeBraceToken) {
        if (this.openBraceToken === openBraceToken && this.typeMembers === typeMembers && this.closeBraceToken === closeBraceToken) {
            return this;
        }
        return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, this.parsedInStrictMode());
    };
    ObjectTypeSyntax.create = function create(openBraceToken, closeBraceToken) {
        return new ObjectTypeSyntax(openBraceToken, Syntax.emptySeparatedList, closeBraceToken, false);
    };
    ObjectTypeSyntax.create1 = function create1() {
        return new ObjectTypeSyntax(Syntax.token(70 /* OpenBraceToken */ ), Syntax.emptySeparatedList, Syntax.token(71 /* CloseBraceToken */ ), false);
    };
    ObjectTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ObjectTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ObjectTypeSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
        return this.update(openBraceToken, this.typeMembers, this.closeBraceToken);
    };
    ObjectTypeSyntax.prototype.withTypeMembers = function (typeMembers) {
        return this.update(this.openBraceToken, typeMembers, this.closeBraceToken);
    };
    ObjectTypeSyntax.prototype.withTypeMember = function (typeMember) {
        return this.withTypeMembers(Syntax.separatedList([
            typeMember
        ]));
    };
    ObjectTypeSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
        return this.update(this.openBraceToken, this.typeMembers, closeBraceToken);
    };
    ObjectTypeSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ObjectTypeSyntax;
})(SyntaxNode);
var ArrayTypeSyntax = (function (_super) {
    __extends(ArrayTypeSyntax, _super);
    function ArrayTypeSyntax(type, openBracketToken, closeBracketToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.type = type;
        this.openBracketToken = openBracketToken;
        this.closeBracketToken = closeBracketToken;
    }
    ArrayTypeSyntax.prototype.accept = function (visitor) {
        return visitor.visitArrayType(this);
    };
    ArrayTypeSyntax.prototype.kind = function () {
        return 124 /* ArrayType */ ;
    };
    ArrayTypeSyntax.prototype.childCount = function () {
        return 3;
    };
    ArrayTypeSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.type;
            case 1:
                return this.openBracketToken;
            case 2:
                return this.closeBracketToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ArrayTypeSyntax.prototype.isType = function () {
        return true;
    };
    ArrayTypeSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ArrayTypeSyntax.prototype.isExpression = function () {
        return true;
    };
    ArrayTypeSyntax.prototype.update = function (type, openBracketToken, closeBracketToken) {
        if (this.type === type && this.openBracketToken === openBracketToken && this.closeBracketToken === closeBracketToken) {
            return this;
        }
        return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, this.parsedInStrictMode());
    };
    ArrayTypeSyntax.create1 = function create1(type) {
        return new ArrayTypeSyntax(type, Syntax.token(74 /* OpenBracketToken */ ), Syntax.token(75 /* CloseBracketToken */ ), false);
    };
    ArrayTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ArrayTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ArrayTypeSyntax.prototype.withType = function (type) {
        return this.update(type, this.openBracketToken, this.closeBracketToken);
    };
    ArrayTypeSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
        return this.update(this.type, openBracketToken, this.closeBracketToken);
    };
    ArrayTypeSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
        return this.update(this.type, this.openBracketToken, closeBracketToken);
    };
    ArrayTypeSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ArrayTypeSyntax;
})(SyntaxNode);
var GenericTypeSyntax = (function (_super) {
    __extends(GenericTypeSyntax, _super);
    function GenericTypeSyntax(name, typeArgumentList, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.name = name;
        this.typeArgumentList = typeArgumentList;
    }
    GenericTypeSyntax.prototype.accept = function (visitor) {
        return visitor.visitGenericType(this);
    };
    GenericTypeSyntax.prototype.kind = function () {
        return 126 /* GenericType */ ;
    };
    GenericTypeSyntax.prototype.childCount = function () {
        return 2;
    };
    GenericTypeSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.name;
            case 1:
                return this.typeArgumentList;
            default:
                throw Errors.invalidOperation();
        }
    };
    GenericTypeSyntax.prototype.isType = function () {
        return true;
    };
    GenericTypeSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    GenericTypeSyntax.prototype.isExpression = function () {
        return true;
    };
    GenericTypeSyntax.prototype.update = function (name, typeArgumentList) {
        if (this.name === name && this.typeArgumentList === typeArgumentList) {
            return this;
        }
        return new GenericTypeSyntax(name, typeArgumentList, this.parsedInStrictMode());
    };
    GenericTypeSyntax.create1 = function create1(name) {
        return new GenericTypeSyntax(name, TypeArgumentListSyntax.create1(), false);
    };
    GenericTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    GenericTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    GenericTypeSyntax.prototype.withName = function (name) {
        return this.update(name, this.typeArgumentList);
    };
    GenericTypeSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
        return this.update(this.name, typeArgumentList);
    };
    GenericTypeSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return GenericTypeSyntax;
})(SyntaxNode);
var TypeAnnotationSyntax = (function (_super) {
    __extends(TypeAnnotationSyntax, _super);
    function TypeAnnotationSyntax(colonToken, type, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.colonToken = colonToken;
        this.type = type;
    }
    TypeAnnotationSyntax.prototype.accept = function (visitor) {
        return visitor.visitTypeAnnotation(this);
    };
    TypeAnnotationSyntax.prototype.kind = function () {
        return 238 /* TypeAnnotation */ ;
    };
    TypeAnnotationSyntax.prototype.childCount = function () {
        return 2;
    };
    TypeAnnotationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.colonToken;
            case 1:
                return this.type;
            default:
                throw Errors.invalidOperation();
        }
    };
    TypeAnnotationSyntax.prototype.update = function (colonToken, type) {
        if (this.colonToken === colonToken && this.type === type) {
            return this;
        }
        return new TypeAnnotationSyntax(colonToken, type, this.parsedInStrictMode());
    };
    TypeAnnotationSyntax.create1 = function create1(type) {
        return new TypeAnnotationSyntax(Syntax.token(106 /* ColonToken */ ), type, false);
    };
    TypeAnnotationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    TypeAnnotationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    TypeAnnotationSyntax.prototype.withColonToken = function (colonToken) {
        return this.update(colonToken, this.type);
    };
    TypeAnnotationSyntax.prototype.withType = function (type) {
        return this.update(this.colonToken, type);
    };
    TypeAnnotationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return TypeAnnotationSyntax;
})(SyntaxNode);
var BlockSyntax = (function (_super) {
    __extends(BlockSyntax, _super);
    function BlockSyntax(openBraceToken, statements, closeBraceToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.openBraceToken = openBraceToken;
        this.statements = statements;
        this.closeBraceToken = closeBraceToken;
    }
    BlockSyntax.prototype.accept = function (visitor) {
        return visitor.visitBlock(this);
    };
    BlockSyntax.prototype.kind = function () {
        return 143 /* Block */ ;
    };
    BlockSyntax.prototype.childCount = function () {
        return 3;
    };
    BlockSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.openBraceToken;
            case 1:
                return this.statements;
            case 2:
                return this.closeBraceToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    BlockSyntax.prototype.isStatement = function () {
        return true;
    };
    BlockSyntax.prototype.isModuleElement = function () {
        return true;
    };
    BlockSyntax.prototype.update = function (openBraceToken, statements, closeBraceToken) {
        if (this.openBraceToken === openBraceToken && this.statements === statements && this.closeBraceToken === closeBraceToken) {
            return this;
        }
        return new BlockSyntax(openBraceToken, statements, closeBraceToken, this.parsedInStrictMode());
    };
    BlockSyntax.create = function create(openBraceToken, closeBraceToken) {
        return new BlockSyntax(openBraceToken, Syntax.emptyList, closeBraceToken, false);
    };
    BlockSyntax.create1 = function create1() {
        return new BlockSyntax(Syntax.token(70 /* OpenBraceToken */ ), Syntax.emptyList, Syntax.token(71 /* CloseBraceToken */ ), false);
    };
    BlockSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    BlockSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    BlockSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
        return this.update(openBraceToken, this.statements, this.closeBraceToken);
    };
    BlockSyntax.prototype.withStatements = function (statements) {
        return this.update(this.openBraceToken, statements, this.closeBraceToken);
    };
    BlockSyntax.prototype.withStatement = function (statement) {
        return this.withStatements(Syntax.list([
            statement
        ]));
    };
    BlockSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
        return this.update(this.openBraceToken, this.statements, closeBraceToken);
    };
    BlockSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.statements.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return BlockSyntax;
})(SyntaxNode);
var ParameterSyntax = (function (_super) {
    __extends(ParameterSyntax, _super);
    function ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.dotDotDotToken = dotDotDotToken;
        this.publicOrPrivateKeyword = publicOrPrivateKeyword;
        this.identifier = identifier;
        this.questionToken = questionToken;
        this.typeAnnotation = typeAnnotation;
        this.equalsValueClause = equalsValueClause;
    }
    ParameterSyntax.prototype.accept = function (visitor) {
        return visitor.visitParameter(this);
    };
    ParameterSyntax.prototype.kind = function () {
        return 237 /* Parameter */ ;
    };
    ParameterSyntax.prototype.childCount = function () {
        return 6;
    };
    ParameterSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.dotDotDotToken;
            case 1:
                return this.publicOrPrivateKeyword;
            case 2:
                return this.identifier;
            case 3:
                return this.questionToken;
            case 4:
                return this.typeAnnotation;
            case 5:
                return this.equalsValueClause;
            default:
                throw Errors.invalidOperation();
        }
    };
    ParameterSyntax.prototype.update = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
        if (this.dotDotDotToken === dotDotDotToken && this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
            return this;
        }
        return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
    };
    ParameterSyntax.create = function create(identifier) {
        return new ParameterSyntax(null, null, identifier, null, null, null, false);
    };
    ParameterSyntax.create1 = function create1(identifier) {
        return new ParameterSyntax(null, null, identifier, null, null, null, false);
    };
    ParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ParameterSyntax.prototype.withDotDotDotToken = function (dotDotDotToken) {
        return this.update(dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    };
    ParameterSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
        return this.update(this.dotDotDotToken, publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    };
    ParameterSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    };
    ParameterSyntax.prototype.withQuestionToken = function (questionToken) {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, questionToken, this.typeAnnotation, this.equalsValueClause);
    };
    ParameterSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, typeAnnotation, this.equalsValueClause);
    };
    ParameterSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, equalsValueClause);
    };
    ParameterSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.dotDotDotToken !== null) {
            return true;
        }
        if (this.publicOrPrivateKeyword !== null) {
            return true;
        }
        if (this.questionToken !== null) {
            return true;
        }
        if (this.typeAnnotation !== null) {
            return true;
        }
        if (this.equalsValueClause !== null) {
            return true;
        }
        return false;
    };
    return ParameterSyntax;
})(SyntaxNode);
var MemberAccessExpressionSyntax = (function (_super) {
    __extends(MemberAccessExpressionSyntax, _super);
    function MemberAccessExpressionSyntax(expression, dotToken, name, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.expression = expression;
        this.dotToken = dotToken;
        this.name = name;
    }
    MemberAccessExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitMemberAccessExpression(this);
    };
    MemberAccessExpressionSyntax.prototype.kind = function () {
        return 209 /* MemberAccessExpression */ ;
    };
    MemberAccessExpressionSyntax.prototype.childCount = function () {
        return 3;
    };
    MemberAccessExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.expression;
            case 1:
                return this.dotToken;
            case 2:
                return this.name;
            default:
                throw Errors.invalidOperation();
        }
    };
    MemberAccessExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    MemberAccessExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    MemberAccessExpressionSyntax.prototype.update = function (expression, dotToken, name) {
        if (this.expression === expression && this.dotToken === dotToken && this.name === name) {
            return this;
        }
        return new MemberAccessExpressionSyntax(expression, dotToken, name, this.parsedInStrictMode());
    };
    MemberAccessExpressionSyntax.create1 = function create1(expression, name) {
        return new MemberAccessExpressionSyntax(expression, Syntax.token(76 /* DotToken */ ), name, false);
    };
    MemberAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    MemberAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    MemberAccessExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(expression, this.dotToken, this.name);
    };
    MemberAccessExpressionSyntax.prototype.withDotToken = function (dotToken) {
        return this.update(this.expression, dotToken, this.name);
    };
    MemberAccessExpressionSyntax.prototype.withName = function (name) {
        return this.update(this.expression, this.dotToken, name);
    };
    MemberAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return MemberAccessExpressionSyntax;
})(SyntaxNode);
var PostfixUnaryExpressionSyntax = (function (_super) {
    __extends(PostfixUnaryExpressionSyntax, _super);
    function PostfixUnaryExpressionSyntax(kind, operand, operatorToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.operand = operand;
        this.operatorToken = operatorToken;
        this._kind = kind;
    }
    PostfixUnaryExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitPostfixUnaryExpression(this);
    };
    PostfixUnaryExpressionSyntax.prototype.childCount = function () {
        return 2;
    };
    PostfixUnaryExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.operand;
            case 1:
                return this.operatorToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    PostfixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    PostfixUnaryExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    PostfixUnaryExpressionSyntax.prototype.kind = function () {
        return this._kind;
    };
    PostfixUnaryExpressionSyntax.prototype.update = function (kind, operand, operatorToken) {
        if (this._kind === kind && this.operand === operand && this.operatorToken === operatorToken) {
            return this;
        }
        return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.parsedInStrictMode());
    };
    PostfixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    PostfixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    PostfixUnaryExpressionSyntax.prototype.withKind = function (kind) {
        return this.update(kind, this.operand, this.operatorToken);
    };
    PostfixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
        return this.update(this._kind, operand, this.operatorToken);
    };
    PostfixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
        return this.update(this._kind, this.operand, operatorToken);
    };
    PostfixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.operand.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return PostfixUnaryExpressionSyntax;
})(SyntaxNode);
var ElementAccessExpressionSyntax = (function (_super) {
    __extends(ElementAccessExpressionSyntax, _super);
    function ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.expression = expression;
        this.openBracketToken = openBracketToken;
        this.argumentExpression = argumentExpression;
        this.closeBracketToken = closeBracketToken;
    }
    ElementAccessExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitElementAccessExpression(this);
    };
    ElementAccessExpressionSyntax.prototype.kind = function () {
        return 218 /* ElementAccessExpression */ ;
    };
    ElementAccessExpressionSyntax.prototype.childCount = function () {
        return 4;
    };
    ElementAccessExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.expression;
            case 1:
                return this.openBracketToken;
            case 2:
                return this.argumentExpression;
            case 3:
                return this.closeBracketToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ElementAccessExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ElementAccessExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    ElementAccessExpressionSyntax.prototype.update = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
        if (this.expression === expression && this.openBracketToken === openBracketToken && this.argumentExpression === argumentExpression && this.closeBracketToken === closeBracketToken) {
            return this;
        }
        return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, this.parsedInStrictMode());
    };
    ElementAccessExpressionSyntax.create1 = function create1(expression, argumentExpression) {
        return new ElementAccessExpressionSyntax(expression, Syntax.token(74 /* OpenBracketToken */ ), argumentExpression, Syntax.token(75 /* CloseBracketToken */ ), false);
    };
    ElementAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ElementAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ElementAccessExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(expression, this.openBracketToken, this.argumentExpression, this.closeBracketToken);
    };
    ElementAccessExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
        return this.update(this.expression, openBracketToken, this.argumentExpression, this.closeBracketToken);
    };
    ElementAccessExpressionSyntax.prototype.withArgumentExpression = function (argumentExpression) {
        return this.update(this.expression, this.openBracketToken, argumentExpression, this.closeBracketToken);
    };
    ElementAccessExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
        return this.update(this.expression, this.openBracketToken, this.argumentExpression, closeBracketToken);
    };
    ElementAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        if (this.argumentExpression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ElementAccessExpressionSyntax;
})(SyntaxNode);
var InvocationExpressionSyntax = (function (_super) {
    __extends(InvocationExpressionSyntax, _super);
    function InvocationExpressionSyntax(expression, argumentList, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.expression = expression;
        this.argumentList = argumentList;
    }
    InvocationExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitInvocationExpression(this);
    };
    InvocationExpressionSyntax.prototype.kind = function () {
        return 210 /* InvocationExpression */ ;
    };
    InvocationExpressionSyntax.prototype.childCount = function () {
        return 2;
    };
    InvocationExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.expression;
            case 1:
                return this.argumentList;
            default:
                throw Errors.invalidOperation();
        }
    };
    InvocationExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    InvocationExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    InvocationExpressionSyntax.prototype.update = function (expression, argumentList) {
        if (this.expression === expression && this.argumentList === argumentList) {
            return this;
        }
        return new InvocationExpressionSyntax(expression, argumentList, this.parsedInStrictMode());
    };
    InvocationExpressionSyntax.create1 = function create1(expression) {
        return new InvocationExpressionSyntax(expression, ArgumentListSyntax.create1(), false);
    };
    InvocationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    InvocationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    InvocationExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(expression, this.argumentList);
    };
    InvocationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
        return this.update(this.expression, argumentList);
    };
    InvocationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        if (this.argumentList.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return InvocationExpressionSyntax;
})(SyntaxNode);
var ArgumentListSyntax = (function (_super) {
    __extends(ArgumentListSyntax, _super);
    function ArgumentListSyntax(typeArgumentList, openParenToken, arguments, closeParenToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.typeArgumentList = typeArgumentList;
        this.openParenToken = openParenToken;
        this.arguments = arguments;
        this.closeParenToken = closeParenToken;
    }
    ArgumentListSyntax.prototype.accept = function (visitor) {
        return visitor.visitArgumentList(this);
    };
    ArgumentListSyntax.prototype.kind = function () {
        return 223 /* ArgumentList */ ;
    };
    ArgumentListSyntax.prototype.childCount = function () {
        return 4;
    };
    ArgumentListSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.typeArgumentList;
            case 1:
                return this.openParenToken;
            case 2:
                return this.arguments;
            case 3:
                return this.closeParenToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ArgumentListSyntax.prototype.update = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
        if (this.typeArgumentList === typeArgumentList && this.openParenToken === openParenToken && this.arguments === _arguments && this.closeParenToken === closeParenToken) {
            return this;
        }
        return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, this.parsedInStrictMode());
    };
    ArgumentListSyntax.create = function create(openParenToken, closeParenToken) {
        return new ArgumentListSyntax(null, openParenToken, Syntax.emptySeparatedList, closeParenToken, false);
    };
    ArgumentListSyntax.create1 = function create1() {
        return new ArgumentListSyntax(null, Syntax.token(72 /* OpenParenToken */ ), Syntax.emptySeparatedList, Syntax.token(73 /* CloseParenToken */ ), false);
    };
    ArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ArgumentListSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
        return this.update(typeArgumentList, this.openParenToken, this.arguments, this.closeParenToken);
    };
    ArgumentListSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.typeArgumentList, openParenToken, this.arguments, this.closeParenToken);
    };
    ArgumentListSyntax.prototype.withArguments = function (_arguments) {
        return this.update(this.typeArgumentList, this.openParenToken, _arguments, this.closeParenToken);
    };
    ArgumentListSyntax.prototype.withArgument = function (_argument) {
        return this.withArguments(Syntax.separatedList([
            _argument
        ]));
    };
    ArgumentListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.typeArgumentList, this.openParenToken, this.arguments, closeParenToken);
    };
    ArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.typeArgumentList !== null && this.typeArgumentList.isTypeScriptSpecific()) {
            return true;
        }
        if (this.arguments.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ArgumentListSyntax;
})(SyntaxNode);
var BinaryExpressionSyntax = (function (_super) {
    __extends(BinaryExpressionSyntax, _super);
    function BinaryExpressionSyntax(kind, left, operatorToken, right, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.left = left;
        this.operatorToken = operatorToken;
        this.right = right;
        this._kind = kind;
    }
    BinaryExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitBinaryExpression(this);
    };
    BinaryExpressionSyntax.prototype.childCount = function () {
        return 3;
    };
    BinaryExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.left;
            case 1:
                return this.operatorToken;
            case 2:
                return this.right;
            default:
                throw Errors.invalidOperation();
        }
    };
    BinaryExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    BinaryExpressionSyntax.prototype.kind = function () {
        return this._kind;
    };
    BinaryExpressionSyntax.prototype.update = function (kind, left, operatorToken, right) {
        if (this._kind === kind && this.left === left && this.operatorToken === operatorToken && this.right === right) {
            return this;
        }
        return new BinaryExpressionSyntax(kind, left, operatorToken, right, this.parsedInStrictMode());
    };
    BinaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    BinaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    BinaryExpressionSyntax.prototype.withKind = function (kind) {
        return this.update(kind, this.left, this.operatorToken, this.right);
    };
    BinaryExpressionSyntax.prototype.withLeft = function (left) {
        return this.update(this._kind, left, this.operatorToken, this.right);
    };
    BinaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
        return this.update(this._kind, this.left, operatorToken, this.right);
    };
    BinaryExpressionSyntax.prototype.withRight = function (right) {
        return this.update(this._kind, this.left, this.operatorToken, right);
    };
    BinaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.left.isTypeScriptSpecific()) {
            return true;
        }
        if (this.right.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return BinaryExpressionSyntax;
})(SyntaxNode);
var ConditionalExpressionSyntax = (function (_super) {
    __extends(ConditionalExpressionSyntax, _super);
    function ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.condition = condition;
        this.questionToken = questionToken;
        this.whenTrue = whenTrue;
        this.colonToken = colonToken;
        this.whenFalse = whenFalse;
    }
    ConditionalExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitConditionalExpression(this);
    };
    ConditionalExpressionSyntax.prototype.kind = function () {
        return 183 /* ConditionalExpression */ ;
    };
    ConditionalExpressionSyntax.prototype.childCount = function () {
        return 5;
    };
    ConditionalExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.condition;
            case 1:
                return this.questionToken;
            case 2:
                return this.whenTrue;
            case 3:
                return this.colonToken;
            case 4:
                return this.whenFalse;
            default:
                throw Errors.invalidOperation();
        }
    };
    ConditionalExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    ConditionalExpressionSyntax.prototype.update = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
        if (this.condition === condition && this.questionToken === questionToken && this.whenTrue === whenTrue && this.colonToken === colonToken && this.whenFalse === whenFalse) {
            return this;
        }
        return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, this.parsedInStrictMode());
    };
    ConditionalExpressionSyntax.create1 = function create1(condition, whenTrue, whenFalse) {
        return new ConditionalExpressionSyntax(condition, Syntax.token(105 /* QuestionToken */ ), whenTrue, Syntax.token(106 /* ColonToken */ ), whenFalse, false);
    };
    ConditionalExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ConditionalExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ConditionalExpressionSyntax.prototype.withCondition = function (condition) {
        return this.update(condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse);
    };
    ConditionalExpressionSyntax.prototype.withQuestionToken = function (questionToken) {
        return this.update(this.condition, questionToken, this.whenTrue, this.colonToken, this.whenFalse);
    };
    ConditionalExpressionSyntax.prototype.withWhenTrue = function (whenTrue) {
        return this.update(this.condition, this.questionToken, whenTrue, this.colonToken, this.whenFalse);
    };
    ConditionalExpressionSyntax.prototype.withColonToken = function (colonToken) {
        return this.update(this.condition, this.questionToken, this.whenTrue, colonToken, this.whenFalse);
    };
    ConditionalExpressionSyntax.prototype.withWhenFalse = function (whenFalse) {
        return this.update(this.condition, this.questionToken, this.whenTrue, this.colonToken, whenFalse);
    };
    ConditionalExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.condition.isTypeScriptSpecific()) {
            return true;
        }
        if (this.whenTrue.isTypeScriptSpecific()) {
            return true;
        }
        if (this.whenFalse.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ConditionalExpressionSyntax;
})(SyntaxNode);
var TypeMemberSyntax = (function (_super) {
    __extends(TypeMemberSyntax, _super);
    function TypeMemberSyntax(parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
    }
    TypeMemberSyntax.prototype.isTypeMember = function () {
        return true;
    };
    TypeMemberSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    TypeMemberSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    TypeMemberSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return TypeMemberSyntax;
})(SyntaxNode);
var ConstructSignatureSyntax = (function (_super) {
    __extends(ConstructSignatureSyntax, _super);
    function ConstructSignatureSyntax(newKeyword, callSignature, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.newKeyword = newKeyword;
        this.callSignature = callSignature;
    }
    ConstructSignatureSyntax.prototype.accept = function (visitor) {
        return visitor.visitConstructSignature(this);
    };
    ConstructSignatureSyntax.prototype.kind = function () {
        return 140 /* ConstructSignature */ ;
    };
    ConstructSignatureSyntax.prototype.childCount = function () {
        return 2;
    };
    ConstructSignatureSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.newKeyword;
            case 1:
                return this.callSignature;
            default:
                throw Errors.invalidOperation();
        }
    };
    ConstructSignatureSyntax.prototype.update = function (newKeyword, callSignature) {
        if (this.newKeyword === newKeyword && this.callSignature === callSignature) {
            return this;
        }
        return new ConstructSignatureSyntax(newKeyword, callSignature, this.parsedInStrictMode());
    };
    ConstructSignatureSyntax.create1 = function create1() {
        return new ConstructSignatureSyntax(Syntax.token(31 /* NewKeyword */ ), CallSignatureSyntax.create1(), false);
    };
    ConstructSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ConstructSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ConstructSignatureSyntax.prototype.withNewKeyword = function (newKeyword) {
        return this.update(newKeyword, this.callSignature);
    };
    ConstructSignatureSyntax.prototype.withCallSignature = function (callSignature) {
        return this.update(this.newKeyword, callSignature);
    };
    ConstructSignatureSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ConstructSignatureSyntax;
})(TypeMemberSyntax);
var FunctionSignatureSyntax = (function (_super) {
    __extends(FunctionSignatureSyntax, _super);
    function FunctionSignatureSyntax(identifier, questionToken, callSignature, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.identifier = identifier;
        this.questionToken = questionToken;
        this.callSignature = callSignature;
    }
    FunctionSignatureSyntax.prototype.accept = function (visitor) {
        return visitor.visitFunctionSignature(this);
    };
    FunctionSignatureSyntax.prototype.kind = function () {
        return 142 /* FunctionSignature */ ;
    };
    FunctionSignatureSyntax.prototype.childCount = function () {
        return 3;
    };
    FunctionSignatureSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.identifier;
            case 1:
                return this.questionToken;
            case 2:
                return this.callSignature;
            default:
                throw Errors.invalidOperation();
        }
    };
    FunctionSignatureSyntax.prototype.update = function (identifier, questionToken, callSignature) {
        if (this.identifier === identifier && this.questionToken === questionToken && this.callSignature === callSignature) {
            return this;
        }
        return new FunctionSignatureSyntax(identifier, questionToken, callSignature, this.parsedInStrictMode());
    };
    FunctionSignatureSyntax.create = function create(identifier, callSignature) {
        return new FunctionSignatureSyntax(identifier, null, callSignature, false);
    };
    FunctionSignatureSyntax.create1 = function create1(identifier) {
        return new FunctionSignatureSyntax(identifier, null, CallSignatureSyntax.create1(), false);
    };
    FunctionSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    FunctionSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    FunctionSignatureSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(identifier, this.questionToken, this.callSignature);
    };
    FunctionSignatureSyntax.prototype.withQuestionToken = function (questionToken) {
        return this.update(this.identifier, questionToken, this.callSignature);
    };
    FunctionSignatureSyntax.prototype.withCallSignature = function (callSignature) {
        return this.update(this.identifier, this.questionToken, callSignature);
    };
    FunctionSignatureSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.callSignature.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return FunctionSignatureSyntax;
})(TypeMemberSyntax);
var IndexSignatureSyntax = (function (_super) {
    __extends(IndexSignatureSyntax, _super);
    function IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.openBracketToken = openBracketToken;
        this.parameter = parameter;
        this.closeBracketToken = closeBracketToken;
        this.typeAnnotation = typeAnnotation;
    }
    IndexSignatureSyntax.prototype.accept = function (visitor) {
        return visitor.visitIndexSignature(this);
    };
    IndexSignatureSyntax.prototype.kind = function () {
        return 141 /* IndexSignature */ ;
    };
    IndexSignatureSyntax.prototype.childCount = function () {
        return 4;
    };
    IndexSignatureSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.openBracketToken;
            case 1:
                return this.parameter;
            case 2:
                return this.closeBracketToken;
            case 3:
                return this.typeAnnotation;
            default:
                throw Errors.invalidOperation();
        }
    };
    IndexSignatureSyntax.prototype.update = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
        if (this.openBracketToken === openBracketToken && this.parameter === parameter && this.closeBracketToken === closeBracketToken && this.typeAnnotation === typeAnnotation) {
            return this;
        }
        return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, this.parsedInStrictMode());
    };
    IndexSignatureSyntax.create = function create(openBracketToken, parameter, closeBracketToken) {
        return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, null, false);
    };
    IndexSignatureSyntax.create1 = function create1(parameter) {
        return new IndexSignatureSyntax(Syntax.token(74 /* OpenBracketToken */ ), parameter, Syntax.token(75 /* CloseBracketToken */ ), null, false);
    };
    IndexSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    IndexSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    IndexSignatureSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
        return this.update(openBracketToken, this.parameter, this.closeBracketToken, this.typeAnnotation);
    };
    IndexSignatureSyntax.prototype.withParameter = function (parameter) {
        return this.update(this.openBracketToken, parameter, this.closeBracketToken, this.typeAnnotation);
    };
    IndexSignatureSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
        return this.update(this.openBracketToken, this.parameter, closeBracketToken, this.typeAnnotation);
    };
    IndexSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
        return this.update(this.openBracketToken, this.parameter, this.closeBracketToken, typeAnnotation);
    };
    IndexSignatureSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return IndexSignatureSyntax;
})(TypeMemberSyntax);
var PropertySignatureSyntax = (function (_super) {
    __extends(PropertySignatureSyntax, _super);
    function PropertySignatureSyntax(identifier, questionToken, typeAnnotation, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.identifier = identifier;
        this.questionToken = questionToken;
        this.typeAnnotation = typeAnnotation;
    }
    PropertySignatureSyntax.prototype.accept = function (visitor) {
        return visitor.visitPropertySignature(this);
    };
    PropertySignatureSyntax.prototype.kind = function () {
        return 138 /* PropertySignature */ ;
    };
    PropertySignatureSyntax.prototype.childCount = function () {
        return 3;
    };
    PropertySignatureSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.identifier;
            case 1:
                return this.questionToken;
            case 2:
                return this.typeAnnotation;
            default:
                throw Errors.invalidOperation();
        }
    };
    PropertySignatureSyntax.prototype.update = function (identifier, questionToken, typeAnnotation) {
        if (this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation) {
            return this;
        }
        return new PropertySignatureSyntax(identifier, questionToken, typeAnnotation, this.parsedInStrictMode());
    };
    PropertySignatureSyntax.create = function create(identifier) {
        return new PropertySignatureSyntax(identifier, null, null, false);
    };
    PropertySignatureSyntax.create1 = function create1(identifier) {
        return new PropertySignatureSyntax(identifier, null, null, false);
    };
    PropertySignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    PropertySignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    PropertySignatureSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(identifier, this.questionToken, this.typeAnnotation);
    };
    PropertySignatureSyntax.prototype.withQuestionToken = function (questionToken) {
        return this.update(this.identifier, questionToken, this.typeAnnotation);
    };
    PropertySignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
        return this.update(this.identifier, this.questionToken, typeAnnotation);
    };
    PropertySignatureSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return PropertySignatureSyntax;
})(TypeMemberSyntax);
var ParameterListSyntax = (function (_super) {
    __extends(ParameterListSyntax, _super);
    function ParameterListSyntax(openParenToken, parameters, closeParenToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.openParenToken = openParenToken;
        this.parameters = parameters;
        this.closeParenToken = closeParenToken;
    }
    ParameterListSyntax.prototype.accept = function (visitor) {
        return visitor.visitParameterList(this);
    };
    ParameterListSyntax.prototype.kind = function () {
        return 224 /* ParameterList */ ;
    };
    ParameterListSyntax.prototype.childCount = function () {
        return 3;
    };
    ParameterListSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.openParenToken;
            case 1:
                return this.parameters;
            case 2:
                return this.closeParenToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ParameterListSyntax.prototype.update = function (openParenToken, parameters, closeParenToken) {
        if (this.openParenToken === openParenToken && this.parameters === parameters && this.closeParenToken === closeParenToken) {
            return this;
        }
        return new ParameterListSyntax(openParenToken, parameters, closeParenToken, this.parsedInStrictMode());
    };
    ParameterListSyntax.create = function create(openParenToken, closeParenToken) {
        return new ParameterListSyntax(openParenToken, Syntax.emptySeparatedList, closeParenToken, false);
    };
    ParameterListSyntax.create1 = function create1() {
        return new ParameterListSyntax(Syntax.token(72 /* OpenParenToken */ ), Syntax.emptySeparatedList, Syntax.token(73 /* CloseParenToken */ ), false);
    };
    ParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ParameterListSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(openParenToken, this.parameters, this.closeParenToken);
    };
    ParameterListSyntax.prototype.withParameters = function (parameters) {
        return this.update(this.openParenToken, parameters, this.closeParenToken);
    };
    ParameterListSyntax.prototype.withParameter = function (parameter) {
        return this.withParameters(Syntax.separatedList([
            parameter
        ]));
    };
    ParameterListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.openParenToken, this.parameters, closeParenToken);
    };
    ParameterListSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.parameters.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ParameterListSyntax;
})(SyntaxNode);
var CallSignatureSyntax = (function (_super) {
    __extends(CallSignatureSyntax, _super);
    function CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.typeParameterList = typeParameterList;
        this.parameterList = parameterList;
        this.typeAnnotation = typeAnnotation;
    }
    CallSignatureSyntax.prototype.accept = function (visitor) {
        return visitor.visitCallSignature(this);
    };
    CallSignatureSyntax.prototype.kind = function () {
        return 139 /* CallSignature */ ;
    };
    CallSignatureSyntax.prototype.childCount = function () {
        return 3;
    };
    CallSignatureSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.typeParameterList;
            case 1:
                return this.parameterList;
            case 2:
                return this.typeAnnotation;
            default:
                throw Errors.invalidOperation();
        }
    };
    CallSignatureSyntax.prototype.update = function (typeParameterList, parameterList, typeAnnotation) {
        if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation) {
            return this;
        }
        return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, this.parsedInStrictMode());
    };
    CallSignatureSyntax.create = function create(parameterList) {
        return new CallSignatureSyntax(null, parameterList, null, false);
    };
    CallSignatureSyntax.create1 = function create1() {
        return new CallSignatureSyntax(null, ParameterListSyntax.create1(), null, false);
    };
    CallSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    CallSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    CallSignatureSyntax.prototype.withTypeParameterList = function (typeParameterList) {
        return this.update(typeParameterList, this.parameterList, this.typeAnnotation);
    };
    CallSignatureSyntax.prototype.withParameterList = function (parameterList) {
        return this.update(this.typeParameterList, parameterList, this.typeAnnotation);
    };
    CallSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
        return this.update(this.typeParameterList, this.parameterList, typeAnnotation);
    };
    CallSignatureSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.typeParameterList !== null) {
            return true;
        }
        if (this.parameterList.isTypeScriptSpecific()) {
            return true;
        }
        if (this.typeAnnotation !== null) {
            return true;
        }
        return false;
    };
    return CallSignatureSyntax;
})(TypeMemberSyntax);
var TypeParameterListSyntax = (function (_super) {
    __extends(TypeParameterListSyntax, _super);
    function TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.lessThanToken = lessThanToken;
        this.typeParameters = typeParameters;
        this.greaterThanToken = greaterThanToken;
    }
    TypeParameterListSyntax.prototype.accept = function (visitor) {
        return visitor.visitTypeParameterList(this);
    };
    TypeParameterListSyntax.prototype.kind = function () {
        return 226 /* TypeParameterList */ ;
    };
    TypeParameterListSyntax.prototype.childCount = function () {
        return 3;
    };
    TypeParameterListSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.lessThanToken;
            case 1:
                return this.typeParameters;
            case 2:
                return this.greaterThanToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    TypeParameterListSyntax.prototype.update = function (lessThanToken, typeParameters, greaterThanToken) {
        if (this.lessThanToken === lessThanToken && this.typeParameters === typeParameters && this.greaterThanToken === greaterThanToken) {
            return this;
        }
        return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, this.parsedInStrictMode());
    };
    TypeParameterListSyntax.create = function create(lessThanToken, greaterThanToken) {
        return new TypeParameterListSyntax(lessThanToken, Syntax.emptySeparatedList, greaterThanToken, false);
    };
    TypeParameterListSyntax.create1 = function create1() {
        return new TypeParameterListSyntax(Syntax.token(80 /* LessThanToken */ ), Syntax.emptySeparatedList, Syntax.token(81 /* GreaterThanToken */ ), false);
    };
    TypeParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    TypeParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    TypeParameterListSyntax.prototype.withLessThanToken = function (lessThanToken) {
        return this.update(lessThanToken, this.typeParameters, this.greaterThanToken);
    };
    TypeParameterListSyntax.prototype.withTypeParameters = function (typeParameters) {
        return this.update(this.lessThanToken, typeParameters, this.greaterThanToken);
    };
    TypeParameterListSyntax.prototype.withTypeParameter = function (typeParameter) {
        return this.withTypeParameters(Syntax.separatedList([
            typeParameter
        ]));
    };
    TypeParameterListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
        return this.update(this.lessThanToken, this.typeParameters, greaterThanToken);
    };
    TypeParameterListSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return TypeParameterListSyntax;
})(SyntaxNode);
var TypeParameterSyntax = (function (_super) {
    __extends(TypeParameterSyntax, _super);
    function TypeParameterSyntax(identifier, constraint, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.identifier = identifier;
        this.constraint = constraint;
    }
    TypeParameterSyntax.prototype.accept = function (visitor) {
        return visitor.visitTypeParameter(this);
    };
    TypeParameterSyntax.prototype.kind = function () {
        return 235 /* TypeParameter */ ;
    };
    TypeParameterSyntax.prototype.childCount = function () {
        return 2;
    };
    TypeParameterSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.identifier;
            case 1:
                return this.constraint;
            default:
                throw Errors.invalidOperation();
        }
    };
    TypeParameterSyntax.prototype.update = function (identifier, constraint) {
        if (this.identifier === identifier && this.constraint === constraint) {
            return this;
        }
        return new TypeParameterSyntax(identifier, constraint, this.parsedInStrictMode());
    };
    TypeParameterSyntax.create = function create(identifier) {
        return new TypeParameterSyntax(identifier, null, false);
    };
    TypeParameterSyntax.create1 = function create1(identifier) {
        return new TypeParameterSyntax(identifier, null, false);
    };
    TypeParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    TypeParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    TypeParameterSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(identifier, this.constraint);
    };
    TypeParameterSyntax.prototype.withConstraint = function (constraint) {
        return this.update(this.identifier, constraint);
    };
    TypeParameterSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return TypeParameterSyntax;
})(SyntaxNode);
var ConstraintSyntax = (function (_super) {
    __extends(ConstraintSyntax, _super);
    function ConstraintSyntax(extendsKeyword, type, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.extendsKeyword = extendsKeyword;
        this.type = type;
    }
    ConstraintSyntax.prototype.accept = function (visitor) {
        return visitor.visitConstraint(this);
    };
    ConstraintSyntax.prototype.kind = function () {
        return 236 /* Constraint */ ;
    };
    ConstraintSyntax.prototype.childCount = function () {
        return 2;
    };
    ConstraintSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.extendsKeyword;
            case 1:
                return this.type;
            default:
                throw Errors.invalidOperation();
        }
    };
    ConstraintSyntax.prototype.update = function (extendsKeyword, type) {
        if (this.extendsKeyword === extendsKeyword && this.type === type) {
            return this;
        }
        return new ConstraintSyntax(extendsKeyword, type, this.parsedInStrictMode());
    };
    ConstraintSyntax.create1 = function create1(type) {
        return new ConstraintSyntax(Syntax.token(48 /* ExtendsKeyword */ ), type, false);
    };
    ConstraintSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ConstraintSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ConstraintSyntax.prototype.withExtendsKeyword = function (extendsKeyword) {
        return this.update(extendsKeyword, this.type);
    };
    ConstraintSyntax.prototype.withType = function (type) {
        return this.update(this.extendsKeyword, type);
    };
    ConstraintSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ConstraintSyntax;
})(SyntaxNode);
var ElseClauseSyntax = (function (_super) {
    __extends(ElseClauseSyntax, _super);
    function ElseClauseSyntax(elseKeyword, statement, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.elseKeyword = elseKeyword;
        this.statement = statement;
    }
    ElseClauseSyntax.prototype.accept = function (visitor) {
        return visitor.visitElseClause(this);
    };
    ElseClauseSyntax.prototype.kind = function () {
        return 232 /* ElseClause */ ;
    };
    ElseClauseSyntax.prototype.childCount = function () {
        return 2;
    };
    ElseClauseSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.elseKeyword;
            case 1:
                return this.statement;
            default:
                throw Errors.invalidOperation();
        }
    };
    ElseClauseSyntax.prototype.update = function (elseKeyword, statement) {
        if (this.elseKeyword === elseKeyword && this.statement === statement) {
            return this;
        }
        return new ElseClauseSyntax(elseKeyword, statement, this.parsedInStrictMode());
    };
    ElseClauseSyntax.create1 = function create1(statement) {
        return new ElseClauseSyntax(Syntax.token(23 /* ElseKeyword */ ), statement, false);
    };
    ElseClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ElseClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ElseClauseSyntax.prototype.withElseKeyword = function (elseKeyword) {
        return this.update(elseKeyword, this.statement);
    };
    ElseClauseSyntax.prototype.withStatement = function (statement) {
        return this.update(this.elseKeyword, statement);
    };
    ElseClauseSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.statement.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ElseClauseSyntax;
})(SyntaxNode);
var IfStatementSyntax = (function (_super) {
    __extends(IfStatementSyntax, _super);
    function IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.ifKeyword = ifKeyword;
        this.openParenToken = openParenToken;
        this.condition = condition;
        this.closeParenToken = closeParenToken;
        this.statement = statement;
        this.elseClause = elseClause;
    }
    IfStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitIfStatement(this);
    };
    IfStatementSyntax.prototype.kind = function () {
        return 144 /* IfStatement */ ;
    };
    IfStatementSyntax.prototype.childCount = function () {
        return 6;
    };
    IfStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.ifKeyword;
            case 1:
                return this.openParenToken;
            case 2:
                return this.condition;
            case 3:
                return this.closeParenToken;
            case 4:
                return this.statement;
            case 5:
                return this.elseClause;
            default:
                throw Errors.invalidOperation();
        }
    };
    IfStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    IfStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    IfStatementSyntax.prototype.update = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
        if (this.ifKeyword === ifKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement && this.elseClause === elseClause) {
            return this;
        }
        return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, this.parsedInStrictMode());
    };
    IfStatementSyntax.create = function create(ifKeyword, openParenToken, condition, closeParenToken, statement) {
        return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, null, false);
    };
    IfStatementSyntax.create1 = function create1(condition, statement) {
        return new IfStatementSyntax(Syntax.token(28 /* IfKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), condition, Syntax.token(73 /* CloseParenToken */ ), statement, null, false);
    };
    IfStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    IfStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    IfStatementSyntax.prototype.withIfKeyword = function (ifKeyword) {
        return this.update(ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
    };
    IfStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.ifKeyword, openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
    };
    IfStatementSyntax.prototype.withCondition = function (condition) {
        return this.update(this.ifKeyword, this.openParenToken, condition, this.closeParenToken, this.statement, this.elseClause);
    };
    IfStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, closeParenToken, this.statement, this.elseClause);
    };
    IfStatementSyntax.prototype.withStatement = function (statement) {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, statement, this.elseClause);
    };
    IfStatementSyntax.prototype.withElseClause = function (elseClause) {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, elseClause);
    };
    IfStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.condition.isTypeScriptSpecific()) {
            return true;
        }
        if (this.statement.isTypeScriptSpecific()) {
            return true;
        }
        if (this.elseClause !== null && this.elseClause.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return IfStatementSyntax;
})(SyntaxNode);
var ExpressionStatementSyntax = (function (_super) {
    __extends(ExpressionStatementSyntax, _super);
    function ExpressionStatementSyntax(expression, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.expression = expression;
        this.semicolonToken = semicolonToken;
    }
    ExpressionStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitExpressionStatement(this);
    };
    ExpressionStatementSyntax.prototype.kind = function () {
        return 146 /* ExpressionStatement */ ;
    };
    ExpressionStatementSyntax.prototype.childCount = function () {
        return 2;
    };
    ExpressionStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.expression;
            case 1:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ExpressionStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    ExpressionStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    ExpressionStatementSyntax.prototype.update = function (expression, semicolonToken) {
        if (this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new ExpressionStatementSyntax(expression, semicolonToken, this.parsedInStrictMode());
    };
    ExpressionStatementSyntax.create1 = function create1(expression) {
        return new ExpressionStatementSyntax(expression, Syntax.token(78 /* SemicolonToken */ ), false);
    };
    ExpressionStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ExpressionStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ExpressionStatementSyntax.prototype.withExpression = function (expression) {
        return this.update(expression, this.semicolonToken);
    };
    ExpressionStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.expression, semicolonToken);
    };
    ExpressionStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ExpressionStatementSyntax;
})(SyntaxNode);
var ConstructorDeclarationSyntax = (function (_super) {
    __extends(ConstructorDeclarationSyntax, _super);
    function ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.constructorKeyword = constructorKeyword;
        this.parameterList = parameterList;
        this.block = block;
        this.semicolonToken = semicolonToken;
    }
    ConstructorDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitConstructorDeclaration(this);
    };
    ConstructorDeclarationSyntax.prototype.kind = function () {
        return 135 /* ConstructorDeclaration */ ;
    };
    ConstructorDeclarationSyntax.prototype.childCount = function () {
        return 4;
    };
    ConstructorDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.constructorKeyword;
            case 1:
                return this.parameterList;
            case 2:
                return this.block;
            case 3:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ConstructorDeclarationSyntax.prototype.isClassElement = function () {
        return true;
    };
    ConstructorDeclarationSyntax.prototype.update = function (constructorKeyword, parameterList, block, semicolonToken) {
        if (this.constructorKeyword === constructorKeyword && this.parameterList === parameterList && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, this.parsedInStrictMode());
    };
    ConstructorDeclarationSyntax.create = function create(constructorKeyword, parameterList) {
        return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, null, null, false);
    };
    ConstructorDeclarationSyntax.create1 = function create1() {
        return new ConstructorDeclarationSyntax(Syntax.token(63 /* ConstructorKeyword */ ), ParameterListSyntax.create1(), null, null, false);
    };
    ConstructorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ConstructorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ConstructorDeclarationSyntax.prototype.withConstructorKeyword = function (constructorKeyword) {
        return this.update(constructorKeyword, this.parameterList, this.block, this.semicolonToken);
    };
    ConstructorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
        return this.update(this.constructorKeyword, parameterList, this.block, this.semicolonToken);
    };
    ConstructorDeclarationSyntax.prototype.withBlock = function (block) {
        return this.update(this.constructorKeyword, this.parameterList, block, this.semicolonToken);
    };
    ConstructorDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.constructorKeyword, this.parameterList, this.block, semicolonToken);
    };
    ConstructorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return ConstructorDeclarationSyntax;
})(SyntaxNode);
var MemberFunctionDeclarationSyntax = (function (_super) {
    __extends(MemberFunctionDeclarationSyntax, _super);
    function MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.publicOrPrivateKeyword = publicOrPrivateKeyword;
        this.staticKeyword = staticKeyword;
        this.functionSignature = functionSignature;
        this.block = block;
        this.semicolonToken = semicolonToken;
    }
    MemberFunctionDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitMemberFunctionDeclaration(this);
    };
    MemberFunctionDeclarationSyntax.prototype.kind = function () {
        return 133 /* MemberFunctionDeclaration */ ;
    };
    MemberFunctionDeclarationSyntax.prototype.childCount = function () {
        return 5;
    };
    MemberFunctionDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.publicOrPrivateKeyword;
            case 1:
                return this.staticKeyword;
            case 2:
                return this.functionSignature;
            case 3:
                return this.block;
            case 4:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    MemberFunctionDeclarationSyntax.prototype.isMemberDeclaration = function () {
        return true;
    };
    MemberFunctionDeclarationSyntax.prototype.isClassElement = function () {
        return true;
    };
    MemberFunctionDeclarationSyntax.prototype.update = function (publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken) {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.functionSignature === functionSignature && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken, this.parsedInStrictMode());
    };
    MemberFunctionDeclarationSyntax.create = function create(functionSignature) {
        return new MemberFunctionDeclarationSyntax(null, null, functionSignature, null, null, false);
    };
    MemberFunctionDeclarationSyntax.create1 = function create1(functionSignature) {
        return new MemberFunctionDeclarationSyntax(null, null, functionSignature, null, null, false);
    };
    MemberFunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    MemberFunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    MemberFunctionDeclarationSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.functionSignature, this.block, this.semicolonToken);
    };
    MemberFunctionDeclarationSyntax.prototype.withStaticKeyword = function (staticKeyword) {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.functionSignature, this.block, this.semicolonToken);
    };
    MemberFunctionDeclarationSyntax.prototype.withFunctionSignature = function (functionSignature) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, functionSignature, this.block, this.semicolonToken);
    };
    MemberFunctionDeclarationSyntax.prototype.withBlock = function (block) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.functionSignature, block, this.semicolonToken);
    };
    MemberFunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.functionSignature, this.block, semicolonToken);
    };
    MemberFunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return MemberFunctionDeclarationSyntax;
})(SyntaxNode);
var MemberAccessorDeclarationSyntax = (function (_super) {
    __extends(MemberAccessorDeclarationSyntax, _super);
    function MemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, identifier, parameterList, block, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.publicOrPrivateKeyword = publicOrPrivateKeyword;
        this.staticKeyword = staticKeyword;
        this.identifier = identifier;
        this.parameterList = parameterList;
        this.block = block;
    }
    MemberAccessorDeclarationSyntax.prototype.isMemberDeclaration = function () {
        return true;
    };
    MemberAccessorDeclarationSyntax.prototype.isClassElement = function () {
        return true;
    };
    MemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    MemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    MemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return MemberAccessorDeclarationSyntax;
})(SyntaxNode);
var GetMemberAccessorDeclarationSyntax = (function (_super) {
    __extends(GetMemberAccessorDeclarationSyntax, _super);
    function GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, parsedInStrictMode) {
        _super.call(this, publicOrPrivateKeyword, staticKeyword, identifier, parameterList, block, parsedInStrictMode);
        this.getKeyword = getKeyword;
        this.typeAnnotation = typeAnnotation;
    }
    GetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitGetMemberAccessorDeclaration(this);
    };
    GetMemberAccessorDeclarationSyntax.prototype.kind = function () {
        return 136 /* GetMemberAccessorDeclaration */ ;
    };
    GetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
        return 7;
    };
    GetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.publicOrPrivateKeyword;
            case 1:
                return this.staticKeyword;
            case 2:
                return this.getKeyword;
            case 3:
                return this.identifier;
            case 4:
                return this.parameterList;
            case 5:
                return this.typeAnnotation;
            case 6:
                return this.block;
            default:
                throw Errors.invalidOperation();
        }
    };
    GetMemberAccessorDeclarationSyntax.prototype.update = function (publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block) {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.getKeyword === getKeyword && this.identifier === identifier && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation && this.block === block) {
            return this;
        }
        return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, this.parsedInStrictMode());
    };
    GetMemberAccessorDeclarationSyntax.create = function create(getKeyword, identifier, parameterList, block) {
        return new GetMemberAccessorDeclarationSyntax(null, null, getKeyword, identifier, parameterList, null, block, false);
    };
    GetMemberAccessorDeclarationSyntax.create1 = function create1(identifier) {
        return new GetMemberAccessorDeclarationSyntax(null, null, Syntax.token(65 /* GetKeyword */ ), identifier, ParameterListSyntax.create1(), null, BlockSyntax.create1(), false);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withStaticKeyword = function (staticKeyword) {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withGetKeyword = function (getKeyword) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, identifier, this.parameterList, this.typeAnnotation, this.block);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, parameterList, this.typeAnnotation, this.block);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, typeAnnotation, this.block);
    };
    GetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, block);
    };
    GetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return GetMemberAccessorDeclarationSyntax;
})(MemberAccessorDeclarationSyntax);
var SetMemberAccessorDeclarationSyntax = (function (_super) {
    __extends(SetMemberAccessorDeclarationSyntax, _super);
    function SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, parsedInStrictMode) {
        _super.call(this, publicOrPrivateKeyword, staticKeyword, identifier, parameterList, block, parsedInStrictMode);
        this.setKeyword = setKeyword;
    }
    SetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitSetMemberAccessorDeclaration(this);
    };
    SetMemberAccessorDeclarationSyntax.prototype.kind = function () {
        return 137 /* SetMemberAccessorDeclaration */ ;
    };
    SetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
        return 6;
    };
    SetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.publicOrPrivateKeyword;
            case 1:
                return this.staticKeyword;
            case 2:
                return this.setKeyword;
            case 3:
                return this.identifier;
            case 4:
                return this.parameterList;
            case 5:
                return this.block;
            default:
                throw Errors.invalidOperation();
        }
    };
    SetMemberAccessorDeclarationSyntax.prototype.update = function (publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block) {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.setKeyword === setKeyword && this.identifier === identifier && this.parameterList === parameterList && this.block === block) {
            return this;
        }
        return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, this.parsedInStrictMode());
    };
    SetMemberAccessorDeclarationSyntax.create = function create(setKeyword, identifier, parameterList, block) {
        return new SetMemberAccessorDeclarationSyntax(null, null, setKeyword, identifier, parameterList, block, false);
    };
    SetMemberAccessorDeclarationSyntax.create1 = function create1(identifier) {
        return new SetMemberAccessorDeclarationSyntax(null, null, Syntax.token(68 /* SetKeyword */ ), identifier, ParameterListSyntax.create1(), BlockSyntax.create1(), false);
    };
    SetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    SetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    SetMemberAccessorDeclarationSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, this.parameterList, this.block);
    };
    SetMemberAccessorDeclarationSyntax.prototype.withStaticKeyword = function (staticKeyword) {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.setKeyword, this.identifier, this.parameterList, this.block);
    };
    SetMemberAccessorDeclarationSyntax.prototype.withSetKeyword = function (setKeyword) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, setKeyword, this.identifier, this.parameterList, this.block);
    };
    SetMemberAccessorDeclarationSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, identifier, this.parameterList, this.block);
    };
    SetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, parameterList, this.block);
    };
    SetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, this.parameterList, block);
    };
    SetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return SetMemberAccessorDeclarationSyntax;
})(MemberAccessorDeclarationSyntax);
var MemberVariableDeclarationSyntax = (function (_super) {
    __extends(MemberVariableDeclarationSyntax, _super);
    function MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.publicOrPrivateKeyword = publicOrPrivateKeyword;
        this.staticKeyword = staticKeyword;
        this.variableDeclarator = variableDeclarator;
        this.semicolonToken = semicolonToken;
    }
    MemberVariableDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitMemberVariableDeclaration(this);
    };
    MemberVariableDeclarationSyntax.prototype.kind = function () {
        return 134 /* MemberVariableDeclaration */ ;
    };
    MemberVariableDeclarationSyntax.prototype.childCount = function () {
        return 4;
    };
    MemberVariableDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.publicOrPrivateKeyword;
            case 1:
                return this.staticKeyword;
            case 2:
                return this.variableDeclarator;
            case 3:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    MemberVariableDeclarationSyntax.prototype.isMemberDeclaration = function () {
        return true;
    };
    MemberVariableDeclarationSyntax.prototype.isClassElement = function () {
        return true;
    };
    MemberVariableDeclarationSyntax.prototype.update = function (publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken) {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.variableDeclarator === variableDeclarator && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, this.parsedInStrictMode());
    };
    MemberVariableDeclarationSyntax.create = function create(variableDeclarator, semicolonToken) {
        return new MemberVariableDeclarationSyntax(null, null, variableDeclarator, semicolonToken, false);
    };
    MemberVariableDeclarationSyntax.create1 = function create1(variableDeclarator) {
        return new MemberVariableDeclarationSyntax(null, null, variableDeclarator, Syntax.token(78 /* SemicolonToken */ ), false);
    };
    MemberVariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    MemberVariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    MemberVariableDeclarationSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.variableDeclarator, this.semicolonToken);
    };
    MemberVariableDeclarationSyntax.prototype.withStaticKeyword = function (staticKeyword) {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.variableDeclarator, this.semicolonToken);
    };
    MemberVariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, variableDeclarator, this.semicolonToken);
    };
    MemberVariableDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.variableDeclarator, semicolonToken);
    };
    MemberVariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return MemberVariableDeclarationSyntax;
})(SyntaxNode);
var ThrowStatementSyntax = (function (_super) {
    __extends(ThrowStatementSyntax, _super);
    function ThrowStatementSyntax(throwKeyword, expression, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.throwKeyword = throwKeyword;
        this.expression = expression;
        this.semicolonToken = semicolonToken;
    }
    ThrowStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitThrowStatement(this);
    };
    ThrowStatementSyntax.prototype.kind = function () {
        return 154 /* ThrowStatement */ ;
    };
    ThrowStatementSyntax.prototype.childCount = function () {
        return 3;
    };
    ThrowStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.throwKeyword;
            case 1:
                return this.expression;
            case 2:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ThrowStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    ThrowStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    ThrowStatementSyntax.prototype.update = function (throwKeyword, expression, semicolonToken) {
        if (this.throwKeyword === throwKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, this.parsedInStrictMode());
    };
    ThrowStatementSyntax.create1 = function create1(expression) {
        return new ThrowStatementSyntax(Syntax.token(36 /* ThrowKeyword */ ), expression, Syntax.token(78 /* SemicolonToken */ ), false);
    };
    ThrowStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ThrowStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ThrowStatementSyntax.prototype.withThrowKeyword = function (throwKeyword) {
        return this.update(throwKeyword, this.expression, this.semicolonToken);
    };
    ThrowStatementSyntax.prototype.withExpression = function (expression) {
        return this.update(this.throwKeyword, expression, this.semicolonToken);
    };
    ThrowStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.throwKeyword, this.expression, semicolonToken);
    };
    ThrowStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ThrowStatementSyntax;
})(SyntaxNode);
var ReturnStatementSyntax = (function (_super) {
    __extends(ReturnStatementSyntax, _super);
    function ReturnStatementSyntax(returnKeyword, expression, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.returnKeyword = returnKeyword;
        this.expression = expression;
        this.semicolonToken = semicolonToken;
    }
    ReturnStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitReturnStatement(this);
    };
    ReturnStatementSyntax.prototype.kind = function () {
        return 147 /* ReturnStatement */ ;
    };
    ReturnStatementSyntax.prototype.childCount = function () {
        return 3;
    };
    ReturnStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.returnKeyword;
            case 1:
                return this.expression;
            case 2:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ReturnStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    ReturnStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    ReturnStatementSyntax.prototype.update = function (returnKeyword, expression, semicolonToken) {
        if (this.returnKeyword === returnKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, this.parsedInStrictMode());
    };
    ReturnStatementSyntax.create = function create(returnKeyword, semicolonToken) {
        return new ReturnStatementSyntax(returnKeyword, null, semicolonToken, false);
    };
    ReturnStatementSyntax.create1 = function create1() {
        return new ReturnStatementSyntax(Syntax.token(33 /* ReturnKeyword */ ), null, Syntax.token(78 /* SemicolonToken */ ), false);
    };
    ReturnStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ReturnStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ReturnStatementSyntax.prototype.withReturnKeyword = function (returnKeyword) {
        return this.update(returnKeyword, this.expression, this.semicolonToken);
    };
    ReturnStatementSyntax.prototype.withExpression = function (expression) {
        return this.update(this.returnKeyword, expression, this.semicolonToken);
    };
    ReturnStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.returnKeyword, this.expression, semicolonToken);
    };
    ReturnStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression !== null && this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ReturnStatementSyntax;
})(SyntaxNode);
var ObjectCreationExpressionSyntax = (function (_super) {
    __extends(ObjectCreationExpressionSyntax, _super);
    function ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.newKeyword = newKeyword;
        this.expression = expression;
        this.argumentList = argumentList;
    }
    ObjectCreationExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitObjectCreationExpression(this);
    };
    ObjectCreationExpressionSyntax.prototype.kind = function () {
        return 213 /* ObjectCreationExpression */ ;
    };
    ObjectCreationExpressionSyntax.prototype.childCount = function () {
        return 3;
    };
    ObjectCreationExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.newKeyword;
            case 1:
                return this.expression;
            case 2:
                return this.argumentList;
            default:
                throw Errors.invalidOperation();
        }
    };
    ObjectCreationExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ObjectCreationExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    ObjectCreationExpressionSyntax.prototype.update = function (newKeyword, expression, argumentList) {
        if (this.newKeyword === newKeyword && this.expression === expression && this.argumentList === argumentList) {
            return this;
        }
        return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, this.parsedInStrictMode());
    };
    ObjectCreationExpressionSyntax.create = function create(newKeyword, expression) {
        return new ObjectCreationExpressionSyntax(newKeyword, expression, null, false);
    };
    ObjectCreationExpressionSyntax.create1 = function create1(expression) {
        return new ObjectCreationExpressionSyntax(Syntax.token(31 /* NewKeyword */ ), expression, null, false);
    };
    ObjectCreationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ObjectCreationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ObjectCreationExpressionSyntax.prototype.withNewKeyword = function (newKeyword) {
        return this.update(newKeyword, this.expression, this.argumentList);
    };
    ObjectCreationExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(this.newKeyword, expression, this.argumentList);
    };
    ObjectCreationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
        return this.update(this.newKeyword, this.expression, argumentList);
    };
    ObjectCreationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        if (this.argumentList !== null && this.argumentList.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ObjectCreationExpressionSyntax;
})(SyntaxNode);
var SwitchStatementSyntax = (function (_super) {
    __extends(SwitchStatementSyntax, _super);
    function SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.switchKeyword = switchKeyword;
        this.openParenToken = openParenToken;
        this.expression = expression;
        this.closeParenToken = closeParenToken;
        this.openBraceToken = openBraceToken;
        this.switchClauses = switchClauses;
        this.closeBraceToken = closeBraceToken;
    }
    SwitchStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitSwitchStatement(this);
    };
    SwitchStatementSyntax.prototype.kind = function () {
        return 148 /* SwitchStatement */ ;
    };
    SwitchStatementSyntax.prototype.childCount = function () {
        return 7;
    };
    SwitchStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.switchKeyword;
            case 1:
                return this.openParenToken;
            case 2:
                return this.expression;
            case 3:
                return this.closeParenToken;
            case 4:
                return this.openBraceToken;
            case 5:
                return this.switchClauses;
            case 6:
                return this.closeBraceToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    SwitchStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    SwitchStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    SwitchStatementSyntax.prototype.update = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
        if (this.switchKeyword === switchKeyword && this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken && this.openBraceToken === openBraceToken && this.switchClauses === switchClauses && this.closeBraceToken === closeBraceToken) {
            return this;
        }
        return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, this.parsedInStrictMode());
    };
    SwitchStatementSyntax.create = function create(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, closeBraceToken) {
        return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, Syntax.emptyList, closeBraceToken, false);
    };
    SwitchStatementSyntax.create1 = function create1(expression) {
        return new SwitchStatementSyntax(Syntax.token(34 /* SwitchKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), expression, Syntax.token(73 /* CloseParenToken */ ), Syntax.token(70 /* OpenBraceToken */ ), Syntax.emptyList, Syntax.token(71 /* CloseBraceToken */ ), false);
    };
    SwitchStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    SwitchStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    SwitchStatementSyntax.prototype.withSwitchKeyword = function (switchKeyword) {
        return this.update(switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    };
    SwitchStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.switchKeyword, openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    };
    SwitchStatementSyntax.prototype.withExpression = function (expression) {
        return this.update(this.switchKeyword, this.openParenToken, expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    };
    SwitchStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    };
    SwitchStatementSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, openBraceToken, this.switchClauses, this.closeBraceToken);
    };
    SwitchStatementSyntax.prototype.withSwitchClauses = function (switchClauses) {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, switchClauses, this.closeBraceToken);
    };
    SwitchStatementSyntax.prototype.withSwitchClause = function (switchClause) {
        return this.withSwitchClauses(Syntax.list([
            switchClause
        ]));
    };
    SwitchStatementSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, closeBraceToken);
    };
    SwitchStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        if (this.switchClauses.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return SwitchStatementSyntax;
})(SyntaxNode);
var SwitchClauseSyntax = (function (_super) {
    __extends(SwitchClauseSyntax, _super);
    function SwitchClauseSyntax(colonToken, statements, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.colonToken = colonToken;
        this.statements = statements;
    }
    SwitchClauseSyntax.prototype.isSwitchClause = function () {
        return true;
    };
    SwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    SwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    SwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return SwitchClauseSyntax;
})(SyntaxNode);
var CaseSwitchClauseSyntax = (function (_super) {
    __extends(CaseSwitchClauseSyntax, _super);
    function CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, parsedInStrictMode) {
        _super.call(this, colonToken, statements, parsedInStrictMode);
        this.caseKeyword = caseKeyword;
        this.expression = expression;
    }
    CaseSwitchClauseSyntax.prototype.accept = function (visitor) {
        return visitor.visitCaseSwitchClause(this);
    };
    CaseSwitchClauseSyntax.prototype.kind = function () {
        return 230 /* CaseSwitchClause */ ;
    };
    CaseSwitchClauseSyntax.prototype.childCount = function () {
        return 4;
    };
    CaseSwitchClauseSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.caseKeyword;
            case 1:
                return this.expression;
            case 2:
                return this.colonToken;
            case 3:
                return this.statements;
            default:
                throw Errors.invalidOperation();
        }
    };
    CaseSwitchClauseSyntax.prototype.update = function (caseKeyword, expression, colonToken, statements) {
        if (this.caseKeyword === caseKeyword && this.expression === expression && this.colonToken === colonToken && this.statements === statements) {
            return this;
        }
        return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, this.parsedInStrictMode());
    };
    CaseSwitchClauseSyntax.create = function create(caseKeyword, expression, colonToken) {
        return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, Syntax.emptyList, false);
    };
    CaseSwitchClauseSyntax.create1 = function create1(expression) {
        return new CaseSwitchClauseSyntax(Syntax.token(16 /* CaseKeyword */ ), expression, Syntax.token(106 /* ColonToken */ ), Syntax.emptyList, false);
    };
    CaseSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    CaseSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    CaseSwitchClauseSyntax.prototype.withCaseKeyword = function (caseKeyword) {
        return this.update(caseKeyword, this.expression, this.colonToken, this.statements);
    };
    CaseSwitchClauseSyntax.prototype.withExpression = function (expression) {
        return this.update(this.caseKeyword, expression, this.colonToken, this.statements);
    };
    CaseSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
        return this.update(this.caseKeyword, this.expression, colonToken, this.statements);
    };
    CaseSwitchClauseSyntax.prototype.withStatements = function (statements) {
        return this.update(this.caseKeyword, this.expression, this.colonToken, statements);
    };
    CaseSwitchClauseSyntax.prototype.withStatement = function (statement) {
        return this.withStatements(Syntax.list([
            statement
        ]));
    };
    CaseSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        if (this.statements.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return CaseSwitchClauseSyntax;
})(SwitchClauseSyntax);
var DefaultSwitchClauseSyntax = (function (_super) {
    __extends(DefaultSwitchClauseSyntax, _super);
    function DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, parsedInStrictMode) {
        _super.call(this, colonToken, statements, parsedInStrictMode);
        this.defaultKeyword = defaultKeyword;
    }
    DefaultSwitchClauseSyntax.prototype.accept = function (visitor) {
        return visitor.visitDefaultSwitchClause(this);
    };
    DefaultSwitchClauseSyntax.prototype.kind = function () {
        return 231 /* DefaultSwitchClause */ ;
    };
    DefaultSwitchClauseSyntax.prototype.childCount = function () {
        return 3;
    };
    DefaultSwitchClauseSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.defaultKeyword;
            case 1:
                return this.colonToken;
            case 2:
                return this.statements;
            default:
                throw Errors.invalidOperation();
        }
    };
    DefaultSwitchClauseSyntax.prototype.update = function (defaultKeyword, colonToken, statements) {
        if (this.defaultKeyword === defaultKeyword && this.colonToken === colonToken && this.statements === statements) {
            return this;
        }
        return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, this.parsedInStrictMode());
    };
    DefaultSwitchClauseSyntax.create = function create(defaultKeyword, colonToken) {
        return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, Syntax.emptyList, false);
    };
    DefaultSwitchClauseSyntax.create1 = function create1() {
        return new DefaultSwitchClauseSyntax(Syntax.token(20 /* DefaultKeyword */ ), Syntax.token(106 /* ColonToken */ ), Syntax.emptyList, false);
    };
    DefaultSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    DefaultSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    DefaultSwitchClauseSyntax.prototype.withDefaultKeyword = function (defaultKeyword) {
        return this.update(defaultKeyword, this.colonToken, this.statements);
    };
    DefaultSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
        return this.update(this.defaultKeyword, colonToken, this.statements);
    };
    DefaultSwitchClauseSyntax.prototype.withStatements = function (statements) {
        return this.update(this.defaultKeyword, this.colonToken, statements);
    };
    DefaultSwitchClauseSyntax.prototype.withStatement = function (statement) {
        return this.withStatements(Syntax.list([
            statement
        ]));
    };
    DefaultSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.statements.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return DefaultSwitchClauseSyntax;
})(SwitchClauseSyntax);
var BreakStatementSyntax = (function (_super) {
    __extends(BreakStatementSyntax, _super);
    function BreakStatementSyntax(breakKeyword, identifier, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.breakKeyword = breakKeyword;
        this.identifier = identifier;
        this.semicolonToken = semicolonToken;
    }
    BreakStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitBreakStatement(this);
    };
    BreakStatementSyntax.prototype.kind = function () {
        return 149 /* BreakStatement */ ;
    };
    BreakStatementSyntax.prototype.childCount = function () {
        return 3;
    };
    BreakStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.breakKeyword;
            case 1:
                return this.identifier;
            case 2:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    BreakStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    BreakStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    BreakStatementSyntax.prototype.update = function (breakKeyword, identifier, semicolonToken) {
        if (this.breakKeyword === breakKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, this.parsedInStrictMode());
    };
    BreakStatementSyntax.create = function create(breakKeyword, semicolonToken) {
        return new BreakStatementSyntax(breakKeyword, null, semicolonToken, false);
    };
    BreakStatementSyntax.create1 = function create1() {
        return new BreakStatementSyntax(Syntax.token(15 /* BreakKeyword */ ), null, Syntax.token(78 /* SemicolonToken */ ), false);
    };
    BreakStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    BreakStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    BreakStatementSyntax.prototype.withBreakKeyword = function (breakKeyword) {
        return this.update(breakKeyword, this.identifier, this.semicolonToken);
    };
    BreakStatementSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.breakKeyword, identifier, this.semicolonToken);
    };
    BreakStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.breakKeyword, this.identifier, semicolonToken);
    };
    BreakStatementSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return BreakStatementSyntax;
})(SyntaxNode);
var ContinueStatementSyntax = (function (_super) {
    __extends(ContinueStatementSyntax, _super);
    function ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.continueKeyword = continueKeyword;
        this.identifier = identifier;
        this.semicolonToken = semicolonToken;
    }
    ContinueStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitContinueStatement(this);
    };
    ContinueStatementSyntax.prototype.kind = function () {
        return 150 /* ContinueStatement */ ;
    };
    ContinueStatementSyntax.prototype.childCount = function () {
        return 3;
    };
    ContinueStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.continueKeyword;
            case 1:
                return this.identifier;
            case 2:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ContinueStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    ContinueStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    ContinueStatementSyntax.prototype.update = function (continueKeyword, identifier, semicolonToken) {
        if (this.continueKeyword === continueKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, this.parsedInStrictMode());
    };
    ContinueStatementSyntax.create = function create(continueKeyword, semicolonToken) {
        return new ContinueStatementSyntax(continueKeyword, null, semicolonToken, false);
    };
    ContinueStatementSyntax.create1 = function create1() {
        return new ContinueStatementSyntax(Syntax.token(18 /* ContinueKeyword */ ), null, Syntax.token(78 /* SemicolonToken */ ), false);
    };
    ContinueStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ContinueStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ContinueStatementSyntax.prototype.withContinueKeyword = function (continueKeyword) {
        return this.update(continueKeyword, this.identifier, this.semicolonToken);
    };
    ContinueStatementSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.continueKeyword, identifier, this.semicolonToken);
    };
    ContinueStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.continueKeyword, this.identifier, semicolonToken);
    };
    ContinueStatementSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return ContinueStatementSyntax;
})(SyntaxNode);
var IterationStatementSyntax = (function (_super) {
    __extends(IterationStatementSyntax, _super);
    function IterationStatementSyntax(openParenToken, closeParenToken, statement, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.openParenToken = openParenToken;
        this.closeParenToken = closeParenToken;
        this.statement = statement;
    }
    IterationStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    IterationStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    IterationStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    IterationStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    IterationStatementSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return IterationStatementSyntax;
})(SyntaxNode);
var BaseForStatementSyntax = (function (_super) {
    __extends(BaseForStatementSyntax, _super);
    function BaseForStatementSyntax(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode) {
        _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
        this.forKeyword = forKeyword;
        this.variableDeclaration = variableDeclaration;
    }
    BaseForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    BaseForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    BaseForStatementSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return BaseForStatementSyntax;
})(IterationStatementSyntax);
var ForStatementSyntax = (function (_super) {
    __extends(ForStatementSyntax, _super);
    function ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, parsedInStrictMode) {
        _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
        this.initializer = initializer;
        this.firstSemicolonToken = firstSemicolonToken;
        this.condition = condition;
        this.secondSemicolonToken = secondSemicolonToken;
        this.incrementor = incrementor;
    }
    ForStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitForStatement(this);
    };
    ForStatementSyntax.prototype.kind = function () {
        return 151 /* ForStatement */ ;
    };
    ForStatementSyntax.prototype.childCount = function () {
        return 10;
    };
    ForStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.forKeyword;
            case 1:
                return this.openParenToken;
            case 2:
                return this.variableDeclaration;
            case 3:
                return this.initializer;
            case 4:
                return this.firstSemicolonToken;
            case 5:
                return this.condition;
            case 6:
                return this.secondSemicolonToken;
            case 7:
                return this.incrementor;
            case 8:
                return this.closeParenToken;
            case 9:
                return this.statement;
            default:
                throw Errors.invalidOperation();
        }
    };
    ForStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
        if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.initializer === initializer && this.firstSemicolonToken === firstSemicolonToken && this.condition === condition && this.secondSemicolonToken === secondSemicolonToken && this.incrementor === incrementor && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }
        return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, this.parsedInStrictMode());
    };
    ForStatementSyntax.create = function create(forKeyword, openParenToken, firstSemicolonToken, secondSemicolonToken, closeParenToken, statement) {
        return new ForStatementSyntax(forKeyword, openParenToken, null, null, firstSemicolonToken, null, secondSemicolonToken, null, closeParenToken, statement, false);
    };
    ForStatementSyntax.create1 = function create1(statement) {
        return new ForStatementSyntax(Syntax.token(26 /* ForKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), null, null, Syntax.token(78 /* SemicolonToken */ ), null, Syntax.token(78 /* SemicolonToken */ ), null, Syntax.token(73 /* CloseParenToken */ ), statement, false);
    };
    ForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ForStatementSyntax.prototype.withForKeyword = function (forKeyword) {
        return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
        return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withInitializer = function (initializer) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withFirstSemicolonToken = function (firstSemicolonToken) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withCondition = function (condition) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withSecondSemicolonToken = function (secondSemicolonToken) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withIncrementor = function (incrementor) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, incrementor, this.closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, closeParenToken, this.statement);
    };
    ForStatementSyntax.prototype.withStatement = function (statement) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, statement);
    };
    ForStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
            return true;
        }
        if (this.initializer !== null && this.initializer.isTypeScriptSpecific()) {
            return true;
        }
        if (this.condition !== null && this.condition.isTypeScriptSpecific()) {
            return true;
        }
        if (this.incrementor !== null && this.incrementor.isTypeScriptSpecific()) {
            return true;
        }
        if (this.statement.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ForStatementSyntax;
})(BaseForStatementSyntax);
var ForInStatementSyntax = (function (_super) {
    __extends(ForInStatementSyntax, _super);
    function ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, parsedInStrictMode) {
        _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
        this.left = left;
        this.inKeyword = inKeyword;
        this.expression = expression;
    }
    ForInStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitForInStatement(this);
    };
    ForInStatementSyntax.prototype.kind = function () {
        return 152 /* ForInStatement */ ;
    };
    ForInStatementSyntax.prototype.childCount = function () {
        return 8;
    };
    ForInStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.forKeyword;
            case 1:
                return this.openParenToken;
            case 2:
                return this.variableDeclaration;
            case 3:
                return this.left;
            case 4:
                return this.inKeyword;
            case 5:
                return this.expression;
            case 6:
                return this.closeParenToken;
            case 7:
                return this.statement;
            default:
                throw Errors.invalidOperation();
        }
    };
    ForInStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
        if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.left === left && this.inKeyword === inKeyword && this.expression === expression && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }
        return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, this.parsedInStrictMode());
    };
    ForInStatementSyntax.create = function create(forKeyword, openParenToken, inKeyword, expression, closeParenToken, statement) {
        return new ForInStatementSyntax(forKeyword, openParenToken, null, null, inKeyword, expression, closeParenToken, statement, false);
    };
    ForInStatementSyntax.create1 = function create1(expression, statement) {
        return new ForInStatementSyntax(Syntax.token(26 /* ForKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), null, null, Syntax.token(29 /* InKeyword */ ), expression, Syntax.token(73 /* CloseParenToken */ ), statement, false);
    };
    ForInStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ForInStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ForInStatementSyntax.prototype.withForKeyword = function (forKeyword) {
        return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    };
    ForInStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    };
    ForInStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
        return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    };
    ForInStatementSyntax.prototype.withLeft = function (left) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    };
    ForInStatementSyntax.prototype.withInKeyword = function (inKeyword) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, inKeyword, this.expression, this.closeParenToken, this.statement);
    };
    ForInStatementSyntax.prototype.withExpression = function (expression) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, expression, this.closeParenToken, this.statement);
    };
    ForInStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, closeParenToken, this.statement);
    };
    ForInStatementSyntax.prototype.withStatement = function (statement) {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, statement);
    };
    ForInStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
            return true;
        }
        if (this.left !== null && this.left.isTypeScriptSpecific()) {
            return true;
        }
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        if (this.statement.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ForInStatementSyntax;
})(BaseForStatementSyntax);
var WhileStatementSyntax = (function (_super) {
    __extends(WhileStatementSyntax, _super);
    function WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
        _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
        this.whileKeyword = whileKeyword;
        this.condition = condition;
    }
    WhileStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitWhileStatement(this);
    };
    WhileStatementSyntax.prototype.kind = function () {
        return 155 /* WhileStatement */ ;
    };
    WhileStatementSyntax.prototype.childCount = function () {
        return 5;
    };
    WhileStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.whileKeyword;
            case 1:
                return this.openParenToken;
            case 2:
                return this.condition;
            case 3:
                return this.closeParenToken;
            case 4:
                return this.statement;
            default:
                throw Errors.invalidOperation();
        }
    };
    WhileStatementSyntax.prototype.update = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
        if (this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }
        return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
    };
    WhileStatementSyntax.create1 = function create1(condition, statement) {
        return new WhileStatementSyntax(Syntax.token(42 /* WhileKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), condition, Syntax.token(73 /* CloseParenToken */ ), statement, false);
    };
    WhileStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    WhileStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    WhileStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
        return this.update(whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
    };
    WhileStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
    };
    WhileStatementSyntax.prototype.withCondition = function (condition) {
        return this.update(this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
    };
    WhileStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
    };
    WhileStatementSyntax.prototype.withStatement = function (statement) {
        return this.update(this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
    };
    WhileStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.condition.isTypeScriptSpecific()) {
            return true;
        }
        if (this.statement.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return WhileStatementSyntax;
})(IterationStatementSyntax);
var WithStatementSyntax = (function (_super) {
    __extends(WithStatementSyntax, _super);
    function WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.withKeyword = withKeyword;
        this.openParenToken = openParenToken;
        this.condition = condition;
        this.closeParenToken = closeParenToken;
        this.statement = statement;
    }
    WithStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitWithStatement(this);
    };
    WithStatementSyntax.prototype.kind = function () {
        return 160 /* WithStatement */ ;
    };
    WithStatementSyntax.prototype.childCount = function () {
        return 5;
    };
    WithStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.withKeyword;
            case 1:
                return this.openParenToken;
            case 2:
                return this.condition;
            case 3:
                return this.closeParenToken;
            case 4:
                return this.statement;
            default:
                throw Errors.invalidOperation();
        }
    };
    WithStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    WithStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    WithStatementSyntax.prototype.update = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
        if (this.withKeyword === withKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }
        return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
    };
    WithStatementSyntax.create1 = function create1(condition, statement) {
        return new WithStatementSyntax(Syntax.token(43 /* WithKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), condition, Syntax.token(73 /* CloseParenToken */ ), statement, false);
    };
    WithStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    WithStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    WithStatementSyntax.prototype.withWithKeyword = function (withKeyword) {
        return this.update(withKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
    };
    WithStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.withKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
    };
    WithStatementSyntax.prototype.withCondition = function (condition) {
        return this.update(this.withKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
    };
    WithStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.withKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
    };
    WithStatementSyntax.prototype.withStatement = function (statement) {
        return this.update(this.withKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
    };
    WithStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.condition.isTypeScriptSpecific()) {
            return true;
        }
        if (this.statement.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return WithStatementSyntax;
})(SyntaxNode);
var EnumDeclarationSyntax = (function (_super) {
    __extends(EnumDeclarationSyntax, _super);
    function EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.exportKeyword = exportKeyword;
        this.enumKeyword = enumKeyword;
        this.identifier = identifier;
        this.openBraceToken = openBraceToken;
        this.variableDeclarators = variableDeclarators;
        this.closeBraceToken = closeBraceToken;
    }
    EnumDeclarationSyntax.prototype.accept = function (visitor) {
        return visitor.visitEnumDeclaration(this);
    };
    EnumDeclarationSyntax.prototype.kind = function () {
        return 131 /* EnumDeclaration */ ;
    };
    EnumDeclarationSyntax.prototype.childCount = function () {
        return 6;
    };
    EnumDeclarationSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.exportKeyword;
            case 1:
                return this.enumKeyword;
            case 2:
                return this.identifier;
            case 3:
                return this.openBraceToken;
            case 4:
                return this.variableDeclarators;
            case 5:
                return this.closeBraceToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    EnumDeclarationSyntax.prototype.isModuleElement = function () {
        return true;
    };
    EnumDeclarationSyntax.prototype.update = function (exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken) {
        if (this.exportKeyword === exportKeyword && this.enumKeyword === enumKeyword && this.identifier === identifier && this.openBraceToken === openBraceToken && this.variableDeclarators === variableDeclarators && this.closeBraceToken === closeBraceToken) {
            return this;
        }
        return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken, this.parsedInStrictMode());
    };
    EnumDeclarationSyntax.create = function create(enumKeyword, identifier, openBraceToken, closeBraceToken) {
        return new EnumDeclarationSyntax(null, enumKeyword, identifier, openBraceToken, Syntax.emptySeparatedList, closeBraceToken, false);
    };
    EnumDeclarationSyntax.create1 = function create1(identifier) {
        return new EnumDeclarationSyntax(null, Syntax.token(46 /* EnumKeyword */ ), identifier, Syntax.token(70 /* OpenBraceToken */ ), Syntax.emptySeparatedList, Syntax.token(71 /* CloseBraceToken */ ), false);
    };
    EnumDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    EnumDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    EnumDeclarationSyntax.prototype.withExportKeyword = function (exportKeyword) {
        return this.update(exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, this.variableDeclarators, this.closeBraceToken);
    };
    EnumDeclarationSyntax.prototype.withEnumKeyword = function (enumKeyword) {
        return this.update(this.exportKeyword, enumKeyword, this.identifier, this.openBraceToken, this.variableDeclarators, this.closeBraceToken);
    };
    EnumDeclarationSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.exportKeyword, this.enumKeyword, identifier, this.openBraceToken, this.variableDeclarators, this.closeBraceToken);
    };
    EnumDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, openBraceToken, this.variableDeclarators, this.closeBraceToken);
    };
    EnumDeclarationSyntax.prototype.withVariableDeclarators = function (variableDeclarators) {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, variableDeclarators, this.closeBraceToken);
    };
    EnumDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
        return this.withVariableDeclarators(Syntax.separatedList([
            variableDeclarator
        ]));
    };
    EnumDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, this.variableDeclarators, closeBraceToken);
    };
    EnumDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return EnumDeclarationSyntax;
})(SyntaxNode);
var CastExpressionSyntax = (function (_super) {
    __extends(CastExpressionSyntax, _super);
    function CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.lessThanToken = lessThanToken;
        this.type = type;
        this.greaterThanToken = greaterThanToken;
        this.expression = expression;
    }
    CastExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitCastExpression(this);
    };
    CastExpressionSyntax.prototype.kind = function () {
        return 217 /* CastExpression */ ;
    };
    CastExpressionSyntax.prototype.childCount = function () {
        return 4;
    };
    CastExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.lessThanToken;
            case 1:
                return this.type;
            case 2:
                return this.greaterThanToken;
            case 3:
                return this.expression;
            default:
                throw Errors.invalidOperation();
        }
    };
    CastExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    CastExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    CastExpressionSyntax.prototype.update = function (lessThanToken, type, greaterThanToken, expression) {
        if (this.lessThanToken === lessThanToken && this.type === type && this.greaterThanToken === greaterThanToken && this.expression === expression) {
            return this;
        }
        return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, this.parsedInStrictMode());
    };
    CastExpressionSyntax.create1 = function create1(type, expression) {
        return new CastExpressionSyntax(Syntax.token(80 /* LessThanToken */ ), type, Syntax.token(81 /* GreaterThanToken */ ), expression, false);
    };
    CastExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    CastExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    CastExpressionSyntax.prototype.withLessThanToken = function (lessThanToken) {
        return this.update(lessThanToken, this.type, this.greaterThanToken, this.expression);
    };
    CastExpressionSyntax.prototype.withType = function (type) {
        return this.update(this.lessThanToken, type, this.greaterThanToken, this.expression);
    };
    CastExpressionSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
        return this.update(this.lessThanToken, this.type, greaterThanToken, this.expression);
    };
    CastExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(this.lessThanToken, this.type, this.greaterThanToken, expression);
    };
    CastExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        return true;
    };
    return CastExpressionSyntax;
})(SyntaxNode);
var ObjectLiteralExpressionSyntax = (function (_super) {
    __extends(ObjectLiteralExpressionSyntax, _super);
    function ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.openBraceToken = openBraceToken;
        this.propertyAssignments = propertyAssignments;
        this.closeBraceToken = closeBraceToken;
    }
    ObjectLiteralExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitObjectLiteralExpression(this);
    };
    ObjectLiteralExpressionSyntax.prototype.kind = function () {
        return 212 /* ObjectLiteralExpression */ ;
    };
    ObjectLiteralExpressionSyntax.prototype.childCount = function () {
        return 3;
    };
    ObjectLiteralExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.openBraceToken;
            case 1:
                return this.propertyAssignments;
            case 2:
                return this.closeBraceToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    ObjectLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    ObjectLiteralExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    ObjectLiteralExpressionSyntax.prototype.update = function (openBraceToken, propertyAssignments, closeBraceToken) {
        if (this.openBraceToken === openBraceToken && this.propertyAssignments === propertyAssignments && this.closeBraceToken === closeBraceToken) {
            return this;
        }
        return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, this.parsedInStrictMode());
    };
    ObjectLiteralExpressionSyntax.create = function create(openBraceToken, closeBraceToken) {
        return new ObjectLiteralExpressionSyntax(openBraceToken, Syntax.emptySeparatedList, closeBraceToken, false);
    };
    ObjectLiteralExpressionSyntax.create1 = function create1() {
        return new ObjectLiteralExpressionSyntax(Syntax.token(70 /* OpenBraceToken */ ), Syntax.emptySeparatedList, Syntax.token(71 /* CloseBraceToken */ ), false);
    };
    ObjectLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    ObjectLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    ObjectLiteralExpressionSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
        return this.update(openBraceToken, this.propertyAssignments, this.closeBraceToken);
    };
    ObjectLiteralExpressionSyntax.prototype.withPropertyAssignments = function (propertyAssignments) {
        return this.update(this.openBraceToken, propertyAssignments, this.closeBraceToken);
    };
    ObjectLiteralExpressionSyntax.prototype.withPropertyAssignment = function (propertyAssignment) {
        return this.withPropertyAssignments(Syntax.separatedList([
            propertyAssignment
        ]));
    };
    ObjectLiteralExpressionSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
        return this.update(this.openBraceToken, this.propertyAssignments, closeBraceToken);
    };
    ObjectLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.propertyAssignments.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return ObjectLiteralExpressionSyntax;
})(SyntaxNode);
var PropertyAssignmentSyntax = (function (_super) {
    __extends(PropertyAssignmentSyntax, _super);
    function PropertyAssignmentSyntax(propertyName, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.propertyName = propertyName;
    }
    PropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    PropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    PropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return PropertyAssignmentSyntax;
})(SyntaxNode);
var SimplePropertyAssignmentSyntax = (function (_super) {
    __extends(SimplePropertyAssignmentSyntax, _super);
    function SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, parsedInStrictMode) {
        _super.call(this, propertyName, parsedInStrictMode);
        this.colonToken = colonToken;
        this.expression = expression;
    }
    SimplePropertyAssignmentSyntax.prototype.accept = function (visitor) {
        return visitor.visitSimplePropertyAssignment(this);
    };
    SimplePropertyAssignmentSyntax.prototype.kind = function () {
        return 239 /* SimplePropertyAssignment */ ;
    };
    SimplePropertyAssignmentSyntax.prototype.childCount = function () {
        return 3;
    };
    SimplePropertyAssignmentSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.propertyName;
            case 1:
                return this.colonToken;
            case 2:
                return this.expression;
            default:
                throw Errors.invalidOperation();
        }
    };
    SimplePropertyAssignmentSyntax.prototype.update = function (propertyName, colonToken, expression) {
        if (this.propertyName === propertyName && this.colonToken === colonToken && this.expression === expression) {
            return this;
        }
        return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, this.parsedInStrictMode());
    };
    SimplePropertyAssignmentSyntax.create1 = function create1(propertyName, expression) {
        return new SimplePropertyAssignmentSyntax(propertyName, Syntax.token(106 /* ColonToken */ ), expression, false);
    };
    SimplePropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    SimplePropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    SimplePropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
        return this.update(propertyName, this.colonToken, this.expression);
    };
    SimplePropertyAssignmentSyntax.prototype.withColonToken = function (colonToken) {
        return this.update(this.propertyName, colonToken, this.expression);
    };
    SimplePropertyAssignmentSyntax.prototype.withExpression = function (expression) {
        return this.update(this.propertyName, this.colonToken, expression);
    };
    SimplePropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return SimplePropertyAssignmentSyntax;
})(PropertyAssignmentSyntax);
var AccessorPropertyAssignmentSyntax = (function (_super) {
    __extends(AccessorPropertyAssignmentSyntax, _super);
    function AccessorPropertyAssignmentSyntax(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode) {
        _super.call(this, propertyName, parsedInStrictMode);
        this.openParenToken = openParenToken;
        this.closeParenToken = closeParenToken;
        this.block = block;
    }
    AccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    AccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    AccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return AccessorPropertyAssignmentSyntax;
})(PropertyAssignmentSyntax);
var GetAccessorPropertyAssignmentSyntax = (function (_super) {
    __extends(GetAccessorPropertyAssignmentSyntax, _super);
    function GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode) {
        _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
        this.getKeyword = getKeyword;
    }
    GetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
        return visitor.visitGetAccessorPropertyAssignment(this);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
        return 242 /* GetAccessorPropertyAssignment */ ;
    };
    GetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
        return 5;
    };
    GetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.getKeyword;
            case 1:
                return this.propertyName;
            case 2:
                return this.openParenToken;
            case 3:
                return this.closeParenToken;
            case 4:
                return this.block;
            default:
                throw Errors.invalidOperation();
        }
    };
    GetAccessorPropertyAssignmentSyntax.prototype.update = function (getKeyword, propertyName, openParenToken, closeParenToken, block) {
        if (this.getKeyword === getKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.closeParenToken === closeParenToken && this.block === block) {
            return this;
        }
        return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, block, this.parsedInStrictMode());
    };
    GetAccessorPropertyAssignmentSyntax.create1 = function create1(propertyName) {
        return new GetAccessorPropertyAssignmentSyntax(Syntax.token(65 /* GetKeyword */ ), propertyName, Syntax.token(72 /* OpenParenToken */ ), Syntax.token(73 /* CloseParenToken */ ), BlockSyntax.create1(), false);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.withGetKeyword = function (getKeyword) {
        return this.update(getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.block);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
        return this.update(this.getKeyword, propertyName, this.openParenToken, this.closeParenToken, this.block);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.getKeyword, this.propertyName, openParenToken, this.closeParenToken, this.block);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.getKeyword, this.propertyName, this.openParenToken, closeParenToken, this.block);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
        return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, block);
    };
    GetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.block.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return GetAccessorPropertyAssignmentSyntax;
})(AccessorPropertyAssignmentSyntax);
var SetAccessorPropertyAssignmentSyntax = (function (_super) {
    __extends(SetAccessorPropertyAssignmentSyntax, _super);
    function SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block, parsedInStrictMode) {
        _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
        this.setKeyword = setKeyword;
        this.parameterName = parameterName;
    }
    SetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
        return visitor.visitSetAccessorPropertyAssignment(this);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
        return 243 /* SetAccessorPropertyAssignment */ ;
    };
    SetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
        return 6;
    };
    SetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.setKeyword;
            case 1:
                return this.propertyName;
            case 2:
                return this.openParenToken;
            case 3:
                return this.parameterName;
            case 4:
                return this.closeParenToken;
            case 5:
                return this.block;
            default:
                throw Errors.invalidOperation();
        }
    };
    SetAccessorPropertyAssignmentSyntax.prototype.update = function (setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block) {
        if (this.setKeyword === setKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.parameterName === parameterName && this.closeParenToken === closeParenToken && this.block === block) {
            return this;
        }
        return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block, this.parsedInStrictMode());
    };
    SetAccessorPropertyAssignmentSyntax.create1 = function create1(propertyName, parameterName) {
        return new SetAccessorPropertyAssignmentSyntax(Syntax.token(68 /* SetKeyword */ ), propertyName, Syntax.token(72 /* OpenParenToken */ ), parameterName, Syntax.token(73 /* CloseParenToken */ ), BlockSyntax.create1(), false);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.withSetKeyword = function (setKeyword) {
        return this.update(setKeyword, this.propertyName, this.openParenToken, this.parameterName, this.closeParenToken, this.block);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
        return this.update(this.setKeyword, propertyName, this.openParenToken, this.parameterName, this.closeParenToken, this.block);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.setKeyword, this.propertyName, openParenToken, this.parameterName, this.closeParenToken, this.block);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.withParameterName = function (parameterName) {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, parameterName, this.closeParenToken, this.block);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameterName, closeParenToken, this.block);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameterName, this.closeParenToken, block);
    };
    SetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.block.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return SetAccessorPropertyAssignmentSyntax;
})(AccessorPropertyAssignmentSyntax);
var FunctionExpressionSyntax = (function (_super) {
    __extends(FunctionExpressionSyntax, _super);
    function FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.functionKeyword = functionKeyword;
        this.identifier = identifier;
        this.callSignature = callSignature;
        this.block = block;
    }
    FunctionExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitFunctionExpression(this);
    };
    FunctionExpressionSyntax.prototype.kind = function () {
        return 219 /* FunctionExpression */ ;
    };
    FunctionExpressionSyntax.prototype.childCount = function () {
        return 4;
    };
    FunctionExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.functionKeyword;
            case 1:
                return this.identifier;
            case 2:
                return this.callSignature;
            case 3:
                return this.block;
            default:
                throw Errors.invalidOperation();
        }
    };
    FunctionExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    FunctionExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    FunctionExpressionSyntax.prototype.update = function (functionKeyword, identifier, callSignature, block) {
        if (this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block) {
            return this;
        }
        return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, this.parsedInStrictMode());
    };
    FunctionExpressionSyntax.create = function create(functionKeyword, callSignature, block) {
        return new FunctionExpressionSyntax(functionKeyword, null, callSignature, block, false);
    };
    FunctionExpressionSyntax.create1 = function create1() {
        return new FunctionExpressionSyntax(Syntax.token(27 /* FunctionKeyword */ ), null, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
    };
    FunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    FunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    FunctionExpressionSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
        return this.update(functionKeyword, this.identifier, this.callSignature, this.block);
    };
    FunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.functionKeyword, identifier, this.callSignature, this.block);
    };
    FunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
        return this.update(this.functionKeyword, this.identifier, callSignature, this.block);
    };
    FunctionExpressionSyntax.prototype.withBlock = function (block) {
        return this.update(this.functionKeyword, this.identifier, this.callSignature, block);
    };
    FunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.callSignature.isTypeScriptSpecific()) {
            return true;
        }
        if (this.block.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return FunctionExpressionSyntax;
})(SyntaxNode);
var EmptyStatementSyntax = (function (_super) {
    __extends(EmptyStatementSyntax, _super);
    function EmptyStatementSyntax(semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.semicolonToken = semicolonToken;
    }
    EmptyStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitEmptyStatement(this);
    };
    EmptyStatementSyntax.prototype.kind = function () {
        return 153 /* EmptyStatement */ ;
    };
    EmptyStatementSyntax.prototype.childCount = function () {
        return 1;
    };
    EmptyStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    EmptyStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    EmptyStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    EmptyStatementSyntax.prototype.update = function (semicolonToken) {
        if (this.semicolonToken === semicolonToken) {
            return this;
        }
        return new EmptyStatementSyntax(semicolonToken, this.parsedInStrictMode());
    };
    EmptyStatementSyntax.create1 = function create1() {
        return new EmptyStatementSyntax(Syntax.token(78 /* SemicolonToken */ ), false);
    };
    EmptyStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    EmptyStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    EmptyStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(semicolonToken);
    };
    EmptyStatementSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return EmptyStatementSyntax;
})(SyntaxNode);
var TryStatementSyntax = (function (_super) {
    __extends(TryStatementSyntax, _super);
    function TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.tryKeyword = tryKeyword;
        this.block = block;
        this.catchClause = catchClause;
        this.finallyClause = finallyClause;
    }
    TryStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitTryStatement(this);
    };
    TryStatementSyntax.prototype.kind = function () {
        return 156 /* TryStatement */ ;
    };
    TryStatementSyntax.prototype.childCount = function () {
        return 4;
    };
    TryStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.tryKeyword;
            case 1:
                return this.block;
            case 2:
                return this.catchClause;
            case 3:
                return this.finallyClause;
            default:
                throw Errors.invalidOperation();
        }
    };
    TryStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    TryStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    TryStatementSyntax.prototype.update = function (tryKeyword, block, catchClause, finallyClause) {
        if (this.tryKeyword === tryKeyword && this.block === block && this.catchClause === catchClause && this.finallyClause === finallyClause) {
            return this;
        }
        return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, this.parsedInStrictMode());
    };
    TryStatementSyntax.create = function create(tryKeyword, block) {
        return new TryStatementSyntax(tryKeyword, block, null, null, false);
    };
    TryStatementSyntax.create1 = function create1() {
        return new TryStatementSyntax(Syntax.token(38 /* TryKeyword */ ), BlockSyntax.create1(), null, null, false);
    };
    TryStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    TryStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    TryStatementSyntax.prototype.withTryKeyword = function (tryKeyword) {
        return this.update(tryKeyword, this.block, this.catchClause, this.finallyClause);
    };
    TryStatementSyntax.prototype.withBlock = function (block) {
        return this.update(this.tryKeyword, block, this.catchClause, this.finallyClause);
    };
    TryStatementSyntax.prototype.withCatchClause = function (catchClause) {
        return this.update(this.tryKeyword, this.block, catchClause, this.finallyClause);
    };
    TryStatementSyntax.prototype.withFinallyClause = function (finallyClause) {
        return this.update(this.tryKeyword, this.block, this.catchClause, finallyClause);
    };
    TryStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.block.isTypeScriptSpecific()) {
            return true;
        }
        if (this.catchClause !== null && this.catchClause.isTypeScriptSpecific()) {
            return true;
        }
        if (this.finallyClause !== null && this.finallyClause.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return TryStatementSyntax;
})(SyntaxNode);
var CatchClauseSyntax = (function (_super) {
    __extends(CatchClauseSyntax, _super);
    function CatchClauseSyntax(catchKeyword, openParenToken, identifier, closeParenToken, block, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.catchKeyword = catchKeyword;
        this.openParenToken = openParenToken;
        this.identifier = identifier;
        this.closeParenToken = closeParenToken;
        this.block = block;
    }
    CatchClauseSyntax.prototype.accept = function (visitor) {
        return visitor.visitCatchClause(this);
    };
    CatchClauseSyntax.prototype.kind = function () {
        return 233 /* CatchClause */ ;
    };
    CatchClauseSyntax.prototype.childCount = function () {
        return 5;
    };
    CatchClauseSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.catchKeyword;
            case 1:
                return this.openParenToken;
            case 2:
                return this.identifier;
            case 3:
                return this.closeParenToken;
            case 4:
                return this.block;
            default:
                throw Errors.invalidOperation();
        }
    };
    CatchClauseSyntax.prototype.update = function (catchKeyword, openParenToken, identifier, closeParenToken, block) {
        if (this.catchKeyword === catchKeyword && this.openParenToken === openParenToken && this.identifier === identifier && this.closeParenToken === closeParenToken && this.block === block) {
            return this;
        }
        return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, closeParenToken, block, this.parsedInStrictMode());
    };
    CatchClauseSyntax.create1 = function create1(identifier) {
        return new CatchClauseSyntax(Syntax.token(17 /* CatchKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), identifier, Syntax.token(73 /* CloseParenToken */ ), BlockSyntax.create1(), false);
    };
    CatchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    CatchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    CatchClauseSyntax.prototype.withCatchKeyword = function (catchKeyword) {
        return this.update(catchKeyword, this.openParenToken, this.identifier, this.closeParenToken, this.block);
    };
    CatchClauseSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.catchKeyword, openParenToken, this.identifier, this.closeParenToken, this.block);
    };
    CatchClauseSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(this.catchKeyword, this.openParenToken, identifier, this.closeParenToken, this.block);
    };
    CatchClauseSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.catchKeyword, this.openParenToken, this.identifier, closeParenToken, this.block);
    };
    CatchClauseSyntax.prototype.withBlock = function (block) {
        return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.closeParenToken, block);
    };
    CatchClauseSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.block.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return CatchClauseSyntax;
})(SyntaxNode);
var FinallyClauseSyntax = (function (_super) {
    __extends(FinallyClauseSyntax, _super);
    function FinallyClauseSyntax(finallyKeyword, block, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.finallyKeyword = finallyKeyword;
        this.block = block;
    }
    FinallyClauseSyntax.prototype.accept = function (visitor) {
        return visitor.visitFinallyClause(this);
    };
    FinallyClauseSyntax.prototype.kind = function () {
        return 234 /* FinallyClause */ ;
    };
    FinallyClauseSyntax.prototype.childCount = function () {
        return 2;
    };
    FinallyClauseSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.finallyKeyword;
            case 1:
                return this.block;
            default:
                throw Errors.invalidOperation();
        }
    };
    FinallyClauseSyntax.prototype.update = function (finallyKeyword, block) {
        if (this.finallyKeyword === finallyKeyword && this.block === block) {
            return this;
        }
        return new FinallyClauseSyntax(finallyKeyword, block, this.parsedInStrictMode());
    };
    FinallyClauseSyntax.create1 = function create1() {
        return new FinallyClauseSyntax(Syntax.token(25 /* FinallyKeyword */ ), BlockSyntax.create1(), false);
    };
    FinallyClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    FinallyClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    FinallyClauseSyntax.prototype.withFinallyKeyword = function (finallyKeyword) {
        return this.update(finallyKeyword, this.block);
    };
    FinallyClauseSyntax.prototype.withBlock = function (block) {
        return this.update(this.finallyKeyword, block);
    };
    FinallyClauseSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.block.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return FinallyClauseSyntax;
})(SyntaxNode);
var LabeledStatementSyntax = (function (_super) {
    __extends(LabeledStatementSyntax, _super);
    function LabeledStatementSyntax(identifier, colonToken, statement, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.identifier = identifier;
        this.colonToken = colonToken;
        this.statement = statement;
    }
    LabeledStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitLabeledStatement(this);
    };
    LabeledStatementSyntax.prototype.kind = function () {
        return 157 /* LabeledStatement */ ;
    };
    LabeledStatementSyntax.prototype.childCount = function () {
        return 3;
    };
    LabeledStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.identifier;
            case 1:
                return this.colonToken;
            case 2:
                return this.statement;
            default:
                throw Errors.invalidOperation();
        }
    };
    LabeledStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    LabeledStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    LabeledStatementSyntax.prototype.update = function (identifier, colonToken, statement) {
        if (this.identifier === identifier && this.colonToken === colonToken && this.statement === statement) {
            return this;
        }
        return new LabeledStatementSyntax(identifier, colonToken, statement, this.parsedInStrictMode());
    };
    LabeledStatementSyntax.create1 = function create1(identifier, statement) {
        return new LabeledStatementSyntax(identifier, Syntax.token(106 /* ColonToken */ ), statement, false);
    };
    LabeledStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    LabeledStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    LabeledStatementSyntax.prototype.withIdentifier = function (identifier) {
        return this.update(identifier, this.colonToken, this.statement);
    };
    LabeledStatementSyntax.prototype.withColonToken = function (colonToken) {
        return this.update(this.identifier, colonToken, this.statement);
    };
    LabeledStatementSyntax.prototype.withStatement = function (statement) {
        return this.update(this.identifier, this.colonToken, statement);
    };
    LabeledStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.statement.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return LabeledStatementSyntax;
})(SyntaxNode);
var DoStatementSyntax = (function (_super) {
    __extends(DoStatementSyntax, _super);
    function DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, parsedInStrictMode) {
        _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
        this.doKeyword = doKeyword;
        this.whileKeyword = whileKeyword;
        this.condition = condition;
        this.semicolonToken = semicolonToken;
    }
    DoStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitDoStatement(this);
    };
    DoStatementSyntax.prototype.kind = function () {
        return 158 /* DoStatement */ ;
    };
    DoStatementSyntax.prototype.childCount = function () {
        return 7;
    };
    DoStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.doKeyword;
            case 1:
                return this.statement;
            case 2:
                return this.whileKeyword;
            case 3:
                return this.openParenToken;
            case 4:
                return this.condition;
            case 5:
                return this.closeParenToken;
            case 6:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    DoStatementSyntax.prototype.update = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
        if (this.doKeyword === doKeyword && this.statement === statement && this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.parsedInStrictMode());
    };
    DoStatementSyntax.create1 = function create1(statement, condition) {
        return new DoStatementSyntax(Syntax.token(22 /* DoKeyword */ ), statement, Syntax.token(42 /* WhileKeyword */ ), Syntax.token(72 /* OpenParenToken */ ), condition, Syntax.token(73 /* CloseParenToken */ ), Syntax.token(78 /* SemicolonToken */ ), false);
    };
    DoStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    DoStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    DoStatementSyntax.prototype.withDoKeyword = function (doKeyword) {
        return this.update(doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    };
    DoStatementSyntax.prototype.withStatement = function (statement) {
        return this.update(this.doKeyword, statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    };
    DoStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
        return this.update(this.doKeyword, this.statement, whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    };
    DoStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    };
    DoStatementSyntax.prototype.withCondition = function (condition) {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.semicolonToken);
    };
    DoStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.semicolonToken);
    };
    DoStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, semicolonToken);
    };
    DoStatementSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.statement.isTypeScriptSpecific()) {
            return true;
        }
        if (this.condition.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return DoStatementSyntax;
})(IterationStatementSyntax);
var TypeOfExpressionSyntax = (function (_super) {
    __extends(TypeOfExpressionSyntax, _super);
    function TypeOfExpressionSyntax(typeOfKeyword, expression, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.typeOfKeyword = typeOfKeyword;
        this.expression = expression;
    }
    TypeOfExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitTypeOfExpression(this);
    };
    TypeOfExpressionSyntax.prototype.kind = function () {
        return 168 /* TypeOfExpression */ ;
    };
    TypeOfExpressionSyntax.prototype.childCount = function () {
        return 2;
    };
    TypeOfExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.typeOfKeyword;
            case 1:
                return this.expression;
            default:
                throw Errors.invalidOperation();
        }
    };
    TypeOfExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    TypeOfExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    TypeOfExpressionSyntax.prototype.update = function (typeOfKeyword, expression) {
        if (this.typeOfKeyword === typeOfKeyword && this.expression === expression) {
            return this;
        }
        return new TypeOfExpressionSyntax(typeOfKeyword, expression, this.parsedInStrictMode());
    };
    TypeOfExpressionSyntax.create1 = function create1(expression) {
        return new TypeOfExpressionSyntax(Syntax.token(39 /* TypeOfKeyword */ ), expression, false);
    };
    TypeOfExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    TypeOfExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    TypeOfExpressionSyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
        return this.update(typeOfKeyword, this.expression);
    };
    TypeOfExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(this.typeOfKeyword, expression);
    };
    TypeOfExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return TypeOfExpressionSyntax;
})(SyntaxNode);
var DeleteExpressionSyntax = (function (_super) {
    __extends(DeleteExpressionSyntax, _super);
    function DeleteExpressionSyntax(deleteKeyword, expression, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.deleteKeyword = deleteKeyword;
        this.expression = expression;
    }
    DeleteExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitDeleteExpression(this);
    };
    DeleteExpressionSyntax.prototype.kind = function () {
        return 167 /* DeleteExpression */ ;
    };
    DeleteExpressionSyntax.prototype.childCount = function () {
        return 2;
    };
    DeleteExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.deleteKeyword;
            case 1:
                return this.expression;
            default:
                throw Errors.invalidOperation();
        }
    };
    DeleteExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    DeleteExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    DeleteExpressionSyntax.prototype.update = function (deleteKeyword, expression) {
        if (this.deleteKeyword === deleteKeyword && this.expression === expression) {
            return this;
        }
        return new DeleteExpressionSyntax(deleteKeyword, expression, this.parsedInStrictMode());
    };
    DeleteExpressionSyntax.create1 = function create1(expression) {
        return new DeleteExpressionSyntax(Syntax.token(21 /* DeleteKeyword */ ), expression, false);
    };
    DeleteExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    DeleteExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    DeleteExpressionSyntax.prototype.withDeleteKeyword = function (deleteKeyword) {
        return this.update(deleteKeyword, this.expression);
    };
    DeleteExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(this.deleteKeyword, expression);
    };
    DeleteExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return DeleteExpressionSyntax;
})(SyntaxNode);
var VoidExpressionSyntax = (function (_super) {
    __extends(VoidExpressionSyntax, _super);
    function VoidExpressionSyntax(voidKeyword, expression, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.voidKeyword = voidKeyword;
        this.expression = expression;
    }
    VoidExpressionSyntax.prototype.accept = function (visitor) {
        return visitor.visitVoidExpression(this);
    };
    VoidExpressionSyntax.prototype.kind = function () {
        return 169 /* VoidExpression */ ;
    };
    VoidExpressionSyntax.prototype.childCount = function () {
        return 2;
    };
    VoidExpressionSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.voidKeyword;
            case 1:
                return this.expression;
            default:
                throw Errors.invalidOperation();
        }
    };
    VoidExpressionSyntax.prototype.isUnaryExpression = function () {
        return true;
    };
    VoidExpressionSyntax.prototype.isExpression = function () {
        return true;
    };
    VoidExpressionSyntax.prototype.update = function (voidKeyword, expression) {
        if (this.voidKeyword === voidKeyword && this.expression === expression) {
            return this;
        }
        return new VoidExpressionSyntax(voidKeyword, expression, this.parsedInStrictMode());
    };
    VoidExpressionSyntax.create1 = function create1(expression) {
        return new VoidExpressionSyntax(Syntax.token(41 /* VoidKeyword */ ), expression, false);
    };
    VoidExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    VoidExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    VoidExpressionSyntax.prototype.withVoidKeyword = function (voidKeyword) {
        return this.update(voidKeyword, this.expression);
    };
    VoidExpressionSyntax.prototype.withExpression = function (expression) {
        return this.update(this.voidKeyword, expression);
    };
    VoidExpressionSyntax.prototype.isTypeScriptSpecific = function () {
        if (this.expression.isTypeScriptSpecific()) {
            return true;
        }
        return false;
    };
    return VoidExpressionSyntax;
})(SyntaxNode);
var DebuggerStatementSyntax = (function (_super) {
    __extends(DebuggerStatementSyntax, _super);
    function DebuggerStatementSyntax(debuggerKeyword, semicolonToken, parsedInStrictMode) {
        _super.call(this, parsedInStrictMode);
        this.debuggerKeyword = debuggerKeyword;
        this.semicolonToken = semicolonToken;
    }
    DebuggerStatementSyntax.prototype.accept = function (visitor) {
        return visitor.visitDebuggerStatement(this);
    };
    DebuggerStatementSyntax.prototype.kind = function () {
        return 159 /* DebuggerStatement */ ;
    };
    DebuggerStatementSyntax.prototype.childCount = function () {
        return 2;
    };
    DebuggerStatementSyntax.prototype.childAt = function (slot) {
        switch(slot) {
            case 0:
                return this.debuggerKeyword;
            case 1:
                return this.semicolonToken;
            default:
                throw Errors.invalidOperation();
        }
    };
    DebuggerStatementSyntax.prototype.isStatement = function () {
        return true;
    };
    DebuggerStatementSyntax.prototype.isModuleElement = function () {
        return true;
    };
    DebuggerStatementSyntax.prototype.update = function (debuggerKeyword, semicolonToken) {
        if (this.debuggerKeyword === debuggerKeyword && this.semicolonToken === semicolonToken) {
            return this;
        }
        return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, this.parsedInStrictMode());
    };
    DebuggerStatementSyntax.create1 = function create1() {
        return new DebuggerStatementSyntax(Syntax.token(19 /* DebuggerKeyword */ ), Syntax.token(78 /* SemicolonToken */ ), false);
    };
    DebuggerStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
        return _super.prototype.withLeadingTrivia.call(this, trivia);
    };
    DebuggerStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
        return _super.prototype.withTrailingTrivia.call(this, trivia);
    };
    DebuggerStatementSyntax.prototype.withDebuggerKeyword = function (debuggerKeyword) {
        return this.update(debuggerKeyword, this.semicolonToken);
    };
    DebuggerStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
        return this.update(this.debuggerKeyword, semicolonToken);
    };
    DebuggerStatementSyntax.prototype.isTypeScriptSpecific = function () {
        return false;
    };
    return DebuggerStatementSyntax;
})(SyntaxNode);
var SyntaxVisitor = (function () {
    function SyntaxVisitor() { }
    SyntaxVisitor.prototype.defaultVisit = function (node) {
        return null;
    };
    SyntaxVisitor.prototype.visitToken = function (token) {
        return this.defaultVisit(token);
    };
    SyntaxVisitor.prototype.visitSourceUnit = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitExternalModuleReference = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitModuleNameModuleReference = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitImportDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitClassDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitInterfaceDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitExtendsClause = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitImplementsClause = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitModuleDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitFunctionDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitVariableStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitVariableDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitVariableDeclarator = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitEqualsValueClause = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitPrefixUnaryExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitArrayLiteralExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitOmittedExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitParenthesizedExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitQualifiedName = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitTypeArgumentList = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitConstructorType = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitFunctionType = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitObjectType = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitArrayType = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitGenericType = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitTypeAnnotation = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitBlock = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitParameter = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitMemberAccessExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitPostfixUnaryExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitElementAccessExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitInvocationExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitArgumentList = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitBinaryExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitConditionalExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitConstructSignature = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitFunctionSignature = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitIndexSignature = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitPropertySignature = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitParameterList = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitCallSignature = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitTypeParameterList = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitTypeParameter = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitConstraint = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitElseClause = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitIfStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitExpressionStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitConstructorDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitMemberVariableDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitThrowStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitReturnStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitObjectCreationExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitSwitchStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitCaseSwitchClause = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitDefaultSwitchClause = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitBreakStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitContinueStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitForStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitForInStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitWhileStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitWithStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitEnumDeclaration = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitCastExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitObjectLiteralExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitSimplePropertyAssignment = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitFunctionExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitEmptyStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitTryStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitCatchClause = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitFinallyClause = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitLabeledStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitDoStatement = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitTypeOfExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitDeleteExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitVoidExpression = function (node) {
        return this.defaultVisit(node);
    };
    SyntaxVisitor.prototype.visitDebuggerStatement = function (node) {
        return this.defaultVisit(node);
    };
    return SyntaxVisitor;
})();
var ParseOptions = (function () {
    function ParseOptions(allowAutomaticSemicolonInsertion) {
        if (typeof allowAutomaticSemicolonInsertion === "undefined") { allowAutomaticSemicolonInsertion = true; }
        this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
    }
    ParseOptions.prototype.allowAutomaticSemicolonInsertion = function () {
        return this._allowAutomaticSemicolonInsertion;
    };
    return ParseOptions;
})();
var Strings = (function () {
    function Strings() { }
    Strings.module__class__interface__enum__import_or_statement = "module, class, interface, enum, import or statement";
    Strings.constructor__function__accessor_or_variable = "constructor, function, accessor or variable";
    Strings.statement = "statement";
    Strings.case_or_default_clause = "case or default clause";
    Strings.identifier = "identifier";
    Strings.call__construct__index__property_or_function_signature = "call, construct, index, property or function signature";
    Strings.expression = "expression";
    Strings.type_name = "type name";
    Strings.property_or_accessor = "property or accessor";
    Strings.parameter = "parameter";
    Strings.type = "type";
    Strings.type_parameter = "type parameter";
    return Strings;
})();
var SyntaxTree = (function () {
    function SyntaxTree(sourceUnit, diagnostics) {
        this._sourceUnit = sourceUnit;
        this._diagnostics = diagnostics;
    }
    SyntaxTree.prototype.toJSON = function (key) {
        var result = {};
        if (this._diagnostics.length > 0) {
            result._diagnostics = this._diagnostics;
        }
        result._sourceUnit = this._sourceUnit;
        return result;
    };
    SyntaxTree.prototype.sourceUnit = function () {
        return this._sourceUnit;
    };
    SyntaxTree.prototype.diagnostics = function () {
        return this._diagnostics;
    };
    SyntaxTree.prototype.structuralEquals = function (tree) {
        return ArrayUtilities.sequenceEquals(this.diagnostics(), tree.diagnostics(), SyntaxDiagnostic.equals) && this.sourceUnit().structuralEquals(tree.sourceUnit());
    };
    return SyntaxTree;
})();
var Constants;
(function (Constants) {
    Constants._map = [];
    Constants.Max31BitInteger = 1073741823;
    Constants.Min31BitInteger = -1073741824;
})(Constants || (Constants = {}));
var TextChangeRange = (function () {
    function TextChangeRange(span, newLength) {
        if (newLength < 0) {
            throw Errors.argumentOutOfRange("newLength");
        }
        this._span = span;
        this._newLength = newLength;
    }
    TextChangeRange.prototype.span = function () {
        return this._span;
    };
    TextChangeRange.prototype.newLength = function () {
        return this._newLength;
    };
    TextChangeRange.prototype.newSpan = function () {
        return new TextSpan(this.span().start(), this.newLength());
    };
    TextChangeRange.collapse = function collapse(changes) {
        var diff = 0;
        var start = 1073741823 /* Max31BitInteger */ ;
        var end = 0;
        for(var i = 0; i < changes.length; i++) {
            var change = changes[i];
            diff += change.newLength() - change.span().length();
            if (change.span().start() < start) {
                start = change.span().start();
            }
            if (change.span().end() > end) {
                end = change.span().end();
            }
        }
        if (start > end) {
            return null;
        }
        var combined = TextSpan.fromBounds(start, end);
        var newLen = combined.length() + diff;
        return new TextChangeRange(combined, newLen);
    };
    return TextChangeRange;
})();
var Parser1;
(function (Parser1) {
    var ExpressionPrecedence;
    (function (ExpressionPrecedence) {
        ExpressionPrecedence._map = [];
        ExpressionPrecedence.CommaExpressionPrecedence = 1;
        ExpressionPrecedence.AssignmentExpressionPrecedence = 2;
        ExpressionPrecedence.ConditionalExpressionPrecedence = 3;
        ExpressionPrecedence.ArrowFunctionPrecedence = 4;
        ExpressionPrecedence.LogicalOrExpressionPrecedence = 5;
        ExpressionPrecedence.LogicalAndExpressionPrecedence = 6;
        ExpressionPrecedence.BitwiseOrExpressionPrecedence = 7;
        ExpressionPrecedence.BitwiseExclusiveOrExpressionPrecedence = 8;
        ExpressionPrecedence.BitwiseAndExpressionPrecedence = 9;
        ExpressionPrecedence.EqualityExpressionPrecedence = 10;
        ExpressionPrecedence.RelationalExpressionPrecedence = 11;
        ExpressionPrecedence.ShiftExpressionPrecdence = 12;
        ExpressionPrecedence.AdditiveExpressionPrecedence = 13;
        ExpressionPrecedence.MultiplicativeExpressionPrecedence = 14;
        ExpressionPrecedence.UnaryExpressionPrecedence = 15;
    })(ExpressionPrecedence || (ExpressionPrecedence = {}));
    var ListParsingState;
    (function (ListParsingState) {
        ListParsingState._map = [];
        ListParsingState.SourceUnit_ModuleElements = 1 << 0;
        ListParsingState.ClassDeclaration_ClassElements = 1 << 1;
        ListParsingState.ModuleDeclaration_ModuleElements = 1 << 2;
        ListParsingState.SwitchStatement_SwitchClauses = 1 << 3;
        ListParsingState.SwitchClause_Statements = 1 << 4;
        ListParsingState.Block_Statements = 1 << 5;
        ListParsingState.TryBlock_Statements = 1 << 6;
        ListParsingState.CatchBlock_Statements = 1 << 7;
        ListParsingState.EnumDeclaration_VariableDeclarators = 1 << 8;
        ListParsingState.ObjectType_TypeMembers = 1 << 9;
        ListParsingState.ExtendsOrImplementsClause_TypeNameList = 1 << 10;
        ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn = 1 << 11;
        ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn = 1 << 12;
        ListParsingState.ArgumentList_AssignmentExpressions = 1 << 13;
        ListParsingState.ObjectLiteralExpression_PropertyAssignments = 1 << 14;
        ListParsingState.ArrayLiteralExpression_AssignmentExpressions = 1 << 15;
        ListParsingState.ParameterList_Parameters = 1 << 16;
        ListParsingState.TypeArgumentList_Types = 1 << 17;
        ListParsingState.TypeParameterList_TypeParameters = 1 << 18;
        ListParsingState.FirstListParsingState = ListParsingState.SourceUnit_ModuleElements;
        ListParsingState.LastListParsingState = ListParsingState.TypeArgumentList_Types;
    })(ListParsingState || (ListParsingState = {}));
    var SyntaxCursor = (function () {
        function SyntaxCursor(sourceUnit) {
            this._elements = [];
            this._index = 0;
            this._pinCount = 0;
            sourceUnit.insertChildrenInto(this._elements, 0);
        }
        SyntaxCursor.prototype.isFinished = function () {
            return this._index === this._elements.length;
        };
        SyntaxCursor.prototype.currentElement = function () {
            if (this.isFinished()) {
                return null;
            }
            return this._elements[this._index];
        };
        SyntaxCursor.prototype.currentNode = function () {
            var element = this.currentElement();
            return element !== null && element.isNode() ? element : null;
        };
        SyntaxCursor.prototype.moveToFirstChild = function () {
            if (this.isFinished()) {
                return;
            }
            var element = this._elements[this._index];
            if (element.isToken()) {
                return;
            }
            var node = element;
            this._elements.splice(this._index, 1);
            node.insertChildrenInto(this._elements, this._index);
        };
        SyntaxCursor.prototype.moveToNextSibling = function () {
            if (this.isFinished()) {
                return;
            }
            if (this._pinCount > 0) {
                this._index++;
                return;
            }
            this._elements.shift();
        };
        SyntaxCursor.prototype.getAndPinCursorIndex = function () {
            this._pinCount++;
            return this._index;
        };
        SyntaxCursor.prototype.releaseAndUnpinCursorIndex = function (index) {
            this._pinCount--;
            if (this._pinCount === 0) {
            }
        };
        SyntaxCursor.prototype.rewindToPinnedCursorIndex = function (index) {
            this._index = index;
        };
        SyntaxCursor.prototype.pinCount = function () {
            return this._pinCount;
        };
        SyntaxCursor.prototype.moveToFirstToken = function () {
            var element;
            while(!this.isFinished()) {
                var element = this.currentElement();
                if (element.isNode()) {
                    this.moveToFirstChild();
                    continue;
                }
                return;
            }
        };
        SyntaxCursor.prototype.currentToken = function () {
            this.moveToFirstToken();
            if (this.isFinished()) {
                return null;
            }
            var element = this.currentElement();
            return element;
        };
        SyntaxCursor.prototype.peekToken = function (n) {
            this.moveToFirstToken();
            var pin = this.getAndPinCursorIndex();
            try  {
                for(var i = 0; i < n; i++) {
                    this.moveToNextSibling();
                    this.moveToFirstToken();
                }
                return this.currentToken();
            } finally {
                this.rewindToPinnedCursorIndex(pin);
                this.releaseAndUnpinCursorIndex(pin);
            }
        };
        return SyntaxCursor;
    })();    
    var NormalParserSource = (function () {
        function NormalParserSource(text, languageVersion, stringTable) {
            this._previousToken = null;
            this._absolutePosition = 0;
            this._tokenDiagnostics = [];
            this.rewindPointPool = [];
            this.rewindPointPoolCount = 0;
            this.slidingWindow = new SlidingWindow(this, ArrayUtilities.createArray(32, null), null);
            this.scanner = new Scanner(text, languageVersion, stringTable);
        }
        NormalParserSource.prototype.currentNode = function () {
            return null;
        };
        NormalParserSource.prototype.moveToNextNode = function () {
            throw Errors.invalidOperation();
        };
        NormalParserSource.prototype.absolutePosition = function () {
            return this._absolutePosition;
        };
        NormalParserSource.prototype.previousToken = function () {
            return this._previousToken;
        };
        NormalParserSource.prototype.tokenDiagnostics = function () {
            return this._tokenDiagnostics;
        };
        NormalParserSource.prototype.getOrCreateRewindPoint = function () {
            if (this.rewindPointPoolCount === 0) {
                return {};
            }
            this.rewindPointPoolCount--;
            var result = this.rewindPointPool[this.rewindPointPoolCount];
            this.rewindPointPool[this.rewindPointPoolCount] = null;
            return result;
        };
        NormalParserSource.prototype.getRewindPoint = function () {
            var slidingWindowIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var rewindPoint = this.getOrCreateRewindPoint();
            rewindPoint.slidingWindowIndex = slidingWindowIndex;
            rewindPoint.previousToken = this._previousToken;
            rewindPoint.absolutePosition = this._absolutePosition;
            rewindPoint.pinCount = this.slidingWindow.pinCount();
            return rewindPoint;
        };
        NormalParserSource.prototype.isPinned = function () {
            return this.slidingWindow.pinCount() > 0;
        };
        NormalParserSource.prototype.rewind = function (rewindPoint) {
            this.slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);
            this._previousToken = rewindPoint.previousToken;
            this._absolutePosition = rewindPoint.absolutePosition;
        };
        NormalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
            this.slidingWindow.releaseAndUnpinAbsoluteIndex((rewindPoint).absoluteIndex);
            this.rewindPointPool[this.rewindPointPoolCount] = rewindPoint;
            this.rewindPointPoolCount++;
        };
        NormalParserSource.prototype.fetchMoreItems = function (allowRegularExpression, sourceIndex, window, destinationIndex, spaceAvailable) {
            window[destinationIndex] = this.scanner.scan(this._tokenDiagnostics, allowRegularExpression);
            return 1;
        };
        NormalParserSource.prototype.peekToken = function (n) {
            return this.slidingWindow.peekItemN(n);
        };
        NormalParserSource.prototype.moveToNextToken = function () {
            var currentToken = this.currentToken();
            this._absolutePosition += currentToken.fullWidth();
            this._previousToken = currentToken;
            this.slidingWindow.moveToNextItem();
        };
        NormalParserSource.prototype.currentToken = function () {
            return this.slidingWindow.currentItem(false);
        };
        NormalParserSource.prototype.removeDiagnosticsOnOrAfterPosition = function (position) {
            var tokenDiagnosticsLength = this._tokenDiagnostics.length;
            while(tokenDiagnosticsLength > 0) {
                var diagnostic = this._tokenDiagnostics[tokenDiagnosticsLength - 1];
                if (diagnostic.position() >= position) {
                    tokenDiagnosticsLength--;
                } else {
                    break;
                }
            }
            this._tokenDiagnostics.length = tokenDiagnosticsLength;
        };
        NormalParserSource.prototype.resetToPosition = function (absolutePosition, previousToken) {
            this._absolutePosition = absolutePosition;
            this._previousToken = previousToken;
            this.removeDiagnosticsOnOrAfterPosition(absolutePosition);
            this.slidingWindow.disgardAllItemsFromCurrentIndexOnwards();
            this.scanner.setAbsoluteIndex(absolutePosition);
        };
        NormalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
            this.resetToPosition(this._absolutePosition, this._previousToken);
            var token = this.slidingWindow.currentItem(true);
            return token;
        };
        return NormalParserSource;
    })();    
    var IncrementalParserSource = (function () {
        function IncrementalParserSource(oldSourceUnit, changeRanges, newText, languageVersion, stringTable) {
            this._changeDelta = 0;
            this._oldSourceUnitCursor = new SyntaxCursor(oldSourceUnit);
            this._changeRange = IncrementalParserSource.extendToAffectedRange(TextChangeRange.collapse(changeRanges), oldSourceUnit);
            this._normalParserSource = new NormalParserSource(newText, languageVersion, stringTable);
        }
        IncrementalParserSource.extendToAffectedRange = function extendToAffectedRange(changeRange, sourceUnit) {
            var maxLookahead = 1;
            var start = changeRange.span().start();
            for(var i = 0; start > 0 && i <= maxLookahead; i++) {
                var token = sourceUnit.findToken(start);
                var position = token.fullStart();
                start = MathPrototype.max(0, position - 1);
            }
            var finalSpan = TextSpan.fromBounds(start, changeRange.span().end());
            var finalLength = changeRange.newLength() + (changeRange.span().start() - start);
            return new TextChangeRange(finalSpan, finalLength);
        };
        IncrementalParserSource.prototype.absolutePosition = function () {
            return this._normalParserSource.absolutePosition();
        };
        IncrementalParserSource.prototype.previousToken = function () {
            return this._normalParserSource.previousToken();
        };
        IncrementalParserSource.prototype.tokenDiagnostics = function () {
            return this._normalParserSource.tokenDiagnostics();
        };
        IncrementalParserSource.prototype.getRewindPoint = function () {
            var rewindPoint = this._normalParserSource.getRewindPoint();
            var oldSourceUnitCursorIndex = this._oldSourceUnitCursor.getAndPinCursorIndex();
            rewindPoint.changeDelta = this._changeDelta;
            rewindPoint.changeRange = this._changeRange;
            rewindPoint.oldSourceUnitCursorIndex = oldSourceUnitCursorIndex;
            return rewindPoint;
        };
        IncrementalParserSource.prototype.rewind = function (rewindPoint) {
            this._changeRange = rewindPoint.changeRange;
            this._changeDelta = rewindPoint.changeDelta;
            this._oldSourceUnitCursor.rewindToPinnedCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
            this._normalParserSource.rewind(rewindPoint);
        };
        IncrementalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
            this._oldSourceUnitCursor.releaseAndUnpinCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
            this._normalParserSource.releaseRewindPoint(rewindPoint);
        };
        IncrementalParserSource.prototype.canReadFromOldSourceUnit = function () {
            if (this._normalParserSource.isPinned()) {
                return false;
            }
            if (this._changeRange !== null && this._changeRange.newSpan().intersectsWithPosition(this.absolutePosition())) {
                return false;
            }
            this.syncCursorToNewTextIfBehind();
            return this._changeDelta === 0 && !this._oldSourceUnitCursor.isFinished();
        };
        IncrementalParserSource.prototype.currentNode = function () {
            if (this.canReadFromOldSourceUnit()) {
                return this.tryGetNodeFromOldSourceUnit();
            }
            return null;
        };
        IncrementalParserSource.prototype.currentToken = function () {
            if (this.canReadFromOldSourceUnit()) {
                var token = this.tryGetTokenFromOldSourceUnit();
                if (token !== null) {
                    return token;
                }
            }
            return this._normalParserSource.currentToken();
        };
        IncrementalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
            return this._normalParserSource.currentTokenAllowingRegularExpression();
        };
        IncrementalParserSource.prototype.syncCursorToNewTextIfBehind = function () {
            while(true) {
                if (this._oldSourceUnitCursor.isFinished()) {
                    break;
                }
                if (this._changeDelta >= 0) {
                    break;
                }
                var currentElement = this._oldSourceUnitCursor.currentElement();
                if (currentElement.isNode() && (currentElement.fullWidth() > Math.abs(this._changeDelta))) {
                    this._oldSourceUnitCursor.moveToFirstChild();
                } else {
                    this._oldSourceUnitCursor.moveToNextSibling();
                    this._changeDelta += currentElement.fullWidth();
                }
            }
        };
        IncrementalParserSource.prototype.intersectsWithChangeRangeSpanInOriginalText = function (start, length) {
            return this._changeRange !== null && this._changeRange.span().intersectsWith(start, length);
        };
        IncrementalParserSource.prototype.tryGetNodeFromOldSourceUnit = function () {
            while(true) {
                var node = this._oldSourceUnitCursor.currentNode();
                if (node === null) {
                    return null;
                }
                if (!this.intersectsWithChangeRangeSpanInOriginalText(this.absolutePosition(), node.fullWidth())) {
                    if (!node.hasSkippedText() && !node.hasZeroWidthToken() && !node.hasRegularExpressionToken()) {
                        return node;
                    }
                }
                this._oldSourceUnitCursor.moveToFirstChild();
            }
        };
        IncrementalParserSource.prototype.canReuseTokenFromOldSourceUnit = function (position, token) {
            if (token !== null) {
                if (!this.intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                    if (!token.hasSkippedText() && token.width() > 0 && !SyntaxFacts.isAnyDivideOrRegularExpressionToken(token.tokenKind) && !SyntaxFacts.isParserGenerated(token.tokenKind)) {
                        return true;
                    }
                }
            }
            return false;
        };
        IncrementalParserSource.prototype.tryGetTokenFromOldSourceUnit = function () {
            var token = this._oldSourceUnitCursor.currentToken();
            return this.canReuseTokenFromOldSourceUnit(this.absolutePosition(), token) ? token : null;
        };
        IncrementalParserSource.prototype.peekToken = function (n) {
            if (this.canReadFromOldSourceUnit()) {
                var token = this.tryPeekTokenFromOldSourceUnit(n);
                if (token !== null) {
                    return token;
                }
            }
            return this._normalParserSource.peekToken(n);
        };
        IncrementalParserSource.prototype.tryPeekTokenFromOldSourceUnit = function (n) {
            var currentPosition = this.absolutePosition();
            for(var i = 0; i < n; i++) {
                var interimToken = this._oldSourceUnitCursor.peekToken(i);
                if (!this.canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                    return null;
                }
                currentPosition += interimToken.fullWidth();
            }
            var token = this._oldSourceUnitCursor.peekToken(n);
            return this.canReuseTokenFromOldSourceUnit(currentPosition, token) ? token : null;
        };
        IncrementalParserSource.prototype.moveToNextNode = function () {
            var currentElement = this._oldSourceUnitCursor.currentElement();
            var currentNode = this._oldSourceUnitCursor.currentNode();
            this._oldSourceUnitCursor.moveToNextSibling();
            var absolutePosition = this.absolutePosition() + currentNode.fullWidth();
            var previousToken = currentNode.lastToken();
            this._normalParserSource.resetToPosition(absolutePosition, previousToken);
            if (this._changeRange !== null) {
            }
        };
        IncrementalParserSource.prototype.moveToNextToken = function () {
            var currentToken = this.currentToken();
            if (this._oldSourceUnitCursor.currentToken() === currentToken) {
                this._oldSourceUnitCursor.moveToNextSibling();
                var absolutePosition = this.absolutePosition() + currentToken.fullWidth();
                var previousToken = currentToken;
                this._normalParserSource.resetToPosition(absolutePosition, previousToken);
                if (this._changeRange !== null) {
                }
            } else {
                this._changeDelta -= currentToken.fullWidth();
                this._normalParserSource.moveToNextToken();
                if (this._changeRange !== null) {
                    var changeRangeSpanInNewText = this._changeRange.newSpan();
                    if (this.absolutePosition() >= changeRangeSpanInNewText.end()) {
                        this._changeDelta += this._changeRange.newLength() - this._changeRange.span().length();
                        this._changeRange = null;
                    }
                }
            }
        };
        return IncrementalParserSource;
    })();    
    var ParserImpl = (function () {
        function ParserImpl(source, options) {
            this.listParsingState = 0;
            this.isInStrictMode = false;
            this.diagnostics = [];
            this.factory = Syntax.normalModeFactory;
            this.mergeTokensStorage = [];
            this.arrayPool = [];
            this.source = source;
            this.options = options;
        }
        ParserImpl.prototype.getRewindPoint = function () {
            var rewindPoint = this.source.getRewindPoint();
            rewindPoint.diagnosticsCount = this.diagnostics.length;
            rewindPoint.isInStrictMode = this.isInStrictMode;
            rewindPoint.listParsingState = this.listParsingState;
            return rewindPoint;
        };
        ParserImpl.prototype.rewind = function (rewindPoint) {
            this.source.rewind(rewindPoint);
            this.diagnostics.length = rewindPoint.diagnosticsCount;
        };
        ParserImpl.prototype.releaseRewindPoint = function (rewindPoint) {
            this.source.releaseRewindPoint(rewindPoint);
        };
        ParserImpl.prototype.currentTokenStart = function () {
            return this.source.absolutePosition() + this.currentToken().leadingTriviaWidth();
        };
        ParserImpl.prototype.previousTokenStart = function () {
            if (this.previousToken() === null) {
                return 0;
            }
            return this.source.absolutePosition() - this.previousToken().fullWidth() + this.previousToken().leadingTriviaWidth();
        };
        ParserImpl.prototype.previousTokenEnd = function () {
            if (this.previousToken() === null) {
                return 0;
            }
            return this.previousTokenStart() + this.previousToken().width();
        };
        ParserImpl.prototype.currentNode = function () {
            var node = this.source.currentNode();
            if (node === null || node.parsedInStrictMode() !== this.isInStrictMode) {
                return null;
            }
            return node;
        };
        ParserImpl.prototype.currentToken = function () {
            return this.source.currentToken();
        };
        ParserImpl.prototype.currentTokenAllowingRegularExpression = function () {
            return this.source.currentTokenAllowingRegularExpression();
        };
        ParserImpl.prototype.peekToken = function (n) {
            return this.source.peekToken(n);
        };
        ParserImpl.prototype.eatAnyToken = function () {
            var token = this.currentToken();
            this.moveToNextToken();
            return token;
        };
        ParserImpl.prototype.moveToNextToken = function () {
            this.source.moveToNextToken();
        };
        ParserImpl.prototype.previousToken = function () {
            return this.source.previousToken();
        };
        ParserImpl.prototype.eatNode = function () {
            var node = this.source.currentNode();
            this.source.moveToNextNode();
            return node;
        };
        ParserImpl.prototype.eatToken = function (kind) {
            var token = this.currentToken();
            if (token.tokenKind === kind) {
                this.moveToNextToken();
                return token;
            }
            return this.createMissingToken(kind, token);
        };
        ParserImpl.prototype.tryEatToken = function (kind) {
            if (this.currentToken().tokenKind === kind) {
                return this.eatToken(kind);
            }
            return null;
        };
        ParserImpl.prototype.tryEatKeyword = function (kind) {
            if (this.currentToken().tokenKind === kind) {
                return this.eatKeyword(kind);
            }
            return null;
        };
        ParserImpl.prototype.eatKeyword = function (kind) {
            var token = this.currentToken();
            if (token.tokenKind === kind) {
                this.moveToNextToken();
                return token;
            }
            return this.createMissingToken(kind, token);
        };
        ParserImpl.isIdentifierName = function isIdentifierName(token) {
            return SyntaxFacts.isIdentifierName(token.tokenKind);
        };
        ParserImpl.prototype.isIdentifier = function (token) {
            var tokenKind = token.tokenKind;
            if (tokenKind === 11 /* IdentifierName */ ) {
                return true;
            }
            if (tokenKind >= 51 /* FirstFutureReservedStrictKeyword */ ) {
                if (tokenKind <= 59 /* LastFutureReservedStrictKeyword */ ) {
                    return !this.isInStrictMode;
                }
                return tokenKind <= 69 /* LastTypeScriptKeyword */ ;
            }
            return false;
        };
        ParserImpl.prototype.eatIdentifierNameToken = function () {
            var token = this.currentToken();
            if (ParserImpl.isIdentifierName(token)) {
                this.moveToNextToken();
                return token;
            }
            return this.createMissingToken(11 /* IdentifierName */ , token);
        };
        ParserImpl.prototype.eatIdentifierToken = function () {
            var token = this.currentToken();
            if (this.isIdentifier(token)) {
                this.moveToNextToken();
                return token;
            }
            return this.createMissingToken(11 /* IdentifierName */ , token);
        };
        ParserImpl.prototype.canEatAutomaticSemicolon = function (allowWithoutNewLine) {
            var token = this.currentToken();
            if (token.tokenKind === 10 /* EndOfFileToken */ ) {
                return true;
            }
            if (token.tokenKind === 71 /* CloseBraceToken */ ) {
                return true;
            }
            if (allowWithoutNewLine) {
                return true;
            }
            if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                return true;
            }
            return false;
        };
        ParserImpl.prototype.canEatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
            var token = this.currentToken();
            if (token.tokenKind === 78 /* SemicolonToken */ ) {
                return true;
            }
            return this.canEatAutomaticSemicolon(allowWithoutNewline);
        };
        ParserImpl.prototype.eatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
            var token = this.currentToken();
            if (token.tokenKind === 78 /* SemicolonToken */ ) {
                return this.eatToken(78 /* SemicolonToken */ );
            }
            if (this.canEatAutomaticSemicolon(allowWithoutNewline)) {
                var semicolonToken = Syntax.emptyToken(78 /* SemicolonToken */ );
                if (!this.options.allowAutomaticSemicolonInsertion()) {
                    this.addDiagnostic(new SyntaxDiagnostic(this.previousTokenEnd(), 0, 7 /* Automatic_semicolon_insertion_not_allowed */ , null));
                }
                return semicolonToken;
            }
            return this.eatToken(78 /* SemicolonToken */ );
        };
        ParserImpl.prototype.isKeyword = function (kind) {
            if (kind >= 15 /* FirstKeyword */ ) {
                if (kind <= 50 /* LastFutureReservedKeyword */ ) {
                    return true;
                }
                if (this.isInStrictMode) {
                    return kind <= 59 /* LastFutureReservedStrictKeyword */ ;
                }
            }
            return false;
        };
        ParserImpl.prototype.createMissingToken = function (expectedKind, actual) {
            var diagnostic = this.getExpectedTokenDiagnostic(expectedKind, actual);
            this.addDiagnostic(diagnostic);
            return Syntax.emptyToken(expectedKind);
        };
        ParserImpl.prototype.getExpectedTokenDiagnostic = function (expectedKind, actual) {
            var token = this.currentToken();
            if (SyntaxFacts.isAnyKeyword(expectedKind) || SyntaxFacts.isAnyPunctuation(expectedKind)) {
                return new SyntaxDiagnostic(this.currentTokenStart(), token.width(), 5 /* _0_expected */ , [
                    SyntaxFacts.getText(expectedKind)
                ]);
            } else {
                if (actual !== null && SyntaxFacts.isAnyKeyword(actual.tokenKind)) {
                    return new SyntaxDiagnostic(this.currentTokenStart(), token.width(), 6 /* Identifier_expected__0_is_a_keyword */ , [
                        SyntaxFacts.getText(actual.tokenKind)
                    ]);
                } else {
                    return new SyntaxDiagnostic(this.currentTokenStart(), token.width(), 3 /* Identifier_expected */ , null);
                }
            }
        };
        ParserImpl.getPrecedence = function getPrecedence(expressionKind) {
            switch(expressionKind) {
                case 170 /* CommaExpression */ :
                    return 1 /* CommaExpressionPrecedence */ ;
                case 171 /* AssignmentExpression */ :
                case 172 /* AddAssignmentExpression */ :
                case 173 /* SubtractAssignmentExpression */ :
                case 174 /* MultiplyAssignmentExpression */ :
                case 175 /* DivideAssignmentExpression */ :
                case 176 /* ModuloAssignmentExpression */ :
                case 177 /* AndAssignmentExpression */ :
                case 178 /* ExclusiveOrAssignmentExpression */ :
                case 179 /* OrAssignmentExpression */ :
                case 180 /* LeftShiftAssignmentExpression */ :
                case 181 /* SignedRightShiftAssignmentExpression */ :
                case 182 /* UnsignedRightShiftAssignmentExpression */ :
                    return 2 /* AssignmentExpressionPrecedence */ ;
                case 183 /* ConditionalExpression */ :
                    return 3 /* ConditionalExpressionPrecedence */ ;
                case 184 /* LogicalOrExpression */ :
                    return 5 /* LogicalOrExpressionPrecedence */ ;
                case 185 /* LogicalAndExpression */ :
                    return 6 /* LogicalAndExpressionPrecedence */ ;
                case 186 /* BitwiseOrExpression */ :
                    return 7 /* BitwiseOrExpressionPrecedence */ ;
                case 187 /* BitwiseExclusiveOrExpression */ :
                    return 8 /* BitwiseExclusiveOrExpressionPrecedence */ ;
                case 188 /* BitwiseAndExpression */ :
                    return 9 /* BitwiseAndExpressionPrecedence */ ;
                case 189 /* EqualsWithTypeConversionExpression */ :
                case 190 /* NotEqualsWithTypeConversionExpression */ :
                case 191 /* EqualsExpression */ :
                case 192 /* NotEqualsExpression */ :
                    return 10 /* EqualityExpressionPrecedence */ ;
                case 193 /* LessThanExpression */ :
                case 194 /* GreaterThanExpression */ :
                case 195 /* LessThanOrEqualExpression */ :
                case 196 /* GreaterThanOrEqualExpression */ :
                case 197 /* InstanceOfExpression */ :
                case 198 /* InExpression */ :
                    return 11 /* RelationalExpressionPrecedence */ ;
                case 199 /* LeftShiftExpression */ :
                case 200 /* SignedRightShiftExpression */ :
                case 201 /* UnsignedRightShiftExpression */ :
                    return 12 /* ShiftExpressionPrecdence */ ;
                case 205 /* AddExpression */ :
                case 206 /* SubtractExpression */ :
                    return 13 /* AdditiveExpressionPrecedence */ ;
                case 202 /* MultiplyExpression */ :
                case 203 /* DivideExpression */ :
                case 204 /* ModuloExpression */ :
                    return 14 /* MultiplicativeExpressionPrecedence */ ;
                case 161 /* PlusExpression */ :
                case 162 /* NegateExpression */ :
                case 163 /* BitwiseNotExpression */ :
                case 164 /* LogicalNotExpression */ :
                case 167 /* DeleteExpression */ :
                case 168 /* TypeOfExpression */ :
                case 169 /* VoidExpression */ :
                case 165 /* PreIncrementExpression */ :
                case 166 /* PreDecrementExpression */ :
                    return 15 /* UnaryExpressionPrecedence */ ;
            }
            throw Errors.invalidOperation();
        };
        ParserImpl.isDirectivePrologueElement = function isDirectivePrologueElement(node) {
            if (node.kind() === 146 /* ExpressionStatement */ ) {
                var expressionStatement = node;
                var expression = expressionStatement.expression;
                if (expression.kind() === 14 /* StringLiteral */ ) {
                    return true;
                }
            }
            return false;
        };
        ParserImpl.isUseStrictDirective = function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;
            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        };
        ParserImpl.prototype.addSkippedTokenAfterNodeOrToken = function (nodeOrToken, skippedToken) {
            if (nodeOrToken.isToken()) {
                return this.addSkippedTokenAfterToken(nodeOrToken, skippedToken);
            } else if (nodeOrToken.isNode()) {
                return this.addSkippedTokenAfterNode(nodeOrToken, skippedToken);
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.addSkippedTokenAfterNode = function (node, skippedToken) {
            var oldToken = node.lastToken();
            var newToken = this.addSkippedTokenAfterToken(oldToken, skippedToken);
            return node.replaceToken(oldToken, newToken);
        };
        ParserImpl.prototype.addSkippedTokensBeforeNode = function (node, skippedTokens) {
            if (skippedTokens.length > 0) {
                var oldToken = node.firstToken();
                var newToken = this.addSkippedTokensBeforeToken(oldToken, skippedTokens);
                return node.replaceToken(oldToken, newToken);
            }
            return node;
        };
        ParserImpl.prototype.addSkippedTokensBeforeToken = function (token, skippedTokens) {
            var leadingTrivia = [];
            for(var i = 0, n = skippedTokens.length; i < n; i++) {
                this.addSkippedTokenToTriviaArray(leadingTrivia, skippedTokens[i]);
            }
            this.addTriviaTo(token.leadingTrivia(), leadingTrivia);
            this.returnArray(skippedTokens);
            return token.withLeadingTrivia(Syntax.triviaList(leadingTrivia));
        };
        ParserImpl.prototype.addSkippedTokensAfterToken = function (token, skippedTokens) {
            if (skippedTokens.length === 0) {
                this.returnArray(skippedTokens);
                return token;
            }
            var trailingTrivia = token.trailingTrivia().toArray();
            for(var i = 0, n = skippedTokens.length; i < n; i++) {
                this.addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
            }
            this.returnArray(skippedTokens);
            return token.withTrailingTrivia(Syntax.triviaList(trailingTrivia));
        };
        ParserImpl.prototype.addSkippedTokenAfterToken = function (token, skippedToken) {
            var trailingTrivia = token.trailingTrivia().toArray();
            this.addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);
            return token.withTrailingTrivia(Syntax.triviaList(trailingTrivia));
        };
        ParserImpl.prototype.addSkippedTokenToTriviaArray = function (array, skippedToken) {
            this.addTriviaTo(skippedToken.leadingTrivia(), array);
            array.push(Syntax.trivia(8 /* SkippedTextTrivia */ , skippedToken.text()));
            this.addTriviaTo(skippedToken.trailingTrivia(), array);
        };
        ParserImpl.prototype.addTriviaTo = function (list, array) {
            for(var i = 0, n = list.count(); i < n; i++) {
                array.push(list.syntaxTriviaAt(i));
            }
        };
        ParserImpl.prototype.parseSyntaxTree = function () {
            var sourceUnit = this.parseSourceUnit();
            var allDiagnostics = this.source.tokenDiagnostics().concat(this.diagnostics);
            allDiagnostics.sort(function (a, b) {
                return a.position() - b.position();
            });
            return new SyntaxTree(sourceUnit, allDiagnostics);
        };
        ParserImpl.prototype.setStrictMode = function (isInStrictMode) {
            this.isInStrictMode = isInStrictMode;
            this.factory = isInStrictMode ? Syntax.strictModeFactory : Syntax.normalModeFactory;
        };
        ParserImpl.prototype.parseSourceUnit = function () {
            var savedIsInStrictMode = this.isInStrictMode;
            var result = this.parseSyntaxList(1 /* SourceUnit_ModuleElements */ , ParserImpl.updateStrictModeState);
            var moduleElements = result.list;
            this.setStrictMode(savedIsInStrictMode);
            var sourceUnit = this.factory.sourceUnit(moduleElements, this.currentToken());
            sourceUnit = this.addSkippedTokensBeforeNode(sourceUnit, result.skippedTokens);
            return sourceUnit;
        };
        ParserImpl.updateStrictModeState = function updateStrictModeState(parser, items) {
            if (!parser.isInStrictMode) {
                for(var i = 0; i < items.length; i++) {
                    var item = items[i];
                    if (!ParserImpl.isDirectivePrologueElement(item)) {
                        return;
                    }
                }
                parser.setStrictMode(ParserImpl.isUseStrictDirective(items[items.length - 1]));
            }
        };
        ParserImpl.prototype.isModuleElement = function () {
            if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                return true;
            }
            return this.isImportDeclaration() || this.isModuleDeclaration() || this.isInterfaceDeclaration() || this.isClassDeclaration() || this.isEnumDeclaration() || this.isStatement();
        };
        ParserImpl.prototype.parseModuleElement = function () {
            if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                return this.eatNode();
            }
            if (this.isImportDeclaration()) {
                return this.parseImportDeclaration();
            } else if (this.isModuleDeclaration()) {
                return this.parseModuleDeclaration();
            } else if (this.isInterfaceDeclaration()) {
                return this.parseInterfaceDeclaration();
            } else if (this.isClassDeclaration()) {
                return this.parseClassDeclaration();
            } else if (this.isEnumDeclaration()) {
                return this.parseEnumDeclaration();
            } else if (this.isStatement()) {
                return this.parseStatement();
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.isImportDeclaration = function () {
            return this.currentToken().tokenKind === 49 /* ImportKeyword */  && ParserImpl.isIdentifierName(this.peekToken(1)) && this.peekToken(2).tokenKind === 107 /* EqualsToken */ ;
        };
        ParserImpl.prototype.parseImportDeclaration = function () {
            var importKeyword = this.eatKeyword(49 /* ImportKeyword */ );
            var identifier = this.eatIdentifierToken();
            var equalsToken = this.eatToken(107 /* EqualsToken */ );
            var moduleReference = this.parseModuleReference();
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.importDeclaration(importKeyword, identifier, equalsToken, moduleReference, semicolonToken);
        };
        ParserImpl.prototype.parseModuleReference = function () {
            if (this.isExternalModuleReference()) {
                return this.parseExternalModuleReference();
            } else {
                return this.parseModuleNameModuleReference();
            }
        };
        ParserImpl.prototype.isExternalModuleReference = function () {
            return this.currentToken().tokenKind === 66 /* ModuleKeyword */  && this.peekToken(1).tokenKind === 72 /* OpenParenToken */ ;
        };
        ParserImpl.prototype.parseExternalModuleReference = function () {
            var moduleKeyword = this.eatKeyword(66 /* ModuleKeyword */ );
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var stringLiteral = this.eatToken(14 /* StringLiteral */ );
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            return this.factory.externalModuleReference(moduleKeyword, openParenToken, stringLiteral, closeParenToken);
        };
        ParserImpl.prototype.parseModuleNameModuleReference = function () {
            var name = this.parseName();
            return this.factory.moduleNameModuleReference(name);
        };
        ParserImpl.prototype.parseIdentifierName = function () {
            var identifierName = this.eatIdentifierNameToken();
            return identifierName;
        };
        ParserImpl.prototype.isName = function () {
            return this.isIdentifier(this.currentToken());
        };
        ParserImpl.prototype.tryParseTypeArgumentList = function (inExpression) {
            if (this.currentToken().kind() !== 80 /* LessThanToken */ ) {
                return null;
            }
            if (!inExpression) {
                var lessThanToken = this.eatToken(80 /* LessThanToken */ );
                var result = this.parseSeparatedSyntaxList(131072 /* TypeArgumentList_Types */ );
                var typeArguments = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);
                var greaterThanToken = this.eatToken(81 /* GreaterThanToken */ );
                return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
            }
            var rewindPoint = this.getRewindPoint();
            try  {
                var lessThanToken = this.eatToken(80 /* LessThanToken */ );
                var result = this.parseSeparatedSyntaxList(131072 /* TypeArgumentList_Types */ );
                var typeArguments = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);
                var greaterThanToken = this.eatToken(81 /* GreaterThanToken */ );
                if (greaterThanToken.fullWidth() === 0 || !this.canFollowTypeArgumentListInExpression(this.currentToken().kind())) {
                    this.rewind(rewindPoint);
                    return null;
                }
                return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
            } finally {
                this.releaseRewindPoint(rewindPoint);
            }
        };
        ParserImpl.prototype.canFollowTypeArgumentListInExpression = function (kind) {
            switch(kind) {
                case 72 /* OpenParenToken */ :
                case 76 /* DotToken */ :
                case 73 /* CloseParenToken */ :
                case 75 /* CloseBracketToken */ :
                case 106 /* ColonToken */ :
                case 78 /* SemicolonToken */ :
                case 79 /* CommaToken */ :
                case 105 /* QuestionToken */ :
                case 84 /* EqualsEqualsToken */ :
                case 87 /* EqualsEqualsEqualsToken */ :
                case 86 /* ExclamationEqualsToken */ :
                case 88 /* ExclamationEqualsEqualsToken */ :
                case 103 /* AmpersandAmpersandToken */ :
                case 104 /* BarBarToken */ :
                case 100 /* CaretToken */ :
                case 98 /* AmpersandToken */ :
                case 99 /* BarToken */ :
                case 71 /* CloseBraceToken */ :
                case 10 /* EndOfFileToken */ :
                    return true;
                default:
                    return false;
            }
        };
        ParserImpl.prototype.parseName = function () {
            var shouldContinue = this.isIdentifier(this.currentToken());
            var current = this.eatIdentifierToken();
            while(shouldContinue && this.currentToken().tokenKind === 76 /* DotToken */ ) {
                var dotToken = this.eatToken(76 /* DotToken */ );
                shouldContinue = ParserImpl.isIdentifierName(this.currentToken());
                var identifier = this.eatIdentifierNameToken();
                current = this.factory.qualifiedName(current, dotToken, identifier);
            }
            return current;
        };
        ParserImpl.prototype.isEnumDeclaration = function () {
            if (this.currentToken().tokenKind === 47 /* ExportKeyword */  && this.peekToken(1).tokenKind === 46 /* EnumKeyword */ ) {
                return true;
            }
            return this.currentToken().tokenKind === 46 /* EnumKeyword */ ;
        };
        ParserImpl.prototype.parseEnumDeclaration = function () {
            var exportKeyword = this.tryEatKeyword(47 /* ExportKeyword */ );
            var enumKeyword = this.eatKeyword(46 /* EnumKeyword */ );
            var identifier = this.eatIdentifierToken();
            var openBraceToken = this.eatToken(70 /* OpenBraceToken */ );
            var variableDeclarators = Syntax.emptySeparatedList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(256 /* EnumDeclaration_VariableDeclarators */ );
                variableDeclarators = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }
            var closeBraceToken = this.eatToken(71 /* CloseBraceToken */ );
            return this.factory.enumDeclaration(exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken);
        };
        ParserImpl.prototype.isClassDeclaration = function () {
            var token0 = this.currentToken();
            if (token0.tokenKind === 47 /* ExportKeyword */  && this.peekToken(1).tokenKind === 44 /* ClassKeyword */ ) {
                return true;
            }
            if (token0.tokenKind === 64 /* DeclareKeyword */  && this.peekToken(1).tokenKind === 44 /* ClassKeyword */ ) {
                return true;
            }
            return token0.tokenKind === 44 /* ClassKeyword */ ;
        };
        ParserImpl.prototype.parseClassDeclaration = function () {
            var exportKeyword = this.tryEatKeyword(47 /* ExportKeyword */ );
            var declareKeyword = this.tryEatKeyword(64 /* DeclareKeyword */ );
            var classKeyword = this.eatKeyword(44 /* ClassKeyword */ );
            var identifier = this.eatIdentifierToken();
            var typeParameterList = this.parseOptionalTypeParameterList(false);
            var extendsClause = null;
            if (this.isExtendsClause()) {
                extendsClause = this.parseExtendsClause();
            }
            var implementsClause = null;
            if (this.isImplementsClause()) {
                implementsClause = this.parseImplementsClause();
            }
            var openBraceToken = this.eatToken(70 /* OpenBraceToken */ );
            var classElements = Syntax.emptyList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(2 /* ClassDeclaration_ClassElements */ );
                classElements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }
            var closeBraceToken = this.eatToken(71 /* CloseBraceToken */ );
            return this.factory.classDeclaration(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken);
        };
        ParserImpl.prototype.isConstructorDeclaration = function () {
            return this.currentToken().tokenKind === 63 /* ConstructorKeyword */ ;
        };
        ParserImpl.prototype.isMemberAccessorDeclaration = function () {
            var index = 0;
            if (this.currentToken().tokenKind === 57 /* PublicKeyword */  || this.currentToken().tokenKind === 55 /* PrivateKeyword */ ) {
                index++;
            }
            if (this.peekToken(index).tokenKind === 58 /* StaticKeyword */ ) {
                index++;
            }
            if (this.peekToken(index).tokenKind !== 65 /* GetKeyword */  && this.peekToken(index).tokenKind !== 68 /* SetKeyword */ ) {
                return false;
            }
            index++;
            return this.isIdentifier(this.peekToken(index));
        };
        ParserImpl.prototype.parseMemberAccessorDeclaration = function () {
            var publicOrPrivateKeyword = null;
            if (this.currentToken().tokenKind === 57 /* PublicKeyword */  || this.currentToken().tokenKind === 55 /* PrivateKeyword */ ) {
                publicOrPrivateKeyword = this.eatAnyToken();
            }
            var staticKeyword = this.tryEatKeyword(58 /* StaticKeyword */ );
            if (this.currentToken().tokenKind === 65 /* GetKeyword */ ) {
                return this.parseGetMemberAccessorDeclaration(publicOrPrivateKeyword, staticKeyword);
            } else if (this.currentToken().tokenKind === 68 /* SetKeyword */ ) {
                return this.parseSetMemberAccessorDeclaration(publicOrPrivateKeyword, staticKeyword);
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.parseGetMemberAccessorDeclaration = function (publicOrPrivateKeyword, staticKeyword) {
            var getKeyword = this.eatKeyword(65 /* GetKeyword */ );
            var identifier = this.eatIdentifierToken();
            var parameterList = this.parseParameterList();
            var typeAnnotation = this.parseOptionalTypeAnnotation();
            var block = this.parseBlock();
            return this.factory.getMemberAccessorDeclaration(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block);
        };
        ParserImpl.prototype.parseSetMemberAccessorDeclaration = function (publicOrPrivateKeyword, staticKeyword) {
            var setKeyword = this.eatKeyword(68 /* SetKeyword */ );
            var identifier = this.eatIdentifierToken();
            var parameterList = this.parseParameterList();
            var block = this.parseBlock();
            return this.factory.setMemberAccessorDeclaration(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block);
        };
        ParserImpl.prototype.isMemberVariableDeclaration = function () {
            var index = 0;
            if (this.currentToken().tokenKind === 57 /* PublicKeyword */  || this.currentToken().tokenKind === 55 /* PrivateKeyword */ ) {
                index++;
                if (this.peekToken(index).tokenKind === 71 /* CloseBraceToken */  || this.peekToken(index).tokenKind === 10 /* EndOfFileToken */ ) {
                    return true;
                }
            }
            if (this.peekToken(index).tokenKind === 58 /* StaticKeyword */ ) {
                index++;
                if (this.peekToken(index).tokenKind === 71 /* CloseBraceToken */  || this.peekToken(index).tokenKind === 10 /* EndOfFileToken */ ) {
                    return true;
                }
            }
            return this.isIdentifier(this.peekToken(index));
        };
        ParserImpl.prototype.isClassElement = function () {
            if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                return true;
            }
            return this.isConstructorDeclaration() || this.isMemberFunctionDeclaration() || this.isMemberAccessorDeclaration() || this.isMemberVariableDeclaration();
        };
        ParserImpl.prototype.parseConstructorDeclaration = function () {
            var constructorKeyword = this.eatKeyword(63 /* ConstructorKeyword */ );
            var parameterList = this.parseParameterList();
            var semicolonToken = null;
            var block = null;
            if (this.isBlock()) {
                block = this.parseBlock();
            } else {
                semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
            }
            return this.factory.constructorDeclaration(constructorKeyword, parameterList, block, semicolonToken);
        };
        ParserImpl.prototype.isMemberFunctionDeclaration = function () {
            var index = 0;
            var token0KeywordKind = this.currentToken().tokenKind;
            if (token0KeywordKind === 57 /* PublicKeyword */  || token0KeywordKind === 55 /* PrivateKeyword */ ) {
                index++;
            }
            if (this.peekToken(index).tokenKind === 58 /* StaticKeyword */ ) {
                index++;
            }
            return this.isFunctionSignature(index);
        };
        ParserImpl.prototype.parseMemberFunctionDeclaration = function () {
            var publicOrPrivateKeyword = null;
            if (this.currentToken().tokenKind === 57 /* PublicKeyword */  || this.currentToken().tokenKind === 55 /* PrivateKeyword */ ) {
                publicOrPrivateKeyword = this.eatAnyToken();
            }
            var staticKeyword = this.tryEatKeyword(58 /* StaticKeyword */ );
            var functionSignature = this.parseFunctionSignature();
            var block = null;
            var semicolon = null;
            if (this.isBlock()) {
                block = this.parseBlock();
            } else {
                semicolon = this.eatExplicitOrAutomaticSemicolon(false);
            }
            return this.factory.memberFunctionDeclaration(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolon);
        };
        ParserImpl.prototype.parseMemberVariableDeclaration = function () {
            var publicOrPrivateKeyword = null;
            if (this.currentToken().tokenKind === 57 /* PublicKeyword */  || this.currentToken().tokenKind === 55 /* PrivateKeyword */ ) {
                publicOrPrivateKeyword = this.eatAnyToken();
            }
            var staticKeyword = this.tryEatKeyword(58 /* StaticKeyword */ );
            var variableDeclarator = this.parseVariableDeclarator(true);
            var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.memberVariableDeclaration(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolon);
        };
        ParserImpl.prototype.parseClassElement = function () {
            if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                return this.eatNode();
            }
            if (this.isConstructorDeclaration()) {
                return this.parseConstructorDeclaration();
            } else if (this.isMemberFunctionDeclaration()) {
                return this.parseMemberFunctionDeclaration();
            } else if (this.isMemberAccessorDeclaration()) {
                return this.parseMemberAccessorDeclaration();
            } else if (this.isMemberVariableDeclaration()) {
                return this.parseMemberVariableDeclaration();
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.isFunctionDeclaration = function () {
            var token0KeywordKind = this.currentToken().tokenKind;
            if (token0KeywordKind === 27 /* FunctionKeyword */ ) {
                return true;
            }
            if (token0KeywordKind === 47 /* ExportKeyword */  && this.peekToken(1).tokenKind === 27 /* FunctionKeyword */ ) {
                return true;
            }
            return token0KeywordKind === 64 /* DeclareKeyword */  && this.peekToken(1).tokenKind === 27 /* FunctionKeyword */ ;
        };
        ParserImpl.prototype.parseFunctionDeclaration = function () {
            var exportKeyword = this.tryEatKeyword(47 /* ExportKeyword */ );
            var declareKeyword = this.tryEatKeyword(64 /* DeclareKeyword */ );
            var functionKeyword = this.eatKeyword(27 /* FunctionKeyword */ );
            var functionSignature = this.parseFunctionSignature();
            var semicolonToken = null;
            var block = null;
            if (this.isBlock()) {
                block = this.parseBlock();
            } else {
                semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
            }
            return this.factory.functionDeclaration(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken);
        };
        ParserImpl.prototype.isModuleDeclaration = function () {
            var token0 = this.currentToken();
            if (token0.tokenKind === 47 /* ExportKeyword */  && this.peekToken(1).tokenKind === 66 /* ModuleKeyword */ ) {
                return true;
            }
            if (token0.tokenKind === 64 /* DeclareKeyword */  && this.peekToken(1).tokenKind === 66 /* ModuleKeyword */ ) {
                return true;
            }
            if (token0.tokenKind === 66 /* ModuleKeyword */ ) {
                var token1 = this.peekToken(1);
                if (token1.tokenKind === 70 /* OpenBraceToken */ ) {
                    return true;
                }
                if (ParserImpl.isIdentifierName(token1)) {
                    var token2 = this.peekToken(2);
                    if (token2.tokenKind === 70 /* OpenBraceToken */ ) {
                        return true;
                    }
                    if (token2.tokenKind === 76 /* DotToken */ ) {
                        return true;
                    }
                }
            }
            return false;
        };
        ParserImpl.prototype.parseModuleDeclaration = function () {
            var exportKeyword = this.tryEatKeyword(47 /* ExportKeyword */ );
            var declareKeyword = this.tryEatKeyword(64 /* DeclareKeyword */ );
            var moduleKeyword = this.eatKeyword(66 /* ModuleKeyword */ );
            var moduleName = null;
            var stringLiteral = null;
            if (this.currentToken().tokenKind === 14 /* StringLiteral */ ) {
                stringLiteral = this.eatToken(14 /* StringLiteral */ );
            } else {
                moduleName = this.parseName();
            }
            var openBraceToken = this.eatToken(70 /* OpenBraceToken */ );
            var moduleElements = Syntax.emptyList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(4 /* ModuleDeclaration_ModuleElements */ );
                moduleElements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }
            var closeBraceToken = this.eatToken(71 /* CloseBraceToken */ );
            return this.factory.moduleDeclaration(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken);
        };
        ParserImpl.prototype.isInterfaceDeclaration = function () {
            if (this.currentToken().tokenKind === 47 /* ExportKeyword */  && this.peekToken(1).tokenKind === 52 /* InterfaceKeyword */ ) {
                return true;
            }
            return this.currentToken().tokenKind === 52 /* InterfaceKeyword */  && this.isIdentifier(this.peekToken(1));
        };
        ParserImpl.prototype.parseInterfaceDeclaration = function () {
            var exportKeyword = this.tryEatKeyword(47 /* ExportKeyword */ );
            var interfaceKeyword = this.eatKeyword(52 /* InterfaceKeyword */ );
            var identifier = this.eatIdentifierToken();
            var typeParameterList = this.parseOptionalTypeParameterList(false);
            var extendsClause = null;
            if (this.isExtendsClause()) {
                extendsClause = this.parseExtendsClause();
            }
            var objectType = this.parseObjectType();
            return this.factory.interfaceDeclaration(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, objectType);
        };
        ParserImpl.prototype.parseObjectType = function () {
            var openBraceToken = this.eatToken(70 /* OpenBraceToken */ );
            var typeMembers = Syntax.emptySeparatedList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(512 /* ObjectType_TypeMembers */ );
                typeMembers = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }
            var closeBraceToken = this.eatToken(71 /* CloseBraceToken */ );
            return this.factory.objectType(openBraceToken, typeMembers, closeBraceToken);
        };
        ParserImpl.prototype.isTypeMember = function () {
            if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                return true;
            }
            return this.isCallSignature(0) || this.isConstructSignature() || this.isIndexSignature() || this.isFunctionSignature(0) || this.isPropertySignature();
        };
        ParserImpl.prototype.parseTypeMember = function () {
            if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                return this.eatNode();
            }
            if (this.isCallSignature(0)) {
                return this.parseCallSignature(false);
            } else if (this.isConstructSignature()) {
                return this.parseConstructSignature();
            } else if (this.isIndexSignature()) {
                return this.parseIndexSignature();
            } else if (this.isFunctionSignature(0)) {
                return this.parseFunctionSignature();
            } else if (this.isPropertySignature()) {
                return this.parsePropertySignature();
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.parseConstructSignature = function () {
            var newKeyword = this.eatKeyword(31 /* NewKeyword */ );
            var callSignature = this.parseCallSignature(false);
            return this.factory.constructSignature(newKeyword, callSignature);
        };
        ParserImpl.prototype.parseIndexSignature = function () {
            var openBracketToken = this.eatToken(74 /* OpenBracketToken */ );
            var parameter = this.parseParameter();
            var closeBracketToken = this.eatToken(75 /* CloseBracketToken */ );
            var typeAnnotation = this.parseOptionalTypeAnnotation();
            return this.factory.indexSignature(openBracketToken, parameter, closeBracketToken, typeAnnotation);
        };
        ParserImpl.prototype.parseFunctionSignature = function () {
            var identifier = this.eatIdentifierToken();
            var questionToken = this.tryEatToken(105 /* QuestionToken */ );
            var callSignature = this.parseCallSignature(false);
            return this.factory.functionSignature(identifier, questionToken, callSignature);
        };
        ParserImpl.prototype.parsePropertySignature = function () {
            var identifier = this.eatIdentifierToken();
            var questionToken = this.tryEatToken(105 /* QuestionToken */ );
            var typeAnnotation = this.parseOptionalTypeAnnotation();
            return this.factory.propertySignature(identifier, questionToken, typeAnnotation);
        };
        ParserImpl.prototype.isCallSignature = function (tokenIndex) {
            var tokenKind = this.peekToken(tokenIndex).tokenKind;
            return tokenKind === 72 /* OpenParenToken */  || tokenKind == 80 /* LessThanToken */ ;
        };
        ParserImpl.prototype.isConstructSignature = function () {
            return this.currentToken().tokenKind === 31 /* NewKeyword */ ;
        };
        ParserImpl.prototype.isIndexSignature = function () {
            return this.currentToken().tokenKind === 74 /* OpenBracketToken */ ;
        };
        ParserImpl.prototype.isFunctionSignature = function (tokenIndex) {
            if (this.isIdentifier(this.peekToken(tokenIndex))) {
                if (this.isCallSignature(tokenIndex + 1)) {
                    return true;
                }
                if (this.peekToken(tokenIndex + 1).tokenKind === 105 /* QuestionToken */  && this.isCallSignature(tokenIndex + 2)) {
                    return true;
                }
            }
            return false;
        };
        ParserImpl.prototype.isPropertySignature = function () {
            return this.isIdentifier(this.currentToken());
        };
        ParserImpl.prototype.isExtendsClause = function () {
            return this.currentToken().tokenKind === 48 /* ExtendsKeyword */ ;
        };
        ParserImpl.prototype.parseExtendsClause = function () {
            var extendsKeyword = this.eatKeyword(48 /* ExtendsKeyword */ );
            var result = this.parseSeparatedSyntaxList(1024 /* ExtendsOrImplementsClause_TypeNameList */ );
            var typeNames = result.list;
            extendsKeyword = this.addSkippedTokensAfterToken(extendsKeyword, result.skippedTokens);
            return this.factory.extendsClause(extendsKeyword, typeNames);
        };
        ParserImpl.prototype.isImplementsClause = function () {
            return this.currentToken().tokenKind === 51 /* ImplementsKeyword */ ;
        };
        ParserImpl.prototype.parseImplementsClause = function () {
            var implementsKeyword = this.eatKeyword(51 /* ImplementsKeyword */ );
            var result = this.parseSeparatedSyntaxList(1024 /* ExtendsOrImplementsClause_TypeNameList */ );
            var typeNames = result.list;
            implementsKeyword = this.addSkippedTokensAfterToken(implementsKeyword, result.skippedTokens);
            return this.factory.implementsClause(implementsKeyword, typeNames);
        };
        ParserImpl.prototype.isStatement = function () {
            if (this.currentNode() !== null && this.currentNode().isStatement()) {
                return true;
            }
            switch(this.currentToken().tokenKind) {
                case 57 /* PublicKeyword */ :
                case 55 /* PrivateKeyword */ :
                case 58 /* StaticKeyword */ :
                    if (this.isClassElement()) {
                        return false;
                    }
            }
            return this.isVariableStatement() || this.isLabeledStatement() || this.isFunctionDeclaration() || this.isIfStatement() || this.isBlock() || this.isExpressionStatement() || this.isReturnStatement() || this.isSwitchStatement() || this.isThrowStatement() || this.isBreakStatement() || this.isContinueStatement() || this.isForOrForInStatement() || this.isEmptyStatement() || this.isWhileStatement() || this.isWithStatement() || this.isDoStatement() || this.isTryStatement() || this.isDebuggerStatement();
        };
        ParserImpl.prototype.parseStatement = function () {
            if (this.currentNode() !== null && this.currentNode().isStatement()) {
                return this.eatNode();
            }
            if (this.isVariableStatement()) {
                return this.parseVariableStatement();
            } else if (this.isLabeledStatement()) {
                return this.parseLabeledStatement();
            } else if (this.isFunctionDeclaration()) {
                return this.parseFunctionDeclaration();
            } else if (this.isIfStatement()) {
                return this.parseIfStatement();
            } else if (this.isBlock()) {
                return this.parseBlock();
            } else if (this.isReturnStatement()) {
                return this.parseReturnStatement();
            } else if (this.isSwitchStatement()) {
                return this.parseSwitchStatement();
            } else if (this.isThrowStatement()) {
                return this.parseThrowStatement();
            } else if (this.isBreakStatement()) {
                return this.parseBreakStatement();
            } else if (this.isContinueStatement()) {
                return this.parseContinueStatement();
            } else if (this.isForOrForInStatement()) {
                return this.parseForOrForInStatement();
            } else if (this.isEmptyStatement()) {
                return this.parseEmptyStatement();
            } else if (this.isWhileStatement()) {
                return this.parseWhileStatement();
            } else if (this.isWithStatement()) {
                return this.parseWithStatement();
            } else if (this.isDoStatement()) {
                return this.parseDoStatement();
            } else if (this.isTryStatement()) {
                return this.parseTryStatement();
            } else if (this.isDebuggerStatement()) {
                return this.parseDebuggerStatement();
            } else {
                return this.parseExpressionStatement();
            }
        };
        ParserImpl.prototype.isDebuggerStatement = function () {
            return this.currentToken().tokenKind === 19 /* DebuggerKeyword */ ;
        };
        ParserImpl.prototype.parseDebuggerStatement = function () {
            var debuggerKeyword = this.eatKeyword(19 /* DebuggerKeyword */ );
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.debuggerStatement(debuggerKeyword, semicolonToken);
        };
        ParserImpl.prototype.isDoStatement = function () {
            return this.currentToken().tokenKind === 22 /* DoKeyword */ ;
        };
        ParserImpl.prototype.parseDoStatement = function () {
            var doKeyword = this.eatKeyword(22 /* DoKeyword */ );
            var statement = this.parseStatement();
            var whileKeyword = this.eatKeyword(42 /* WhileKeyword */ );
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var condition = this.parseExpression(true);
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(true);
            return this.factory.doStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
        };
        ParserImpl.prototype.isLabeledStatement = function () {
            return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === 106 /* ColonToken */ ;
        };
        ParserImpl.prototype.parseLabeledStatement = function () {
            var identifier = this.eatIdentifierToken();
            var colonToken = this.eatToken(106 /* ColonToken */ );
            var statement = this.parseStatement();
            return this.factory.labeledStatement(identifier, colonToken, statement);
        };
        ParserImpl.prototype.isTryStatement = function () {
            return this.currentToken().tokenKind === 38 /* TryKeyword */ ;
        };
        ParserImpl.prototype.parseTryStatement = function () {
            var tryKeyword = this.eatKeyword(38 /* TryKeyword */ );
            var savedListParsingState = this.listParsingState;
            this.listParsingState |= 64 /* TryBlock_Statements */ ;
            var block = this.parseBlock();
            this.listParsingState = savedListParsingState;
            var catchClause = null;
            if (this.isCatchClause()) {
                catchClause = this.parseCatchClause();
            }
            var finallyClause = null;
            if (catchClause === null || this.isFinallyClause()) {
                finallyClause = this.parseFinallyClause();
            }
            return this.factory.tryStatement(tryKeyword, block, catchClause, finallyClause);
        };
        ParserImpl.prototype.isCatchClause = function () {
            return this.currentToken().tokenKind === 17 /* CatchKeyword */ ;
        };
        ParserImpl.prototype.parseCatchClause = function () {
            var catchKeyword = this.eatKeyword(17 /* CatchKeyword */ );
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var identifier = this.eatIdentifierToken();
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var savedListParsingState = this.listParsingState;
            this.listParsingState |= 128 /* CatchBlock_Statements */ ;
            var block = this.parseBlock();
            this.listParsingState = savedListParsingState;
            return this.factory.catchClause(catchKeyword, openParenToken, identifier, closeParenToken, block);
        };
        ParserImpl.prototype.isFinallyClause = function () {
            return this.currentToken().tokenKind === 25 /* FinallyKeyword */ ;
        };
        ParserImpl.prototype.parseFinallyClause = function () {
            var finallyKeyword = this.eatKeyword(25 /* FinallyKeyword */ );
            var block = this.parseBlock();
            return this.factory.finallyClause(finallyKeyword, block);
        };
        ParserImpl.prototype.isWithStatement = function () {
            return this.currentToken().tokenKind === 43 /* WithKeyword */ ;
        };
        ParserImpl.prototype.parseWithStatement = function () {
            var withKeyword = this.eatKeyword(43 /* WithKeyword */ );
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var condition = this.parseExpression(true);
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var statement = this.parseStatement();
            return this.factory.withStatement(withKeyword, openParenToken, condition, closeParenToken, statement);
        };
        ParserImpl.prototype.isWhileStatement = function () {
            return this.currentToken().tokenKind === 42 /* WhileKeyword */ ;
        };
        ParserImpl.prototype.parseWhileStatement = function () {
            var whileKeyword = this.eatKeyword(42 /* WhileKeyword */ );
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var condition = this.parseExpression(true);
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var statement = this.parseStatement();
            return this.factory.whileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
        };
        ParserImpl.prototype.isEmptyStatement = function () {
            return this.currentToken().tokenKind === 78 /* SemicolonToken */ ;
        };
        ParserImpl.prototype.parseEmptyStatement = function () {
            var semicolonToken = this.eatToken(78 /* SemicolonToken */ );
            return this.factory.emptyStatement(semicolonToken);
        };
        ParserImpl.prototype.isForOrForInStatement = function () {
            return this.currentToken().tokenKind === 26 /* ForKeyword */ ;
        };
        ParserImpl.prototype.parseForOrForInStatement = function () {
            var forKeyword = this.eatKeyword(26 /* ForKeyword */ );
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var currentToken = this.currentToken();
            if (currentToken.tokenKind === 40 /* VarKeyword */ ) {
                return this.parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
            } else if (currentToken.tokenKind === 78 /* SemicolonToken */ ) {
                return this.parseForStatement(forKeyword, openParenToken);
            } else {
                return this.parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
            }
        };
        ParserImpl.prototype.parseForOrForInStatementWithVariableDeclaration = function (forKeyword, openParenToken) {
            var variableDeclaration = this.parseVariableDeclaration(false);
            if (this.currentToken().tokenKind === 29 /* InKeyword */ ) {
                return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            }
            return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
        };
        ParserImpl.prototype.parseForInStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
            var inKeyword = this.eatKeyword(29 /* InKeyword */ );
            var expression = this.parseExpression(true);
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var statement = this.parseStatement();
            return this.factory.forInStatement(forKeyword, openParenToken, variableDeclaration, initializer, inKeyword, expression, closeParenToken, statement);
        };
        ParserImpl.prototype.parseForOrForInStatementWithInitializer = function (forKeyword, openParenToken) {
            var initializer = this.parseExpression(false);
            if (this.currentToken().tokenKind === 29 /* InKeyword */ ) {
                return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            } else {
                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }
        };
        ParserImpl.prototype.parseForStatement = function (forKeyword, openParenToken) {
            var initializer = null;
            if (this.currentToken().tokenKind !== 78 /* SemicolonToken */  && this.currentToken().tokenKind !== 73 /* CloseParenToken */  && this.currentToken().tokenKind !== 10 /* EndOfFileToken */ ) {
                initializer = this.parseExpression(false);
            }
            return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
        };
        ParserImpl.prototype.parseForStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
            var firstSemicolonToken = this.eatToken(78 /* SemicolonToken */ );
            var condition = null;
            if (this.currentToken().tokenKind !== 78 /* SemicolonToken */  && this.currentToken().tokenKind !== 73 /* CloseParenToken */  && this.currentToken().tokenKind !== 10 /* EndOfFileToken */ ) {
                condition = this.parseExpression(true);
            }
            var secondSemicolonToken = this.eatToken(78 /* SemicolonToken */ );
            var incrementor = null;
            if (this.currentToken().tokenKind !== 73 /* CloseParenToken */  && this.currentToken().tokenKind !== 10 /* EndOfFileToken */ ) {
                incrementor = this.parseExpression(true);
            }
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var statement = this.parseStatement();
            return this.factory.forStatement(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement);
        };
        ParserImpl.prototype.isBreakStatement = function () {
            return this.currentToken().tokenKind === 15 /* BreakKeyword */ ;
        };
        ParserImpl.prototype.parseBreakStatement = function () {
            var breakKeyword = this.eatKeyword(15 /* BreakKeyword */ );
            var identifier = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }
            }
            var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.breakStatement(breakKeyword, identifier, semicolon);
        };
        ParserImpl.prototype.isContinueStatement = function () {
            return this.currentToken().tokenKind === 18 /* ContinueKeyword */ ;
        };
        ParserImpl.prototype.parseContinueStatement = function () {
            var continueKeyword = this.eatKeyword(18 /* ContinueKeyword */ );
            var identifier = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }
            }
            var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.continueStatement(continueKeyword, identifier, semicolon);
        };
        ParserImpl.prototype.isSwitchStatement = function () {
            return this.currentToken().tokenKind === 34 /* SwitchKeyword */ ;
        };
        ParserImpl.prototype.parseSwitchStatement = function () {
            var switchKeyword = this.eatKeyword(34 /* SwitchKeyword */ );
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var expression = this.parseExpression(true);
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var openBraceToken = this.eatToken(70 /* OpenBraceToken */ );
            var switchClauses = Syntax.emptyList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(8 /* SwitchStatement_SwitchClauses */ );
                switchClauses = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }
            var closeBraceToken = this.eatToken(71 /* CloseBraceToken */ );
            return this.factory.switchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken);
        };
        ParserImpl.prototype.isCaseSwitchClause = function () {
            return this.currentToken().tokenKind === 16 /* CaseKeyword */ ;
        };
        ParserImpl.prototype.isDefaultSwitchClause = function () {
            return this.currentToken().tokenKind === 20 /* DefaultKeyword */ ;
        };
        ParserImpl.prototype.isSwitchClause = function () {
            if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                return true;
            }
            return this.isCaseSwitchClause() || this.isDefaultSwitchClause();
        };
        ParserImpl.prototype.parseSwitchClause = function () {
            if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                return this.eatNode();
            }
            if (this.isCaseSwitchClause()) {
                return this.parseCaseSwitchClause();
            } else if (this.isDefaultSwitchClause()) {
                return this.parseDefaultSwitchClause();
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.parseCaseSwitchClause = function () {
            var caseKeyword = this.eatKeyword(16 /* CaseKeyword */ );
            var expression = this.parseExpression(true);
            var colonToken = this.eatToken(106 /* ColonToken */ );
            var statements = Syntax.emptyList;
            if (colonToken.fullWidth() > 0) {
                var result = this.parseSyntaxList(16 /* SwitchClause_Statements */ );
                statements = result.list;
                colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
            }
            return this.factory.caseSwitchClause(caseKeyword, expression, colonToken, statements);
        };
        ParserImpl.prototype.parseDefaultSwitchClause = function () {
            var defaultKeyword = this.eatKeyword(20 /* DefaultKeyword */ );
            var colonToken = this.eatToken(106 /* ColonToken */ );
            var statements = Syntax.emptyList;
            if (colonToken.fullWidth() > 0) {
                var result = this.parseSyntaxList(16 /* SwitchClause_Statements */ );
                statements = result.list;
                colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
            }
            return this.factory.defaultSwitchClause(defaultKeyword, colonToken, statements);
        };
        ParserImpl.prototype.isThrowStatement = function () {
            return this.currentToken().tokenKind === 36 /* ThrowKeyword */ ;
        };
        ParserImpl.prototype.parseThrowStatement = function () {
            var throwKeyword = this.eatKeyword(36 /* ThrowKeyword */ );
            var expression = null;
            if (this.canEatExplicitOrAutomaticSemicolon(false)) {
                var token = this.createMissingToken(11 /* IdentifierName */ , null);
                expression = token;
            } else {
                expression = this.parseExpression(true);
            }
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.throwStatement(throwKeyword, expression, semicolonToken);
        };
        ParserImpl.prototype.isReturnStatement = function () {
            return this.currentToken().tokenKind === 33 /* ReturnKeyword */ ;
        };
        ParserImpl.prototype.parseReturnStatement = function () {
            var returnKeyword = this.eatKeyword(33 /* ReturnKeyword */ );
            var expression = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                expression = this.parseExpression(true);
            }
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.returnStatement(returnKeyword, expression, semicolonToken);
        };
        ParserImpl.prototype.isExpressionStatement = function () {
            var currentToken = this.currentToken();
            var kind = currentToken.tokenKind;
            if (kind === 70 /* OpenBraceToken */  || kind === 27 /* FunctionKeyword */ ) {
                return false;
            }
            return this.isExpression();
        };
        ParserImpl.prototype.isAssignmentOrOmittedExpression = function () {
            if (this.currentToken().tokenKind === 79 /* CommaToken */ ) {
                return true;
            }
            return this.isExpression();
        };
        ParserImpl.prototype.parseAssignmentOrOmittedExpression = function () {
            if (this.currentToken().tokenKind === 79 /* CommaToken */ ) {
                return this.factory.omittedExpression();
            }
            return this.parseAssignmentExpression(true);
        };
        ParserImpl.prototype.isExpression = function () {
            var currentToken = this.currentToken();
            var kind = currentToken.tokenKind;
            switch(kind) {
                case 13 /* NumericLiteral */ :
                case 14 /* StringLiteral */ :
                case 12 /* RegularExpressionLiteral */ :
                    return true;
                case 74 /* OpenBracketToken */ :
                case 72 /* OpenParenToken */ :
                    return true;
                case 80 /* LessThanToken */ :
                    return true;
                case 93 /* PlusPlusToken */ :
                case 94 /* MinusMinusToken */ :
                case 89 /* PlusToken */ :
                case 90 /* MinusToken */ :
                case 102 /* TildeToken */ :
                case 101 /* ExclamationToken */ :
                    return true;
                case 70 /* OpenBraceToken */ :
                    return true;
                case 85 /* EqualsGreaterThanToken */ :
                    return true;
                case 118 /* SlashToken */ :
                case 119 /* SlashEqualsToken */ :
                    return true;
                case 50 /* SuperKeyword */ :
                case 35 /* ThisKeyword */ :
                case 37 /* TrueKeyword */ :
                case 24 /* FalseKeyword */ :
                case 32 /* NullKeyword */ :
                    return true;
                case 31 /* NewKeyword */ :
                    return true;
                case 21 /* DeleteKeyword */ :
                case 41 /* VoidKeyword */ :
                case 39 /* TypeOfKeyword */ :
                    return true;
                case 27 /* FunctionKeyword */ :
                    return true;
            }
            if (this.isIdentifier(this.currentToken())) {
                return true;
            }
            return false;
        };
        ParserImpl.prototype.parseExpressionStatement = function () {
            var expression = this.parseExpression(true);
            var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.expressionStatement(expression, semicolon);
        };
        ParserImpl.prototype.isIfStatement = function () {
            return this.currentToken().tokenKind === 28 /* IfKeyword */ ;
        };
        ParserImpl.prototype.parseIfStatement = function () {
            var ifKeyword = this.eatKeyword(28 /* IfKeyword */ );
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var condition = this.parseExpression(true);
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var statement = this.parseStatement();
            var elseClause = null;
            if (this.isElseClause()) {
                elseClause = this.parseElseClause();
            }
            return this.factory.ifStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause);
        };
        ParserImpl.prototype.isElseClause = function () {
            return this.currentToken().tokenKind === 23 /* ElseKeyword */ ;
        };
        ParserImpl.prototype.parseElseClause = function () {
            var elseKeyword = this.eatKeyword(23 /* ElseKeyword */ );
            var statement = this.parseStatement();
            return this.factory.elseClause(elseKeyword, statement);
        };
        ParserImpl.prototype.isVariableStatement = function () {
            var token0KeywordKind = this.currentToken().tokenKind;
            if (token0KeywordKind === 40 /* VarKeyword */ ) {
                return true;
            }
            if (token0KeywordKind === 47 /* ExportKeyword */  && this.peekToken(1).tokenKind === 40 /* VarKeyword */ ) {
                return true;
            }
            return token0KeywordKind === 64 /* DeclareKeyword */  && this.peekToken(1).tokenKind === 40 /* VarKeyword */ ;
        };
        ParserImpl.prototype.parseVariableStatement = function () {
            var exportKeyword = this.tryEatKeyword(47 /* ExportKeyword */ );
            var declareKeyword = this.tryEatKeyword(64 /* DeclareKeyword */ );
            var variableDeclaration = this.parseVariableDeclaration(true);
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
            return this.factory.variableStatement(exportKeyword, declareKeyword, variableDeclaration, semicolonToken);
        };
        ParserImpl.prototype.parseVariableDeclaration = function (allowIn) {
            var varKeyword = this.eatKeyword(40 /* VarKeyword */ );
            var listParsingState = allowIn ? 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */  : 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ ;
            var result = this.parseSeparatedSyntaxList(listParsingState);
            var variableDeclarators = result.list;
            varKeyword = this.addSkippedTokensAfterToken(varKeyword, result.skippedTokens);
            return this.factory.variableDeclaration(varKeyword, variableDeclarators);
        };
        ParserImpl.prototype.isVariableDeclarator = function () {
            if (this.currentNode() !== null && this.currentNode().kind() === 222 /* VariableDeclarator */ ) {
                return true;
            }
            return this.isIdentifier(this.currentToken());
        };
        ParserImpl.prototype.parseVariableDeclarator = function (allowIn) {
            if (this.currentNode() !== null && this.currentNode().kind() === 222 /* VariableDeclarator */ ) {
                return this.eatNode();
            }
            var identifier = this.eatIdentifierToken();
            var equalsValueClause = null;
            var typeAnnotation = null;
            if (identifier.width() > 0) {
                typeAnnotation = this.parseOptionalTypeAnnotation();
                if (this.isEqualsValueClause()) {
                    equalsValueClause = this.parseEqualsValuesClause(allowIn);
                }
            }
            return this.factory.variableDeclarator(identifier, typeAnnotation, equalsValueClause);
        };
        ParserImpl.prototype.isEqualsValueClause = function () {
            return this.currentToken().tokenKind === 107 /* EqualsToken */ ;
        };
        ParserImpl.prototype.parseEqualsValuesClause = function (allowIn) {
            var equalsToken = this.eatToken(107 /* EqualsToken */ );
            var value = this.parseAssignmentExpression(allowIn);
            return this.factory.equalsValueClause(equalsToken, value);
        };
        ParserImpl.prototype.parseExpression = function (allowIn) {
            return this.parseSubExpression(0, allowIn);
        };
        ParserImpl.prototype.parseAssignmentExpression = function (allowIn) {
            return this.parseSubExpression(2 /* AssignmentExpressionPrecedence */ , allowIn);
        };
        ParserImpl.prototype.parseUnaryExpression = function () {
            var currentTokenKind = this.currentToken().tokenKind;
            if (SyntaxFacts.isPrefixUnaryExpressionOperatorToken(currentTokenKind)) {
                var operatorKind = SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(currentTokenKind);
                var operatorToken = this.eatAnyToken();
                var operand = this.parseUnaryExpression();
                return this.factory.prefixUnaryExpression(operatorKind, operatorToken, operand);
            } else {
                return this.parseTerm(true, false);
            }
        };
        ParserImpl.prototype.parseSubExpression = function (precedence, allowIn) {
            var leftOperand = this.parseUnaryExpression();
            leftOperand = this.parseBinaryOrConditionalExpressions(precedence, allowIn, leftOperand);
            return leftOperand;
        };
        ParserImpl.prototype.parseBinaryOrConditionalExpressions = function (precedence, allowIn, leftOperand) {
            while(true) {
                var token0 = this.currentToken();
                var token0Kind = token0.tokenKind;
                if (SyntaxFacts.isBinaryExpressionOperatorToken(token0Kind)) {
                    if (token0Kind === 29 /* InKeyword */  && !allowIn) {
                        break;
                    }
                    var mergedToken = this.tryMergeBinaryExpressionTokens();
                    var tokenKind = mergedToken === null ? token0Kind : mergedToken.syntaxKind;
                    var binaryExpressionKind = SyntaxFacts.getBinaryExpressionFromOperatorToken(tokenKind);
                    var newPrecedence = ParserImpl.getPrecedence(binaryExpressionKind);
                    if (newPrecedence < precedence) {
                        break;
                    }
                    if (newPrecedence === precedence && !this.isRightAssociative(binaryExpressionKind)) {
                        break;
                    }
                    var operatorToken = mergedToken === null ? token0 : Syntax.token(mergedToken.syntaxKind).withLeadingTrivia(token0.leadingTrivia()).withTrailingTrivia(this.peekToken(mergedToken.tokenCount - 1).trailingTrivia());
                    var skipCount = mergedToken === null ? 1 : mergedToken.tokenCount;
                    for(var i = 0; i < skipCount; i++) {
                        this.eatAnyToken();
                    }
                    leftOperand = this.factory.binaryExpression(binaryExpressionKind, leftOperand, operatorToken, this.parseSubExpression(newPrecedence, allowIn));
                    continue;
                }
                if (token0Kind === 105 /* QuestionToken */  && precedence <= 3 /* ConditionalExpressionPrecedence */ ) {
                    var questionToken = this.eatToken(105 /* QuestionToken */ );
                    var whenTrueExpression = this.parseAssignmentExpression(allowIn);
                    var colon = this.eatToken(106 /* ColonToken */ );
                    var whenFalseExpression = this.parseAssignmentExpression(allowIn);
                    leftOperand = this.factory.conditionalExpression(leftOperand, questionToken, whenTrueExpression, colon, whenFalseExpression);
                    continue;
                }
                break;
            }
            return leftOperand;
        };
        ParserImpl.prototype.tryMergeBinaryExpressionTokens = function () {
            var token0 = this.currentToken();
            if (token0.tokenKind === 81 /* GreaterThanToken */  && !token0.hasTrailingTrivia()) {
                var storage = this.mergeTokensStorage;
                storage[0] = 0 /* None */ ;
                storage[1] = 0 /* None */ ;
                storage[2] = 0 /* None */ ;
                for(var i = 0; i < storage.length; i++) {
                    var nextToken = this.peekToken(i + 1);
                    if (!nextToken.hasLeadingTrivia()) {
                        storage[i] = nextToken.tokenKind;
                    }
                    if (nextToken.hasTrailingTrivia()) {
                        break;
                    }
                }
                if (storage[0] === 81 /* GreaterThanToken */ ) {
                    if (storage[1] === 81 /* GreaterThanToken */ ) {
                        if (storage[2] === 107 /* EqualsToken */ ) {
                            return {
                                tokenCount: 4,
                                syntaxKind: 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */ 
                            };
                        } else {
                            return {
                                tokenCount: 3,
                                syntaxKind: 97 /* GreaterThanGreaterThanGreaterThanToken */ 
                            };
                        }
                    } else if (storage[1] === 107 /* EqualsToken */ ) {
                        return {
                            tokenCount: 3,
                            syntaxKind: 113 /* GreaterThanGreaterThanEqualsToken */ 
                        };
                    } else {
                        return {
                            tokenCount: 2,
                            syntaxKind: 96 /* GreaterThanGreaterThanToken */ 
                        };
                    }
                } else if (storage[0] === 107 /* EqualsToken */ ) {
                    return {
                        tokenCount: 2,
                        syntaxKind: 83 /* GreaterThanEqualsToken */ 
                    };
                }
            }
            return null;
        };
        ParserImpl.prototype.isRightAssociative = function (expressionKind) {
            switch(expressionKind) {
                case 171 /* AssignmentExpression */ :
                case 172 /* AddAssignmentExpression */ :
                case 173 /* SubtractAssignmentExpression */ :
                case 174 /* MultiplyAssignmentExpression */ :
                case 175 /* DivideAssignmentExpression */ :
                case 176 /* ModuloAssignmentExpression */ :
                case 177 /* AndAssignmentExpression */ :
                case 178 /* ExclusiveOrAssignmentExpression */ :
                case 179 /* OrAssignmentExpression */ :
                case 180 /* LeftShiftAssignmentExpression */ :
                case 181 /* SignedRightShiftAssignmentExpression */ :
                case 182 /* UnsignedRightShiftAssignmentExpression */ :
                    return true;
                default:
                    return false;
            }
        };
        ParserImpl.prototype.parseTerm = function (allowInvocation, insideObjectCreation) {
            var term = this.parseTermWorker(insideObjectCreation);
            if (term === null) {
                return this.eatIdentifierToken();
            }
            return this.parsePostFixExpression(term, allowInvocation);
        };
        ParserImpl.prototype.parsePostFixExpression = function (expression, allowInvocation) {
            while(true) {
                var currentTokenKind = this.currentToken().tokenKind;
                switch(currentTokenKind) {
                    case 72 /* OpenParenToken */ :
                        if (!allowInvocation) {
                            return expression;
                        }
                        expression = this.factory.invocationExpression(expression, this.parseArgumentList(null));
                        continue;
                    case 80 /* LessThanToken */ :
                        var argumentList = this.tryParseArgumentList();
                        if (argumentList !== null) {
                            expression = this.factory.invocationExpression(expression, argumentList);
                            continue;
                        }
                        break;
                    case 74 /* OpenBracketToken */ :
                        expression = this.parseElementAccessExpression(expression);
                        continue;
                    case 93 /* PlusPlusToken */ :
                    case 94 /* MinusMinusToken */ :
                        if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                            break;
                        }
                        expression = this.factory.postfixUnaryExpression(SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(currentTokenKind), expression, this.eatAnyToken());
                        continue;
                    case 76 /* DotToken */ :
                        expression = this.factory.memberAccessExpression(expression, this.eatToken(76 /* DotToken */ ), this.eatIdentifierNameToken());
                        continue;
                }
                return expression;
            }
        };
        ParserImpl.prototype.tryParseArgumentList = function () {
            var typeArgumentList = null;
            if (this.currentToken().tokenKind === 80 /* LessThanToken */ ) {
                var rewindPoint = this.getRewindPoint();
                try  {
                    typeArgumentList = this.tryParseTypeArgumentList(true);
                    if (typeArgumentList === null || this.currentToken().tokenKind !== 72 /* OpenParenToken */ ) {
                        this.rewind(rewindPoint);
                        return null;
                    }
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            }
            if (this.currentToken().tokenKind === 72 /* OpenParenToken */ ) {
                return this.parseArgumentList(typeArgumentList);
            }
            return null;
        };
        ParserImpl.prototype.parseArgumentList = function (typeArgumentList) {
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var arguments = Syntax.emptySeparatedList;
            if (openParenToken.fullWidth() > 0) {
                var result = this.parseSeparatedSyntaxList(8192 /* ArgumentList_AssignmentExpressions */ );
                arguments = result.list;
                openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
            }
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            return this.factory.argumentList(typeArgumentList, openParenToken, arguments, closeParenToken);
        };
        ParserImpl.prototype.parseElementAccessExpression = function (expression) {
            var openBracketToken = this.eatToken(74 /* OpenBracketToken */ );
            var argumentExpression = this.parseExpression(true);
            var closeBracketToken = this.eatToken(75 /* CloseBracketToken */ );
            return this.factory.elementAccessExpression(expression, openBracketToken, argumentExpression, closeBracketToken);
        };
        ParserImpl.prototype.parseTermWorker = function (insideObjectCreation) {
            var currentToken = this.currentToken();
            if (insideObjectCreation) {
                if (this.isType(false, false)) {
                    return this.parseType(true);
                }
            }
            if (currentToken.tokenKind === 85 /* EqualsGreaterThanToken */ ) {
                return this.parseSimpleArrowFunctionExpression();
            }
            if (this.isIdentifier(currentToken)) {
                if (this.isSimpleArrowFunctionExpression()) {
                    return this.parseSimpleArrowFunctionExpression();
                } else {
                    var identifier = this.eatIdentifierToken();
                    return identifier;
                }
            }
            var currentTokenKind = currentToken.tokenKind;
            switch(currentTokenKind) {
                case 35 /* ThisKeyword */ :
                    return this.parseThisExpression();
                case 37 /* TrueKeyword */ :
                case 24 /* FalseKeyword */ :
                    return this.parseLiteralExpression();
                case 32 /* NullKeyword */ :
                    return this.parseLiteralExpression();
                case 31 /* NewKeyword */ :
                    return this.parseObjectCreationExpression();
                case 27 /* FunctionKeyword */ :
                    return this.parseFunctionExpression();
                case 50 /* SuperKeyword */ :
                    return this.parseSuperExpression();
                case 39 /* TypeOfKeyword */ :
                    return this.parseTypeOfExpression();
                case 21 /* DeleteKeyword */ :
                    return this.parseDeleteExpression();
                case 41 /* VoidKeyword */ :
                    return this.parseVoidExpression();
                case 13 /* NumericLiteral */ :
                    return this.parseLiteralExpression();
                case 12 /* RegularExpressionLiteral */ :
                    return this.parseLiteralExpression();
                case 14 /* StringLiteral */ :
                    return this.parseLiteralExpression();
                case 74 /* OpenBracketToken */ :
                    return this.parseArrayLiteralExpression();
                case 70 /* OpenBraceToken */ :
                    return this.parseObjectLiteralExpression();
                case 72 /* OpenParenToken */ :
                    return this.parseParenthesizedOrArrowFunctionExpression();
                case 80 /* LessThanToken */ :
                    return this.parseCastOrArrowFunctionExpression();
                case 118 /* SlashToken */ :
                case 119 /* SlashEqualsToken */ :
                    var result = this.tryReparseDivideAsRegularExpression();
                    if (result !== null) {
                        return result;
                    }
                    break;
            }
            return null;
        };
        ParserImpl.prototype.tryReparseDivideAsRegularExpression = function () {
            var currentToken = this.currentToken();
            if (this.previousToken() !== null) {
                var previousTokenKind = this.previousToken().tokenKind;
                switch(previousTokenKind) {
                    case 11 /* IdentifierName */ :
                        return null;
                    case 35 /* ThisKeyword */ :
                    case 37 /* TrueKeyword */ :
                    case 24 /* FalseKeyword */ :
                        return null;
                    case 14 /* StringLiteral */ :
                    case 13 /* NumericLiteral */ :
                    case 12 /* RegularExpressionLiteral */ :
                    case 93 /* PlusPlusToken */ :
                    case 94 /* MinusMinusToken */ :
                    case 75 /* CloseBracketToken */ :
                    case 71 /* CloseBraceToken */ :
                        return null;
                }
            }
            currentToken = this.currentTokenAllowingRegularExpression();
            if (currentToken.tokenKind === 118 /* SlashToken */  || currentToken.tokenKind === 119 /* SlashEqualsToken */ ) {
                return null;
            } else if (currentToken.tokenKind === 12 /* RegularExpressionLiteral */ ) {
                return this.parseLiteralExpression();
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.parseTypeOfExpression = function () {
            var typeOfKeyword = this.eatKeyword(39 /* TypeOfKeyword */ );
            var expression = this.parseUnaryExpression();
            return this.factory.typeOfExpression(typeOfKeyword, expression);
        };
        ParserImpl.prototype.parseDeleteExpression = function () {
            var deleteKeyword = this.eatKeyword(21 /* DeleteKeyword */ );
            var expression = this.parseUnaryExpression();
            return this.factory.deleteExpression(deleteKeyword, expression);
        };
        ParserImpl.prototype.parseVoidExpression = function () {
            var voidKeyword = this.eatKeyword(41 /* VoidKeyword */ );
            var expression = this.parseUnaryExpression();
            return this.factory.voidExpression(voidKeyword, expression);
        };
        ParserImpl.prototype.parseSuperExpression = function () {
            var superKeyword = this.eatKeyword(50 /* SuperKeyword */ );
            return superKeyword;
        };
        ParserImpl.prototype.parseFunctionExpression = function () {
            var functionKeyword = this.eatKeyword(27 /* FunctionKeyword */ );
            var identifier = null;
            if (this.isIdentifier(this.currentToken())) {
                identifier = this.eatIdentifierToken();
            }
            var callSignature = this.parseCallSignature(false);
            var block = this.parseBlock();
            return this.factory.functionExpression(functionKeyword, identifier, callSignature, block);
        };
        ParserImpl.prototype.parseObjectCreationExpression = function () {
            var newKeyword = this.eatKeyword(31 /* NewKeyword */ );
            var expression = this.parseTerm(false, true);
            var argumentList = this.tryParseArgumentList();
            return this.factory.objectCreationExpression(newKeyword, expression, argumentList);
        };
        ParserImpl.prototype.parseCastOrArrowFunctionExpression = function () {
            var rewindPoint = this.getRewindPoint();
            try  {
                var arrowFunction = this.tryParseArrowFunctionExpression();
                if (arrowFunction !== null) {
                    return arrowFunction;
                }
                this.rewind(rewindPoint);
                return this.parseCastExpression();
            } finally {
                this.releaseRewindPoint(rewindPoint);
            }
        };
        ParserImpl.prototype.parseCastExpression = function () {
            var lessThanToken = this.eatToken(80 /* LessThanToken */ );
            var type = this.parseType(false);
            var greaterThanToken = this.eatToken(81 /* GreaterThanToken */ );
            var expression = this.parseUnaryExpression();
            return this.factory.castExpression(lessThanToken, type, greaterThanToken, expression);
        };
        ParserImpl.prototype.parseParenthesizedOrArrowFunctionExpression = function () {
            var result = this.tryParseArrowFunctionExpression();
            if (result !== null) {
                return result;
            }
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var expression = this.parseExpression(true);
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            return this.factory.parenthesizedExpression(openParenToken, expression, closeParenToken);
        };
        ParserImpl.prototype.tryParseArrowFunctionExpression = function () {
            var tokenKind = this.currentToken().tokenKind;
            if (this.isDefinitelyArrowFunctionExpression()) {
                return this.parseParenthesizedArrowFunctionExpression(false);
            }
            if (!this.isPossiblyArrowFunctionExpression()) {
                return null;
            }
            var rewindPoint = this.getRewindPoint();
            try  {
                var arrowFunction = this.parseParenthesizedArrowFunctionExpression(true);
                if (arrowFunction === null) {
                    this.rewind(rewindPoint);
                }
                return arrowFunction;
            } finally {
                this.releaseRewindPoint(rewindPoint);
            }
        };
        ParserImpl.prototype.parseParenthesizedArrowFunctionExpression = function (requireArrow) {
            var currentToken = this.currentToken();
            var callSignature = this.parseCallSignature(true);
            if (requireArrow && this.currentToken().tokenKind !== 85 /* EqualsGreaterThanToken */ ) {
                return null;
            }
            var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */ );
            var body = this.parseArrowFunctionBody();
            return this.factory.parenthesizedArrowFunctionExpression(callSignature, equalsGreaterThanToken, body);
        };
        ParserImpl.prototype.parseArrowFunctionBody = function () {
            if (this.isBlock()) {
                return this.parseBlock();
            } else {
                return this.parseAssignmentExpression(true);
            }
        };
        ParserImpl.prototype.isSimpleArrowFunctionExpression = function () {
            if (this.currentToken().tokenKind === 85 /* EqualsGreaterThanToken */ ) {
                return true;
            }
            return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === 85 /* EqualsGreaterThanToken */ ;
        };
        ParserImpl.prototype.parseSimpleArrowFunctionExpression = function () {
            var identifier = this.eatIdentifierToken();
            var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */ );
            var body = this.parseArrowFunctionBody();
            return this.factory.simpleArrowFunctionExpression(identifier, equalsGreaterThanToken, body);
        };
        ParserImpl.prototype.isBlock = function () {
            return this.currentToken().tokenKind === 70 /* OpenBraceToken */ ;
        };
        ParserImpl.prototype.isDefinitelyArrowFunctionExpression = function () {
            var token0 = this.currentToken();
            if (token0.tokenKind !== 72 /* OpenParenToken */ ) {
                return false;
            }
            var token1 = this.peekToken(1);
            if (token1.tokenKind === 73 /* CloseParenToken */ ) {
                return true;
            }
            if (token1.tokenKind === 77 /* DotDotDotToken */ ) {
                return true;
            }
            if (!this.isIdentifier(token1)) {
                return false;
            }
            var token2 = this.peekToken(2);
            if (token2.tokenKind === 106 /* ColonToken */ ) {
                return true;
            }
            var token3 = this.peekToken(3);
            if (token2.tokenKind === 105 /* QuestionToken */ ) {
                if (token3.tokenKind === 106 /* ColonToken */  || token3.tokenKind === 73 /* CloseParenToken */  || token3.tokenKind === 79 /* CommaToken */ ) {
                    return true;
                }
            }
            if (token2.tokenKind === 73 /* CloseParenToken */ ) {
                if (token3.tokenKind === 85 /* EqualsGreaterThanToken */ ) {
                    return true;
                }
            }
            return false;
        };
        ParserImpl.prototype.isPossiblyArrowFunctionExpression = function () {
            var token0 = this.currentToken();
            if (token0.tokenKind !== 72 /* OpenParenToken */ ) {
                return true;
            }
            var token1 = this.peekToken(1);
            if (!this.isIdentifier(token1)) {
                return false;
            }
            var token2 = this.peekToken(2);
            if (token2.tokenKind === 107 /* EqualsToken */ ) {
                return true;
            }
            if (token2.tokenKind === 79 /* CommaToken */ ) {
                return true;
            }
            if (token2.tokenKind === 73 /* CloseParenToken */ ) {
                var token3 = this.peekToken(3);
                if (token3.tokenKind === 106 /* ColonToken */ ) {
                    return true;
                }
            }
            return false;
        };
        ParserImpl.prototype.parseObjectLiteralExpression = function () {
            var openBraceToken = this.eatToken(70 /* OpenBraceToken */ );
            var result = this.parseSeparatedSyntaxList(16384 /* ObjectLiteralExpression_PropertyAssignments */ );
            var propertyAssignments = result.list;
            openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            var closeBraceToken = this.eatToken(71 /* CloseBraceToken */ );
            return this.factory.objectLiteralExpression(openBraceToken, propertyAssignments, closeBraceToken);
        };
        ParserImpl.prototype.parsePropertyAssignment = function () {
            if (this.isGetAccessorPropertyAssignment()) {
                return this.parseGetAccessorPropertyAssignment();
            } else if (this.isSetAccessorPropertyAssignment()) {
                return this.parseSetAccessorPropertyAssignment();
            } else if (this.isSimplePropertyAssignment(false)) {
                return this.parseSimplePropertyAssignment();
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.isPropertyAssignment = function (inErrorRecovery) {
            return this.isGetAccessorPropertyAssignment() || this.isSetAccessorPropertyAssignment() || this.isSimplePropertyAssignment(inErrorRecovery);
        };
        ParserImpl.prototype.isGetAccessorPropertyAssignment = function () {
            return this.currentToken().tokenKind === 65 /* GetKeyword */  && this.isPropertyName(this.peekToken(1), false);
        };
        ParserImpl.prototype.parseGetAccessorPropertyAssignment = function () {
            var getKeyword = this.eatKeyword(65 /* GetKeyword */ );
            var propertyName = this.eatAnyToken();
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var block = this.parseBlock();
            return this.factory.getAccessorPropertyAssignment(getKeyword, propertyName, openParenToken, closeParenToken, block);
        };
        ParserImpl.prototype.isSetAccessorPropertyAssignment = function () {
            return this.currentToken().tokenKind === 68 /* SetKeyword */  && this.isPropertyName(this.peekToken(1), false);
        };
        ParserImpl.prototype.parseSetAccessorPropertyAssignment = function () {
            var setKeyword = this.eatKeyword(68 /* SetKeyword */ );
            var propertyName = this.eatAnyToken();
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var parameterName = this.eatIdentifierToken();
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            var block = this.parseBlock();
            return this.factory.setAccessorPropertyAssignment(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block);
        };
        ParserImpl.prototype.isSimplePropertyAssignment = function (inErrorRecovery) {
            return this.isPropertyName(this.currentToken(), inErrorRecovery);
        };
        ParserImpl.prototype.parseSimplePropertyAssignment = function () {
            var propertyName = this.eatAnyToken();
            var colonToken = this.eatToken(106 /* ColonToken */ );
            var expression = this.parseAssignmentExpression(true);
            return this.factory.simplePropertyAssignment(propertyName, colonToken, expression);
        };
        ParserImpl.prototype.isPropertyName = function (token, inErrorRecovery) {
            if (ParserImpl.isIdentifierName(token)) {
                if (inErrorRecovery) {
                    return this.isIdentifier(token);
                } else {
                    return true;
                }
            }
            switch(token.tokenKind) {
                case 14 /* StringLiteral */ :
                case 13 /* NumericLiteral */ :
                    return true;
                default:
                    return false;
            }
        };
        ParserImpl.prototype.parseArrayLiteralExpression = function () {
            var openBracketToken = this.eatToken(74 /* OpenBracketToken */ );
            var result = this.parseSeparatedSyntaxList(32768 /* ArrayLiteralExpression_AssignmentExpressions */ );
            var expressions = result.list;
            openBracketToken = this.addSkippedTokensAfterToken(openBracketToken, result.skippedTokens);
            var closeBracketToken = this.eatToken(75 /* CloseBracketToken */ );
            return this.factory.arrayLiteralExpression(openBracketToken, expressions, closeBracketToken);
        };
        ParserImpl.prototype.parseLiteralExpression = function () {
            return this.eatAnyToken();
        };
        ParserImpl.prototype.parseThisExpression = function () {
            var thisKeyword = this.eatKeyword(35 /* ThisKeyword */ );
            return thisKeyword;
        };
        ParserImpl.prototype.parseBlock = function () {
            var openBraceToken = this.eatToken(70 /* OpenBraceToken */ );
            var statements = Syntax.emptyList;
            if (openBraceToken.width() > 0) {
                var savedIsInStrictMode = this.isInStrictMode;
                var result = this.parseSyntaxList(32 /* Block_Statements */ , ParserImpl.updateStrictModeState);
                statements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                this.setStrictMode(savedIsInStrictMode);
            }
            var closeBraceToken = this.eatToken(71 /* CloseBraceToken */ );
            return this.factory.block(openBraceToken, statements, closeBraceToken);
        };
        ParserImpl.prototype.parseCallSignature = function (requireCompleteTypeParameterList) {
            var typeParameterList = this.parseOptionalTypeParameterList(requireCompleteTypeParameterList);
            var parameterList = this.parseParameterList();
            var typeAnnotation = this.parseOptionalTypeAnnotation();
            return this.factory.callSignature(typeParameterList, parameterList, typeAnnotation);
        };
        ParserImpl.prototype.parseOptionalTypeParameterList = function (requireCompleteTypeParameterList) {
            if (this.currentToken().tokenKind !== 80 /* LessThanToken */ ) {
                return null;
            }
            var rewindPoint = this.getRewindPoint();
            try  {
                var lessThanToken = this.eatToken(80 /* LessThanToken */ );
                var result = this.parseSeparatedSyntaxList(262144 /* TypeParameterList_TypeParameters */ );
                var typeParameterList = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);
                var greaterThanToken = this.eatToken(81 /* GreaterThanToken */ );
                if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                    this.rewind(rewindPoint);
                    return null;
                }
                return this.factory.typeParameterList(lessThanToken, typeParameterList, greaterThanToken);
            } finally {
                this.releaseRewindPoint(rewindPoint);
            }
        };
        ParserImpl.prototype.isTypeParameter = function () {
            return this.isIdentifier(this.currentToken());
        };
        ParserImpl.prototype.parseTypeParameter = function () {
            var identifier = this.eatIdentifierToken();
            var constraint = this.parseOptionalConstraint();
            return this.factory.typeParameter(identifier, constraint);
        };
        ParserImpl.prototype.parseOptionalConstraint = function () {
            if (this.currentToken().kind() !== 48 /* ExtendsKeyword */ ) {
                return null;
            }
            var extendsKeyword = this.eatKeyword(48 /* ExtendsKeyword */ );
            var type = this.parseType(false);
            return this.factory.constraint(extendsKeyword, type);
        };
        ParserImpl.prototype.parseParameterList = function () {
            var openParenToken = this.eatToken(72 /* OpenParenToken */ );
            var parameters = Syntax.emptySeparatedList;
            if (openParenToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(65536 /* ParameterList_Parameters */ );
                parameters = result.list;
                openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
            }
            var closeParenToken = this.eatToken(73 /* CloseParenToken */ );
            return this.factory.parameterList(openParenToken, parameters, closeParenToken);
        };
        ParserImpl.prototype.isTypeAnnotation = function () {
            return this.currentToken().tokenKind === 106 /* ColonToken */ ;
        };
        ParserImpl.prototype.parseOptionalTypeAnnotation = function () {
            return this.isTypeAnnotation() ? this.parseTypeAnnotation() : null;
        };
        ParserImpl.prototype.parseTypeAnnotation = function () {
            var colonToken = this.eatToken(106 /* ColonToken */ );
            var type = this.parseType(false);
            return this.factory.typeAnnotation(colonToken, type);
        };
        ParserImpl.prototype.isType = function (allowFunctionType, allowConstructorType) {
            return this.isPredefinedType() || this.isTypeLiteral(allowFunctionType, allowConstructorType) || this.isName();
        };
        ParserImpl.prototype.parseType = function (requireCompleteArraySuffix) {
            var type = this.parseNonArrayType();
            while(this.currentToken().tokenKind === 74 /* OpenBracketToken */ ) {
                if (requireCompleteArraySuffix && this.peekToken(1).tokenKind !== 75 /* CloseBracketToken */ ) {
                    break;
                }
                var openBracketToken = this.eatToken(74 /* OpenBracketToken */ );
                var closeBracketToken = this.eatToken(75 /* CloseBracketToken */ );
                type = this.factory.arrayType(type, openBracketToken, closeBracketToken);
            }
            return type;
        };
        ParserImpl.prototype.parseNonArrayType = function () {
            if (this.isPredefinedType()) {
                return this.parsePredefinedType();
            } else if (this.isTypeLiteral(true, true)) {
                return this.parseTypeLiteral();
            } else {
                return this.parseNameOrGenericType();
            }
        };
        ParserImpl.prototype.parseNameOrGenericType = function () {
            var name = this.parseName();
            var typeArgumentList = this.tryParseTypeArgumentList(false);
            return typeArgumentList === null ? name : this.factory.genericType(name, typeArgumentList);
        };
        ParserImpl.prototype.parseTypeLiteral = function () {
            if (this.isObjectType()) {
                return this.parseObjectType();
            } else if (this.isFunctionType()) {
                return this.parseFunctionType();
            } else if (this.isConstructorType()) {
                return this.parseConstructorType();
            } else {
                throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.parseFunctionType = function () {
            var typeParameterList = this.parseOptionalTypeParameterList(false);
            var parameterList = this.parseParameterList();
            var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */ );
            var returnType = this.parseType(false);
            return this.factory.functionType(typeParameterList, parameterList, equalsGreaterThanToken, returnType);
        };
        ParserImpl.prototype.parseConstructorType = function () {
            var newKeyword = this.eatKeyword(31 /* NewKeyword */ );
            var parameterList = this.parseParameterList();
            var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */ );
            var type = this.parseType(false);
            return this.factory.constructorType(newKeyword, null, parameterList, equalsGreaterThanToken, type);
        };
        ParserImpl.prototype.isTypeLiteral = function (allowFunctionType, allowConstructorType) {
            if (this.isObjectType()) {
                return true;
            }
            if (allowFunctionType && this.isFunctionType()) {
                return true;
            }
            if (allowConstructorType && this.isConstructorType()) {
                return true;
            }
            return false;
        };
        ParserImpl.prototype.isObjectType = function () {
            return this.currentToken().tokenKind === 70 /* OpenBraceToken */ ;
        };
        ParserImpl.prototype.isFunctionType = function () {
            var tokenKind = this.currentToken().tokenKind;
            return tokenKind === 72 /* OpenParenToken */  || tokenKind === 80 /* LessThanToken */ ;
        };
        ParserImpl.prototype.isConstructorType = function () {
            return this.currentToken().tokenKind === 31 /* NewKeyword */ ;
        };
        ParserImpl.prototype.parsePredefinedType = function () {
            var keyword = this.eatAnyToken();
            return keyword;
        };
        ParserImpl.prototype.isPredefinedType = function () {
            switch(this.currentToken().tokenKind) {
                case 60 /* AnyKeyword */ :
                case 67 /* NumberKeyword */ :
                case 61 /* BooleanKeyword */ :
                case 62 /* BoolKeyword */ :
                case 69 /* StringKeyword */ :
                case 41 /* VoidKeyword */ :
                    return true;
            }
            return false;
        };
        ParserImpl.prototype.isParameter = function () {
            if (this.currentNode() !== null && this.currentNode().kind() === 237 /* Parameter */ ) {
                return true;
            }
            var token = this.currentToken();
            if (token.tokenKind === 77 /* DotDotDotToken */ ) {
                return true;
            }
            if (token.tokenKind === 57 /* PublicKeyword */  || token.tokenKind === 55 /* PrivateKeyword */ ) {
                return true;
            }
            return this.isIdentifier(token);
        };
        ParserImpl.prototype.parseParameter = function () {
            if (this.currentNode() !== null && this.currentNode().kind() === 237 /* Parameter */ ) {
                return this.eatNode();
            }
            var dotDotDotToken = this.tryEatToken(77 /* DotDotDotToken */ );
            var publicOrPrivateToken = null;
            if (this.currentToken().tokenKind === 57 /* PublicKeyword */  || this.currentToken().tokenKind === 55 /* PrivateKeyword */ ) {
                publicOrPrivateToken = this.eatAnyToken();
            }
            var identifier = this.eatIdentifierToken();
            var questionToken = this.tryEatToken(105 /* QuestionToken */ );
            var typeAnnotation = this.parseOptionalTypeAnnotation();
            var equalsValueClause = null;
            if (this.isEqualsValueClause()) {
                equalsValueClause = this.parseEqualsValuesClause(true);
            }
            return this.factory.parameter(dotDotDotToken, publicOrPrivateToken, identifier, questionToken, typeAnnotation, equalsValueClause);
        };
        ParserImpl.prototype.parseSyntaxList = function (currentListType, processItems) {
            if (typeof processItems === "undefined") { processItems = null; }
            var savedListParsingState = this.listParsingState;
            this.listParsingState |= currentListType;
            var result = this.parseSyntaxListWorker(currentListType, processItems);
            this.listParsingState = savedListParsingState;
            return result;
        };
        ParserImpl.prototype.parseSeparatedSyntaxList = function (currentListType) {
            var savedListParsingState = this.listParsingState;
            this.listParsingState |= currentListType;
            var result = this.parseSeparatedSyntaxListWorker(currentListType);
            this.listParsingState = savedListParsingState;
            return result;
        };
        ParserImpl.prototype.abortParsingListOrMoveToNextToken = function (currentListType, itemCount, items, skippedTokens) {
            this.reportUnexpectedTokenDiagnostic(currentListType);
            for(var state = 131072 /* LastListParsingState */ ; state >= 1 /* FirstListParsingState */ ; state >>= 1) {
                if ((this.listParsingState & state) !== 0) {
                    if (this.isExpectedListTerminator(state, itemCount) || this.isExpectedListItem(state, true)) {
                        return true;
                    }
                }
            }
            var skippedToken = this.currentToken();
            this.moveToNextToken();
            this.addSkippedTokenToList(items, skippedTokens, skippedToken);
            return false;
        };
        ParserImpl.prototype.addSkippedTokenToList = function (items, skippedTokens, skippedToken) {
            for(var i = items.length - 1; i >= 0; i--) {
                var item = items[i];
                var lastToken = item.lastToken();
                if (lastToken.fullWidth() > 0) {
                    items[i] = this.addSkippedTokenAfterNodeOrToken(item, skippedToken);
                    return;
                }
            }
            skippedTokens.push(skippedToken);
        };
        ParserImpl.prototype.tryParseExpectedListItem = function (currentListType, inErrorRecovery, items, processItems) {
            if (this.isExpectedListItem(currentListType, inErrorRecovery)) {
                var item = this.parseExpectedListItem(currentListType);
                items.push(item);
                if (processItems !== null) {
                    processItems(this, items);
                }
            }
        };
        ParserImpl.prototype.listIsTerminated = function (currentListType, itemCount) {
            return this.isExpectedListTerminator(currentListType, itemCount) || this.currentToken().tokenKind === 10 /* EndOfFileToken */ ;
        };
        ParserImpl.prototype.getArray = function () {
            if (this.arrayPool.length > 0) {
                return this.arrayPool.pop();
            }
            return [];
        };
        ParserImpl.prototype.returnArray = function (array) {
            array.length = 0;
            this.arrayPool.push(array);
        };
        ParserImpl.prototype.parseSyntaxListWorker = function (currentListType, processItems) {
            var items = this.getArray();
            var skippedTokens = this.getArray();
            while(true) {
                var oldItemsCount = items.length;
                this.tryParseExpectedListItem(currentListType, false, items, processItems);
                var newItemsCount = items.length;
                if (newItemsCount === oldItemsCount) {
                    if (this.listIsTerminated(currentListType, newItemsCount)) {
                        break;
                    }
                    var abort = this.abortParsingListOrMoveToNextToken(currentListType, newItemsCount, items, skippedTokens);
                    if (abort) {
                        break;
                    }
                }
            }
            var result = Syntax.list(items);
            if (items.length <= 1) {
                this.returnArray(items);
            }
            return {
                skippedTokens: skippedTokens,
                list: result
            };
        };
        ParserImpl.prototype.parseSeparatedSyntaxListWorker = function (currentListType) {
            var items = this.getArray();
            var skippedTokens = this.getArray();
            var allowAutomaticSemicolonInsertion = this.allowsAutomaticSemicolonInsertion(currentListType);
            var separatorKind = this.separatorKind(currentListType);
            var inErrorRecovery = false;
            var listWasTerminated = false;
            while(true) {
                var oldItemsCount = items.length;
                this.tryParseExpectedListItem(currentListType, inErrorRecovery, items, null);
                var newItemsCount = items.length;
                if (newItemsCount === oldItemsCount) {
                    if (this.listIsTerminated(currentListType, newItemsCount)) {
                        listWasTerminated = true;
                        break;
                    }
                    var abort = this.abortParsingListOrMoveToNextToken(currentListType, oldItemsCount, items, skippedTokens);
                    if (abort) {
                        break;
                    } else {
                        inErrorRecovery = true;
                        continue;
                    }
                }
                inErrorRecovery = false;
                if (this.currentToken().tokenKind === separatorKind) {
                    items.push(this.eatToken(separatorKind));
                    continue;
                }
                if (this.listIsTerminated(currentListType, newItemsCount)) {
                    listWasTerminated = true;
                    break;
                }
                if (allowAutomaticSemicolonInsertion && this.canEatAutomaticSemicolon(false)) {
                    items.push(this.eatExplicitOrAutomaticSemicolon(false));
                    continue;
                }
                items.push(this.eatToken(separatorKind));
                inErrorRecovery = true;
            }
            var allowTrailingSeparator = this.allowsTrailingSeparator(currentListType);
            var requiresAtLeastOneItem = this.requiresAtLeastOneItem(currentListType);
            if (requiresAtLeastOneItem && items.length === 0) {
                this.reportUnexpectedTokenDiagnostic(currentListType);
            } else {
                if (listWasTerminated && !allowTrailingSeparator && items.length > 0 && items.length % 2 === 0 && items[items.length - 1] === this.previousToken()) {
                    this.addDiagnostic(new SyntaxDiagnostic(this.previousTokenStart(), this.previousToken().width(), 9 /* Trailing_separator_not_allowed */ , null));
                }
            }
            var result = Syntax.separatedList(items);
            if (items.length <= 1) {
                this.returnArray(items);
            }
            return {
                skippedTokens: skippedTokens,
                list: result
            };
        };
        ParserImpl.prototype.allowsTrailingSeparator = function (currentListType) {
            switch(currentListType) {
                case 256 /* EnumDeclaration_VariableDeclarators */ :
                case 512 /* ObjectType_TypeMembers */ :
                case 16384 /* ObjectLiteralExpression_PropertyAssignments */ :
                case 32768 /* ArrayLiteralExpression_AssignmentExpressions */ :
                    return true;
                case 1024 /* ExtendsOrImplementsClause_TypeNameList */ :
                case 8192 /* ArgumentList_AssignmentExpressions */ :
                case 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */ :
                case 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ :
                case 65536 /* ParameterList_Parameters */ :
                case 131072 /* TypeArgumentList_Types */ :
                case 262144 /* TypeParameterList_TypeParameters */ :
                    return false;
                case 1 /* SourceUnit_ModuleElements */ :
                case 2 /* ClassDeclaration_ClassElements */ :
                case 4 /* ModuleDeclaration_ModuleElements */ :
                case 8 /* SwitchStatement_SwitchClauses */ :
                case 16 /* SwitchClause_Statements */ :
                case 32 /* Block_Statements */ :
                default:
                    throw Errors.notYetImplemented();
            }
        };
        ParserImpl.prototype.requiresAtLeastOneItem = function (currentListType) {
            switch(currentListType) {
                case 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */ :
                case 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ :
                case 1024 /* ExtendsOrImplementsClause_TypeNameList */ :
                case 131072 /* TypeArgumentList_Types */ :
                case 262144 /* TypeParameterList_TypeParameters */ :
                    return true;
                case 512 /* ObjectType_TypeMembers */ :
                case 256 /* EnumDeclaration_VariableDeclarators */ :
                case 8192 /* ArgumentList_AssignmentExpressions */ :
                case 16384 /* ObjectLiteralExpression_PropertyAssignments */ :
                case 65536 /* ParameterList_Parameters */ :
                case 32768 /* ArrayLiteralExpression_AssignmentExpressions */ :
                    return false;
                case 1 /* SourceUnit_ModuleElements */ :
                case 2 /* ClassDeclaration_ClassElements */ :
                case 4 /* ModuleDeclaration_ModuleElements */ :
                case 8 /* SwitchStatement_SwitchClauses */ :
                case 16 /* SwitchClause_Statements */ :
                case 32 /* Block_Statements */ :
                default:
                    throw Errors.notYetImplemented();
            }
        };
        ParserImpl.prototype.allowsAutomaticSemicolonInsertion = function (currentListType) {
            switch(currentListType) {
                case 512 /* ObjectType_TypeMembers */ :
                    return true;
                case 1024 /* ExtendsOrImplementsClause_TypeNameList */ :
                case 256 /* EnumDeclaration_VariableDeclarators */ :
                case 8192 /* ArgumentList_AssignmentExpressions */ :
                case 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */ :
                case 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ :
                case 16384 /* ObjectLiteralExpression_PropertyAssignments */ :
                case 65536 /* ParameterList_Parameters */ :
                case 32768 /* ArrayLiteralExpression_AssignmentExpressions */ :
                case 131072 /* TypeArgumentList_Types */ :
                case 262144 /* TypeParameterList_TypeParameters */ :
                    return false;
                case 1 /* SourceUnit_ModuleElements */ :
                case 2 /* ClassDeclaration_ClassElements */ :
                case 4 /* ModuleDeclaration_ModuleElements */ :
                case 8 /* SwitchStatement_SwitchClauses */ :
                case 16 /* SwitchClause_Statements */ :
                case 32 /* Block_Statements */ :
                default:
                    throw Errors.notYetImplemented();
            }
        };
        ParserImpl.prototype.separatorKind = function (currentListType) {
            switch(currentListType) {
                case 1024 /* ExtendsOrImplementsClause_TypeNameList */ :
                case 8192 /* ArgumentList_AssignmentExpressions */ :
                case 256 /* EnumDeclaration_VariableDeclarators */ :
                case 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */ :
                case 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ :
                case 16384 /* ObjectLiteralExpression_PropertyAssignments */ :
                case 65536 /* ParameterList_Parameters */ :
                case 32768 /* ArrayLiteralExpression_AssignmentExpressions */ :
                case 131072 /* TypeArgumentList_Types */ :
                case 262144 /* TypeParameterList_TypeParameters */ :
                    return 79 /* CommaToken */ ;
                case 512 /* ObjectType_TypeMembers */ :
                    return 78 /* SemicolonToken */ ;
                case 1 /* SourceUnit_ModuleElements */ :
                case 2 /* ClassDeclaration_ClassElements */ :
                case 4 /* ModuleDeclaration_ModuleElements */ :
                case 8 /* SwitchStatement_SwitchClauses */ :
                case 16 /* SwitchClause_Statements */ :
                case 32 /* Block_Statements */ :
                default:
                    throw Errors.notYetImplemented();
            }
        };
        ParserImpl.prototype.reportUnexpectedTokenDiagnostic = function (listType) {
            var token = this.currentToken();
            var diagnostic = new SyntaxDiagnostic(this.currentTokenStart(), token.width(), 8 /* Unexpected_token__0_expected */ , [
                this.getExpectedListElementType(listType)
            ]);
            this.addDiagnostic(diagnostic);
        };
        ParserImpl.prototype.addDiagnostic = function (diagnostic) {
            if (this.diagnostics.length > 0 && this.diagnostics[this.diagnostics.length - 1].position() === diagnostic.position()) {
                return;
            }
            this.diagnostics.push(diagnostic);
        };
        ParserImpl.prototype.isExpectedListTerminator = function (currentListType, itemCount) {
            switch(currentListType) {
                case 1 /* SourceUnit_ModuleElements */ :
                    return this.isExpectedSourceUnit_ModuleElementsTerminator();
                case 2 /* ClassDeclaration_ClassElements */ :
                    return this.isExpectedClassDeclaration_ClassElementsTerminator();
                case 4 /* ModuleDeclaration_ModuleElements */ :
                    return this.isExpectedModuleDeclaration_ModuleElementsTerminator();
                case 8 /* SwitchStatement_SwitchClauses */ :
                    return this.isExpectedSwitchStatement_SwitchClausesTerminator();
                case 16 /* SwitchClause_Statements */ :
                    return this.isExpectedSwitchClause_StatementsTerminator();
                case 32 /* Block_Statements */ :
                    return this.isExpectedBlock_StatementsTerminator();
                case 64 /* TryBlock_Statements */ :
                    return this.isExpectedTryBlock_StatementsTerminator();
                case 128 /* CatchBlock_Statements */ :
                    return this.isExpectedCatchBlock_StatementsTerminator();
                case 256 /* EnumDeclaration_VariableDeclarators */ :
                    return this.isExpectedEnumDeclaration_VariableDeclaratorsTerminator();
                case 512 /* ObjectType_TypeMembers */ :
                    return this.isExpectedObjectType_TypeMembersTerminator();
                case 8192 /* ArgumentList_AssignmentExpressions */ :
                    return this.isExpectedArgumentList_AssignmentExpressionsTerminator();
                case 1024 /* ExtendsOrImplementsClause_TypeNameList */ :
                    return this.isExpectedExtendsOrImplementsClause_TypeNameListTerminator();
                case 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */ :
                    return this.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator(itemCount);
                case 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ :
                    return this.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();
                case 16384 /* ObjectLiteralExpression_PropertyAssignments */ :
                    return this.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();
                case 65536 /* ParameterList_Parameters */ :
                    return this.isExpectedParameterList_ParametersTerminator();
                case 131072 /* TypeArgumentList_Types */ :
                    return this.isExpectedTypeArgumentList_TypesTerminator();
                case 262144 /* TypeParameterList_TypeParameters */ :
                    return this.isExpectedTypeParameterList_TypeParametersTerminator();
                case 32768 /* ArrayLiteralExpression_AssignmentExpressions */ :
                    return this.isExpectedLiteralExpression_AssignmentExpressionsTerminator();
                default:
                    throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.isExpectedSourceUnit_ModuleElementsTerminator = function () {
            return this.currentToken().tokenKind === 10 /* EndOfFileToken */ ;
        };
        ParserImpl.prototype.isExpectedEnumDeclaration_VariableDeclaratorsTerminator = function () {
            return this.currentToken().tokenKind === 71 /* CloseBraceToken */ ;
        };
        ParserImpl.prototype.isExpectedModuleDeclaration_ModuleElementsTerminator = function () {
            return this.currentToken().tokenKind === 71 /* CloseBraceToken */ ;
        };
        ParserImpl.prototype.isExpectedObjectType_TypeMembersTerminator = function () {
            return this.currentToken().tokenKind === 71 /* CloseBraceToken */ ;
        };
        ParserImpl.prototype.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator = function () {
            return this.currentToken().tokenKind === 71 /* CloseBraceToken */ ;
        };
        ParserImpl.prototype.isExpectedLiteralExpression_AssignmentExpressionsTerminator = function () {
            return this.currentToken().tokenKind === 75 /* CloseBracketToken */ ;
        };
        ParserImpl.prototype.isExpectedTypeArgumentList_TypesTerminator = function () {
            var token = this.currentToken();
            if (token.tokenKind === 81 /* GreaterThanToken */ ) {
                return true;
            }
            if (this.canFollowTypeArgumentListInExpression(token.tokenKind)) {
                return true;
            }
            return false;
        };
        ParserImpl.prototype.isExpectedTypeParameterList_TypeParametersTerminator = function () {
            var token = this.currentToken();
            if (token.tokenKind === 81 /* GreaterThanToken */ ) {
                return true;
            }
            if (token.tokenKind === 72 /* OpenParenToken */  || token.tokenKind === 70 /* OpenBraceToken */  || token.tokenKind === 48 /* ExtendsKeyword */  || token.tokenKind === 51 /* ImplementsKeyword */ ) {
                return true;
            }
            return false;
        };
        ParserImpl.prototype.isExpectedParameterList_ParametersTerminator = function () {
            var token = this.currentToken();
            if (token.tokenKind === 73 /* CloseParenToken */ ) {
                return true;
            }
            if (token.tokenKind === 70 /* OpenBraceToken */ ) {
                return true;
            }
            if (token.tokenKind === 85 /* EqualsGreaterThanToken */ ) {
                return true;
            }
            return false;
        };
        ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator = function () {
            if (this.currentToken().tokenKind === 78 /* SemicolonToken */  || this.currentToken().tokenKind === 73 /* CloseParenToken */ ) {
                return true;
            }
            if (this.currentToken().tokenKind === 29 /* InKeyword */ ) {
                return true;
            }
            return false;
        };
        ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator = function (itemCount) {
            if (this.previousToken().tokenKind === 79 /* CommaToken */ ) {
                return false;
            }
            if (this.currentToken().tokenKind === 85 /* EqualsGreaterThanToken */ ) {
                return true;
            }
            return itemCount > 0 && this.canEatExplicitOrAutomaticSemicolon(false);
        };
        ParserImpl.prototype.isExpectedExtendsOrImplementsClause_TypeNameListTerminator = function () {
            if (this.currentToken().tokenKind === 48 /* ExtendsKeyword */  || this.currentToken().tokenKind === 51 /* ImplementsKeyword */ ) {
                return true;
            }
            if (this.currentToken().tokenKind === 70 /* OpenBraceToken */  || this.currentToken().tokenKind === 71 /* CloseBraceToken */ ) {
                return true;
            }
            return false;
        };
        ParserImpl.prototype.isExpectedArgumentList_AssignmentExpressionsTerminator = function () {
            return this.currentToken().tokenKind === 73 /* CloseParenToken */ ;
        };
        ParserImpl.prototype.isExpectedClassDeclaration_ClassElementsTerminator = function () {
            return this.currentToken().tokenKind === 71 /* CloseBraceToken */ ;
        };
        ParserImpl.prototype.isExpectedSwitchStatement_SwitchClausesTerminator = function () {
            return this.currentToken().tokenKind === 71 /* CloseBraceToken */ ;
        };
        ParserImpl.prototype.isExpectedSwitchClause_StatementsTerminator = function () {
            return this.currentToken().tokenKind === 71 /* CloseBraceToken */  || this.isSwitchClause();
        };
        ParserImpl.prototype.isExpectedBlock_StatementsTerminator = function () {
            return this.currentToken().tokenKind === 71 /* CloseBraceToken */ ;
        };
        ParserImpl.prototype.isExpectedTryBlock_StatementsTerminator = function () {
            return this.currentToken().tokenKind === 17 /* CatchKeyword */  || this.currentToken().tokenKind === 25 /* FinallyKeyword */ ;
        };
        ParserImpl.prototype.isExpectedCatchBlock_StatementsTerminator = function () {
            return this.currentToken().tokenKind === 25 /* FinallyKeyword */ ;
        };
        ParserImpl.prototype.isExtendsOrImplementsClause = function () {
            if (this.currentToken().tokenKind === 51 /* ImplementsKeyword */  || this.currentToken().tokenKind === 48 /* ExtendsKeyword */ ) {
                return this.isIdentifier(this.peekToken(1));
            }
            return false;
        };
        ParserImpl.prototype.isExtendsOrImplementsClauseTypeName = function () {
            if (this.isName()) {
                return !this.isExtendsOrImplementsClause();
            }
            return false;
        };
        ParserImpl.prototype.isExpectedListItem = function (currentListType, inErrorRecovery) {
            switch(currentListType) {
                case 1 /* SourceUnit_ModuleElements */ :
                    return this.isModuleElement();
                case 2 /* ClassDeclaration_ClassElements */ :
                    return this.isClassElement();
                case 4 /* ModuleDeclaration_ModuleElements */ :
                    return this.isModuleElement();
                case 8 /* SwitchStatement_SwitchClauses */ :
                    return this.isSwitchClause();
                case 16 /* SwitchClause_Statements */ :
                    return this.isStatement();
                case 32 /* Block_Statements */ :
                    return this.isStatement();
                case 64 /* TryBlock_Statements */ :
                case 128 /* CatchBlock_Statements */ :
                    return false;
                case 256 /* EnumDeclaration_VariableDeclarators */ :
                case 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */ :
                case 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ :
                    return this.isVariableDeclarator();
                case 512 /* ObjectType_TypeMembers */ :
                    return this.isTypeMember();
                case 8192 /* ArgumentList_AssignmentExpressions */ :
                    return this.isExpression();
                case 1024 /* ExtendsOrImplementsClause_TypeNameList */ :
                    return this.isExtendsOrImplementsClauseTypeName();
                case 16384 /* ObjectLiteralExpression_PropertyAssignments */ :
                    return this.isPropertyAssignment(inErrorRecovery);
                case 65536 /* ParameterList_Parameters */ :
                    return this.isParameter();
                case 131072 /* TypeArgumentList_Types */ :
                    return this.isType(true, true);
                case 262144 /* TypeParameterList_TypeParameters */ :
                    return this.isTypeParameter();
                case 32768 /* ArrayLiteralExpression_AssignmentExpressions */ :
                    return this.isAssignmentOrOmittedExpression();
                default:
                    throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.parseExpectedListItem = function (currentListType) {
            switch(currentListType) {
                case 1 /* SourceUnit_ModuleElements */ :
                    return this.parseModuleElement();
                case 2 /* ClassDeclaration_ClassElements */ :
                    return this.parseClassElement();
                case 4 /* ModuleDeclaration_ModuleElements */ :
                    return this.parseModuleElement();
                case 8 /* SwitchStatement_SwitchClauses */ :
                    return this.parseSwitchClause();
                case 16 /* SwitchClause_Statements */ :
                    return this.parseStatement();
                case 32 /* Block_Statements */ :
                    return this.parseStatement();
                case 256 /* EnumDeclaration_VariableDeclarators */ :
                    return this.parseVariableDeclarator(true);
                case 512 /* ObjectType_TypeMembers */ :
                    return this.parseTypeMember();
                case 8192 /* ArgumentList_AssignmentExpressions */ :
                    return this.parseAssignmentExpression(true);
                case 1024 /* ExtendsOrImplementsClause_TypeNameList */ :
                    return this.parseNameOrGenericType();
                case 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */ :
                    return this.parseVariableDeclarator(true);
                case 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ :
                    return this.parseVariableDeclarator(false);
                case 16384 /* ObjectLiteralExpression_PropertyAssignments */ :
                    return this.parsePropertyAssignment();
                case 32768 /* ArrayLiteralExpression_AssignmentExpressions */ :
                    return this.parseAssignmentOrOmittedExpression();
                case 65536 /* ParameterList_Parameters */ :
                    return this.parseParameter();
                case 131072 /* TypeArgumentList_Types */ :
                    return this.parseType(false);
                case 262144 /* TypeParameterList_TypeParameters */ :
                    return this.parseTypeParameter();
                default:
                    throw Errors.invalidOperation();
            }
        };
        ParserImpl.prototype.getExpectedListElementType = function (currentListType) {
            switch(currentListType) {
                case 1 /* SourceUnit_ModuleElements */ :
                    return Strings.module__class__interface__enum__import_or_statement;
                case 2 /* ClassDeclaration_ClassElements */ :
                    return Strings.constructor__function__accessor_or_variable;
                case 4 /* ModuleDeclaration_ModuleElements */ :
                    return Strings.module__class__interface__enum__import_or_statement;
                case 8 /* SwitchStatement_SwitchClauses */ :
                    return Strings.case_or_default_clause;
                case 16 /* SwitchClause_Statements */ :
                    return Strings.statement;
                case 32 /* Block_Statements */ :
                    return Strings.statement;
                case 2048 /* VariableDeclaration_VariableDeclarators_AllowIn */ :
                case 4096 /* VariableDeclaration_VariableDeclarators_DisallowIn */ :
                case 256 /* EnumDeclaration_VariableDeclarators */ :
                    return Strings.identifier;
                case 512 /* ObjectType_TypeMembers */ :
                    return Strings.call__construct__index__property_or_function_signature;
                case 8192 /* ArgumentList_AssignmentExpressions */ :
                    return Strings.expression;
                case 1024 /* ExtendsOrImplementsClause_TypeNameList */ :
                    return Strings.type_name;
                case 16384 /* ObjectLiteralExpression_PropertyAssignments */ :
                    return Strings.property_or_accessor;
                case 65536 /* ParameterList_Parameters */ :
                    return Strings.parameter;
                case 131072 /* TypeArgumentList_Types */ :
                    return Strings.type;
                case 262144 /* TypeParameterList_TypeParameters */ :
                    return Strings.type_parameter;
                case 32768 /* ArrayLiteralExpression_AssignmentExpressions */ :
                    return Strings.expression;
                default:
                    throw Errors.invalidOperation();
            }
        };
        return ParserImpl;
    })();    
    function parse(text, languageVersion, stringTable, options) {
        if (typeof languageVersion === "undefined") { languageVersion = 1 /* EcmaScript5 */ ; }
        if (typeof stringTable === "undefined") { stringTable = null; }
        if (typeof options === "undefined") { options = null; }
        var source = new NormalParserSource(text, languageVersion, stringTable);
        options = options || new ParseOptions();
        return new ParserImpl(source, options).parseSyntaxTree();
    }
    Parser1.parse = parse;
    function incrementalParse(oldSourceUnit, textChangeRanges, newText, languageVersion, stringTable, options) {
        if (typeof languageVersion === "undefined") { languageVersion = 1 /* EcmaScript5 */ ; }
        if (typeof stringTable === "undefined") { stringTable = null; }
        if (typeof options === "undefined") { options = null; }
        var source = new IncrementalParserSource(oldSourceUnit, textChangeRanges, newText, languageVersion, stringTable);
        options = options || new ParseOptions();
        return new ParserImpl(source, options).parseSyntaxTree();
    }
    Parser1.incrementalParse = incrementalParse;
})(Parser1 || (Parser1 = {}));
var TextFactory;
(function (TextFactory) {
    function getLengthOfLineBreakSlow(text, index, c) {
        if (c === 13 /* carriageReturn */ ) {
            var next = index + 1;
            return (next < text.length()) && 10 /* lineFeed */  === text.charCodeAt(next) ? 2 : 1;
        } else if (isAnyLineBreakCharacter(c)) {
            return 1;
        } else {
            return 0;
        }
    }
    function getLengthOfLineBreak(text, index) {
        var c = text.charCodeAt(index);
        if (c > 13 /* carriageReturn */  && c <= 127) {
            return 0;
        }
        return getLengthOfLineBreakSlow(text, index, c);
    }
    function isAnyLineBreakCharacter(c) {
        return c === 10 /* lineFeed */  || c === 13 /* carriageReturn */  || c === 133 /* nextLine */  || c === 8232 /* lineSeparator */  || c === 8233 /* paragraphSeparator */ ;
    }
    function getStartAndLengthOfLineBreakEndingAt(text, index, info) {
        var c = text.charCodeAt(index);
        if (c === 10 /* lineFeed */ ) {
            if (index > 0 && text.charCodeAt(index - 1) === 13 /* carriageReturn */ ) {
                info.startPosition = index - 1;
                info.length = 2;
            } else {
                info.startPosition = index;
                info.length = 1;
            }
        } else if (isAnyLineBreakCharacter(c)) {
            info.startPosition = index;
            info.length = 1;
        } else {
            info.startPosition = index + 1;
            info.length = 0;
        }
    }
    var LinebreakInfo = (function () {
        function LinebreakInfo(startPosition, length) {
            this.startPosition = startPosition;
            this.length = length;
        }
        return LinebreakInfo;
    })();    
    var TextLine = (function () {
        function TextLine(text, body, lineBreakLength, lineNumber) {
            this._text = null;
            this._textSpan = null;
            Contract.throwIfNull(text);
            Contract.throwIfFalse(lineBreakLength >= 0);
            Contract.requires(lineNumber >= 0);
            this._text = text;
            this._textSpan = body;
            this._lineBreakLength = lineBreakLength;
            this._lineNumber = lineNumber;
        }
        TextLine.prototype.start = function () {
            return this._textSpan.start();
        };
        TextLine.prototype.end = function () {
            return this._textSpan.end();
        };
        TextLine.prototype.endIncludingLineBreak = function () {
            return this.end() + this._lineBreakLength;
        };
        TextLine.prototype.extent = function () {
            return this._textSpan;
        };
        TextLine.prototype.extentIncludingLineBreak = function () {
            return TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
        };
        TextLine.prototype.toString = function () {
            return this._text.toString(this._textSpan);
        };
        TextLine.prototype.lineNumber = function () {
            return this._lineNumber;
        };
        return TextLine;
    })();    
    var TextBase = (function () {
        function TextBase() {
            this.lazyLineStarts = null;
            this.linebreakInfo = new LinebreakInfo(0, 0);
            this.lastLineFoundForPosition = null;
        }
        TextBase.prototype.length = function () {
            throw Errors.abstract();
        };
        TextBase.prototype.charCodeAt = function (position) {
            throw Errors.abstract();
        };
        TextBase.prototype.checkSubSpan = function (span) {
            if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                throw Errors.argumentOutOfRange("span");
            }
        };
        TextBase.prototype.toString = function (span) {
            if (typeof span === "undefined") { span = null; }
            throw Errors.abstract();
        };
        TextBase.prototype.subText = function (span) {
            this.checkSubSpan(span);
            return new SubText(this, span);
        };
        TextBase.prototype.substr = function (start, length, intern) {
            throw Errors.abstract();
        };
        TextBase.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
            throw Errors.abstract();
        };
        TextBase.prototype.lineCount = function () {
            return this.lineStarts().length;
        };
        TextBase.prototype.lines = function () {
            var lines = [];
            var length = this.lineCount();
            for(var i = 0; i < length; ++i) {
                lines[i] = this.getLineFromLineNumber(i);
            }
            return lines;
        };
        TextBase.prototype.lineStarts = function () {
            if (this.lazyLineStarts === null) {
                this.lazyLineStarts = this.parseLineStarts();
            }
            return this.lazyLineStarts;
        };
        TextBase.prototype.getLineFromLineNumber = function (lineNumber) {
            var lineStarts = this.lineStarts();
            if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                throw Errors.argumentOutOfRange("lineNumber");
            }
            var first = lineStarts[lineNumber];
            if (lineNumber === lineStarts.length - 1) {
                return new TextLine(this, new TextSpan(first, this.length() - first), 0, lineNumber);
            } else {
                getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                return new TextLine(this, new TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
            }
        };
        TextBase.prototype.getLineFromPosition = function (position) {
            var lastFound = this.lastLineFoundForPosition;
            if (lastFound !== null && lastFound.start() <= position && lastFound.endIncludingLineBreak() > position) {
                return lastFound;
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            var result = this.getLineFromLineNumber(lineNumber);
            this.lastLineFoundForPosition = result;
            return result;
        };
        TextBase.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }
            if (position === this.length()) {
                return this.lineCount() - 1;
            }
            var lineNumber = ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }
            return lineNumber;
        };
        TextBase.prototype.getLinePosition = function (position) {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }
            var lineNumber = this.getLineNumberFromPosition(position);
            return new LinePosition(lineNumber, position - this.lineStarts()[lineNumber]);
        };
        TextBase.prototype.parseLineStarts = function () {
            var length = this.length();
            if (0 === this.length()) {
                var result = [];
                result.push(0);
                return result;
            }
            var position = 0;
            var index = 0;
            var arrayBuilder = [];
            var lineNumber = 0;
            while(index < length) {
                var c = this.charCodeAt(index);
                var lineBreakLength;
                if (c > 13 /* carriageReturn */  && c <= 127) {
                    index++;
                    continue;
                } else if (c === 13 /* carriageReturn */  && index + 1 < length && this.charCodeAt(index + 1) === 10 /* lineFeed */ ) {
                    lineBreakLength = 2;
                } else if (c === 10 /* lineFeed */ ) {
                    lineBreakLength = 1;
                } else {
                    lineBreakLength = getLengthOfLineBreak(this, index);
                }
                if (0 === lineBreakLength) {
                    index++;
                } else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }
            arrayBuilder.push(position);
            return arrayBuilder;
        };
        return TextBase;
    })();    
    var SubText = (function (_super) {
        __extends(SubText, _super);
        function SubText(text, span) {
                _super.call(this);
            if (text === null) {
                throw Errors.argumentNull("text");
            }
            if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                throw Errors.argument("span");
            }
            this.text = text;
            this.span = span;
        }
        SubText.prototype.length = function () {
            return this.span.length();
        };
        SubText.prototype.charCodeAt = function (position) {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }
            return this.text.charCodeAt(this.span.start() + position);
        };
        SubText.prototype.subText = function (span) {
            this.checkSubSpan(span);
            return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
        };
        SubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
            var span = this.getCompositeSpan(sourceIndex, count);
            this.text.copyTo(span.start(), destination, destinationIndex, span.length());
        };
        SubText.prototype.getCompositeSpan = function (start, length) {
            var compositeStart = MathPrototype.min(this.text.length(), this.span.start() + start);
            var compositeEnd = MathPrototype.min(this.text.length(), compositeStart + length);
            return new TextSpan(compositeStart, compositeEnd - compositeStart);
        };
        return SubText;
    })(TextBase);    
    var StringText = (function (_super) {
        __extends(StringText, _super);
        function StringText(data) {
                _super.call(this);
            this.source = null;
            if (data === null) {
                throw Errors.argumentNull("data");
            }
            this.source = data;
        }
        StringText.prototype.length = function () {
            return this.source.length;
        };
        StringText.prototype.charCodeAt = function (position) {
            if (position < 0 || position >= this.source.length) {
                throw Errors.argumentOutOfRange("position");
            }
            return this.source.charCodeAt(position);
        };
        StringText.prototype.substr = function (start, length, intern) {
            return this.source.substr(start, length);
        };
        StringText.prototype.toString = function (span) {
            if (typeof span === "undefined") { span = null; }
            if (span === null) {
                span = new TextSpan(0, this.length());
            }
            this.checkSubSpan(span);
            if (span.start() === 0 && span.length() === this.length()) {
                return this.source;
            }
            return this.source.substr(span.start(), span.length());
        };
        StringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
            StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
        };
        return StringText;
    })(TextBase);    
    var stringTable = Collections.createStringTable();
    var SimpleSubText = (function () {
        function SimpleSubText(text, span) {
            this.text = null;
            this.span = null;
            if (text === null) {
                throw Errors.argumentNull("text");
            }
            if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                throw Errors.argument("span");
            }
            this.text = text;
            this.span = span;
        }
        SimpleSubText.prototype.checkSubSpan = function (span) {
            if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                throw Errors.argumentOutOfRange("span");
            }
        };
        SimpleSubText.prototype.length = function () {
            return this.span.length();
        };
        SimpleSubText.prototype.subText = function (span) {
            this.checkSubSpan(span);
            return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
        };
        SimpleSubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
            var span = this.getCompositeSpan(sourceIndex, count);
            this.text.copyTo(span.start(), destination, destinationIndex, span.length());
        };
        SimpleSubText.prototype.substr = function (start, length, intern) {
            var span = this.getCompositeSpan(start, length);
            return this.text.substr(span.start(), span.length(), intern);
        };
        SimpleSubText.prototype.getCompositeSpan = function (start, length) {
            var compositeStart = MathPrototype.min(this.text.length(), this.span.start() + start);
            var compositeEnd = MathPrototype.min(this.text.length(), compositeStart + length);
            return new TextSpan(compositeStart, compositeEnd - compositeStart);
        };
        return SimpleSubText;
    })();    
    var SimpleStringText = (function () {
        function SimpleStringText(value) {
            this.value = value;
        }
        SimpleStringText.prototype.length = function () {
            return this.value.length;
        };
        SimpleStringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
            StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
        };
        SimpleStringText.charArray = ArrayUtilities.createArray(1024, 0);
        SimpleStringText.prototype.substr = function (start, length, intern) {
            if (intern) {
                var array = length <= SimpleStringText.charArray.length ? SimpleStringText.charArray : ArrayUtilities.createArray(length, 0);
                this.copyTo(start, array, 0, length);
                return stringTable.addCharArray(array, 0, length);
            }
            return this.value.substr(start, length);
        };
        SimpleStringText.prototype.subText = function (span) {
            return new SimpleSubText(this, span);
        };
        return SimpleStringText;
    })();    
    function createText(value) {
        return new StringText(value);
    }
    TextFactory.createText = createText;
    function createSimpleText(value) {
        return new SimpleStringText(value);
    }
    TextFactory.createSimpleText = createSimpleText;
    function createSimpleSubText(text, span) {
        return new SimpleSubText(text, span);
    }
    TextFactory.createSimpleSubText = createSimpleSubText;
})(TextFactory || (TextFactory = {}));
var TypeScript;
(function (TypeScript) {
    var DataMap = (function () {
        function DataMap() {
            this.map = {};
        }
        DataMap.prototype.link = function (id, data) {
            this.map[id] = data;
        };
        DataMap.prototype.unlink = function (id) {
            this.map[id] = undefined;
        };
        DataMap.prototype.read = function (id) {
            return this.map[id];
        };
        DataMap.prototype.flush = function () {
            this.map = {};
        };
        DataMap.prototype.unpatch = function () {
            return null;
        };
        return DataMap;
    })();
    TypeScript.DataMap = DataMap;    
    var PatchedDataMap = (function (_super) {
        __extends(PatchedDataMap, _super);
        function PatchedDataMap(parent) {
                _super.call(this);
            this.parent = parent;
            this.diffs = {};
        }
        PatchedDataMap.prototype.link = function (id, data) {
            this.diffs[id] = data;
        };
        PatchedDataMap.prototype.unlink = function (id) {
            this.diffs[id] = undefined;
        };
        PatchedDataMap.prototype.read = function (id) {
            var data = this.diffs[id];
            if (data) {
                return data;
            }
            return this.parent.read(id);
        };
        PatchedDataMap.prototype.flush = function () {
            this.diffs = {};
        };
        PatchedDataMap.prototype.unpatch = function () {
            this.flush();
            return this.parent;
        };
        return PatchedDataMap;
    })(DataMap);
    TypeScript.PatchedDataMap = PatchedDataMap;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullElementFlags) {
        PullElementFlags._map = [];
        PullElementFlags.None = 0;
        PullElementFlags.Exported = 1;
        PullElementFlags.Private = 1 << 1;
        PullElementFlags.Public = 1 << 2;
        PullElementFlags.Ambient = 1 << 3;
        PullElementFlags.Static = 1 << 4;
        PullElementFlags.LocalStatic = 1 << 5;
        PullElementFlags.GetAccessor = 1 << 6;
        PullElementFlags.SetAccessor = 1 << 7;
        PullElementFlags.Optional = 1 << 8;
        PullElementFlags.Call = 1 << 9;
        PullElementFlags.Constructor = 1 << 10;
        PullElementFlags.Index = 1 << 11;
        PullElementFlags.Signature = 1 << 12;
        PullElementFlags.Enum = 1 << 13;
        PullElementFlags.FatArrow = 1 << 14;
        PullElementFlags.ClassConstructorVariable = 1 << 15;
        PullElementFlags.InitializedModule = 1 << 16;
        PullElementFlags.EnumVariable = 1 << 17;
        PullElementFlags.ImplicitVariable = PullElementFlags.ClassConstructorVariable | PullElementFlags.InitializedModule;
    })(TypeScript.PullElementFlags || (TypeScript.PullElementFlags = {}));
    var PullElementFlags = TypeScript.PullElementFlags;
    (function (PullElementKind) {
        PullElementKind._map = [];
        PullElementKind.None = 0;
        PullElementKind.Script = 1;
        PullElementKind.Global = 1 << 1;
        PullElementKind.Primitive = 1 << 2;
        PullElementKind.Container = 1 << 3;
        PullElementKind.Class = 1 << 4;
        PullElementKind.Interface = 1 << 5;
        PullElementKind.DynamicModule = 1 << 6;
        PullElementKind.Enum = 1 << 7;
        PullElementKind.Array = 1 << 8;
        PullElementKind.TypeAlias = 1 << 9;
        PullElementKind.Variable = 1 << 11;
        PullElementKind.Parameter = 1 << 12;
        PullElementKind.Property = 1 << 13;
        PullElementKind.TypeParameter = 1 << 14;
        PullElementKind.Function = 1 << 15;
        PullElementKind.ConstructorMethod = 1 << 16;
        PullElementKind.Method = 1 << 17;
        PullElementKind.FunctionExpression = 1 << 18;
        PullElementKind.GetAccessor = 1 << 19;
        PullElementKind.SetAccessor = 1 << 20;
        PullElementKind.CallSignature = 1 << 21;
        PullElementKind.ConstructSignature = 1 << 22;
        PullElementKind.IndexSignature = 1 << 23;
        PullElementKind.ObjectType = 1 << 24;
        PullElementKind.FunctionType = 1 << 25;
        PullElementKind.ConstructorType = 1 << 26;
        PullElementKind.SomeFunction = PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature;
        PullElementKind.SomeValue = PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.SomeFunction;
        PullElementKind.SomeType = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Container | PullElementKind.Class | PullElementKind.Interface | PullElementKind.DynamicModule | PullElementKind.Enum | PullElementKind.Array | PullElementKind.TypeAlias | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.TypeParameter;
        PullElementKind.SomeSignature = PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature;
    })(TypeScript.PullElementKind || (TypeScript.PullElementKind = {}));
    var PullElementKind = TypeScript.PullElementKind;
    (function (SymbolLinkKind) {
        SymbolLinkKind._map = [];
        SymbolLinkKind._map[0] = "TypedAs";
        SymbolLinkKind.TypedAs = 0;
        SymbolLinkKind._map[1] = "ContextuallyTypedAs";
        SymbolLinkKind.ContextuallyTypedAs = 1;
        SymbolLinkKind._map[2] = "ProvidesInferredType";
        SymbolLinkKind.ProvidesInferredType = 2;
        SymbolLinkKind._map[3] = "ArrayType";
        SymbolLinkKind.ArrayType = 3;
        SymbolLinkKind._map[4] = "ArrayOf";
        SymbolLinkKind.ArrayOf = 4;
        SymbolLinkKind._map[5] = "PublicMember";
        SymbolLinkKind.PublicMember = 5;
        SymbolLinkKind._map[6] = "PrivateMember";
        SymbolLinkKind.PrivateMember = 6;
        SymbolLinkKind._map[7] = "ConstructorMethod";
        SymbolLinkKind.ConstructorMethod = 7;
        SymbolLinkKind._map[8] = "Aliases";
        SymbolLinkKind.Aliases = 8;
        SymbolLinkKind._map[9] = "ContainedBy";
        SymbolLinkKind.ContainedBy = 9;
        SymbolLinkKind._map[10] = "Extends";
        SymbolLinkKind.Extends = 10;
        SymbolLinkKind._map[11] = "Implements";
        SymbolLinkKind.Implements = 11;
        SymbolLinkKind._map[12] = "Parameter";
        SymbolLinkKind.Parameter = 12;
        SymbolLinkKind._map[13] = "ReturnType";
        SymbolLinkKind.ReturnType = 13;
        SymbolLinkKind._map[14] = "CallSignature";
        SymbolLinkKind.CallSignature = 14;
        SymbolLinkKind._map[15] = "ConstructSignature";
        SymbolLinkKind.ConstructSignature = 15;
        SymbolLinkKind._map[16] = "IndexSignature";
        SymbolLinkKind.IndexSignature = 16;
        SymbolLinkKind._map[17] = "TypeParameter";
        SymbolLinkKind.TypeParameter = 17;
        SymbolLinkKind._map[18] = "TypeArgument";
        SymbolLinkKind.TypeArgument = 18;
        SymbolLinkKind._map[19] = "TypeParameterSpecializedTo";
        SymbolLinkKind.TypeParameterSpecializedTo = 19;
        SymbolLinkKind._map[20] = "SpecializedTo";
        SymbolLinkKind.SpecializedTo = 20;
        SymbolLinkKind._map[21] = "TypeConstraint";
        SymbolLinkKind.TypeConstraint = 21;
    })(TypeScript.SymbolLinkKind || (TypeScript.SymbolLinkKind = {}));
    var SymbolLinkKind = TypeScript.SymbolLinkKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullDeclID = 0;
    TypeScript.lastBoundPullDeclId = 0;
    var DeclSpan = (function () {
        function DeclSpan() {
            this.minChar = 0;
            this.limChar = 0;
        }
        return DeclSpan;
    })();
    TypeScript.DeclSpan = DeclSpan;    
    var PullDecl = (function () {
        function PullDecl(declName, declType, declFlags, span, scriptName) {
            this.symbol = null;
            this.propertySymbol = null;
            this.signatureSymbol = null;
            this.childDecls = [];
            this.typeParameters = [];
            this.childDeclTypeCache = new TypeScript.BlockIntrinsics();
            this.childDeclValueCache = new TypeScript.BlockIntrinsics();
            this.childDeclTypeParameterCache = new TypeScript.BlockIntrinsics();
            this.declID = TypeScript.pullDeclID++;
            this.declFlags = 0 /* None */ ;
            this.errors = null;
            this.parentDecl = null;
            this.synthesizedValDecl = null;
            this.declName = declName;
            this.declType = declType;
            this.declFlags = declFlags;
            this.span = span;
            this.scriptName = scriptName;
        }
        PullDecl.prototype.getDeclID = function () {
            return this.declID;
        };
        PullDecl.prototype.getName = function () {
            return this.declName;
        };
        PullDecl.prototype.getKind = function () {
            return this.declType;
        };
        PullDecl.prototype.setSymbol = function (symbol) {
            this.symbol = symbol;
        };
        PullDecl.prototype.getSymbol = function () {
            return this.symbol;
        };
        PullDecl.prototype.setPropertySymbol = function (symbol) {
            this.propertySymbol = symbol;
        };
        PullDecl.prototype.getPropertySymbol = function () {
            return this.propertySymbol;
        };
        PullDecl.prototype.setSignatureSymbol = function (signature) {
            this.signatureSymbol = signature;
        };
        PullDecl.prototype.getSignatureSymbol = function () {
            return this.signatureSymbol;
        };
        PullDecl.prototype.getFlags = function () {
            return this.declFlags;
        };
        PullDecl.prototype.setFlags = function (flags) {
            this.declFlags = flags;
        };
        PullDecl.prototype.getSpan = function () {
            return this.span;
        };
        PullDecl.prototype.setSpan = function (span) {
            this.span = span;
        };
        PullDecl.prototype.getScriptName = function () {
            return this.scriptName;
        };
        PullDecl.prototype.setValueDecl = function (valDecl) {
            this.synthesizedValDecl = valDecl;
        };
        PullDecl.prototype.getValueDecl = function () {
            return this.synthesizedValDecl;
        };
        PullDecl.prototype.getParentDecl = function () {
            return this.parentDecl;
        };
        PullDecl.prototype.addError = function (error) {
            if (!this.errors) {
                this.errors = [];
            }
            error.adjustOffset(this.span.minChar);
            this.errors[this.errors.length] = error;
        };
        PullDecl.prototype.getErrors = function () {
            return this.errors;
        };
        PullDecl.prototype.setErrors = function (errors) {
            if (errors) {
                this.errors = [];
                for(var i = 0; i < errors.length; i++) {
                    errors[i].adjustOffset(this.span.minChar);
                    this.errors[this.errors.length] = errors[i];
                }
            }
        };
        PullDecl.prototype.resetErrors = function () {
            this.errors = [];
        };
        PullDecl.prototype.addChildDecl = function (childDecl, addIfDuplicate) {
            if (typeof addIfDuplicate === "undefined") { addIfDuplicate = true; }
            var declName = childDecl.getName();
            if (!addIfDuplicate) {
                for(var i = 0; i < this.childDecls.length; i++) {
                    if (this.childDecls[i].getName() == declName) {
                        return false;
                    }
                }
            }
            if (childDecl.getKind() & 16384 /* TypeParameter */ ) {
                this.typeParameters[this.typeParameters.length] = childDecl;
            } else {
                this.childDecls[this.childDecls.length] = childDecl;
            }
            var cache = (childDecl.getKind() & TypeScript.PullElementKind.SomeType) ? (childDecl.getKind() & 16384 /* TypeParameter */ ) ? this.childDeclTypeParameterCache : this.childDeclTypeCache : this.childDeclValueCache;
            var cacheVal = cache[declName];
            if (!cacheVal) {
                cacheVal = [];
            }
            cacheVal[cacheVal.length] = childDecl;
            cache[declName] = cacheVal;
            return true;
        };
        PullDecl.prototype.findChildDecls = function (declName, declKind) {
            var cache = (declKind & TypeScript.PullElementKind.SomeType) ? this.childDeclTypeCache : this.childDeclValueCache;
            var cacheVal = cache[declName];
            if (cacheVal) {
                return cacheVal;
            } else {
                if (declKind & TypeScript.PullElementKind.SomeType) {
                    cacheVal = this.childDeclTypeParameterCache[declName];
                    if (cacheVal) {
                        return cacheVal;
                    }
                }
                return [];
            }
        };
        PullDecl.prototype.getChildDecls = function () {
            return this.childDecls;
        };
        PullDecl.prototype.getTypeParameters = function () {
            return this.typeParameters;
        };
        return PullDecl;
    })();
    TypeScript.PullDecl = PullDecl;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullSymbolID = 0;
    TypeScript.lastBoundPullSymbolID = 0;
    var PullSymbol = (function () {
        function PullSymbol(name, declKind) {
            this.pullSymbolID = TypeScript.pullSymbolID++;
            this.outgoingLinks = new TypeScript.LinkList();
            this.incomingLinks = new TypeScript.LinkList();
            this.declarations = new TypeScript.LinkList();
            this.cachedPathIDs = {};
            this.cachedContainerLink = null;
            this.cachedTypeLink = null;
            this.hasBeenResolved = false;
            this.isOptional = false;
            this.inResolution = false;
            this.isSynthesized = false;
            this.resolvingTypeArguments = false;
            this.typeChangeUpdateVersion = -1;
            this.addUpdateVersion = -1;
            this.removeUpdateVersion = -1;
            this.name = name;
            this.declKind = declKind;
        }
        PullSymbol.prototype.getSymbolID = function () {
            return this.pullSymbolID;
        };
        PullSymbol.prototype.isType = function () {
            return (this.declKind & TypeScript.PullElementKind.SomeType) != 0;
        };
        PullSymbol.prototype.isSignature = function () {
            return (this.declKind & TypeScript.PullElementKind.SomeSignature) != 0;
        };
        PullSymbol.prototype.isArray = function () {
            return (this.declKind & 256 /* Array */ ) != 0;
        };
        PullSymbol.prototype.isPrimitive = function () {
            return this.declKind == 4 /* Primitive */ ;
        };
        PullSymbol.prototype.getName = function () {
            return this.name;
        };
        PullSymbol.prototype.getKind = function () {
            return this.declKind;
        };
        PullSymbol.prototype.setKind = function (declType) {
            this.declKind = declType;
        };
        PullSymbol.prototype.setIsOptional = function () {
            this.isOptional = true;
        };
        PullSymbol.prototype.getIsOptional = function () {
            return this.isOptional;
        };
        PullSymbol.prototype.setIsSynthesized = function () {
            this.isSynthesized = true;
        };
        PullSymbol.prototype.getIsSynthesized = function () {
            return this.isSynthesized;
        };
        PullSymbol.prototype.addCacheID = function (cacheID) {
            if (!this.cachedPathIDs[cacheID]) {
                this.cachedPathIDs[cacheID] = true;
            }
        };
        PullSymbol.prototype.invalidateCachedIDs = function (cache) {
            for(var id in this.cachedPathIDs) {
                if (cache[id]) {
                    cache[id] = undefined;
                }
            }
        };
        PullSymbol.prototype.addDeclaration = function (decl) {
            this.declarations.addItem(decl);
        };
        PullSymbol.prototype.getDeclarations = function () {
            return this.declarations.find(function (d) {
                return d;
            });
        };
        PullSymbol.prototype.removeDeclaration = function (decl) {
            this.declarations.remove(function (d) {
                return d === decl;
            });
        };
        PullSymbol.prototype.updateDeclarations = function (map, context) {
            this.declarations.update(map, context);
        };
        PullSymbol.prototype.addOutgoingLink = function (linkTo, kind) {
            var link = new TypeScript.PullSymbolLink(this, linkTo, kind);
            this.outgoingLinks.addItem(link);
            linkTo.incomingLinks.addItem(link);
            return link;
        };
        PullSymbol.prototype.findOutgoingLinks = function (p) {
            return this.outgoingLinks.find(p);
        };
        PullSymbol.prototype.findIncomingLinks = function (p) {
            return this.incomingLinks.find(p);
        };
        PullSymbol.prototype.removeOutgoingLink = function (link) {
            if (link) {
                this.outgoingLinks.remove(function (p) {
                    return p === link;
                });
                link.end.incomingLinks.remove(function (p) {
                    return p === link;
                });
            }
        };
        PullSymbol.prototype.updateOutgoingLinks = function (map, context) {
            this.outgoingLinks.update(map, context);
        };
        PullSymbol.prototype.updateIncomingLinks = function (map, context) {
            this.incomingLinks.update(map, context);
        };
        PullSymbol.prototype.setContainer = function (containerSymbol, relationshipKind) {
            var link = this.addOutgoingLink(containerSymbol, 9 /* ContainedBy */ );
            this.cachedContainerLink = link;
        };
        PullSymbol.prototype.getContainer = function () {
            if (this.cachedContainerLink) {
                return this.cachedContainerLink.end;
            }
            var containerList = this.findOutgoingLinks(function (link) {
                return link.kind == 9 /* ContainedBy */ ;
            });
            if (containerList.length) {
                this.cachedContainerLink = containerList[0];
                return this.cachedContainerLink.end;
            }
            return null;
        };
        PullSymbol.prototype.unsetContainer = function () {
            if (this.cachedContainerLink) {
                this.removeOutgoingLink(this.cachedContainerLink);
            } else {
                var containerList = this.findOutgoingLinks(function (link) {
                    return link.kind == 9 /* ContainedBy */ ;
                });
                if (containerList.length) {
                    this.removeOutgoingLink(containerList[0]);
                }
            }
            this.invalidate();
        };
        PullSymbol.prototype.setType = function (typeRef) {
            if (this.cachedTypeLink) {
                this.unsetType();
            }
            var link = this.addOutgoingLink(typeRef, 0 /* TypedAs */ );
            this.cachedTypeLink = link;
        };
        PullSymbol.prototype.getType = function () {
            if (this.cachedTypeLink) {
                return this.cachedTypeLink.end;
            }
            var typeList = this.findOutgoingLinks(function (link) {
                return link.kind == 0 /* TypedAs */ ;
            });
            if (typeList.length) {
                this.cachedTypeLink = typeList[0];
                return this.cachedTypeLink.end;
            }
            return null;
        };
        PullSymbol.prototype.unsetType = function () {
            var foundType = false;
            if (this.cachedTypeLink) {
                this.removeOutgoingLink(this.cachedTypeLink);
                foundType = true;
            } else {
                var typeList = this.findOutgoingLinks(function (link) {
                    return link.kind == 0 /* TypedAs */ ;
                });
                if (typeList.length) {
                    this.removeOutgoingLink(typeList[0]);
                }
                foundType = true;
            }
            if (foundType) {
                this.invalidate();
            }
        };
        PullSymbol.prototype.isTyped = function () {
            return this.getType() != null;
        };
        PullSymbol.prototype.setResolved = function () {
            this.hasBeenResolved = true;
            this.inResolution = false;
        };
        PullSymbol.prototype.isResolved = function () {
            return this.hasBeenResolved;
        };
        PullSymbol.prototype.startResolving = function () {
            this.inResolution = true;
        };
        PullSymbol.prototype.isResolving = function () {
            return this.inResolution;
        };
        PullSymbol.prototype.startResolvingTypeArguments = function () {
            this.resolvingTypeArguments = true;
        };
        PullSymbol.prototype.isResolvingTypeArguments = function () {
            return this.resolvingTypeArguments;
        };
        PullSymbol.prototype.doneResolvingTypeArguments = function () {
            this.resolvingTypeArguments = false;
        };
        PullSymbol.prototype.invalidate = function () {
            this.removeOutgoingLink(this.cachedContainerLink);
            this.cachedContainerLink = null;
            this.hasBeenResolved = false;
            this.declarations.update(function (pullDecl) {
                return pullDecl.resetErrors();
            }, null);
        };
        PullSymbol.prototype.getDocComments = function () {
            return "";
        };
        PullSymbol.prototype.hasFlag = function (flag) {
            var declarations = this.getDeclarations();
            for(var i = 0, n = declarations.length; i < n; i++) {
                var declaration = declarations[i];
                if ((declaration.getFlags() & flag) !== 0 /* None */ ) {
                    return true;
                }
            }
            return false;
        };
        PullSymbol.prototype.toString = function () {
            var str = this.name;
            var type = this.getType();
            if (type) {
                var typeName;
                if (type.isArray()) {
                    typeName = type.getElementType().getName() + "[]";
                } else {
                    typeName = type.getName();
                }
                str += ": " + typeName;
            }
            return this.name;
        };
        return PullSymbol;
    })();
    TypeScript.PullSymbol = PullSymbol;    
    var PullSignatureSymbol = (function (_super) {
        __extends(PullSignatureSymbol, _super);
        function PullSignatureSymbol(kind) {
                _super.call(this, "", kind);
            this.parameterLinks = null;
            this.typeParameterLinks = null;
            this.returnTypeLink = null;
            this.hasOptionalParam = false;
            this.nonOptionalParamCount = 0;
            this.specializationCache = {};
            this.memberTypeParameterNameCache = null;
            this.hasAGenericParameter = false;
        }
        PullSignatureSymbol.prototype.isDefinition = function () {
            return false;
        };
        PullSignatureSymbol.prototype.hasVariableParamList = function () {
            return this.hasOptionalParam;
        };
        PullSignatureSymbol.prototype.setHasGenericParameter = function () {
            this.hasAGenericParameter = true;
        };
        PullSignatureSymbol.prototype.hasGenericParameter = function () {
            return this.hasAGenericParameter;
        };
        PullSignatureSymbol.prototype.isGeneric = function () {
            return this.hasAGenericParameter || (this.typeParameterLinks && this.typeParameterLinks.length != 0);
        };
        PullSignatureSymbol.prototype.addParameter = function (parameter, isOptional) {
            if (typeof isOptional === "undefined") { isOptional = false; }
            if (!this.parameterLinks) {
                this.parameterLinks = [];
            }
            var link = this.addOutgoingLink(parameter, 12 /* Parameter */ );
            this.parameterLinks[this.parameterLinks.length] = link;
            this.hasOptionalParam = isOptional;
            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        };
        PullSignatureSymbol.prototype.addSpecialization = function (signature, typeArguments) {
            this.specializationCache[getIDForTypeSubstitutions(typeArguments)] = signature;
        };
        PullSignatureSymbol.prototype.getSpecialization = function (typeArguments) {
            var sig = this.specializationCache[getIDForTypeSubstitutions(typeArguments)];
            if (sig) {
                return sig;
            }
            return null;
        };
        PullSignatureSymbol.prototype.addTypeParameter = function (parameter) {
            if (!this.typeParameterLinks) {
                this.typeParameterLinks = [];
            }
            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
            }
            var link = this.addOutgoingLink(parameter, 17 /* TypeParameter */ );
            this.typeParameterLinks[this.typeParameterLinks.length] = link;
            this.memberTypeParameterNameCache[link.end.getName()] = link.end;
        };
        PullSignatureSymbol.prototype.getNonOptionalParameterCount = function () {
            return this.nonOptionalParamCount;
        };
        PullSignatureSymbol.prototype.setReturnType = function (returnType) {
            this.returnTypeLink = this.addOutgoingLink(returnType, 13 /* ReturnType */ );
        };
        PullSignatureSymbol.prototype.getParameters = function () {
            var params = [];
            if (this.parameterLinks) {
                for(var i = 0; i < this.parameterLinks.length; i++) {
                    params[params.length] = this.parameterLinks[i].end;
                }
            }
            return params;
        };
        PullSignatureSymbol.prototype.getTypeParameters = function () {
            var params = [];
            if (this.typeParameterLinks) {
                for(var i = 0; i < this.typeParameterLinks.length; i++) {
                    params[params.length] = this.typeParameterLinks[i].end;
                }
            }
            return params;
        };
        PullSignatureSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;
            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
                if (this.typeParameterLinks) {
                    for(var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }
            memberSymbol = this.memberTypeParameterNameCache[name];
            return memberSymbol;
        };
        PullSignatureSymbol.prototype.removeParameter = function (parameterSymbol) {
            var paramLink;
            if (this.parameterLinks) {
                for(var i = 0; i < this.parameterLinks.length; i++) {
                    if (parameterSymbol == this.parameterLinks[i].end) {
                        paramLink = this.parameterLinks[i];
                        this.removeOutgoingLink(paramLink);
                        break;
                    }
                }
            }
            this.invalidate();
        };
        PullSignatureSymbol.prototype.getReturnType = function () {
            if (this.returnTypeLink) {
                return this.returnTypeLink.end;
            } else {
                var rtl = this.findOutgoingLinks(function (p) {
                    return p.kind == 13 /* ReturnType */ ;
                });
                if (rtl.length) {
                    this.returnTypeLink = rtl[0];
                    return this.returnTypeLink.end;
                }
                return null;
            }
        };
        PullSignatureSymbol.prototype.invalidate = function () {
            this.removeOutgoingLink(this.returnTypeLink);
            this.returnTypeLink = null;
            this.parameterLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 12 /* Parameter */ ;
            });
            this.nonOptionalParamCount = 0;
            this.hasOptionalParam = false;
            this.hasAGenericParameter = false;
            if (this.parameterLinks) {
                for(var i = 0; i < this.parameterLinks.length; i++) {
                    this.parameterLinks[i].end.invalidate();
                    if (!this.parameterLinks[i].end.getIsOptional()) {
                        this.nonOptionalParamCount++;
                    } else {
                        this.hasOptionalParam;
                        break;
                    }
                }
            }
            _super.prototype.invalidate.call(this);
        };
        PullSignatureSymbol.prototype.toString = function () {
            var typeParameters = this.getTypeParameters();
            var typeParameterString = "";
            if (typeParameters && typeParameters.length) {
                typeParameterString = "<";
                for(var i = 0; i < typeParameters.length; i++) {
                    if (i) {
                        typeParameterString += ",";
                    }
                    typeParameterString += typeParameters[i].getName();
                }
                typeParameterString += ">";
            }
            var sigString = typeParameterString + "(";
            var params = this.getParameters();
            var paramType;
            for(var i = 0; i < params.length; i++) {
                sigString += params[i].getName();
                paramType = params[i].getType();
                if (paramType) {
                    sigString += ": " + paramType.getName();
                }
                if (i < params.length - 1) {
                    sigString += ", ";
                }
            }
            sigString += ")";
            var returnType = this.getReturnType();
            if (returnType) {
                sigString += ": " + returnType.getName();
            }
            return sigString;
        };
        return PullSignatureSymbol;
    })(PullSymbol);
    TypeScript.PullSignatureSymbol = PullSignatureSymbol;    
    var PullTypeSymbol = (function (_super) {
        __extends(PullTypeSymbol, _super);
        function PullTypeSymbol() {
            _super.apply(this, arguments);

            this.memberLinks = null;
            this.typeParameterLinks = null;
            this.specializationLinks = null;
            this.memberNameCache = null;
            this.memberTypeNameCache = null;
            this.memberTypeParameterNameCache = null;
            this.typeArguments = null;
            this.specializedTypeCache = null;
            this.memberCache = null;
            this.implementedTypeLinks = null;
            this.extendedTypeLinks = null;
            this.callSignatureLinks = null;
            this.constructSignatureLinks = null;
            this.indexSignatureLinks = null;
            this.arrayType = null;
            this.isSpecialized = false;
            this.isBeingSpecialized = false;
            this.hasGenericSignature = false;
            this.invalidatedSpecializations = false;
        }
        PullTypeSymbol.prototype.isType = function () {
            return true;
        };
        PullTypeSymbol.prototype.isClass = function () {
            return false;
        };
        PullTypeSymbol.prototype.hasMembers = function () {
            return this.memberLinks && this.memberLinks.length != 0;
        };
        PullTypeSymbol.prototype.isFunction = function () {
            return false;
        };
        PullTypeSymbol.prototype.isTypeParameter = function () {
            return false;
        };
        PullTypeSymbol.prototype.isContainer = function () {
            return false;
        };
        PullTypeSymbol.prototype.setIsSpecialized = function () {
            this.isSpecialized = true;
            this.isBeingSpecialized = false;
        };
        PullTypeSymbol.prototype.currentlyBeingSpecialized = function () {
            return this.isBeingSpecialized;
        };
        PullTypeSymbol.prototype.setIsBeingSpecialized = function () {
            this.isBeingSpecialized = true;
        };
        PullTypeSymbol.prototype.setHasGenericSignature = function () {
            this.hasGenericSignature = true;
        };
        PullTypeSymbol.prototype.getType = function () {
            return this;
        };
        PullTypeSymbol.prototype.getArrayType = function () {
            return this.arrayType;
        };
        PullTypeSymbol.prototype.getElementType = function () {
            var arrayOfLinks = this.findOutgoingLinks(function (link) {
                return link.kind == 4 /* ArrayOf */ ;
            });
            if (arrayOfLinks.length) {
                return arrayOfLinks[0].end;
            }
            return null;
        };
        PullTypeSymbol.prototype.setArrayType = function (arrayType) {
            this.arrayType = arrayType;
            arrayType.addOutgoingLink(this, 4 /* ArrayOf */ );
        };
        PullTypeSymbol.prototype.addMember = function (memberSymbol, linkKind) {
            var link = this.addOutgoingLink(memberSymbol, linkKind);
            memberSymbol.setContainer(this, linkKind);
            if (!this.memberCache) {
                this.memberCache = [];
            }
            if (!this.memberNameCache) {
                this.memberNameCache = new TypeScript.BlockIntrinsics();
            }
            if (!this.memberLinks) {
                this.memberLinks = [];
            }
            if (!memberSymbol.isType()) {
                this.memberLinks[this.memberLinks.length] = link;
                this.memberCache[this.memberCache.length] = memberSymbol;
                if (!this.memberNameCache) {
                    this.memberNameCache = new TypeScript.BlockIntrinsics();
                }
                this.memberNameCache[memberSymbol.getName()] = memberSymbol;
            } else {
                if ((memberSymbol).isTypeParameter()) {
                    if (!this.typeParameterLinks) {
                        this.typeParameterLinks = [];
                    }
                    if (!this.memberTypeParameterNameCache) {
                        this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
                    }
                    this.typeParameterLinks[this.typeParameterLinks.length] = link;
                    this.memberTypeParameterNameCache[memberSymbol.getName()] = memberSymbol;
                } else {
                    if (!this.memberTypeNameCache) {
                        this.memberTypeNameCache = new TypeScript.BlockIntrinsics();
                    }
                    this.memberLinks[this.memberLinks.length] = link;
                    this.memberTypeNameCache[memberSymbol.getName()] = memberSymbol;
                    this.memberCache[this.memberCache.length] = memberSymbol;
                }
            }
        };
        PullTypeSymbol.prototype.removeMember = function (memberSymbol) {
            var memberLink;
            var child;
            var links = (memberSymbol.isType() && (memberSymbol).isTypeParameter()) ? this.typeParameterLinks : this.memberLinks;
            if (links) {
                for(var i = 0; i < links.length; i++) {
                    if (memberSymbol == links[i].end) {
                        memberLink = links[i];
                        child = memberLink.end;
                        child.unsetContainer();
                        this.removeOutgoingLink(memberLink);
                        break;
                    }
                }
            }
            this.invalidate();
        };
        PullTypeSymbol.prototype.getMembers = function () {
            if (this.memberCache) {
                return this.memberCache;
            } else {
                var members = [];
                if (this.memberLinks) {
                    for(var i = 0; i < this.memberLinks.length; i++) {
                        members[members.length] = this.memberLinks[i].end;
                    }
                }
                if (members.length) {
                    this.memberCache = members;
                }
                return members;
            }
        };
        PullTypeSymbol.prototype.getTypeParameters = function () {
            var members = [];
            if (this.typeParameterLinks) {
                for(var i = 0; i < this.typeParameterLinks.length; i++) {
                    members[members.length] = this.typeParameterLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.isGeneric = function () {
            return (this.typeParameterLinks && this.typeParameterLinks.length != 0) || this.hasGenericSignature;
        };
        PullTypeSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, substitutingTypes) {
            if (!this.specializedTypeCache) {
                this.specializedTypeCache = {};
            }
            if (!this.specializationLinks) {
                this.specializationLinks = [];
            }
            this.specializationLinks[this.specializationLinks.length] = this.addOutgoingLink(specializedVersionOfThisType, 20 /* SpecializedTo */ );
            this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)] = specializedVersionOfThisType;
        };
        PullTypeSymbol.prototype.getSpecialization = function (substitutingTypes) {
            if (!this.specializedTypeCache) {
                this.specializedTypeCache = {};
                return null;
            }
            var specialization = this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)];
            if (!specialization) {
                return null;
            }
            return specialization;
        };
        PullTypeSymbol.prototype.getKnownSpecializations = function () {
            var specializations = [];
            if (this.specializedTypeCache) {
                for(var specializationID in this.specializedTypeCache) {
                    specializations[specializations.length] = this.specializedTypeCache[specializationID];
                }
            }
            return specializations;
        };
        PullTypeSymbol.prototype.invalidateSpecializations = function () {
            if (this.invalidatedSpecializations) {
                return;
            }
            var specializations = this.getKnownSpecializations();
            for(var i = 0; i < specializations.length; i++) {
                specializations[i].invalidate();
            }
            if (this.specializationLinks && this.specializationLinks.length) {
                for(var i = 0; i < this.specializationLinks.length; i++) {
                    this.removeOutgoingLink(this.specializationLinks[i]);
                }
            }
            this.specializedTypeCache = null;
            this.invalidatedSpecializations = true;
        };
        PullTypeSymbol.prototype.getTypeArguments = function () {
            return this.typeArguments;
        };
        PullTypeSymbol.prototype.setTypeArguments = function (typeArgs) {
            this.typeArguments = typeArgs;
        };
        PullTypeSymbol.prototype.addCallSignature = function (callSignature) {
            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }
            var link = this.addOutgoingLink(callSignature, 14 /* CallSignature */ );
            this.callSignatureLinks[this.callSignatureLinks.length] = link;
            if (callSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };
        PullTypeSymbol.prototype.addCallSignatures = function (callSignatures) {
            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }
            for(var i = 0; i < callSignatures.length; i++) {
                this.addCallSignature(callSignatures[i]);
            }
        };
        PullTypeSymbol.prototype.addConstructSignature = function (constructSignature) {
            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }
            var link = this.addOutgoingLink(constructSignature, 15 /* ConstructSignature */ );
            this.constructSignatureLinks[this.constructSignatureLinks.length] = link;
            if (constructSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };
        PullTypeSymbol.prototype.addConstructSignatures = function (constructSignatures) {
            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }
            for(var i = 0; i < constructSignatures.length; i++) {
                this.addConstructSignature(constructSignatures[i]);
            }
        };
        PullTypeSymbol.prototype.addIndexSignature = function (indexSignature) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }
            var link = this.addOutgoingLink(indexSignature, 16 /* IndexSignature */ );
            this.indexSignatureLinks[this.indexSignatureLinks.length] = link;
            if (indexSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };
        PullTypeSymbol.prototype.addIndexSignatures = function (indexSignatures) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }
            for(var i = 0; i < indexSignatures.length; i++) {
                this.addIndexSignature(indexSignatures[i]);
            }
        };
        PullTypeSymbol.prototype.getCallSignatures = function () {
            var members = [];
            if (this.callSignatureLinks) {
                for(var i = 0; i < this.callSignatureLinks.length; i++) {
                    members[members.length] = this.callSignatureLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.getConstructSignatures = function () {
            var members = [];
            if (this.constructSignatureLinks) {
                for(var i = 0; i < this.constructSignatureLinks.length; i++) {
                    members[members.length] = this.constructSignatureLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.getIndexSignatures = function () {
            var members = [];
            if (this.indexSignatureLinks) {
                for(var i = 0; i < this.indexSignatureLinks.length; i++) {
                    members[members.length] = this.indexSignatureLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.removeCallSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;
            if (this.callSignatureLinks) {
                for(var i = 0; i < this.callSignatureLinks.length; i++) {
                    if (signature == this.callSignatureLinks[i].end) {
                        signatureLink = this.callSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }
            if (invalidate) {
                this.invalidate();
            }
        };
        PullTypeSymbol.prototype.recomputeCallSignatures = function () {
            this.callSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 14 /* CallSignature */ ;
            });
        };
        PullTypeSymbol.prototype.removeConstructSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;
            if (this.constructSignatureLinks) {
                for(var i = 0; i < this.constructSignatureLinks.length; i++) {
                    if (signature == this.constructSignatureLinks[i].end) {
                        signatureLink = this.constructSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }
            if (invalidate) {
                this.invalidate();
            }
        };
        PullTypeSymbol.prototype.recomputeConstructSignatures = function () {
            this.constructSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 15 /* ConstructSignature */ ;
            });
        };
        PullTypeSymbol.prototype.removeIndexSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;
            if (this.indexSignatureLinks) {
                for(var i = 0; i < this.indexSignatureLinks.length; i++) {
                    if (signature == this.indexSignatureLinks[i].end) {
                        signatureLink = this.indexSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }
            if (invalidate) {
                this.invalidate();
            }
        };
        PullTypeSymbol.prototype.recomputeIndexSignatures = function () {
            this.indexSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 16 /* IndexSignature */ ;
            });
        };
        PullTypeSymbol.prototype.addImplementedType = function (interfaceType) {
            if (!this.implementedTypeLinks) {
                this.implementedTypeLinks = [];
            }
            var link = this.addOutgoingLink(interfaceType, 11 /* Implements */ );
            this.implementedTypeLinks[this.implementedTypeLinks.length] = link;
        };
        PullTypeSymbol.prototype.getImplementedTypes = function () {
            var members = [];
            if (this.implementedTypeLinks) {
                for(var i = 0; i < this.implementedTypeLinks.length; i++) {
                    members[members.length] = this.implementedTypeLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.removeImplementedType = function (implementedType) {
            var typeLink;
            if (this.implementedTypeLinks) {
                for(var i = 0; i < this.implementedTypeLinks.length; i++) {
                    if (implementedType == this.implementedTypeLinks[i].end) {
                        typeLink = this.implementedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }
            this.invalidate();
        };
        PullTypeSymbol.prototype.addExtendedType = function (extendedType) {
            if (!this.extendedTypeLinks) {
                this.extendedTypeLinks = [];
            }
            var link = this.addOutgoingLink(extendedType, 10 /* Extends */ );
            this.extendedTypeLinks[this.extendedTypeLinks.length] = link;
        };
        PullTypeSymbol.prototype.getExtendedTypes = function () {
            var members = [];
            if (this.extendedTypeLinks) {
                for(var i = 0; i < this.extendedTypeLinks.length; i++) {
                    members[members.length] = this.extendedTypeLinks[i].end;
                }
            }
            return members;
        };
        PullTypeSymbol.prototype.hasBase = function (potentialBase) {
            if (this == potentialBase) {
                return true;
            }
            var extendedTypes = this.getExtendedTypes();
            for(var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase)) {
                    return true;
                }
            }
            return false;
        };
        PullTypeSymbol.prototype.removeExtendedType = function (extendedType) {
            var typeLink;
            if (this.extendedTypeLinks) {
                for(var i = 0; i < this.extendedTypeLinks.length; i++) {
                    if (extendedType == this.extendedTypeLinks[i].end) {
                        typeLink = this.extendedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }
            this.invalidate();
        };
        PullTypeSymbol.prototype.findMember = function (name) {
            var memberSymbol;
            if (!this.memberNameCache) {
                this.memberNameCache = new TypeScript.BlockIntrinsics();
                this.memberCache = [];
                if (this.memberLinks) {
                    for(var i = 0; i < this.memberLinks.length; i++) {
                        this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                        this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                    }
                }
            }
            memberSymbol = this.memberNameCache[name];
            if (memberSymbol) {
                return memberSymbol;
            }
            if (!memberSymbol && this.extendedTypeLinks) {
                for(var i = 0; i < this.extendedTypeLinks.length; i++) {
                    memberSymbol = (this.extendedTypeLinks[i].end).findMember(name);
                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }
            if (!memberSymbol && this.implementedTypeLinks) {
                for(var i = 0; i < this.implementedTypeLinks.length; i++) {
                    memberSymbol = (this.implementedTypeLinks[i].end).findMember(name);
                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }
            return this.findNestedType(name);
        };
        PullTypeSymbol.prototype.findNestedType = function (name) {
            var memberSymbol;
            if (!this.memberTypeNameCache) {
                this.memberTypeNameCache = new TypeScript.BlockIntrinsics();
                var setAll = false;
                if (!this.memberCache) {
                    this.memberCache = [];
                    setAll = true;
                }
                if (this.memberLinks) {
                    for(var i = 0; i < this.memberLinks.length; i++) {
                        if (this.memberLinks[i].end.isType()) {
                            this.memberTypeNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        } else if (setAll) {
                            this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        }
                    }
                }
            }
            memberSymbol = this.memberTypeNameCache[name];
            return memberSymbol;
        };
        PullTypeSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;
            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
                if (this.typeParameterLinks) {
                    for(var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }
            memberSymbol = this.memberTypeParameterNameCache[name];
            return memberSymbol;
        };
        PullTypeSymbol.prototype.setResolved = function () {
            this.invalidatedSpecializations = true;
            _super.prototype.setResolved.call(this);
        };
        PullTypeSymbol.prototype.invalidate = function () {
            this.memberNameCache = null;
            this.memberCache = null;
            this.invalidatedSpecializations = false;
            this.memberLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 6 /* PrivateMember */  || psl.kind == 5 /* PublicMember */ ;
            });
            this.typeParameterLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 17 /* TypeParameter */ ;
            });
            this.callSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 14 /* CallSignature */ ;
            });
            this.constructSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 15 /* ConstructSignature */ ;
            });
            this.indexSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 16 /* IndexSignature */ ;
            });
            this.implementedTypeLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 11 /* Implements */ ;
            });
            this.extendedTypeLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind == 10 /* Extends */ ;
            });
            _super.prototype.invalidate.call(this);
        };
        PullTypeSymbol.prototype.toString = function () {
            var tstring = this.getName();
            var typarString = "";
            var typars = this.getTypeArguments();
            if (!typars || !typars.length) {
                typars = this.getTypeParameters();
            }
            if (typars && typars.length) {
                typarString = "<";
                for(var i = 0; i < typars.length; i++) {
                    if (i) {
                        typarString += ",";
                    }
                    typarString += typars[i].getName();
                }
                typarString += ">";
            }
            tstring += typarString ? typarString + "{ " : " {";
            var members = this.getMembers();
            var callSigs = this.getCallSignatures();
            var constructSigs = this.getConstructSignatures();
            var indexSigs = this.getIndexSignatures();
            for(var i = 0; i < members.length; i++) {
                tstring += members[i].toString();
                tstring += "; ";
            }
            for(i = 0; i < callSigs.length; i++) {
                tstring += callSigs[i].toString();
                tstring += "; ";
            }
            for(i = 0; i < constructSigs.length; i++) {
                tstring += "new " + constructSigs[i].toString();
                tstring += "; ";
            }
            for(i = 0; i < indexSigs.length; i++) {
                tstring += "[" + indexSigs[i].toString() + "]";
                tstring += "; ";
            }
            tstring += " }";
            return tstring;
        };
        return PullTypeSymbol;
    })(PullSymbol);
    TypeScript.PullTypeSymbol = PullTypeSymbol;    
    var PullPrimitiveTypeSymbol = (function (_super) {
        __extends(PullPrimitiveTypeSymbol, _super);
        function PullPrimitiveTypeSymbol(name) {
                _super.call(this, name, 4 /* Primitive */ );
        }
        PullPrimitiveTypeSymbol.prototype.isResolved = function () {
            return true;
        };
        PullPrimitiveTypeSymbol.prototype.invalidate = function () {
        };
        PullPrimitiveTypeSymbol.prototype.toString = function () {
            return this.getName();
        };
        return PullPrimitiveTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullPrimitiveTypeSymbol = PullPrimitiveTypeSymbol;    
    var PullClassTypeSymbol = (function (_super) {
        __extends(PullClassTypeSymbol, _super);
        function PullClassTypeSymbol(name) {
                _super.call(this, name, 16 /* Class */ );
            this.constructorMethod = null;
        }
        PullClassTypeSymbol.prototype.isClass = function () {
            return true;
        };
        PullClassTypeSymbol.prototype.getConstructorMethod = function () {
            return this.constructorMethod;
        };
        PullClassTypeSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            this.constructorMethod = constructorMethod;
        };
        PullClassTypeSymbol.prototype.invalidate = function () {
            if (this.constructorMethod) {
                this.constructorMethod.invalidate();
            }
            _super.prototype.invalidate.call(this);
        };
        return PullClassTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullClassTypeSymbol = PullClassTypeSymbol;    
    var PullContainerTypeSymbol = (function (_super) {
        __extends(PullContainerTypeSymbol, _super);
        function PullContainerTypeSymbol(name) {
                _super.call(this, name, 8 /* Container */ );
            this.instanceSymbol = null;
        }
        PullContainerTypeSymbol.prototype.isContainer = function () {
            return true;
        };
        PullContainerTypeSymbol.prototype.setInstanceSymbol = function (symbol) {
            this.instanceSymbol = symbol;
        };
        PullContainerTypeSymbol.prototype.getInstanceSymbol = function () {
            return this.instanceSymbol;
        };
        PullContainerTypeSymbol.prototype.invalidate = function () {
            if (this.instanceSymbol) {
                this.instanceSymbol.invalidate();
            }
            _super.prototype.invalidate.call(this);
        };
        return PullContainerTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullContainerTypeSymbol = PullContainerTypeSymbol;    
    var PullDefinitionSignatureSymbol = (function (_super) {
        __extends(PullDefinitionSignatureSymbol, _super);
        function PullDefinitionSignatureSymbol() {
            _super.apply(this, arguments);

        }
        PullDefinitionSignatureSymbol.prototype.isDefinition = function () {
            return true;
        };
        return PullDefinitionSignatureSymbol;
    })(PullSignatureSymbol);
    TypeScript.PullDefinitionSignatureSymbol = PullDefinitionSignatureSymbol;    
    var PullFunctionTypeSymbol = (function (_super) {
        __extends(PullFunctionTypeSymbol, _super);
        function PullFunctionTypeSymbol() {
                _super.call(this, "", 33554432 /* FunctionType */ );
            this.definitionSignature = null;
        }
        PullFunctionTypeSymbol.prototype.isFunction = function () {
            return true;
        };
        PullFunctionTypeSymbol.prototype.invalidate = function () {
            var callSignatures = this.getCallSignatures();
            if (callSignatures.length) {
                for(var i = 0; i < callSignatures.length; i++) {
                    callSignatures[i].invalidate();
                }
            }
            this.definitionSignature = null;
            _super.prototype.invalidate.call(this);
        };
        PullFunctionTypeSymbol.prototype.addSignature = function (signature) {
            this.addCallSignature(signature);
            if (signature.isDefinition()) {
                this.definitionSignature = signature;
            }
        };
        PullFunctionTypeSymbol.prototype.getDefinitionSignature = function () {
            return this.definitionSignature;
        };
        return PullFunctionTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullFunctionTypeSymbol = PullFunctionTypeSymbol;    
    var PullConstructorTypeSymbol = (function (_super) {
        __extends(PullConstructorTypeSymbol, _super);
        function PullConstructorTypeSymbol() {
                _super.call(this, "", 67108864 /* ConstructorType */ );
            this.definitionSignature = null;
        }
        PullConstructorTypeSymbol.prototype.isFunction = function () {
            return true;
        };
        PullConstructorTypeSymbol.prototype.isConstructor = function () {
            return true;
        };
        PullConstructorTypeSymbol.prototype.invalidate = function () {
            this.definitionSignature = null;
            _super.prototype.invalidate.call(this);
        };
        PullConstructorTypeSymbol.prototype.addSignature = function (signature) {
            this.addConstructSignature(signature);
            if (signature.isDefinition()) {
                this.definitionSignature = signature;
            }
        };
        PullConstructorTypeSymbol.prototype.addTypeParameter = function (typeParameter) {
            this.addMember(typeParameter, 17 /* TypeParameter */ );
            var constructSignatures = this.getConstructSignatures();
            for(var i = 0; i < constructSignatures.length; i++) {
                constructSignatures[i].addTypeParameter(typeParameter);
            }
        };
        PullConstructorTypeSymbol.prototype.getDefinitionSignature = function () {
            return this.definitionSignature;
        };
        return PullConstructorTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullConstructorTypeSymbol = PullConstructorTypeSymbol;    
    var PullTypeParameterSymbol = (function (_super) {
        __extends(PullTypeParameterSymbol, _super);
        function PullTypeParameterSymbol(name) {
                _super.call(this, name, 16384 /* TypeParameter */ );
            this.constraintLink = null;
        }
        PullTypeParameterSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeParameterSymbol.prototype.setConstraint = function (constraintType) {
            if (this.constraintLink) {
                this.removeOutgoingLink(this.constraintLink);
            }
            this.constraintLink = this.addOutgoingLink(constraintType, 21 /* TypeConstraint */ );
        };
        PullTypeParameterSymbol.prototype.getConstraint = function () {
            if (this.constraintLink) {
                return this.constraintLink.end;
            }
            return null;
        };
        PullTypeParameterSymbol.prototype.isGeneric = function () {
            return true;
        };
        return PullTypeParameterSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeParameterSymbol = PullTypeParameterSymbol;    
    var PullArrayTypeSymbol = (function (_super) {
        __extends(PullArrayTypeSymbol, _super);
        function PullArrayTypeSymbol() {
                _super.call(this, "Array", 256 /* Array */ );
            this.elementType = null;
        }
        PullArrayTypeSymbol.prototype.isArray = function () {
            return true;
        };
        PullArrayTypeSymbol.prototype.getElementType = function () {
            return this.elementType;
        };
        PullArrayTypeSymbol.prototype.isGeneric = function () {
            return true;
        };
        PullArrayTypeSymbol.prototype.setElementType = function (type) {
            this.elementType = type;
        };
        PullArrayTypeSymbol.prototype.getName = function () {
            return this.toString();
        };
        PullArrayTypeSymbol.prototype.toString = function () {
            var elementTypeName = this.elementType ? this.elementType.getName() : "TypeArg";
            return "Array<" + elementTypeName + ">";
        };
        return PullArrayTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullArrayTypeSymbol = PullArrayTypeSymbol;    
    function specializeToArrayType(typeToReplace, typeToSpecializeTo, resolver, context) {
        var arrayInterfaceType = resolver.getCachedArrayType();
        if (!arrayInterfaceType || (arrayInterfaceType.getKind() & 32 /* Interface */ ) == 0) {
            return null;
        }
        if (arrayInterfaceType.isGeneric()) {
            var enclosingDecl = arrayInterfaceType.getDeclarations()[0];
            return specializeType(arrayInterfaceType, [
                typeToSpecializeTo
            ], resolver, enclosingDecl, context);
        }
        if (typeToSpecializeTo.getArrayType()) {
            return typeToSpecializeTo.getArrayType();
        }
        var newArrayType = new PullTypeSymbol(arrayInterfaceType.getName(), arrayInterfaceType.getKind() | 256 /* Array */ );
        newArrayType.addDeclaration(arrayInterfaceType.getDeclarations()[0]);
        typeToSpecializeTo.setArrayType(newArrayType);
        newArrayType.addOutgoingLink(typeToSpecializeTo, 4 /* ArrayOf */ );
        var field = null;
        var newField = null;
        var fieldType = null;
        var method = null;
        var methodType = null;
        var newMethod = null;
        var newMethodType = null;
        var signatures = null;
        var newSignature = null;
        var parameters = null;
        var newParameter = null;
        var parameterType = null;
        var returnType = null;
        var newReturnType = null;
        var members = arrayInterfaceType.getMembers();
        for(var i = 0; i < members.length; i++) {
            resolver.resolveDeclaredSymbol(members[i], null, context);
            if (members[i].getKind() == 131072 /* Method */ ) {
                method = members[i];
                resolver.resolveDeclaredSymbol(method, null, context);
                methodType = method.getType();
                newMethod = new PullSymbol(method.getName(), 131072 /* Method */ );
                newMethodType = new PullFunctionTypeSymbol();
                newMethod.setType(newMethodType);
                newMethod.addDeclaration(method.getDeclarations()[0]);
                signatures = methodType.getCallSignatures();
                for(var j = 0; j < signatures.length; j++) {
                    newSignature = new PullSignatureSymbol(2097152 /* CallSignature */ );
                    newSignature.addDeclaration(signatures[j].getDeclarations()[0]);
                    parameters = signatures[j].getParameters();
                    returnType = signatures[j].getReturnType();
                    if (returnType == typeToReplace) {
                        newSignature.setReturnType(typeToSpecializeTo);
                    } else {
                        newSignature.setReturnType(returnType);
                    }
                    for(var k = 0; k < parameters.length; k++) {
                        newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());
                        parameterType = parameters[k].getType();
                        if (parameterType == typeToReplace) {
                            newParameter.setType(typeToSpecializeTo);
                        } else {
                            newParameter.setType(parameterType);
                        }
                        newSignature.addParameter(newParameter);
                    }
                    newMethodType.addSignature(newSignature);
                }
                newArrayType.addMember(newMethod, 5 /* PublicMember */ );
            } else {
                field = members[i];
                newField = new PullSymbol(field.getName(), field.getKind());
                newField.addDeclaration(field.getDeclarations()[0]);
                fieldType = field.getType();
                if (fieldType == typeToReplace) {
                    newField.setType(typeToSpecializeTo);
                } else {
                    newField.setType(fieldType);
                }
                newArrayType.addMember(newField, 5 /* PublicMember */ );
            }
        }
        newArrayType.addOutgoingLink(arrayInterfaceType, 3 /* ArrayType */ );
        return newArrayType;
    }
    TypeScript.specializeToArrayType = specializeToArrayType;
    function specializeType(typeToSpecialize, typeArguments, resolver, enclosingDecl, context, ast) {
        if (typeToSpecialize.isPrimitive() || !typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }
        if (typeToSpecialize.currentlyBeingSpecialized()) {
            return typeToSpecialize;
        }
        if (typeToSpecialize.isTypeParameter()) {
            if (context.specializingToAny) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            var subsitution = context.findSpecializationForType(typeToSpecialize);
            if (subsitution) {
                return subsitution;
            }
            if (typeArguments.length) {
                return typeArguments[0];
            }
        }
        if (typeToSpecialize.isArray()) {
            var elementType = (typeToSpecialize).getElementType();
            var newElementType = specializeType(elementType, typeArguments, resolver, enclosingDecl, context, ast);
            var newArrayType = specializeType(resolver.getCachedArrayType(), [
                newElementType
            ], resolver, enclosingDecl, context);
            return newArrayType;
        }
        var typeParameters = typeToSpecialize.getTypeParameters();
        var isArray = typeToSpecialize == resolver.getCachedArrayType() || typeToSpecialize.isArray();
        if (!typeArguments.length) {
            for(var i = 0; i < typeParameters.length; i++) {
                typeArguments[typeArguments.length] = resolver.semanticInfoChain.anyTypeSymbol;
            }
        }
        var newType = typeToSpecialize.getSpecialization(typeArguments);
        if (newType) {
            if (!newType.isResolved() && !newType.currentlyBeingSpecialized()) {
                typeToSpecialize.invalidateSpecializations();
            } else {
                return newType;
            }
        }
        newType = typeToSpecialize.isClass() ? new PullClassTypeSymbol(typeToSpecialize.getName()) : isArray ? new PullArrayTypeSymbol() : new PullTypeSymbol(typeToSpecialize.getName(), typeToSpecialize.getKind());
        newType.addDeclaration(typeToSpecialize.getDeclarations()[0]);
        newType.setIsBeingSpecialized();
        typeToSpecialize.addSpecialization(newType, typeArguments);
        if (isArray) {
            (newType).setElementType(typeArguments[0]);
        }
        var typeReplacementMap = {};
        for(var i = 0; i < typeParameters.length; i++) {
            typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            newType.addMember(typeParameters[i], 17 /* TypeParameter */ );
        }
        var extendedTypesToSpecialize = typeToSpecialize.getExtendedTypes();
        if (extendedTypesToSpecialize.length) {
            var typeDecl = typeToSpecialize.getDeclarations()[0];
            var typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl, typeDecl.getScriptName());
            var unitPath = resolver.getUnitPath();
            resolver.setUnitPath(typeDecl.getScriptName());
            context.pushTypeSpecializationCache(typeReplacementMap);
            var extendTypeSymbol = resolver.resolveTypeReference(new TypeScript.TypeReference(typeAST.extendsList.members[0], 0), typeDecl, context);
            resolver.setUnitPath(unitPath);
            newType.addExtendedType(extendTypeSymbol);
        }
        var implementedTypesToSpecialize = typeToSpecialize.getImplementedTypes();
        if (implementedTypesToSpecialize.length) {
            var typeDecl = typeToSpecialize.getDeclarations()[0];
            var typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl, typeDecl.getScriptName());
            var unitPath = resolver.getUnitPath();
            resolver.setUnitPath(typeDecl.getScriptName());
            context.pushTypeSpecializationCache(typeReplacementMap);
            var implementedTypeSymbol = resolver.resolveTypeReference(new TypeScript.TypeReference(typeAST.implementsList.members[0], 0), typeDecl, context);
            resolver.setUnitPath(unitPath);
            newType.addImplementedType(implementedTypeSymbol);
        }
        var callSignatures = typeToSpecialize.getCallSignatures();
        var constructSignatures = typeToSpecialize.getConstructSignatures();
        var indexSignatures = typeToSpecialize.getIndexSignatures();
        var members = typeToSpecialize.getMembers();
        var newSignature;
        var signature;
        var decl = null;
        var decls = null;
        var declAST = null;
        var unitPath = null;
        for(var i = 0; i < callSignatures.length; i++) {
            signature = callSignatures[i];
            context.pushTypeSpecializationCache(typeReplacementMap);
            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());
            declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());
            resolver.resolveAST(declAST, false, enclosingDecl, context);
            resolver.setUnitPath(unitPath);
            newSignature = specializeSignature(signature, true, typeReplacementMap, typeArguments, resolver, enclosingDecl, context);
            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            newSignature.addDeclaration(decl);
            newType.addCallSignature(newSignature);
            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }
        for(var i = 0; i < constructSignatures.length; i++) {
            signature = constructSignatures[i];
            context.pushTypeSpecializationCache(typeReplacementMap);
            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());
            declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());
            resolver.resolveAST(declAST, false, enclosingDecl, context);
            resolver.setUnitPath(unitPath);
            newSignature = specializeSignature(signature, true, typeReplacementMap, typeArguments, resolver, enclosingDecl, context);
            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            newSignature.addDeclaration(decl);
            newType.addConstructSignature(newSignature);
            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }
        for(var i = 0; i < indexSignatures.length; i++) {
            signature = indexSignatures[i];
            context.pushTypeSpecializationCache(typeReplacementMap);
            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());
            declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());
            resolver.resolveAST(declAST, false, enclosingDecl, context);
            resolver.setUnitPath(unitPath);
            newSignature = specializeSignature(signature, true, typeReplacementMap, typeArguments, resolver, enclosingDecl, context);
            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            newSignature.addDeclaration(decl);
            newType.addIndexSignature(newSignature);
            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }
        context.popTypeSpecializationCache();
        var field = null;
        var newField = null;
        var fieldType = null;
        var newFieldType = null;
        var replacementType = null;
        for(var i = 0; i < members.length; i++) {
            field = members[i];
            resolver.resolveDeclaredSymbol(field, enclosingDecl, context);
            decls = field.getDeclarations();
            newField = new PullSymbol(field.getName(), field.getKind());
            fieldType = field.getType();
            replacementType = typeReplacementMap[fieldType.getSymbolID().toString()];
            if (replacementType) {
                newField.setType(replacementType);
                decl = decls[0];
                for(var j = 0; j < decls.length; j++) {
                    newField.addDeclaration(decls[j]);
                }
            } else {
                field.invalidate();
                if (fieldType.isFunction()) {
                    fieldType.invalidate();
                }
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decls[0].getScriptName());
                context.pushTypeSpecializationCache(typeReplacementMap);
                for(var j = 0; j < decls.length; j++) {
                    decl = decls[j];
                    newField.addDeclaration(decl);
                    declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());
                    fieldType = (resolver.resolveAST(declAST, false, enclosingDecl, context)).getType();
                    if (fieldType.isFunction) {
                        fieldType.addDeclaration(decl);
                    }
                }
                newFieldType = specializeType(fieldType, typeArguments, resolver, enclosingDecl, context, ast);
                resolver.setUnitPath(unitPath);
                context.popTypeSpecializationCache();
                newField.setType(newFieldType);
            }
            newType.addMember(newField, (decl.getFlags() & 2 /* Private */ ) ? 6 /* PrivateMember */  : 5 /* PublicMember */ );
        }
        if (typeToSpecialize.isClass()) {
            var constructorMethod = (typeToSpecialize).getConstructorMethod();
            var newConstructorMethod = new PullSymbol(constructorMethod.getName(), 65536 /* ConstructorMethod */ );
            var newConstructorType = specializeType(constructorMethod.getType(), typeArguments, resolver, enclosingDecl, context, ast);
            newConstructorMethod.setType(newConstructorType);
            var constructorDecls = constructorMethod.getDeclarations();
            for(var i = 0; i < constructorDecls.length; i++) {
                newConstructorMethod.addDeclaration(constructorDecls[i]);
                newConstructorType.addDeclaration(constructorDecls[i]);
            }
            (newType).setConstructorMethod(newConstructorMethod);
        }
        newType.setIsSpecialized();
        newType.setTypeArguments(typeArguments);
        newType.setResolved();
        return newType;
    }
    TypeScript.specializeType = specializeType;
    function specializeSignature(signature, skipLocalTypeParameters, typeReplacementMap, typeArguments, resolver, enclosingDecl, context, ast) {
        var newSignature = signature.getSpecialization(typeArguments);
        if (newSignature) {
            return newSignature;
        }
        newSignature = new PullSignatureSymbol(signature.getKind());
        newSignature.addDeclaration(signature.getDeclarations()[0]);
        signature.addSpecialization(newSignature, typeArguments);
        var parameters = signature.getParameters();
        var typeParameters = signature.getTypeParameters();
        var returnType = signature.getReturnType();
        for(var i = 0; i < typeParameters.length; i++) {
            newSignature.addTypeParameter(typeParameters[i]);
        }
        if (signature.hasGenericParameter()) {
            newSignature.setHasGenericParameter();
        }
        context.pushTypeSpecializationCache(typeReplacementMap);
        var newReturnType = specializeType(returnType, typeArguments, resolver, enclosingDecl, context, ast);
        context.popTypeSpecializationCache();
        if (newReturnType != returnType) {
            newReturnType.addDeclaration(returnType.getDeclarations()[0]);
        }
        newSignature.setReturnType(newReturnType);
        var newParameter;
        var newParameterType;
        var newParameterElementType;
        var parameterType;
        var replacementParameterType;
        var localTypeParameters = {};
        if (skipLocalTypeParameters) {
            for(var i = 0; i < typeParameters.length; i++) {
                localTypeParameters[typeParameters[i].getName()] = true;
            }
        }
        for(var k = 0; k < parameters.length; k++) {
            newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());
            newParameter.addDeclaration(parameters[k].getDeclarations()[0]);
            parameterType = parameters[k].getType();
            context.pushTypeSpecializationCache(typeReplacementMap);
            var newParameterType = !localTypeParameters[parameterType.getName()] ? specializeType(parameterType, typeArguments, resolver, enclosingDecl, context, ast) : parameterType;
            context.popTypeSpecializationCache();
            if (newParameterType != parameterType) {
                newParameterType.addDeclaration(parameterType.getDeclarations()[0]);
            }
            newParameter.setType(newParameterType);
            newSignature.addParameter(newParameter);
        }
        return newSignature;
    }
    TypeScript.specializeSignature = specializeSignature;
    function getIDForTypeSubstitutions(types) {
        var substitution = "";
        for(var i = 0; i < types.length; i++) {
            substitution += types[i].getSymbolID().toString() + "#";
        }
        return substitution;
    }
    TypeScript.getIDForTypeSubstitutions = getIDForTypeSubstitutions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullSymbolBindingContext = (function () {
        function PullSymbolBindingContext(semanticInfoChain, scriptName, useFidelity) {
            if (typeof useFidelity === "undefined") { useFidelity = false; }
            this.semanticInfoChain = semanticInfoChain;
            this.scriptName = scriptName;
            this.useFidelity = useFidelity;
            this.parentChain = [];
            this.declPath = [];
            this.reBindingAfterChange = false;
            this.startingDeclForRebind = TypeScript.pullDeclID;
            this.semanticInfo = this.semanticInfoChain.getUnit(this.scriptName);
        }
        PullSymbolBindingContext.prototype.getParent = function (n) {
            if (typeof n === "undefined") { n = 0; }
            return this.parentChain ? this.parentChain[this.parentChain.length - 1 - n] : null;
        };
        PullSymbolBindingContext.prototype.getDeclPath = function () {
            return this.declPath;
        };
        PullSymbolBindingContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.getName();
            }
        };
        PullSymbolBindingContext.prototype.popParent = function () {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        };
        return PullSymbolBindingContext;
    })();
    TypeScript.PullSymbolBindingContext = PullSymbolBindingContext;    
    TypeScript.time_in_findSymbol = 0;
    function findSymbolInContext(name, declKind, context, typeLookupPath) {
        var startTime = new Date().getTime();
        var contextSymbolPath = context.getDeclPath();
        var nestedSymbolPath = [];
        var copyOfContextSymbolPath = [];
        var symbol = null;
        if (typeLookupPath.length) {
            for(var i = 0; i < typeLookupPath.length; i++) {
                nestedSymbolPath[nestedSymbolPath.length] = typeLookupPath[i];
            }
            nestedSymbolPath[nestedSymbolPath.length] = name;
            while(nestedSymbolPath.length >= 2) {
                symbol = context.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);
                if (symbol) {
                    var endTime = new Date().getTime();
                    TypeScript.time_in_findSymbol += endTime - startTime;
                    return symbol;
                }
                nestedSymbolPath.length -= 2;
                nestedSymbolPath[nestedSymbolPath.length] = name;
            }
        }
        if (contextSymbolPath.length) {
            for(var i = 0; i < contextSymbolPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i];
            }
            for(var i = 0; i < typeLookupPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = typeLookupPath[i];
            }
            copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
            while(copyOfContextSymbolPath.length >= 2) {
                symbol = context.semanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);
                if (symbol) {
                    var endTime = new Date().getTime();
                    TypeScript.time_in_findSymbol += endTime - startTime;
                    return symbol;
                }
                copyOfContextSymbolPath.length -= 2;
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
            }
        }
        symbol = context.semanticInfoChain.findSymbol([
            name
        ], declKind);
        var endTime = new Date().getTime();
        TypeScript.time_in_findSymbol += endTime - startTime;
        return symbol;
    }
    TypeScript.findSymbolInContext = findSymbolInContext;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CandidateInferenceInfo = (function () {
        function CandidateInferenceInfo() {
            this.typeParameter = null;
            this.isFixed = false;
            this.inferenceCandidates = [];
        }
        CandidateInferenceInfo.prototype.addCandidate = function (candidate) {
            if (!this.isFixed) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        };
        return CandidateInferenceInfo;
    })();
    TypeScript.CandidateInferenceInfo = CandidateInferenceInfo;    
    var ArgumentInferenceContext = (function () {
        function ArgumentInferenceContext() {
            this.candidateCache = {};
        }
        ArgumentInferenceContext.prototype.getInferenceInfo = function (param) {
            var info = this.candidateCache[param.getSymbolID().toString()];
            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.getSymbolID().toString()] = info;
            }
            return info;
        };
        ArgumentInferenceContext.prototype.addCandidateForInference = function (param, candidate, fix) {
            var info = this.getInferenceInfo(param);
            if (candidate) {
                info.addCandidate(candidate);
            }
            if (!info.isFixed) {
                info.isFixed = fix;
            }
        };
        ArgumentInferenceContext.prototype.getInferenceCandidates = function () {
            var inferenceCandidates = [];
            var info;
            var val;
            for(var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];
                for(var i = 0; i < info.inferenceCandidates.length; i++) {
                    val = {};
                    val[info.typeParameter.getSymbolID().toString()] = info.inferenceCandidates[i];
                    inferenceCandidates[inferenceCandidates.length] = val;
                }
            }
            return inferenceCandidates;
        };
        ArgumentInferenceContext.prototype.inferArgumentTypes = function (resolver, context) {
            var info = null;
            var collection;
            var bestCommonType;
            var results = [];
            var unfit = false;
            for(var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];
                collection = {
                    getLength: function () {
                        return info.inferenceCandidates.length;
                    },
                    setTypeAtIndex: function (index, type) {
                    },
                    getTypeAtIndex: function (index) {
                        return info.inferenceCandidates[index].getType();
                    }
                };
                bestCommonType = resolver.findBestCommonType(info.inferenceCandidates[0], null, collection, true, context, new TypeScript.TypeComparisonInfo());
                if (!bestCommonType) {
                    bestCommonType = resolver.semanticInfoChain.undefinedTypeSymbol;
                }
                if (bestCommonType == resolver.semanticInfoChain.undefinedTypeSymbol) {
                    unfit = true;
                }
                results[results.length] = {
                    param: info.typeParameter,
                    type: bestCommonType
                };
            }
            return {
                results: results,
                unfit: unfit
            };
        };
        return ArgumentInferenceContext;
    })();
    TypeScript.ArgumentInferenceContext = ArgumentInferenceContext;    
    var PullContextualTypeContext = (function () {
        function PullContextualTypeContext(contextualType, provisional, substitutions) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.substitutions = substitutions;
            this.provisionallyTypedSymbols = [];
            this.provisionalErrors = [];
        }
        PullContextualTypeContext.prototype.recordProvisionallyTypedSymbol = function (symbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        };
        PullContextualTypeContext.prototype.invalidateProvisionallyTypedSymbols = function () {
            for(var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].invalidate();
            }
        };
        PullContextualTypeContext.prototype.postError = function (error) {
            this.provisionalErrors[this.provisionalErrors.length] = error;
        };
        PullContextualTypeContext.prototype.hadProvisionalErrors = function () {
            return this.provisionalErrors.length > 0;
        };
        return PullContextualTypeContext;
    })();
    TypeScript.PullContextualTypeContext = PullContextualTypeContext;    
    var PullTypeResolutionContext = (function () {
        function PullTypeResolutionContext() {
            this.contextStack = [];
            this.typeSpecializationStack = [];
            this.resolvingTypeReference = false;
            this.resolveAggressively = false;
            this.searchTypeSpace = false;
            this.specializingToAny = false;
        }
        PullTypeResolutionContext.prototype.pushContextualType = function (type, provisional, substitutions) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, substitutions));
        };
        PullTypeResolutionContext.prototype.popContextualType = function () {
            var tc = this.contextStack.pop();
            tc.invalidateProvisionallyTypedSymbols();
            return tc;
        };
        PullTypeResolutionContext.prototype.findSubstitution = function (type) {
            var substitution = null;
            if (this.contextStack.length) {
                for(var i = this.contextStack.length - 1; i >= 0; i--) {
                    if (this.contextStack[i].substitutions) {
                        substitution = this.contextStack[i].substitutions[type.getSymbolID().toString()];
                        if (substitution) {
                            break;
                        }
                    }
                }
            }
            return substitution;
        };
        PullTypeResolutionContext.prototype.getContextualType = function () {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];
            if (context) {
                var type = context.contextualType;
                if (type.isTypeParameter() && (type).getConstraint()) {
                    type = (type).getConstraint();
                }
                var substitution = this.findSubstitution(type);
                return substitution ? substitution : type;
            }
            return null;
        };
        PullTypeResolutionContext.prototype.inProvisionalResolution = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };
        PullTypeResolutionContext.prototype.setTypeInContext = function (symbol, type) {
            var substitution = this.findSubstitution(type);
            symbol.setType(substitution ? substitution : type);
            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        };
        PullTypeResolutionContext.prototype.pushTypeSpecializationCache = function (cache) {
            this.typeSpecializationStack[this.typeSpecializationStack.length] = cache;
        };
        PullTypeResolutionContext.prototype.popTypeSpecializationCache = function () {
            if (this.typeSpecializationStack.length) {
                this.typeSpecializationStack.length--;
            }
        };
        PullTypeResolutionContext.prototype.findSpecializationForType = function (type) {
            var specialization = null;
            for(var i = this.typeSpecializationStack.length - 1; i >= 0; i--) {
                specialization = (this.typeSpecializationStack[i])[type.getSymbolID().toString()];
                if (specialization) {
                    return specialization;
                }
            }
            return type;
        };
        PullTypeResolutionContext.prototype.postError = function (offset, length, filename, message, enclosingDecl) {
            var error = new TypeScript.PullError(offset, length, filename, message);
            if (this.inProvisionalResolution()) {
                (this.contextStack[this.contextStack.length - 1]).postError(error);
            } else if (enclosingDecl) {
                enclosingDecl.addError(error);
            }
        };
        return PullTypeResolutionContext;
    })();
    TypeScript.PullTypeResolutionContext = PullTypeResolutionContext;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullResolutionDataCache = (function () {
        function PullResolutionDataCache() {
            this.cacheSize = 16;
            this.rdCache = [];
            this.nextUp = 0;
            for(var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: i
                };
            }
        }
        PullResolutionDataCache.prototype.getResolutionData = function () {
            var rd = null;
            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }
            if (rd == null) {
                this.cacheSize++;
                rd = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }
            this.nextUp++;
            return rd;
        };
        PullResolutionDataCache.prototype.returnResolutionData = function (rd) {
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;
            this.nextUp = rd.id;
        };
        return PullResolutionDataCache;
    })();
    TypeScript.PullResolutionDataCache = PullResolutionDataCache;    
    var PullTypeResolver = (function () {
        function PullTypeResolver(semanticInfoChain, unitPath) {
            this.semanticInfoChain = semanticInfoChain;
            this.unitPath = unitPath;
            this.cachedArrayInterfaceType = null;
            this.cachedNumberInterfaceType = null;
            this.cachedStringInterfaceType = null;
            this.cachedBooleanInterfaceType = null;
            this.cachedObjectInterfaceType = null;
            this.cachedFunctionInterfaceType = null;
            this.cachedIArgumentsInterfaceType = null;
            this.assignableCache = {};
            this.subtypeCache = {};
            this.identicalCache = {};
            this.resolutionDataCache = new PullResolutionDataCache();
            this.currentUnit = null;
            this.cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", [], 32 /* Interface */ );
            this.cachedNumberInterfaceType = this.getSymbolFromDeclPath("Number", [], 32 /* Interface */ );
            this.cachedStringInterfaceType = this.getSymbolFromDeclPath("String", [], 32 /* Interface */ );
            this.cachedBooleanInterfaceType = this.getSymbolFromDeclPath("Boolean", [], 32 /* Interface */ );
            this.cachedObjectInterfaceType = this.getSymbolFromDeclPath("Object", [], 32 /* Interface */ );
            this.cachedFunctionInterfaceType = this.getSymbolFromDeclPath("Function", [], 32 /* Interface */ );
            this.cachedIArgumentsInterfaceType = this.getSymbolFromDeclPath("IArguments", [], 32 /* Interface */ );
            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        }
        PullTypeResolver.prototype.getUnitPath = function () {
            return this.unitPath;
        };
        PullTypeResolver.prototype.setUnitPath = function (unitPath) {
            this.unitPath = unitPath;
            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        };
        PullTypeResolver.prototype.getDeclForAST = function (ast, unitPath) {
            return this.semanticInfoChain.getDeclForAST(ast, unitPath ? unitPath : this.unitPath);
        };
        PullTypeResolver.prototype.getSymbolForAST = function (ast, unitPath) {
            return this.semanticInfoChain.getSymbolForAST(ast, unitPath ? unitPath : this.unitPath);
        };
        PullTypeResolver.prototype.setSymbolForAST = function (ast, typeSymbol, unitPath) {
            return this.semanticInfoChain.setSymbolForAST(ast, typeSymbol, unitPath ? unitPath : this.unitPath);
        };
        PullTypeResolver.prototype.getASTForSymbol = function (symbol, unitPath) {
            return this.semanticInfoChain.getASTForSymbol(symbol, unitPath ? unitPath : this.unitPath);
        };
        PullTypeResolver.prototype.getCachedArrayType = function () {
            return this.cachedArrayInterfaceType;
        };
        PullTypeResolver.prototype.getPathToDecl = function (decl) {
            if (!decl) {
                return [];
            }
            var decls = [];
            var searchDecls = this.semanticInfoChain.getUnit(decl.getScriptName()).getTopLevelDecls();
            var spanToFind = decl.getSpan();
            var candidateSpan = null;
            var searchKinds = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeFunction;
            var found = false;
            while(true) {
                found = false;
                for(var i = 0; i < searchDecls.length; i++) {
                    candidateSpan = searchDecls[i].getSpan();
                    if (spanToFind.minChar >= candidateSpan.minChar && spanToFind.limChar <= candidateSpan.limChar) {
                        if (searchDecls[i].getKind() & searchKinds) {
                            decls[decls.length] = searchDecls[i];
                            searchDecls = searchDecls[i].getChildDecls();
                            found = true;
                        }
                    }
                }
                if (!found) {
                    break;
                }
            }
            if (decls.length && (decl.getKind() & (TypeScript.PullElementKind.SomeFunction | 16777216 /* ObjectType */  | 33554432 /* FunctionType */  | 67108864 /* ConstructorType */ )) && (decls[decls.length - 1] != decl)) {
                decls[decls.length] = decl;
            }
            return decls;
        };
        PullTypeResolver.prototype.getEnclosingDecl = function (decl) {
            var declPath = this.getPathToDecl(decl);
            if (!declPath.length) {
                return null;
            } else if (declPath.length > 1 && declPath[declPath.length - 1] == decl) {
                return declPath[declPath.length - 2];
            } else {
                return declPath[declPath.length - 1];
            }
        };
        PullTypeResolver.prototype.findSymbolForPath = function (pathToName, enclosingDecl, declKind) {
            if (!pathToName.length) {
                return null;
            }
            var symbolName = pathToName[pathToName.length - 1];
            var contextDeclPath = this.getPathToDecl(enclosingDecl);
            var contextSymbolPath = [];
            var nestedSymbolPath = [];
            for(var i = 0; i < pathToName.length; i++) {
                nestedSymbolPath[nestedSymbolPath.length] = pathToName[i];
            }
            var symbol = null;
            while(nestedSymbolPath.length >= 2) {
                symbol = this.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);
                if (symbol) {
                    return symbol;
                }
                nestedSymbolPath.length -= 2;
                nestedSymbolPath[nestedSymbolPath.length] = symbolName;
            }
            for(var i = 0; i < contextDeclPath.length; i++) {
                contextSymbolPath[contextSymbolPath.length] = contextDeclPath[i].getName();
            }
            for(var i = 0; i < pathToName.length; i++) {
                contextSymbolPath[contextSymbolPath.length] = pathToName[i];
            }
            while(contextSymbolPath.length >= 2) {
                symbol = this.semanticInfoChain.findSymbol(contextSymbolPath, declKind);
                if (symbol) {
                    return symbol;
                }
                contextSymbolPath.length -= 2;
                contextSymbolPath[contextSymbolPath.length] = symbolName;
            }
            symbol = this.semanticInfoChain.findSymbol([
                symbolName
            ], declKind);
            return symbol;
        };
        PullTypeResolver.prototype.getSymbolFromDeclPath = function (symbolName, declPath, declSearchKind) {
            var symbol = null;
            var decl = null;
            var childDecls;
            var declSymbol = null;
            var declMembers;
            var pathDeclKind;
            for(var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.getKind();
                if (pathDeclKind & 8 /* Container */ ) {
                    childDecls = decl.findChildDecls(symbolName, declSearchKind);
                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }
                    declSymbol = decl.getSymbol();
                    declMembers = declSymbol.getMembers();
                    var kind;
                    for(var j = 0; j < declMembers.length; j++) {
                        if (declMembers[j].getName() == symbolName) {
                            kind = declMembers[j].getKind();
                            if ((kind & declSearchKind) != 0) {
                                return declMembers[j];
                            }
                        }
                    }
                } else {
                    childDecls = decl.findChildDecls(symbolName, declSearchKind);
                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }
                }
            }
            symbol = this.semanticInfoChain.findSymbol([
                symbolName
            ], declSearchKind);
            return symbol;
        };
        PullTypeResolver.prototype.resolveDeclaration = function (declAST, context) {
            switch(declAST.nodeType) {
                case 98 /* ModuleDeclaration */ :
                    return this.resolveModuleDeclaration(declAST, context);
                case 97 /* InterfaceDeclaration */ :
                    return this.resolveInterfaceDeclaration(declAST, context);
                case 96 /* ClassDeclaration */ :
                    return this.resolveClassDeclaration(declAST, context);
                case 73 /* FuncDecl */ :
                    return this.resolveFunctionDeclaration(declAST, context);
                case 75 /* VarDecl */ :
                case 76 /* ArgDecl */ :
                    return this.resolveVariableDeclaration(declAST, context);
                case 26 /* TypeParameter */ :
                    return this.resolveTypeParameterDeclaration(declAST, context);
                default:
                    throw new Error("Invalid declaration type");
            }
        };
        PullTypeResolver.prototype.resolveDeclaredSymbol = function (symbol, enclosingDecl, context) {
            if (!symbol || symbol.isResolved()) {
                return;
            }
            var thisUnit = this.unitPath;
            var decls = symbol.getDeclarations();
            var ast = null;
            for(var i = 0; i < decls.length; i++) {
                var decl = decls[i];
                ast = this.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());
                if (!ast || ast.nodeType == 74 /* Member */ ) {
                    return symbol;
                }
                this.setUnitPath(decl.getScriptName());
                this.resolveDeclaration(ast, context);
            }
            var typeArgs = symbol.isType() ? (symbol).getTypeArguments() : null;
            if (typeArgs && typeArgs.length) {
                var typeParameters = (symbol).getTypeParameters();
                var typeCache = {};
                for(var i = 0; i < typeParameters.length; i++) {
                    typeCache[typeParameters[i].getSymbolID().toString()] = typeArgs[i];
                }
                context.pushTypeSpecializationCache(typeCache);
                var specializedSymbol = TypeScript.specializeType((symbol), typeArgs, this, enclosingDecl, context, ast);
                context.popTypeSpecializationCache();
                symbol = specializedSymbol;
            }
            this.setUnitPath(thisUnit);
            return symbol;
        };
        PullTypeResolver.prototype.resolveModuleDeclaration = function (ast, context) {
            var declSymbol = this.semanticInfoChain.getSymbolForAST(ast, this.unitPath);
            return declSymbol;
        };
        PullTypeResolver.prototype.resolveClassDeclaration = function (classDeclAST, context) {
            var classDecl = this.getDeclForAST(classDeclAST);
            var enclosingDecl = this.getEnclosingDecl(classDecl);
            var classDeclSymbol = classDecl.getSymbol();
            if (classDeclSymbol.isResolved()) {
                return classDeclSymbol;
            }
            if (classDeclAST.extendsList) {
                var parentType = null;
                for(var i = 0; i < classDeclAST.extendsList.members.length; i++) {
                    parentType = this.resolveTypeReference(new TypeScript.TypeReference(classDeclAST.extendsList.members[i], 0), classDecl, context);
                    classDeclSymbol.addExtendedType(parentType);
                }
            }
            if (classDeclAST.implementsList) {
                var implementedType = null;
                for(var i = 0; i < classDeclAST.implementsList.members.length; i++) {
                    implementedType = this.resolveTypeReference(new TypeScript.TypeReference(classDeclAST.implementsList.members[i], 0), classDecl, context);
                    classDeclSymbol.addImplementedType(implementedType);
                }
            }
            classDeclSymbol.setResolved();
            var classMembers = classDeclSymbol.getMembers();
            var constructorMethod = classDeclSymbol.getConstructorMethod();
            var classTypeParameters = classDeclSymbol.getTypeParameters();
            if (constructorMethod) {
                this.resolveDeclaredSymbol(constructorMethod, classDecl, context);
            }
            for(var i = 0; i < classMembers.length; i++) {
                this.resolveDeclaredSymbol(classMembers[i], classDecl, context);
            }
            for(var i = 0; i < classTypeParameters.length; i++) {
                this.resolveDeclaredSymbol(classTypeParameters[i], classDecl, context);
            }
            return classDeclSymbol;
        };
        PullTypeResolver.prototype.resolveInterfaceDeclaration = function (interfaceDeclAST, context) {
            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
            var enclosingDecl = this.getEnclosingDecl(interfaceDecl);
            var interfaceDeclSymbol = interfaceDecl.getSymbol();
            if (interfaceDeclSymbol.isResolved()) {
                return interfaceDeclSymbol;
            }
            if (interfaceDeclAST.extendsList) {
                var parentType = null;
                for(var i = 0; i < interfaceDeclAST.extendsList.members.length; i++) {
                    parentType = this.resolveTypeReference(new TypeScript.TypeReference(interfaceDeclAST.extendsList.members[i], 0), interfaceDecl, context);
                    interfaceDeclSymbol.addExtendedType(parentType);
                }
            }
            if (interfaceDeclAST.implementsList) {
                var implementedType = null;
                for(var i = 0; i < interfaceDeclAST.implementsList.members.length; i++) {
                    implementedType = this.resolveTypeReference(new TypeScript.TypeReference(interfaceDeclAST.implementsList.members[i], 0), interfaceDecl, context);
                    interfaceDeclSymbol.addImplementedType(implementedType);
                }
            }
            interfaceDeclSymbol.setResolved();
            var interfaceMembers = interfaceDeclSymbol.getMembers();
            var interfaceTypeParameters = interfaceDeclSymbol.getTypeParameters();
            for(var i = 0; i < interfaceMembers.length; i++) {
                this.resolveDeclaredSymbol(interfaceMembers[i], interfaceDecl, context);
            }
            for(var i = 0; i < interfaceTypeParameters.length; i++) {
                this.resolveDeclaredSymbol(interfaceTypeParameters[i], interfaceDecl, context);
            }
            var callSignatures = interfaceDeclSymbol.getCallSignatures();
            var constructSignatures = interfaceDeclSymbol.getConstructSignatures();
            var indexSignatures = interfaceDeclSymbol.getIndexSignatures();
            for(var i = 0; i < callSignatures.length; i++) {
                this.resolveDeclaredSymbol(callSignatures[i], interfaceDecl, context);
            }
            for(var i = 0; i < constructSignatures.length; i++) {
                this.resolveDeclaredSymbol(constructSignatures[i], interfaceDecl, context);
            }
            for(var i = 0; i < indexSignatures.length; i++) {
                this.resolveDeclaredSymbol(indexSignatures[i], interfaceDecl, context);
            }
            return interfaceDeclSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionTypeSignature = function (funcDeclAST, enclosingDecl, context) {
            var funcDeclSymbol = this.semanticInfoChain.getSymbolForAST(funcDeclAST, this.unitPath);
            if (!funcDeclSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                declCollectionContext.scriptName = this.unitPath;
                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                var functionDecl = this.getDeclForAST(funcDeclAST);
                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindFunctionTypeDeclarationToPullSymbol(functionDecl);
                funcDeclSymbol = functionDecl.getSymbol();
            }
            var signature = funcDeclSymbol.getCallSignatures()[0];
            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeRef = funcDeclAST.returnTypeAnnotation;
                var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, enclosingDecl, context);
                signature.setReturnType(returnTypeSymbol);
                if (returnTypeSymbol.isGeneric()) {
                    signature.setHasGenericParameter();
                    if (funcDeclSymbol) {
                        funcDeclSymbol.getType().setHasGenericSignature();
                    }
                }
            } else {
                signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
            }
            if (funcDeclAST.arguments) {
                for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(funcDeclAST.arguments.members[i], null, enclosingDecl, context);
                }
            }
            if (signature.hasGenericParameter()) {
                if (funcDeclSymbol) {
                    funcDeclSymbol.getType().setHasGenericSignature();
                }
            }
            funcDeclSymbol.setResolved();
            return funcDeclSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionTypeSignatureParameter = function (argDeclAST, contextParam, enclosingDecl, context) {
            var paramSymbol = this.semanticInfoChain.getSymbolForAST(argDeclAST, this.unitPath);
            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context);
                context.setTypeInContext(paramSymbol, typeRef);
                if (enclosingDecl && typeRef.isGeneric()) {
                    var signature = enclosingDecl.getSignatureSymbol();
                    signature.setHasGenericParameter();
                }
            } else {
                if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }
            paramSymbol.setResolved();
        };
        PullTypeResolver.prototype.resolveFunctionExpressionParameter = function (argDeclAST, contextParam, enclosingDecl, context) {
            var paramSymbol = this.getSymbolForAST(argDeclAST);
            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context);
                context.setTypeInContext(paramSymbol, typeRef);
            } else {
                if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }
            paramSymbol.setResolved();
        };
        PullTypeResolver.prototype.resolveInterfaceTypeReference = function (interfaceDeclAST, enclosingDecl, context) {
            var interfaceSymbol = this.semanticInfoChain.getSymbolForAST(interfaceDeclAST, this.unitPath);
            if (!interfaceSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                declCollectionContext.scriptName = this.unitPath;
                TypeScript.getAstWalkerFactory().walk(interfaceDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindObjectTypeDeclarationToPullSymbol(interfaceDecl);
                interfaceSymbol = interfaceDecl.getSymbol();
            }
            if (interfaceDeclAST.members) {
                var memberSymbol = null;
                var typeMembers = interfaceDeclAST.members;
                for(var i = 0; i < typeMembers.members.length; i++) {
                    var memberSymbol = this.semanticInfoChain.getSymbolForAST(typeMembers.members[i], this.unitPath);
                    this.resolveDeclaredSymbol(memberSymbol, enclosingDecl, context);
                }
            }
            interfaceSymbol.setResolved();
            return interfaceSymbol;
        };
        PullTypeResolver.prototype.resolveTypeReference = function (typeRef, enclosingDecl, context) {
            if (!typeRef) {
                return null;
            }
            var typeDeclSymbol = null;
            var prevResolvingTypeReference = context.resolvingTypeReference;
            if (typeRef.term.nodeType == 25 /* Name */ ) {
                var typeName = typeRef.term;
                if (typeName.actualText == "any") {
                    typeDeclSymbol = this.semanticInfoChain.anyTypeSymbol;
                } else if (typeName.actualText == "string") {
                    typeDeclSymbol = this.semanticInfoChain.stringTypeSymbol;
                } else if (typeName.actualText == "number") {
                    typeDeclSymbol = this.semanticInfoChain.numberTypeSymbol;
                } else if (typeName.actualText == "bool") {
                    typeDeclSymbol = this.semanticInfoChain.boolTypeSymbol;
                } else if (typeName.actualText == "null") {
                    typeDeclSymbol = this.semanticInfoChain.nullTypeSymbol;
                } else if (typeName.actualText == "undefined") {
                    typeDeclSymbol = this.semanticInfoChain.undefinedTypeSymbol;
                } else if (typeName.actualText == "void") {
                    typeDeclSymbol = this.semanticInfoChain.voidTypeSymbol;
                } else if (typeName.actualText == "_element") {
                    typeDeclSymbol = this.semanticInfoChain.elementTypeSymbol;
                } else {
                    context.resolvingTypeReference = true;
                    typeDeclSymbol = this.resolveTypeNameExpression(typeName, enclosingDecl, context);
                    context.resolvingTypeReference = prevResolvingTypeReference;
                }
                if (!typeDeclSymbol) {
                    context.postError(typeName.minChar, typeName.getLength(), this.unitPath, "Could not find type '" + typeName.actualText + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (typeRef.term.nodeType == 73 /* FuncDecl */ ) {
                typeDeclSymbol = this.resolveFunctionTypeSignature(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType == 97 /* InterfaceDeclaration */ ) {
                typeDeclSymbol = this.resolveInterfaceTypeReference(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType == 27 /* GenericType */ ) {
                typeDeclSymbol = this.resolveGenericTypeReference(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType == 19 /* Dot */ ) {
                var dottedName = typeRef.term;
                var prevResolvingTypeReference = context.resolvingTypeReference;
                typeDeclSymbol = this.resolveDottedTypeNameExpression(dottedName, enclosingDecl, context);
                context.resolvingTypeReference = prevResolvingTypeReference;
                if (!typeDeclSymbol) {
                    context.postError(dottedName.operand2.minChar, dottedName.operand2.getLength(), this.unitPath, "Could not find dotted type '" + (dottedName.operand2).actualText + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (!typeDeclSymbol) {
                context.postError(typeRef.term.minChar, typeRef.term.getLength(), this.unitPath, "Could not resolve type reference", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            if (typeRef.arrayCount) {
                var arraySymbol = typeDeclSymbol.getArrayType();
                if (!arraySymbol) {
                    if (!this.cachedArrayInterfaceType) {
                        this.cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", this.getPathToDecl(enclosingDecl), 32 /* Interface */ );
                    }
                    arraySymbol = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, typeDeclSymbol, this, context);
                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
                typeDeclSymbol = arraySymbol;
            }
            this.setSymbolForAST(typeRef, typeDeclSymbol);
            return typeDeclSymbol;
        };
        PullTypeResolver.prototype.resolveVariableDeclaration = function (varDecl, context, enclosingDecl) {
            var decl = this.getDeclForAST(varDecl);
            var declSymbol = decl.getSymbol();
            var declPropertySymbol = decl.getPropertySymbol();
            var hadError = false;
            if (declSymbol.isResolved()) {
                return declSymbol.getType();
            }
            if (declSymbol.isResolving()) {
                declSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                declSymbol.setResolved();
                return this.semanticInfoChain.anyTypeSymbol;
            }
            declSymbol.startResolving();
            if (varDecl.typeExpr) {
                var typeExprSymbol = this.resolveTypeReference(varDecl.typeExpr, enclosingDecl ? enclosingDecl : this.getEnclosingDecl(decl), context);
                if (!typeExprSymbol) {
                    context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, "Could not resolve type expression for variable '" + varDecl.id.actualText + "'", decl);
                    declSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    if (declPropertySymbol) {
                        declPropertySymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                    hadError = true;
                } else {
                    context.setTypeInContext(declSymbol, typeExprSymbol);
                    if (declPropertySymbol) {
                        declPropertySymbol.setType(typeExprSymbol);
                    }
                    if (enclosingDecl && typeExprSymbol.isGeneric()) {
                        var signature = enclosingDecl.getSignatureSymbol();
                        signature.setHasGenericParameter();
                    }
                }
            } else if (varDecl.init) {
                var initExprSymbol = this.resolveStatementOrExpression(varDecl.init, false, enclosingDecl ? enclosingDecl : this.getEnclosingDecl(decl), context);
                if (!initExprSymbol) {
                    context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, "Could not resolve type of initializer expression for variable '" + varDecl.id.actualText + "'", decl);
                    context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);
                    if (declPropertySymbol) {
                        context.setTypeInContext(declPropertySymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                    hadError = true;
                } else {
                    context.setTypeInContext(declSymbol, initExprSymbol.getType());
                    initExprSymbol.addOutgoingLink(declSymbol, 2 /* ProvidesInferredType */ );
                    if (declPropertySymbol) {
                        context.setTypeInContext(declPropertySymbol, initExprSymbol.getType());
                        initExprSymbol.addOutgoingLink(declPropertySymbol, 2 /* ProvidesInferredType */ );
                    }
                }
            } else {
                context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);
                if (declPropertySymbol) {
                    declPropertySymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                }
            }
            if (!hadError) {
                declSymbol.setResolved();
            }
            if (declPropertySymbol) {
                declPropertySymbol.setResolved();
                this.setSymbolForAST(varDecl, declPropertySymbol);
                this.setSymbolForAST(varDecl.id, declPropertySymbol);
            }
            return declSymbol;
        };
        PullTypeResolver.prototype.resolveTypeParameterDeclaration = function (typeParameterAST, context) {
            var typeParameterDecl = this.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = typeParameterDecl.getSymbol();
            if (typeParameterSymbol.isResolved() || typeParameterSymbol.isResolving()) {
                return typeParameterSymbol;
            }
            typeParameterSymbol.startResolving();
            if (typeParameterAST.constraint) {
                var constraintTypeSymbol = this.resolveTypeReference(typeParameterAST.constraint, this.getEnclosingDecl(typeParameterDecl), context);
                if (!constraintTypeSymbol) {
                    context.postError(typeParameterAST.minChar, typeParameterAST.getLength(), this.unitPath, "Could not resolve constraint for type parameter '" + typeParameterDecl.getName() + "'", typeParameterDecl);
                } else if (constraintTypeSymbol.isTypeParameter() || constraintTypeSymbol.isPrimitive()) {
                    context.postError(typeParameterAST.constraint.minChar, typeParameterAST.constraint.getLength(), this.unitPath, "Type parameter constraints may not be type parameters or primitive types", typeParameterDecl);
                } else {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }
            typeParameterSymbol.setResolved();
            return typeParameterSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionBodyReturnTypes = function (funcDeclAST, signature, enclosingDecl, context) {
            var returnStatements = [];
            var preFindReturnExpressionTypes = function (ast, parent, walker) {
                var go = true;
                switch(ast.nodeType) {
                    case 73 /* FuncDecl */ :
                        go = false;
                        break;
                    case 77 /* Return */ :
                        var returnStatement = ast;
                        returnStatements[returnStatements.length] = returnStatement;
                    default:
                        break;
                }
                walker.options.goChildren = go;
                walker.options.goNextSibling = go;
                return ast;
            };
            TypeScript.getAstWalkerFactory().walk(funcDeclAST.bod, preFindReturnExpressionTypes);
            if (!returnStatements.length) {
                signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
            } else {
                var returnExpressionSymbols = [];
                for(var i = 0; i < returnStatements.length; i++) {
                    if (returnStatements[i].returnExpression) {
                        returnExpressionSymbols[returnExpressionSymbols.length] = this.resolveStatementOrExpression(returnStatements[i].returnExpression, false, enclosingDecl, context).getType();
                    }
                }
                if (!returnExpressionSymbols.length) {
                    signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
                } else {
                    var collection = {
                        getLength: function () {
                            return returnExpressionSymbols.length;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return returnExpressionSymbols[index].getType();
                        }
                    };
                    var returnType = this.findBestCommonType(returnExpressionSymbols[0], null, collection, true, context, new TypeScript.TypeComparisonInfo());
                    signature.setReturnType(returnType ? returnType : this.semanticInfoChain.anyTypeSymbol);
                    for(var i = 0; i < returnExpressionSymbols.length; i++) {
                        returnExpressionSymbols[i].addOutgoingLink(signature, 2 /* ProvidesInferredType */ );
                    }
                }
            }
        };
        PullTypeResolver.prototype.resolveFunctionDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var funcSymbol = funcDecl.getSymbol();
            var signature = funcDecl.getSignatureSymbol();
            var hadError = false;
            if (signature) {
                if (signature.isResolved()) {
                    return funcSymbol;
                }
                if (signature.isResolving()) {
                    signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    signature.setResolved();
                    return funcSymbol;
                }
                signature.startResolving();
                if (funcDeclAST.arguments) {
                    for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }
                if (signature.hasGenericParameter()) {
                    if (funcSymbol) {
                        funcSymbol.getType().setHasGenericSignature();
                    }
                }
                if (funcDeclAST.returnTypeAnnotation) {
                    var returnTypeRef = funcDeclAST.returnTypeAnnotation;
                    var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, funcDecl, context);
                    if (!returnTypeSymbol) {
                        context.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), this.unitPath, "Could not resolve return type reference for some reason...", funcDecl);
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                        hadError = true;
                    } else {
                        if (returnTypeSymbol.isGeneric()) {
                            signature.setHasGenericParameter();
                            if (funcSymbol) {
                                funcSymbol.getType().setHasGenericSignature();
                            }
                        }
                        signature.setReturnType(returnTypeSymbol);
                    }
                } else {
                    if (funcDeclAST.isSignature()) {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, funcDecl, new TypeScript.PullTypeResolutionContext());
                    }
                }
                if (!hadError) {
                    signature.setResolved();
                }
            }
            return funcSymbol;
        };
        PullTypeResolver.prototype.resolveAST = function (ast, isTypedAssignment, enclosingDecl, context) {
            switch(ast.nodeType) {
                case 98 /* ModuleDeclaration */ :
                case 97 /* InterfaceDeclaration */ :
                case 96 /* ClassDeclaration */ :
                case 75 /* VarDecl */ :
                case 76 /* ArgDecl */ :
                    return this.resolveDeclaration(ast, context);
                case 73 /* FuncDecl */ :
                    if (isTypedAssignment) {
                        return this.resolveStatementOrExpression(ast, isTypedAssignment, enclosingDecl, context);
                    } else {
                        return this.resolveDeclaration(ast, context);
                    }
                default:
                    return this.resolveStatementOrExpression(ast, isTypedAssignment, enclosingDecl, context);
            }
        };
        PullTypeResolver.prototype.resolveStatementOrExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            switch(expressionAST.nodeType) {
                case 25 /* Name */ :
                    if (context.searchTypeSpace) {
                        return this.resolveTypeNameExpression(expressionAST, enclosingDecl, context);
                    } else {
                        return this.resolveNameExpression(expressionAST, enclosingDecl, context);
                    }
                case TypeScript.GenericType:
                    return this.resolveGenericTypeReference(expressionAST, enclosingDecl, context);
                case 19 /* Dot */ :
                    if (context.searchTypeSpace) {
                        return this.resolveDottedTypeNameExpression(expressionAST, enclosingDecl, context);
                    } else {
                        return this.resolveDottedNameExpression(expressionAST, enclosingDecl, context);
                    }
                case 73 /* FuncDecl */ :
                    return this.resolveFunctionExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 11 /* ObjectLit */ :
                    return this.resolveObjectLiteralExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 10 /* ArrayLit */ :
                    return this.resolveArrayLiteralExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 5 /* This */ :
                    return this.resolveThisExpression(expressionAST, enclosingDecl, context);
                case 6 /* Super */ :
                    return this.resolveSuperExpression(expressionAST, enclosingDecl, context);
                case 30 /* Call */ :
                    return this.resolveCallExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 31 /* New */ :
                    return this.resolveNewExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 72 /* TypeAssertion */ :
                    return this.resolveTypeAssertionExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 28 /* TypeRef */ :
                    return this.resolveTypeReference(expressionAST, enclosingDecl, context);
                case 24 /* NumberLit */ :
                    return this.semanticInfoChain.numberTypeSymbol;
                case 7 /* QString */ :
                    return this.semanticInfoChain.stringTypeSymbol;
                case 9 /* Null */ :
                    return this.semanticInfoChain.nullTypeSymbol;
                case 3 /* True */ :
                case 4 /* False */ :
                    return this.semanticInfoChain.boolTypeSymbol;
                case 12 /* Void */ :
                    return this.semanticInfoChain.voidTypeSymbol;
                case 32 /* Asg */ :
                    return this.resolveAssignmentStatement(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 66 /* Not */ :
                case 67 /* LogNot */ :
                case 51 /* Ne */ :
                case 50 /* Eq */ :
                case 52 /* Eqv */ :
                case 53 /* NEqv */ :
                case 54 /* Lt */ :
                case 55 /* Le */ :
                case 57 /* Ge */ :
                case 56 /* Gt */ :
                    return this.semanticInfoChain.boolTypeSymbol;
                case 58 /* Add */ :
                case 59 /* Sub */ :
                case 60 /* Mul */ :
                case 61 /* Div */ :
                case 62 /* Mod */ :
                case 47 /* Or */ :
                case 49 /* And */ :
                case 33 /* AsgAdd */ :
                case 34 /* AsgSub */ :
                case 36 /* AsgMul */ :
                case 35 /* AsgDiv */ :
                case 37 /* AsgMod */ :
                case 40 /* AsgOr */ :
                case 38 /* AsgAnd */ :
                    return this.resolveArithmeticExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 14 /* Pos */ :
                case 15 /* Neg */ :
                case 70 /* IncPost */ :
                case 68 /* IncPre */ :
                case 71 /* DecPost */ :
                case 69 /* DecPre */ :
                    return this.semanticInfoChain.numberTypeSymbol;
                case 63 /* Lsh */ :
                case 64 /* Rsh */ :
                case 65 /* Rs2 */ :
                case 41 /* AsgLsh */ :
                case 42 /* AsgRsh */ :
                case 43 /* AsgRs2 */ :
                    return this.semanticInfoChain.numberTypeSymbol;
                case 29 /* Index */ :
                    return this.resolveIndexExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 45 /* LogOr */ :
                    return this.resolveLogicalOrExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 46 /* LogAnd */ :
                    return this.resolveLogicalAndExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case 23 /* Typeof */ :
                    return this.semanticInfoChain.stringTypeSymbol;
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveNameExpression = function (nameAST, enclosingDecl, context) {
            var id = nameAST.actualText;
            var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            if (enclosingDecl && !declPath.length) {
                declPath = [
                    enclosingDecl
                ];
            }
            var nameSymbol = null;
            nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);
            if (!nameSymbol) {
                nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
            }
            if (!nameSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find symbol '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
            }
            return nameSymbol;
        };
        PullTypeResolver.prototype.resolveDottedNameExpression = function (dottedNameAST, enclosingDecl, context) {
            var rhsName = (dottedNameAST.operand2).actualText;
            var lhs = this.resolveStatementOrExpression(dottedNameAST.operand1, false, enclosingDecl, context);
            var lhsType = lhs.getType();
            if (lhsType == this.semanticInfoChain.anyTypeSymbol) {
                return lhsType;
            }
            if (!lhsType) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find enclosing symbol for dotted name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            if (lhsType == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                lhsType = this.cachedNumberInterfaceType;
            } else if (lhsType == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                lhsType = this.cachedStringInterfaceType;
            } else if (lhsType == this.semanticInfoChain.boolTypeSymbol && this.cachedBooleanInterfaceType) {
                lhsType = this.cachedBooleanInterfaceType;
            }
            if (!lhsType.isResolved()) {
                var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);
                if (potentiallySpecializedType != lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }
                    lhsType = potentiallySpecializedType;
                }
            }
            if (rhsName == "prototype" && lhsType.isClass()) {
                return lhsType;
            }
            var nameSymbol = lhsType.findMember(rhsName);
            if (!nameSymbol) {
                if (lhsType.isClass()) {
                    lhsType = (lhsType).getConstructorMethod().getType();
                    nameSymbol = lhsType.findMember(rhsName);
                }
                if (!nameSymbol) {
                    context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find dotted symbol name '" + rhsName + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
            }
            return nameSymbol;
        };
        PullTypeResolver.prototype.resolveTypeNameExpression = function (nameAST, enclosingDecl, context) {
            var id = nameAST.actualText;
            var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            if (enclosingDecl && !declPath.length) {
                declPath = [
                    enclosingDecl
                ];
            }
            var typeNameSymbol = null;
            typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
            if (!typeNameSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find type '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            typeNameSymbol = context.findSpecializationForType(typeNameSymbol);
            if (!typeNameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(typeNameSymbol, enclosingDecl, context);
            }
            return typeNameSymbol;
        };
        PullTypeResolver.prototype.resolveGenericTypeReference = function (genericTypeAST, enclosingDecl, context) {
            var nameAST = genericTypeAST.name;
            var id = nameAST.actualText;
            var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            if (enclosingDecl && !declPath.length) {
                declPath = [
                    enclosingDecl
                ];
            }
            var genericTypeSymbol = null;
            genericTypeSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
            if (!genericTypeSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find generic type '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            if (genericTypeSymbol.isResolving()) {
                return genericTypeSymbol;
            }
            if (!genericTypeSymbol.isResolved()) {
                genericTypeSymbol.startResolving();
                this.resolveDeclaredSymbol(genericTypeSymbol, enclosingDecl, context);
                genericTypeSymbol.setResolved();
            }
            var typeArgs = [];
            var typeArg = null;
            if (!genericTypeSymbol.isResolvingTypeArguments()) {
                genericTypeSymbol.startResolvingTypeArguments();
                if (genericTypeAST.typeArguments && genericTypeAST.typeArguments.members.length) {
                    for(var i = 0; i < genericTypeAST.typeArguments.members.length; i++) {
                        typeArg = this.resolveTypeReference(genericTypeAST.typeArguments.members[i], enclosingDecl, context);
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
                genericTypeSymbol.doneResolvingTypeArguments();
            }
            var typeParameters = genericTypeSymbol.getTypeParameters();
            if (typeArgs.length && typeArgs.length != typeParameters.length) {
                context.postError(genericTypeAST.minChar, genericTypeAST.getLength(), this.unitPath, "Generic type '" + genericTypeSymbol.getName() + "' expects " + genericTypeSymbol.getTypeParameters().length + " type arguments, but " + typeArgs.length + " arguments were supplied", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var specializedSymbol = TypeScript.specializeType(genericTypeSymbol, typeArgs, this, enclosingDecl, context, genericTypeAST);
            var typeConstraint = null;
            for(var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {
                typeConstraint = typeParameters[iArg].getConstraint();
                if (typeConstraint) {
                    if (!this.sourceIsAssignableToTarget(typeArgs[iArg], typeConstraint, context)) {
                        context.postError(genericTypeAST.minChar, genericTypeAST.getLength(), this.getUnitPath(), "Type '" + typeArgs[iArg].getName() + "' does not satisfy the constraint '" + typeConstraint.getName() + "' for type parameter '" + typeParameters[iArg].getName() + "'", enclosingDecl);
                    }
                }
            }
            return specializedSymbol;
        };
        PullTypeResolver.prototype.resolveDottedTypeNameExpression = function (dottedNameAST, enclosingDecl, context) {
            var rhsName = (dottedNameAST.operand2).actualText;
            var prevSearchTypeSpace = context.searchTypeSpace;
            context.searchTypeSpace = true;
            var lhs = this.resolveStatementOrExpression(dottedNameAST.operand1, false, enclosingDecl, context);
            context.searchTypeSpace = prevSearchTypeSpace;
            var lhsType = lhs.getType();
            if (lhsType == this.semanticInfoChain.anyTypeSymbol) {
                return lhsType;
            }
            if (!lhsType) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find enclosing type for dotted type name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var childTypeSymbol = lhsType.findNestedType(rhsName);
            if (!childTypeSymbol) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find dotted type name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            if (!childTypeSymbol.isResolved()) {
                this.resolveDeclaredSymbol(childTypeSymbol, enclosingDecl, context);
            }
            return childTypeSymbol;
        };
        PullTypeResolver.prototype.resolveFunctionExpression = function (funcDeclAST, isTypedAssignment, enclosingDecl, context) {
            var functionDecl = this.getDeclForAST(funcDeclAST);
            var funcDeclSymbol = null;
            if (functionDecl) {
                funcDeclSymbol = functionDecl.getSymbol();
                if (funcDeclSymbol.isResolved()) {
                    return funcDeclSymbol;
                }
            }
            var shouldContextuallyType = isTypedAssignment && !funcDeclAST.isParenthesized;
            var assigningFunctionTypeSymbol = null;
            var assigningFunctionSignature = null;
            if (funcDeclAST.returnTypeAnnotation) {
                shouldContextuallyType = false;
            }
            if (shouldContextuallyType && funcDeclAST.arguments) {
                for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    if ((funcDeclAST.arguments.members[i]).typeExpr) {
                        shouldContextuallyType = false;
                        break;
                    }
                }
            }
            if (shouldContextuallyType) {
                assigningFunctionTypeSymbol = context.getContextualType();
                this.resolveDeclaredSymbol(assigningFunctionTypeSymbol, enclosingDecl, context);
                if (assigningFunctionTypeSymbol) {
                    assigningFunctionSignature = assigningFunctionTypeSymbol.getCallSignatures()[0];
                }
            }
            if (!funcDeclSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                declCollectionContext.scriptName = this.unitPath;
                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                functionDecl = this.getDeclForAST(funcDeclAST);
                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindFunctionExpressionToPullSymbol(functionDecl);
                funcDeclSymbol = functionDecl.getSymbol();
            }
            var signature = funcDeclSymbol.getType().getCallSignatures()[0];
            if (funcDeclAST.arguments) {
                var contextParams = [];
                var contextParam = null;
                if (assigningFunctionSignature) {
                    contextParams = assigningFunctionSignature.getParameters();
                }
                for(var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    if (i < contextParams.length) {
                        contextParam = contextParams[i];
                    }
                    this.resolveFunctionExpressionParameter(funcDeclAST.arguments.members[i], contextParam, enclosingDecl, context);
                }
            }
            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeRef = funcDeclAST.returnTypeAnnotation;
                var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, enclosingDecl, context);
                signature.setReturnType(returnTypeSymbol);
            } else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.getReturnType();
                    if (returnType) {
                        context.pushContextualType(returnType, context.inProvisionalResolution(), null);
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, functionDecl, context);
                        context.popContextualType();
                    } else {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                } else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, functionDecl, context);
                }
            }
            if (assigningFunctionTypeSymbol) {
                funcDeclSymbol.addOutgoingLink(assigningFunctionTypeSymbol, 1 /* ContextuallyTypedAs */ );
            }
            funcDeclSymbol.setResolved();
            return funcDeclSymbol;
        };
        PullTypeResolver.prototype.resolveThisExpression = function (ast, enclosingDecl, context) {
            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            var decl;
            var classSymbol;
            if (declPath.length) {
                for(var i = declPath.length - 1; i >= 0; i--) {
                    decl = declPath[i];
                    if (decl.getKind() == 16 /* Class */ ) {
                        classSymbol = decl.getSymbol();
                        return classSymbol;
                    }
                }
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveSuperExpression = function (ast, enclosingDecl, context) {
            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var declPath = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            var decl;
            var declFlags;
            var classSymbol = null;
            if (declPath.length) {
                for(var i = declPath.length - 1; i >= 0; i--) {
                    decl = declPath[i];
                    declFlags = decl.getFlags();
                    if (decl.getKind() == 262144 /* FunctionExpression */  && !(declFlags & 16384 /* FatArrow */ )) {
                        break;
                    } else if (declFlags & 16 /* Static */ ) {
                        break;
                    } else if (decl.getKind() == 16 /* Class */ ) {
                        classSymbol = decl.getSymbol();
                        break;
                    }
                }
            }
            if (classSymbol) {
                var parents = classSymbol.getExtendedTypes();
                if (parents.length) {
                    return parents[0];
                }
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveObjectLiteralExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var typeSymbol = this.getSymbolForAST(expressionAST);
            var span;
            if (typeSymbol && typeSymbol.isResolved()) {
                return typeSymbol.getType();
            }
            var objectLitAST = expressionAST;
            span = new TypeScript.DeclSpan();
            span.minChar = objectLitAST.minChar;
            span.limChar = objectLitAST.limChar;
            var objectLitDecl = new TypeScript.PullDecl("", 16777216 /* ObjectType */ , 0 /* None */ , span, this.unitPath);
            this.currentUnit.setDeclForAST(objectLitAST, objectLitDecl);
            this.currentUnit.setASTForDecl(objectLitDecl, objectLitAST);
            typeSymbol = new TypeScript.PullTypeSymbol("", 32 /* Interface */ );
            typeSymbol.addDeclaration(objectLitDecl);
            objectLitDecl.setSymbol(typeSymbol);
            var memberDecls = objectLitAST.operand;
            var contextualType = null;
            if (isTypedAssignment) {
                contextualType = context.getContextualType();
                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);
            }
            if (memberDecls) {
                var binex;
                var id;
                var text;
                var idText;
                var memberSymbol;
                var memberExprType;
                var assigningSymbol = null;
                var acceptedContextualType = false;
                for(var i = 0, len = memberDecls.members.length; i < len; i++) {
                    binex = memberDecls.members[i];
                    id = binex.operand1;
                    if (id.nodeType == 25 /* Name */ ) {
                        text = (id).text;
                    } else if (id.nodeType == 7 /* QString */ ) {
                        idText = (id).text;
                        text = idText.substring(1, idText.length - 1);
                    } else {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }
                    span = new TypeScript.DeclSpan();
                    span.minChar = binex.minChar;
                    span.limChar = binex.limChar;
                    var decl = new TypeScript.PullDecl(text, 8192 /* Property */ , 4 /* Public */ , span, this.unitPath);
                    objectLitDecl.addChildDecl(decl);
                    this.semanticInfoChain.getUnit(this.unitPath).setDeclForAST(binex, decl);
                    this.semanticInfoChain.getUnit(this.unitPath).setASTForDecl(decl, binex);
                    memberSymbol = new TypeScript.PullSymbol(text, 8192 /* Property */ );
                    memberSymbol.addDeclaration(decl);
                    decl.setSymbol(memberSymbol);
                    if (contextualType) {
                        assigningSymbol = contextualType.findMember(text);
                        if (assigningSymbol) {
                            this.resolveDeclaredSymbol(assigningSymbol, enclosingDecl, context);
                            context.pushContextualType(assigningSymbol.getType(), context.inProvisionalResolution(), null);
                            acceptedContextualType = true;
                        }
                    }
                    memberExprType = this.resolveStatementOrExpression(binex.operand2, assigningSymbol != null, enclosingDecl, context);
                    if (acceptedContextualType) {
                        context.popContextualType();
                        acceptedContextualType = false;
                    }
                    context.setTypeInContext(memberSymbol, memberExprType.getType());
                    memberSymbol.setResolved();
                    this.setSymbolForAST(binex.operand1, memberSymbol);
                    typeSymbol.addMember(memberSymbol, 5 /* PublicMember */ );
                }
            }
            typeSymbol.setResolved();
            this.setSymbolForAST(expressionAST, typeSymbol);
            return typeSymbol;
        };
        PullTypeResolver.prototype.resolveArrayLiteralExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var arrayLit = expressionAST;
            var elements = arrayLit.operand;
            var elementType = this.semanticInfoChain.anyTypeSymbol;
            var elementTypes = [];
            var targetElementType = null;
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            comparisonInfo.onlyCaptureFirstError = true;
            if (isTypedAssignment) {
                var contextualType = context.getContextualType();
                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);
                if (contextualType.isArray()) {
                    contextualType = contextualType.getElementType();
                }
                context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
            }
            if (elements) {
                for(var i = 0; i < elements.members.length; i++) {
                    elementTypes[elementTypes.length] = this.resolveStatementOrExpression(elements.members[i], isTypedAssignment, enclosingDecl, context).getType();
                }
                if (isTypedAssignment) {
                    context.popContextualType();
                }
                if (elementTypes.length) {
                    elementType = elementTypes[0];
                }
                var collection = {
                    getLength: function () {
                        return elements.members.length;
                    },
                    setTypeAtIndex: function (index, type) {
                        elementTypes[index] = type;
                    },
                    getTypeAtIndex: function (index) {
                        return elementTypes[index];
                    }
                };
                elementType = this.findBestCommonType(elementType, targetElementType, collection, false, context, comparisonInfo);
                if (elementType == this.semanticInfoChain.undefinedTypeSymbol || elementType == this.semanticInfoChain.nullTypeSymbol) {
                    elementType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (!elementType) {
                context.postError(expressionAST.minChar, expressionAST.getLength(), this.unitPath, "Incompatible types in array literal expression", enclosingDecl);
                elementType = this.semanticInfoChain.anyTypeSymbol;
            } else if (targetElementType) {
                if (this.sourceIsAssignableToTarget(elementType, targetElementType, context)) {
                    elementType = targetElementType;
                }
            }
            var arraySymbol = elementType.getArrayType();
            if (!arraySymbol) {
                if (!this.cachedArrayInterfaceType) {
                    this.cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", this.getPathToDecl(enclosingDecl), 32 /* Interface */ );
                }
                arraySymbol = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, elementType, this, context);
                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            return arraySymbol;
        };
        PullTypeResolver.prototype.resolveIndexExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var indexType = this.resolveStatementOrExpression((expressionAST).operand1, isTypedAssignment, enclosingDecl, context).getType();
            var elementType = indexType.getElementType();
            if (elementType) {
                return elementType;
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveBitwiseOperator = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();
            if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                return this.semanticInfoChain.numberTypeSymbol;
            } else if ((leftType == this.semanticInfoChain.boolTypeSymbol) && (rightType == this.semanticInfoChain.boolTypeSymbol)) {
                return this.semanticInfoChain.boolTypeSymbol;
            } else if (leftType == this.semanticInfoChain.anyTypeSymbol) {
                if ((rightType == this.semanticInfoChain.anyTypeSymbol) || (rightType == this.semanticInfoChain.numberTypeSymbol) || (rightType == this.semanticInfoChain.boolTypeSymbol)) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (rightType == this.semanticInfoChain.anyTypeSymbol) {
                if ((leftType == this.semanticInfoChain.numberTypeSymbol) || (leftType == this.semanticInfoChain.boolTypeSymbol)) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveArithmeticExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();
            if (this.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }
            leftType = this.widenType(leftType);
            rightType = this.widenType(rightType);
            if (expressionAST.nodeType == 58 /* Add */  || expressionAST.nodeType == 33 /* AsgAdd */ ) {
                if (leftType == this.semanticInfoChain.stringTypeSymbol || rightType == this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                } else if (leftType == this.semanticInfoChain.numberTypeSymbol && rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                if (leftType == this.semanticInfoChain.numberTypeSymbol && rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else if (leftType == this.semanticInfoChain.anyTypeSymbol || rightType == this.semanticInfoChain.anyTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
        };
        PullTypeResolver.prototype.resolveLogicalOrExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();
            if (leftType == this.semanticInfoChain.anyTypeSymbol || rightType == this.semanticInfoChain.anyTypeSymbol) {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (leftType == this.semanticInfoChain.boolTypeSymbol) {
                if (rightType == this.semanticInfoChain.boolTypeSymbol) {
                    return this.semanticInfoChain.boolTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (leftType == this.semanticInfoChain.numberTypeSymbol) {
                if (rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (leftType == this.semanticInfoChain.stringTypeSymbol) {
                if (rightType == this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (this.sourceIsSubtypeOfTarget(leftType, rightType, context)) {
                return rightType;
            } else if (this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                return leftType;
            }
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveLogicalAndExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();
            return rightType;
        };
        PullTypeResolver.prototype.resolveCallExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context, additionalResults) {
            var callEx = expressionAST;
            var targetSymbol = this.resolveStatementOrExpression(callEx.target, isTypedAssignment, enclosingDecl, context).getType();
            if (targetSymbol == this.semanticInfoChain.anyTypeSymbol) {
                return targetSymbol;
            }
            var isSuperCall = false;
            if (callEx.target.nodeType == 6 /* Super */ ) {
                isSuperCall = true;
                targetSymbol = (targetSymbol).getConstructorMethod().getType();
            }
            var signatures = isSuperCall ? (targetSymbol).getConstructSignatures() : (targetSymbol).getCallSignatures();
            var typeArgs = null;
            var typeReplacementMap = null;
            if (callEx.typeArguments) {
                typeArgs = [];
                var typeArg = null;
                if (callEx.typeArguments && callEx.typeArguments.members.length) {
                    for(var i = 0; i < callEx.typeArguments.members.length; i++) {
                        typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context);
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
            }
            if (targetSymbol.isGeneric()) {
                var resolvedSignatures = [];
                var inferredTypeArgs;
                var specializedSignature;
                var typeParameters;
                var typeConstraint = null;
                for(var i = 0; i < signatures.length; i++) {
                    if (signatures[i].isGeneric()) {
                        if (typeArgs) {
                            inferredTypeArgs = typeArgs;
                        } else {
                            inferredTypeArgs = this.inferArgumentTypesForSignature(signatures[i], callEx.arguments, new TypeScript.TypeComparisonInfo(), enclosingDecl, context);
                        }
                        if (inferredTypeArgs) {
                            typeParameters = signatures[i].getTypeParameters();
                            if (inferredTypeArgs.length != typeParameters.length) {
                                continue;
                            }
                            typeReplacementMap = {};
                            for(var j = 0; j < typeParameters.length; j++) {
                                typeReplacementMap[typeParameters[j].getSymbolID().toString()] = inferredTypeArgs[j];
                                typeConstraint = typeParameters[j].getConstraint();
                                if (typeConstraint) {
                                    if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                        context.postError(callEx.target.minChar, callEx.target.getLength(), this.getUnitPath(), "Type '" + inferredTypeArgs[j].getName() + "' does not satisfy the constraint '" + typeConstraint.getName() + "' for type parameter '" + typeParameters[j].getName() + "'", enclosingDecl);
                                    }
                                }
                            }
                            specializedSignature = TypeScript.specializeSignature(signatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);
                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        }
                    } else {
                        resolvedSignatures[resolvedSignatures.length] = signatures[i];
                    }
                }
                signatures = resolvedSignatures;
            }
            if (!signatures.length) {
                context.postError(expressionAST.minChar, expressionAST.getLength(), this.unitPath, "Attempting to call on a type with no call signatures", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var signature = signatures.length > 1 ? this.resolveOverloads(expressionAST, signatures, enclosingDecl, context) : signatures[0];
            if (!signature) {
                signature = signatures[0];
            }
            var returnType = signature.getReturnType();
            if (callEx.arguments) {
                var len = callEx.arguments.members.length;
                var params = signature.getParameters();
                var contextualType = null;
                for(var i = 0; i < len; i++) {
                    if (params.length && i < params.length) {
                        if (typeReplacementMap) {
                            context.pushTypeSpecializationCache(typeReplacementMap);
                        }
                        this.resolveDeclaredSymbol(params[i], enclosingDecl, context);
                        if (typeReplacementMap) {
                            context.popTypeSpecializationCache();
                        }
                        contextualType = params[i].getType();
                    } else if (params.length) {
                        contextualType = params[params.length - 1].getType();
                        if (contextualType.isArray()) {
                            contextualType = contextualType.getElementType();
                        }
                    }
                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                    }
                    this.resolveStatementOrExpression(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);
                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }
            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }
            if (additionalResults) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.signatures = signatures;
                additionalResults.signature = signature;
            }
            return returnType;
        };
        PullTypeResolver.prototype.resolveNewExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context, additionalResults) {
            var callEx = expressionAST;
            var returnType = null;
            var targetSymbol = this.resolveStatementOrExpression(callEx.target, isTypedAssignment, enclosingDecl, context);
            var targetTypeSymbol = targetSymbol.isType() ? targetSymbol : targetSymbol.getType();
            if (targetTypeSymbol.isClass()) {
                targetTypeSymbol = (targetTypeSymbol).getConstructorMethod().getType();
            }
            if (targetTypeSymbol == this.semanticInfoChain.anyTypeSymbol) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            var constructSignatures = targetTypeSymbol.getConstructSignatures();
            if (constructSignatures.length) {
                var signature = constructSignatures.length > 1 ? this.resolveOverloads(expressionAST, constructSignatures, enclosingDecl, context) : constructSignatures[0];
                if (!signature) {
                    signature = constructSignatures[0];
                }
                if (!returnType) {
                    returnType = signature.getReturnType();
                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    var params = signature.getParameters();
                    var contextualType = null;
                    for(var i = 0; i < len; i++) {
                        if (params.length && i < params.length) {
                            contextualType = params[i].getType();
                        } else if (params.length) {
                            contextualType = params[params.length - 1].getType();
                            if (contextualType.isArray()) {
                                contextualType = contextualType.getElementType();
                            }
                        }
                        if (contextualType) {
                            context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                        }
                        this.resolveStatementOrExpression(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);
                        if (contextualType) {
                            context.popContextualType();
                            contextualType = null;
                        }
                    }
                }
                if (additionalResults) {
                    additionalResults.targetSymbol = targetTypeSymbol;
                    additionalResults.signatures = constructSignatures;
                    additionalResults.signature = signature;
                }
                return returnType;
            } else if (targetTypeSymbol.isClass()) {
                return returnType;
            }
            context.postError(expressionAST.minChar, expressionAST.getLength(), this.unitPath, "Invalid 'new' expression", enclosingDecl);
            return this.semanticInfoChain.anyTypeSymbol;
        };
        PullTypeResolver.prototype.resolveTypeAssertionExpression = function (expressionAST, isTypedAssignment, enclosingDecl, context) {
            var assertionExpression = expressionAST;
            var typeReference = this.resolveTypeReference(assertionExpression.castTerm, enclosingDecl, context);
            if (context.resolveAggressively && !assertionExpression.operand.isParenthesized) {
                context.pushContextualType(typeReference, context.inProvisionalResolution(), null);
                this.resolveStatementOrExpression(assertionExpression.operand, true, enclosingDecl, context);
                context.popContextualType();
            }
            return typeReference;
        };
        PullTypeResolver.prototype.resolveAssignmentStatement = function (statementAST, isTypedAssignment, enclosingDecl, context) {
            var binex = statementAST;
            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            this.resolveStatementOrExpression(binex.operand2, true, enclosingDecl, context);
            context.popContextualType();
            return leftType;
        };
        PullTypeResolver.prototype.resolveBoundDecls = function (decl, context) {
            if (!decl) {
                return;
            }
            switch(decl.getKind()) {
                case 1 /* Script */ :
                    var childDecls = decl.getChildDecls();
                    for(var i = 0; i < childDecls.length; i++) {
                        this.resolveBoundDecls(childDecls[i], context);
                    }
                    break;
                case 8 /* Container */ :
                    var moduleDecl = this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveModuleDeclaration(moduleDecl, context);
                    break;
                case 32 /* Interface */ :
                    var interfaceDecl = this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveInterfaceDeclaration(interfaceDecl, context);
                    break;
                case 16 /* Class */ :
                    var classDecl = this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveClassDeclaration(classDecl, context);
                    break;
                case 131072 /* Method */ :
                case 32768 /* Function */ :
                    var funcDecl = this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveFunctionDeclaration(funcDecl, context);
                    break;
                case 8192 /* Property */ :
                case 2048 /* Variable */ :
                case 4096 /* Parameter */ :
                    var varDecl = this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    if (varDecl) {
                        this.resolveVariableDeclaration(varDecl, context);
                    }
                    break;
            }
        };
        PullTypeResolver.prototype.mergeOrdered = function (a, b, acceptVoid, context, comparisonInfo) {
            if ((a == this.semanticInfoChain.anyTypeSymbol) || (b == this.semanticInfoChain.anyTypeSymbol)) {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (a == b) {
                return a;
            } else if ((b == this.semanticInfoChain.nullTypeSymbol) && a != this.semanticInfoChain.nullTypeSymbol) {
                return a;
            } else if ((a == this.semanticInfoChain.nullTypeSymbol) && (b != this.semanticInfoChain.nullTypeSymbol)) {
                return b;
            } else if (acceptVoid && (b == this.semanticInfoChain.voidTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            } else if (acceptVoid && (a == this.semanticInfoChain.voidTypeSymbol) && (b != this.semanticInfoChain.voidTypeSymbol)) {
                return b;
            } else if ((b == this.semanticInfoChain.undefinedTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            } else if ((a == this.semanticInfoChain.undefinedTypeSymbol) && (b != this.semanticInfoChain.undefinedTypeSymbol)) {
                return b;
            } else if (a.isTypeParameter() && !b.isTypeParameter()) {
                return b;
            } else if (!a.isTypeParameter() && b.isTypeParameter()) {
                return a;
            } else if (a.isArray() && b.isArray()) {
                if (a.getElementType() == b.getElementType()) {
                    return a;
                } else {
                    var mergedET = this.mergeOrdered(a.getElementType(), b.getElementType(), acceptVoid, context, comparisonInfo);
                    var mergedArrayType = mergedET.getArrayType();
                    if (!mergedArrayType) {
                        mergedArrayType = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, mergedET, this, context);
                    }
                    return mergedArrayType;
                }
            } else if (this.sourceIsSubtypeOfTarget(a, b, context, comparisonInfo)) {
                return b;
            } else if (this.sourceIsSubtypeOfTarget(b, a, context, comparisonInfo)) {
                return a;
            } else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        };
        PullTypeResolver.prototype.widenType = function (type) {
            if (type == this.semanticInfoChain.undefinedTypeSymbol || type == this.semanticInfoChain.nullTypeSymbol) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            return type;
        };
        PullTypeResolver.prototype.isNullOrUndefinedType = function (type) {
            return type == this.semanticInfoChain.nullTypeSymbol || type == this.semanticInfoChain.undefinedTypeSymbol;
        };
        PullTypeResolver.prototype.findBestCommonType = function (initialType, targetType, collection, acceptVoid, context, comparisonInfo) {
            var i = 0;
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;
            if (targetType) {
                bestCommonType = bestCommonType ? this.mergeOrdered(bestCommonType, targetType, acceptVoid, context) : targetType;
            }
            var convergenceType = bestCommonType;
            while(nlastChecked < len) {
                for(i = 0; i < len; i++) {
                    if (i == nlastChecked) {
                        continue;
                    }
                    if (convergenceType && (bestCommonType = this.mergeOrdered(convergenceType, collection.getTypeAtIndex(i), acceptVoid, context, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }
                    if (bestCommonType == this.semanticInfoChain.anyTypeSymbol || bestCommonType == null) {
                        break;
                    } else if (targetType) {
                        collection.setTypeAtIndex(i, targetType);
                    }
                }
                if (convergenceType && bestCommonType) {
                    break;
                }
                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }
            return acceptVoid ? bestCommonType : (bestCommonType == this.semanticInfoChain.voidTypeSymbol ? null : bestCommonType);
        };
        PullTypeResolver.prototype.typesAreIdentical = function (t1, t2) {
            if (t1 == t2) {
                return true;
            }
            if (!t1 || !t2) {
                return false;
            }
            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }
            if (t1.isClass()) {
                return false;
            }
            var comboId = (t2.getSymbolID() << 16) | t1.getSymbolID();
            if (this.identicalCache[comboId]) {
                return true;
            }
            if ((t1.getKind() & 128 /* Enum */ ) || (t2.getKind() & 128 /* Enum */ )) {
                return false;
            }
            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.getElementType(), t2.getElementType());
                if (ret) {
                    this.subtypeCache[comboId] = true;
                } else {
                    this.subtypeCache[comboId] = undefined;
                }
                return ret;
            }
            if (t1.isPrimitive() != t2.isPrimitive()) {
                return false;
            }
            this.identicalCache[comboId] = false;
            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getMembers();
                var t2Members = t2.getMembers();
                if (t1Members.length != t2Members.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }
                var t1MemberSymbol = null;
                var t2MemberSymbol = null;
                var t1MemberType = null;
                var t2MemberType = null;
                for(var iMember = 0; iMember < t1Members.length; iMember++) {
                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = t2.findMember(t1MemberSymbol.getName());
                    if (!t2MemberSymbol || (t1MemberSymbol.getIsOptional() != t2MemberSymbol.getIsOptional())) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();
                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.getSymbolID() << 16) | t1MemberType.getSymbolID()] != undefined)) {
                        continue;
                    }
                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            } else if (t1.hasMembers() || t2.hasMembers()) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();
            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();
            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();
            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }
            this.identicalCache[comboId] = true;
            return true;
        };
        PullTypeResolver.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {
            if (sg1 == sg2) {
                return true;
            }
            if (!sg1 || !sg2) {
                return false;
            }
            if (sg1.length != sg2.length) {
                return false;
            }
            var sig1 = null;
            var sig2 = null;
            var sigsMatch = false;
            for(var iSig1 = 0; iSig1 < sg1.length; iSig1++) {
                sig1 = sg1[iSig1];
                for(var iSig2 = 0; iSig2 < sg2.length; iSig2++) {
                    sig2 = sg2[iSig2];
                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }
                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.signaturesAreIdentical = function (s1, s2) {
            if (s1.hasVariableParamList() != s2.hasVariableParamList()) {
                return false;
            }
            if (s1.getNonOptionalParameterCount() != s2.getNonOptionalParameterCount()) {
                return false;
            }
            var s1Params = s1.getParameters();
            var s2Params = s2.getParameters();
            if (s1Params.length != s2Params.length) {
                return false;
            }
            if (!this.typesAreIdentical(s1.getReturnType(), s2.getReturnType())) {
                return false;
            }
            for(var iParam = 0; iParam < s1Params.length; iParam++) {
                if (!this.typesAreIdentical(s1Params[iParam].getType(), s2Params[iParam].getType())) {
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.sourceIsSubtypeOfTarget = function (source, target, context, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.signatureGroupIsSubtypeOfTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.signatureIsSubtypeOfTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourceIsAssignableToTarget = function (source, target, context, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.signatureGroupIsAssignableToTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.signatureIsAssignableToTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, context, comparisonInfo);
        };
        PullTypeResolver.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            if (source == target) {
                return true;
            }
            if (!(source && target)) {
                return true;
            }
            var comboId = (source.getSymbolID() << 16) | target.getSymbolID();
            if (comparisonCache[comboId] != undefined) {
                return true;
            }
            if (assignableTo) {
                if (source == this.semanticInfoChain.anyTypeSymbol || target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }
            } else {
                if (target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }
            }
            if (source == this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }
            if ((source == this.semanticInfoChain.nullTypeSymbol) && (target != this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }
            if (target == this.semanticInfoChain.numberTypeSymbol && (source.getKind() & 128 /* Enum */ )) {
                return true;
            }
            if (source == this.semanticInfoChain.numberTypeSymbol && (target.getKind() & 128 /* Enum */ )) {
                return true;
            }
            if ((source.getKind() & 128 /* Enum */ ) || (target.getKind() & 128 /* Enum */ )) {
                return false;
            }
            if (source.isArray() || target.isArray()) {
                if (!(source.isArray() && target.isArray())) {
                    return false;
                }
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.getElementType(), target.getElementType(), assignableTo, comparisonCache, context, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                } else {
                    comparisonCache[comboId] = undefined;
                }
                return ret;
            }
            if (source.isPrimitive() && target.isPrimitive()) {
                return false;
            } else if (source.isPrimitive() != target.isPrimitive()) {
                if (!target.isPrimitive()) {
                    if (source == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                        source = this.cachedNumberInterfaceType;
                    } else if (source == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                        source = this.cachedStringInterfaceType;
                    } else if (source == this.semanticInfoChain.boolTypeSymbol && this.cachedBooleanInterfaceType) {
                        source = this.cachedBooleanInterfaceType;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            comparisonCache[comboId] = false;
            if (source.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }
            if (this.cachedObjectInterfaceType && target == this.cachedObjectInterfaceType) {
                return true;
            }
            if (this.cachedFunctionInterfaceType && (source.getCallSignatures().length || source.getConstructSignatures().length) && target == this.cachedFunctionInterfaceType) {
                return true;
            }
            if (target.isClass()) {
                comparisonCache[comboId] = undefined;
                return false;
            }
            if (target.hasMembers() && source.hasMembers()) {
                var mProps = target.getMembers();
                var mProp = null;
                var nProp = null;
                var mPropType = null;
                var nPropType = null;
                for(var iMProp = 0; iMProp < mProps.length; iMProp++) {
                    mProp = mProps[iMProp];
                    nProp = source.findMember(mProp.getName());
                    if (!mProp.isResolved()) {
                        this.resolveDeclaredSymbol(mProp, null, context);
                    }
                    mPropType = mProp.getType();
                    if (!nProp) {
                        if (this.cachedObjectInterfaceType) {
                            nProp = this.cachedObjectInterfaceType.findMember(mProp.getName());
                        }
                        if (!nProp) {
                            if (this.cachedFunctionInterfaceType && (mPropType.getCallSignatures().length || mPropType.getConstructSignatures().length)) {
                                nProp = this.cachedFunctionInterfaceType.findMember(mProp.getName());
                            }
                            if (!nProp) {
                                if (!(mProp.getIsOptional())) {
                                    comparisonCache[comboId] = undefined;
                                    if (comparisonInfo) {
                                        comparisonInfo.flags |= 2 /* RequiredPropertyIsMissing */ ;
                                        comparisonInfo.addMessageToFront("Type '" + source.getName() + "' is missing property '" + mProp.getName() + "' from type '" + target.getName() + "'");
                                    }
                                    return false;
                                } else {
                                    continue;
                                }
                            }
                        }
                    }
                    if (!nProp.isResolved()) {
                        this.resolveDeclaredSymbol(nProp, null, context);
                    }
                    nPropType = nProp.getType();
                    if (mPropType && nPropType && (comparisonCache[(nPropType.getSymbolID() << 16) | mPropType.getSymbolID()] != undefined)) {
                        continue;
                    }
                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, context, comparisonInfo)) {
                        comparisonCache[comboId] = undefined;
                        if (comparisonInfo) {
                            comparisonInfo.flags |= 32 /* IncompatiblePropertyTypes */ ;
                            comparisonInfo.addMessageToFront("Types of property '" + mProp.getName() + "' of types '" + source.getName() + "' and '" + target.getName() + "' are incompatible");
                        }
                        return false;
                    }
                }
            }
            var sourceCallSigs = source.getCallSignatures();
            var targetCallSigs = target.getCallSignatures();
            var sourceConstructSigs = source.getConstructSignatures();
            var targetConstructSigs = target.getConstructSignatures();
            var sourceIndexSigs = source.getIndexSignatures();
            var targetIndexSigs = target.getIndexSignatures();
            if (sourceCallSigs.length || targetCallSigs.length) {
                if (!this.signatureGroupIsRelatableToTarget(sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            comparisonInfo.addMessageToFront("Call signatures of types '" + source.getName() + "' and '" + target.getName() + "' are incompatible");
                        } else {
                            var hasSig = targetCallSigs.length ? target.getName() : source.getName();
                            var lacksSig = !targetCallSigs.length ? target.getName() : source.getName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a call signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */ ;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            if (sourceConstructSigs.length || targetConstructSigs.length) {
                if (!this.signatureGroupIsRelatableToTarget(sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            comparisonInfo.addMessageToFront("Construct signatures of types '" + source.getName() + "' and '" + target.getName() + "' are incompatible");
                        } else {
                            var hasSig = targetConstructSigs.length ? target.getName() : source.getName();
                            var lacksSig = !targetConstructSigs.length ? target.getName() : source.getName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a construct signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */ ;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            if (targetIndexSigs.length) {
                var targetIndex = !targetIndexSigs.length && this.cachedObjectInterfaceType ? this.cachedObjectInterfaceType.getIndexSignatures() : targetIndexSigs;
                var sourceIndex = !sourceIndexSigs.length && this.cachedObjectInterfaceType ? this.cachedObjectInterfaceType.getIndexSignatures() : sourceIndexSigs;
                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.addMessageToFront("Index signatures of types '" + source.getName() + "' and '" + target.getName() + "' are incompatible");
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */ ;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }
            comparisonCache[comboId] = true;
            return true;
        };
        PullTypeResolver.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, context, comparisonInfo) {
            if (sourceSG == targetSG) {
                return true;
            }
            if (!(sourceSG && targetSG)) {
                return false;
            }
            var mSig = null;
            var nSig = null;
            var foundMatch = false;
            for(var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                mSig = targetSG[iMSig];
                for(var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    nSig = sourceSG[iNSig];
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, context, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }
                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, context, comparisonInfo) {
            var sourceParameters = sourceSig.getParameters();
            var targetParameters = targetSig.getParameters();
            if (!sourceParameters.length || !targetParameters.length) {
                return false;
            }
            var targetVarArgCount = targetSig.hasVariableParamList() ? targetSig.getNonOptionalParameterCount() - 1 : targetSig.getNonOptionalParameterCount();
            var sourceVarArgCount = sourceSig.hasVariableParamList() ? sourceSig.getNonOptionalParameterCount() - 1 : sourceSig.getNonOptionalParameterCount();
            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableParamList()) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= 3 /* SourceSignatureHasTooManyParameters */ ;
                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");
                }
                return false;
            }
            var sourceReturnType = sourceSig.getReturnType();
            var targetReturnType = targetSig.getReturnType();
            if (targetReturnType != this.semanticInfoChain.voidTypeSymbol) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 16 /* IncompatibleReturnTypes */ ;
                    }
                    return false;
                }
            }
            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableParamList()) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType = null;
            var targetParamType = null;
            var sourceParamName = "";
            var targetParamName = "";
            for(var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {
                if (!sourceSig.hasVariableParamList || iSource < sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].getType();
                    sourceParamName = sourceParameters[iSource].getName();
                } else if (iSource == sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].getType();
                    if (sourceParamType.isArray()) {
                        sourceParamType = sourceParamType.getElementType();
                    }
                    sourceParamName = sourceParameters[iSource].getName();
                }
                if (iTarget < targetParameters.length && iTarget < targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType();
                    targetParamName = targetParameters[iTarget].getName();
                } else if (targetSig.hasVariableParamList && iTarget == targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType();
                    if (targetParamType.isArray()) {
                        targetParamType = targetParamType.getElementType();
                    }
                    targetParamName = targetParameters[iTarget].getName();
                }
                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, context, comparisonInfo) || this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, context, comparisonInfo))) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 64 /* IncompatibleParameterTypes */ ;
                    }
                    return false;
                }
            }
            return true;
        };
        PullTypeResolver.prototype.resolveOverloads = function (application, group, enclosingDecl, context) {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate = null;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var args = null;
            var target = null;
            var argSym;
            if (application.nodeType == 30 /* Call */  || application.nodeType == 31 /* New */ ) {
                var callEx = application;
                args = callEx.arguments;
                target = callEx.target;
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    for(var i = 0; i < len; i++) {
                        argSym = this.resolveStatementOrExpression(callEx.arguments.members[i], false, enclosingDecl, context);
                        actuals[i] = argSym.getType();
                    }
                }
            } else if (application.nodeType == 29 /* Index */ ) {
                var binExp = application;
                target = binExp.operand1;
                args = new TypeScript.ASTList();
                args.members[0] = binExp.operand2;
                argSym = this.resolveStatementOrExpression(args.members[0], false, enclosingDecl, context);
                actuals[0] = argSym.getType();
            }
            var signature;
            var returnType;
            for(var j = 0, groupLen = group.length; j < groupLen; j++) {
                signature = group[j];
                if (hasOverloads && signature.isDefinition()) {
                    continue;
                }
                returnType = signature.getReturnType();
                this.getCandidateSignatures(signature, actuals, exactCandidates, conversionCandidates, context, comparisonInfo);
            }
            if (exactCandidates.length == 0) {
                var applicableCandidates = this.getApplicableSignaturesFromCandidates(conversionCandidates, args, comparisonInfo, enclosingDecl, context);
                if (applicableCandidates.length > 0) {
                    var candidateInfo = this.findMostApplicableSignature(applicableCandidates, args, enclosingDecl, context);
                    if (candidateInfo.ambiguous) {
                        context.postError(application.minChar, application.getLength(), this.unitPath, "Ambiguous call expression - could not choose overload", enclosingDecl);
                    }
                    candidate = candidateInfo.sig;
                } else {
                    var emsg = "Supplied parameters do not match any signature of call target";
                    if (comparisonInfo.message) {
                        context.postError(application.minChar, application.getLength(), this.unitPath, emsg + ":\n\t" + comparisonInfo.message, enclosingDecl);
                    } else {
                        context.postError(application.minChar, application.getLength(), this.unitPath, emsg, enclosingDecl);
                    }
                }
            } else {
                if (exactCandidates.length > 1) {
                    var applicableSigs = [];
                    for(var i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = {
                            signature: exactCandidates[i],
                            hadProvisionalErrors: false
                        };
                    }
                    var candidateInfo = this.findMostApplicableSignature(applicableSigs, args, enclosingDecl, context);
                    if (candidateInfo.ambiguous) {
                        context.postError(application.minChar, application.getLength(), this.unitPath, "Ambiguous call expression - could not choose overload", enclosingDecl);
                    }
                    candidate = candidateInfo.sig;
                } else {
                    candidate = exactCandidates[0];
                }
            }
            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        };
        PullTypeResolver.prototype.getCandidateSignatures = function (signature, actuals, exactCandidates, conversionCandidates, context, comparisonInfo) {
            var parameters = signature.getParameters();
            var lowerBound = signature.getNonOptionalParameterCount();
            var upperBound = parameters.length;
            var formalLen = lowerBound;
            var acceptable = false;
            if ((actuals.length >= lowerBound) && (signature.hasVariableParamList() || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableParamList() ? parameters.length : actuals.length);
                acceptable = true;
            }
            var repeatType = null;
            if (acceptable || signature.hasVariableParamList()) {
                if (signature.hasVariableParamList()) {
                    formalLen -= 1;
                    repeatType = parameters[formalLen].getType();
                    repeatType = repeatType.getElementType();
                    acceptable = actuals.length >= formalLen;
                }
                var len = actuals.length;
                var exact = acceptable;
                var convert = acceptable;
                var typeA;
                var typeB;
                for(var i = 0; i < len; i++) {
                    if (i < formalLen) {
                        typeA = parameters[i].getType();
                    } else {
                        typeA = repeatType;
                    }
                    typeB = actuals[i];
                    if (!typeA || !typeB || !(this.typesAreIdentical(typeA, typeB))) {
                        exact = false;
                    }
                    if (!this.sourceIsAssignableToTarget(typeB, typeA, context, comparisonInfo)) {
                        convert = false;
                    }
                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                } else if (convert && (exactCandidates.length == 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }
            }
        };
        PullTypeResolver.prototype.getApplicableSignaturesFromCandidates = function (candidateSignatures, args, comparisonInfo, enclosingDecl, context) {
            var applicableSigs = [];
            var memberType = null;
            var miss = false;
            var cxt = null;
            var hadProvisionalErrors = false;
            var parameters;
            var signature;
            var argSym;
            for(var i = 0; i < candidateSignatures.length; i++) {
                miss = false;
                signature = candidateSignatures[i];
                parameters = signature.getParameters();
                for(var j = 0; j < args.members.length; j++) {
                    if (j >= parameters.length) {
                        continue;
                    }
                    memberType = parameters[j].getType();
                    if (signature.hasVariableParamList() && (j >= signature.getNonOptionalParameterCount() - 1) && memberType.isArray()) {
                        memberType = memberType.getElementType();
                    }
                    if (memberType == this.semanticInfoChain.anyTypeSymbol) {
                        continue;
                    } else if (args.members[j].nodeType == 73 /* FuncDecl */ ) {
                        if (this.cachedFunctionInterfaceType && memberType == this.cachedFunctionInterfaceType) {
                            continue;
                        }
                        argSym = this.resolveFunctionExpression(args.members[j], false, enclosingDecl, context);
                        if (!this.canApplyContextualTypeToFunction(memberType, args.members[j], true)) {
                            if (this.canApplyContextualTypeToFunction(memberType, args.members[j], false)) {
                                if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        } else {
                            context.pushContextualType(memberType, true, null);
                            argSym = this.resolveFunctionExpression(args.members[j], true, enclosingDecl, context);
                            if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage("Could not apply type '" + memberType.getName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                                }
                                miss = true;
                            }
                            cxt = context.popContextualType();
                            hadProvisionalErrors = cxt.hadProvisionalErrors();
                            if (miss) {
                                break;
                            }
                        }
                    } else if (args.members[j].nodeType == 11 /* ObjectLit */ ) {
                        if (this.cachedObjectInterfaceType && memberType == this.cachedObjectInterfaceType) {
                            continue;
                        }
                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveObjectLiteralExpression(args.members[j], true, enclosingDecl, context);
                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            miss = true;
                        }
                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    } else if (args.members[j].nodeType == 10 /* ArrayLit */ ) {
                        if (this.cachedArrayInterfaceType && memberType == this.cachedArrayInterfaceType) {
                            continue;
                        }
                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveArrayLiteralExpression(args.members[j], true, enclosingDecl, context);
                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            break;
                        }
                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                }
                if (j == args.members.length) {
                    applicableSigs[applicableSigs.length] = {
                        signature: candidateSignatures[i],
                        hadProvisionalErrors: hadProvisionalErrors
                    };
                }
                hadProvisionalErrors = false;
            }
            return applicableSigs;
        };
        PullTypeResolver.prototype.findMostApplicableSignature = function (signatures, args, enclosingDecl, context) {
            if (signatures.length == 1) {
                return {
                    sig: signatures[0].signature,
                    ambiguous: false
                };
            }
            var best = signatures[0];
            var Q = null;
            var AType = null;
            var PType = null;
            var QType = null;
            var ambiguous = false;
            var argSym;
            var bestParams;
            var qParams;
            for(var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];
                var i = 0;
                for(i = 0; args && i < args.members.length; i++) {
                    argSym = this.resolveStatementOrExpression(args.members[i], false, enclosingDecl, context);
                    AType = argSym.getType();
                    argSym.invalidate();
                    bestParams = best.signature.getParameters();
                    qParams = Q.signature.getParameters();
                    PType = i < bestParams.length ? bestParams[i].getType() : bestParams[bestParams.length - 1].getType().getElementType();
                    QType = i < qParams.length ? qParams[i].getType() : qParams[qParams.length - 1].getType().getElementType();
                    if (this.typesAreIdentical(PType, QType)) {
                        continue;
                    } else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    } else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(PType, QType, context)) {
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(QType, PType, context)) {
                        best = Q;
                        break;
                    } else if (Q.hadProvisionalErrors) {
                        break;
                    } else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }
                if (!args || i == args.members.length) {
                    var collection = {
                        getLength: function () {
                            return 2;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return index ? Q.signature.getReturnType() : best.signature.getReturnType();
                        }
                    };
                    var bct = this.findBestCommonType(best.signature.getReturnType(), null, collection, false, context);
                    ambiguous = !bct;
                } else {
                    ambiguous = false;
                }
            }
            return {
                sig: best.signature,
                ambiguous: ambiguous
            };
        };
        PullTypeResolver.prototype.canApplyContextualTypeToFunction = function (candidateType, funcDecl, beStringent) {
            if (funcDecl.isParenthesized || funcDecl.isMethod() || beStringent && funcDecl.returnTypeAnnotation || funcDecl.isInlineCallLiteral) {
                return false;
            }
            beStringent = beStringent || (this.cachedFunctionInterfaceType == candidateType);
            if (!beStringent) {
                return true;
            }
            var signature = this.getSymbolForAST(funcDecl).getType().getCallSignatures()[0];
            var parameters = signature.getParameters();
            var paramLen = parameters.length;
            for(var i = 0; i < paramLen; i++) {
                var param = parameters[i];
                var argDecl = this.getASTForSymbol(param);
                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }
            if (candidateType.getConstructSignatures().length && candidateType.getCallSignatures().length) {
                return false;
            }
            var candidateSigs = candidateType.getConstructSignatures().length ? candidateType.getConstructSignatures() : candidateType.getCallSignatures();
            if (!candidateSigs || candidateSigs.length > 1) {
                return false;
            }
            return true;
        };
        PullTypeResolver.prototype.inferArgumentTypesForSignature = function (signature, args, comparisonInfo, enclosingDecl, context) {
            var cxt = null;
            var hadProvisionalErrors = false;
            var argSym;
            var parameters = signature.getParameters();
            var typeParameters = signature.getTypeParameters();
            var argContext = new TypeScript.ArgumentInferenceContext();
            var parameterType = null;
            for(var i = 0; i < typeParameters.length; i++) {
                argContext.addCandidateForInference(typeParameters[i], null, false);
            }
            var substitutions;
            var inferenceCandidates;
            var inferenceCandidate;
            for(var i = 0; i < args.members.length; i++) {
                if (i >= parameters.length) {
                    break;
                }
                parameterType = parameters[i].getType();
                if (signature.hasVariableParamList() && (i >= signature.getNonOptionalParameterCount() - 1) && parameterType.isArray()) {
                    parameterType = parameterType.getElementType();
                }
                inferenceCandidates = argContext.getInferenceCandidates();
                substitutions = {};
                if (inferenceCandidates.length) {
                    for(var j = 0; j < inferenceCandidates.length; j++) {
                        inferenceCandidate = inferenceCandidates[j];
                        substitutions = inferenceCandidates[j];
                        context.pushContextualType(parameterType, true, substitutions);
                        argSym = this.resolveStatementOrExpression(args.members[i], true, enclosingDecl, context);
                        this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);
                        cxt = context.popContextualType();
                        argSym.invalidate();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                    }
                } else {
                    context.pushContextualType(parameterType, true, {});
                    argSym = this.resolveStatementOrExpression(args.members[i], true, enclosingDecl, context);
                    this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);
                    cxt = context.popContextualType();
                    argSym.invalidate();
                    hadProvisionalErrors = cxt.hadProvisionalErrors();
                }
            }
            hadProvisionalErrors = false;
            var inferenceResults = argContext.inferArgumentTypes(this, context);
            if (inferenceResults.unfit) {
                return null;
            }
            var resultTypes = [];
            for(var i = 0; i < inferenceResults.results.length; i++) {
                resultTypes[resultTypes.length] = inferenceResults.results[i].type;
            }
            return resultTypes;
        };
        PullTypeResolver.prototype.relateTypeToTypeParameters = function (expressionType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            if (parameterType == expressionType) {
                return;
            }
            if (parameterType.isTypeParameter()) {
                argContext.addCandidateForInference(parameterType, expressionType, shouldFix);
                return;
            }
            var anyExpressionType = this.specializeTypeToAny(expressionType, enclosingDecl, context);
            var anyParameterType = this.specializeTypeToAny(parameterType, enclosingDecl, context);
            if (!this.sourceIsAssignableToTarget(anyExpressionType, anyParameterType, context)) {
                return;
            }
            if (expressionType.isArray() && parameterType.isArray()) {
                this.relateArrayTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
                return;
            }
            this.relateObjectTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
        };
        PullTypeResolver.prototype.relateFunctionSignatureToTypeParameters = function (expressionSignature, parameterSignature, argContext, enclosingDecl, context) {
            var anyExpressionSignature = this.specializeSignatureToAny(expressionSignature, enclosingDecl, context);
            var anyParamExpressionSignature = this.specializeSignatureToAny(parameterSignature, enclosingDecl, context);
            if (!this.signatureIsAssignableToTarget(anyExpressionSignature, anyParamExpressionSignature, context)) {
                return;
            }
            var expressionParams = expressionSignature.getParameters();
            var expressionReturnType = expressionSignature.getReturnType();
            var parameterParams = parameterSignature.getParameters();
            var parameterReturnType = parameterSignature.getReturnType();
            var len = parameterParams.length < expressionParams.length ? parameterParams.length : expressionParams.length;
            for(var i = 0; i < len; i++) {
                this.relateTypeToTypeParameters(expressionParams[i].getType(), parameterParams[i].getType(), true, argContext, enclosingDecl, context);
            }
            this.relateTypeToTypeParameters(expressionReturnType, parameterReturnType, true, argContext, enclosingDecl, context);
        };
        PullTypeResolver.prototype.relateObjectTypeToTypeParameters = function (objectType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures;
            var parameterSignature;
            var objectMember;
            var objectSignatures;
            for(var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = objectType.findMember(parameterTypeMembers[i].getName());
                if (objectMember) {
                    this.relateTypeToTypeParameters(objectMember.getType(), parameterTypeMembers[i].getType(), shouldFix, argContext, enclosingDecl, context);
                }
            }
            parameterSignatures = parameterType.getCallSignatures();
            objectSignatures = objectType.getCallSignatures();
            for(var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];
                for(var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
            parameterSignatures = parameterType.getConstructSignatures();
            objectSignatures = objectType.getConstructSignatures();
            for(var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];
                for(var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
            parameterSignatures = parameterType.getIndexSignatures();
            objectSignatures = objectType.getIndexSignatures();
            for(var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];
                for(var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
        };
        PullTypeResolver.prototype.relateArrayTypeToTypeParameters = function (argArrayType, parameterArrayType, shouldFix, argContext, enclosingDecl, context) {
            var argElement = argArrayType.getElementType();
            var paramElement = parameterArrayType.getElementType();
            this.relateTypeToTypeParameters(argElement, paramElement, shouldFix, argContext, enclosingDecl, context);
        };
        PullTypeResolver.prototype.specializeTypeToAny = function (typeToSpecialize, enclosingDecl, context) {
            var prevSpecialize = context.specializingToAny;
            context.specializingToAny = true;
            var type = TypeScript.specializeType(typeToSpecialize, [], this, enclosingDecl, context);
            context.specializingToAny = prevSpecialize;
            return type;
        };
        PullTypeResolver.prototype.specializeSignatureToAny = function (signatureToSpecialize, enclosingDecl, context) {
            var typeParameters = signatureToSpecialize.getTypeParameters();
            var typeReplacementMap = {};
            var typeArguments = [];
            for(var i = 0; i < typeParameters.length; i++) {
                typeArguments[i] = this.semanticInfoChain.anyTypeSymbol;
                typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            }
            return TypeScript.specializeSignature(signatureToSpecialize, false, typeReplacementMap, typeArguments, this, enclosingDecl, context);
        };
        return PullTypeResolver;
    })();
    TypeScript.PullTypeResolver = PullTypeResolver;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function prePullTypeCheck(ast, parent, walker) {
        var typeChecker = walker.state;
        var go = false;
        if (ast.nodeType == 95 /* Script */ ) {
            ast = typeChecker.typeCheckScript(ast);
            go = true;
        }
        if (ast.nodeType == 94 /* List */ ) {
            go = true;
        } else if (ast.nodeType == 75 /* VarDecl */ ) {
            ast = typeChecker.typeCheckBoundDecl(ast);
        } else if (ast.nodeType == 32 /* Asg */ ) {
            ast = typeChecker.typeCheckAsgOperator(ast);
        } else if (ast.nodeType == 73 /* FuncDecl */ ) {
            ast = typeChecker.typeCheckFunction(ast);
            go = true;
        } else if (ast.nodeType == 96 /* ClassDeclaration */ ) {
            ast = typeChecker.typeCheckClass(ast);
            go = true;
        } else if (ast.nodeType == 97 /* InterfaceDeclaration */ ) {
            ast = typeChecker.typeCheckInterface(ast);
            go = true;
        } else if (ast.nodeType == 98 /* ModuleDeclaration */ ) {
            ast = typeChecker.typeCheckModule(ast);
            go = true;
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.prePullTypeCheck = prePullTypeCheck;
    var PullTypeChecker = (function () {
        function PullTypeChecker(semanticInfoChain) {
            this.typingMap = new TypeScript.DataMap();
            this.errorMap = new TypeScript.DataMap();
            this.symbolTypeCheckStatusMap = new TypeScript.DataMap();
            this.resolver = null;
            this.context = new TypeScript.PullTypeResolutionContext();
            this.semanticInfoChain = semanticInfoChain;
        }
        PullTypeChecker.prototype.setUnit = function (unitPath) {
            this.resolver = new TypeScript.PullTypeResolver(this.semanticInfoChain, unitPath);
        };
        PullTypeChecker.prototype.typeCheck = function (ast) {
            return ast;
        };
        PullTypeChecker.prototype.typeCheckScript = function (script) {
            return script;
        };
        PullTypeChecker.prototype.typeCheckFunction = function (funcDecl) {
            var sym = this.resolver.resolveFunctionDeclaration(funcDecl, this.context);
            return funcDecl;
        };
        PullTypeChecker.prototype.typeCheckClass = function (classDecl) {
            var sym = this.resolver.resolveClassDeclaration(classDecl, this.context);
            return classDecl;
        };
        PullTypeChecker.prototype.typeCheckInterface = function (interfaceDecl) {
            var sym = this.resolver.resolveInterfaceDeclaration(interfaceDecl, this.context);
            return interfaceDecl;
        };
        PullTypeChecker.prototype.typeCheckModule = function (moduleDecl) {
            var sym = this.resolver.resolveModuleDeclaration(moduleDecl, this.context);
            return moduleDecl;
        };
        PullTypeChecker.prototype.typeCheckBoundDecl = function (varDecl) {
            var sym = this.resolver.resolveVariableDeclaration(varDecl, this.context);
            return varDecl;
        };
        PullTypeChecker.prototype.typeCheckThis = function (ast) {
            return ast;
        };
        PullTypeChecker.prototype.typeCheckName = function (ast) {
            return ast;
        };
        PullTypeChecker.prototype.typeCheckAsgOperator = function (ast) {
            return ast;
        };
        PullTypeChecker.prototype.typeCheckObjectLit = function (objectLit) {
            return objectLit;
        };
        PullTypeChecker.prototype.typeCheckReturn = function (returnStmt) {
            return returnStmt;
        };
        PullTypeChecker.prototype.typeCheckNew = function (ast) {
            return ast;
        };
        PullTypeChecker.prototype.typeCheckCall = function (ast) {
            return ast;
        };
        return PullTypeChecker;
    })();
    TypeScript.PullTypeChecker = PullTypeChecker;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullDeclEdit) {
        PullDeclEdit._map = [];
        PullDeclEdit._map[0] = "NoChanges";
        PullDeclEdit.NoChanges = 0;
        PullDeclEdit._map[1] = "DeclAdded";
        PullDeclEdit.DeclAdded = 1;
        PullDeclEdit._map[2] = "DeclRemoved";
        PullDeclEdit.DeclRemoved = 2;
        PullDeclEdit._map[3] = "DeclChanged";
        PullDeclEdit.DeclChanged = 3;
    })(TypeScript.PullDeclEdit || (TypeScript.PullDeclEdit = {}));
    var PullDeclEdit = TypeScript.PullDeclEdit;
    var PullDeclDiff = (function () {
        function PullDeclDiff(oldDecl, newDecl, kind) {
            this.oldDecl = oldDecl;
            this.newDecl = newDecl;
            this.kind = kind;
        }
        return PullDeclDiff;
    })();
    TypeScript.PullDeclDiff = PullDeclDiff;    
    var PullDeclDiffer = (function () {
        function PullDeclDiffer() { }
        PullDeclDiffer.prototype.diffDecls = function (oldDecl, newDecl, diffs) {
            var oldDeclChildren = oldDecl.getChildDecls();
            var newDeclChildren = newDecl.getChildDecls();
            var foundDecls;
            var foundDiff = false;
            for(var i = 0; i < oldDeclChildren.length; i++) {
                foundDecls = newDecl.findChildDecls(oldDeclChildren[i].getName(), oldDeclChildren[i].getKind());
                if (!foundDecls.length) {
                    diffs[diffs.length] = new PullDeclDiff(oldDeclChildren[i], null, 2 /* DeclRemoved */ );
                    foundDiff = true;
                } else if (foundDecls.length == 1) {
                    this.diffDecls(oldDeclChildren[i], foundDecls[0], diffs);
                }
            }
            for(var i = 0; i < newDeclChildren.length; i++) {
                foundDecls = oldDecl.findChildDecls(newDeclChildren[i].getName(), newDeclChildren[i].getKind());
                if (!foundDecls.length) {
                    diffs[diffs.length] = new PullDeclDiff(oldDecl, newDeclChildren[i], 1 /* DeclAdded */ );
                    foundDiff = true;
                }
            }
            if (!foundDiff) {
                newDecl.setErrors(oldDecl.getErrors());
            }
        };
        return PullDeclDiffer;
    })();
    TypeScript.PullDeclDiffer = PullDeclDiffer;    
})(TypeScript || (TypeScript = {}));
var Collections;
(function (Collections) {
    Collections.DefaultHashTableCapacity = 256;
    var HashTableEntry = (function () {
        function HashTableEntry(Key, Value, HashCode, Next) {
            this.Key = Key;
            this.Value = Value;
            this.HashCode = HashCode;
            this.Next = Next;
        }
        return HashTableEntry;
    })();    
    var HashTable = (function () {
        function HashTable(capacity, hash, equals) {
            this.hash = hash;
            this.equals = equals;
            this.entries = [];
            this.count = 0;
            var size = Hash.getPrime(capacity);
            this.hash = hash;
            this.equals = equals;
            this.entries = ArrayUtilities.createArray(size, null);
        }
        HashTable.prototype.set = function (key, value) {
            this.addOrSet(key, value, false);
        };
        HashTable.prototype.add = function (key, value) {
            this.addOrSet(key, value, true);
        };
        HashTable.prototype.containsKey = function (key) {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);
            return entry !== null;
        };
        HashTable.prototype.get = function (key) {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);
            return entry === null ? null : entry.Value;
        };
        HashTable.prototype.computeHashCode = function (key) {
            var hashCode = this.hash === null ? key.hashCode() : this.hash(key);
            hashCode = hashCode & 0x7FFFFFFF;
            Debug.assert(hashCode > 0);
            return hashCode;
        };
        HashTable.prototype.addOrSet = function (key, value, throwOnExistingEntry) {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);
            if (entry !== null) {
                if (throwOnExistingEntry) {
                    throw Errors.argument('key', 'Key was already in table.');
                }
                entry.Key = key;
                entry.Value = value;
                return;
            }
            return this.addEntry(key, value, hashCode);
        };
        HashTable.prototype.findEntry = function (key, hashCode) {
            for(var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                if (e.HashCode === hashCode) {
                    var equals = this.equals === null ? key === e.Key : this.equals(key, e.Key);
                    if (equals) {
                        return e;
                    }
                }
            }
            return null;
        };
        HashTable.prototype.addEntry = function (key, value, hashCode) {
            var index = hashCode % this.entries.length;
            var e = new HashTableEntry(key, value, hashCode, this.entries[index]);
            this.entries[index] = e;
            if (this.count === this.entries.length) {
                this.grow();
            }
            this.count++;
            return e.Key;
        };
        HashTable.prototype.grow = function () {
            var newSize = Hash.expandPrime(this.entries.length);
            var oldEntries = this.entries;
            var newEntries = ArrayUtilities.createArray(newSize, null);
            this.entries = newEntries;
            for(var i = 0; i < oldEntries.length; i++) {
                var e = oldEntries[i];
                while(e !== null) {
                    var newIndex = e.HashCode % newSize;
                    var tmp = e.Next;
                    e.Next = newEntries[newIndex];
                    newEntries[newIndex] = e;
                    e = tmp;
                }
            }
        };
        return HashTable;
    })();
    Collections.HashTable = HashTable;    
    function createHashTable(capacity, hash, equals) {
        if (typeof capacity === "undefined") { capacity = Collections.DefaultHashTableCapacity; }
        if (typeof hash === "undefined") { hash = null; }
        if (typeof equals === "undefined") { equals = null; }
        return new HashTable(capacity, hash, equals);
    }
    Collections.createHashTable = createHashTable;
    var currentHashCode = 1;
    function identityHashCode(value) {
        if (value.__hash === undefined) {
            value.__hash = currentHashCode;
            currentHashCode++;
        }
        return value.__hash;
    }
    Collections.identityHashCode = identityHashCode;
})(Collections || (Collections = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.declCacheHit = 0;
    TypeScript.declCacheMiss = 0;
    TypeScript.symbolCacheHit = 0;
    TypeScript.symbolCacheMiss = 0;
    var SemanticInfo = (function () {
        function SemanticInfo(compilationUnitPath, locationInfo) {
            if (typeof locationInfo === "undefined") { locationInfo = null; }
            this.locationInfo = locationInfo;
            this.topLevelDecls = [];
            this.astDeclMap = new TypeScript.DataMap();
            this.declASTMap = new TypeScript.DataMap();
            this.syntaxElementDeclMap = new TypeScript.DataMap();
            this.declSyntaxElementMap = new TypeScript.DataMap();
            this.declSymbolMap = new TypeScript.DataMap();
            this.astSymbolMap = new TypeScript.DataMap();
            this.symbolASTMap = new TypeScript.DataMap();
            this.syntaxElementSymbolMap = new TypeScript.DataMap();
            this.symbolSyntaxElementMap = new TypeScript.DataMap();
            this.compilationUnitPath = compilationUnitPath;
        }
        SemanticInfo.prototype.addTopLevelDecl = function (decl) {
            this.topLevelDecls[this.topLevelDecls.length] = decl;
        };
        SemanticInfo.prototype.getTopLevelDecls = function () {
            return this.topLevelDecls;
        };
        SemanticInfo.prototype.getPath = function () {
            return this.compilationUnitPath;
        };
        SemanticInfo.prototype.getDeclForAST = function (ast) {
            return this.astDeclMap.read(ast.getID().toString());
        };
        SemanticInfo.prototype.setDeclForAST = function (ast, decl) {
            this.astDeclMap.link(ast.getID().toString(), decl);
        };
        SemanticInfo.prototype.getASTForDecl = function (decl) {
            return this.declASTMap.read(decl.getDeclID().toString() + decl.getKind().toString());
        };
        SemanticInfo.prototype.setASTForDecl = function (decl, ast) {
            this.declASTMap.link(decl.getDeclID().toString() + decl.getKind().toString(), ast);
        };
        SemanticInfo.prototype.setSymbolForAST = function (ast, symbol) {
            this.astSymbolMap.link(ast.getID().toString(), symbol);
            this.symbolASTMap.link(symbol.getSymbolID().toString(), ast);
        };
        SemanticInfo.prototype.getSymbolForAST = function (ast) {
            return this.astSymbolMap.read(ast.getID().toString());
        };
        SemanticInfo.prototype.getASTForSymbol = function (symbol) {
            return this.symbolASTMap.read(symbol.getSymbolID().toString());
        };
        SemanticInfo.prototype.getSyntaxElementForDecl = function (decl) {
            return this.declSyntaxElementMap.read(decl.getDeclID().toString() + decl.getKind().toString());
        };
        SemanticInfo.prototype.setSyntaxElementForDecl = function (decl, syntaxElement) {
            this.declSyntaxElementMap.link(decl.getDeclID().toString() + decl.getKind().toString(), syntaxElement);
        };
        SemanticInfo.prototype.getDeclForSyntaxElement = function (syntaxElement) {
            return this.syntaxElementDeclMap.read(Collections.identityHashCode(syntaxElement).toString());
        };
        SemanticInfo.prototype.setDeclForSyntaxElement = function (syntaxElement, decl) {
            this.syntaxElementDeclMap.link(Collections.identityHashCode(syntaxElement).toString(), decl);
        };
        SemanticInfo.prototype.getSyntaxElementForSymbol = function (symbol) {
            return this.symbolSyntaxElementMap.read(symbol.getSymbolID().toString());
        };
        SemanticInfo.prototype.getSymbolForSyntaxElement = function (syntaxElement) {
            return this.syntaxElementSymbolMap.read(Collections.identityHashCode(syntaxElement).toString());
        };
        SemanticInfo.prototype.setSymbolForSyntaxElement = function (syntaxElement, symbol) {
            this.syntaxElementSymbolMap.link(Collections.identityHashCode(syntaxElement).toString(), symbol);
            this.symbolSyntaxElementMap.link(symbol.getSymbolID().toString(), syntaxElement);
        };
        SemanticInfo.prototype.getErrors = function (semanticErrors) {
            for(var i = 0; i < this.topLevelDecls.length; i++) {
                TypeScript.getErrorsFromEnclosingDecl(this.topLevelDecls[i], semanticErrors);
            }
        };
        return SemanticInfo;
    })();
    TypeScript.SemanticInfo = SemanticInfo;    
    var SemanticInfoChain = (function () {
        function SemanticInfoChain() {
            this.units = [
                new SemanticInfo("")
            ];
            this.declCache = new TypeScript.BlockIntrinsics();
            this.symbolCache = new TypeScript.BlockIntrinsics();
            this.unitCache = new TypeScript.BlockIntrinsics();
            this.anyTypeSymbol = null;
            this.boolTypeSymbol = null;
            this.numberTypeSymbol = null;
            this.stringTypeSymbol = null;
            this.nullTypeSymbol = null;
            this.undefinedTypeSymbol = null;
            this.elementTypeSymbol = null;
            this.voidTypeSymbol = null;
            var span = new TypeScript.DeclSpan();
            var globalDecl = new TypeScript.PullDecl("", 2 /* Global */ , 0 /* None */ , span, "");
            var globalInfo = this.units[0];
            globalInfo.addTopLevelDecl(globalDecl);
            this.anyTypeSymbol = this.addPrimitive("any", globalDecl);
            this.boolTypeSymbol = this.addPrimitive("bool", globalDecl);
            this.numberTypeSymbol = this.addPrimitive("number", globalDecl);
            this.stringTypeSymbol = this.addPrimitive("string", globalDecl);
            this.nullTypeSymbol = this.addPrimitive("null", globalDecl);
            this.undefinedTypeSymbol = this.addPrimitive("undefined", globalDecl);
            this.voidTypeSymbol = this.addPrimitive("void", globalDecl);
            this.elementTypeSymbol = this.addPrimitive("_element", globalDecl);
        }
        SemanticInfoChain.prototype.addPrimitive = function (name, globalDecl) {
            var span = new TypeScript.DeclSpan();
            var decl = new TypeScript.PullDecl(name, 4 /* Primitive */ , 0 /* None */ , span, "");
            var symbol = new TypeScript.PullPrimitiveTypeSymbol(name);
            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);
            symbol.setResolved();
            globalDecl.addChildDecl(decl);
            return symbol;
        };
        SemanticInfoChain.prototype.addUnit = function (unit) {
            this.units[this.units.length] = unit;
            this.unitCache[unit.getPath()] = unit;
        };
        SemanticInfoChain.prototype.getUnit = function (compilationUnitPath) {
            for(var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() == compilationUnitPath) {
                    return this.units[i];
                }
            }
            return null;
        };
        SemanticInfoChain.prototype.updateUnit = function (oldUnit, newUnit) {
            for(var i = 0; i < this.units.length; i++) {
                if (this.units[i] == oldUnit) {
                    this.units[i] = newUnit;
                    this.unitCache[oldUnit.getPath()] = newUnit;
                    return;
                }
            }
        };
        SemanticInfoChain.prototype.collectAllTopLevelDecls = function () {
            var decls = [];
            var unitDecls;
            for(var i = 0; i < this.units.length; i++) {
                unitDecls = this.units[i].getTopLevelDecls();
                for(var j = 0; j < unitDecls.length; j++) {
                    decls[decls.length] = unitDecls[j];
                }
            }
            return decls;
        };
        SemanticInfoChain.prototype.getDeclPathCacheID = function (declPath, declKind) {
            var cacheID = "";
            for(var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }
            return cacheID + "#" + declKind.toString();
        };
        SemanticInfoChain.prototype.findDecls = function (declPath, declKind) {
            var cacheID = this.getDeclPathCacheID(declPath, declKind);
            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];
                if (cachedDecls && cachedDecls.length) {
                    TypeScript.declCacheHit++;
                    return cachedDecls;
                }
            }
            TypeScript.declCacheMiss++;
            var declsToSearch = this.collectAllTopLevelDecls();
            var decls = [];
            var path;
            var foundDecls = [];
            var keepSearching = (declKind & 8 /* Container */ ) || (declKind & 32 /* Interface */ );
            for(var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = [];
                for(var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].findChildDecls(path, (i == declPath.length - 1) ? declKind : TypeScript.PullElementKind.SomeType);
                    for(var k = 0; k < foundDecls.length; k++) {
                        decls[decls.length] = foundDecls[k];
                    }
                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }
                declsToSearch = decls;
                if (!declsToSearch) {
                    break;
                }
            }
            if (decls.length) {
                this.declCache[cacheID] = decls;
            }
            return decls;
        };
        SemanticInfoChain.prototype.findSymbol = function (declPath, declType) {
            var cacheID = this.getDeclPathCacheID(declPath, declType);
            if (declPath.length) {
                var cachedSymbol = this.symbolCache[cacheID];
                if (cachedSymbol) {
                    TypeScript.symbolCacheHit++;
                    return cachedSymbol;
                }
            }
            TypeScript.symbolCacheMiss++;
            var decls = this.findDecls(declPath, declType);
            var symbol = null;
            if (decls.length) {
                var symbol = decls[0].getSymbol();
                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                    symbol.addCacheID(cacheID);
                }
            }
            return symbol;
        };
        SemanticInfoChain.prototype.update = function (compilationUnitPath) {
            this.declCache = new TypeScript.BlockIntrinsics();
        };
        SemanticInfoChain.prototype.getDeclForAST = function (ast, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                return unit.getDeclForAST(ast);
            }
            return null;
        };
        SemanticInfoChain.prototype.getASTForDecl = function (decl, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                return unit.getASTForDecl(decl);
            }
            return null;
        };
        SemanticInfoChain.prototype.getSymbolForAST = function (ast, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                return unit.getSymbolForAST(ast);
            }
            return null;
        };
        SemanticInfoChain.prototype.getASTForSymbol = function (symbol, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                return unit.getASTForSymbol(symbol);
            }
            return null;
        };
        SemanticInfoChain.prototype.setSymbolForAST = function (ast, typeSymbol, unitPath) {
            var unit = this.unitCache[unitPath];
            if (unit) {
                unit.setSymbolForAST(ast, typeSymbol);
            }
        };
        SemanticInfoChain.prototype.removeSymbolFromCache = function (symbol) {
            var path = [
                symbol.getName()
            ];
            var kind = (symbol.getKind() & TypeScript.PullElementKind.SomeType) != 0 ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeValue;
            var kindID = this.getDeclPathCacheID(path, kind);
            var symID = this.getDeclPathCacheID(path, symbol.getKind());
            symbol.addCacheID(kindID);
            symbol.addCacheID(symID);
            symbol.invalidateCachedIDs(this.symbolCache);
        };
        SemanticInfoChain.prototype.postErrors = function () {
            var errors = [];
            for(var i = 1; i < this.units.length; i++) {
                this.units[i].getErrors(errors);
            }
            return errors;
        };
        return SemanticInfoChain;
    })();
    TypeScript.SemanticInfoChain = SemanticInfoChain;    
})(TypeScript || (TypeScript = {}));
var SyntaxWalker = (function () {
    function SyntaxWalker() { }
    SyntaxWalker.prototype.visitToken = function (token) {
    };
    SyntaxWalker.prototype.visitNode = function (node) {
        node.accept(this);
    };
    SyntaxWalker.prototype.visitNodeOrToken = function (nodeOrToken) {
        if (nodeOrToken.isToken()) {
            this.visitToken(nodeOrToken);
        } else {
            this.visitNode(nodeOrToken);
        }
    };
    SyntaxWalker.prototype.visitOptionalToken = function (token) {
        if (token === null) {
            return;
        }
        this.visitToken(token);
    };
    SyntaxWalker.prototype.visitOptionalNode = function (node) {
        if (node === null) {
            return;
        }
        this.visitNode(node);
    };
    SyntaxWalker.prototype.visitOptionalNodeOrToken = function (nodeOrToken) {
        if (nodeOrToken === null) {
            return;
        }
        this.visitNodeOrToken(nodeOrToken);
    };
    SyntaxWalker.prototype.visitList = function (list) {
        for(var i = 0, n = list.childCount(); i < n; i++) {
            this.visitNodeOrToken(list.childAt(i));
        }
    };
    SyntaxWalker.prototype.visitSeparatedList = function (list) {
        for(var i = 0, n = list.childCount(); i < n; i++) {
            var item = list.childAt(i);
            this.visitNodeOrToken(item);
        }
    };
    SyntaxWalker.prototype.visitSourceUnit = function (node) {
        this.visitList(node.moduleElements);
        this.visitToken(node.endOfFileToken);
    };
    SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
        this.visitToken(node.moduleKeyword);
        this.visitToken(node.openParenToken);
        this.visitToken(node.stringLiteral);
        this.visitToken(node.closeParenToken);
    };
    SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
        this.visitNodeOrToken(node.moduleName);
    };
    SyntaxWalker.prototype.visitImportDeclaration = function (node) {
        this.visitToken(node.importKeyword);
        this.visitToken(node.identifier);
        this.visitToken(node.equalsToken);
        this.visitNode(node.moduleReference);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitClassDeclaration = function (node) {
        this.visitOptionalToken(node.exportKeyword);
        this.visitOptionalToken(node.declareKeyword);
        this.visitToken(node.classKeyword);
        this.visitToken(node.identifier);
        this.visitOptionalNode(node.typeParameterList);
        this.visitOptionalNode(node.extendsClause);
        this.visitOptionalNode(node.implementsClause);
        this.visitToken(node.openBraceToken);
        this.visitList(node.classElements);
        this.visitToken(node.closeBraceToken);
    };
    SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
        this.visitOptionalToken(node.exportKeyword);
        this.visitToken(node.interfaceKeyword);
        this.visitToken(node.identifier);
        this.visitOptionalNode(node.typeParameterList);
        this.visitOptionalNode(node.extendsClause);
        this.visitNode(node.body);
    };
    SyntaxWalker.prototype.visitExtendsClause = function (node) {
        this.visitToken(node.extendsKeyword);
        this.visitSeparatedList(node.typeNames);
    };
    SyntaxWalker.prototype.visitImplementsClause = function (node) {
        this.visitToken(node.implementsKeyword);
        this.visitSeparatedList(node.typeNames);
    };
    SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
        this.visitOptionalToken(node.exportKeyword);
        this.visitOptionalToken(node.declareKeyword);
        this.visitToken(node.moduleKeyword);
        this.visitOptionalNodeOrToken(node.moduleName);
        this.visitOptionalToken(node.stringLiteral);
        this.visitToken(node.openBraceToken);
        this.visitList(node.moduleElements);
        this.visitToken(node.closeBraceToken);
    };
    SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
        this.visitOptionalToken(node.exportKeyword);
        this.visitOptionalToken(node.declareKeyword);
        this.visitToken(node.functionKeyword);
        this.visitNode(node.functionSignature);
        this.visitOptionalNode(node.block);
        this.visitOptionalToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitVariableStatement = function (node) {
        this.visitOptionalToken(node.exportKeyword);
        this.visitOptionalToken(node.declareKeyword);
        this.visitNode(node.variableDeclaration);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
        this.visitToken(node.varKeyword);
        this.visitSeparatedList(node.variableDeclarators);
    };
    SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
        this.visitToken(node.identifier);
        this.visitOptionalNode(node.typeAnnotation);
        this.visitOptionalNode(node.equalsValueClause);
    };
    SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
        this.visitToken(node.equalsToken);
        this.visitNodeOrToken(node.value);
    };
    SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
        this.visitToken(node.operatorToken);
        this.visitNodeOrToken(node.operand);
    };
    SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
        this.visitToken(node.openBracketToken);
        this.visitSeparatedList(node.expressions);
        this.visitToken(node.closeBracketToken);
    };
    SyntaxWalker.prototype.visitOmittedExpression = function (node) {
    };
    SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.closeParenToken);
    };
    SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
        this.visitToken(node.identifier);
        this.visitToken(node.equalsGreaterThanToken);
        this.visitNodeOrToken(node.body);
    };
    SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
        this.visitNode(node.callSignature);
        this.visitToken(node.equalsGreaterThanToken);
        this.visitNodeOrToken(node.body);
    };
    SyntaxWalker.prototype.visitQualifiedName = function (node) {
        this.visitNodeOrToken(node.left);
        this.visitToken(node.dotToken);
        this.visitToken(node.right);
    };
    SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
        this.visitToken(node.lessThanToken);
        this.visitSeparatedList(node.typeArguments);
        this.visitToken(node.greaterThanToken);
    };
    SyntaxWalker.prototype.visitConstructorType = function (node) {
        this.visitToken(node.newKeyword);
        this.visitOptionalNode(node.typeParameterList);
        this.visitNode(node.parameterList);
        this.visitToken(node.equalsGreaterThanToken);
        this.visitNodeOrToken(node.type);
    };
    SyntaxWalker.prototype.visitFunctionType = function (node) {
        this.visitOptionalNode(node.typeParameterList);
        this.visitNode(node.parameterList);
        this.visitToken(node.equalsGreaterThanToken);
        this.visitNodeOrToken(node.type);
    };
    SyntaxWalker.prototype.visitObjectType = function (node) {
        this.visitToken(node.openBraceToken);
        this.visitSeparatedList(node.typeMembers);
        this.visitToken(node.closeBraceToken);
    };
    SyntaxWalker.prototype.visitArrayType = function (node) {
        this.visitNodeOrToken(node.type);
        this.visitToken(node.openBracketToken);
        this.visitToken(node.closeBracketToken);
    };
    SyntaxWalker.prototype.visitGenericType = function (node) {
        this.visitNodeOrToken(node.name);
        this.visitNode(node.typeArgumentList);
    };
    SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
        this.visitToken(node.colonToken);
        this.visitNodeOrToken(node.type);
    };
    SyntaxWalker.prototype.visitBlock = function (node) {
        this.visitToken(node.openBraceToken);
        this.visitList(node.statements);
        this.visitToken(node.closeBraceToken);
    };
    SyntaxWalker.prototype.visitParameter = function (node) {
        this.visitOptionalToken(node.dotDotDotToken);
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitToken(node.identifier);
        this.visitOptionalToken(node.questionToken);
        this.visitOptionalNode(node.typeAnnotation);
        this.visitOptionalNode(node.equalsValueClause);
    };
    SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.dotToken);
        this.visitToken(node.name);
    };
    SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
        this.visitNodeOrToken(node.operand);
        this.visitToken(node.operatorToken);
    };
    SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.openBracketToken);
        this.visitNodeOrToken(node.argumentExpression);
        this.visitToken(node.closeBracketToken);
    };
    SyntaxWalker.prototype.visitInvocationExpression = function (node) {
        this.visitNodeOrToken(node.expression);
        this.visitNode(node.argumentList);
    };
    SyntaxWalker.prototype.visitArgumentList = function (node) {
        this.visitOptionalNode(node.typeArgumentList);
        this.visitToken(node.openParenToken);
        this.visitSeparatedList(node.arguments);
        this.visitToken(node.closeParenToken);
    };
    SyntaxWalker.prototype.visitBinaryExpression = function (node) {
        this.visitNodeOrToken(node.left);
        this.visitToken(node.operatorToken);
        this.visitNodeOrToken(node.right);
    };
    SyntaxWalker.prototype.visitConditionalExpression = function (node) {
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.questionToken);
        this.visitNodeOrToken(node.whenTrue);
        this.visitToken(node.colonToken);
        this.visitNodeOrToken(node.whenFalse);
    };
    SyntaxWalker.prototype.visitConstructSignature = function (node) {
        this.visitToken(node.newKeyword);
        this.visitNode(node.callSignature);
    };
    SyntaxWalker.prototype.visitFunctionSignature = function (node) {
        this.visitToken(node.identifier);
        this.visitOptionalToken(node.questionToken);
        this.visitNode(node.callSignature);
    };
    SyntaxWalker.prototype.visitIndexSignature = function (node) {
        this.visitToken(node.openBracketToken);
        this.visitNode(node.parameter);
        this.visitToken(node.closeBracketToken);
        this.visitOptionalNode(node.typeAnnotation);
    };
    SyntaxWalker.prototype.visitPropertySignature = function (node) {
        this.visitToken(node.identifier);
        this.visitOptionalToken(node.questionToken);
        this.visitOptionalNode(node.typeAnnotation);
    };
    SyntaxWalker.prototype.visitParameterList = function (node) {
        this.visitToken(node.openParenToken);
        this.visitSeparatedList(node.parameters);
        this.visitToken(node.closeParenToken);
    };
    SyntaxWalker.prototype.visitCallSignature = function (node) {
        this.visitOptionalNode(node.typeParameterList);
        this.visitNode(node.parameterList);
        this.visitOptionalNode(node.typeAnnotation);
    };
    SyntaxWalker.prototype.visitTypeParameterList = function (node) {
        this.visitToken(node.lessThanToken);
        this.visitSeparatedList(node.typeParameters);
        this.visitToken(node.greaterThanToken);
    };
    SyntaxWalker.prototype.visitTypeParameter = function (node) {
        this.visitToken(node.identifier);
        this.visitOptionalNode(node.constraint);
    };
    SyntaxWalker.prototype.visitConstraint = function (node) {
        this.visitToken(node.extendsKeyword);
        this.visitNodeOrToken(node.type);
    };
    SyntaxWalker.prototype.visitElseClause = function (node) {
        this.visitToken(node.elseKeyword);
        this.visitNodeOrToken(node.statement);
    };
    SyntaxWalker.prototype.visitIfStatement = function (node) {
        this.visitToken(node.ifKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
        this.visitOptionalNode(node.elseClause);
    };
    SyntaxWalker.prototype.visitExpressionStatement = function (node) {
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
        this.visitToken(node.constructorKeyword);
        this.visitNode(node.parameterList);
        this.visitOptionalNode(node.block);
        this.visitOptionalToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitOptionalToken(node.staticKeyword);
        this.visitNode(node.functionSignature);
        this.visitOptionalNode(node.block);
        this.visitOptionalToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitOptionalToken(node.staticKeyword);
        this.visitToken(node.getKeyword);
        this.visitToken(node.identifier);
        this.visitNode(node.parameterList);
        this.visitOptionalNode(node.typeAnnotation);
        this.visitNode(node.block);
    };
    SyntaxWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitOptionalToken(node.staticKeyword);
        this.visitToken(node.setKeyword);
        this.visitToken(node.identifier);
        this.visitNode(node.parameterList);
        this.visitNode(node.block);
    };
    SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitOptionalToken(node.staticKeyword);
        this.visitNode(node.variableDeclarator);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitThrowStatement = function (node) {
        this.visitToken(node.throwKeyword);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitReturnStatement = function (node) {
        this.visitToken(node.returnKeyword);
        this.visitOptionalNodeOrToken(node.expression);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
        this.visitToken(node.newKeyword);
        this.visitNodeOrToken(node.expression);
        this.visitOptionalNode(node.argumentList);
    };
    SyntaxWalker.prototype.visitSwitchStatement = function (node) {
        this.visitToken(node.switchKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.closeParenToken);
        this.visitToken(node.openBraceToken);
        this.visitList(node.switchClauses);
        this.visitToken(node.closeBraceToken);
    };
    SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
        this.visitToken(node.caseKeyword);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.colonToken);
        this.visitList(node.statements);
    };
    SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
        this.visitToken(node.defaultKeyword);
        this.visitToken(node.colonToken);
        this.visitList(node.statements);
    };
    SyntaxWalker.prototype.visitBreakStatement = function (node) {
        this.visitToken(node.breakKeyword);
        this.visitOptionalToken(node.identifier);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitContinueStatement = function (node) {
        this.visitToken(node.continueKeyword);
        this.visitOptionalToken(node.identifier);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitForStatement = function (node) {
        this.visitToken(node.forKeyword);
        this.visitToken(node.openParenToken);
        this.visitOptionalNode(node.variableDeclaration);
        this.visitOptionalNodeOrToken(node.initializer);
        this.visitToken(node.firstSemicolonToken);
        this.visitOptionalNodeOrToken(node.condition);
        this.visitToken(node.secondSemicolonToken);
        this.visitOptionalNodeOrToken(node.incrementor);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
    };
    SyntaxWalker.prototype.visitForInStatement = function (node) {
        this.visitToken(node.forKeyword);
        this.visitToken(node.openParenToken);
        this.visitOptionalNode(node.variableDeclaration);
        this.visitOptionalNodeOrToken(node.left);
        this.visitToken(node.inKeyword);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
    };
    SyntaxWalker.prototype.visitWhileStatement = function (node) {
        this.visitToken(node.whileKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
    };
    SyntaxWalker.prototype.visitWithStatement = function (node) {
        this.visitToken(node.withKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
    };
    SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
        this.visitOptionalToken(node.exportKeyword);
        this.visitToken(node.enumKeyword);
        this.visitToken(node.identifier);
        this.visitToken(node.openBraceToken);
        this.visitSeparatedList(node.variableDeclarators);
        this.visitToken(node.closeBraceToken);
    };
    SyntaxWalker.prototype.visitCastExpression = function (node) {
        this.visitToken(node.lessThanToken);
        this.visitNodeOrToken(node.type);
        this.visitToken(node.greaterThanToken);
        this.visitNodeOrToken(node.expression);
    };
    SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
        this.visitToken(node.openBraceToken);
        this.visitSeparatedList(node.propertyAssignments);
        this.visitToken(node.closeBraceToken);
    };
    SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
        this.visitToken(node.propertyName);
        this.visitToken(node.colonToken);
        this.visitNodeOrToken(node.expression);
    };
    SyntaxWalker.prototype.visitGetAccessorPropertyAssignment = function (node) {
        this.visitToken(node.getKeyword);
        this.visitToken(node.propertyName);
        this.visitToken(node.openParenToken);
        this.visitToken(node.closeParenToken);
        this.visitNode(node.block);
    };
    SyntaxWalker.prototype.visitSetAccessorPropertyAssignment = function (node) {
        this.visitToken(node.setKeyword);
        this.visitToken(node.propertyName);
        this.visitToken(node.openParenToken);
        this.visitToken(node.parameterName);
        this.visitToken(node.closeParenToken);
        this.visitNode(node.block);
    };
    SyntaxWalker.prototype.visitFunctionExpression = function (node) {
        this.visitToken(node.functionKeyword);
        this.visitOptionalToken(node.identifier);
        this.visitNode(node.callSignature);
        this.visitNode(node.block);
    };
    SyntaxWalker.prototype.visitEmptyStatement = function (node) {
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitTryStatement = function (node) {
        this.visitToken(node.tryKeyword);
        this.visitNode(node.block);
        this.visitOptionalNode(node.catchClause);
        this.visitOptionalNode(node.finallyClause);
    };
    SyntaxWalker.prototype.visitCatchClause = function (node) {
        this.visitToken(node.catchKeyword);
        this.visitToken(node.openParenToken);
        this.visitToken(node.identifier);
        this.visitToken(node.closeParenToken);
        this.visitNode(node.block);
    };
    SyntaxWalker.prototype.visitFinallyClause = function (node) {
        this.visitToken(node.finallyKeyword);
        this.visitNode(node.block);
    };
    SyntaxWalker.prototype.visitLabeledStatement = function (node) {
        this.visitToken(node.identifier);
        this.visitToken(node.colonToken);
        this.visitNodeOrToken(node.statement);
    };
    SyntaxWalker.prototype.visitDoStatement = function (node) {
        this.visitToken(node.doKeyword);
        this.visitNodeOrToken(node.statement);
        this.visitToken(node.whileKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.closeParenToken);
        this.visitToken(node.semicolonToken);
    };
    SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
        this.visitToken(node.typeOfKeyword);
        this.visitNodeOrToken(node.expression);
    };
    SyntaxWalker.prototype.visitDeleteExpression = function (node) {
        this.visitToken(node.deleteKeyword);
        this.visitNodeOrToken(node.expression);
    };
    SyntaxWalker.prototype.visitVoidExpression = function (node) {
        this.visitToken(node.voidKeyword);
        this.visitNodeOrToken(node.expression);
    };
    SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
        this.visitToken(node.debuggerKeyword);
        this.visitToken(node.semicolonToken);
    };
    return SyntaxWalker;
})();
var TypeScript;
(function (TypeScript) {
    var DeclCollectionContext = (function () {
        function DeclCollectionContext(semanticInfo, scriptName) {
            if (typeof scriptName === "undefined") { scriptName = ""; }
            this.semanticInfo = semanticInfo;
            this.scriptName = scriptName;
            this.parentChain = [];
            this.foundValueDecl = false;
        }
        DeclCollectionContext.prototype.getParent = function () {
            return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;
        };
        DeclCollectionContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
            }
        };
        DeclCollectionContext.prototype.popParent = function () {
            this.parentChain.length--;
        };
        return DeclCollectionContext;
    })();
    TypeScript.DeclCollectionContext = DeclCollectionContext;    
    function preCollectImportDecls(ast, parent, context) {
        var importDecl = ast;
        var declFlags = 0 /* None */ ;
        var span = new TypeScript.DeclSpan();
        span.minChar = importDecl.minChar;
        span.limChar = importDecl.limChar;
        var decl = new TypeScript.PullDecl(importDecl.id.actualText, 512 /* TypeAlias */ , declFlags, span, context.scriptName);
        context.getParent().addChildDecl(decl);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);
        return false;
    }
    TypeScript.preCollectImportDecls = preCollectImportDecls;
    function preCollectModuleDecls(ast, parent, context) {
        var moduleDecl = ast;
        var declFlags = 0 /* None */ ;
        var modName = (moduleDecl.name).text;
        var isDynamic = TypeScript.isQuoted(modName);
        var kind = 8 /* Container */ ;
        if (TypeScript.hasFlag(moduleDecl.modFlags, 8 /* Ambient */ )) {
            declFlags |= 8 /* Ambient */ ;
        }
        if (TypeScript.hasFlag(moduleDecl.modFlags, 1 /* Exported */ )) {
            declFlags |= 1 /* Exported */ ;
        }
        if (TypeScript.hasFlag(moduleDecl.modFlags, 256 /* IsEnum */ )) {
            declFlags |= 8192 /* Enum */ ;
            kind = 128 /* Enum */ ;
        } else {
            kind = isDynamic ? 64 /* DynamicModule */  : 8 /* Container */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = moduleDecl.minChar;
        span.limChar = moduleDecl.limChar;
        var decl = new TypeScript.PullDecl(modName, kind, declFlags, span, context.scriptName);
        context.getParent().addChildDecl(decl);
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);
        return true;
    }
    TypeScript.preCollectModuleDecls = preCollectModuleDecls;
    function preCollectClassDecls(ast, parent, context) {
        var classDecl = ast;
        var declFlags = 0 /* None */ ;
        var constructorDeclKind = 2048 /* Variable */ ;
        if (TypeScript.hasFlag(classDecl.varFlags, 8 /* Ambient */ )) {
            declFlags |= 8 /* Ambient */ ;
        }
        if (TypeScript.hasFlag(classDecl.varFlags, 1 /* Exported */ )) {
            declFlags |= 1 /* Exported */ ;
            constructorDeclKind = 8192 /* Property */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = classDecl.minChar;
        span.limChar = classDecl.limChar;
        var decl = new TypeScript.PullDecl(classDecl.name.text, 16 /* Class */ , declFlags, span, context.scriptName);
        var constructorDecl = new TypeScript.PullDecl(classDecl.name.text, constructorDeclKind, declFlags | 32768 /* ClassConstructorVariable */ , span, context.scriptName);
        decl.setValueDecl(constructorDecl);
        context.getParent().addChildDecl(decl);
        context.getParent().addChildDecl(constructorDecl);
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);
        return true;
    }
    TypeScript.preCollectClassDecls = preCollectClassDecls;
    function createInferfaceDeclaration(interfaceDecl, context) {
        var declFlags = 0 /* None */ ;
        if (TypeScript.hasFlag(interfaceDecl.varFlags, 1 /* Exported */ )) {
            declFlags |= 1 /* Exported */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = interfaceDecl.minChar;
        span.limChar = interfaceDecl.limChar;
        var decl = new TypeScript.PullDecl(interfaceDecl.name.text, 32 /* Interface */ , declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);
        return true;
    }
    TypeScript.createInferfaceDeclaration = createInferfaceDeclaration;
    function createObjectTypeDeclaration(interfaceDecl, context) {
        var declFlags = 0 /* None */ ;
        if (TypeScript.hasFlag(interfaceDecl.varFlags, 1 /* Exported */ )) {
            declFlags |= 1 /* Exported */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = interfaceDecl.minChar;
        span.limChar = interfaceDecl.limChar;
        var decl = new TypeScript.PullDecl("", 16777216 /* ObjectType */ , declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);
        return true;
    }
    TypeScript.createObjectTypeDeclaration = createObjectTypeDeclaration;
    function preCollectInterfaceDecls(ast, parent, context) {
        var interfaceDecl = ast;
        var declFlags = 0 /* None */ ;
        if (TypeScript.hasFlag(interfaceDecl.varFlags, 1 /* Exported */ )) {
            declFlags |= 1 /* Exported */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = interfaceDecl.minChar;
        span.limChar = interfaceDecl.limChar;
        var decl = new TypeScript.PullDecl(interfaceDecl.name.text, 32 /* Interface */ , declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);
        return true;
    }
    TypeScript.preCollectInterfaceDecls = preCollectInterfaceDecls;
    function preCollectParameterDecl(ast, parent, context) {
        var argDecl = ast;
        var declFlags = 0 /* None */ ;
        if (TypeScript.hasFlag(argDecl.varFlags, 2 /* Private */ )) {
            declFlags |= 2 /* Private */ ;
        }
        if (TypeScript.hasFlag(argDecl.flags, 1024 /* OptionalName */ )) {
            declFlags |= 256 /* Optional */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = argDecl.minChar;
        span.limChar = argDecl.limChar;
        var decl = new TypeScript.PullDecl(argDecl.id.text, 4096 /* Parameter */ , declFlags, span, context.scriptName);
        context.getParent().addChildDecl(decl);
        if (TypeScript.hasFlag(argDecl.varFlags, 512 /* Property */ )) {
            var propDecl = new TypeScript.PullDecl(argDecl.id.text, 8192 /* Property */ , declFlags, span, context.scriptName);
            context.parentChain[context.parentChain.length - 2].addChildDecl(propDecl);
            context.semanticInfo.setASTForDecl(propDecl, ast);
            context.semanticInfo.setDeclForAST(ast, propDecl);
        } else {
            context.semanticInfo.setASTForDecl(decl, ast);
            context.semanticInfo.setDeclForAST(ast, decl);
        }
        if (argDecl.typeExpr && ((argDecl.typeExpr).term.nodeType == 97 /* InterfaceDeclaration */  || (argDecl.typeExpr).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((argDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return false;
    }
    TypeScript.preCollectParameterDecl = preCollectParameterDecl;
    function preCollectTypeParameterDecl(ast, parent, context) {
        var typeParameterDecl = ast;
        var declFlags = 0 /* None */ ;
        var span = new TypeScript.DeclSpan();
        span.minChar = typeParameterDecl.minChar;
        span.limChar = typeParameterDecl.limChar;
        var decl = new TypeScript.PullDecl(typeParameterDecl.name.actualText, 16384 /* TypeParameter */ , declFlags, span, context.scriptName);
        context.semanticInfo.setASTForDecl(decl, ast);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.getParent().addChildDecl(decl);
        if (typeParameterDecl.constraint && ((typeParameterDecl.constraint).term.nodeType == 97 /* InterfaceDeclaration */  || (typeParameterDecl.constraint).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((typeParameterDecl.constraint).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.preCollectTypeParameterDecl = preCollectTypeParameterDecl;
    function createPropertySignature(propertyDecl, context) {
        var declFlags = 4 /* Public */ ;
        var declType = 8192 /* Property */ ;
        if (TypeScript.hasFlag(propertyDecl.id.flags, 1024 /* OptionalName */ )) {
            declFlags |= 256 /* Optional */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = propertyDecl.minChar;
        span.limChar = propertyDecl.limChar;
        var decl = new TypeScript.PullDecl(propertyDecl.id.text, declType, declFlags, span, context.scriptName);
        context.getParent().addChildDecl(decl);
        context.semanticInfo.setDeclForAST(propertyDecl, decl);
        context.semanticInfo.setASTForDecl(decl, propertyDecl);
        if (propertyDecl.typeExpr && ((propertyDecl.typeExpr).term.nodeType == 97 /* InterfaceDeclaration */  || (propertyDecl.typeExpr).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((propertyDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return false;
    }
    TypeScript.createPropertySignature = createPropertySignature;
    function createMemberVariableDeclaration(memberDecl, context) {
        var declFlags = 4 /* Public */ ;
        var declType = 8192 /* Property */ ;
        if (TypeScript.hasFlag(memberDecl.varFlags, 2 /* Private */ )) {
            declFlags = 2 /* Private */ ;
        }
        if (TypeScript.hasFlag(memberDecl.varFlags, 16 /* Static */ )) {
            declFlags |= 16 /* Static */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = memberDecl.minChar;
        span.limChar = memberDecl.limChar;
        var decl = new TypeScript.PullDecl(memberDecl.id.text, declType, declFlags, span, context.scriptName);
        context.getParent().addChildDecl(decl);
        context.semanticInfo.setDeclForAST(memberDecl, decl);
        context.semanticInfo.setASTForDecl(decl, memberDecl);
        if (memberDecl.typeExpr && ((memberDecl.typeExpr).term.nodeType == 97 /* InterfaceDeclaration */  || (memberDecl.typeExpr).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((memberDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return false;
    }
    TypeScript.createMemberVariableDeclaration = createMemberVariableDeclaration;
    function createVariableDeclaration(varDecl, context) {
        var declFlags = 0 /* None */ ;
        var declType = 2048 /* Variable */ ;
        if (TypeScript.hasFlag(varDecl.varFlags, 8 /* Ambient */ )) {
            declFlags |= 8 /* Ambient */ ;
        }
        if (TypeScript.hasFlag(varDecl.varFlags, 1 /* Exported */ )) {
            declFlags |= 1 /* Exported */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = varDecl.minChar;
        span.limChar = varDecl.limChar;
        var decl = new TypeScript.PullDecl(varDecl.id.text, declType, declFlags, span, context.scriptName);
        context.getParent().addChildDecl(decl);
        context.semanticInfo.setDeclForAST(varDecl, decl);
        context.semanticInfo.setASTForDecl(decl, varDecl);
        if (varDecl.typeExpr && ((varDecl.typeExpr).term.nodeType == 97 /* InterfaceDeclaration */  || (varDecl.typeExpr).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((varDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return false;
    }
    TypeScript.createVariableDeclaration = createVariableDeclaration;
    function preCollectVarDecls(ast, parent, context) {
        var varDecl = ast;
        var declFlags = 0 /* None */ ;
        var declType = 2048 /* Variable */ ;
        var isProperty = false;
        var isStatic = false;
        if (TypeScript.hasFlag(varDecl.varFlags, 4096 /* ClassProperty */ )) {
            return createMemberVariableDeclaration(varDecl, context);
        } else if (TypeScript.hasFlag(varDecl.varFlags, 512 /* Property */ )) {
            return createPropertySignature(varDecl, context);
        }
        return createVariableDeclaration(varDecl, context);
    }
    TypeScript.preCollectVarDecls = preCollectVarDecls;
    function createFunctionTypeDeclaration(functionTypeDeclAST, context) {
        var declFlags = 0 /* None */ ;
        var declType = 33554432 /* FunctionType */ ;
        var span = new TypeScript.DeclSpan();
        span.minChar = functionTypeDeclAST.minChar;
        span.limChar = functionTypeDeclAST.limChar;
        var decl = new TypeScript.PullDecl("", declType, declFlags, span, context.semanticInfo.getPath());
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(functionTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionTypeDeclAST);
        if (functionTypeDeclAST.returnTypeAnnotation && ((functionTypeDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (functionTypeDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((functionTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createFunctionTypeDeclaration = createFunctionTypeDeclaration;
    function createConstructorTypeDeclaration(constructorTypeDeclAST, context) {
        var declFlags = 0 /* None */ ;
        var declType = 67108864 /* ConstructorType */ ;
        var span = new TypeScript.DeclSpan();
        span.minChar = constructorTypeDeclAST.minChar;
        span.limChar = constructorTypeDeclAST.limChar;
        var decl = new TypeScript.PullDecl("{new}", declType, declFlags, span, context.semanticInfo.getPath());
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(constructorTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorTypeDeclAST);
        if (constructorTypeDeclAST.returnTypeAnnotation && ((constructorTypeDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (constructorTypeDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((constructorTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createConstructorTypeDeclaration = createConstructorTypeDeclaration;
    function createFunctionDeclaration(funcDeclAST, context) {
        var declFlags = 0 /* None */ ;
        var declType = 32768 /* Function */ ;
        if (TypeScript.hasFlag(funcDeclAST.fncFlags, 8 /* Ambient */ )) {
            declFlags |= 8 /* Ambient */ ;
        }
        if (TypeScript.hasFlag(funcDeclAST.fncFlags, 1 /* Exported */ )) {
            declFlags |= 1 /* Exported */ ;
        }
        if (!funcDeclAST.bod) {
            declFlags |= 4096 /* Signature */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = funcDeclAST.minChar;
        span.limChar = funcDeclAST.limChar;
        var decl = new TypeScript.PullDecl(funcDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(funcDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, funcDeclAST);
        if (funcDeclAST.returnTypeAnnotation && ((funcDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (funcDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((funcDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createFunctionDeclaration = createFunctionDeclaration;
    function createFunctionExpressionDeclaration(functionExpressionDeclAST, context) {
        var declFlags = 0 /* None */ ;
        var declType = 262144 /* FunctionExpression */ ;
        if (TypeScript.hasFlag(functionExpressionDeclAST.fncFlags, 32768 /* IsFatArrowFunction */ )) {
            declFlags |= 16384 /* FatArrow */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = functionExpressionDeclAST.minChar;
        span.limChar = functionExpressionDeclAST.limChar;
        var decl = new TypeScript.PullDecl("", declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(functionExpressionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionExpressionDeclAST);
        if (functionExpressionDeclAST.returnTypeAnnotation && ((functionExpressionDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (functionExpressionDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((functionExpressionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createFunctionExpressionDeclaration = createFunctionExpressionDeclaration;
    function createMemberFunctionDeclaration(memberFunctionDeclAST, context) {
        var declFlags = 0 /* None */ ;
        var declType = 131072 /* Method */ ;
        if (TypeScript.hasFlag(memberFunctionDeclAST.fncFlags, 16 /* Static */ )) {
            declFlags |= 16 /* Static */ ;
        }
        if (TypeScript.hasFlag(memberFunctionDeclAST.fncFlags, 2 /* Private */ )) {
            declFlags |= 2 /* Private */ ;
        }
        if (!memberFunctionDeclAST.bod) {
            declFlags |= 4096 /* Signature */ ;
        }
        if (TypeScript.hasFlag(memberFunctionDeclAST.name.flags, 1024 /* OptionalName */ )) {
            declFlags |= 256 /* Optional */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = memberFunctionDeclAST.minChar;
        span.limChar = memberFunctionDeclAST.limChar;
        var decl = new TypeScript.PullDecl(memberFunctionDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(memberFunctionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, memberFunctionDeclAST);
        if (memberFunctionDeclAST.returnTypeAnnotation && ((memberFunctionDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (memberFunctionDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((memberFunctionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createMemberFunctionDeclaration = createMemberFunctionDeclaration;
    function createIndexSignatureDeclaration(indexSignatureDeclAST, context) {
        var declFlags = 4096 /* Signature */  | 2048 /* Index */ ;
        var declType = 8388608 /* IndexSignature */ ;
        var span = new TypeScript.DeclSpan();
        span.minChar = indexSignatureDeclAST.minChar;
        span.limChar = indexSignatureDeclAST.limChar;
        var decl = new TypeScript.PullDecl("[]", declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(indexSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, indexSignatureDeclAST);
        if (indexSignatureDeclAST.returnTypeAnnotation && ((indexSignatureDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (indexSignatureDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((indexSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createIndexSignatureDeclaration = createIndexSignatureDeclaration;
    function createCallSignatureDeclaration(callSignatureDeclAST, context) {
        var declFlags = 4096 /* Signature */  | 512 /* Call */ ;
        var declType = 2097152 /* CallSignature */ ;
        var span = new TypeScript.DeclSpan();
        span.minChar = callSignatureDeclAST.minChar;
        span.limChar = callSignatureDeclAST.limChar;
        var decl = new TypeScript.PullDecl("()", declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(callSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, callSignatureDeclAST);
        if (callSignatureDeclAST.returnTypeAnnotation && ((callSignatureDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (callSignatureDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((callSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createCallSignatureDeclaration = createCallSignatureDeclaration;
    function createConstructSignatureDeclaration(constructSignatureDeclAST, context) {
        var declFlags = 4096 /* Signature */  | 512 /* Call */ ;
        var declType = 4194304 /* ConstructSignature */ ;
        var span = new TypeScript.DeclSpan();
        span.minChar = constructSignatureDeclAST.minChar;
        span.limChar = constructSignatureDeclAST.limChar;
        var decl = new TypeScript.PullDecl("new", declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(constructSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructSignatureDeclAST);
        if (constructSignatureDeclAST.returnTypeAnnotation && ((constructSignatureDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (constructSignatureDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((constructSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createConstructSignatureDeclaration = createConstructSignatureDeclaration;
    function createClassConstructorDeclaration(constructorDeclAST, context) {
        var declFlags = 1024 /* Constructor */ ;
        var declType = 65536 /* ConstructorMethod */ ;
        if (!constructorDeclAST.bod) {
            declFlags |= 4096 /* Signature */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = constructorDeclAST.minChar;
        span.limChar = constructorDeclAST.limChar;
        var decl = new TypeScript.PullDecl(constructorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(constructorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorDeclAST);
        if (constructorDeclAST.returnTypeAnnotation && ((constructorDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (constructorDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((constructorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createClassConstructorDeclaration = createClassConstructorDeclaration;
    function createGetAccessorDeclaration(getAccessorDeclAST, context) {
        var declFlags = 4 /* Public */ ;
        var declType = 524288 /* GetAccessor */ ;
        if (TypeScript.hasFlag(getAccessorDeclAST.fncFlags, 16 /* Static */ )) {
            declFlags |= 16 /* Static */ ;
        }
        if (TypeScript.hasFlag(getAccessorDeclAST.name.flags, 1024 /* OptionalName */ )) {
            declFlags |= 256 /* Optional */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = getAccessorDeclAST.minChar;
        span.limChar = getAccessorDeclAST.limChar;
        var decl = new TypeScript.PullDecl(getAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(getAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, getAccessorDeclAST);
        if (getAccessorDeclAST.returnTypeAnnotation && ((getAccessorDeclAST.returnTypeAnnotation).term.nodeType == 97 /* InterfaceDeclaration */  || (getAccessorDeclAST.returnTypeAnnotation).term.nodeType == 73 /* FuncDecl */ )) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);
            declCollectionContext.scriptName = context.scriptName;
            TypeScript.getAstWalkerFactory().walk((getAccessorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
        return true;
    }
    TypeScript.createGetAccessorDeclaration = createGetAccessorDeclaration;
    function createSetAccessorDeclaration(setAccessorDeclAST, context) {
        var declFlags = 4 /* Public */ ;
        var declType = 1048576 /* SetAccessor */ ;
        if (TypeScript.hasFlag(setAccessorDeclAST.fncFlags, 16 /* Static */ )) {
            declFlags |= 16 /* Static */ ;
        }
        if (TypeScript.hasFlag(setAccessorDeclAST.name.flags, 1024 /* OptionalName */ )) {
            declFlags |= 256 /* Optional */ ;
        }
        var span = new TypeScript.DeclSpan();
        span.minChar = setAccessorDeclAST.minChar;
        span.limChar = setAccessorDeclAST.limChar;
        var decl = new TypeScript.PullDecl(setAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        var parent = context.getParent();
        if (parent) {
            parent.addChildDecl(decl);
        }
        context.pushParent(decl);
        context.semanticInfo.setDeclForAST(setAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, setAccessorDeclAST);
        return true;
    }
    TypeScript.createSetAccessorDeclaration = createSetAccessorDeclaration;
    function preCollectFuncDecls(ast, parent, context) {
        var funcDecl = ast;
        if (TypeScript.hasFlag(funcDecl.fncFlags, (131072 /* IsFunctionExpression */  | 32768 /* IsFatArrowFunction */ ))) {
            return createFunctionExpressionDeclaration(funcDecl, context);
        } else if (funcDecl.isConstructor) {
            return createClassConstructorDeclaration(funcDecl, context);
        } else if (funcDecl.isGetAccessor()) {
            return createGetAccessorDeclaration(funcDecl, context);
        } else if (funcDecl.isSetAccessor()) {
            return createSetAccessorDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.fncFlags, 8192 /* ConstructMember */ )) {
            return TypeScript.hasFlag(funcDecl.flags, 4096 /* TypeReference */ ) ? createConstructorTypeDeclaration(funcDecl, context) : createConstructSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.fncFlags, 4096 /* CallMember */ )) {
            return createCallSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.fncFlags, 65536 /* IndexerMember */ )) {
            return createIndexSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.flags, 4096 /* TypeReference */ )) {
            return createFunctionTypeDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.fncFlags, 1024 /* Method */ ) || TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) {
            return createMemberFunctionDeclaration(funcDecl, context);
        }
        return createFunctionDeclaration(funcDecl, context);
    }
    TypeScript.preCollectFuncDecls = preCollectFuncDecls;
    function preCollectDecls(ast, parent, walker) {
        var context = walker.state;
        var go = false;
        if (ast.nodeType == 95 /* Script */ ) {
            var script = ast;
            var span = new TypeScript.DeclSpan();
            span.minChar = script.minChar;
            span.limChar = script.limChar;
            var decl = new TypeScript.PullDecl(context.scriptName, 1 /* Script */ , 0 /* None */ , span, context.scriptName);
            context.pushParent(decl);
            go = true;
        } else if (ast.nodeType == 94 /* List */ ) {
            go = true;
        } else if (ast.nodeType == 86 /* Block */ ) {
            go = true;
        } else if (ast.nodeType == 98 /* ModuleDeclaration */ ) {
            go = preCollectModuleDecls(ast, parent, context);
        } else if (ast.nodeType == 96 /* ClassDeclaration */ ) {
            go = preCollectClassDecls(ast, parent, context);
        } else if (ast.nodeType == 97 /* InterfaceDeclaration */ ) {
            go = preCollectInterfaceDecls(ast, parent, context);
        } else if (ast.nodeType == 76 /* ArgDecl */ ) {
            go = preCollectParameterDecl(ast, parent, context);
        } else if (ast.nodeType == 75 /* VarDecl */ ) {
            go = preCollectVarDecls(ast, parent, context);
        } else if (ast.nodeType == 73 /* FuncDecl */ ) {
            go = preCollectFuncDecls(ast, parent, context);
        } else if (ast.nodeType == 99 /* ImportDeclaration */ ) {
            go = preCollectImportDecls(ast, parent, context);
        } else if (ast.nodeType == 26 /* TypeParameter */ ) {
            go = preCollectTypeParameterDecl(ast, parent, context);
        } else if (ast.nodeType == 83 /* If */ ) {
            go = true;
        } else if (ast.nodeType == 81 /* For */ ) {
            go = true;
        } else if (ast.nodeType == 82 /* ForIn */ ) {
            go = true;
        } else if (ast.nodeType == 84 /* While */ ) {
            go = true;
        } else if (ast.nodeType == 85 /* DoWhile */ ) {
            go = true;
        } else if (ast.nodeType == 13 /* Comma */ ) {
            go = true;
        } else if (ast.nodeType == 77 /* Return */ ) {
            go = true;
        } else if (ast.nodeType == 88 /* Switch */  || ast.nodeType == 87 /* Case */ ) {
            go = true;
        } else if (ast.nodeType == 30 /* Call */ ) {
            go = true;
        } else if (ast.nodeType == 31 /* New */ ) {
            go = true;
        }
        walker.options.goChildren = go;
        return ast;
    }
    TypeScript.preCollectDecls = preCollectDecls;
    function postCollectDecls(ast, parent, walker) {
        var context = walker.state;
        var parentDecl;
        if (ast.nodeType == 98 /* ModuleDeclaration */ ) {
            var thisModule = context.getParent();
            context.popParent();
            parentDecl = context.getParent();
            if (thisModule.getFlags() & 65536 /* InitializedModule */ ) {
                if (parentDecl && parentDecl.getKind() == 8 /* Container */ ) {
                    parentDecl.setFlags(parentDecl.getFlags() | 65536 /* InitializedModule */ );
                }
                var valueDecl = new TypeScript.PullDecl(thisModule.getName(), 2048 /* Variable */ , thisModule.getFlags(), thisModule.getSpan(), context.scriptName);
                thisModule.setValueDecl(valueDecl);
                context.semanticInfo.setASTForDecl(valueDecl, ast);
                if (parentDecl) {
                    parentDecl.addChildDecl(valueDecl);
                }
            }
        } else if (ast.nodeType == 96 /* ClassDeclaration */ ) {
            context.popParent();
            parentDecl = context.getParent();
            if (parentDecl && parentDecl.getKind() == 8 /* Container */ ) {
                parentDecl.setFlags(parentDecl.getFlags() | 65536 /* InitializedModule */ );
            }
        } else if (ast.nodeType == 97 /* InterfaceDeclaration */ ) {
            context.popParent();
        } else if (ast.nodeType == 73 /* FuncDecl */ ) {
            context.popParent();
            parentDecl = context.getParent();
            if (parentDecl && parentDecl.getKind() == 8 /* Container */ ) {
                parentDecl.setFlags(parentDecl.getFlags() | 65536 /* InitializedModule */ );
            }
        } else if (ast.nodeType == 75 /* VarDecl */ ) {
            parentDecl = context.getParent();
            if (parentDecl && parentDecl.getKind() == 8 /* Container */ ) {
                parentDecl.setFlags(parentDecl.getFlags() | 65536 /* InitializedModule */ );
            }
        }
        return ast;
    }
    TypeScript.postCollectDecls = postCollectDecls;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullSymbolBinder = (function () {
        function PullSymbolBinder(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
            this.parentChain = [];
            this.declPath = [];
            this.staticClassMembers = [];
            this.reBindingAfterChange = false;
            this.startingDeclForRebind = TypeScript.pullDeclID;
            this.startingSymbolForRebind = TypeScript.pullSymbolID;
        }
        PullSymbolBinder.prototype.setUnit = function (fileName) {
            this.semanticInfo = this.semanticInfoChain.getUnit(fileName);
        };
        PullSymbolBinder.prototype.getParent = function (returnInstanceType) {
            if (typeof returnInstanceType === "undefined") { returnInstanceType = false; }
            var parent = this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;
            if (parent && parent.isContainer() && returnInstanceType) {
                var instanceSymbol = (parent).getInstanceSymbol();
                if (instanceSymbol) {
                    parent = instanceSymbol.getType();
                }
            }
            return parent;
        };
        PullSymbolBinder.prototype.getDeclPath = function () {
            return this.declPath;
        };
        PullSymbolBinder.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.getName();
            }
        };
        PullSymbolBinder.prototype.popParent = function () {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        };
        PullSymbolBinder.prototype.findSymbolInContext = function (name, declKind, typeLookupPath) {
            var startTime = new Date().getTime();
            var contextSymbolPath = this.getDeclPath();
            var nestedSymbolPath = [];
            var copyOfContextSymbolPath = [];
            var symbol = null;
            if (typeLookupPath.length) {
                for(var i = 0; i < typeLookupPath.length; i++) {
                    nestedSymbolPath[nestedSymbolPath.length] = typeLookupPath[i];
                }
                nestedSymbolPath[nestedSymbolPath.length] = name;
                while(nestedSymbolPath.length >= 2) {
                    symbol = this.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);
                    if (symbol) {
                        var endTime = new Date().getTime();
                        TypeScript.time_in_findSymbol += endTime - startTime;
                        return symbol;
                    }
                    nestedSymbolPath.length -= 2;
                    nestedSymbolPath[nestedSymbolPath.length] = name;
                }
            }
            if (contextSymbolPath.length) {
                for(var i = 0; i < contextSymbolPath.length; i++) {
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i];
                }
                for(var i = 0; i < typeLookupPath.length; i++) {
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = typeLookupPath[i];
                }
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
                while(copyOfContextSymbolPath.length >= 2) {
                    symbol = this.semanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);
                    if (symbol) {
                        var endTime = new Date().getTime();
                        TypeScript.time_in_findSymbol += endTime - startTime;
                        return symbol;
                    }
                    copyOfContextSymbolPath.length -= 2;
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
                }
            }
            symbol = this.semanticInfoChain.findSymbol([
                name
            ], declKind);
            var endTime = new Date().getTime();
            TypeScript.time_in_findSymbol += endTime - startTime;
            return symbol;
        };
        PullSymbolBinder.prototype.bindModuleDeclarationToPullSymbol = function (moduleContainerDecl) {
            var modName = moduleContainerDecl.getName();
            var moduleContainerTypeSymbol = null;
            var moduleInstanceSymbol = null;
            var moduleInstanceTypeSymbol = null;
            var moduleInstanceDecl = moduleContainerDecl.getValueDecl();
            var parent = this.getParent();
            var parentInstanceSymbol = this.getParent(true);
            var moduleAST = this.semanticInfo.getASTForDecl(moduleContainerDecl);
            var createdNewSymbol = false;
            if (parent) {
                moduleContainerTypeSymbol = parent.findNestedType(modName);
            } else if (!(moduleContainerDecl.getFlags() & 1 /* Exported */ )) {
                moduleContainerTypeSymbol = this.findSymbolInContext(modName, TypeScript.PullElementKind.SomeType, []);
            }
            if (moduleContainerTypeSymbol && moduleContainerTypeSymbol.getKind() != 8 /* Container */ ) {
                moduleContainerDecl.addError(new TypeScript.PullError(moduleAST.minChar, moduleAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                    modName
                ])));
                moduleContainerTypeSymbol = null;
            }
            if (moduleContainerTypeSymbol) {
                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
            } else {
                var moduleContainerTypeSymbol = new TypeScript.PullContainerTypeSymbol(modName);
                createdNewSymbol = true;
            }
            if (!moduleInstanceSymbol && (moduleContainerDecl.getFlags() & 65536 /* InitializedModule */ )) {
                moduleInstanceTypeSymbol = new TypeScript.PullTypeSymbol(modName, 16777216 /* ObjectType */ );
                moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);
                moduleInstanceSymbol = new TypeScript.PullSymbol(modName, 2048 /* Variable */ );
                moduleInstanceSymbol.setType(moduleInstanceTypeSymbol);
                moduleContainerTypeSymbol.setInstanceSymbol(moduleInstanceSymbol);
            }
            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol);
            this.semanticInfo.setSymbolForAST(moduleAST, moduleContainerTypeSymbol);
            this.semanticInfo.setSymbolForAST(moduleAST.name, moduleContainerTypeSymbol);
            if (createdNewSymbol) {
                if (parent) {
                    var linkKind = moduleContainerDecl.getFlags() & 1 /* Exported */  ? 5 /* PublicMember */  : 6 /* PrivateMember */ ;
                    if (linkKind == 5 /* PublicMember */ ) {
                        parent.addMember(moduleContainerTypeSymbol, linkKind);
                        if (moduleInstanceSymbol && parentInstanceSymbol && (parentInstanceSymbol != moduleInstanceSymbol)) {
                            parentInstanceSymbol.addMember(moduleInstanceSymbol, linkKind);
                        }
                    } else {
                        moduleContainerTypeSymbol.addOutgoingLink(parent, 9 /* ContainedBy */ );
                        if (moduleInstanceSymbol && parentInstanceSymbol && (parentInstanceSymbol != moduleInstanceSymbol)) {
                            moduleInstanceSymbol.addOutgoingLink(parentInstanceSymbol, 9 /* ContainedBy */ );
                        }
                    }
                }
            } else if (this.reBindingAfterChange) {
                var decls = moduleContainerTypeSymbol.getDeclarations();
                var scriptName = moduleContainerDecl.getScriptName();
                for(var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        moduleContainerTypeSymbol.removeDeclaration(decls[i]);
                    }
                }
                if (moduleInstanceSymbol) {
                    decls = moduleInstanceSymbol.getDeclarations();
                    for(var i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceSymbol.removeDeclaration(decls[i]);
                        }
                    }
                    moduleInstanceTypeSymbol = moduleInstanceSymbol.getType();
                    decls = moduleInstanceTypeSymbol.getDeclarations();
                    for(var i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceTypeSymbol.removeDeclaration(decls[i]);
                        }
                    }
                    moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);
                    moduleInstanceSymbol.invalidate();
                }
                moduleContainerTypeSymbol.invalidate();
            }
            this.pushParent(moduleContainerTypeSymbol);
            var childDecls = moduleContainerDecl.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
        };
        PullSymbolBinder.prototype.bindEnumDeclarationToPullSymbol = function (enumDeclaration) {
            var enumName = enumDeclaration.getName();
            var enumSymbol = this.findSymbolInContext(enumName, 128 /* Enum */ , []);
            var enumAST = this.semanticInfo.getASTForDecl(enumDeclaration);
            var createdNewSymbol = false;
            var parent = this.getParent();
            if (parent) {
                enumSymbol = parent.findNestedType(enumName);
            } else if (!(enumDeclaration.getFlags() & 1 /* Exported */ )) {
                enumSymbol = this.findSymbolInContext(enumName, TypeScript.PullElementKind.SomeType, []);
            }
            if (enumSymbol && (enumSymbol.getKind() != 128 /* Enum */  || enumSymbol.getSymbolID() > this.startingSymbolForRebind)) {
                enumDeclaration.addError(new TypeScript.PullError(enumAST.minChar, enumAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                    enumName
                ])));
                enumSymbol = null;
            }
            if (!enumSymbol) {
                enumSymbol = new TypeScript.PullTypeSymbol(enumName, 128 /* Enum */ );
                enumSymbol.addDeclaration(enumDeclaration);
                enumDeclaration.setSymbol(enumSymbol);
                createdNewSymbol = true;
            }
            enumSymbol.addDeclaration(enumDeclaration);
            enumDeclaration.setSymbol(enumSymbol);
            this.semanticInfo.setSymbolForAST(enumAST, enumSymbol);
            this.semanticInfo.setSymbolForAST(enumAST.name, enumSymbol);
            if (createdNewSymbol) {
                var parent = this.getParent();
                if (parent) {
                    var linkKind = enumDeclaration.getFlags() & 1 /* Exported */  ? 5 /* PublicMember */  : 6 /* PrivateMember */ ;
                    if (linkKind == 5 /* PublicMember */ ) {
                        parent.addMember(enumSymbol, linkKind);
                    } else {
                        enumSymbol.addOutgoingLink(parent, 9 /* ContainedBy */ );
                    }
                }
            } else if (this.reBindingAfterChange) {
                var decls = enumSymbol.getDeclarations();
                var scriptName = enumDeclaration.getScriptName();
                for(var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        enumSymbol.removeDeclaration(decls[i]);
                    }
                }
            }
            this.pushParent(enumSymbol);
            var childDecls = enumDeclaration.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
        };
        PullSymbolBinder.prototype.bindClassDeclarationToPullSymbol = function (classDecl) {
            var className = classDecl.getName();
            var classSymbol = null;
            var constructorSymbol = null;
            var constructorTypeSymbol = null;
            var classAST = this.semanticInfo.getASTForDecl(classDecl);
            var parentHadSymbol = false;
            var parent = this.getParent();
            var cleanedPreviousDecls = false;
            if (parent) {
                classSymbol = parent.findNestedType(className);
            } else if (!(classDecl.getFlags() & 1 /* Exported */ )) {
                classSymbol = this.findSymbolInContext(className, TypeScript.PullElementKind.SomeType, []);
            }
            if (classSymbol && (classSymbol.getKind() != 16 /* Class */  || (!this.reBindingAfterChange || classSymbol.getSymbolID() > this.startingSymbolForRebind))) {
                classDecl.addError(new TypeScript.PullError(classAST.minChar, classAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                    className
                ])));
                classSymbol = null;
            } else if (classSymbol) {
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && classSymbol) {
                var decls = classSymbol.getDeclarations();
                var scriptName = classDecl.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        classSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                constructorSymbol = classSymbol.getConstructorMethod();
                decls = constructorSymbol.getDeclarations();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        constructorSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                if (constructorSymbol.getIsSynthesized()) {
                    constructorSymbol.addDeclaration(classDecl);
                }
                if (classSymbol.isGeneric()) {
                    var specializations = classSymbol.getKnownSpecializations();
                    var specialization = null;
                    for(var i = 0; i < specializations.length; i++) {
                        specialization = specializations[i];
                        decls = specialization.getDeclarations();
                        for(var j = 0; j < decls.length; j++) {
                            if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                specialization.removeDeclaration(decls[j]);
                                cleanedPreviousDecls = true;
                            }
                        }
                        specialization.addDeclaration(classDecl);
                    }
                }
            }
            if (!parentHadSymbol) {
                classSymbol = new TypeScript.PullClassTypeSymbol(className);
            }
            classSymbol.addDeclaration(classDecl);
            classDecl.setSymbol(classSymbol);
            this.semanticInfo.setSymbolForAST(classAST, classSymbol);
            this.semanticInfo.setSymbolForAST(classAST.name, classSymbol);
            if (parent && !parentHadSymbol) {
                var linkKind = classDecl.getFlags() & 1 /* Exported */  ? 5 /* PublicMember */  : 6 /* PrivateMember */ ;
                if (linkKind == 5 /* PublicMember */ ) {
                    parent.addMember(classSymbol, linkKind);
                } else {
                    classSymbol.addOutgoingLink(parent, 9 /* ContainedBy */ );
                }
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = classSymbol.getCallSignatures();
                var constructSigs = classSymbol.getConstructSignatures();
                var indexSigs = classSymbol.getIndexSignatures();
                for(var i = 0; i < callSigs.length; i++) {
                    classSymbol.removeCallSignature(callSigs[i], false);
                }
                for(var i = 0; i < constructSigs.length; i++) {
                    classSymbol.removeConstructSignature(constructSigs[i], false);
                }
                for(var i = 0; i < indexSigs.length; i++) {
                    classSymbol.removeIndexSignature(indexSigs[i], false);
                }
                constructorSymbol = classSymbol.getConstructorMethod();
                constructorTypeSymbol = (constructorSymbol ? constructorSymbol.getType() : null);
                if (constructorTypeSymbol) {
                    constructSigs = constructorTypeSymbol.getConstructSignatures();
                    for(var i = 0; i < constructSigs.length; i++) {
                        constructorTypeSymbol.removeConstructSignature(constructSigs[i], false);
                    }
                }
                classSymbol.invalidate();
            }
            this.pushParent(classSymbol);
            var childDecls = classDecl.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = (constructorSymbol ? constructorSymbol.getType() : null);
            if (!constructorSymbol) {
                constructorSymbol = new TypeScript.PullSymbol(className, 65536 /* ConstructorMethod */ );
                constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();
                constructorSymbol.setIsSynthesized();
                constructorSymbol.setType(constructorTypeSymbol);
                constructorSymbol.addDeclaration(classDecl);
                classSymbol.setConstructorMethod(constructorSymbol);
                constructorTypeSymbol.addDeclaration(classDecl);
                this.semanticInfo.setASTForDecl(classDecl, classAST);
                var constructorSignature = new TypeScript.PullSignatureSymbol(4194304 /* ConstructSignature */ );
                constructorSignature.setReturnType(classSymbol);
                constructorTypeSymbol.addSignature(constructorSignature);
                constructorSignature.addDeclaration(classDecl);
            }
            if (this.staticClassMembers.length) {
                var member;
                var isPrivate = false;
                var decls;
                for(var i = 0; i < this.staticClassMembers.length; i++) {
                    member = this.staticClassMembers[i];
                    decls = member.getDeclarations();
                    isPrivate = (decls[0].getFlags() & 2 /* Private */ ) != 0;
                    constructorTypeSymbol.addMember(member, isPrivate ? 6 /* PrivateMember */  : 5 /* PublicMember */ );
                }
                this.staticClassMembers.length = 0;
            }
            var typeParameters = classDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = classSymbol.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    classSymbol.addMember(typeParameter, 17 /* TypeParameter */ );
                    constructorTypeSymbol.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };
        PullSymbolBinder.prototype.bindInterfaceDeclarationToPullSymbol = function (interfaceDecl) {
            var interfaceName = interfaceDecl.getName();
            var interfaceSymbol = this.findSymbolInContext(interfaceName, TypeScript.PullElementKind.SomeType, []);
            var interfaceAST = this.semanticInfo.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent();
            if (parent) {
                interfaceSymbol = parent.findNestedType(interfaceName);
            } else if (!(interfaceDecl.getFlags() & 1 /* Exported */ )) {
                interfaceSymbol = this.findSymbolInContext(interfaceName, TypeScript.PullElementKind.SomeType, []);
            }
            if (interfaceSymbol && (interfaceSymbol.getKind() != 32 /* Interface */ )) {
                interfaceDecl.addError(new TypeScript.PullError(interfaceAST.minChar, interfaceAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                    interfaceName
                ])));
                interfaceSymbol = null;
            }
            if (!interfaceSymbol) {
                interfaceSymbol = new TypeScript.PullTypeSymbol(interfaceName, 32 /* Interface */ );
                createdNewSymbol = true;
            }
            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol);
            this.semanticInfo.setSymbolForAST(interfaceAST, interfaceSymbol);
            this.semanticInfo.setSymbolForAST(interfaceAST.name, interfaceSymbol);
            if (createdNewSymbol) {
                if (parent) {
                    var linkKind = interfaceDecl.getFlags() & 1 /* Exported */  ? 5 /* PublicMember */  : 6 /* PrivateMember */ ;
                    if (linkKind == 5 /* PublicMember */ ) {
                        parent.addMember(interfaceSymbol, linkKind);
                    } else {
                        interfaceSymbol.addOutgoingLink(parent, 9 /* ContainedBy */ );
                    }
                }
            } else if (this.reBindingAfterChange) {
                var decls = interfaceSymbol.getDeclarations();
                var scriptName = interfaceDecl.getScriptName();
                for(var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        interfaceSymbol.removeDeclaration(decls[i]);
                    }
                }
                if (interfaceSymbol.isGeneric()) {
                    var specializations = interfaceSymbol.getKnownSpecializations();
                    var specialization = null;
                    for(var i = 0; i < specializations.length; i++) {
                        specialization = specializations[i];
                        decls = specialization.getDeclarations();
                        for(var j = 0; j < decls.length; j++) {
                            if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                specialization.removeDeclaration(decls[j]);
                            }
                        }
                        specialization.addDeclaration(interfaceDecl);
                    }
                }
            }
            this.pushParent(interfaceSymbol);
            var childDecls = interfaceDecl.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    interfaceSymbol.addMember(typeParameter, 17 /* TypeParameter */ );
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };
        PullSymbolBinder.prototype.bindObjectTypeDeclarationToPullSymbol = function (objectDecl) {
            var objectSymbolAST = this.semanticInfo.getASTForDecl(objectDecl);
            var objectSymbol = new TypeScript.PullTypeSymbol("{}", 16777216 /* ObjectType */ );
            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol);
            this.semanticInfo.setSymbolForAST(objectSymbolAST, objectSymbol);
            this.pushParent(objectSymbol);
            var childDecls = objectDecl.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
            var typeParameters = objectDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = objectSymbol.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    objectSymbol.addMember(typeParameter, 17 /* TypeParameter */ );
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };
        PullSymbolBinder.prototype.bindConstructorTypeDeclarationToPullSymbol = function (constructorTypeDeclaration) {
            var declKind = constructorTypeDeclaration.getKind();
            var declFlags = constructorTypeDeclaration.getFlags();
            var constructorTypeAST = this.semanticInfo.getASTForDecl(constructorTypeDeclaration);
            var constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();
            constructorTypeDeclaration.setSymbol(constructorTypeSymbol);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfo.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);
            var signature = new TypeScript.PullDefinitionSignatureSymbol(4194304 /* ConstructSignature */ );
            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructorTypeDeclaration), signature);
            constructorTypeSymbol.addSignature(signature);
            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    constructorTypeSymbol.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };
        PullSymbolBinder.prototype.bindVariableDeclarationToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.getFlags();
            var declKind = variableDeclaration.getKind();
            var varDeclAST = this.semanticInfo.getASTForDecl(variableDeclaration);
            var isExported = false;
            var linkKind = 6 /* PrivateMember */ ;
            var variableSymbol = null;
            var declName = variableDeclaration.getName();
            var parentHadSymbol = false;
            var parent = this.getParent(true);
            if (parent) {
                variableSymbol = parent.findMember(declName);
            } else if (!(variableDeclaration.getFlags() & 1 /* Exported */ )) {
                variableSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeValue, []);
            }
            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }
            if (variableSymbol && (variableSymbol.getSymbolID() > this.startingSymbolForRebind)) {
                if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) == 0) {
                    var span = variableDeclaration.getSpan();
                    variableDeclaration.addError(new TypeScript.PullError(span.minChar, span.limChar - span.minChar, this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                        declName
                    ])));
                    variableSymbol = null;
                    parentHadSymbol = false;
                }
            } else if (variableSymbol && (variableSymbol.getKind() != 2048 /* Variable */ )) {
                var span = variableDeclaration.getSpan();
                variableDeclaration.addError(new TypeScript.PullError(span.minChar, span.limChar - span.minChar, this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                    declName
                ])));
                variableSymbol = null;
                parentHadSymbol = false;
            }
            if (this.reBindingAfterChange && variableSymbol && !variableSymbol.isType()) {
                var decls = variableSymbol.getDeclarations();
                var scriptName = variableDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        variableSymbol.removeDeclaration(decls[j]);
                    }
                }
            }
            if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) == 0) {
                if (!variableSymbol) {
                    variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                }
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
                this.semanticInfo.setSymbolForAST(varDeclAST, variableSymbol);
                this.semanticInfo.setSymbolForAST(varDeclAST.id, variableSymbol);
            } else if (!parentHadSymbol) {
                if ((declFlags & 32768 /* ClassConstructorVariable */ )) {
                    var classTypeSymbol = variableSymbol;
                    if (parent) {
                        var members = parent.getMembers();
                        for(var i = 0; i < members.length; i++) {
                            if ((members[i].getName() == declName) && (members[i].getKind() == 16 /* Class */ )) {
                                classTypeSymbol = members[i];
                                break;
                            }
                        }
                    }
                    if (!classTypeSymbol) {
                        classTypeSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeType, []);
                        if (classTypeSymbol && (classTypeSymbol.getKind() != 16 /* Class */ )) {
                            classTypeSymbol = null;
                        }
                    }
                    if (classTypeSymbol) {
                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol);
                        var decls = classTypeSymbol.getDeclarations();
                        if (decls.length) {
                            var decl = decls[decls.length - 1];
                            var ast = this.semanticInfo.getASTForDecl(decl);
                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    } else {
                        if (!variableSymbol) {
                            variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                        }
                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);
                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                } else if ((declFlags & 65536 /* InitializedModule */ )) {
                    var moduleContainerTypeSymbol = null;
                    var moduleParent = this.getParent(false);
                    if (moduleParent) {
                        var members = moduleParent.getMembers();
                        for(var i = 0; i < members.length; i++) {
                            if ((members[i].getName() == declName) && (members[i].getKind() == 8 /* Container */ )) {
                                moduleContainerTypeSymbol = members[i];
                                break;
                            }
                        }
                    }
                    if (!moduleContainerTypeSymbol) {
                        moduleContainerTypeSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeType, []);
                        if (moduleContainerTypeSymbol && (moduleContainerTypeSymbol.getKind() != 8 /* Container */ )) {
                            moduleContainerTypeSymbol = null;
                        }
                    }
                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);
                        var decls = moduleContainerTypeSymbol.getDeclarations();
                        if (decls.length) {
                            var decl = decls[decls.length - 1];
                            var ast = this.semanticInfo.getASTForDecl(decl);
                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                        parentHadSymbol = true;
                    } else {
                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                }
            } else {
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
            }
            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */ ) {
                    parent.addMember(variableSymbol, 5 /* PublicMember */ );
                } else {
                    variableSymbol.addOutgoingLink(parent, 9 /* ContainedBy */ );
                }
            }
        };
        PullSymbolBinder.prototype.bindPropertyDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.getFlags();
            var declKind = propertyDeclaration.getKind();
            var propDeclAST = this.semanticInfo.getASTForDecl(propertyDeclaration);
            var isStatic = false;
            var isOptional = false;
            var linkKind = 5 /* PublicMember */ ;
            var propertySymbol = null;
            if (TypeScript.hasFlag(declFlags, 16 /* Static */ )) {
                isStatic = true;
            }
            if (TypeScript.hasFlag(declFlags, 2 /* Private */ )) {
                linkKind = 6 /* PrivateMember */ ;
            }
            if (TypeScript.hasFlag(declFlags, 256 /* Optional */ )) {
                isOptional = true;
            }
            var declName = propertyDeclaration.getName();
            var parentHadSymbol = false;
            var parent = this.getParent(true);
            propertySymbol = parent.findMember(declName);
            if (propertySymbol && (!this.reBindingAfterChange || (propertySymbol.getSymbolID() > this.startingSymbolForRebind))) {
                var span = propertyDeclaration.getSpan();
                propertyDeclaration.addError(new TypeScript.PullError(span.minChar, span.limChar - span.minChar, this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                    declName
                ])));
                propertySymbol = null;
            }
            if (propertySymbol) {
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && propertySymbol) {
                var decls = propertySymbol.getDeclarations();
                var scriptName = propertyDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        propertySymbol.removeDeclaration(decls[j]);
                    }
                }
                propertySymbol.invalidate();
            }
            if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) == 0) {
                if (!parentHadSymbol) {
                    propertySymbol = new TypeScript.PullSymbol(declName, declKind);
                }
                propertySymbol.addDeclaration(propertyDeclaration);
                propertyDeclaration.setSymbol(propertySymbol);
                this.semanticInfo.setSymbolForAST(propDeclAST, propertySymbol);
                this.semanticInfo.setSymbolForAST(propDeclAST.id, propertySymbol);
            } else {
                var classTypeSymbol = null;
                if (parent) {
                    var members = parent.getMembers();
                    for(var i = 0; i < members.length; i++) {
                        if ((members[i].getName() == declName) && (members[i].getKind() == 16 /* Class */ )) {
                            classTypeSymbol = members[i];
                            break;
                        }
                    }
                }
                if (!classTypeSymbol) {
                    classTypeSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeType, []);
                    if (classTypeSymbol && (classTypeSymbol.getKind() != 16 /* Class */ )) {
                        classTypeSymbol = null;
                    }
                }
                if (classTypeSymbol) {
                    propertySymbol = classTypeSymbol.getConstructorMethod();
                    propertyDeclaration.setSymbol(propertySymbol);
                } else {
                    propertySymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                }
                propertySymbol.setResolved();
            }
            if (isOptional) {
                propertySymbol.setIsOptional();
            }
            if (parent && !parentHadSymbol) {
                if (parent.isClass()) {
                    var classTypeSymbol = parent;
                    if (isStatic) {
                        this.staticClassMembers[this.staticClassMembers.length] = propertySymbol;
                    } else {
                        classTypeSymbol.addMember(propertySymbol, linkKind);
                    }
                } else {
                    parent.addMember(propertySymbol, linkKind);
                }
            }
        };
        PullSymbolBinder.prototype.bindImportDeclaration = function (importDeclaration) {
            var declFlags = importDeclaration.getFlags();
            var declKind = importDeclaration.getKind();
            var importDeclAST = this.semanticInfo.getASTForDecl(importDeclaration);
            var isExported = false;
            var linkKind = 6 /* PrivateMember */ ;
            var importSymbol = null;
            var declName = importDeclaration.getName();
            var parentHadSymbol = false;
            var parent = this.getParent(true);
            if (parent) {
                importSymbol = parent.findMember(declName);
            } else if (!(importDeclaration.getFlags() & 1 /* Exported */ )) {
                importSymbol = this.findSymbolInContext(declName, TypeScript.PullElementKind.SomeValue, []);
            }
            if (importSymbol) {
                parentHadSymbol = true;
            }
            if (importSymbol && (importSymbol.getSymbolID() > this.startingSymbolForRebind)) {
                if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) == 0) {
                    importDeclaration.addError(new TypeScript.PullError(importDeclAST.minChar, importDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                        declName
                    ])));
                    importSymbol = null;
                }
            }
            if (this.reBindingAfterChange && importSymbol) {
                var decls = importSymbol.getDeclarations();
                var scriptName = importDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        importSymbol.removeDeclaration(decls[j]);
                    }
                }
            }
            if (!importSymbol) {
                importSymbol = new TypeScript.PullSymbol(declName, declKind);
            }
            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol);
            this.semanticInfo.setSymbolForAST(importDeclAST, importSymbol);
            this.semanticInfo.setSymbolForAST(importDeclAST.id, importSymbol);
            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */ ) {
                    parent.addMember(importSymbol, 5 /* PublicMember */ );
                } else {
                    importSymbol.addOutgoingLink(parent, 9 /* ContainedBy */ );
                }
            }
        };
        PullSymbolBinder.prototype.bindParameterSymbols = function (funcDecl, signatureSymbol) {
            var parameters = [];
            var decl = null;
            var argDecl = null;
            var parameterSymbol = null;
            var isProperty = false;
            var params = new TypeScript.BlockIntrinsics();
            if (funcDecl.arguments) {
                for(var i = 0; i < funcDecl.arguments.members.length; i++) {
                    argDecl = funcDecl.arguments.members[i];
                    decl = this.semanticInfo.getDeclForAST(argDecl);
                    isProperty = TypeScript.hasFlag(argDecl.varFlags, 512 /* Property */ );
                    parameterSymbol = new TypeScript.PullSymbol(argDecl.id.actualText, 2048 /* Variable */ );
                    if (params[argDecl.id.actualText]) {
                        decl.addError(new TypeScript.PullError(argDecl.minChar, argDecl.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                            argDecl.id.actualText
                        ])));
                    } else {
                        params[argDecl.id.actualText] = true;
                    }
                    if (decl) {
                        parameterSymbol.addDeclaration(decl);
                        decl.setSymbol(parameterSymbol);
                    }
                    this.semanticInfo.setSymbolForAST(argDecl, parameterSymbol);
                    this.semanticInfo.setSymbolForAST(argDecl.id, parameterSymbol);
                    signatureSymbol.addParameter(parameterSymbol);
                }
            }
        };
        PullSymbolBinder.prototype.bindFunctionDeclarationToPullSymbol = function (functionDeclaration) {
            var declKind = functionDeclaration.getKind();
            var declFlags = functionDeclaration.getFlags();
            var funcDeclAST = this.semanticInfo.getASTForDecl(functionDeclaration);
            var isExported = (declFlags & 1 /* Exported */ ) != 0;
            var funcName = functionDeclaration.getName();
            var isSignature = (declFlags & 4096 /* Signature */ ) != 0;
            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;
            var functionSymbol = null;
            var functionTypeSymbol = null;
            if (parent) {
                functionSymbol = parent.findMember(funcName);
            } else if (!(functionDeclaration.getFlags() & 1 /* Exported */ )) {
                functionSymbol = this.findSymbolInContext(funcName, TypeScript.PullElementKind.SomeValue, []);
            }
            if (functionSymbol && functionSymbol.getKind() != 32768 /* Function */ ) {
                functionDeclaration.addError(new TypeScript.PullError(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                    funcName
                ])));
                functionSymbol = null;
            }
            if (functionSymbol) {
                functionTypeSymbol = functionSymbol.getType();
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && functionSymbol) {
                var decls = functionSymbol.getDeclarations();
                var scriptName = functionDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        functionSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                functionSymbol.invalidate();
            }
            if (!functionSymbol) {
                functionSymbol = new TypeScript.PullSymbol(funcName, 32768 /* Function */ );
                functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
                functionSymbol.setType(functionTypeSymbol);
            }
            functionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionDeclaration);
            this.semanticInfo.setSymbolForAST(funcDeclAST, functionSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST.name, functionSymbol);
            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol, 5 /* PublicMember */ );
                } else {
                    functionSymbol.addOutgoingLink(parent, 9 /* ContainedBy */ );
                }
            }
            if (!isSignature) {
                this.pushParent(functionTypeSymbol);
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = functionTypeSymbol.getCallSignatures();
                for(var i = 0; i < callSigs.length; i++) {
                    functionTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                functionSymbol.invalidate();
                functionTypeSymbol.invalidate();
            }
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(2097152 /* CallSignature */ ) : new TypeScript.PullDefinitionSignatureSymbol(2097152 /* CallSignature */ );
            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionDeclaration), signature);
            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            functionTypeSymbol.addSignature(signature);
            if (!isSignature) {
                var childDecls = functionDeclaration.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }
                this.popParent();
            }
        };
        PullSymbolBinder.prototype.bindFunctionExpressionToPullSymbol = function (functionExpressionDeclaration) {
            var declKind = functionExpressionDeclaration.getKind();
            var declFlags = functionExpressionDeclaration.getFlags();
            var funcExpAST = this.semanticInfo.getASTForDecl(functionExpressionDeclaration);
            var functionSymbol = new TypeScript.PullSymbol(functionExpressionDeclaration.getName(), 32768 /* Function */ );
            var functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
            functionSymbol.setType(functionTypeSymbol);
            functionExpressionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionExpressionDeclaration);
            this.semanticInfo.setSymbolForAST(funcExpAST, functionSymbol);
            if (funcExpAST.name) {
                this.semanticInfo.setSymbolForAST(funcExpAST.name, functionSymbol);
            }
            this.pushParent(functionTypeSymbol);
            var signature = new TypeScript.PullDefinitionSignatureSymbol(2097152 /* CallSignature */ );
            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionExpressionDeclaration), signature);
            functionTypeSymbol.addSignature(signature);
            var childDecls = functionExpressionDeclaration.getChildDecls();
            for(var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }
            this.popParent();
        };
        PullSymbolBinder.prototype.bindFunctionTypeDeclarationToPullSymbol = function (functionTypeDeclaration) {
            var declKind = functionTypeDeclaration.getKind();
            var declFlags = functionTypeDeclaration.getFlags();
            var funcTypeAST = this.semanticInfo.getASTForDecl(functionTypeDeclaration);
            var functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
            functionTypeDeclaration.setSymbol(functionTypeSymbol);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfo.setSymbolForAST(funcTypeAST, functionTypeSymbol);
            this.pushParent(functionTypeSymbol);
            var signature = new TypeScript.PullDefinitionSignatureSymbol(2097152 /* CallSignature */ );
            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionTypeDeclaration), signature);
            functionTypeSymbol.addSignature(signature);
            this.popParent();
        };
        PullSymbolBinder.prototype.bindMethodDeclarationToPullSymbol = function (methodDeclaration) {
            var declKind = methodDeclaration.getKind();
            var declFlags = methodDeclaration.getFlags();
            var methodAST = this.semanticInfo.getASTForDecl(methodDeclaration);
            var isPrivate = (declFlags & 2 /* Private */ ) != 0;
            var isStatic = (declFlags & 16 /* Static */ ) != 0;
            var methodName = methodDeclaration.getName();
            var isSignature = (declFlags & 4096 /* Signature */ ) != 0;
            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;
            var methodSymbol = null;
            var methodTypeSymbol = null;
            var linkKind = isPrivate ? 6 /* PrivateMember */  : 5 /* PublicMember */ ;
            methodSymbol = parent.isClass() && isStatic && (parent).getConstructorMethod() ? (parent).getConstructorMethod().getType().findMember(methodName) : parent.findMember(methodName);
            if (methodSymbol && methodSymbol.getKind() != 131072 /* Method */ ) {
                methodDeclaration.addError(new TypeScript.PullError(methodAST.minChar, methodAST.getLength(), this.semanticInfo.getPath(), TypeScript.getDiagnosticMessage(2 /* duplicateIdentifier_1 */ , [
                    methodName
                ])));
                methodSymbol = null;
            }
            if (methodSymbol) {
                methodTypeSymbol = methodSymbol.getType();
                parentHadSymbol = true;
            }
            if (this.reBindingAfterChange && methodSymbol) {
                var decls = methodSymbol.getDeclarations();
                var scriptName = methodDeclaration.getScriptName();
                for(var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        methodSymbol.removeDeclaration(decls[j]);
                        cleanedPreviousDecls = true;
                    }
                }
                methodSymbol.invalidate();
            }
            if (!methodSymbol) {
                methodSymbol = new TypeScript.PullSymbol(methodName, 131072 /* Method */ );
                methodTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
                methodSymbol.setType(methodTypeSymbol);
            }
            methodDeclaration.setSymbol(methodSymbol);
            methodSymbol.addDeclaration(methodDeclaration);
            this.semanticInfo.setSymbolForAST(methodAST, methodSymbol);
            this.semanticInfo.setSymbolForAST(methodAST.name, methodSymbol);
            if (!parentHadSymbol) {
                if (isStatic) {
                    this.staticClassMembers[this.staticClassMembers.length] = methodSymbol;
                } else {
                    parent.addMember(methodSymbol, linkKind);
                }
            }
            if (!isSignature) {
                this.pushParent(methodTypeSymbol);
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = methodTypeSymbol.getCallSignatures();
                var constructSigs = methodTypeSymbol.getConstructSignatures();
                var indexSigs = methodTypeSymbol.getIndexSignatures();
                for(var i = 0; i < callSigs.length; i++) {
                    methodTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                for(var i = 0; i < constructSigs.length; i++) {
                    methodTypeSymbol.removeConstructSignature(constructSigs[i], false);
                }
                for(var i = 0; i < indexSigs.length; i++) {
                    methodTypeSymbol.removeIndexSignature(indexSigs[i], false);
                }
                methodSymbol.invalidate();
                methodTypeSymbol.invalidate();
            }
            var sigKind = 2097152 /* CallSignature */ ;
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(sigKind) : new TypeScript.PullDefinitionSignatureSymbol(sigKind);
            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(methodDeclaration), signature);
            methodTypeSymbol.addSignature(signature);
            if (!isSignature) {
                var childDecls = methodDeclaration.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }
                this.popParent();
            }
        };
        PullSymbolBinder.prototype.bindConstructorDeclarationToPullSymbol = function (constructorDeclaration) {
            var declKind = constructorDeclaration.getKind();
            var declFlags = constructorDeclaration.getFlags();
            var constructorAST = this.semanticInfo.getASTForDecl(constructorDeclaration);
            var constructorName = constructorDeclaration.getName();
            var isSignature = (declFlags & 4096 /* Signature */ ) != 0;
            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;
            var constructorSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol = null;
            var linkKind = 7 /* ConstructorMethod */ ;
            if (constructorSymbol) {
                constructorTypeSymbol = constructorSymbol.getType();
                if (this.reBindingAfterChange) {
                    var decls = constructorSymbol.getDeclarations();
                    var scriptName = constructorDeclaration.getScriptName();
                    for(var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            constructorSymbol.removeDeclaration(decls[j]);
                            cleanedPreviousDecls = true;
                        }
                    }
                    constructorSymbol.invalidate();
                    constructorTypeSymbol.invalidate();
                }
            }
            if (!constructorSymbol) {
                constructorSymbol = new TypeScript.PullSymbol(constructorName, 65536 /* ConstructorMethod */ );
                constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();
            }
            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.setType(constructorTypeSymbol);
            constructorDeclaration.setSymbol(constructorSymbol);
            constructorSymbol.addDeclaration(constructorDeclaration);
            this.semanticInfo.setSymbolForAST(constructorAST, constructorSymbol);
            if (!isSignature) {
                this.pushParent(constructorTypeSymbol);
            }
            if (parentHadSymbol && cleanedPreviousDecls) {
                var constructSigs = constructorTypeSymbol.getConstructSignatures();
                for(var i = 0; i < constructSigs.length; i++) {
                    constructorTypeSymbol.removeConstructSignature(constructSigs[i]);
                }
                constructorSymbol.invalidate();
                constructorTypeSymbol.invalidate();
            }
            var constructSignature = isSignature ? new TypeScript.PullSignatureSymbol(4194304 /* ConstructSignature */ ) : new TypeScript.PullDefinitionSignatureSymbol(4194304 /* ConstructSignature */ );
            constructSignature.setReturnType(parent);
            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature);
            var constructorDeclAST = this.semanticInfo.getASTForDecl(constructorDeclaration);
            this.bindParameterSymbols(constructorDeclAST, constructSignature);
            constructorTypeSymbol.addSignature(constructSignature);
            if (!isSignature) {
                var childDecls = constructorDeclaration.getChildDecls();
                for(var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }
                this.popParent();
            }
        };
        PullSymbolBinder.prototype.bindConstructSignatureDeclarationToPullSymbol = function (constructSignatureDeclaration) {
            var parent = this.getParent(true);
            var constructSigs = parent.getConstructSignatures();
            for(var i = 0; i < constructSigs.length; i++) {
                if (constructSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeConstructSignature(constructSigs[i], false);
                }
            }
            parent.recomputeConstructSignatures();
            var constructSignature = new TypeScript.PullSignatureSymbol(4194304 /* ConstructSignature */ );
            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructSignature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    constructSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), constructSignature);
            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), constructSignature);
            parent.addConstructSignature(constructSignature);
        };
        PullSymbolBinder.prototype.bindCallSignatureDeclarationToPullSymbol = function (callSignatureDeclaration) {
            var parent = this.getParent(true);
            var callSigs = parent.getCallSignatures();
            for(var i = 0; i < callSigs.length; i++) {
                if (callSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeCallSignature(callSigs[i], false);
                }
            }
            parent.recomputeCallSignatures();
            var callSignature = new TypeScript.PullSignatureSymbol(2097152 /* CallSignature */ );
            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = callSignature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    callSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(callSignatureDeclaration), callSignature);
            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(callSignatureDeclaration), callSignature);
            parent.addCallSignature(callSignature);
        };
        PullSymbolBinder.prototype.bindIndexSignatureDeclarationToPullSymbol = function (indexSignatureDeclaration) {
            var parent = this.getParent(true);
            var indexSigs = parent.getIndexSignatures();
            for(var i = 0; i < indexSigs.length; i++) {
                if (indexSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeIndexSignature(indexSigs[i], false);
                }
            }
            parent.recomputeIndexSignatures();
            var indexSignature = new TypeScript.PullSignatureSymbol(8388608 /* IndexSignature */ );
            var typeParameters = indexSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            for(var i = 0; i < typeParameters.length; i++) {
                typeParameter = indexSignature.findTypeParameter(typeParameters[i].getName());
                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName());
                    indexSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();
                    for(var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature);
            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), indexSignature);
            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), indexSignature);
            parent.addIndexSignature(indexSignature);
        };
        PullSymbolBinder.prototype.bindDeclToPullSymbol = function (decl, rebind) {
            if (typeof rebind === "undefined") { rebind = false; }
            if (rebind) {
                this.startingDeclForRebind = TypeScript.lastBoundPullDeclId;
                this.startingSymbolForRebind = TypeScript.lastBoundPullSymbolID;
                this.reBindingAfterChange = true;
            }
            switch(decl.getKind()) {
                case 1 /* Script */ :
                    var childDecls = decl.getChildDecls();
                    for(var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;
                case 8 /* Container */ :
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;
                case 32 /* Interface */ :
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;
                case 16 /* Class */ :
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;
                case 32768 /* Function */ :
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;
                case 2048 /* Variable */ :
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;
                case 8192 /* Property */ :
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;
                case 131072 /* Method */ :
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;
                case 65536 /* ConstructorMethod */ :
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;
                case 2097152 /* CallSignature */ :
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;
                case 4194304 /* ConstructSignature */ :
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;
                case 8388608 /* IndexSignature */ :
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;
                case 128 /* Enum */ :
                    this.bindEnumDeclarationToPullSymbol(decl);
                    break;
                case 524288 /* GetAccessor */ :
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;
                case 1048576 /* SetAccessor */ :
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;
                case 16777216 /* ObjectType */ :
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;
                case 33554432 /* FunctionType */ :
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;
                case 67108864 /* ConstructorType */ :
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;
                case 262144 /* FunctionExpression */ :
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;
                case 4096 /* Parameter */ :
                    break;
                default:
                    throw new Error("Unrecognized type declaration");
            }
        };
        PullSymbolBinder.prototype.bindGetAccessorDeclarationToPullSymbol = function (getAccessorDeclaration) {
        };
        PullSymbolBinder.prototype.bindSetAccessorDeclarationToPullSymbol = function (setAccessorDeclaration) {
        };
        PullSymbolBinder.prototype.bindDeclsForUnit = function (filePath, rebind) {
            if (typeof rebind === "undefined") { rebind = false; }
            this.setUnit(filePath);
            var topLevelDecls = this.semanticInfo.getTopLevelDecls();
            for(var i = 0; i < topLevelDecls.length; i++) {
                this.bindDeclToPullSymbol(topLevelDecls[i], rebind);
            }
        };
        return PullSymbolBinder;
    })();
    TypeScript.PullSymbolBinder = PullSymbolBinder;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.linkID = 0;
    var IListItem = (function () {
        function IListItem(value) {
            this.value = value;
            this.next = null;
            this.prev = null;
        }
        return IListItem;
    })();
    TypeScript.IListItem = IListItem;    
    var LinkList = (function () {
        function LinkList() {
            this.head = null;
            this.last = null;
            this.length = 0;
        }
        LinkList.prototype.addItem = function (item) {
            if (!this.head) {
                this.head = new IListItem(item);
                this.last = this.head;
            } else {
                this.last.next = new IListItem(item);
                this.last.next.prev = this.last;
                this.last = this.last.next;
            }
            this.length++;
        };
        LinkList.prototype.find = function (p) {
            var node = this.head;
            var vals = [];
            while(node) {
                if (p(node.value)) {
                    vals[vals.length] = node.value;
                }
                node = node.next;
            }
            return vals;
        };
        LinkList.prototype.remove = function (p) {
            var node = this.head;
            var prev = null;
            var next = null;
            while(node) {
                if (p(node.value)) {
                    if (node == this.head) {
                        if (this.last == this.head) {
                            this.last = null;
                        }
                        this.head = this.head.next;
                        if (this.head) {
                            this.head.prev = null;
                        }
                    } else {
                        prev = node.prev;
                        next = node.next;
                        if (prev) {
                            prev.next = next;
                        }
                        if (next) {
                            next.prev = prev;
                        }
                        if (node == this.last) {
                            this.last = prev;
                        }
                    }
                    this.length--;
                }
                node = node.next;
            }
        };
        LinkList.prototype.update = function (map, context) {
            var node = this.head;
            while(node) {
                map(node.value, context);
                node = node.next;
            }
        };
        return LinkList;
    })();
    TypeScript.LinkList = LinkList;    
    var PullSymbolLink = (function () {
        function PullSymbolLink(start, end, kind) {
            this.start = start;
            this.end = end;
            this.kind = kind;
            this.id = TypeScript.linkID++;
        }
        return PullSymbolLink;
    })();
    TypeScript.PullSymbolLink = PullSymbolLink;    
    (function (GraphUpdateKind) {
        GraphUpdateKind._map = [];
        GraphUpdateKind._map[0] = "NoUpdate";
        GraphUpdateKind.NoUpdate = 0;
        GraphUpdateKind._map[1] = "SymbolRemoved";
        GraphUpdateKind.SymbolRemoved = 1;
        GraphUpdateKind._map[2] = "SymbolAdded";
        GraphUpdateKind.SymbolAdded = 2;
        GraphUpdateKind._map[3] = "TypeChanged";
        GraphUpdateKind.TypeChanged = 3;
    })(TypeScript.GraphUpdateKind || (TypeScript.GraphUpdateKind = {}));
    var GraphUpdateKind = TypeScript.GraphUpdateKind;
    var PullSymbolUpdate = (function () {
        function PullSymbolUpdate(updateKind, symbolToUpdate, updater) {
            this.updateKind = updateKind;
            this.symbolToUpdate = symbolToUpdate;
            this.updater = updater;
        }
        return PullSymbolUpdate;
    })();
    TypeScript.PullSymbolUpdate = PullSymbolUpdate;    
    TypeScript.updateVersion = 0;
    var PullSymbolGraphUpdater = (function () {
        function PullSymbolGraphUpdater(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
        }
        PullSymbolGraphUpdater.prototype.removeDecl = function (declToRemove) {
            var declSymbol = declToRemove.getSymbol();
            if (declSymbol) {
                declSymbol.removeDeclaration(declToRemove);
                var decls = declSymbol.getDeclarations();
                if (!decls.length) {
                    this.removeSymbol(declSymbol);
                } else {
                    var childDecls = declToRemove.getChildDecls();
                    for(var i = 0; i < childDecls.length; i++) {
                        this.removeDecl(childDecls[i]);
                    }
                }
                this.semanticInfoChain.removeSymbolFromCache(declSymbol);
            }
            var valDecl = declToRemove.getValueDecl();
            if (valDecl) {
                this.removeDecl(valDecl);
            }
            TypeScript.updateVersion++;
        };
        PullSymbolGraphUpdater.prototype.addDecl = function (declToAdd) {
            var symbolToAdd = declToAdd.getSymbol();
            this.addSymbol(symbolToAdd);
            TypeScript.updateVersion++;
        };
        PullSymbolGraphUpdater.prototype.removeSymbol = function (symbolToRemove) {
            if (symbolToRemove.removeUpdateVersion == TypeScript.updateVersion) {
                return;
            }
            symbolToRemove.removeUpdateVersion = TypeScript.updateVersion;
            symbolToRemove.updateOutgoingLinks(propagateRemovalToOutgoingLinks, new PullSymbolUpdate(1 /* SymbolRemoved */ , symbolToRemove, this));
            symbolToRemove.updateIncomingLinks(propagateRemovalToIncomingLinks, new PullSymbolUpdate(1 /* SymbolRemoved */ , symbolToRemove, this));
            var container = symbolToRemove.getContainer();
            if (container) {
                container.removeMember(symbolToRemove);
            }
        };
        PullSymbolGraphUpdater.prototype.addSymbol = function (symbolToAdd) {
            if (symbolToAdd.addUpdateVersion == TypeScript.updateVersion) {
                return;
            }
            symbolToAdd.addUpdateVersion = TypeScript.updateVersion;
            symbolToAdd.updateOutgoingLinks(propagateAdditionToOutgoingLinks, new PullSymbolUpdate(2 /* SymbolAdded */ , symbolToAdd, this));
            symbolToAdd.updateIncomingLinks(propagateAdditionToIncomingLinks, new PullSymbolUpdate(2 /* SymbolAdded */ , symbolToAdd, this));
        };
        PullSymbolGraphUpdater.prototype.invalidateType = function (symbolWhoseTypeChanged) {
            if (!symbolWhoseTypeChanged) {
                return;
            }
            if (symbolWhoseTypeChanged.isPrimitive()) {
                return;
            }
            if (symbolWhoseTypeChanged.typeChangeUpdateVersion == TypeScript.updateVersion) {
                return;
            }
            symbolWhoseTypeChanged.typeChangeUpdateVersion = TypeScript.updateVersion;
            symbolWhoseTypeChanged.updateOutgoingLinks(propagateChangedTypeToOutgoingLinks, new PullSymbolUpdate(3 /* TypeChanged */ , symbolWhoseTypeChanged, this));
            symbolWhoseTypeChanged.updateIncomingLinks(propagateChangedTypeToIncomingLinks, new PullSymbolUpdate(3 /* TypeChanged */ , symbolWhoseTypeChanged, this));
            symbolWhoseTypeChanged.invalidate();
        };
        return PullSymbolGraphUpdater;
    })();
    TypeScript.PullSymbolGraphUpdater = PullSymbolGraphUpdater;    
    function propagateRemovalToOutgoingLinks(link, update) {
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.end;
        if (link.kind == 0 /* TypedAs */ ) {
        } else if (link.kind == 1 /* ContextuallyTypedAs */ ) {
        } else if (link.kind == 2 /* ProvidesInferredType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 17 /* TypeParameter */ ) {
        } else if (link.kind == 18 /* TypeArgument */ ) {
        } else if (link.kind == 19 /* TypeParameterSpecializedTo */ ) {
        } else if (link.kind == 20 /* SpecializedTo */ ) {
            update.updater.removeSymbol(affectedSymbol);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 21 /* TypeConstraint */ ) {
        } else if (link.kind == 4 /* ArrayOf */ ) {
        } else if (link.kind == 5 /* PublicMember */ ) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind == 6 /* PrivateMember */ ) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind == 7 /* ConstructorMethod */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 8 /* Aliases */ ) {
        } else if (link.kind == 9 /* ContainedBy */ ) {
            (affectedSymbol).removeMember(symbolToRemove);
        } else if (link.kind == 10 /* Extends */ ) {
        } else if (link.kind == 11 /* Implements */ ) {
        } else if (link.kind == 12 /* Parameter */ ) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind == 13 /* ReturnType */ ) {
        } else if (link.kind == 14 /* CallSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 15 /* ConstructSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 16 /* IndexSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        }
        symbolToRemove.removeOutgoingLink(link);
    }
    TypeScript.propagateRemovalToOutgoingLinks = propagateRemovalToOutgoingLinks;
    function propagateRemovalToIncomingLinks(link, update) {
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.start;
        if (link.kind == 0 /* TypedAs */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 1 /* ContextuallyTypedAs */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 2 /* ProvidesInferredType */ ) {
        } else if (link.kind == 17 /* TypeParameter */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 18 /* TypeArgument */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 19 /* TypeParameterSpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 20 /* SpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 21 /* TypeConstraint */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 3 /* ArrayType */ ) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind == 4 /* ArrayOf */ ) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind == 5 /* PublicMember */ ) {
            (affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 6 /* PrivateMember */ ) {
            (affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 7 /* ConstructorMethod */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 8 /* Aliases */ ) {
        } else if (link.kind == 9 /* ContainedBy */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 10 /* Extends */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 11 /* Implements */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 12 /* Parameter */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 13 /* ReturnType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 14 /* CallSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 15 /* ConstructSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 16 /* IndexSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateRemovalToIncomingLinks = propagateRemovalToIncomingLinks;
    function propagateAdditionToOutgoingLinks(link, update) {
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.end;
        if (link.kind == 0 /* TypedAs */ ) {
        } else if (link.kind == 1 /* ContextuallyTypedAs */ ) {
        } else if (link.kind == 2 /* ProvidesInferredType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 17 /* TypeParameter */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 18 /* TypeArgument */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 19 /* TypeParameterSpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 20 /* SpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 21 /* TypeConstraint */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 4 /* ArrayOf */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 5 /* PublicMember */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 6 /* PrivateMember */ ) {
        } else if (link.kind == 7 /* ConstructorMethod */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 8 /* Aliases */ ) {
        } else if (link.kind == 9 /* ContainedBy */ ) {
        } else if (link.kind == 10 /* Extends */ ) {
        } else if (link.kind == 11 /* Implements */ ) {
        } else if (link.kind == 12 /* Parameter */ ) {
        } else if (link.kind == 13 /* ReturnType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 14 /* CallSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 15 /* ConstructSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 16 /* IndexSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateAdditionToOutgoingLinks = propagateAdditionToOutgoingLinks;
    function propagateAdditionToIncomingLinks(link, update) {
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.start;
        if (link.kind == 0 /* TypedAs */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 1 /* ContextuallyTypedAs */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 2 /* ProvidesInferredType */ ) {
        } else if (link.kind == 17 /* TypeParameter */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 18 /* TypeArgument */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 19 /* TypeParameterSpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 20 /* SpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 21 /* TypeConstraint */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 4 /* ArrayOf */ ) {
        } else if (link.kind == 5 /* PublicMember */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 6 /* PrivateMember */ ) {
        } else if (link.kind == 7 /* ConstructorMethod */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 8 /* Aliases */ ) {
        } else if (link.kind == 9 /* ContainedBy */ ) {
        } else if (link.kind == 10 /* Extends */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 11 /* Implements */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 12 /* Parameter */ ) {
        } else if (link.kind == 13 /* ReturnType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 14 /* CallSignature */ ) {
        } else if (link.kind == 15 /* ConstructSignature */ ) {
        } else if (link.kind == 16 /* IndexSignature */ ) {
        }
    }
    TypeScript.propagateAdditionToIncomingLinks = propagateAdditionToIncomingLinks;
    function propagateChangedTypeToOutgoingLinks(link, update) {
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.end;
        if (link.kind == 0 /* TypedAs */ ) {
        } else if (link.kind == 1 /* ContextuallyTypedAs */ ) {
        } else if (link.kind == 2 /* ProvidesInferredType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 17 /* TypeParameter */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 18 /* TypeArgument */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 19 /* TypeParameterSpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 20 /* SpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 21 /* TypeConstraint */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 4 /* ArrayOf */ ) {
        } else if (link.kind == 5 /* PublicMember */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 6 /* PrivateMember */ ) {
        } else if (link.kind == 7 /* ConstructorMethod */ ) {
        } else if (link.kind == 8 /* Aliases */ ) {
        } else if (link.kind == 9 /* ContainedBy */ ) {
        } else if (link.kind == 10 /* Extends */ ) {
        } else if (link.kind == 11 /* Implements */ ) {
        } else if (link.kind == 12 /* Parameter */ ) {
        } else if (link.kind == 13 /* ReturnType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 14 /* CallSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 15 /* ConstructSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 16 /* IndexSignature */ ) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateChangedTypeToOutgoingLinks = propagateChangedTypeToOutgoingLinks;
    function propagateChangedTypeToIncomingLinks(link, update) {
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.start;
        if (link.kind == 0 /* TypedAs */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 1 /* ContextuallyTypedAs */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 2 /* ProvidesInferredType */ ) {
        } else if (link.kind == 3 /* ArrayType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 17 /* TypeParameter */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 18 /* TypeArgument */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 19 /* TypeParameterSpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 20 /* SpecializedTo */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 21 /* TypeConstraint */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 4 /* ArrayOf */ ) {
        } else if (link.kind == 5 /* PublicMember */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 6 /* PrivateMember */ ) {
        } else if (link.kind == 7 /* ConstructorMethod */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 8 /* Aliases */ ) {
        } else if (link.kind == 9 /* ContainedBy */ ) {
        } else if (link.kind == 10 /* Extends */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 11 /* Implements */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 12 /* Parameter */ ) {
        } else if (link.kind == 13 /* ReturnType */ ) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind == 14 /* CallSignature */ ) {
        } else if (link.kind == 15 /* ConstructSignature */ ) {
        } else if (link.kind == 16 /* IndexSignature */ ) {
        }
    }
    TypeScript.propagateChangedTypeToIncomingLinks = propagateChangedTypeToIncomingLinks;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullEmitter = (function (_super) {
        __extends(PullEmitter, _super);
        function PullEmitter(checker, emittingFileName, outfile, emitOptions, errorReporter, semanticInfoChain) {
                _super.call(this, checker, emittingFileName, outfile, emitOptions, errorReporter);
            this.checker = checker;
            this.emittingFileName = emittingFileName;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.errorReporter = errorReporter;
            this.semanticInfoChain = semanticInfoChain;
        }
        PullEmitter.prototype.setSourceMappings = function (mapper) {
            this.allSourceMappers.push(mapper);
            this.sourceMapper = mapper;
        };
        PullEmitter.prototype.writeToOutput = function (s) {
            this.outfile.Write(s);
            this.emitState.column += s.length;
        };
        PullEmitter.prototype.writeToOutputTrimmable = function (s) {
            if (this.emitOptions.minWhitespace) {
                s = s.replace(/[\s]*/g, '');
            }
            this.writeToOutput(s);
        };
        PullEmitter.prototype.writeLineToOutput = function (s) {
            if (this.emitOptions.minWhitespace) {
                this.writeToOutput(s);
                var c = s.charCodeAt(s.length - 1);
                if (!((c == TypeScript.LexCodeSpace) || (c == TypeScript.LexCodeSMC) || (c == TypeScript.LexCodeLBR))) {
                    this.writeToOutput(' ');
                }
            } else {
                this.outfile.WriteLine(s);
                this.emitState.column = 0;
                this.emitState.line++;
            }
        };
        PullEmitter.prototype.writeCaptureThisStatement = function (ast) {
            this.emitIndent();
            this.recordSourceMappingStart(ast);
            this.writeToOutput(this.captureThisStmtString);
            this.recordSourceMappingEnd(ast);
            this.writeLineToOutput("");
        };
        PullEmitter.prototype.setInVarBlock = function (count) {
            this.varListCountStack[this.varListCountStack.length - 1] = count;
        };
        PullEmitter.prototype.setInObjectLiteral = function (val) {
            var temp = this.emitState.inObjectLiteral;
            this.emitState.inObjectLiteral = val;
            return temp;
        };
        PullEmitter.prototype.setContainer = function (c) {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        };
        PullEmitter.prototype.getIndentString = function () {
            if (this.emitOptions.minWhitespace) {
                return "";
            } else {
                return this.indenter.getIndent();
            }
        };
        PullEmitter.prototype.emitIndent = function () {
            this.writeToOutput(this.getIndentString());
        };
        PullEmitter.prototype.emitCommentInPlace = function (comment) {
            var text = comment.getText();
            var hadNewLine = false;
            if (comment.isBlockComment) {
                if (this.emitState.column == 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                if (text.length > 1 || comment.endsLine) {
                    for(var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                    hadNewLine = true;
                } else {
                    this.recordSourceMappingEnd(comment);
                }
            } else {
                if (this.emitState.column == 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
                hadNewLine = true;
            }
            if (hadNewLine) {
                this.emitIndent();
            } else {
                this.writeToOutput(" ");
            }
        };
        PullEmitter.prototype.emitParensAndCommentsInPlace = function (ast, pre) {
            var comments = pre ? ast.preComments : ast.postComments;
            if (ast.isParenthesized && !pre) {
                this.writeToOutput(")");
            }
            if (this.emitOptions.emitComments && comments && comments.length != 0) {
                for(var i = 0; i < comments.length; i++) {
                    this.emitCommentInPlace(comments[i]);
                }
            }
            if (ast.isParenthesized && pre) {
                this.writeToOutput("(");
            }
        };
        PullEmitter.prototype.emitObjectLiteral = function (content) {
            this.writeLineToOutput("{");
            this.indenter.increaseIndent();
            var inObjectLiteral = this.setInObjectLiteral(true);
            this.emitJavascriptList(content, ",", 62 /* Comma */ , true, false, false);
            this.setInObjectLiteral(inObjectLiteral);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
        };
        PullEmitter.prototype.emitArrayLiteral = function (content) {
            this.writeToOutput("[");
            if (content) {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascriptList(content, ", ", 62 /* Comma */ , true, false, false);
                this.indenter.decreaseIndent();
                this.emitIndent();
            }
            this.writeToOutput("]");
        };
        PullEmitter.prototype.emitNew = function (target, args) {
            this.writeToOutput("new ");
            if (target.nodeType == 28 /* TypeRef */ ) {
                var typeRef = target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                } else {
                    this.emitJavascript(typeRef.term, 98 /* Tilde */ , false);
                    this.writeToOutput("()");
                }
            } else {
                this.emitJavascript(target, 98 /* Tilde */ , false);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitJavascriptList(args, ", ", 62 /* Comma */ , false, false, false);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        };
        PullEmitter.prototype.getConstantValue = function (init) {
            if (init) {
                if (init.nodeType === 24 /* NumberLit */ ) {
                    var numLit = init;
                    return numLit.value;
                } else if (init.nodeType === 63 /* Lsh */ ) {
                    var binop = init;
                    if (binop.operand1.nodeType === 24 /* NumberLit */  && binop.operand2.nodeType === 24 /* NumberLit */ ) {
                        return (binop.operand1).value << (binop.operand2).value;
                    }
                } else if (init.nodeType === 25 /* Name */ ) {
                    var ident = init;
                    if (ident.sym !== null && ident.sym.declAST.nodeType === 75 /* VarDecl */ ) {
                        var varDecl = ident.sym.declAST;
                        return this.getConstantValue(varDecl.init);
                    }
                }
            }
            return null;
        };
        PullEmitter.prototype.tryEmitConstant = function (dotExpr) {
            if (!this.emitOptions.propagateConstants) {
                return false;
            }
            var propertyName = dotExpr.operand2;
            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {
                if (TypeScript.hasFlag(propertyName.sym.flags, 32768 /* Constant */ )) {
                    if (propertyName.sym.declAST) {
                        var boundDecl = propertyName.sym.declAST;
                        var value = this.getConstantValue(boundDecl.init);
                        if (value !== null) {
                            this.writeToOutput(value.toString());
                            var comment = " /* ";
                            comment += propertyName.actualText;
                            comment += " */ ";
                            this.writeToOutput(comment);
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        PullEmitter.prototype.emitCall = function (callNode, target, args) {
            if (!this.emitSuperCall(callNode)) {
                if (!TypeScript.hasFlag(callNode.flags, 512 /* ClassBaseConstructorCall */ )) {
                    if (target.nodeType == 73 /* FuncDecl */  && !target.isParenthesized) {
                        this.writeToOutput("(");
                    }
                    if (callNode.target.nodeType == 6 /* Super */  && this.emitState.container == 4 /* Constructor */ ) {
                        this.writeToOutput("_super.call");
                    } else {
                        this.emitJavascript(target, 56 /* OpenParen */ , false);
                    }
                    if (target.nodeType == 73 /* FuncDecl */  && !target.isParenthesized) {
                        this.writeToOutput(")");
                    }
                    this.recordSourceMappingStart(args);
                    this.writeToOutput("(");
                    if (callNode.target.nodeType == 6 /* Super */  && this.emitState.container == 4 /* Constructor */ ) {
                        this.writeToOutput("this");
                        if (args && args.members.length) {
                            this.writeToOutput(", ");
                        }
                    }
                    this.emitJavascriptList(args, ", ", 62 /* Comma */ , false, false, false);
                    this.writeToOutput(")");
                    this.recordSourceMappingEnd(args);
                } else {
                    this.indenter.decreaseIndent();
                    this.indenter.decreaseIndent();
                    var constructorCall = new TypeScript.ASTList();
                    constructorCall.members[0] = callNode;
                    this.emitConstructorCalls(constructorCall, this.thisClassNode);
                    this.indenter.increaseIndent();
                    this.indenter.increaseIndent();
                }
            }
        };
        PullEmitter.prototype.emitConstructorCalls = function (bases, classDecl) {
            if (bases == null) {
                return;
            }
            var basesLen = bases.members.length;
            this.recordSourceMappingStart(classDecl);
            for(var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol = null;
                if (baseExpr.nodeType == 30 /* Call */ ) {
                    baseSymbol = (baseExpr).target.type.symbol;
                } else {
                    baseSymbol = baseExpr.type.symbol;
                }
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                if (baseExpr.nodeType == 30 /* Call */ ) {
                    this.emitIndent();
                    this.writeToOutput("_super.call(this");
                    var args = (baseExpr).arguments;
                    if (args && (args.members.length > 0)) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(args, ", ", 62 /* Comma */ , false, false, false);
                    }
                    this.writeToOutput(")");
                } else {
                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {
                        this.emitIndent();
                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");
                        this.writeToOutput(".call(this)");
                    }
                }
            }
            this.recordSourceMappingEnd(classDecl);
        };
        PullEmitter.prototype.emitInnerFunction = function (funcDecl, printName, isMember, bases, hasSelfRef, classDecl) {
            var isClassConstructor = funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ );
            var hasNonObjectBaseType = isClassConstructor && TypeScript.hasFlag(this.thisClassNode.type.instanceType.typeFlags, 32 /* HasBaseType */ ) && !TypeScript.hasFlag(this.thisClassNode.type.instanceType.typeFlags, 64 /* HasBaseTypeOfObject */ );
            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && TypeScript.hasFlag((this.thisClassNode).varFlags, 32768 /* ClassSuperMustBeFirstCallInConstructor */ );
            var shouldParenthesize = TypeScript.hasFlag(funcDecl.fncFlags, 131072 /* IsFunctionExpression */ ) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (TypeScript.hasFlag(funcDecl.flags, 1 /* ExplicitSemicolon */ ) || TypeScript.hasFlag(funcDecl.flags, 2 /* AutomaticSemicolon */ ));
            this.emitParensAndCommentsInPlace(funcDecl, true);
            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            if (!(funcDecl.isAccessor() && (funcDecl.accessorSymbol).isObjectLitField)) {
                this.writeToOutput("function ");
            }
            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }
            this.writeToOutput("(");
            var argsLen = 0;
            var i = 0;
            var arg;
            var defaultArgs = [];
            if (funcDecl.arguments) {
                var tempContainer = this.setContainer(6 /* Args */ );
                argsLen = funcDecl.arguments.members.length;
                var printLen = argsLen;
                if (funcDecl.variableArgList) {
                    printLen--;
                }
                for(i = 0; i < printLen; i++) {
                    arg = funcDecl.arguments.members[i];
                    if (arg.init) {
                        defaultArgs.push(arg);
                    }
                    this.emitJavascript(arg, 56 /* OpenParen */ , false);
                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);
            }
            this.writeLineToOutput(") {");
            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();
            for(i = 0; i < defaultArgs.length; i++) {
                var arg = defaultArgs[i];
                this.emitIndent();
                this.recordSourceMappingStart(arg);
                this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");
                this.recordSourceMappingStart(arg.id);
                this.writeToOutput(arg.id.actualText);
                this.recordSourceMappingEnd(arg.id);
                this.writeToOutput(" = ");
                this.emitJavascript(arg.init, 56 /* OpenParen */ , false);
                this.writeLineToOutput("; }");
                this.recordSourceMappingEnd(arg);
            }
            if (funcDecl.isConstructor && ((funcDecl.classDecl).varFlags & 131072 /* MustCaptureThis */ )) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {
                if (funcDecl.arguments) {
                    argsLen = funcDecl.arguments.members.length;
                    for(i = 0; i < argsLen; i++) {
                        arg = funcDecl.arguments.members[i];
                        if ((arg.varFlags & 512 /* Property */ ) != 0 /* None */ ) {
                            this.emitIndent();
                            this.recordSourceMappingStart(arg);
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput("this." + arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeToOutput(" = ");
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput(arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeLineToOutput(";");
                            this.recordSourceMappingEnd(arg);
                        }
                    }
                }
                if (!TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ )) {
                    this.emitConstructorCalls(bases, classDecl);
                }
            }
            if (hasSelfRef) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.variableArgList) {
                argsLen = funcDecl.arguments.members.length;
                var lastArg = funcDecl.arguments.members[argsLen - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(lastArg.id);
                this.writeToOutput(lastArg.id.actualText);
                this.recordSourceMappingEnd(lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var _i = 0;");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput(" ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput("; ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i++");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
            if (funcDecl.isConstructor && TypeScript.hasFlag(funcDecl.fncFlags, 262144 /* ClassMethod */ ) && !classPropertiesMustComeAfterSuperCall) {
                var nProps = (this.thisClassNode.members).members.length;
                for(var i = 0; i < nProps; i++) {
                    if ((this.thisClassNode.members).members[i].nodeType == 75 /* VarDecl */ ) {
                        var varDecl = (this.thisClassNode.members).members[i];
                        if (!TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ ) && varDecl.init) {
                            this.emitIndent();
                            this.emitJavascriptVarDecl(varDecl, 98 /* Tilde */ );
                            this.writeLineToOutput("");
                        }
                    }
                }
            }
            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl.endingToken);
            this.writeToOutput("}");
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl.endingToken);
            this.recordSourceMappingEnd(funcDecl);
            if (shouldParenthesize) {
                this.writeToOutput(")");
            }
            this.recordSourceMappingEnd(funcDecl);
            this.emitParensAndCommentsInPlace(funcDecl, false);
            if (!isMember && !TypeScript.hasFlag(funcDecl.fncFlags, 131072 /* IsFunctionExpression */ ) && (!TypeScript.hasFlag(funcDecl.fncFlags, 512 /* Signature */ ) || funcDecl.isConstructor)) {
                this.writeLineToOutput("");
            } else if (TypeScript.hasFlag(funcDecl.fncFlags, 131072 /* IsFunctionExpression */ )) {
                if (TypeScript.hasFlag(funcDecl.flags, 1 /* ExplicitSemicolon */ ) || TypeScript.hasFlag(funcDecl.flags, 2 /* AutomaticSemicolon */ )) {
                    this.writeLineToOutput(";");
                }
            }
        };
        PullEmitter.prototype.emitJavascriptModule = function (moduleDecl) {
            var modName = moduleDecl.name.actualText;
            if (TypeScript.isTSFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 3));
            } else if (TypeScript.isSTRFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 4));
            }
            if (!TypeScript.hasFlag(moduleDecl.modFlags, 8 /* Ambient */ )) {
                var isDynamicMod = TypeScript.hasFlag(moduleDecl.modFlags, 2048 /* IsDynamic */ );
                var prevOutFile = this.outfile;
                var prevOutFileName = this.emittingFileName;
                var prevAllSourceMappers = this.allSourceMappers;
                var prevSourceMapper = this.sourceMapper;
                var prevColumn = this.emitState.column;
                var prevLine = this.emitState.line;
                var temp = this.setContainer(1 /* Module */ );
                var svModuleName = this.moduleName;
                var isExported = TypeScript.hasFlag(moduleDecl.modFlags, 1 /* Exported */ );
                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;
                var isWholeFile = TypeScript.hasFlag(moduleDecl.modFlags, 1024 /* IsWholeFile */ );
                this.moduleName = moduleDecl.name.actualText;
                if (isDynamicMod) {
                    var tsModFileName = TypeScript.stripQuotes(moduleDecl.name.actualText);
                    var modFilePath = TypeScript.trimModName(tsModFileName) + ".js";
                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScript.TypeScriptCompiler.mapToJSFileName);
                    if (this.emitOptions.ioHost) {
                        if (TypeScript.switchToForwardSlashes(modFilePath) != TypeScript.switchToForwardSlashes(this.emittingFileName)) {
                            this.emittingFileName = modFilePath;
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);
                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);
                            if (prevSourceMapper != null) {
                                this.allSourceMappers = [];
                                var sourceMappingFile = this.createFile(this.emittingFileName + TypeScript.SourceMapper.MapFileExtension, false);
                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter, this.emitOptions.emitFullSourceMapPath));
                                this.emitState.column = 0;
                                this.emitState.line = 0;
                            }
                        } else {
                            TypeScript.CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");
                        }
                    }
                    this.setContainer(2 /* DynamicModule */ );
                    this.recordSourceMappingStart(moduleDecl);
                    if (TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                        var dependencyList = "[\"require\", \"exports\"";
                        var importList = "require, exports";
                        var importStatement = null;
                        for(var i = 0; i < (moduleDecl.mod).importedModules.length; i++) {
                            importStatement = (moduleDecl.mod).importedModules[i];
                            if (importStatement.id.sym && !(importStatement.id.sym).onlyReferencedAsTypeRef) {
                                if (i <= (moduleDecl.mod).importedModules.length - 1) {
                                    dependencyList += ", ";
                                    importList += ", ";
                                }
                                importList += "__" + importStatement.id.actualText + "__";
                                dependencyList += importStatement.firstAliasedModToString();
                            }
                        }
                        for(var i = 0; i < moduleDecl.amdDependencies.length; i++) {
                            dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
                        }
                        dependencyList += "]";
                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                    } else {
                    }
                } else {
                    if (!isExported) {
                        this.recordSourceMappingStart(moduleDecl);
                        this.writeToOutput("var ");
                        this.recordSourceMappingStart(moduleDecl.name);
                        this.writeToOutput(this.moduleName);
                        this.recordSourceMappingEnd(moduleDecl.name);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(moduleDecl);
                        this.emitIndent();
                    }
                    this.writeToOutput("(");
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("function (");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(") {");
                }
                if (!isWholeFile) {
                    this.recordSourceMappingNameStart(this.moduleName);
                }
                if (!isDynamicMod || TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                    this.indenter.increaseIndent();
                }
                if (moduleDecl.modFlags & 4096 /* MustCaptureThis */ ) {
                    this.writeCaptureThisStatement(moduleDecl);
                }
                this.emitJavascriptList(moduleDecl.members, null, 55 /* Semicolon */ , true, false, false);
                if (!isDynamicMod || TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                    this.indenter.decreaseIndent();
                }
                this.emitIndent();
                if (isDynamicMod) {
                    if (TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                        this.writeLineToOutput("})");
                    } else {
                    }
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    if (this.outfile != prevOutFile) {
                        this.Close();
                        if (prevSourceMapper != null) {
                            this.allSourceMappers = prevAllSourceMappers;
                            this.sourceMapper = prevSourceMapper;
                            this.emitState.column = prevColumn;
                            this.emitState.line = prevLine;
                        }
                        this.outfile = prevOutFile;
                        this.emittingFileName = prevOutFileName;
                    }
                } else {
                    var containingMod = null;
                    if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {
                        containingMod = moduleDecl.type.symbol.container.declAST;
                    }
                    var parentIsDynamic = containingMod && TypeScript.hasFlag(containingMod.modFlags, 2048 /* IsDynamic */ );
                    this.recordSourceMappingStart(moduleDecl.endingToken);
                    if (temp == 0 /* Prog */  && isExported) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                    } else if (isExported || temp == 0 /* Prog */ ) {
                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                    } else if (!isExported && temp != 0 /* Prog */ ) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                    } else {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")();");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    this.writeLineToOutput("");
                    if (temp != 0 /* Prog */  && isExported) {
                        this.emitIndent();
                        this.recordSourceMappingStart(moduleDecl);
                        if (parentIsDynamic) {
                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                        } else {
                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                        }
                        this.recordSourceMappingEnd(moduleDecl);
                    }
                }
                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.moduleDeclList.length--;
            }
        };
        PullEmitter.prototype.emitIndex = function (operand1, operand2) {
            var temp = this.setInObjectLiteral(false);
            this.emitJavascript(operand1, 98 /* Tilde */ , false);
            this.writeToOutput("[");
            this.emitJavascriptList(operand2, ", ", 62 /* Comma */ , false, false, false);
            this.writeToOutput("]");
            this.setInObjectLiteral(temp);
        };
        PullEmitter.prototype.emitStringLiteral = function (text) {
            this.writeToOutput(text);
        };
        PullEmitter.prototype.emitJavascriptFunction = function (funcDecl) {
            if (TypeScript.hasFlag(funcDecl.fncFlags, 512 /* Signature */ ) || funcDecl.isOverload) {
                return;
            }
            var temp;
            var tempFnc = this.thisFnc;
            this.thisFnc = funcDecl;
            if (funcDecl.isConstructor) {
                temp = this.setContainer(4 /* Constructor */ );
            } else {
                temp = this.setContainer(5 /* Function */ );
            }
            var bases = null;
            var hasSelfRef = false;
            var funcName = funcDecl.getNameText();
            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) && ((temp != 4 /* Constructor */ ) || ((funcDecl.fncFlags & 1024 /* Method */ ) == 0 /* None */ ))) {
                var tempLit = this.setInObjectLiteral(false);
                if (this.thisClassNode) {
                    bases = this.thisClassNode.extendsList;
                }
                hasSelfRef = TypeScript.Emitter.shouldCaptureThis(funcDecl);
                this.recordSourceMappingStart(funcDecl);
                if (TypeScript.hasFlag(funcDecl.fncFlags, 1 /* Exported */  | 524288 /* ClassPropertyMethodExported */ ) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {
                    this.writeToOutput("this." + funcName + " = ");
                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);
                } else {
                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);
                }
                this.setInObjectLiteral(tempLit);
            }
            this.setContainer(temp);
            this.thisFnc = tempFnc;
            if (!TypeScript.hasFlag(funcDecl.fncFlags, 512 /* Signature */ )) {
                if (TypeScript.hasFlag(funcDecl.fncFlags, 16 /* Static */ )) {
                    if (this.thisClassNode) {
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        } else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName + " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                } else if ((this.emitState.container == 1 /* Module */  || this.emitState.container == 2 /* DynamicModule */ ) && TypeScript.hasFlag(funcDecl.fncFlags, 1 /* Exported */  | 524288 /* ClassPropertyMethodExported */ )) {
                    this.emitIndent();
                    var modName = this.emitState.container == 1 /* Module */  ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeLineToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        };
        PullEmitter.prototype.emitAmbientVarDecl = function (varDecl) {
            if (varDecl.init) {
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, 62 /* Comma */ , false);
                this.recordSourceMappingEnd(varDecl);
                this.writeToOutput(";");
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        };
        PullEmitter.prototype.varListCount = function () {
            return this.varListCountStack[this.varListCountStack.length - 1];
        };
        PullEmitter.prototype.emitVarDeclVar = function () {
            if (this.varListCount() >= 0) {
                this.writeToOutput("var ");
                this.setInVarBlock(-this.varListCount());
            }
            return true;
        };
        PullEmitter.prototype.onEmitVar = function () {
            if (this.varListCount() > 0) {
                this.setInVarBlock(this.varListCount() - 1);
            } else if (this.varListCount() < 0) {
                this.setInVarBlock(this.varListCount() + 1);
            }
        };
        PullEmitter.prototype.emitJavascriptVarDecl = function (varDecl, tokenId) {
            if ((varDecl.varFlags & 8 /* Ambient */ ) == 8 /* Ambient */ ) {
                this.emitAmbientVarDecl(varDecl);
                this.onEmitVar();
            } else {
                var sym = varDecl.sym;
                var hasInitializer = (varDecl.init != null);
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                if (sym && sym.isMember() && sym.container && (sym.container.kind() == 1 /* Type */ )) {
                    var type = (sym.container).type;
                    if (type.isClass() && (!TypeScript.hasFlag(sym.flags, 1024 /* ModuleMember */ ))) {
                        if (this.emitState.container != 6 /* Args */ ) {
                            if (TypeScript.hasFlag(sym.flags, 16 /* Static */ )) {
                                this.writeToOutput(sym.container.name + ".");
                            } else {
                                this.writeToOutput("this.");
                            }
                        }
                    } else if (type.hasImplementation()) {
                        if (!TypeScript.hasFlag(sym.flags, 1 /* Exported */ ) && (sym.container == this.checker.gloMod || !TypeScript.hasFlag(sym.flags, 256 /* Property */ ))) {
                            this.emitVarDeclVar();
                        } else if (TypeScript.hasFlag(varDecl.varFlags, 32 /* LocalStatic */ )) {
                            this.writeToOutput(".");
                        } else {
                            if (this.emitState.container == 2 /* DynamicModule */ ) {
                                this.writeToOutput("exports.");
                            } else {
                                this.writeToOutput(this.moduleName + ".");
                            }
                        }
                    } else {
                        if (tokenId != 56 /* OpenParen */ ) {
                            if (TypeScript.hasFlag(sym.flags, 1 /* Exported */ ) && sym.container == this.checker.gloMod) {
                                this.writeToOutput("this.");
                            } else {
                                this.emitVarDeclVar();
                            }
                        }
                    }
                } else {
                    if (tokenId != 56 /* OpenParen */ ) {
                        this.emitVarDeclVar();
                    }
                }
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                if (hasInitializer) {
                    this.writeToOutputTrimmable(" = ");
                    this.varListCountStack.push(0);
                    this.emitJavascript(varDecl.init, 62 /* Comma */ , false);
                    this.varListCountStack.pop();
                }
                this.onEmitVar();
                if ((tokenId != 56 /* OpenParen */ )) {
                    if (this.varListCount() < 0) {
                        this.writeToOutput(", ");
                    } else if (tokenId != 19 /* For */ ) {
                        this.writeToOutputTrimmable(";");
                    }
                }
                this.recordSourceMappingEnd(varDecl);
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        };
        PullEmitter.prototype.declEnclosed = function (moduleDecl) {
            if (moduleDecl == null) {
                return true;
            }
            for(var i = 0, len = this.moduleDeclList.length; i < len; i++) {
                if (this.moduleDeclList[i] == moduleDecl) {
                    return true;
                }
            }
            return false;
        };
        PullEmitter.prototype.emitJavascriptName = function (name, addThis) {
            var sym = name.sym;
            this.emitParensAndCommentsInPlace(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                if (addThis && (this.emitState.container != 6 /* Args */ ) && sym) {
                    if (sym.container && (sym.container.name != TypeScript.globalId)) {
                        if (TypeScript.hasFlag(sym.flags, 16 /* Static */ ) && (TypeScript.hasFlag(sym.flags, 256 /* Property */ ))) {
                            if (sym.declModule && TypeScript.hasFlag(sym.declModule.modFlags, 2048 /* IsDynamic */ )) {
                                this.writeToOutput("exports.");
                            } else {
                                this.writeToOutput(sym.container.name + ".");
                            }
                        } else if (sym.kind() == 2 /* Field */ ) {
                            var fieldSym = sym;
                            if (TypeScript.hasFlag(fieldSym.flags, 1024 /* ModuleMember */ )) {
                                if ((sym.container != this.checker.gloMod) && ((TypeScript.hasFlag(sym.flags, 256 /* Property */ )) || TypeScript.hasFlag(sym.flags, 1 /* Exported */ ))) {
                                    if (TypeScript.hasFlag(sym.declModule.modFlags, 2048 /* IsDynamic */ )) {
                                        this.writeToOutput("exports.");
                                    } else {
                                        this.writeToOutput(sym.container.name + ".");
                                    }
                                }
                            } else {
                                if (sym.isInstanceProperty()) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            }
                        } else if (sym.kind() == 1 /* Type */ ) {
                            if (sym.isInstanceProperty()) {
                                var typeSym = sym;
                                var type = typeSym.type;
                                if (type.call && !TypeScript.hasFlag(sym.flags, 1024 /* ModuleMember */ )) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            } else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {
                                this.writeToOutput(sym.container.name + ".");
                            }
                        }
                    } else if (sym.container == this.checker.gloMod && TypeScript.hasFlag(sym.flags, 1 /* Exported */ ) && !TypeScript.hasFlag(sym.flags, 8 /* Ambient */ ) && !((sym.isType() || sym.isMember()) && sym.declModule && TypeScript.hasFlag(sym.declModule.modFlags, 8 /* Ambient */ )) && this.emitState.container == 0 /* Prog */  && sym.declAST.nodeType != 73 /* FuncDecl */ ) {
                        this.writeToOutput("this.");
                    }
                }
                if (sym && sym.declAST && sym.declAST.nodeType == 98 /* ModuleDeclaration */  && (TypeScript.hasFlag((sym.declAST).modFlags, 2048 /* IsDynamic */ ))) {
                    var moduleDecl = sym.declAST;
                    if (TypeScript.moduleGenTarget == 1 /* Asynchronous */ ) {
                        this.writeLineToOutput("__" + this.modAliasId + "__;");
                    } else {
                        var modPath = name.actualText;
                        var isAmbient = moduleDecl.mod.symbol.declAST && TypeScript.hasFlag((moduleDecl.mod.symbol.declAST).modFlags, 8 /* Ambient */ );
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : TypeScript.quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!TypeScript.isRelative(TypeScript.stripQuotes(modPath)) ? TypeScript.quoteStr("./" + TypeScript.stripQuotes(modPath)) : modPath);
                        this.writeToOutput("require(" + modPath + ")");
                    }
                } else {
                    this.writeToOutput(name.actualText);
                }
            }
            this.recordSourceMappingEnd(name);
            this.emitParensAndCommentsInPlace(name, false);
        };
        PullEmitter.prototype.emitJavascriptStatements = function (stmts, emitEmptyBod) {
            if (stmts) {
                if (stmts.nodeType != 86 /* Block */ ) {
                    var hasContents = (stmts && (stmts.nodeType != 94 /* List */  || ((stmts).members.length > 0)));
                    if (emitEmptyBod || hasContents) {
                        var hasOnlyBlockStatement = ((stmts.nodeType == 86 /* Block */ ) || ((stmts.nodeType == 94 /* List */ ) && ((stmts).members.length == 1) && ((stmts).members[0].nodeType == 86 /* Block */ )));
                        this.recordSourceMappingStart(stmts);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput(" {");
                            this.indenter.increaseIndent();
                        }
                        this.emitJavascriptList(stmts, null, 55 /* Semicolon */ , true, false, false);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput("");
                            this.indenter.decreaseIndent();
                            this.emitIndent();
                            this.writeToOutput("}");
                        }
                        this.recordSourceMappingEnd(stmts);
                    }
                } else {
                    this.emitJavascript(stmts, 55 /* Semicolon */ , true);
                }
            } else if (emitEmptyBod) {
                this.writeToOutput("{ }");
            }
        };
        PullEmitter.prototype.emitBareJavascriptStatements = function (stmts, emitClassPropertiesAfterSuperCall) {
            if (typeof emitClassPropertiesAfterSuperCall === "undefined") { emitClassPropertiesAfterSuperCall = false; }
            if (stmts.nodeType != 86 /* Block */ ) {
                if (stmts.nodeType == 94 /* List */ ) {
                    var stmtList = stmts;
                    if ((stmtList.members.length == 2) && (stmtList.members[0].nodeType == 86 /* Block */ ) && (stmtList.members[1].nodeType == 105 /* EndCode */ )) {
                        this.emitJavascript(stmtList.members[0], 55 /* Semicolon */ , true);
                        this.writeLineToOutput("");
                    } else {
                        this.emitJavascriptList(stmts, null, 55 /* Semicolon */ , true, false, emitClassPropertiesAfterSuperCall);
                    }
                } else {
                    this.emitJavascript(stmts, 55 /* Semicolon */ , true);
                }
            } else {
                this.emitJavascript(stmts, 55 /* Semicolon */ , true);
            }
        };
        PullEmitter.prototype.recordSourceMappingNameStart = function (name) {
            if (this.sourceMapper) {
                var finalName = name;
                if (!name) {
                    finalName = "";
                } else if (this.sourceMapper.currentNameIndex.length > 0) {
                    finalName = this.sourceMapper.names[this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]] + "." + name;
                }
                this.sourceMapper.names.push(finalName);
                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);
            }
        };
        PullEmitter.prototype.recordSourceMappingNameEnd = function () {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        };
        PullEmitter.prototype.recordSourceMappingStart = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                var lineCol = {
                    line: -1,
                    col: -1
                };
                var sourceMapping = new TypeScript.SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;
                TypeScript.getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);
                sourceMapping.start.sourceColumn = lineCol.col;
                sourceMapping.start.sourceLine = lineCol.line;
                TypeScript.getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);
                sourceMapping.end.sourceColumn = lineCol.col;
                sourceMapping.end.sourceLine = lineCol.line;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        };
        PullEmitter.prototype.recordSourceMappingEnd = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                this.sourceMapper.currentMappings.pop();
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];
                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        };
        PullEmitter.prototype.Close = function () {
            if (this.sourceMapper != null) {
                TypeScript.SourceMapper.EmitSourceMapping(this.allSourceMappers);
            }
            try  {
                this.outfile.Close();
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        };
        PullEmitter.prototype.emitJavascriptList = function (ast, delimiter, tokenId, startLine, onlyStatics, emitClassPropertiesAfterSuperCall, emitPrologue, requiresExtendsBlock) {
            if (typeof emitClassPropertiesAfterSuperCall === "undefined") { emitClassPropertiesAfterSuperCall = false; }
            if (typeof emitPrologue === "undefined") { emitPrologue = false; }
            if (ast == null) {
                return;
            } else if (ast.nodeType != 94 /* List */ ) {
                this.emitPrologue(emitPrologue);
                this.emitJavascript(ast, tokenId, startLine);
            } else {
                var list = ast;
                this.emitParensAndCommentsInPlace(ast, true);
                if (list.members.length == 0) {
                    this.emitParensAndCommentsInPlace(ast, false);
                    return;
                }
                var len = list.members.length;
                for(var i = 0; i < len; i++) {
                    if (emitPrologue) {
                        if (i == 1 || !TypeScript.hasFlag(list.flags, 128 /* StrictMode */ )) {
                            this.emitPrologue(requiresExtendsBlock);
                            emitPrologue = false;
                        }
                    }
                    if (i == 1 && emitClassPropertiesAfterSuperCall) {
                        var constructorDecl = (this.thisClassNode).constructorDecl;
                        if (constructorDecl && constructorDecl.arguments) {
                            var argsLen = constructorDecl.arguments.members.length;
                            for(var iArg = 0; iArg < argsLen; iArg++) {
                                var arg = constructorDecl.arguments.members[iArg];
                                if ((arg.varFlags & 512 /* Property */ ) != 0 /* None */ ) {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(arg);
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput("this." + arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeToOutput(" = ");
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput(arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeLineToOutput(";");
                                    this.recordSourceMappingEnd(arg);
                                }
                            }
                        }
                        var nProps = (this.thisClassNode.members).members.length;
                        for(var iMember = 0; iMember < nProps; iMember++) {
                            if ((this.thisClassNode.members).members[iMember].nodeType == 75 /* VarDecl */ ) {
                                var varDecl = (this.thisClassNode.members).members[iMember];
                                if (!TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ ) && varDecl.init) {
                                    this.emitIndent();
                                    this.emitJavascriptVarDecl(varDecl, 98 /* Tilde */ );
                                    this.writeLineToOutput("");
                                }
                            }
                        }
                    }
                    var emitNode = list.members[i];
                    var isStaticDecl = (emitNode.nodeType == 73 /* FuncDecl */  && TypeScript.hasFlag((emitNode).fncFlags, 16 /* Static */ )) || (emitNode.nodeType == 75 /* VarDecl */  && TypeScript.hasFlag((emitNode).varFlags, 16 /* Static */ ));
                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {
                        continue;
                    }
                    this.emitJavascript(emitNode, tokenId, startLine);
                    if (delimiter && (i < (len - 1))) {
                        if (startLine) {
                            this.writeLineToOutput(delimiter);
                        } else {
                            this.writeToOutput(delimiter);
                        }
                    } else if (startLine && (emitNode.nodeType != 98 /* ModuleDeclaration */ ) && (emitNode.nodeType != 97 /* InterfaceDeclaration */ ) && (!((emitNode.nodeType == 75 /* VarDecl */ ) && ((((emitNode).varFlags) & 8 /* Ambient */ ) == 8 /* Ambient */ ) && (((emitNode).init) == null)) && this.varListCount() >= 0) && (emitNode.nodeType != 86 /* Block */  || (emitNode).isStatementBlock) && (emitNode.nodeType != 105 /* EndCode */ ) && (emitNode.nodeType != 73 /* FuncDecl */ )) {
                        this.writeLineToOutput("");
                    }
                }
                this.emitParensAndCommentsInPlace(ast, false);
            }
        };
        PullEmitter.prototype.emitJavascript = function (ast, tokenId, startLine) {
            if (ast == null) {
                return;
            }
            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != 94 /* List */ ) && (ast.nodeType != 86 /* Block */ )) {
                if ((ast.nodeType != 97 /* InterfaceDeclaration */ ) && (!((ast.nodeType == 75 /* VarDecl */ ) && ((((ast).varFlags) & 8 /* Ambient */ ) == 8 /* Ambient */ ) && (((ast).init) == null)) && this.varListCount() >= 0) && (ast.nodeType != 105 /* EndCode */ ) && ((ast.nodeType != 73 /* FuncDecl */ ) || (this.emitState.container != 4 /* Constructor */ ))) {
                    this.emitIndent();
                }
            }
            ast.emit(this, tokenId, startLine);
            if ((tokenId == 55 /* Semicolon */ ) && (ast.nodeType < 73 /* GeneralNode */ )) {
                this.writeToOutput(";");
            }
        };
        PullEmitter.prototype.emitPropertyAccessor = function (funcDecl, className, isProto) {
            if (!(funcDecl.accessorSymbol).hasBeenEmitted) {
                var accessorSymbol = funcDecl.accessorSymbol;
                this.emitIndent();
                this.recordSourceMappingStart(funcDecl);
                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \"" : ", \"") + funcDecl.name.actualText + "\"" + ", {");
                this.indenter.increaseIndent();
                if (accessorSymbol.getter) {
                    var getter = accessorSymbol.getter.declAST;
                    this.emitIndent();
                    this.recordSourceMappingStart(getter);
                    this.writeToOutput("get: ");
                    this.emitInnerFunction(getter, false, isProto, null, TypeScript.Emitter.shouldCaptureThis(getter), null);
                    this.writeLineToOutput(",");
                }
                if (accessorSymbol.setter) {
                    var setter = accessorSymbol.setter.declAST;
                    this.emitIndent();
                    this.recordSourceMappingStart(setter);
                    this.writeToOutput("set: ");
                    this.emitInnerFunction(setter, false, isProto, null, TypeScript.Emitter.shouldCaptureThis(setter), null);
                    this.writeLineToOutput(",");
                }
                this.emitIndent();
                this.writeLineToOutput("enumerable: true,");
                this.emitIndent();
                this.writeLineToOutput("configurable: true");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("});");
                this.recordSourceMappingEnd(funcDecl);
                accessorSymbol.hasBeenEmitted = true;
            }
        };
        PullEmitter.prototype.emitPrototypeMember = function (member, className) {
            if (member.nodeType == 73 /* FuncDecl */ ) {
                var funcDecl = member;
                if (funcDecl.isAccessor()) {
                    this.emitPropertyAccessor(funcDecl, className, true);
                } else {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");
                    this.emitInnerFunction(funcDecl, false, true, null, TypeScript.Emitter.shouldCaptureThis(funcDecl), null);
                    this.writeLineToOutput(";");
                }
            } else if (member.nodeType == 75 /* VarDecl */ ) {
                var varDecl = member;
                if (varDecl.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(varDecl);
                    this.recordSourceMappingStart(varDecl.id);
                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);
                    this.recordSourceMappingEnd(varDecl.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(varDecl.init, 63 /* Equals */ , false);
                    this.recordSourceMappingEnd(varDecl);
                    this.writeLineToOutput(";");
                }
            }
        };
        PullEmitter.prototype.emitAddBaseMethods = function (className, base, classDecl) {
            if (base.members) {
                var baseSymbol = base.symbol;
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                base.members.allMembers.map(function (key, s, c) {
                    var sym = s;
                    if ((sym.kind() == 1 /* Type */ ) && (sym).type.call) {
                        this.recordSourceMappingStart(sym.declAST);
                        this.writeLineToOutput(className + ".prototype." + sym.name + " = " + baseName + ".prototype." + sym.name + ";");
                        this.recordSourceMappingEnd(sym.declAST);
                    }
                }, null);
            }
            if (base.extendsList) {
                for(var i = 0, len = base.extendsList.length; i < len; i++) {
                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);
                }
            }
        };
        PullEmitter.prototype.emitJavascriptClass = function (classDecl) {
            if (!TypeScript.hasFlag(classDecl.varFlags, 8 /* Ambient */ )) {
                var svClassNode = this.thisClassNode;
                var i = 0;
                this.thisClassNode = classDecl;
                var className = classDecl.name.actualText;
                this.emitParensAndCommentsInPlace(classDecl, true);
                var temp = this.setContainer(3 /* Class */ );
                this.recordSourceMappingStart(classDecl);
                if (TypeScript.hasFlag(classDecl.varFlags, 1 /* Exported */ ) && classDecl.type.symbol.container == this.checker.gloMod) {
                    this.writeToOutput("this." + className);
                } else {
                    this.writeToOutput("var " + className);
                }
                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
                var baseNameDecl = null;
                var baseName = null;
                if (hasBaseClass) {
                    this.writeLineToOutput(" = (function (_super) {");
                } else {
                    this.writeLineToOutput(" = (function () {");
                }
                this.recordSourceMappingNameStart(className);
                this.indenter.increaseIndent();
                if (hasBaseClass) {
                    baseNameDecl = classDecl.extendsList.members[0];
                    baseName = baseNameDecl.nodeType == 30 /* Call */  ? (baseNameDecl).target : baseNameDecl;
                    this.emitIndent();
                    this.writeLineToOutput("__extends(" + className + ", _super);");
                }
                this.emitIndent();
                var constrDecl = classDecl.constructorDecl;
                if (constrDecl) {
                    this.emitJavascript(classDecl.constructorDecl, 56 /* OpenParen */ , false);
                } else {
                    var wroteProps = 0;
                    this.recordSourceMappingStart(classDecl);
                    this.indenter.increaseIndent();
                    this.writeToOutput("function " + classDecl.name.actualText + "() {");
                    this.recordSourceMappingNameStart("constructor");
                    if (hasBaseClass) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeLineToOutput("_super.apply(this, arguments);");
                        wroteProps++;
                    }
                    if (classDecl.varFlags & 131072 /* MustCaptureThis */ ) {
                        this.writeCaptureThisStatement(classDecl);
                    }
                    var members = (this.thisClassNode.members).members;
                    for(var i = 0; i < members.length; i++) {
                        if (members[i].nodeType == 75 /* VarDecl */ ) {
                            var varDecl = members[i];
                            if (!TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ ) && varDecl.init) {
                                this.writeLineToOutput("");
                                this.emitIndent();
                                this.emitJavascriptVarDecl(varDecl, 98 /* Tilde */ );
                                wroteProps++;
                            }
                        }
                    }
                    if (wroteProps) {
                        this.writeLineToOutput("");
                        this.indenter.decreaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("}");
                    } else {
                        this.writeLineToOutput(" }");
                        this.indenter.decreaseIndent();
                    }
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(classDecl);
                }
                var membersLen = classDecl.members.members.length;
                for(var j = 0; j < membersLen; j++) {
                    var memberDecl = classDecl.members.members[j];
                    if (memberDecl.nodeType == 73 /* FuncDecl */ ) {
                        var fn = memberDecl;
                        if (TypeScript.hasFlag(fn.fncFlags, 1024 /* Method */ ) && !fn.isSignature()) {
                            if (!TypeScript.hasFlag(fn.fncFlags, 16 /* Static */ )) {
                                this.emitPrototypeMember(fn, className);
                            } else {
                                if (fn.isAccessor()) {
                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);
                                } else {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(fn);
                                    this.writeToOutput(classDecl.name.actualText + "." + fn.name.actualText + " = ");
                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true, null, TypeScript.Emitter.shouldCaptureThis(fn), null);
                                    this.writeLineToOutput(";");
                                }
                            }
                        }
                    } else if (memberDecl.nodeType == 75 /* VarDecl */ ) {
                        var varDecl = memberDecl;
                        if (TypeScript.hasFlag(varDecl.varFlags, 16 /* Static */ )) {
                            if (varDecl.init) {
                                this.emitIndent();
                                this.recordSourceMappingStart(varDecl);
                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");
                                this.emitJavascript(varDecl.init, 63 /* Equals */ , false);
                                this.writeLineToOutput(";");
                                this.recordSourceMappingEnd(varDecl);
                            }
                        }
                    } else {
                        throw Error("We want to catch this");
                    }
                }
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeLineToOutput("return " + className + ";");
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput(")(");
                if (hasBaseClass) {
                    this.emitJavascript(baseName, 98 /* Tilde */ , false);
                }
                this.writeToOutput(");");
                this.recordSourceMappingEnd(classDecl);
                if ((temp == 1 /* Module */  || temp == 2 /* DynamicModule */ ) && TypeScript.hasFlag(classDecl.varFlags, 1 /* Exported */ )) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = temp == 1 /* Module */  ? this.moduleName : "exports";
                    this.recordSourceMappingStart(classDecl);
                    this.writeToOutput(modName + "." + className + " = " + className + ";");
                    this.recordSourceMappingEnd(classDecl);
                }
                this.emitIndent();
                this.recordSourceMappingEnd(classDecl);
                this.emitParensAndCommentsInPlace(classDecl, false);
                this.setContainer(temp);
                this.thisClassNode = svClassNode;
            }
        };
        PullEmitter.prototype.emitPrologue = function (reqInherits) {
            if (!this.extendsPrologueEmitted) {
                if (reqInherits) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
                if (this.checker.mustCaptureGlobalThis) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        };
        PullEmitter.prototype.emitSuperReference = function () {
            this.writeToOutput("_super.prototype");
        };
        PullEmitter.prototype.emitSuperCall = function (callEx) {
            if (callEx.target.nodeType == 19 /* Dot */ ) {
                var dotNode = callEx.target;
                if (dotNode.operand1.nodeType == 6 /* Super */ ) {
                    this.emitJavascript(dotNode, 56 /* OpenParen */ , false);
                    this.writeToOutput(".call(");
                    this.emitThis();
                    if (callEx.arguments && callEx.arguments.members.length > 0) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(callEx.arguments, ", ", 62 /* Comma */ , false, false, false);
                    }
                    this.writeToOutput(")");
                    return true;
                }
            }
            return false;
        };
        PullEmitter.prototype.emitThis = function () {
            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {
                this.writeToOutput("_this");
            } else {
                this.writeToOutput("this");
            }
        };
        PullEmitter.shouldCaptureThis = function shouldCaptureThis(func) {
            return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();
        };
        PullEmitter.prototype.createFile = function (fileName, useUTF8) {
            try  {
                return this.emitOptions.ioHost.createFile(fileName, useUTF8);
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        };
        return PullEmitter;
    })(TypeScript.Emitter);
    TypeScript.PullEmitter = PullEmitter;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullError = (function () {
        function PullError(offset, length, filename, message) {
            this.offset = offset;
            this.length = length;
            this.filename = filename;
            this.message = message;
            this.adjustedOffset = offset;
        }
        PullError.prototype.adjustOffset = function (pos) {
            this.adjustedOffset = this.offset + pos;
        };
        PullError.prototype.getOffset = function () {
            return this.adjustedOffset;
        };
        return PullError;
    })();
    TypeScript.PullError = PullError;    
    function getErrorsFromEnclosingDecl(enclosingDecl, errors) {
        var declErrors = enclosingDecl.getErrors();
        if (declErrors) {
            for(var i = 0; i < declErrors.length; i++) {
                errors[errors.length] = declErrors[i];
            }
        }
        var childDecls = enclosingDecl.getChildDecls();
        for(var i = 0; i < childDecls.length; i++) {
            getErrorsFromEnclosingDecl(childDecls[i], errors);
        }
    }
    TypeScript.getErrorsFromEnclosingDecl = getErrorsFromEnclosingDecl;
    var PullErrorReporter = (function () {
        function PullErrorReporter(textWriter) {
            this.textWriter = textWriter;
            this.lineCol = {
                line: 0,
                col: 0
            };
            this.locationInfoCache = {};
        }
        PullErrorReporter.prototype.setUnits = function (units) {
            this.locationInfoCache = {};
            for(var i = 0; i < units.length; i++) {
                this.locationInfoCache[units[i].filename] = units[i];
            }
        };
        PullErrorReporter.prototype.reportError = function (error) {
            var locationInfo = this.locationInfoCache[error.filename];
            if (locationInfo && locationInfo.lineMap) {
                TypeScript.getSourceLineColFromMap(this.lineCol, error.getOffset(), locationInfo.lineMap);
                this.textWriter.Write(locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): ");
            } else {
                this.textWriter.Write(error.filename + "(0,0): ");
            }
            this.textWriter.WriteLine(error.message);
        };
        PullErrorReporter.prototype.reportErrors = function (errors) {
            for(var i = 0; i < errors.length; i++) {
                this.reportError(errors[i]);
            }
        };
        return PullErrorReporter;
    })();
    TypeScript.PullErrorReporter = PullErrorReporter;    
})(TypeScript || (TypeScript = {}));
var SyntaxInformationMap = (function (_super) {
    __extends(SyntaxInformationMap, _super);
    function SyntaxInformationMap(trackParents, trackPreviousToken) {
        _super.call(this);
        this.trackParents = trackParents;
        this.trackPreviousToken = trackPreviousToken;
        this.tokenToInformation = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);
        this.elementToPosition = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);
        this._previousToken = null;
        this._previousTokenInformation = null;
        this._currentPosition = 0;
        this._elementToParent = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);
        this._parentStack = [];
        this._parentStack.push(null);
    }
    SyntaxInformationMap.create = function create(node, trackParents, trackPreviousToken) {
        var map = new SyntaxInformationMap(trackParents, trackPreviousToken);
        map.visitNode(node);
        return map;
    };
    SyntaxInformationMap.prototype.visitNode = function (node) {
        this.trackParents && this._elementToParent.add(node, ArrayUtilities.last(this._parentStack));
        this.elementToPosition.add(node, this._currentPosition);
        this.trackParents && this._parentStack.push(node);
        _super.prototype.visitNode.call(this, node);
        this.trackParents && this._parentStack.pop();
    };
    SyntaxInformationMap.prototype.visitToken = function (token) {
        this.trackParents && this._elementToParent.add(token, ArrayUtilities.last(this._parentStack));
        if (this.trackPreviousToken) {
            var tokenInformation = {
                previousToken: this._previousToken,
                nextToken: null
            };
            if (this._previousTokenInformation !== null) {
                this._previousTokenInformation.nextToken = token;
            }
            this._previousToken = token;
            this._previousTokenInformation = tokenInformation;
            this.tokenToInformation.add(token, tokenInformation);
        }
        this.elementToPosition.add(token, this._currentPosition);
        this._currentPosition += token.fullWidth();
    };
    SyntaxInformationMap.prototype.parent = function (element) {
        return this._elementToParent.get(element);
    };
    SyntaxInformationMap.prototype.fullStart = function (element) {
        return this.elementToPosition.get(element);
    };
    SyntaxInformationMap.prototype.start = function (element) {
        return this.fullStart(element) + element.leadingTriviaWidth();
    };
    SyntaxInformationMap.prototype.end = function (element) {
        return this.start(element) + element.width();
    };
    SyntaxInformationMap.prototype.previousToken = function (token) {
        return this.tokenInformation(token).previousToken;
    };
    SyntaxInformationMap.prototype.tokenInformation = function (token) {
        return this.tokenToInformation.get(token);
    };
    SyntaxInformationMap.prototype.firstTokenInLineContainingToken = function (token) {
        var current = token;
        while(true) {
            var information = this.tokenInformation(current);
            if (this.isFirstTokenInLineWorker(information)) {
                break;
            }
            current = information.previousToken;
        }
        return current;
    };
    SyntaxInformationMap.prototype.isFirstTokenInLine = function (token) {
        var information = this.tokenInformation(token);
        return this.isFirstTokenInLineWorker(information);
    };
    SyntaxInformationMap.prototype.isFirstTokenInLineWorker = function (information) {
        return information.previousToken === null || information.previousToken.hasTrailingNewLine();
    };
    return SyntaxInformationMap;
})(SyntaxWalker);
var TypeScript;
(function (TypeScript) {
    var SyntaxPositionMap = (function () {
        function SyntaxPositionMap(node) {
            this.position = 0;
            this.elementToPosition = Collections.createHashTable(2048, Collections.identityHashCode);
            this.process(node);
        }
        SyntaxPositionMap.prototype.process = function (element) {
            if (element !== null) {
                if (element.isToken()) {
                    this.elementToPosition.add(element, this.position);
                    this.position += element.fullWidth();
                } else {
                    if (element.isNode()) {
                        this.elementToPosition.add(element, this.position);
                    }
                    for(var i = 0, n = element.childCount(); i < n; i++) {
                        this.process(element.childAt(i));
                    }
                }
            }
        };
        SyntaxPositionMap.create = function create(node) {
            var map = new SyntaxPositionMap(node);
            return map;
        };
        SyntaxPositionMap.prototype.fullStart = function (element) {
            return this.elementToPosition.get(element);
        };
        SyntaxPositionMap.prototype.start = function (element) {
            return this.fullStart(element) + element.leadingTriviaWidth();
        };
        SyntaxPositionMap.prototype.end = function (element) {
            return this.start(element) + element.width();
        };
        SyntaxPositionMap.prototype.fullEnd = function (element) {
            return this.fullStart(element) + element.fullWidth();
        };
        return SyntaxPositionMap;
    })();
    TypeScript.SyntaxPositionMap = SyntaxPositionMap;    
    var SyntaxTreeToAstVisitor = (function () {
        function SyntaxTreeToAstVisitor(syntaxPositionMap, fileName, unitIndex) {
            this.syntaxPositionMap = syntaxPositionMap;
            this.fileName = fileName;
            this.unitIndex = unitIndex;
            this.nestingLevel = 0;
            this.position = 0;
            this.varLists = [];
            this.scopeLists = [];
            this.staticsLists = [];
            this.requiresExtendsBlock = false;
        }
        SyntaxTreeToAstVisitor.checkPositions = false;
        SyntaxTreeToAstVisitor.visit = function visit(sourceUnit, fileName, unitIndex) {
            var map = SyntaxTreeToAstVisitor.checkPositions ? SyntaxPositionMap.create(sourceUnit) : null;
            var visitor = new SyntaxTreeToAstVisitor(map, fileName, unitIndex);
            return sourceUnit.accept(visitor);
        };
        SyntaxTreeToAstVisitor.prototype.assertElementAtPosition = function (element) {
            if (SyntaxTreeToAstVisitor.checkPositions) {
                Debug.assert(this.position === this.syntaxPositionMap.fullStart(element));
            }
        };
        SyntaxTreeToAstVisitor.prototype.movePast = function (element) {
            if (element !== null) {
                this.assertElementAtPosition(element);
                this.position += element.fullWidth();
            }
        };
        SyntaxTreeToAstVisitor.prototype.moveTo2 = function (element1, element2) {
            if (element2 !== null) {
                this.position += Syntax.childOffset(element1, element2);
            }
        };
        SyntaxTreeToAstVisitor.prototype.moveTo3 = function (element1, element2, element3) {
            this.moveTo2(element1, element2);
            this.moveTo2(element2, element3);
        };
        SyntaxTreeToAstVisitor.prototype.setSpan = function (span, start, end) {
            span.minChar = start;
            span.limChar = end;
        };
        SyntaxTreeToAstVisitor.prototype.hasEscapeSequence = function (token) {
            return false;
        };
        SyntaxTreeToAstVisitor.prototype.valueText = function (token) {
            return token.text();
        };
        SyntaxTreeToAstVisitor.prototype.identifierFromToken = function (token, isOptional) {
            this.assertElementAtPosition(token);
            var result = null;
            if (token.fullWidth() === 0) {
                result = new TypeScript.MissingIdentifier();
                result.flags |= 8 /* Error */ ;
            } else {
                result = new TypeScript.Identifier(this.valueText(token), this.hasEscapeSequence(token));
            }
            if (isOptional) {
                result.flags |= 1024 /* OptionalName */ ;
            }
            this.setSpan(result, this.position, this.position + token.width());
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSyntaxList = function (list) {
            var result = new TypeScript.ASTList();
            var start = this.position;
            for(var i = 0, n = list.childCount(); i < n; i++) {
                result.append(list.childAt(i).accept(this));
            }
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var result = new TypeScript.ASTList();
            var start = this.position;
            for(var i = 0, n = list.childCount(); i < n; i++) {
                if (i % 2 === 0) {
                    result.append(list.childAt(i).accept(this));
                } else {
                    this.movePast(list.childAt(i));
                }
            }
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.createRef = function (text, hasEscapeSequence, minChar) {
            var id = new TypeScript.Identifier(text, hasEscapeSequence);
            id.minChar = minChar;
            return id;
        };
        SyntaxTreeToAstVisitor.prototype.pushDeclLists = function () {
            this.staticsLists.push(new TypeScript.ASTList());
            this.varLists.push(new TypeScript.ASTList());
            this.scopeLists.push(new TypeScript.ASTList());
        };
        SyntaxTreeToAstVisitor.prototype.popDeclLists = function () {
            this.staticsLists.pop();
            this.varLists.pop();
            this.scopeLists.pop();
        };
        SyntaxTreeToAstVisitor.prototype.topVarList = function () {
            return this.varLists[this.varLists.length - 1];
        };
        SyntaxTreeToAstVisitor.prototype.topScopeList = function () {
            return this.scopeLists[this.scopeLists.length - 1];
        };
        SyntaxTreeToAstVisitor.prototype.topStaticsList = function () {
            return this.staticsLists[this.staticsLists.length - 1];
        };
        SyntaxTreeToAstVisitor.prototype.convertComment = function (trivia) {
            throw Errors.notYetImplemented();
        };
        SyntaxTreeToAstVisitor.prototype.convertComments = function (triviaList) {
            var result = [];
            for(var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);
                if (trivia.isComment()) {
                    result.push(this.convertComment(trivia));
                }
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.convertLeadingComments = function (token) {
            if (!token.hasLeadingComment()) {
                return null;
            }
            return this.convertComments(token.leadingTrivia());
        };
        SyntaxTreeToAstVisitor.prototype.convertTrailingComments = function (token) {
            if (!token.hasTrailingComment()) {
                return null;
            }
            return this.convertComments(token.trailingTrivia());
        };
        SyntaxTreeToAstVisitor.prototype.visitToken = function (token) {
            this.assertElementAtPosition(token);
            var result = null;
            if (token.kind() === 35 /* ThisKeyword */ ) {
                result = new TypeScript.AST(5 /* This */ );
            } else if (token.kind() === 50 /* SuperKeyword */ ) {
                result = new TypeScript.AST(6 /* Super */ );
            } else if (token.kind() === 37 /* TrueKeyword */ ) {
                result = new TypeScript.AST(3 /* True */ );
            } else if (token.kind() === 24 /* FalseKeyword */ ) {
                result = new TypeScript.AST(4 /* False */ );
            } else if (token.kind() === 32 /* NullKeyword */ ) {
                result = new TypeScript.AST(9 /* Null */ );
            } else if (token.kind() === 14 /* StringLiteral */ ) {
                result = new TypeScript.StringLiteral(token.text());
            } else if (token.kind() === 12 /* RegularExpressionLiteral */ ) {
                result = new TypeScript.RegexLiteral(token.text());
            } else if (token.kind() === 13 /* NumericLiteral */ ) {
                var value = token.text().indexOf(".") > 0 ? parseFloat(token.text()) : parseInt(token.text());
                result = new TypeScript.NumberLiteral(value, token.text());
            } else {
                result = this.identifierFromToken(token, false);
            }
            this.setSpan(result, this.position, this.position + token.width());
            this.movePast(token);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.hasTopLevelImportOrExport = function (node) {
            for(var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var moduleElement = node.moduleElements.childAt(i);
                var firstToken = moduleElement.firstToken();
                if (firstToken !== null && firstToken.kind() === 47 /* ExportKeyword */ ) {
                    return true;
                }
                if (moduleElement.kind() === 132 /* ImportDeclaration */ ) {
                    var importDecl = moduleElement;
                    if (importDecl.moduleReference.kind() === 240 /* ExternalModuleReference */ ) {
                        return true;
                    }
                }
            }
            var firstToken = node.firstToken();
            if (firstToken.hasLeadingComment()) {
                var leadingTrivia = firstToken.leadingTrivia();
                for(var i = 0, n = leadingTrivia.count(); i < n; i++) {
                    var trivia = leadingTrivia.syntaxTriviaAt(i);
                    if (trivia.isComment()) {
                        if (TypeScript.getImplicitImport(trivia.fullText())) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        SyntaxTreeToAstVisitor.prototype.visitSourceUnit = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var members;
            this.pushDeclLists();
            var isParsingDeclareFile = TypeScript.isDSTRFile(this.fileName) || TypeScript.isDTSFile(this.fileName);
            var bod = this.visitSyntaxList(node.moduleElements);
            var topLevelMod = null;
            if (TypeScript.moduleGenTarget != 2 /* Local */  && this.hasTopLevelImportOrExport(node)) {
                var correctedFileName = TypeScript.switchToForwardSlashes(this.fileName);
                var id = new TypeScript.Identifier(correctedFileName);
                topLevelMod = new TypeScript.ModuleDeclaration(id, bod, this.topVarList(), null);
                this.setSpan(topLevelMod, start, this.position);
                topLevelMod.modFlags |= 2048 /* IsDynamic */ ;
                topLevelMod.modFlags |= 1024 /* IsWholeFile */ ;
                topLevelMod.modFlags |= 1 /* Exported */ ;
                if (isParsingDeclareFile) {
                    topLevelMod.modFlags |= 8 /* Ambient */ ;
                }
                topLevelMod.prettyName = TypeScript.getPrettyName(correctedFileName);
                bod = new TypeScript.ASTList();
                this.setSpan(bod, start, this.position);
                bod.append(topLevelMod);
            }
            var result = new TypeScript.Script(this.topVarList(), this.topScopeList());
            this.setSpan(result, start, this.position);
            this.popDeclLists();
            result.bod = bod;
            result.locationInfo = new TypeScript.LocationInfo(this.fileName, null, this.unitIndex);
            result.topLevelMod = topLevelMod;
            result.isDeclareFile = TypeScript.isDSTRFile(this.fileName) || TypeScript.isDTSFile(this.fileName);
            result.requiresExtendsBlock = this.requiresExtendsBlock;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitExternalModuleReference = function (node) {
            this.assertElementAtPosition(node);
            this.moveTo2(node, node.stringLiteral);
            var result = this.identifierFromToken(node.stringLiteral, false);
            this.movePast(node.stringLiteral);
            this.movePast(node.closeParenToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitModuleNameModuleReference = function (node) {
            this.assertElementAtPosition(node);
            return node.moduleName.accept(this);
        };
        SyntaxTreeToAstVisitor.prototype.visitClassDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var extendsList = node.extendsClause ? node.extendsClause.accept(this) : new TypeScript.ASTList();
            var implementsList = node.implementsClause ? node.implementsClause.accept(this) : new TypeScript.ASTList();
            this.movePast(node.openBraceToken);
            var members = this.visitSyntaxList(node.classElements);
            this.movePast(node.closeBraceToken);
            this.requiresExtendsBlock = this.requiresExtendsBlock || !!node.extendsClause;
            var result = new TypeScript.ClassDeclaration(name, typeParameters, members, extendsList, implementsList);
            this.setSpan(result, start, this.position);
            if (node.exportKeyword) {
                result.varFlags |= 1 /* Exported */ ;
            }
            if (node.declareKeyword) {
                result.varFlags |= 8 /* Ambient */ ;
            }
            result.varFlags |= 2048 /* Class */ ;
            for(var i = 0; i < members.members.length; i++) {
                var member = members.members[i];
                if (member.nodeType === 73 /* FuncDecl */ ) {
                    var funcDecl = member;
                    if (funcDecl.isConstructor) {
                        funcDecl.name = name;
                        funcDecl.returnTypeAnnotation = new TypeScript.TypeReference(name, 0);
                        funcDecl.classDecl = result;
                        result.constructorDecl = funcDecl;
                    }
                }
            }
            var knownMemberNames = {};
            for(var i = 0, n = node.classElements.childCount(); i < n; i++) {
                var classElement = node.classElements.childAt(i);
                if (classElement.kind() === 134 /* MemberVariableDeclaration */ ) {
                    var variableDeclaration = classElement;
                    knownMemberNames[this.valueText(variableDeclaration.variableDeclarator.identifier)] = true;
                } else if (classElement.kind() === 133 /* MemberFunctionDeclaration */ ) {
                    var functionDeclaration = classElement;
                    knownMemberNames[this.valueText(functionDeclaration.functionSignature.identifier)] = true;
                }
            }
            result.knownMemberNames = knownMemberNames;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var extendsList = node.extendsClause ? node.extendsClause.accept(this) : null;
            this.movePast(node.body.openBraceToken);
            var members = this.visitSeparatedSyntaxList(node.body.typeMembers);
            if (members.members) {
                for(var i = 0; i < members.members.length; i++) {
                    if (members.members[i].nodeType == 73 /* FuncDecl */ ) {
                        (members.members[i]).fncFlags |= 1024 /* Method */ ;
                        (members.members[i]).fncFlags |= 512 /* Signature */ ;
                    }
                }
            }
            this.movePast(node.body.closeBraceToken);
            var result = new TypeScript.InterfaceDeclaration(name, typeParameters, members, extendsList, null);
            this.setSpan(result, start, this.position);
            if (node.exportKeyword) {
                result.varFlags |= 1 /* Exported */ ;
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitExtendsClause = function (node) {
            this.assertElementAtPosition(node);
            var result = new TypeScript.ASTList();
            this.movePast(node.extendsKeyword);
            for(var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeNames.childAt(i));
                } else {
                    var type = this.visitType(node.typeNames.childAt(i));
                    if (type.nodeType === 28 /* TypeRef */ ) {
                        type = (type).term;
                    }
                    result.append(type);
                }
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitImplementsClause = function (node) {
            this.assertElementAtPosition(node);
            var result = new TypeScript.ASTList();
            this.movePast(node.implementsKeyword);
            for(var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeNames.childAt(i));
                } else {
                    var type = this.visitType(node.typeNames.childAt(i));
                    if (type.nodeType === 28 /* TypeRef */ ) {
                        type = (type).term;
                    }
                    result.append(type);
                }
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.getModuleNames = function (node) {
            var result = [];
            if (node.stringLiteral !== null) {
                result.push(this.identifierFromToken(node.stringLiteral, false));
                this.movePast(node.stringLiteral);
            } else {
                this.getModuleNamesHelper(node.moduleName, result);
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.getModuleNamesHelper = function (name, result) {
            this.assertElementAtPosition(name);
            if (name.kind() === 121 /* QualifiedName */ ) {
                var qualifiedName = name;
                this.getModuleNamesHelper(qualifiedName.left, result);
                this.movePast(qualifiedName.dotToken);
                result.push(this.identifierFromToken(qualifiedName.right, false));
                this.movePast(qualifiedName.right);
            } else {
                result.push(this.identifierFromToken(name, false));
                this.movePast(name);
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitModuleDeclaration = function (node) {
            this.assertElementAtPosition(node);
            this.pushDeclLists();
            var start = this.position;
            this.movePast(node.exportKeyword);
            this.movePast(node.declareKeyword);
            this.movePast(node.moduleKeyword);
            var names = this.getModuleNames(node);
            this.movePast(node.openBraceToken);
            var members = this.visitSyntaxList(node.moduleElements);
            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var moduleDecl = null;
            for(var i = names.length - 1; i >= 0; i--) {
                var innerName = names[i];
                var closeBraceSpan = new TypeScript.ASTSpan();
                closeBraceSpan.minChar = closeBracePosition;
                closeBraceSpan.limChar = this.position;
                var moduleDecl = new TypeScript.ModuleDeclaration(innerName, members, this.topVarList(), closeBraceSpan);
                this.setSpan(moduleDecl, start, this.position);
                if (i) {
                    moduleDecl.modFlags |= 1 /* Exported */ ;
                }
                if (i === 0) {
                    this.popDeclLists();
                }
                members = new TypeScript.ASTList();
                members.append(moduleDecl);
            }
            if (node.declareKeyword) {
                moduleDecl.modFlags |= 8 /* Ambient */ ;
            }
            if (node.exportKeyword) {
                moduleDecl.modFlags |= 1 /* Exported */ ;
            }
            return moduleDecl;
        };
        SyntaxTreeToAstVisitor.prototype.hasDotDotDotParameter = function (parameters) {
            for(var i = 0, n = parameters.nonSeparatorCount(); i < n; i++) {
                if ((parameters.nonSeparatorAt(i)).dotDotDotToken) {
                    return true;
                }
            }
            return false;
        };
        SyntaxTreeToAstVisitor.prototype.convertBlock = function (node) {
            if (!node) {
                return null;
            }
            this.movePast(node.openBraceToken);
            var statements = this.visitSyntaxList(node.statements);
            this.movePast(node.closeBraceToken);
            return statements;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo3(node, node.functionSignature, node.functionSignature.identifier);
            var name = this.identifierFromToken(node.functionSignature.identifier, !!node.functionSignature.questionToken);
            this.movePast(node.functionSignature.identifier);
            this.movePast(node.functionSignature.questionToken);
            var typeParameters = node.functionSignature.callSignature.typeParameterList === null ? null : node.functionSignature.callSignature.typeParameterList.accept(this);
            var parameters = node.functionSignature.callSignature.parameterList.accept(this);
            var returnType = node.functionSignature.callSignature.typeAnnotation ? node.functionSignature.callSignature.typeAnnotation.accept(this) : null;
            this.pushDeclLists();
            var bod = this.convertBlock(node.block);
            if (bod) {
                bod.append(new TypeScript.EndCode());
            }
            this.movePast(node.semicolonToken);
            var funcDecl = new TypeScript.FuncDecl(name, bod, false, typeParameters, parameters, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(funcDecl, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);
            funcDecl.variableArgList = this.hasDotDotDotParameter(node.functionSignature.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;
            funcDecl.variableArgList = this.hasDotDotDotParameter(node.functionSignature.callSignature.parameterList.parameters);
            if (node.exportKeyword) {
                funcDecl.fncFlags |= 1 /* Exported */ ;
            }
            if (node.declareKeyword) {
                funcDecl.fncFlags |= 8 /* Ambient */ ;
            }
            if (node.semicolonToken) {
                funcDecl.fncFlags |= 512 /* Signature */ ;
            }
            return funcDecl;
        };
        SyntaxTreeToAstVisitor.prototype.visitEnumDeclaration = function (enumDeclaration) {
            this.assertElementAtPosition(enumDeclaration);
            this.moveTo2(enumDeclaration, enumDeclaration.identifier);
            var name = this.identifierFromToken(enumDeclaration.identifier, false);
            this.movePast(enumDeclaration.identifier);
            this.pushDeclLists();
            this.movePast(enumDeclaration.openBraceToken);
            var members = new TypeScript.ASTList();
            var mapDecl = new TypeScript.VarDecl(new TypeScript.Identifier("_map"), 0);
            mapDecl.varFlags |= 1 /* Exported */ ;
            mapDecl.varFlags |= 2 /* Private */ ;
            mapDecl.varFlags |= (512 /* Property */  | 4 /* Public */ );
            mapDecl.init = new TypeScript.UnaryExpression(10 /* ArrayLit */ , null);
            members.append(mapDecl);
            var lastValue = null;
            var memberNames = [];
            var start = this.position;
            for(var i = 0, n = enumDeclaration.variableDeclarators.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(enumDeclaration.variableDeclarators.childAt(i));
                } else {
                    var variableDeclarator = enumDeclaration.variableDeclarators.childAt(i);
                    var memberName = this.identifierFromToken(variableDeclarator.identifier, false);
                    this.movePast(variableDeclarator.identifier);
                    var memberValue = null;
                    var memberStart = this.position;
                    if (variableDeclarator.equalsValueClause !== null) {
                        memberValue = variableDeclarator.equalsValueClause.accept(this);
                        lastValue = memberValue;
                    } else {
                        if (lastValue == null) {
                            memberValue = new TypeScript.NumberLiteral(0, "0");
                            lastValue = memberValue;
                        } else {
                            var nextValue = lastValue.value + 1;
                            memberValue = new TypeScript.NumberLiteral(nextValue, nextValue.toString());
                            lastValue = memberValue;
                        }
                        var map = new TypeScript.BinaryExpression(32 /* Asg */ , new TypeScript.BinaryExpression(29 /* Index */ , new TypeScript.Identifier("_map"), memberValue), new TypeScript.StringLiteral('"' + memberName.actualText + '"'));
                        members.append(map);
                    }
                    var member = new TypeScript.VarDecl(memberName, this.nestingLevel);
                    member.init = memberValue;
                    member.typeExpr = new TypeScript.TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);
                    member.varFlags |= (1024 /* Readonly */  | 512 /* Property */ );
                    this.setSpan(member, memberStart, this.position);
                    if (memberValue.nodeType == 24 /* NumberLit */ ) {
                        member.varFlags |= 65536 /* Constant */ ;
                    } else if (memberValue.nodeType === 63 /* Lsh */ ) {
                        var binop = memberValue;
                        if (binop.operand1.nodeType === 24 /* NumberLit */  && binop.operand2.nodeType === 24 /* NumberLit */ ) {
                            member.varFlags |= 65536 /* Constant */ ;
                        }
                    } else if (memberValue.nodeType === 25 /* Name */ ) {
                        var nameNode = memberValue;
                        for(var j = 0; j < memberNames.length; j++) {
                            var memberName = memberNames[j];
                            if (memberName.text === nameNode.text) {
                                member.varFlags |= 65536 /* Constant */ ;
                                break;
                            }
                        }
                    }
                    members.append(member);
                    member.varFlags |= 1 /* Exported */ ;
                }
            }
            this.movePast(enumDeclaration.closeBraceToken);
            var endingToken = new TypeScript.ASTSpan();
            var modDecl = new TypeScript.ModuleDeclaration(name, members, this.topVarList(), endingToken);
            modDecl.modFlags |= 256 /* IsEnum */ ;
            if (enumDeclaration.exportKeyword) {
                modDecl.modFlags |= 1 /* Exported */ ;
            }
            this.setSpan(modDecl, start, this.position);
            this.popDeclLists();
            return modDecl;
        };
        SyntaxTreeToAstVisitor.prototype.visitImportDeclaration = function (node) {
            this.assertElementAtPosition(node);
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.equalsToken);
            var alias = node.moduleReference.accept(this);
            this.movePast(node.semicolonToken);
            var importDecl = new TypeScript.ImportDeclaration(name, alias);
            importDecl.isDynamicImport = node.moduleReference.kind() === 240 /* ExternalModuleReference */ ;
            return importDecl;
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.variableDeclaration);
            var varList = node.variableDeclaration.accept(this);
            this.movePast(node.semicolonToken);
            if (varList.nodeType === 75 /* VarDecl */ ) {
                varDecl = varList;
                varList = new TypeScript.ASTList();
                varList.append(varDecl);
            }
            for(var i = 0, n = varList.members.length; i < n; i++) {
                var varDecl = varList.members[i];
                if (node.exportKeyword) {
                    varDecl.varFlags |= 1 /* Exported */ ;
                }
                if (node.declareKeyword) {
                    varDecl.varFlags |= 8 /* Ambient */ ;
                }
            }
            if (node.variableDeclaration.variableDeclarators.nonSeparatorCount() === 1) {
                return varList.members[0];
            } else {
                var result = new TypeScript.Block(varList, false);
                this.setSpan(result, start, this.position);
                return result;
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableDeclaration = function (node) {
            this.assertElementAtPosition(node);
            this.moveTo2(node, node.variableDeclarators);
            var variableDecls = this.visitSeparatedSyntaxList(node.variableDeclarators);
            for(var i = 0; i < variableDecls.members.length; i++) {
                (variableDecls.members[i]).nestingLevel = i;
            }
            if (variableDecls.members.length === 1) {
                return variableDecls.members[0];
            }
            return variableDecls;
        };
        SyntaxTreeToAstVisitor.prototype.visitVariableDeclarator = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;
            var result = new TypeScript.VarDecl(name, 0);
            this.setSpan(result, start, this.position);
            this.topVarList().append(result);
            result.typeExpr = typeExpr;
            result.init = init;
            if (init && init.nodeType == 73 /* FuncDecl */ ) {
                var funcDecl = init;
                funcDecl.hint = name.actualText;
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitEqualsValueClause = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.equalsToken);
            return node.value.accept(this);
        };
        SyntaxTreeToAstVisitor.prototype.getUnaryExpressionNodeType = function (kind) {
            switch(kind) {
                case 161 /* PlusExpression */ :
                    return 14 /* Pos */ ;
                case 162 /* NegateExpression */ :
                    return 15 /* Neg */ ;
                case 163 /* BitwiseNotExpression */ :
                    return 66 /* Not */ ;
                case 164 /* LogicalNotExpression */ :
                    return 67 /* LogNot */ ;
                case 165 /* PreIncrementExpression */ :
                    return 68 /* IncPre */ ;
                case 166 /* PreDecrementExpression */ :
                    return 69 /* DecPre */ ;
                default:
                    throw Errors.invalidOperation();
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.operatorToken);
            var operand = node.operand.accept(this);
            var result = new TypeScript.UnaryExpression(this.getUnaryExpressionNodeType(node.kind()), operand);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.openBracketToken);
            var expressions = this.visitSeparatedSyntaxList(node.expressions);
            this.movePast(node.closeBracketToken);
            if (node.expressions.childCount() > 0 && node.expressions.childAt(node.expressions.childCount() - 1).kind() === 79 /* CommaToken */ ) {
                expressions.append(new TypeScript.AST(2 /* EmptyExpr */ ));
            }
            var result = new TypeScript.UnaryExpression(10 /* ArrayLit */ , expressions);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitOmittedExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var result = new TypeScript.AST(2 /* EmptyExpr */ );
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.openParenToken);
            var result = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            result.isParenthesized = true;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.getArrowFunctionStatements = function (body) {
            var statements = null;
            if (body.kind() === 143 /* Block */ ) {
                var block = body;
                statements = this.convertBlock(block);
            } else {
                statements = new TypeScript.ASTList();
                var expr = body.accept(this);
                var retStmt = new TypeScript.ReturnStatement();
                retStmt.returnExpression = expr;
                statements.append(retStmt);
            }
            statements.append(new TypeScript.EndCode());
            return statements;
        };
        SyntaxTreeToAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.equalsGreaterThanToken);
            var parameters = new TypeScript.ASTList();
            parameters.append(new TypeScript.ArgDecl(identifier));
            this.pushDeclLists();
            var statements = this.getArrowFunctionStatements(node.body);
            var result = new TypeScript.FuncDecl(null, statements, false, null, parameters, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);
            result.returnTypeAnnotation = null;
            result.fncFlags |= 131072 /* IsFunctionExpression */ ;
            result.fncFlags |= 32768 /* IsFatArrowFunction */ ;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
            this.movePast(node.equalsGreaterThanToken);
            this.pushDeclLists();
            var statements = this.getArrowFunctionStatements(node.body);
            var result = new TypeScript.FuncDecl(null, statements, false, typeParameters, parameters, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);
            result.returnTypeAnnotation = returnType;
            result.fncFlags |= 131072 /* IsFunctionExpression */ ;
            result.fncFlags |= 32768 /* IsFatArrowFunction */ ;
            result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitType = function (type) {
            this.assertElementAtPosition(type);
            if (type.isToken()) {
                var typeToken = type;
                var start = this.position;
                var identifier = this.identifierFromToken(typeToken, false);
                this.movePast(typeToken);
                var result = new TypeScript.TypeReference(identifier, 0);
                this.setSpan(result, start, this.position);
                return result;
            } else {
                return type.accept(this);
            }
        };
        SyntaxTreeToAstVisitor.prototype.visitQualifiedName = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var left = this.visitType(node.left);
            this.movePast(node.dotToken);
            var right = this.identifierFromToken(node.right, false);
            this.movePast(node.right);
            if (left.nodeType === 28 /* TypeRef */ ) {
                left = (left).term;
            }
            var result = new TypeScript.BinaryExpression(19 /* Dot */ , left, right);
            this.setSpan(result, start, this.position);
            return new TypeScript.TypeReference(result, 0);
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeArgumentList = function (node) {
            this.assertElementAtPosition(node);
            var result = new TypeScript.ASTList();
            this.movePast(node.lessThanToken);
            for(var i = 0, n = node.typeArguments.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeArguments.childAt(i));
                } else {
                    result.append(this.visitType(node.typeArguments.childAt(i)));
                }
            }
            this.movePast(node.greaterThanToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructorType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.newKeyword);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;
            var result = new TypeScript.FuncDecl(null, null, false, typeParameters, parameters, null, null, null, 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            result.returnTypeAnnotation = returnType;
            result.fncFlags |= 512 /* Signature */ ;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            result.fncFlags |= 8192 /* ConstructMember */ ;
            result.flags |= 4096 /* TypeReference */ ;
            result.hint = "_construct";
            result.classDecl = null;
            var typeRef = new TypeScript.TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);
            return typeRef;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;
            var result = new TypeScript.FuncDecl(null, null, false, typeParameters, parameters, null, null, null, 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            result.returnTypeAnnotation = returnType;
            result.fncFlags |= 512 /* Signature */ ;
            result.flags |= 4096 /* TypeReference */ ;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            var typeRef = new TypeScript.TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);
            return typeRef;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.openBraceToken);
            var typeMembers = this.visitSeparatedSyntaxList(node.typeMembers);
            this.movePast(node.closeBraceToken);
            var result = new TypeScript.InterfaceDeclaration(new TypeScript.Identifier("_anonymous"), null, typeMembers, null, null);
            result.flags |= 4096 /* TypeReference */ ;
            this.setSpan(result, start, this.position);
            var typeRef = new TypeScript.TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);
            return typeRef;
        };
        SyntaxTreeToAstVisitor.prototype.visitArrayType = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var underlying = this.visitType(node.type);
            this.movePast(node.openBracketToken);
            this.movePast(node.closeBracketToken);
            var result = null;
            if (underlying.nodeType === 28 /* TypeRef */ ) {
                result = underlying;
                result.arrayCount++;
            } else {
                result = new TypeScript.TypeReference(underlying, 1);
            }
            result.flags |= 4096 /* TypeReference */ ;
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitGenericType = function (node) {
            this.assertElementAtPosition(node);
            var underlying = this.visitType(node.name);
            var typeArguments = node.typeArgumentList.accept(this);
            if (underlying.nodeType === 28 /* TypeRef */ ) {
                underlying = (underlying).term;
            }
            var genericType = new TypeScript.GenericType(underlying, typeArguments);
            genericType.flags |= 4096 /* TypeReference */ ;
            return new TypeScript.TypeReference(genericType, 0);
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeAnnotation = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.colonToken);
            return this.visitType(node.type);
        };
        SyntaxTreeToAstVisitor.prototype.visitBlock = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var statements = this.convertBlock(node);
            var result = new TypeScript.Block(statements, true);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParameter = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.identifier);
            var identifier = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;
            var result = new TypeScript.ArgDecl(identifier);
            this.setSpan(result, start, this.position);
            result.isOptional = !!node.questionToken;
            result.init = init;
            result.typeExpr = typeExpr;
            if (node.publicOrPrivateKeyword) {
                result.varFlags |= 512 /* Property */ ;
                if (node.publicOrPrivateKeyword.kind() === 57 /* PublicKeyword */ ) {
                    result.varFlags |= 4 /* Public */ ;
                } else {
                    result.varFlags |= 2 /* Private */ ;
                }
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var expression = node.expression.accept(this);
            this.movePast(node.dotToken);
            var name = this.identifierFromToken(node.name, false);
            this.movePast(node.name);
            var result = new TypeScript.BinaryExpression(19 /* Dot */ , expression, name);
            this.setSpan(result, start, this.position);
            expression.flags |= 32 /* DotLHS */ ;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var operand = node.operand.accept(this);
            this.movePast(node.operatorToken);
            var result = new TypeScript.UnaryExpression(node.kind() === 207 /* PostIncrementExpression */  ? 70 /* IncPost */  : 71 /* DecPost */ , operand);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitElementAccessExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var expression = node.expression.accept(this);
            this.movePast(node.openBracketToken);
            var argumentExpression = node.argumentExpression.accept(this);
            this.movePast(node.closeBracketToken);
            var result = new TypeScript.BinaryExpression(29 /* Index */ , expression, argumentExpression);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.convertArgumentListArguments = function (node) {
            if (node === null) {
                return null;
            }
            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.arguments);
            this.movePast(node.closeParenToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitInvocationExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var expression = node.expression.accept(this);
            var typeArguments = node.argumentList.typeArgumentList !== null ? node.argumentList.typeArgumentList.accept(this) : null;
            var argumentList = this.convertArgumentListArguments(node.argumentList);
            var result = new TypeScript.CallExpression(30 /* Call */ , expression, typeArguments, argumentList);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitArgumentList = function (node) {
            throw Errors.invalidOperation();
        };
        SyntaxTreeToAstVisitor.prototype.getBinaryExpressionNodeType = function (node) {
            switch(node.kind()) {
                case 170 /* CommaExpression */ :
                    return 13 /* Comma */ ;
                case 171 /* AssignmentExpression */ :
                    return 32 /* Asg */ ;
                case 172 /* AddAssignmentExpression */ :
                    return 33 /* AsgAdd */ ;
                case 173 /* SubtractAssignmentExpression */ :
                    return 34 /* AsgSub */ ;
                case 174 /* MultiplyAssignmentExpression */ :
                    return 36 /* AsgMul */ ;
                case 175 /* DivideAssignmentExpression */ :
                    return 35 /* AsgDiv */ ;
                case 176 /* ModuloAssignmentExpression */ :
                    return 37 /* AsgMod */ ;
                case 177 /* AndAssignmentExpression */ :
                    return 38 /* AsgAnd */ ;
                case 178 /* ExclusiveOrAssignmentExpression */ :
                    return 39 /* AsgXor */ ;
                case 179 /* OrAssignmentExpression */ :
                    return 40 /* AsgOr */ ;
                case 180 /* LeftShiftAssignmentExpression */ :
                    return 41 /* AsgLsh */ ;
                case 181 /* SignedRightShiftAssignmentExpression */ :
                    return 42 /* AsgRsh */ ;
                case 182 /* UnsignedRightShiftAssignmentExpression */ :
                    return 43 /* AsgRs2 */ ;
                case 184 /* LogicalOrExpression */ :
                    return 45 /* LogOr */ ;
                case 185 /* LogicalAndExpression */ :
                    return 46 /* LogAnd */ ;
                case 186 /* BitwiseOrExpression */ :
                    return 47 /* Or */ ;
                case 187 /* BitwiseExclusiveOrExpression */ :
                    return 48 /* Xor */ ;
                case 188 /* BitwiseAndExpression */ :
                    return 49 /* And */ ;
                case 189 /* EqualsWithTypeConversionExpression */ :
                    return 50 /* Eq */ ;
                case 190 /* NotEqualsWithTypeConversionExpression */ :
                    return 51 /* Ne */ ;
                case 191 /* EqualsExpression */ :
                    return 52 /* Eqv */ ;
                case 192 /* NotEqualsExpression */ :
                    return 53 /* NEqv */ ;
                case 193 /* LessThanExpression */ :
                    return 54 /* Lt */ ;
                case 194 /* GreaterThanExpression */ :
                    return 56 /* Gt */ ;
                case 195 /* LessThanOrEqualExpression */ :
                    return 55 /* Le */ ;
                case 196 /* GreaterThanOrEqualExpression */ :
                    return 57 /* Ge */ ;
                case 197 /* InstanceOfExpression */ :
                    return 22 /* InstOf */ ;
                case 198 /* InExpression */ :
                    return 18 /* In */ ;
                case 199 /* LeftShiftExpression */ :
                    return 63 /* Lsh */ ;
                case 200 /* SignedRightShiftExpression */ :
                    return 64 /* Rsh */ ;
                case 201 /* UnsignedRightShiftExpression */ :
                    return 65 /* Rs2 */ ;
                case 202 /* MultiplyExpression */ :
                    return 60 /* Mul */ ;
                case 203 /* DivideExpression */ :
                    return 61 /* Div */ ;
                case 204 /* ModuloExpression */ :
                    return 62 /* Mod */ ;
                case 205 /* AddExpression */ :
                    return 58 /* Add */ ;
                case 206 /* SubtractExpression */ :
                    return 59 /* Sub */ ;
            }
            throw Errors.invalidOperation();
        };
        SyntaxTreeToAstVisitor.prototype.visitBinaryExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var nodeType = this.getBinaryExpressionNodeType(node);
            var left = node.left.accept(this);
            this.movePast(node.operatorToken);
            var right = node.right.accept(this);
            var result = new TypeScript.BinaryExpression(nodeType, left, right);
            this.setSpan(result, start, this.position);
            if (right.nodeType === 73 /* FuncDecl */ ) {
                var id = left.nodeType === 19 /* Dot */  ? (left).operand2 : left;
                var idHint = id.nodeType === 25 /* Name */  ? id.actualText : null;
                var funcDecl = right;
                funcDecl.hint = idHint;
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConditionalExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var condition = node.condition.accept(this);
            this.movePast(node.questionToken);
            var whenTrue = node.whenTrue.accept(this);
            this.movePast(node.colonToken);
            var whenFalse = node.whenFalse.accept(this);
            var result = new TypeScript.ConditionalExpression(condition, whenTrue, whenFalse);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructSignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.newKeyword);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
            var result = new TypeScript.FuncDecl(null, new TypeScript.ASTList(), false, typeParameters, parameters, new TypeScript.ASTList(), new TypeScript.ASTList(), new TypeScript.ASTList(), 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            result.returnTypeAnnotation = returnType;
            result.hint = "_construct";
            result.fncFlags |= 8192 /* ConstructMember */ ;
            result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            var scopeList = this.topScopeList();
            scopeList.append(result);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionSignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var name = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);
            var typeParameters = node.callSignature.typeParameterList ? node.callSignature.typeParameterList.accept(this) : null;
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
            var funcDecl = new TypeScript.FuncDecl(name, new TypeScript.ASTList(), false, typeParameters, parameters, new TypeScript.ASTList(), new TypeScript.ASTList(), new TypeScript.ASTList(), 73 /* FuncDecl */ );
            this.setSpan(funcDecl, start, this.position);
            funcDecl.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;
            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);
            return funcDecl;
        };
        SyntaxTreeToAstVisitor.prototype.visitIndexSignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.openBracketToken);
            var parameter = node.parameter.accept(this);
            this.movePast(node.closeBracketToken);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var name = new TypeScript.Identifier("__item");
            this.setSpan(name, start, start);
            var parameters = new TypeScript.ASTList();
            parameters.append(parameter);
            var result = new TypeScript.FuncDecl(name, new TypeScript.ASTList(), false, null, parameters, new TypeScript.ASTList(), new TypeScript.ASTList(), new TypeScript.ASTList(), 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            result.variableArgList = !!node.parameter.dotDotDotToken;
            result.returnTypeAnnotation = returnType;
            result.fncFlags |= 65536 /* IndexerMember */ ;
            var scopeList = this.topScopeList();
            scopeList.append(result);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitPropertySignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var name = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var result = new TypeScript.VarDecl(name, 0);
            this.setSpan(result, start, this.position);
            result.typeExpr = typeExpr;
            result.varFlags |= 512 /* Property */ ;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitParameterList = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.parameters);
            this.movePast(node.closeParenToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCallSignature = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var result = new TypeScript.FuncDecl(null, new TypeScript.ASTList(), false, typeParameters, parameters, new TypeScript.ASTList(), new TypeScript.ASTList(), new TypeScript.ASTList(), 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            result.returnTypeAnnotation = returnType;
            result.hint = "_call";
            result.fncFlags |= 4096 /* CallMember */ ;
            var scopeList = this.topScopeList();
            scopeList.append(result);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeParameterList = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.lessThanToken);
            var result = this.visitSeparatedSyntaxList(node.typeParameters);
            this.movePast(node.greaterThanToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeParameter = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var constraint = node.constraint ? node.constraint.accept(this) : null;
            var result = new TypeScript.TypeParameter(identifier, constraint);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstraint = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.extendsKeyword);
            return this.visitType(node.type);
        };
        SyntaxTreeToAstVisitor.prototype.visitIfStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var thenBod = node.statement.accept(this);
            var elseBod = node.elseClause ? node.elseClause.accept(this) : null;
            var result = new TypeScript.IfStatement(condition);
            this.setSpan(result, start, this.position);
            result.thenBod = thenBod;
            result.elseBod = elseBod;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitElseClause = function (node) {
            this.assertElementAtPosition(node);
            this.movePast(node.elseKeyword);
            return node.statement.accept(this);
        };
        SyntaxTreeToAstVisitor.prototype.visitExpressionStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);
            var result = expression;
            this.setSpan(result, start, this.position);
            result.flags |= 64 /* IsStatement */ ;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.parameterList);
            var parameters = node.parameterList.accept(this);
            this.pushDeclLists();
            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new TypeScript.EndCode());
            }
            this.movePast(node.semicolonToken);
            var result = new TypeScript.FuncDecl(null, statements, true, null, parameters, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            if (node.semicolonToken) {
                result.fncFlags |= 512 /* Signature */ ;
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo3(node, node.functionSignature, node.functionSignature.identifier);
            var name = this.identifierFromToken(node.functionSignature.identifier, !!node.functionSignature.questionToken);
            this.movePast(node.functionSignature.identifier);
            this.movePast(node.functionSignature.questionToken);
            var typeParameters = node.functionSignature.callSignature.typeParameterList === null ? null : node.functionSignature.callSignature.typeParameterList.accept(this);
            var parameters = node.functionSignature.callSignature.parameterList.accept(this);
            var returnType = node.functionSignature.callSignature.typeAnnotation ? node.functionSignature.callSignature.typeAnnotation.accept(this) : null;
            this.pushDeclLists();
            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new TypeScript.EndCode());
            }
            this.movePast(node.semicolonToken);
            var result = new TypeScript.FuncDecl(name, statements, false, typeParameters, parameters, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);
            result.variableArgList = this.hasDotDotDotParameter(node.functionSignature.callSignature.parameterList.parameters);
            result.returnTypeAnnotation = returnType;
            if (node.semicolonToken) {
                result.fncFlags |= 512 /* Signature */ ;
            }
            if (node.publicOrPrivateKeyword) {
                if (node.publicOrPrivateKeyword.kind() === 55 /* PrivateKeyword */ ) {
                    result.fncFlags |= 2 /* Private */ ;
                } else {
                    result.fncFlags |= 4 /* Public */ ;
                }
            }
            if (node.staticKeyword) {
                result.fncFlags |= 16 /* Static */ ;
            }
            result.fncFlags |= 1024 /* Method */ ;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberAccessorDeclaration = function (node, typeAnnotation) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var parameters = node.parameterList.accept(this);
            var returnType = typeAnnotation ? typeAnnotation.accept(this) : null;
            this.pushDeclLists();
            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new TypeScript.EndCode());
            }
            var result = new TypeScript.FuncDecl(name, statements, false, null, parameters, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(result, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            result.returnTypeAnnotation = returnType;
            if (node.publicOrPrivateKeyword) {
                if (node.publicOrPrivateKeyword.kind() === 55 /* PrivateKeyword */ ) {
                    result.fncFlags |= 2 /* Private */ ;
                } else {
                    result.fncFlags |= 4 /* Public */ ;
                }
            }
            if (node.staticKeyword) {
                result.fncFlags |= 16 /* Static */ ;
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var result = this.visitMemberAccessorDeclaration(node, node.typeAnnotation);
            result.fncFlags |= 64 /* GetAccessor */ ;
            result.hint = "get" + result.name.actualText;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            this.assertElementAtPosition(node);
            var result = this.visitMemberAccessorDeclaration(node, null);
            result.fncFlags |= 128 /* SetAccessor */ ;
            result.hint = "set" + result.name.actualText;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            this.assertElementAtPosition(node);
            this.moveTo3(node, node.variableDeclarator, node.variableDeclarator.identifier);
            var name = this.identifierFromToken(node.variableDeclarator.identifier, false);
            this.movePast(node.variableDeclarator.identifier);
            var typeExpr = node.variableDeclarator.typeAnnotation ? node.variableDeclarator.typeAnnotation.accept(this) : null;
            var init = node.variableDeclarator.equalsValueClause ? node.variableDeclarator.equalsValueClause.accept(this) : null;
            this.movePast(node.semicolonToken);
            var varDecl = new TypeScript.VarDecl(name, 0);
            this.setSpan(varDecl, name.minChar, name.limChar);
            varDecl.typeExpr = typeExpr;
            varDecl.init = init;
            if (node.staticKeyword) {
                varDecl.varFlags |= 16 /* Static */ ;
            }
            if (node.publicOrPrivateKeyword) {
                if (node.publicOrPrivateKeyword.kind() === 55 /* PrivateKeyword */ ) {
                    varDecl.varFlags |= 2 /* Private */ ;
                } else {
                    varDecl.varFlags |= 4 /* Public */ ;
                }
            }
            varDecl.varFlags |= 512 /* Property */ ;
            return varDecl;
        };
        SyntaxTreeToAstVisitor.prototype.visitThrowStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.throwKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.UnaryExpression(80 /* Throw */ , expression);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitReturnStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.returnKeyword);
            var expression = node.expression ? node.expression.accept(this) : null;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.ReturnStatement();
            this.setSpan(result, start, this.position);
            result.returnExpression = expression;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.newKeyword);
            var expression = node.expression.accept(this);
            var typeArgumentList = node.argumentList === null || node.argumentList.typeArgumentList === null ? null : node.argumentList.typeArgumentList.accept(this);
            var argumentList = this.convertArgumentListArguments(node.argumentList);
            var result = new TypeScript.CallExpression(31 /* New */ , expression, typeArgumentList, argumentList);
            this.setSpan(result, start, this.position);
            if (expression.nodeType === 28 /* TypeRef */ ) {
                var typeRef = expression;
                if (typeRef.arrayCount === 0) {
                    var term = typeRef.term;
                    if (term.nodeType === 19 /* Dot */  || term.nodeType === 25 /* Name */ ) {
                        expression = term;
                    }
                }
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSwitchStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.switchKeyword);
            this.movePast(node.openParenToken);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var closeParenPosition = this.position;
            this.movePast(node.openBraceToken);
            var result = new TypeScript.SwitchStatement(expression);
            this.setSpan(result, start, this.position);
            result.statement.minChar = start;
            result.statement.limChar = closeParenPosition;
            result.caseList = new TypeScript.ASTList();
            for(var i = 0, n = node.switchClauses.childCount(); i < n; i++) {
                var switchClause = node.switchClauses.childAt(i);
                var translated = switchClause.accept(this);
                if (switchClause.kind() === 231 /* DefaultSwitchClause */ ) {
                    result.defaultCase = translated;
                }
                result.caseList.append(translated);
            }
            this.movePast(node.closeBraceToken);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.caseKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);
            var result = new TypeScript.CaseStatement();
            this.setSpan(result, start, this.position);
            result.expr = expression;
            result.body = statements;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.defaultKeyword);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);
            var result = new TypeScript.CaseStatement();
            this.setSpan(result, start, this.position);
            result.body = statements;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitBreakStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.breakKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.Jump(78 /* Break */ );
            this.setSpan(result, start, this.position);
            if (node.identifier !== null) {
                result.target = this.valueText(node.identifier);
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitContinueStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.continueKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.Jump(79 /* Continue */ );
            this.setSpan(result, start, this.position);
            if (node.identifier !== null) {
                result.target = this.valueText(node.identifier);
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitForStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.initializer ? node.initializer.accept(this) : null;
            this.movePast(node.firstSemicolonToken);
            var cond = node.condition ? node.condition.accept(this) : null;
            this.movePast(node.secondSemicolonToken);
            var incr = node.incrementor ? node.incrementor.accept(this) : null;
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);
            var result = new TypeScript.ForStatement(init);
            this.setSpan(result, start, this.position);
            result.cond = cond;
            result.incr = incr;
            result.body = body;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitForInStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.left.accept(this);
            this.movePast(node.inKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);
            var result = new TypeScript.ForInStatement(init, expression);
            this.setSpan(result, start, this.position);
            result.body = body;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitWhileStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);
            var result = new TypeScript.WhileStatement(condition);
            this.setSpan(result, start, this.position);
            result.body = statement;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitWithStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);
            var result = new TypeScript.WithStatement(condition);
            this.setSpan(result, start, this.position);
            result.body = statement;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitCastExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.lessThanToken);
            var castTerm = this.visitType(node.type);
            this.movePast(node.greaterThanToken);
            var expression = node.expression.accept(this);
            var result = new TypeScript.UnaryExpression(72 /* TypeAssertion */ , expression);
            this.setSpan(result, start, this.position);
            result.castTerm = castTerm;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.openBraceToken);
            var propertyAssignments = this.visitSeparatedSyntaxList(node.propertyAssignments);
            this.movePast(node.closeBraceToken);
            var result = new TypeScript.UnaryExpression(11 /* ObjectLit */ , propertyAssignments);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var left = node.propertyName.accept(this);
            this.movePast(node.colonToken);
            var right = node.expression.accept(this);
            var result = new TypeScript.BinaryExpression(74 /* Member */ , left, right);
            this.setSpan(result, start, this.position);
            if (right.nodeType == 73 /* FuncDecl */ ) {
                var funcDecl = right;
                funcDecl.hint = left.text;
            }
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            this.movePast(node.closeParenToken);
            this.pushDeclLists();
            var statements = this.convertBlock(node.block);
            statements.append(new TypeScript.EndCode());
            var funcDecl = new TypeScript.FuncDecl(name, statements, false, null, new TypeScript.ASTList(), this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(funcDecl, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);
            funcDecl.fncFlags |= 64 /* GetAccessor */ ;
            funcDecl.fncFlags |= 131072 /* IsFunctionExpression */ ;
            funcDecl.hint = "get" + node.propertyName.text();
            var result = new TypeScript.BinaryExpression(74 /* Member */ , name, funcDecl);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.moveTo2(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            var parameterName = this.identifierFromToken(node.parameterName, false);
            this.movePast(node.parameterName);
            this.movePast(node.closeParenToken);
            var parameter = new TypeScript.ArgDecl(parameterName);
            this.setSpan(parameter, parameterName.minChar, parameter.limChar);
            var parameters = new TypeScript.ASTList();
            parameters.append(parameter);
            this.pushDeclLists();
            var statements = this.convertBlock(node.block);
            statements.append(new TypeScript.EndCode());
            var funcDecl = new TypeScript.FuncDecl(name, statements, false, null, parameters, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(funcDecl, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);
            funcDecl.fncFlags |= 128 /* SetAccessor */ ;
            funcDecl.fncFlags |= 131072 /* IsFunctionExpression */ ;
            funcDecl.hint = "set" + node.propertyName.text();
            var result = new TypeScript.BinaryExpression(74 /* Member */ , name, funcDecl);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFunctionExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.functionKeyword);
            var name = node.identifier === null ? null : this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
            this.pushDeclLists();
            var bod = this.convertBlock(node.block);
            if (bod) {
                bod.append(new TypeScript.EndCode());
            }
            var funcDecl = new TypeScript.FuncDecl(name, bod, false, typeParameters, parameters, this.topVarList(), this.topScopeList(), this.topStaticsList(), 73 /* FuncDecl */ );
            this.setSpan(funcDecl, start, this.position);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);
            funcDecl.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;
            funcDecl.fncFlags |= 131072 /* IsFunctionExpression */ ;
            return funcDecl;
        };
        SyntaxTreeToAstVisitor.prototype.visitEmptyStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.semicolonToken);
            var result = new TypeScript.AST(1 /* Empty */ );
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTryStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.tryKeyword);
            var block = node.block.accept(this);
            var tryPart = new TypeScript.Try(block);
            this.setSpan(tryPart, start, this.position);
            var tryCatch = null;
            if (node.catchClause !== null) {
                var catchBit = node.catchClause.accept(this);
                tryCatch = new TypeScript.TryCatch(tryPart, catchBit);
                this.setSpan(tryCatch, start, this.position);
            }
            if (node.finallyClause !== null) {
                if (tryCatch !== null) {
                    tryPart = tryCatch;
                }
                var finallyBit = node.finallyClause.accept(this);
                var result = new TypeScript.TryFinally(tryPart, finallyBit);
                this.setSpan(result, start, this.position);
                return result;
            }
            Debug.assert(tryCatch !== null);
            return tryCatch;
        };
        SyntaxTreeToAstVisitor.prototype.visitCatchClause = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.catchKeyword);
            this.movePast(node.openParenToken);
            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.closeParenToken);
            var block = node.block.accept(this);
            var varDecl = new TypeScript.VarDecl(identifier, 0);
            this.setSpan(varDecl, identifier.minChar, identifier.limChar);
            var result = new TypeScript.Catch(varDecl, block);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitFinallyClause = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.finallyKeyword);
            var block = node.block.accept(this);
            var result = new TypeScript.Finally(block);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitLabeledStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.colonToken);
            var statement = node.statement.accept(this);
            var labelList = new TypeScript.ASTList();
            labelList.append(new TypeScript.Label(identifier));
            var result = new TypeScript.LabeledStatement(labelList, statement);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDoStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.doKeyword);
            var statement = node.statement.accept(this);
            var whileAst = this.identifierFromToken(node.whileKeyword, false);
            this.movePast(node.whileKeyword);
            this.movePast(node.openParenToken);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.DoWhileStatement();
            this.setSpan(result, start, this.position);
            result.whileAST = whileAst;
            result.cond = condition;
            result.body = statement;
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitTypeOfExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.typeOfKeyword);
            var expression = node.expression.accept(this);
            var result = new TypeScript.UnaryExpression(23 /* Typeof */ , expression);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDeleteExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.deleteKeyword);
            var expression = node.expression.accept(this);
            var result = new TypeScript.UnaryExpression(16 /* Delete */ , expression);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitVoidExpression = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.voidKeyword);
            var expression = node.expression.accept(this);
            var result = new TypeScript.UnaryExpression(12 /* Void */ , expression);
            this.setSpan(result, start, this.position);
            return result;
        };
        SyntaxTreeToAstVisitor.prototype.visitDebuggerStatement = function (node) {
            this.assertElementAtPosition(node);
            var start = this.position;
            this.movePast(node.debuggerKeyword);
            this.movePast(node.semicolonToken);
            var result = new TypeScript.DebuggerStatement();
            this.setSpan(result, start, this.position);
            return result;
        };
        return SyntaxTreeToAstVisitor;
    })();
    TypeScript.SyntaxTreeToAstVisitor = SyntaxTreeToAstVisitor;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCategory) {
        DiagnosticCategory._map = [];
        DiagnosticCategory._map[0] = "Warning";
        DiagnosticCategory.Warning = 0;
        DiagnosticCategory._map[1] = "Error";
        DiagnosticCategory.Error = 1;
    })(TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
    var DiagnosticCategory = TypeScript.DiagnosticCategory;
    (function (DiagnosticMessages) {
        DiagnosticMessages._map = [];
        DiagnosticMessages._map[0] = "error_2";
        DiagnosticMessages.error_2 = 0;
        DiagnosticMessages._map[1] = "warning_2";
        DiagnosticMessages.warning_2 = 1;
        DiagnosticMessages._map[2] = "duplicateIdentifier_1";
        DiagnosticMessages.duplicateIdentifier_1 = 2;
        DiagnosticMessages._map[3] = "unresolvedSymbol_1";
        DiagnosticMessages.unresolvedSymbol_1 = 3;
        DiagnosticMessages._map[4] = "symbolDoesNotReferToAValue_1";
        DiagnosticMessages.symbolDoesNotReferToAValue_1 = 4;
        DiagnosticMessages._map[5] = "invalidSuperReference";
        DiagnosticMessages.invalidSuperReference = 5;
        DiagnosticMessages._map[6] = "valueCannotBeModified";
        DiagnosticMessages.valueCannotBeModified = 6;
        DiagnosticMessages._map[7] = "usedCallInsteadOfNew_1";
        DiagnosticMessages.usedCallInsteadOfNew_1 = 7;
        DiagnosticMessages._map[8] = "valueIsNotCallable_1";
        DiagnosticMessages.valueIsNotCallable_1 = 8;
        DiagnosticMessages._map[9] = "valueIsNotNewable_1";
        DiagnosticMessages.valueIsNotNewable_1 = 9;
        DiagnosticMessages._map[10] = "invalidIndexLHS_2";
        DiagnosticMessages.invalidIndexLHS_2 = 10;
        DiagnosticMessages._map[11] = "incompatibleTypesForOperator_3";
        DiagnosticMessages.incompatibleTypesForOperator_3 = 11;
        DiagnosticMessages._map[12] = "incompatibleTypesForOperatorWithReason_4";
        DiagnosticMessages.incompatibleTypesForOperatorWithReason_4 = 12;
        DiagnosticMessages._map[13] = "incompatibleTypes_2";
        DiagnosticMessages.incompatibleTypes_2 = 13;
        DiagnosticMessages._map[14] = "incompatibleTypesWithReason_3";
        DiagnosticMessages.incompatibleTypesWithReason_3 = 14;
        DiagnosticMessages._map[15] = "expectedClassOrInterface";
        DiagnosticMessages.expectedClassOrInterface = 15;
        DiagnosticMessages._map[16] = "unaryOperatorTypeError_2";
        DiagnosticMessages.unaryOperatorTypeError_2 = 16;
    })(TypeScript.DiagnosticMessages || (TypeScript.DiagnosticMessages = {}));
    var DiagnosticMessages = TypeScript.DiagnosticMessages;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.typescriptDiagnosticMessages = {
        error_2: {
            category: 1 /* Error */ ,
            message: "error TS{0}: {1}",
            code: 0
        },
        warning_2: {
            category: 0 /* Warning */ ,
            message: "warning TS{0}: {1}",
            code: 1
        },
        duplicateIdentifier_1: {
            category: 1 /* Error */ ,
            message: "Duplicate identifier '{0}'",
            code: 100
        },
        unresolvedSymbol_1: {
            category: 1 /* Error */ ,
            message: "The name'{0}' does not exist in the current scope",
            code: 101
        },
        symbolDoesNotReferToAValue_1: {
            category: 1 /* Error */ ,
            message: "The name '{0}' does not refer to a value",
            code: 102
        },
        invalidSuperReference: {
            category: 1 /* Error */ ,
            message: "Keyword 'super' can only be used inside a class instance method",
            code: 103
        },
        valueCannotBeModified: {
            category: 1 /* Error */ ,
            message: "The left-hand side of an assignment expression must be a variable, property or indexer",
            code: 104
        },
        usedCallInsteadOfNew_1: {
            category: 1 /* Error */ ,
            message: "Value of type '{0}' is not callable.  Did you mean to include 'new'?",
            code: 105
        },
        valueIsNotCallable_1: {
            category: 1 /* Error */ ,
            message: "Value of type '{0}' is not callable",
            code: 106
        },
        valueIsNotNewable_1: {
            category: 1 /* Error */ ,
            message: "Value of type '{0}' is not newable",
            code: 107
        },
        invalidIndexLHS_2: {
            category: 1 /* Error */ ,
            message: "Value of type '{0}' is not indexable by type '{1}'",
            code: 108
        },
        incompatibleTypesForOperator_3: {
            category: 1 /* Error */ ,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}'",
            code: 109
        },
        incompatibleTypesForOperatorWithReason_4: {
            category: 1 /* Error */ ,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
            code: 110
        },
        incompatibleTypes_2: {
            category: 1 /* Error */ ,
            message: "Cannot convert '{0}' to '{1}'",
            code: 111
        },
        incompatibleTypesWithReason_3: {
            category: 1 /* Error */ ,
            message: "Cannot convert '{0}' to '{1}': {2}",
            code: 112
        },
        expectedClassOrInterface: {
            category: 1 /* Error */ ,
            message: "Expected var, class, interface, or module",
            code: 113
        },
        unaryOperatorTypeError_2: {
            category: 1 /* Error */ ,
            message: "Operator '{0}' cannot be applied to type '{1}'",
            code: 114
        }
    };
})(TypeScript || (TypeScript = {}));
var global = Function("return this").call(null);
var Clock;
(function (Clock) {
    Clock.now;
    Clock.resolution;
            if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
        global['WScript'].InitializeProjection();
        Clock.now = function () {
            return TestUtilities.QueryPerformanceCounter();
        };
        Clock.resolution = TestUtilities.QueryPerformanceFrequency();
    } else {
        Clock.now = function () {
            return Date.now();
        };
        Clock.resolution = 1000;
    }
})(Clock || (Clock = {}));
var Timer = (function () {
    function Timer() {
        this.time = 0;
    }
    Timer.prototype.start = function () {
        this.time = 0;
        this.startTime = Clock.now();
    };
    Timer.prototype.end = function () {
        this.time = (Clock.now() - this.startTime);
    };
    return Timer;
})();
var TypeScript;
(function (TypeScript) {
    (function (UpdateUnitKind) {
        UpdateUnitKind._map = [];
        UpdateUnitKind._map[0] = "Unknown";
        UpdateUnitKind.Unknown = 0;
        UpdateUnitKind._map[1] = "NoEdits";
        UpdateUnitKind.NoEdits = 1;
        UpdateUnitKind._map[2] = "EditsInsideSingleScope";
        UpdateUnitKind.EditsInsideSingleScope = 2;
    })(TypeScript.UpdateUnitKind || (TypeScript.UpdateUnitKind = {}));
    var UpdateUnitKind = TypeScript.UpdateUnitKind;
    var ScriptEditRange = (function () {
        function ScriptEditRange(minChar, limChar, delta) {
            this.minChar = minChar;
            this.limChar = limChar;
            this.delta = delta;
        }
        ScriptEditRange.unknown = function unknown() {
            return new ScriptEditRange(-1, -1, -1);
        };
        ScriptEditRange.prototype.isUnknown = function () {
            return this.minChar === -1 && this.limChar === -1 && this.delta === -1;
        };
        ScriptEditRange.prototype.containsPosition = function (pos) {
            return (this.minChar <= pos && pos < this.limChar) || (this.minChar <= pos && pos < this.limChar + this.delta);
        };
        ScriptEditRange.prototype.toString = function () {
            return "editRange(minChar=" + this.minChar + ", limChar=" + this.limChar + ", delta=" + this.delta + ")";
        };
        return ScriptEditRange;
    })();
    TypeScript.ScriptEditRange = ScriptEditRange;    
    var UpdateUnitResult = (function () {
        function UpdateUnitResult(kind, unitIndex, script1, script2) {
            this.kind = kind;
            this.unitIndex = unitIndex;
            this.script1 = script1;
            this.script2 = script2;
            this.scope1 = null;
            this.scope2 = null;
            this.editRange = null;
            this.parseErrors = [];
        }
        UpdateUnitResult.noEdits = function noEdits(unitIndex) {
            return new UpdateUnitResult(1 /* NoEdits */ , unitIndex, null, null);
        };
        UpdateUnitResult.unknownEdits = function unknownEdits(script1, script2, parseErrors) {
            var result = new UpdateUnitResult(0 /* Unknown */ , script1.locationInfo.unitIndex, script1, script2);
            result.parseErrors = parseErrors;
            return result;
        };
        UpdateUnitResult.singleScopeEdits = function singleScopeEdits(script1, script2, scope1, scope2, editRange, parseErrors) {
            var result = new UpdateUnitResult(2 /* EditsInsideSingleScope */ , script1.locationInfo.unitIndex, script1, script2);
            result.scope1 = scope1;
            result.scope2 = scope2;
            result.editRange = editRange;
            result.parseErrors = parseErrors;
            return result;
        };
        return UpdateUnitResult;
    })();
    TypeScript.UpdateUnitResult = UpdateUnitResult;    
    var ErrorEntry = (function () {
        function ErrorEntry(unitIndex, minChar, limChar, message) {
            this.unitIndex = unitIndex;
            this.minChar = minChar;
            this.limChar = limChar;
            this.message = message;
        }
        return ErrorEntry;
    })();
    TypeScript.ErrorEntry = ErrorEntry;    
    TypeScript.defaultSettings = new TypeScript.CompilationSettings();
    var TypeScriptCompiler = (function () {
        function TypeScriptCompiler(errorOutput, logger, settings, diagnosticMessages) {
            if (typeof logger === "undefined") { logger = new TypeScript.NullLogger(); }
            if (typeof settings === "undefined") { settings = TypeScript.defaultSettings; }
            if (typeof diagnosticMessages === "undefined") { diagnosticMessages = null; }
            this.errorOutput = errorOutput;
            this.logger = logger;
            this.settings = settings;
            this.diagnosticMessages = diagnosticMessages;
            this.parser = new TypeScript.Parser();
            this.typeFlow = null;
            this.scripts = new TypeScript.ASTList();
            this.units = new Array();
            this.pullTypeChecker = null;
            this.semanticInfoChain = null;
            this.syntaxTrees = [];
            this.stringTable = Collections.createStringTable();
            this.typeCollectionTime = 0;
            this.errorReporter = new TypeScript.ErrorReporter(this.errorOutput);
            this.pullErrorReporter = new TypeScript.PullErrorReporter(this.errorOutput);
            this.persistentTypeState = new TypeScript.PersistentGlobalTypeState(this.errorReporter);
            this.errorReporter.parser = this.parser;
            this.initTypeChecker(this.errorOutput);
            this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;
            this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;
            this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;
            this.emitSettings = new TypeScript.EmitOptions(this.settings);
            if (this.diagnosticMessages) {
                TypeScript.typescriptDiagnosticMessages = diagnosticMessages;
            }
            TypeScript.codeGenTarget = settings.codeGenTarget;
        }
        TypeScriptCompiler.prototype.timeFunction = function (funcDescription, func) {
            return TypeScript.timeFunction(this.logger, funcDescription, func);
        };
        TypeScriptCompiler.prototype.initTypeChecker = function (errorOutput) {
            this.persistentTypeState.refreshPersistentState();
            this.typeChecker = new TypeScript.TypeChecker(this.persistentTypeState);
            this.typeChecker.errorReporter = this.errorReporter;
            this.typeChecker.checkControlFlow = this.settings.controlFlow;
            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;
            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;
            this.typeChecker.errorsOnWith = this.settings.errorOnWith;
            this.typeChecker.styleSettings = this.settings.styleSettings;
            this.typeChecker.canCallDefinitionSignature = this.settings.canCallDefinitionSignature;
            this.errorReporter.checker = this.typeChecker;
            this.setErrorOutput(this.errorOutput);
        };
        TypeScriptCompiler.prototype.setErrorOutput = function (outerr) {
            this.errorOutput = outerr;
            this.errorReporter.setErrOut(outerr);
            this.parser.outfile = outerr;
        };
        TypeScriptCompiler.prototype.emitCommentsToOutput = function () {
            this.emitSettings = new TypeScript.EmitOptions(this.settings);
        };
        TypeScriptCompiler.prototype.setErrorCallback = function (fn) {
            this.parser.errorCallback = fn;
        };
        TypeScriptCompiler.prototype.updateUnit = function (prog, filename, setRecovery) {
            return this.updateSourceUnit(new TypeScript.StringSourceText(prog), filename, setRecovery);
        };
        TypeScriptCompiler.prototype.updateSourceUnit = function (sourceText, filename, setRecovery) {
            var _this = this;
            return this.timeFunction("updateSourceUnit(" + filename + ")", function () {
                var updateResult = _this.partialUpdateUnit(sourceText, filename, setRecovery);
                return _this.applyUpdateResult(updateResult);
            });
        };
        TypeScriptCompiler.prototype.applyUpdateResult = function (updateResult) {
            switch(updateResult.kind) {
                case 1 /* NoEdits */ :
                    return false;
                case 0 /* Unknown */ :
                    this.scripts.members[updateResult.unitIndex] = updateResult.script2;
                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo;
                    for(var i = 0, len = updateResult.parseErrors.length; i < len; i++) {
                        var e = updateResult.parseErrors[i];
                        if (this.parser.errorCallback) {
                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex);
                        }
                    }
                    return true;
                case 2 /* EditsInsideSingleScope */ :
                    new TypeScript.IncrementalParser(this.logger).mergeTrees(updateResult);
                    return true;
            }
        };
        TypeScriptCompiler.prototype.partialUpdateUnit = function (sourceText, filename, setRecovery) {
            var _this = this;
            return this.timeFunction("partialUpdateUnit(" + filename + ")", function () {
                for(var i = 0, len = _this.units.length; i < len; i++) {
                    if (_this.units[i].filename == filename) {
                        if ((_this.scripts.members[i]).isResident) {
                            return UpdateUnitResult.noEdits(i);
                        }
                        if (setRecovery) {
                            _this.parser.setErrorRecovery(null);
                        }
                        var updateResult;
                        var parseErrors = [];
                        var errorCapture = function (minChar, charLen, message, unitIndex) {
                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));
                        };
                        var svErrorCallback = _this.parser.errorCallback;
                        if (svErrorCallback) {
                            _this.parser.errorCallback = errorCapture;
                        }
                        var oldScript = _this.scripts.members[i];
                        var newScript = _this.parser.parse(sourceText, filename, i);
                        if (svErrorCallback) {
                            _this.parser.errorCallback = svErrorCallback;
                        }
                        updateResult = UpdateUnitResult.unknownEdits(oldScript, newScript, parseErrors);
                        return updateResult;
                    }
                }
                throw new Error("Unknown file \"" + filename + "\"");
            });
        };
        TypeScriptCompiler.prototype.addUnit = function (prog, filename, keepResident, referencedFiles) {
            if (typeof keepResident === "undefined") { keepResident = false; }
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            return this.addSourceUnit(new TypeScript.StringSourceText(prog), filename, keepResident, referencedFiles);
        };
        TypeScriptCompiler.prototype.addSourceUnit = function (sourceText, filename, keepResident, referencedFiles) {
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            var _this = this;
            return this.timeFunction("addSourceUnit(" + filename + ", " + keepResident + ")", function () {
                var timer = new Timer();
                var sharedIndex = _this.units.length;
                var reParsedScript = null;
                if (!_this.settings.useFidelity) {
                    timer.start();
                    var script = _this.parser.parse(sourceText, filename, sharedIndex, TypeScript.AllowedElements.Global);
                    timer.end();
                    reParsedScript = script;
                    var oldParseTime = timer.time;
                    script.referencedFiles = referencedFiles;
                    script.isResident = keepResident;
                    _this.persistentTypeState.setCollectionMode(keepResident ? 0 /* Resident */  : 1 /* Transient */ );
                } else {
                    var text = new TypeScript.SourceSimpleText(sourceText);
                    timer.start();
                    var syntaxTree = Parser1.parse(text, 1 /* EcmaScript5 */ , _this.stringTable);
                    timer.end();
                    var newParseTime = timer.time;
                    if (true || syntaxTree.diagnostics().length === 0) {
                        try  {
                            timer.start();
                            var script2 = TypeScript.SyntaxTreeToAstVisitor.visit(syntaxTree.sourceUnit(), filename, sharedIndex);
                            timer.end();
                            var translateTime = timer.time;
                            script2.referencedFiles = referencedFiles;
                            script2.isResident = keepResident;
                            reParsedScript = script2;
                        } catch (e1) {
                            IO.stdout.WriteLine("Error converting: " + filename);
                            IO.stdout.WriteLine("\t" + e1.message);
                        }
                    }
                    _this.syntaxTrees.push(syntaxTree);
                }
                var index = _this.units.length;
                _this.units[index] = reParsedScript.locationInfo;
                if (!_this.settings.usePull) {
                    var typeCollectionStart = new Date().getTime();
                    _this.typeChecker.collectTypes(reParsedScript);
                    _this.typeCollectionTime += (new Date().getTime()) - typeCollectionStart;
                }
                _this.scripts.append(reParsedScript);
                return reParsedScript;
            });
        };
        TypeScriptCompiler.compareObjects = function compareObjects(obj1, obj2) {
            if (obj1.alreadySeenObject) {
                return;
            }
            obj1.alreadySeenObject = true;
            for(var name in obj1) {
                if (name === "limChar" || name === "minChar" || name === "astID" || name === "leftCurlyCount" || name === "rightCurlyCount" || name === "flags" || name === "varFlags" || name === "fncFlags" || name === "modFlags" || name === "nestingLevel" || name === "constructorNestingLevel" || name === "alreadySeenObject" || name === "containsUnicodeCharInComment" || name === "containsUnicodeChar" || name === "isOverload") {
                    continue;
                }
                var value1 = obj1[name];
                if (value1) {
                    if (typeof value1 === 'number' || typeof value1 === 'string' || typeof value1 === 'boolean') {
                        var value2 = obj2[name];
                        if (typeof value1 !== typeof value2) {
                            throw new Error("Objects differed in type for key: " + name);
                        }
                        if (value1 !== value2) {
                            throw new Error("Objects differed in value for key: " + name);
                        }
                    }
                }
            }
            for(var name in obj1) {
                if (name === "preComments" || name === "postComments" || name === "docComments" || name === "sym" || name === "lineMap" || name === "resolvedTarget") {
                    continue;
                }
                var value1 = obj1[name];
                if (value1) {
                    if (typeof value1 === 'object') {
                        var value2 = obj2[name];
                        if (typeof value1 !== typeof value2) {
                            throw new Error("Objects differed in type for key: " + name);
                        }
                        this.compareObjects(value1, value2);
                    }
                }
            }
        };
        TypeScriptCompiler.prototype.typeCheck = function () {
            var _this = this;
            return this.timeFunction("typeCheck()", function () {
                var binder = new TypeScript.Binder(_this.typeChecker);
                _this.typeChecker.units = _this.units;
                binder.bind(_this.typeChecker.globalScope, _this.typeChecker.globals);
                binder.bind(_this.typeChecker.globalScope, _this.typeChecker.ambientGlobals);
                binder.bind(_this.typeChecker.globalScope, _this.typeChecker.globalTypes);
                binder.bind(_this.typeChecker.globalScope, _this.typeChecker.ambientGlobalTypes);
                _this.typeFlow = new TypeScript.TypeFlow(_this.logger, _this.typeChecker.globalScope, _this.parser, _this.typeChecker);
                var i = 0;
                var script = null;
                var len = _this.scripts.members.length;
                _this.persistentTypeState.setCollectionMode(0 /* Resident */ );
                for(i = 0; i < len; i++) {
                    script = _this.scripts.members[i];
                    if (!script.isResident || script.hasBeenTypeChecked) {
                        continue;
                    }
                    _this.typeFlow.assignScopes(script);
                    _this.typeFlow.initLibs();
                }
                for(i = 0; i < len; i++) {
                    script = _this.scripts.members[i];
                    if (!script.isResident || script.hasBeenTypeChecked) {
                        continue;
                    }
                    _this.typeFlow.typeCheck(script);
                    script.hasBeenTypeChecked = true;
                }
                _this.persistentTypeState.setCollectionMode(1 /* Transient */ );
                len = _this.scripts.members.length;
                for(i = 0; i < len; i++) {
                    script = _this.scripts.members[i];
                    if (script.isResident) {
                        continue;
                    }
                    _this.typeFlow.assignScopes(script);
                    _this.typeFlow.initLibs();
                }
                for(i = 0; i < len; i++) {
                    script = _this.scripts.members[i];
                    if (script.isResident) {
                        continue;
                    }
                    _this.typeFlow.typeCheck(script);
                }
                _this.logger.log("Total type collection time: " + _this.typeCollectionTime);
                return null;
            });
        };
        TypeScriptCompiler.prototype.cleanASTTypesForReTypeCheck = function (ast) {
            function cleanASTType(ast, parent) {
                ast.type = null;
                if (ast.nodeType == 75 /* VarDecl */ ) {
                    var vardecl = ast;
                    vardecl.sym = null;
                } else if (ast.nodeType == 76 /* ArgDecl */ ) {
                    var argdecl = ast;
                    argdecl.sym = null;
                } else if (ast.nodeType == 25 /* Name */ ) {
                    var name = ast;
                    name.sym = null;
                } else if (ast.nodeType == 73 /* FuncDecl */ ) {
                    var funcdecl = ast;
                    funcdecl.signature = null;
                    funcdecl.freeVariables = new Array();
                    funcdecl.symbols = null;
                    funcdecl.accessorSymbol = null;
                    funcdecl.scopeType = null;
                } else if (ast.nodeType == 98 /* ModuleDeclaration */ ) {
                    var modDecl = ast;
                    modDecl.mod = null;
                } else if (ast.nodeType == 100 /* With */ ) {
                    (ast).withSym = null;
                } else if (ast.nodeType == 93 /* Catch */ ) {
                    (ast).containedScope = null;
                } else if (ast.nodeType === 95 /* Script */ ) {
                    (ast).externallyVisibleImportedSymbols = [];
                }
                return ast;
            }
            TypeScript.getAstWalkerFactory().walk(ast, cleanASTType);
        };
        TypeScriptCompiler.prototype.cleanTypesForReTypeCheck = function () {
            var _this = this;
            return this.timeFunction("cleanTypesForReTypeCheck()", function () {
                for(var i = 0, len = _this.scripts.members.length; i < len; i++) {
                    var script = _this.scripts.members[i];
                    if ((script).isResident) {
                        continue;
                    }
                    _this.cleanASTTypesForReTypeCheck(script);
                    _this.typeChecker.collectTypes(script);
                }
                return null;
            });
        };
        TypeScriptCompiler.prototype.attemptIncrementalTypeCheck = function (updateResult) {
            return this.timeFunction("attemptIncrementalTypeCheck()", function () {
                return false;
            });
        };
        TypeScriptCompiler.prototype.reTypeCheck = function () {
            var _this = this;
            return this.timeFunction("reTypeCheck()", function () {
                TypeScript.CompilerDiagnostics.analysisPass++;
                _this.initTypeChecker(_this.errorOutput);
                _this.persistentTypeState.setCollectionMode(1 /* Transient */ );
                _this.cleanTypesForReTypeCheck();
                return _this.typeCheck();
            });
        };
        TypeScriptCompiler.prototype.isDynamicModuleCompilation = function () {
            for(var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = this.scripts.members[i];
                if (!script.isDeclareFile && script.topLevelMod != null) {
                    return true;
                }
            }
            return false;
        };
        TypeScriptCompiler.prototype.updateCommonDirectoryPath = function () {
            var commonComponents = [];
            var commonComponentsLength = -1;
            for(var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = this.scripts.members[i];
                if (script.emitRequired(this.emitSettings)) {
                    var fileName = script.locationInfo.filename;
                    var fileComponents = TypeScript.filePathComponents(fileName);
                    if (commonComponentsLength == -1) {
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    } else {
                        var updatedPath = false;
                        for(var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] != fileComponents[j]) {
                                commonComponentsLength = j;
                                updatedPath = true;
                                if (j == 0) {
                                    this.errorReporter.emitterError(null, "Cannot find the common subdirectory path for the input files");
                                    return;
                                }
                                break;
                            }
                        }
                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }
            this.emitSettings.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
            if (this.emitSettings.outputOption.charAt(this.emitSettings.outputOption.length - 1) != "/") {
                this.emitSettings.outputOption += "/";
            }
        };
        TypeScriptCompiler.prototype.parseEmitOption = function (ioHost) {
            this.emitSettings.ioHost = ioHost;
            if (this.emitSettings.outputOption == "") {
                this.emitSettings.outputMany = true;
                this.emitSettings.commonDirectoryPath = "";
                return;
            }
            this.emitSettings.outputOption = TypeScript.switchToForwardSlashes(this.emitSettings.ioHost.resolvePath(this.emitSettings.outputOption));
            if (this.emitSettings.ioHost.directoryExists(this.emitSettings.outputOption)) {
                this.emitSettings.outputMany = true;
            } else if (this.emitSettings.ioHost.fileExists(this.emitSettings.outputOption)) {
                this.emitSettings.outputMany = false;
            } else {
                this.emitSettings.outputMany = !TypeScript.isJSFile(this.emitSettings.outputOption);
            }
            if (this.isDynamicModuleCompilation() && !this.emitSettings.outputMany) {
                this.errorReporter.emitterError(null, "Cannot compile dynamic modules when emitting into single file");
            }
            if (this.emitSettings.outputMany) {
                this.updateCommonDirectoryPath();
            }
        };
        TypeScriptCompiler.prototype.useUTF8ForFile = function (script) {
            if (this.emitSettings.outputMany) {
                return this.outputScriptToUTF8(script);
            } else {
                return this.outputScriptsToUTF8((this.scripts.members));
            }
        };
        TypeScriptCompiler.mapToDTSFileName = function mapToDTSFileName(fileName, wholeFileNameReplaced) {
            return TypeScript.getDeclareFilePath(fileName);
        };
        TypeScriptCompiler.prototype.canEmitDeclarations = function (script) {
            if (!this.settings.generateDeclarationFiles) {
                return false;
            }
            if (!!script && (script.isDeclareFile || script.isResident || script.bod == null)) {
                return false;
            }
            return true;
        };
        TypeScriptCompiler.prototype.emitDeclarationsUnit = function (script, reuseEmitter, declarationEmitter) {
            if (!this.canEmitDeclarations(script)) {
                return null;
            }
            if (!declarationEmitter) {
                var declareFileName = this.emitSettings.mapOutputFileName(script.locationInfo.filename, TypeScriptCompiler.mapToDTSFileName);
                var declareFile = this.createFile(declareFileName, this.useUTF8ForFile(script));
                declarationEmitter = new TypeScript.DeclarationEmitter(this.typeChecker, this.emitSettings, this.errorReporter);
                declarationEmitter.setDeclarationFile(declareFile);
            }
            declarationEmitter.emitDeclarations(script);
            if (!reuseEmitter) {
                declarationEmitter.Close();
                return null;
            } else {
                return declarationEmitter;
            }
        };
        TypeScriptCompiler.prototype.emitDeclarations = function () {
            if (!this.canEmitDeclarations()) {
                return;
            }
            if (this.errorReporter.hasErrors) {
                return;
            }
            if (this.scripts.members.length == 0) {
                return;
            }
            var declarationEmitter = null;
            for(var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = this.scripts.members[i];
                if (this.emitSettings.outputMany || declarationEmitter == null) {
                    declarationEmitter = this.emitDeclarationsUnit(script, !this.emitSettings.outputMany);
                } else {
                    this.emitDeclarationsUnit(script, true, declarationEmitter);
                }
            }
            if (declarationEmitter) {
                declarationEmitter.Close();
            }
        };
        TypeScriptCompiler.mapToFileNameExtension = function mapToFileNameExtension(extension, fileName, wholeFileNameReplaced) {
            if (wholeFileNameReplaced) {
                return fileName;
            } else {
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        };
        TypeScriptCompiler.mapToJSFileName = function mapToJSFileName(fileName, wholeFileNameReplaced) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        };
        TypeScriptCompiler.prototype.emitUnit = function (script, reuseEmitter, emitter, inputOutputMapper) {
            if (!script.emitRequired(this.emitSettings)) {
                return null;
            }
            var fname = script.locationInfo.filename;
            if (!emitter) {
                var outFname = this.emitSettings.mapOutputFileName(fname, TypeScriptCompiler.mapToJSFileName);
                var outFile = this.createFile(outFname, this.useUTF8ForFile(script));
                emitter = new TypeScript.Emitter(this.typeChecker, outFname, outFile, this.emitSettings, this.errorReporter);
                if (this.settings.mapSourceFiles) {
                    emitter.setSourceMappings(new TypeScript.SourceMapper(fname, outFname, outFile, this.createFile(outFname + TypeScript.SourceMapper.MapFileExtension, false), this.errorReporter, this.settings.emitFullSourceMapPath));
                }
                if (inputOutputMapper) {
                    inputOutputMapper(script.locationInfo.unitIndex, outFname);
                }
            } else if (this.settings.mapSourceFiles) {
                emitter.setSourceMappings(new TypeScript.SourceMapper(fname, emitter.emittingFileName, emitter.outfile, emitter.sourceMapper.sourceMapOut, this.errorReporter, this.settings.emitFullSourceMapPath));
            }
            this.typeChecker.locationInfo = script.locationInfo;
            emitter.emitJavascript(script, 62 /* Comma */ , false);
            if (!reuseEmitter) {
                emitter.Close();
                return null;
            } else {
                return emitter;
            }
        };
        TypeScriptCompiler.prototype.emit = function (ioHost, inputOutputMapper) {
            this.parseEmitOption(ioHost);
            var emitter = null;
            for(var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = this.scripts.members[i];
                if (this.emitSettings.outputMany || emitter == null) {
                    emitter = this.emitUnit(script, !this.emitSettings.outputMany, null, inputOutputMapper);
                } else {
                    this.emitUnit(script, true, emitter);
                }
            }
            if (emitter) {
                emitter.Close();
            }
        };
        TypeScriptCompiler.prototype.emitToOutfile = function (outputFile) {
            if (this.settings.mapSourceFiles) {
                throw Error("Cannot generate source map");
            }
            if (this.settings.generateDeclarationFiles) {
                throw Error("Cannot generate declaration files");
            }
            if (this.settings.outputOption != "") {
                throw Error("Cannot parse output option");
            }
            var emitter = emitter = new TypeScript.Emitter(this.typeChecker, "stdout", outputFile, this.emitSettings, this.errorReporter);
            ;
            for(var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = this.scripts.members[i];
                this.typeChecker.locationInfo = script.locationInfo;
                emitter.emitJavascript(script, 62 /* Comma */ , false);
            }
        };
        TypeScriptCompiler.prototype.outputScriptToUTF8 = function (script) {
            return script.containsUnicodeChar || (this.emitSettings.emitComments && script.containsUnicodeCharInComment);
        };
        TypeScriptCompiler.prototype.outputScriptsToUTF8 = function (scripts) {
            for(var i = 0, len = scripts.length; i < len; i++) {
                var script = scripts[i];
                if (this.outputScriptToUTF8(script)) {
                    return true;
                }
            }
            return false;
        };
        TypeScriptCompiler.prototype.createFile = function (fileName, useUTF8) {
            try  {
                return this.emitSettings.ioHost.createFile(fileName, useUTF8);
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        };
        TypeScriptCompiler.prototype.pullResolveFile = function (filename) {
            if (!this.pullTypeChecker) {
                return false;
            }
            var unit = this.semanticInfoChain.getUnit(filename);
            if (!unit) {
                return false;
            }
            this.pullTypeChecker.setUnit(filename);
            this.pullTypeChecker.resolver.resolveBoundDecls(unit.getTopLevelDecls()[0], new TypeScript.PullTypeResolutionContext());
            return true;
        };
        TypeScriptCompiler.prototype.pullGetErrorsForFile = function (filename) {
            var errors = [];
            var unit = this.semanticInfoChain.getUnit(filename);
            if (unit) {
                unit.getErrors(errors);
            }
            return errors;
        };
        TypeScriptCompiler.prototype.pullTypeCheck = function (refresh) {
            if (typeof refresh === "undefined") { refresh = false; }
            var _this = this;
            return this.timeFunction("pullTypeCheck()", function () {
                if (!_this.pullTypeChecker || refresh) {
                    _this.semanticInfoChain = new TypeScript.SemanticInfoChain();
                    _this.pullTypeChecker = new TypeScript.PullTypeChecker(_this.semanticInfoChain);
                }
                _this.pullErrorReporter.setUnits(_this.units);
                var declCollectionContext = null;
                var semanticInfo = null;
                var i = 0;
                var createDeclsStartTime = new Date().getTime();
                for(; i < _this.scripts.members.length; i++) {
                    semanticInfo = new TypeScript.SemanticInfo(_this.units[i].filename, _this.units[i]);
                    declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                    declCollectionContext.scriptName = _this.units[i].filename;
                    TypeScript.getAstWalkerFactory().walk(_this.scripts.members[i], TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                    semanticInfo.addTopLevelDecl(declCollectionContext.getParent());
                    _this.semanticInfoChain.addUnit(semanticInfo);
                }
                var createDeclsEndTime = new Date().getTime();
                var bindStartTime = new Date().getTime();
                var binder = new TypeScript.PullSymbolBinder(_this.semanticInfoChain);
                for(i = 1; i < _this.semanticInfoChain.units.length; i++) {
                    binder.bindDeclsForUnit(_this.semanticInfoChain.units[i].getPath());
                }
                var bindEndTime = new Date().getTime();
                var typeCheckStartTime = new Date().getTime();
                for(i = 0; i < _this.scripts.members.length; i++) {
                    _this.pullResolveFile(_this.units[i].filename);
                }
                var typeCheckEndTime = new Date().getTime();
                _this.logger.log("Decl creation: " + (createDeclsEndTime - createDeclsStartTime));
                _this.logger.log("Binding: " + (bindEndTime - bindStartTime));
                _this.logger.log("    Time in findSymbol: " + TypeScript.time_in_findSymbol);
                _this.logger.log("Type resolution: " + (typeCheckEndTime - typeCheckStartTime));
                _this.logger.log("Total: " + (typeCheckEndTime - createDeclsStartTime));
                _this.pullErrorReporter.reportErrors(_this.semanticInfoChain.postErrors());
            });
        };
        TypeScriptCompiler.prototype.pullUpdateScript = function (oldScript, newScript) {
            var _this = this;
            return this.timeFunction("pullUpdateScript: ", function () {
                var declDiffer = new TypeScript.PullDeclDiffer();
                var newScriptSemanticInfo = new TypeScript.SemanticInfo(oldScript.locationInfo.filename, newScript.locationInfo);
                var oldScriptSemanticInfo = _this.semanticInfoChain.getUnit(oldScript.locationInfo.filename);
                TypeScript.lastBoundPullDeclId = TypeScript.pullDeclID;
                TypeScript.lastBoundPullSymbolID = TypeScript.pullSymbolID;
                var declCollectionContext = new TypeScript.DeclCollectionContext(newScriptSemanticInfo);
                declCollectionContext.scriptName = oldScript.locationInfo.filename;
                TypeScript.getAstWalkerFactory().walk(newScript, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);
                var oldTopLevelDecl = oldScriptSemanticInfo.getTopLevelDecls()[0];
                var newTopLevelDecl = declCollectionContext.getParent();
                newScriptSemanticInfo.addTopLevelDecl(newTopLevelDecl);
                var diffResults = [];
                var diffStartTime = new Date().getTime();
                declDiffer.diffDecls(oldTopLevelDecl, newTopLevelDecl, diffResults);
                var diffEndTime = new Date().getTime();
                _this.logger.log("Update Script - Diff time: " + (diffEndTime - diffStartTime));
                _this.semanticInfoChain.updateUnit(oldScriptSemanticInfo, newScriptSemanticInfo);
                var innerBindStartTime = new Date().getTime();
                var topLevelDecls = newScriptSemanticInfo.getTopLevelDecls();
                _this.semanticInfoChain.update(newScript.locationInfo.filename);
                var binder = new TypeScript.PullSymbolBinder(_this.semanticInfoChain);
                binder.setUnit(newScript.locationInfo.filename);
                for(var i = 0; i < topLevelDecls.length; i++) {
                    binder.bindDeclToPullSymbol(topLevelDecls[i], true);
                }
                var innerBindEndTime = new Date().getTime();
                _this.logger.log("Update Script - Inner bind time: " + (innerBindEndTime - innerBindStartTime));
                if (diffResults.length) {
                    var graphUpdater = new TypeScript.PullSymbolGraphUpdater(_this.semanticInfoChain);
                    var diff;
                    var traceStartTime = new Date().getTime();
                    for(var i = 0; i < diffResults.length; i++) {
                        diff = diffResults[i];
                        if (diff.kind == 2 /* DeclRemoved */ ) {
                            graphUpdater.removeDecl(diff.oldDecl);
                        } else if (diff.kind == 1 /* DeclAdded */ ) {
                            graphUpdater.addDecl(diff.newDecl);
                            graphUpdater.invalidateType(diff.oldDecl.getSymbol());
                            _this.resolvePosition(diff.newDecl.getSpan().minChar, newScript);
                        } else {
                        }
                    }
                    var traceEndTime = new Date().getTime();
                    _this.logger.log("Update Script - Trace time: " + (traceEndTime - traceStartTime));
                    _this.logger.log("Update Script - Number of diffs: " + diffResults.length);
                    _this.pullErrorReporter.setUnits(_this.units);
                    _this.pullErrorReporter.reportErrors(_this.semanticInfoChain.postErrors());
                    return true;
                }
                _this.pullErrorReporter.setUnits(_this.units);
                _this.pullErrorReporter.reportErrors(_this.semanticInfoChain.postErrors());
                return false;
            });
        };
        TypeScriptCompiler.prototype.resolvePosition = function (pos, script, scriptName) {
            var declStack = [];
            var resultASTs = [];
            if (!scriptName) {
                scriptName = script.locationInfo.filename;
            }
            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var lastDeclAST = null;
            var foundAST = null;
            var symbol = null;
            var lambdaAST = null;
            var declarationInitASTs = [];
            var objectLitAST = null;
            var asgAST = null;
            var typeAssertionASTs = [];
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var inTypeReference = false;
            var pre = function (cur, parent) {
                if (TypeScript.isValidAstNode(cur)) {
                    if (pos >= cur.minChar && pos <= cur.limChar) {
                        var previous = resultASTs[resultASTs.length - 1];
                        if (previous == undefined || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                            var decl = semanticInfo.getDeclForAST(cur);
                            if (decl) {
                                declStack[declStack.length] = decl;
                                lastDeclAST = cur;
                            }
                            if (cur.nodeType == 73 /* FuncDecl */  && TypeScript.hasFlag((cur).fncFlags, 131072 /* IsFunctionExpression */ )) {
                                lambdaAST = cur;
                            } else if (cur.nodeType == 75 /* VarDecl */ ) {
                                declarationInitASTs[declarationInitASTs.length] = cur;
                            } else if (cur.nodeType == 11 /* ObjectLit */ ) {
                                objectLitAST = cur;
                            } else if (cur.nodeType == 72 /* TypeAssertion */ ) {
                                typeAssertionASTs[typeAssertionASTs.length] = cur;
                            } else if (cur.nodeType == 32 /* Asg */ ) {
                                asgAST = cur;
                            } else if (cur.nodeType == 28 /* TypeRef */ ) {
                                inTypeReference = true;
                            }
                            resultASTs[resultASTs.length] = cur;
                        }
                    }
                }
                return cur;
            };
            TypeScript.getAstWalkerFactory().walk(script, pre);
            if (resultASTs.length) {
                this.pullTypeChecker.setUnit(script.locationInfo.filename);
                foundAST = resultASTs[resultASTs.length - 1];
                if (foundAST.nodeType == 25 /* Name */  && resultASTs.length > 1) {
                    var previousAST = resultASTs[resultASTs.length - 2];
                    switch(previousAST.nodeType) {
                        case 97 /* InterfaceDeclaration */ :
                        case 96 /* ClassDeclaration */ :
                        case 98 /* ModuleDeclaration */ :
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;
                    }
                }
                if (lastDeclAST == foundAST) {
                    symbol = declStack[declStack.length - 1].getSymbol();
                    this.pullTypeChecker.resolver.resolveDeclaredSymbol(symbol, null, resolutionContext);
                } else {
                    var enclosingDecl = null;
                    for(var i = declStack.length - 1; i >= 0; i--) {
                        if (!(declStack[i].getKind() & (2048 /* Variable */  | 4096 /* Parameter */ ))) {
                            enclosingDecl = declStack[i];
                            break;
                        }
                    }
                    if (foundAST.nodeType == 25 /* Name */  && resultASTs.length > 1) {
                        for(var i = resultASTs.length - 2; i >= 0; i--) {
                            if ((resultASTs[i].nodeType === 75 /* VarDecl */  && (resultASTs[i]).id === resultASTs[i + 1]) || (resultASTs[i].nodeType === 19 /* Dot */  && (resultASTs[i]).operand2 === resultASTs[i + 1])) {
                                foundAST = resultASTs[i];
                            } else {
                                break;
                            }
                        }
                    }
                    if (foundAST.nodeType == 94 /* List */ ) {
                        for(var i = 0; i < (foundAST).members.length; i++) {
                            if ((foundAST).members[i].minChar > pos) {
                                foundAST = (foundAST).members[i];
                                break;
                            }
                        }
                    }
                    resolutionContext.resolveAggressively = true;
                    resolutionContext.searchTypeSpace = inTypeReference;
                    var isTypedAssignment = false;
                    if (declarationInitASTs.length) {
                        var assigningAST;
                        var varSymbol;
                        for(var i = 0; i < declarationInitASTs.length; i++) {
                            assigningAST = declarationInitASTs[i];
                            isTypedAssignment = (assigningAST != null) && (assigningAST.typeExpr != null);
                            this.pullTypeChecker.resolver.resolveDeclaration(assigningAST, resolutionContext);
                            varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);
                            if (varSymbol && isTypedAssignment) {
                                var contextualType = varSymbol.getType();
                                resolutionContext.pushContextualType(contextualType, false, null);
                            }
                            if (assigningAST.init) {
                                this.pullTypeChecker.resolver.resolveAST(assigningAST.init, isTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }
                    }
                    if (typeAssertionASTs.length) {
                        for(var i = 0; i < typeAssertionASTs.length; i++) {
                            this.pullTypeChecker.resolver.resolveAST(typeAssertionASTs[i], isTypedAssignment, enclosingDecl, resolutionContext);
                        }
                    }
                    if (asgAST) {
                        this.pullTypeChecker.resolver.resolveAST(asgAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    }
                    if (objectLitAST) {
                        this.pullTypeChecker.resolver.resolveAST(objectLitAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    }
                    if (lambdaAST) {
                        this.pullTypeChecker.resolver.resolveAST(lambdaAST, true, enclosingDecl, resolutionContext);
                        enclosingDecl = semanticInfo.getDeclForAST(lambdaAST);
                    }
                    symbol = this.pullTypeChecker.resolver.resolveAST(foundAST, isTypedAssignment, enclosingDecl, resolutionContext);
                }
            }
            return {
                symbol: symbol,
                ast: foundAST
            };
        };
        TypeScriptCompiler.prototype.extractResolutionContextFromPath = function (path, script, scriptName) {
            if (!scriptName) {
                scriptName = script.locationInfo.filename;
            }
            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var enclosingDecl = null;
            var isTypedAssignment = false;
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            resolutionContext.resolveAggressively = true;
            if (path.count() == 0) {
                return null;
            }
            for(var i = 0, n = path.count(); i < n; i++) {
                var current = path.asts[i];
                var decl = semanticInfo.getDeclForAST(current);
                if (decl && !(decl.getKind() & (2048 /* Variable */  | 4096 /* Parameter */ ))) {
                    enclosingDecl = decl;
                }
                switch(current.nodeType) {
                    case 73 /* FuncDecl */ :
                        if (TypeScript.hasFlag((current).fncFlags, 131072 /* IsFunctionExpression */ )) {
                            this.pullTypeChecker.resolver.resolveAST((current), true, enclosingDecl, resolutionContext);
                        }
                        break;
                    case 75 /* VarDecl */ :
                        var assigningAST = current;
                        isTypedAssignment = (assigningAST.typeExpr != null);
                        this.pullTypeChecker.resolver.resolveDeclaration(assigningAST, resolutionContext);
                        var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);
                        if (varSymbol && isTypedAssignment) {
                            var contextualType = varSymbol.getType();
                            resolutionContext.pushContextualType(contextualType, false, null);
                        }
                        if (assigningAST.init) {
                            this.pullTypeChecker.resolver.resolveAST(assigningAST.init, isTypedAssignment, enclosingDecl, resolutionContext);
                        }
                        break;
                    case 11 /* ObjectLit */ :
                        this.pullTypeChecker.resolver.resolveAST((current), isTypedAssignment, enclosingDecl, resolutionContext);
                        break;
                    case 32 /* Asg */ :
                        this.pullTypeChecker.resolver.resolveAST((current), isTypedAssignment, enclosingDecl, resolutionContext);
                        break;
                    case 72 /* TypeAssertion */ :
                        this.pullTypeChecker.resolver.resolveAST((current), isTypedAssignment, enclosingDecl, resolutionContext);
                        resolutionContext.searchTypeSpace = true;
                        break;
                    case 28 /* TypeRef */ :
                    case 26 /* TypeParameter */ :
                        resolutionContext.searchTypeSpace = true;
                        break;
                }
            }
            if (path.isNameOfInterface() || path.isInClassImplementsList() || path.isInInterfaceExtendsList()) {
                resolutionContext.searchTypeSpace = true;
            }
            if (path.ast().nodeType === 25 /* Name */  && path.count() > 1) {
                for(var i = path.count() - 1; i >= 0; i--) {
                    if (path.asts[path.top - 1].nodeType === 19 /* Dot */  && (path.asts[path.top - 1]).operand2 === path.asts[path.top]) {
                        path.pop();
                    } else {
                        break;
                    }
                }
            }
            return {
                ast: path.ast(),
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                isTypedAssignment: isTypedAssignment
            };
        };
        TypeScriptCompiler.prototype.pullGetSymbolInformationFromPath = function (path, script, scriptName) {
            var context = this.extractResolutionContextFromPath(path, script, scriptName);
            if (!context) {
                return null;
            }
            var symbol = this.pullTypeChecker.resolver.resolveAST(path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext);
            return {
                symbol: symbol,
                ast: path.ast()
            };
        };
        TypeScriptCompiler.prototype.pullGetCallInformationFormPath = function (path, script, scriptName) {
            if (path.ast().nodeType !== 30 /* Call */  && path.ast().nodeType !== 31 /* New */ ) {
                return null;
            }
            var isNew = (path.ast().nodeType === 31 /* New */ );
            var context = this.extractResolutionContextFromPath(path, script, scriptName);
            if (!context) {
                return null;
            }
            var callResolutionResults = {
                targetSymbol: null,
                signatures: null,
                signature: null,
                ast: path.ast()
            };
            if (isNew) {
                this.pullTypeChecker.resolver.resolveNewExpression(path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            } else {
                this.pullTypeChecker.resolver.resolveCallExpression(path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            }
            return callResolutionResults;
        };
        TypeScriptCompiler.prototype.pullGetTypeInfoAtPosition = function (pos, script, scriptName) {
            var _this = this;
            return this.timeFunction("pullGetTypeInfoAtPosition for pos " + pos + ":", function () {
                var info = _this.resolvePosition(pos, script, scriptName);
                if (info.symbol) {
                    var type = info.symbol.getType();
                    if (type) {
                        return {
                            ast: info.ast,
                            typeName: type.getName(),
                            typeInfo: type.toString(),
                            typeSymbol: type
                        };
                    }
                }
                return {
                    ast: info.ast,
                    typeName: "couldn't find the type...",
                    typeInfo: "couldn't find members...",
                    typeSymbol: null
                };
            });
        };
        TypeScriptCompiler.prototype.pullUpdateUnit = function (sourceText, filename, setRecovery) {
            var _this = this;
            return this.timeFunction("pullUpdateUnit(" + filename + ")", function () {
                for(var i = 0, len = _this.units.length; i < len; i++) {
                    if (_this.units[i].filename == filename) {
                        if (setRecovery) {
                            _this.parser.setErrorRecovery(null);
                        }
                        var updateResult;
                        var parseErrors = [];
                        var errorCapture = function (minChar, charLen, message, unitIndex) {
                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));
                        };
                        var svErrorCallback = _this.parser.errorCallback;
                        if (svErrorCallback) {
                            _this.parser.errorCallback = errorCapture;
                        }
                        var oldScript = _this.scripts.members[i];
                        var text = new TypeScript.SourceSimpleText(sourceText);
                        var syntaxTree = Parser1.parse(text, 1 /* EcmaScript5 */ , _this.stringTable);
                        var newScript = null;
                        try  {
                            newScript = TypeScript.SyntaxTreeToAstVisitor.visit(syntaxTree.sourceUnit(), filename, i);
                        } catch (e1) {
                            IO.stdout.WriteLine("Error converting: " + filename);
                            IO.stdout.WriteLine("\t" + e1.message);
                        }
                        _this.syntaxTrees[i] = syntaxTree;
                        if (svErrorCallback) {
                            _this.parser.errorCallback = svErrorCallback;
                        }
                        _this.scripts.members[i] = newScript;
                        _this.units[i] = newScript.locationInfo;
                        return _this.pullUpdateScript(oldScript, newScript);
                    }
                }
                throw new Error("Unknown file \"" + filename + "\"");
            });
        };
        return TypeScriptCompiler;
    })();
    TypeScript.TypeScriptCompiler = TypeScriptCompiler;    
    var ScopeEntry = (function () {
        function ScopeEntry(name, type, sym) {
            this.name = name;
            this.type = type;
            this.sym = sym;
        }
        return ScopeEntry;
    })();
    TypeScript.ScopeEntry = ScopeEntry;    
    var ScopeTraversal = (function () {
        function ScopeTraversal(compiler) {
            this.compiler = compiler;
        }
        ScopeTraversal.prototype.getScope = function (enclosingScopeContext) {
            if (enclosingScopeContext.enclosingObjectLit && enclosingScopeContext.isMemberCompletion) {
                return enclosingScopeContext.getObjectLiteralScope();
            } else if (enclosingScopeContext.isMemberCompletion) {
                if (enclosingScopeContext.useFullAst) {
                    return this.compiler.typeFlow.findMemberScopeAtFullAst(enclosingScopeContext);
                } else {
                    return this.compiler.typeFlow.findMemberScopeAt(enclosingScopeContext);
                }
            } else {
                return enclosingScopeContext.getScope();
            }
        };
        ScopeTraversal.prototype.getScopeEntries = function (enclosingScopeContext, getPrettyTypeName) {
            var scope = this.getScope(enclosingScopeContext);
            if (scope == null) {
                return [];
            }
            var inScopeNames = new TypeScript.StringHashTable();
            var allSymbolNames = scope.getAllSymbolNames(enclosingScopeContext.isMemberCompletion);
            for(var i = 0; i < allSymbolNames.length; i++) {
                var name = allSymbolNames[i];
                if (name == TypeScript.globalId || name == "_Core" || name == "_element") {
                    continue;
                }
                inScopeNames.add(name, "");
            }
            var svModuleDecl = this.compiler.typeChecker.currentModDecl;
            this.compiler.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl;
            var result = this.getTypeNamesForNames(enclosingScopeContext, inScopeNames.getAllKeys(), scope, getPrettyTypeName);
            this.compiler.typeChecker.currentModDecl = svModuleDecl;
            return result;
        };
        ScopeTraversal.prototype.getTypeNamesForNames = function (enclosingScopeContext, allNames, scope, getPrettyTypeName) {
            var result = [];
            var enclosingScope = enclosingScopeContext.getScope();
            for(var i = 0; i < allNames.length; i++) {
                var name = allNames[i];
                var publicsOnly = enclosingScopeContext.publicsOnly && enclosingScopeContext.isMemberCompletion;
                var symbol = scope.find(name, publicsOnly, false);
                if (symbol == null) {
                    symbol = scope.find(name, publicsOnly, true);
                }
                var displayThisMember = symbol && symbol.flags & 2 /* Private */  ? symbol.container == scope.container : true;
                if (symbol) {
                    if (displayThisMember && !TypeScript.isQuoted(symbol.name) && !TypeScript.isRelative(symbol.name)) {
                        var getPrettyOverload = getPrettyTypeName && symbol.declAST && symbol.declAST.nodeType == 73 /* FuncDecl */ ;
                        var type = symbol.getType();
                        var typeName = type ? type.getScopedTypeName(enclosingScope, getPrettyOverload) : "";
                        result.push(new ScopeEntry(name, typeName, symbol));
                    }
                } else {
                    if (name == "true" || name == "false") {
                        result.push(new ScopeEntry(name, "bool", this.compiler.typeChecker.booleanType.symbol));
                    }
                }
            }
            return result;
        };
        return ScopeTraversal;
    })();
    TypeScript.ScopeTraversal = ScopeTraversal;    
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CompilerDiagnostics) {
        CompilerDiagnostics.debug = false;
        CompilerDiagnostics.diagnosticWriter = null;
        CompilerDiagnostics.analysisPass = 0;
        function Alert(output) {
            if (CompilerDiagnostics.diagnosticWriter) {
                CompilerDiagnostics.diagnosticWriter.Alert(output);
            }
        }
        CompilerDiagnostics.Alert = Alert;
        function debugPrint(s) {
            if (CompilerDiagnostics.debug) {
                Alert(s);
            }
        }
        CompilerDiagnostics.debugPrint = debugPrint;
        function assert(condition, s) {
            if (CompilerDiagnostics.debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }
        CompilerDiagnostics.assert = assert;
    })(TypeScript.CompilerDiagnostics || (TypeScript.CompilerDiagnostics = {}));
    var CompilerDiagnostics = TypeScript.CompilerDiagnostics;
    var NullLogger = (function () {
        function NullLogger() { }
        NullLogger.prototype.information = function () {
            return false;
        };
        NullLogger.prototype.debug = function () {
            return false;
        };
        NullLogger.prototype.warning = function () {
            return false;
        };
        NullLogger.prototype.error = function () {
            return false;
        };
        NullLogger.prototype.fatal = function () {
            return false;
        };
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    })();
    TypeScript.NullLogger = NullLogger;    
    var LoggerAdapter = (function () {
        function LoggerAdapter(logger) {
            this.logger = logger;
            this._information = this.logger.information();
            this._debug = this.logger.debug();
            this._warning = this.logger.warning();
            this._error = this.logger.error();
            this._fatal = this.logger.fatal();
        }
        LoggerAdapter.prototype.information = function () {
            return this._information;
        };
        LoggerAdapter.prototype.debug = function () {
            return this._debug;
        };
        LoggerAdapter.prototype.warning = function () {
            return this._warning;
        };
        LoggerAdapter.prototype.error = function () {
            return this._error;
        };
        LoggerAdapter.prototype.fatal = function () {
            return this._fatal;
        };
        LoggerAdapter.prototype.log = function (s) {
            this.logger.log(s);
        };
        return LoggerAdapter;
    })();
    TypeScript.LoggerAdapter = LoggerAdapter;    
    var BufferedLogger = (function () {
        function BufferedLogger() {
            this.logContents = [];
        }
        BufferedLogger.prototype.information = function () {
            return false;
        };
        BufferedLogger.prototype.debug = function () {
            return false;
        };
        BufferedLogger.prototype.warning = function () {
            return false;
        };
        BufferedLogger.prototype.error = function () {
            return false;
        };
        BufferedLogger.prototype.fatal = function () {
            return false;
        };
        BufferedLogger.prototype.log = function (s) {
            this.logContents.push(s);
        };
        return BufferedLogger;
    })();
    TypeScript.BufferedLogger = BufferedLogger;    
    function timeFunction(logger, funcDescription, func) {
        var start = +new Date();
        var result = func();
        var end = +new Date();
        logger.log(funcDescription + " completed in " + (end - start) + " msec");
        return result;
    }
    TypeScript.timeFunction = timeFunction;
    function stringToLiteral(value, length) {
        var result = "";
        var addChar = function (index) {
            var ch = value.charCodeAt(index);
            switch(ch) {
                case 0x09:
                    result += "\\t";
                    break;
                case 0x0a:
                    result += "\\n";
                    break;
                case 0x0b:
                    result += "\\v";
                    break;
                case 0x0c:
                    result += "\\f";
                    break;
                case 0x0d:
                    result += "\\r";
                    break;
                case 0x22:
                    result += "\\\"";
                    break;
                case 0x27:
                    result += "\\\'";
                    break;
                case 0x5c:
                    result += "\\";
                    break;
                default:
                    result += value.charAt(index);
            }
        };
        var tooLong = (value.length > length);
        if (tooLong) {
            var mid = length >> 1;
            for(var i = 0; i < mid; i++) {
                addChar(i);
            }
            result += "(...)";
            for(var i = value.length - mid; i < value.length; i++) {
                addChar(i);
            }
        } else {
            length = value.length;
            for(var i = 0; i < length; i++) {
                addChar(i);
            }
        }
        return result;
    }
    TypeScript.stringToLiteral = stringToLiteral;
    function getDiagnosticMessage(diagnosticType, args) {
        var diagnosticName = (TypeScript.DiagnosticMessages)._map[diagnosticType];
        var diagnostic = TypeScript.typescriptDiagnosticMessages[diagnosticName];
        if (!diagnostic) {
            throw new Error("Invalid diagnostic");
        } else {
            var components = diagnosticName.split("_");
            if (components.length) {
                var argCount = parseInt(components[1]);
                if (argCount != args.length) {
                    throw new Error("Expected " + argCount + " arguments to diagnostic, got " + args.length + " instead");
                }
            }
        }
        var diagnosticMessage = diagnostic.message.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });
        var message;
        if (diagnosticType != 0 /* error_2 */  && diagnosticType != 1 /* warning_2 */ ) {
            var errorOrWarning = diagnostic.category == 1 /* Error */  ? 0 /* error_2 */  : 1 /* warning_2 */ ;
            message = getDiagnosticMessage(errorOrWarning, [
                diagnostic.code, 
                diagnosticMessage
            ]);
        } else {
            message = diagnosticMessage;
        }
        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));
var IOUtils;
(function (IOUtils) {
    function createDirectoryStructure(ioHost, dirName) {
        if (ioHost.directoryExists(dirName)) {
            return;
        }
        var parentDirectory = ioHost.dirName(dirName);
        if (parentDirectory != "") {
            createDirectoryStructure(ioHost, parentDirectory);
        }
        ioHost.createDirectory(dirName);
    }
    function createFileAndFolderStructure(ioHost, fileName, useUTF8) {
        var path = ioHost.resolvePath(fileName);
        var dirName = ioHost.dirName(path);
        createDirectoryStructure(ioHost, dirName);
        return ioHost.createFile(path, useUTF8);
    }
    IOUtils.createFileAndFolderStructure = createFileAndFolderStructure;
    function throwIOError(message, error) {
        var errorMessage = message;
        if (error && error.message) {
            errorMessage += (" " + error.message);
        }
        throw new Error(errorMessage);
    }
    IOUtils.throwIOError = throwIOError;
    var BufferedTextWriter = (function () {
        function BufferedTextWriter(writer, capacity) {
            if (typeof capacity === "undefined") { capacity = 1024; }
            this.writer = writer;
            this.capacity = capacity;
            this.buffer = "";
        }
        BufferedTextWriter.prototype.Write = function (str) {
            this.buffer += str;
            if (this.buffer.length >= this.capacity) {
                this.writer.Write(this.buffer);
                this.buffer = "";
            }
        };
        BufferedTextWriter.prototype.WriteLine = function (str) {
            this.Write(str + '\r\n');
        };
        BufferedTextWriter.prototype.Close = function () {
            this.writer.Write(this.buffer);
            this.writer.Close();
            this.buffer = null;
        };
        return BufferedTextWriter;
    })();
    IOUtils.BufferedTextWriter = BufferedTextWriter;    
})(IOUtils || (IOUtils = {}));
var IO = (function () {
    function getWindowsScriptHostIO() {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var streamObjectPool = [];
        function getStreamObject() {
            if (streamObjectPool.length > 0) {
                return streamObjectPool.pop();
            } else {
                return new ActiveXObject("ADODB.Stream");
            }
        }
        function releaseStreamObject(obj) {
            streamObjectPool.push(obj);
        }
        var args = [];
        for(var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }
        return {
            readFile: function (path) {
                try  {
                    var streamObj = getStreamObject();
                    streamObj.Open();
                    streamObj.Type = 2;
                    streamObj.Charset = 'x-ansi';
                    streamObj.LoadFromFile(path);
                    var bomChar = streamObj.ReadText(2);
                    streamObj.Position = 0;
                    if ((bomChar.charCodeAt(0) == 0xFE && bomChar.charCodeAt(1) == 0xFF) || (bomChar.charCodeAt(0) == 0xFF && bomChar.charCodeAt(1) == 0xFE)) {
                        streamObj.Charset = 'unicode';
                    } else if (bomChar.charCodeAt(0) == 0xEF && bomChar.charCodeAt(1) == 0xBB) {
                        streamObj.Charset = 'utf-8';
                    }
                    var str = streamObj.ReadText(-1);
                    streamObj.Close();
                    releaseStreamObject(streamObj);
                    return str;
                } catch (err) {
                    IOUtils.throwIOError("Error reading file \"" + path + "\".", err);
                }
            },
            writeFile: function (path, contents) {
                var file = this.createFile(path);
                file.Write(contents);
                file.Close();
            },
            fileExists: function (path) {
                return fso.FileExists(path);
            },
            resolvePath: function (path) {
                return fso.GetAbsolutePathName(path);
            },
            dirName: function (path) {
                return fso.GetParentFolderName(path);
            },
            findFile: function (rootPath, partialFilePath) {
                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;
                while(true) {
                    if (fso.FileExists(path)) {
                        try  {
                            var content = this.readFile(path);
                            return {
                                content: content,
                                path: path
                            };
                        } catch (err) {
                        }
                    } else {
                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));
                        if (rootPath == "") {
                            return null;
                        } else {
                            path = fso.BuildPath(rootPath, partialFilePath);
                        }
                    }
                }
            },
            deleteFile: function (path) {
                try  {
                    if (fso.FileExists(path)) {
                        fso.DeleteFile(path, true);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't delete file '" + path + "'.", e);
                }
            },
            createFile: function (path, useUTF8) {
                try  {
                    var streamObj = getStreamObject();
                    streamObj.Charset = useUTF8 ? 'utf-8' : 'x-ansi';
                    streamObj.Open();
                    return {
                        Write: function (str) {
                            streamObj.WriteText(str, 0);
                        },
                        WriteLine: function (str) {
                            streamObj.WriteText(str, 1);
                        },
                        Close: function () {
                            try  {
                                streamObj.SaveToFile(path, 2);
                            } catch (saveError) {
                                IOUtils.throwIOError("Couldn't write to file '" + path + "'.", saveError);
                            } finally {
                                if (streamObj.State != 0) {
                                    streamObj.Close();
                                }
                                releaseStreamObject(streamObj);
                            }
                        }
                    };
                } catch (creationError) {
                    IOUtils.throwIOError("Couldn't write to file '" + path + "'.", creationError);
                }
            },
            directoryExists: function (path) {
                return fso.FolderExists(path);
            },
            createDirectory: function (path) {
                try  {
                    if (!this.directoryExists(path)) {
                        fso.CreateFolder(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't create directory '" + path + "'.", e);
                }
            },
            dir: function (path, spec, options) {
                options = options || {};
                function filesInFolder(folder, root) {
                    var paths = [];
                    var fc;
                    if (options.recursive) {
                        fc = new Enumerator(folder.subfolders);
                        for(; !fc.atEnd(); fc.moveNext()) {
                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));
                        }
                    }
                    fc = new Enumerator(folder.files);
                    for(; !fc.atEnd(); fc.moveNext()) {
                        if (!spec || fc.item().Name.match(spec)) {
                            paths.push(root + "/" + fc.item().Name);
                        }
                    }
                    return paths;
                }
                var folder = fso.GetFolder(path);
                var paths = [];
                return filesInFolder(folder, path);
            },
            print: function (str) {
                WScript.StdOut.Write(str);
            },
            printLine: function (str) {
                WScript.Echo(str);
            },
            arguments: args,
            stderr: WScript.StdErr,
            stdout: WScript.StdOut,
            watchFile: null,
            run: function (source, filename) {
                try  {
                    eval(source);
                } catch (e) {
                    IOUtils.throwIOError("Error while executing file '" + filename + "'.", e);
                }
            },
            getExecutingFilePath: function () {
                return WScript.ScriptFullName;
            },
            quit: function (exitCode) {
                if (typeof exitCode === "undefined") { exitCode = 0; }
                try  {
                    WScript.Quit(exitCode);
                } catch (e) {
                }
            }
        };
    }
    ;
    function getNodeIO() {
        var _fs = require('fs');
        var _path = require('path');
        var _module = require('module');
        return {
            readFile: function (file) {
                try  {
                    var buffer = _fs.readFileSync(file);
                    switch(buffer[0]) {
                        case 0xFE:
                            if (buffer[1] == 0xFF) {
                                var i = 0;
                                while((i + 1) < buffer.length) {
                                    var temp = buffer[i];
                                    buffer[i] = buffer[i + 1];
                                    buffer[i + 1] = temp;
                                    i += 2;
                                }
                                return buffer.toString("ucs2", 2);
                            }
                            break;
                        case 0xFF:
                            if (buffer[1] == 0xFE) {
                                return buffer.toString("ucs2", 2);
                            }
                            break;
                        case 0xEF:
                            if (buffer[1] == 0xBB) {
                                return buffer.toString("utf8", 3);
                            }
                    }
                    return buffer.toString();
                } catch (e) {
                    IOUtils.throwIOError("Error reading file \"" + file + "\".", e);
                }
            },
            writeFile: _fs.writeFileSync,
            deleteFile: function (path) {
                try  {
                    _fs.unlinkSync(path);
                } catch (e) {
                    IOUtils.throwIOError("Couldn't delete file '" + path + "'.", e);
                }
            },
            fileExists: function (path) {
                return _fs.existsSync(path);
            },
            createFile: function (path, useUTF8) {
                function mkdirRecursiveSync(path) {
                    var stats = _fs.statSync(path);
                    if (stats.isFile()) {
                        IOUtils.throwIOError("\"" + path + "\" exists but isn't a directory.", null);
                    } else if (stats.isDirectory()) {
                        return;
                    } else {
                        mkdirRecursiveSync(_path.dirname(path));
                        _fs.mkdirSync(path, 0775);
                    }
                }
                mkdirRecursiveSync(_path.dirname(path));
                try  {
                    var fd = _fs.openSync(path, 'w');
                } catch (e) {
                    IOUtils.throwIOError("Couldn't write to file '" + path + "'.", e);
                }
                return new IOUtils.BufferedTextWriter({
                    Write: function (str) {
                        _fs.writeSync(fd, str);
                    },
                    Close: function () {
                        _fs.closeSync(fd);
                        fd = null;
                    }
                });
            },
            dir: function dir(path, spec, options) {
                options = options || {};
                function filesInFolder(folder) {
                    var paths = [];
                    var files = _fs.readdirSync(folder);
                    for(var i = 0; i < files.length; i++) {
                        var stat = _fs.statSync(folder + "/" + files[i]);
                        if (options.recursive && stat.isDirectory()) {
                            paths = paths.concat(filesInFolder(folder + "/" + files[i]));
                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                            paths.push(folder + "/" + files[i]);
                        }
                    }
                    return paths;
                }
                return filesInFolder(path);
            },
            createDirectory: function (path) {
                try  {
                    if (!this.directoryExists(path)) {
                        _fs.mkdirSync(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't create directory '" + path + "'.", e);
                }
            },
            directoryExists: function (path) {
                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();
            },
            resolvePath: function (path) {
                return _path.resolve(path);
            },
            dirName: function (path) {
                return _path.dirname(path);
            },
            findFile: function (rootPath, partialFilePath) {
                var path = rootPath + "/" + partialFilePath;
                while(true) {
                    if (_fs.existsSync(path)) {
                        try  {
                            var content = this.readFile(path);
                            return {
                                content: content,
                                path: path
                            };
                        } catch (err) {
                        }
                    } else {
                        var parentPath = _path.resolve(rootPath, "..");
                        if (rootPath === parentPath) {
                            return null;
                        } else {
                            rootPath = parentPath;
                            path = _path.resolve(rootPath, partialFilePath);
                        }
                    }
                }
            },
            print: function (str) {
                process.stdout.write(str);
            },
            printLine: function (str) {
                process.stdout.write(str + '\n');
            },
            arguments: process.argv.slice(2),
            stderr: {
                Write: function (str) {
                    process.stderr.write(str);
                },
                WriteLine: function (str) {
                    process.stderr.write(str + '\n');
                },
                Close: function () {
                }
            },
            stdout: {
                Write: function (str) {
                    process.stdout.write(str);
                },
                WriteLine: function (str) {
                    process.stdout.write(str + '\n');
                },
                Close: function () {
                }
            },
            watchFile: function (filename, callback) {
                var firstRun = true;
                var processingChange = false;
                var fileChanged = function (curr, prev) {
                    if (!firstRun) {
                        if (curr.mtime < prev.mtime) {
                            return;
                        }
                        _fs.unwatchFile(filename, fileChanged);
                        if (!processingChange) {
                            processingChange = true;
                            callback(filename);
                            setTimeout(function () {
                                processingChange = false;
                            }, 100);
                        }
                    }
                    firstRun = false;
                    _fs.watchFile(filename, {
                        persistent: true,
                        interval: 500
                    }, fileChanged);
                };
                fileChanged();
                return {
                    filename: filename,
                    close: function () {
                        _fs.unwatchFile(filename, fileChanged);
                    }
                };
            },
            run: function (source, filename) {
                require.main.filename = filename;
                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(filename)));
                require.main._compile(source, filename);
            },
            getExecutingFilePath: function () {
                return process.mainModule.filename;
            },
            quit: process.exit
        };
    }
    ;
    if (typeof ActiveXObject === "function") {
        return getWindowsScriptHostIO();
    } else if (typeof require === "function") {
        return getNodeIO();
    } else {
        return null;
    }
})();
var OptionsParser = (function () {
    function OptionsParser(host) {
        this.host = host;
        this.DEFAULT_SHORT_FLAG = "-";
        this.DEFAULT_LONG_FLAG = "--";
        this.unnamed = [];
        this.options = [];
    }
    OptionsParser.prototype.findOption = function (arg) {
        for(var i = 0; i < this.options.length; i++) {
            if (arg === this.options[i].short || arg === this.options[i].name) {
                return this.options[i];
            }
        }
        return null;
    };
    OptionsParser.prototype.printUsage = function () {
        this.host.printLine("Syntax:   tsc [options] [file ..]");
        this.host.printLine("");
        this.host.printLine("Examples: tsc hello.ts");
        this.host.printLine("          tsc --out foo.js foo.ts");
        this.host.printLine("          tsc @args.txt");
        this.host.printLine("");
        this.host.printLine("Options:");
        var output = [];
        var maxLength = 0;
        this.options = this.options.sort(function (a, b) {
            var aName = a.name.toLowerCase();
            var bName = b.name.toLowerCase();
            if (aName > bName) {
                return 1;
            } else if (aName < bName) {
                return -1;
            } else {
                return 0;
            }
        });
        for(var i = 0; i < this.options.length; i++) {
            var option = this.options[i];
            if (option.experimental) {
                continue;
            }
            if (!option.usage) {
                break;
            }
            var usageString = "  ";
            var type = option.type ? " " + option.type.toUpperCase() : "";
            if (option.short) {
                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";
            }
            usageString += this.DEFAULT_LONG_FLAG + option.name + type;
            output.push([
                usageString, 
                option.usage
            ]);
            if (usageString.length > maxLength) {
                maxLength = usageString.length;
            }
        }
        output.push([
            "  @<file>", 
            "Insert command line options and files from a file."
        ]);
        for(var i = 0; i < output.length; i++) {
            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);
        }
    };
    OptionsParser.prototype.option = function (name, config, short) {
        if (!config) {
            config = short;
            short = null;
        }
        config.name = name;
        config.short = short;
        config.flag = false;
        this.options.push(config);
    };
    OptionsParser.prototype.flag = function (name, config, short) {
        if (!config) {
            config = short;
            short = null;
        }
        config.name = name;
        config.short = short;
        config.flag = true;
        this.options.push(config);
    };
    OptionsParser.prototype.parseString = function (argString) {
        var position = 0;
        var tokens = argString.match(/\s+|"|[^\s"]+/g);
        function peek() {
            return tokens[position];
        }
        function consume() {
            return tokens[position++];
        }
        function consumeQuotedString() {
            var value = '';
            consume();
            var token = peek();
            while(token && token !== '"') {
                consume();
                value += token;
                token = peek();
            }
            consume();
            return value;
        }
        var args = [];
        var currentArg = '';
        while(position < tokens.length) {
            var token = peek();
            if (token === '"') {
                currentArg += consumeQuotedString();
            } else if (token.match(/\s/)) {
                if (currentArg.length > 0) {
                    args.push(currentArg);
                    currentArg = '';
                }
                consume();
            } else {
                consume();
                currentArg += token;
            }
        }
        if (currentArg.length > 0) {
            args.push(currentArg);
        }
        this.parse(args);
    };
    OptionsParser.prototype.parse = function (args) {
        var position = 0;
        function consume() {
            return args[position++];
        }
        while(position < args.length) {
            var current = consume();
            var match = current.match(/^(--?|@)(.*)/);
            var value = null;
            if (match) {
                if (match[1] === '@') {
                    this.parseString(this.host.readFile(match[2]));
                } else {
                    var arg = match[2];
                    var option = this.findOption(arg);
                    if (option === null) {
                        this.host.printLine("Unknown option '" + arg + "'");
                        this.host.printLine("Use the '--help' flag to see options");
                    } else {
                        if (!option.flag) {
                            value = consume();
                        }
                        option.set(value);
                    }
                }
            } else {
                this.unnamed.push(current);
            }
        }
    };
    return OptionsParser;
})();
var DiagnosticsLogger = (function () {
    function DiagnosticsLogger(ioHost) {
        this.ioHost = ioHost;
    }
    DiagnosticsLogger.prototype.information = function () {
        return false;
    };
    DiagnosticsLogger.prototype.debug = function () {
        return false;
    };
    DiagnosticsLogger.prototype.warning = function () {
        return false;
    };
    DiagnosticsLogger.prototype.error = function () {
        return false;
    };
    DiagnosticsLogger.prototype.fatal = function () {
        return false;
    };
    DiagnosticsLogger.prototype.log = function (s) {
        this.ioHost.stdout.WriteLine(s);
    };
    return DiagnosticsLogger;
})();
var ErrorReporter = (function () {
    function ErrorReporter(ioHost) {
        this.ioHost = ioHost;
        this.hasErrors = false;
    }
    ErrorReporter.prototype.Write = function (s) {
        this.hasErrors = true;
        this.ioHost.stderr.Write(s);
    };
    ErrorReporter.prototype.WriteLine = function (s) {
        this.hasErrors = true;
        this.ioHost.stderr.WriteLine(s);
    };
    ErrorReporter.prototype.Close = function () {
    };
    ErrorReporter.prototype.reset = function () {
        this.hasErrors = false;
    };
    return ErrorReporter;
})();
var CommandLineHost = (function () {
    function CommandLineHost(compilationSettings, errorReporter) {
        this.compilationSettings = compilationSettings;
        this.errorReporter = errorReporter;
        this.pathMap = {};
        this.resolvedPaths = {};
    }
    CommandLineHost.prototype.getPathIdentifier = function (path) {
        return this.compilationSettings.useCaseSensitiveFileResolution ? path : path.toLocaleUpperCase();
    };
    CommandLineHost.prototype.isResolved = function (path) {
        return this.resolvedPaths[this.getPathIdentifier(this.pathMap[path])] != undefined;
    };
    CommandLineHost.prototype.resolveCompilationEnvironment = function (preEnv, resolver, traceDependencies) {
        var _this = this;
        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);
        var nCode = preEnv.code.length;
        var path = "";
        var postResolutionError = function (errorFile, errorMessage) {
            _this.errorReporter(errorFile + (errorMessage == "" ? "" : ": " + errorMessage));
        };
        var resolutionDispatcher = {
            postResolutionError: function (errorFile, line, col, errorMessage) {
                _this.errorReporter(errorFile + "(" + line + "," + col + ") " + (errorMessage == "" ? "" : ": " + errorMessage));
            },
            postResolution: function (path, code) {
                var pathId = _this.getPathIdentifier(path);
                if (!_this.resolvedPaths[pathId]) {
                    resolvedEnv.code.push(code);
                    _this.resolvedPaths[pathId] = true;
                }
            }
        };
        for(var i = 0; i < nCode; i++) {
            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));
            this.pathMap[preEnv.code[i].path] = path;
            resolver.resolveCode(path, "", false, resolutionDispatcher);
        }
        return resolvedEnv;
    };
    return CommandLineHost;
})();
var BatchCompiler = (function () {
    function BatchCompiler(ioHost) {
        this.ioHost = ioHost;
        this.resolvedEnvironment = null;
        this.hasResolveErrors = false;
        this.compilerVersion = "0.9.0.0";
        this.printedVersion = false;
        this.errorReporter = null;
        this.compilationSettings = new TypeScript.CompilationSettings();
        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);
        this.errorReporter = new ErrorReporter(this.ioHost);
    }
    BatchCompiler.prototype.resolve = function () {
        var _this = this;
        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);
        var commandLineHost = new CommandLineHost(this.compilationSettings, function (err) {
            return _this.errorReporter.WriteLine(err);
        });
        var ret = commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);
        for(var i = 0; i < this.compilationEnvironment.code.length; i++) {
            if (!commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {
                var path = this.compilationEnvironment.code[i].path;
                if (!TypeScript.isSTRFile(path) && !TypeScript.isDSTRFile(path) && !TypeScript.isTSFile(path) && !TypeScript.isDTSFile(path)) {
                    this.errorReporter.WriteLine("Unknown extension for file: \"" + path + "\". Only .ts and .d.ts extensions are allowed.");
                } else {
                    this.errorReporter.WriteLine("Error reading file \"" + path + "\": File not found");
                }
            }
        }
        return ret;
    };
    BatchCompiler.prototype.compile = function () {
        var _this = this;
        var compiler;
        if (typeof localizedDiagnosticMessages == "undefined") {
            localizedDiagnosticMessages = null;
        }
        var logger = this.compilationSettings.gatherDiagnostics ? new DiagnosticsLogger(this.ioHost) : new TypeScript.NullLogger();
        compiler = new TypeScript.TypeScriptCompiler(this.errorReporter, logger, this.compilationSettings, localizedDiagnosticMessages);
        compiler.setErrorOutput(this.errorReporter);
        compiler.setErrorCallback(function (minChar, charLen, message, unitIndex) {
            compiler.errorReporter.hasErrors = true;
            var fname = _this.resolvedEnvironment.code[unitIndex].path;
            var lineCol = {
                line: -1,
                col: -1
            };
            compiler.parser.getSourceLineCol(lineCol, minChar);
            var msg = fname + " (" + lineCol.line + "," + (lineCol.col + 1) + "): " + message;
            if (_this.compilationSettings.errorRecovery) {
                _this.errorReporter.WriteLine(msg);
            } else {
                throw new SyntaxError(msg);
            }
        });
        if (this.compilationSettings.emitComments) {
            compiler.emitCommentsToOutput();
        }
        var consumeUnit = function (code, addAsResident) {
            try  {
                if (!_this.compilationSettings.resolve) {
                    code.content = _this.ioHost.readFile(code.path);
                    if (_this.compilationSettings.generateDeclarationFiles) {
                        TypeScript.CompilerDiagnostics.assert(code.referencedFiles == null, "With no resolve option, referenced files need to null");
                        code.referencedFiles = TypeScript.getReferencedFiles(code);
                    }
                }
                if (code.content != null) {
                    if (_this.compilationSettings.errorRecovery) {
                        compiler.parser.setErrorRecovery(_this.errorReporter);
                    }
                    compiler.addUnit(code.content, code.path, addAsResident, code.referencedFiles);
                }
            } catch (err) {
                compiler.errorReporter.hasErrors = true;
                _this.errorReporter.WriteLine(err.message);
            }
        };
        for(var iCode = 0; iCode < this.resolvedEnvironment.code.length; iCode++) {
            consumeUnit(this.resolvedEnvironment.code[iCode], false);
        }
        var emitterIOHost = {
            createFile: function (fileName, useUTF8) {
                return IOUtils.createFileAndFolderStructure(_this.ioHost, fileName, useUTF8);
            },
            directoryExists: this.ioHost.directoryExists,
            fileExists: this.ioHost.fileExists,
            resolvePath: this.ioHost.resolvePath
        };
        try  {
            if (this.compilationSettings.usePull) {
                compiler.pullTypeCheck();
            } else {
                compiler.typeCheck();
                var mapInputToOutput = function (unitIndex, outFile) {
                    _this.compilationEnvironment.inputOutputMap[unitIndex] = outFile;
                };
                compiler.emit(emitterIOHost, mapInputToOutput);
                compiler.emitDeclarations();
            }
        } catch (err) {
            compiler.errorReporter.hasErrors = true;
            if (err.message != "EmitError") {
                throw err;
            }
        }
        return compiler.errorReporter.hasErrors;
    };
    BatchCompiler.prototype.run = function () {
        for(var i in this.compilationEnvironment.code) {
            var outputFileName = this.compilationEnvironment.inputOutputMap[i];
            if (this.ioHost.fileExists(outputFileName)) {
                var unitRes = this.ioHost.readFile(outputFileName);
                this.ioHost.run(unitRes, outputFileName);
            }
        }
    };
    BatchCompiler.prototype.batchCompile = function () {
        var _this = this;
        TypeScript.CompilerDiagnostics.diagnosticWriter = {
            Alert: function (s) {
                _this.ioHost.printLine(s);
            }
        };
        var code;
        var opts = new OptionsParser(this.ioHost);
        opts.option('out', {
            usage: 'Concatenate and emit output to single file | Redirect output structure to the directory',
            type: 'file|directory',
            set: function (str) {
                _this.compilationSettings.outputOption = str;
            }
        });
        opts.option('style', {
            usage: 'Select style checking options (examples --style requireSemi:off or --style "eqeqeq;bitwise:off")',
            experimental: true,
            set: function (str) {
                _this.compilationSettings.setStyleOptions(str);
            }
        });
        opts.flag('sourcemap', {
            usage: 'Generates corresponding .map file',
            set: function () {
                _this.compilationSettings.mapSourceFiles = true;
            }
        });
        opts.flag('fullSourceMapPath', {
            usage: 'Writes the full path of map file in the generated js file',
            experimental: true,
            set: function () {
                _this.compilationSettings.emitFullSourceMapPath = true;
            }
        });
        opts.flag('declaration', {
            usage: 'Generates corresponding .d.ts file',
            set: function () {
                _this.compilationSettings.generateDeclarationFiles = true;
            }
        });
        if (this.ioHost.watchFile) {
            opts.flag('watch', {
                usage: 'Watch output files',
                set: function () {
                    _this.compilationSettings.watch = true;
                }
            }, 'w');
        }
        opts.flag('exec', {
            usage: 'Execute the script after compilation',
            set: function () {
                _this.compilationSettings.exec = true;
            }
        }, 'e');
        opts.flag('minw', {
            usage: 'Minimize whitespace',
            experimental: true,
            set: function () {
                _this.compilationSettings.minWhitespace = true;
            }
        }, 'mw');
        opts.flag('const', {
            usage: 'Propagate constants to emitted code',
            experimental: true,
            set: function () {
                _this.compilationSettings.propagateConstants = true;
            }
        });
        opts.flag('errorrecovery', {
            usage: 'Enable error recovery',
            experimental: true,
            set: function () {
                _this.compilationSettings.errorRecovery = true;
            }
        }, 'er');
        opts.flag('comments', {
            usage: 'Emit comments to output',
            set: function () {
                _this.compilationSettings.emitComments = true;
            }
        }, 'c');
        opts.flag('cflow', {
            usage: 'Control flow',
            experimental: true,
            set: function () {
                _this.compilationSettings.controlFlow = true;
            }
        });
        opts.flag('cflowp', {
            usage: 'Print control flow',
            experimental: true,
            set: function () {
                _this.compilationSettings.controlFlow = true;
                _this.compilationSettings.printControlFlow = true;
            }
        });
        opts.flag('cflowu', {
            usage: 'Print Use Def control flow',
            experimental: true,
            set: function () {
                _this.compilationSettings.controlFlow = true;
                _this.compilationSettings.controlFlowUseDef = true;
            }
        });
        opts.flag('noerroronwith', {
            usage: 'Allow with statements',
            experimental: true,
            set: function () {
                _this.compilationSettings.errorOnWith = false;
            }
        });
        opts.flag('noresolve', {
            usage: 'Skip resolution and preprocessing',
            experimental: true,
            set: function () {
                _this.compilationSettings.resolve = false;
                _this.compilationSettings.preprocess = false;
            }
        });
        opts.flag('debug', {
            usage: 'Print debug output',
            experimental: true,
            set: function () {
                TypeScript.CompilerDiagnostics.debug = true;
            }
        });
        opts.flag('canCallDefinitionSignature', {
            usage: 'Allows you to call the definition signature of an overload group',
            experimental: true,
            set: function () {
                _this.compilationSettings.canCallDefinitionSignature = true;
            }
        });
        opts.flag('nooptimizemodules', {
            usage: 'Do not optimize module codegen',
            experimental: true,
            set: function () {
                TypeScript.optimizeModuleCodeGen = false;
            }
        });
        opts.flag('nolib', {
            usage: 'Do not include a default lib.d.ts with global declarations',
            set: function () {
                _this.compilationSettings.useDefaultLib = false;
            }
        });
        opts.flag('inferProperties', {
            usage: 'Infer class properties from top-level assignments to \'this\'',
            experimental: true,
            set: function () {
                _this.compilationSettings.inferPropertiesFromThisAssignment = true;
            }
        });
        opts.flag('diagnostics', {
            usage: 'gather diagnostic info about the compilation process',
            experimental: true,
            set: function () {
                _this.compilationSettings.gatherDiagnostics = true;
            }
        });
        opts.flag('pull', {
            usage: 'use "pull model" for typecheck operations',
            experimental: true,
            set: function () {
                _this.compilationSettings.usePull = true;
                _this.compilationSettings.useFidelity = true;
            }
        });
        opts.option('target', {
            usage: 'Specify ECMAScript target version: "ES3" (default), or "ES5"',
            type: 'VER',
            set: function (type) {
                type = type.toLowerCase();
                if (type === 'es3') {
                    _this.compilationSettings.codeGenTarget = 0 /* ES3 */ ;
                } else if (type === 'es5') {
                    _this.compilationSettings.codeGenTarget = 1 /* ES5 */ ;
                } else {
                    _this.errorReporter.WriteLine("ECMAScript target version '" + type + "' not supported.  Using default 'ES3' code generation");
                }
            }
        });
        opts.option('module', {
            usage: 'Specify module code generation: "commonjs" (default) or "amd"',
            type: 'kind',
            set: function (type) {
                type = type.toLowerCase();
                if (type === 'commonjs' || type === 'node') {
                    TypeScript.moduleGenTarget = 0 /* Synchronous */ ;
                } else if (type === 'amd') {
                    TypeScript.moduleGenTarget = 1 /* Asynchronous */ ;
                } else {
                    _this.errorReporter.WriteLine("Module code generation '" + type + "' not supported.  Using default 'commonjs' code generation");
                }
            }
        });
        var printedUsage = false;
        opts.flag('help', {
            usage: 'Print this message',
            set: function () {
                _this.printVersion();
                opts.printUsage();
                printedUsage = true;
            }
        }, 'h');
        opts.flag('useCaseSensitiveFileResolution', {
            usage: 'Force file resolution to be case sensitive',
            experimental: true,
            set: function () {
                _this.compilationSettings.useCaseSensitiveFileResolution = true;
            }
        });
        opts.flag('version', {
            usage: 'Print the compiler\'s version: ' + this.compilerVersion,
            set: function () {
                _this.printVersion();
            }
        }, 'v');
        opts.flag('fidelity', {
            usage: 'Use the fidelity parser.',
            experimental: true,
            set: function () {
                _this.compilationSettings.useFidelity = true;
            }
        });
        opts.parse(this.ioHost.arguments);
        if (this.compilationSettings.useDefaultLib) {
            var compilerFilePath = this.ioHost.getExecutingFilePath();
            var binDirPath = this.ioHost.dirName(compilerFilePath);
            var libStrPath = this.ioHost.resolvePath(binDirPath + "/lib.d.ts");
            code = new TypeScript.SourceUnit(libStrPath, null);
            this.compilationEnvironment.code.push(code);
        }
        for(var i = 0; i < opts.unnamed.length; i++) {
            code = new TypeScript.SourceUnit(opts.unnamed[i], null);
            this.compilationEnvironment.code.push(code);
        }
        if (this.compilationEnvironment.code.length == (this.compilationSettings.useDefaultLib ? 1 : 0)) {
            if (!printedUsage && !this.printedVersion) {
                this.printVersion();
                opts.printUsage();
                this.ioHost.quit(1);
            }
            return;
        }
        var sourceFiles = [];
        if (this.compilationSettings.watch) {
            sourceFiles = this.compilationEnvironment.code.slice(0);
        }
        this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;
        this.compile();
        if (!this.errorReporter.hasErrors) {
            if (this.compilationSettings.exec) {
                this.run();
            }
        }
        if (this.compilationSettings.watch) {
            this.watchFiles(sourceFiles);
        } else {
            this.ioHost.quit(this.errorReporter.hasErrors ? 1 : 0);
        }
    };
    BatchCompiler.prototype.printVersion = function () {
        if (!this.printedVersion) {
            this.ioHost.printLine("Version " + this.compilerVersion);
            this.printedVersion = true;
        }
    };
    BatchCompiler.prototype.watchFiles = function (soruceFiles) {
        var _this = this;
        if (!this.ioHost.watchFile) {
            this.errorReporter.WriteLine("Error: Current host does not support -w[atch] option");
            return;
        }
        var resolvedFiles = [];
        var watchers = {};
        var addWatcher = function (filename) {
            if (!watchers[filename]) {
                var watcher = _this.ioHost.watchFile(filename, onWatchedFileChange);
                watchers[filename] = watcher;
            } else {
                TypeScript.CompilerDiagnostics.debugPrint("Cannot watch file, it is already watched.");
            }
        };
        var removeWatcher = function (filename) {
            if (watchers[filename]) {
                watchers[filename].close();
                delete watchers[filename];
            } else {
                TypeScript.CompilerDiagnostics.debugPrint("Cannot stop watching file, it is not being watched.");
            }
        };
        var onWatchedFileChange = function () {
            _this.compilationEnvironment.code = soruceFiles;
            _this.errorReporter.reset();
            _this.resolvedEnvironment = _this.compilationSettings.resolve ? _this.resolve() : _this.compilationEnvironment;
            var oldFiles = resolvedFiles;
            var newFiles = [];
            _this.resolvedEnvironment.code.forEach(function (sf) {
                return newFiles.push(sf.path);
            });
            newFiles = newFiles.sort();
            var i = 0, j = 0;
            while(i < oldFiles.length && j < newFiles.length) {
                var compareResult = oldFiles[i].localeCompare(newFiles[j]);
                if (compareResult == 0) {
                    i++;
                    j++;
                } else if (compareResult < 0) {
                    removeWatcher(oldFiles[i]);
                    i++;
                } else {
                    addWatcher(newFiles[j]);
                    j++;
                }
            }
            for(var k = i; k < oldFiles.length; k++) {
                removeWatcher(oldFiles[k]);
            }
            for(var k = j; k < newFiles.length; k++) {
                addWatcher(newFiles[k]);
            }
            resolvedFiles = newFiles;
            ;
            _this.ioHost.printLine("");
            _this.ioHost.printLine("Recompiling (" + new Date() + "): ");
            resolvedFiles.forEach(function (f) {
                return _this.ioHost.printLine("    " + f);
            });
            _this.compile();
            if (!_this.errorReporter.hasErrors) {
                if (_this.compilationSettings.exec) {
                    _this.run();
                }
            }
        };
        this.ioHost.stderr = this.ioHost.stdout;
        this.resolvedEnvironment.code.forEach(function (sf) {
            resolvedFiles.push(sf.path);
            addWatcher(sf.path);
        });
        resolvedFiles.sort();
    };
    return BatchCompiler;
})();
var batch = new BatchCompiler(IO);
batch.batchCompile();
