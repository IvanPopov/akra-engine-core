


//"use strict";












/// @data: data
/// @DATA: {data}|location()



// #define CRYPTO_API 1
// #define GUI 1

// #define WEBGL_DEBUG 1

// #define DETAILED_LOG 1

//trace all render entry
// #define __VIEW_INTERNALS__ 1

//#define FILEDROP_API 1





module akra {

	export enum ELogLevel {
        NONE = 0x0000,
        LOG = 0x0001,
        INFORMATION = 0x0002,
        WARNING = 0x0004,
        ERROR = 0x0008,
        CRITICAL = 0x0010,
        ALL = 0x001F
    }

    export interface ILogRoutineFunc {
        (pEntity: ILoggerEntity): void;
    }

    export interface ISourceLocation {
        file: string;
        line:  number ;
    }

    export interface ILoggerEntity {
        code:  number ;
        location: ISourceLocation;
        message?: string;
        info: any;
    }

    export interface ILogger {

///**
//* For plugin api:
//* Load file with custom user codes and three messages 
//*/
//loadManifestFile(): bool;

        init(): bool;

        setLogLevel(eLevel: ELogLevel): void;
        getLogLevel(): ELogLevel;

        registerCode(eCode:  number , sMessage?: string): bool;
        setUnknownCode(eCode:  number , sMessage: string): void;

        registerCodeFamily(eCodeMin:  number , eCodeMax:  number , sFamilyName?: string): bool;

        getFamilyName(eCode:  number ): string;

        setCodeFamilyRoutine(eCodeFromFamily:  number , fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine(sFamilyName: string, fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;

        setLogRoutine(fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): void;

        setSourceLocation(sFile: string, iLine:  number ): void;
        setSourceLocation(pLocation: ISourceLocation): void;

// Print messages methods

        log(...pArgs: any[]);

        info(pEntity: ILoggerEntity): void;
        info(eCode:  number , ...pArgs: any[]): void;
        info(...pArgs: any[]): void;

        warning(pEntity: ILoggerEntity): void;
        warning(eCode:  number , ...pArgs: any[]): void;
        warning(...pArgs: any[]): void;

        error(pEntity: ILoggerEntity): void;
        error(eCode:  number , ...pArgs: any[]): void;
        error(...pArgs: any[]): void;

        criticalError(pEntity: ILoggerEntity): void;
        criticalError(eCode:  number , ...pArgs: any[]): void;
        criticalError(...pArgs: any[]):void;

        assert(bCondition: bool, pEntity: ILoggerEntity): void;
        assert(bCondition: bool, eCode:  number , ...pArgs: any[]): void;
        assert(bCondition: bool, ...pArgs: any[]):void;

    }
}






























/*I ## */
/*I ## */
/*I ## */
/*I ## */


// #define IFACE(IF) export interface IF {}


module akra {
    var p = document.getElementsByTagName("script");
    export  /**@const*/var  DATA = (akra.DATA || ((<Element>p[p.length - 1]).getAttribute("data")) || "@DATA") + "/";




    export var  DEBUG : bool = true;






    export var logger: ILogger;
    export var typeOf: (x: any) => string;

    typeOf = function typeOf(x: any): string {
        var s: string = typeof x;

        if (s === "object") {
            if (x) {

                if (x instanceof Array) {
                    return 'array';
                } else if (x instanceof Object) {
                    return s;
                }

                var sClassName = Object.prototype.toString.call(x);

                if (sClassName == '[object Window]') {
                    return 'object';
                }

                if ((sClassName == '[object Array]' ||
                     typeof x.length == 'number' &&
                     typeof x.splice != 'undefined' &&
                     typeof x.propertyIsEnumerable != 'undefined' &&
                     !x.propertyIsEnumerable('splice')

                    )) {
                    return 'array';
                }

                if ((sClassName == '[object Function]' ||
                    typeof x.call != 'undefined' &&
                    typeof x.propertyIsEnumerable != 'undefined' &&
                    !x.propertyIsEnumerable('call'))) {
                    return 'function';
                }

            } else {
                return 'null';
            }

        } else if (s == 'function' && typeof x.call == 'undefined') {
            return 'object';
        }
        return s;
    };


/** @inline */

    export var isDef = (x: any): bool =>  x !== undefined;
/** @inline */

    export var isEmpty = (x: any): bool =>  x.length == 0;

// Note that undefined == null.
/** @inline */

    export var isDefAndNotNull = (x: any): bool =>  x != null;

/** @inline */

    export var isNull = (x: any): bool =>  x === null;

/** @inline */

    export var isBoolean = (x: any): bool => typeof x === "boolean";

/** @inline */

    export var isString = (x: any): bool => typeof x === "string";

/** @inline */

    export var isNumber = (x: any): bool => typeof x === "number";
/** @inline */

    export var isFloat = isNumber;
/** @inline */

    export var isInt = isNumber;

/** @inline */

    export var isFunction = (x: any): bool => typeOf(x) === "function";

/** @inline */

    export var isObject = (x: any): bool => {
        var type = typeOf(x);
        return type == "object" || type == "array" || type == "function";
    };

    export var isArrayBuffer = (x: any): bool => x instanceof ArrayBuffer;

    export var isTypedArray = (x: any): bool => x !== null && typeof x === "object" && typeof x.byteOffset === "number";

    export var isBlob = (x: any): bool => x instanceof Blob;

/** @inline */

    export var isArray = (x: any): bool => {
        return typeOf(x) == "array";
    };

    export function fnSortMinMax(a: number, b: number): number {
        return a - b;
    }

    export function fnSortMaxMin(a: number, b: number): number {
        return b - a;
    }

    export function binarySearchInSortIntArray(pArray:  number [], iValue:  number ):  number  {
        if(iValue < pArray[0] || iValue > pArray[pArray.length - 1]){
            return -1;
        }

        if(iValue === pArray[0]){
            return 0;
        }

        if(iValue === pArray[pArray.length - 1]){
            return pArray.length - 1;
        }

        var p:  number  = 0;
        var q:  number  = pArray.length - 1;

        while(p < q){
            var s:  number  = (p + q) >> 1;

            if(iValue === pArray[s]){
                return s;
            }
            else if(iValue > pArray[s]){
                p = s + 1;
            }
            else {
                q = s;
            }
        }

        return -1;
    }

// data convertion

    export interface IConverter {
        (data: string, output: any[], from?:  number ):  number ;
    }

    export interface IConvertionTableRow {
        type: any;
        converter: IConverter;
    }

    export interface IConvertionTable {
        [type: string]: IConvertionTableRow;
    }

     var pConvFormats: IConvertionTable;

    export function parseBool(sValue: string): bool;
    export function parseString(sValue: string): string;
    export function retrieve(pSrc: any[], pDst: any[], iStride?:  number , iFrom?:  number , iCount?:  number , iOffset?:  number , iLen?:  number ):  number ;

    export function string2Array(sData: string, ppData: any[], fnConv: (data: string) => any, iFrom?:  number ):  number ;
    export function string2IntArray(sData: string, ppData:  number [], iFrom?:  number ):  number ;
    export function string2FloatArray(sData: string, ppData:  number [], iFrom?:  number ):  number ;
    export function string2BoolArray(sData: string, ppData: bool[], iFrom?:  number ):  number ;
    export function string2StringArray(sData: string, ppData: string[], iFrom?:  number ):  number ;

    export function string2Any(sData: string, n:  number , sType: string, isArray?: bool): any;

// data convertion

    pConvFormats = {
        "int"    : { type: Int32Array,      converter: string2IntArray      },
        "float"  : { type: Float32Array,    converter: string2FloatArray    },
        "bool"   : { type: Array,           converter: string2BoolArray     },
        "string" : { type: Array,           converter: string2StringArray   }
    };

    export  /**@inline*/  function parseBool(sValue: string): bool {
        return (sValue === "true");
    }

    export  /**@inline*/  function parseString(sValue: string): string {
        return String(sValue);
    }

/**
     * Получить часть данных массива
     * @param pSrc
     * @param pDst
     * @param iStride шаг (количество элементов в шаге)
     * @param iFrom номер элемента с которого начинать
     * @param iCount сколько элементов надо получить
     * @param iOffset смещение внутри шага (в элементах)
     * @param iLen количество элементов в шаге.
     */


    export function retrieve(pSrc: any[], pDst: any[], iStride:  number  = 1, iFrom:  number  = 0, iCount?:  number , iOffset:  number  = 0, iLen:  number  = iStride - iOffset):  number  {

        if (!isDef(iCount)) {
            iCount = (pSrc.length / iStride - iFrom);
        }

        if (iOffset + iLen > iStride) {
            iLen = iStride - iOffset;
        }

        var iBegin:  number  = iFrom * iStride;
        var n:  number  = 0;

        for (var i:  number  = 0; i < iCount; ++i) {
            for (var j = 0; j < iLen; ++j) {
                pDst[n++] = (pSrc[iBegin + i * iStride + iOffset + j]);
            }
        }

        return n;
    }

    export function string2Array(sData: string, ppData: any[], fnConv: (data: string) => any = parseFloat, iFrom:  number  = 0):  number  {
        var pData: string[] = sData.split(/[\s]+/g);

        for (var i = 0, n = pData.length, j = 0; i < n; ++i) {
            if (pData[i] != "") {
                ppData[iFrom + j] = fnConv(pData[i]);
                j++;
            }
        }

        return j;
    }

    export  /**@inline*/  function string2IntArray(sData: string, ppData:  number [], iFrom?:  number ):  number  {
        return string2Array(sData, ppData, parseInt, iFrom);
    }

    export  /**@inline*/  function string2FloatArray(sData: string, ppData:  number [], iFrom?:  number ):  number  {
        return string2Array(sData, ppData, parseFloat, iFrom);
    }

    export  /**@inline*/  function string2BoolArray(sData: string, ppData: bool[], iFrom?:  number ):  number  {
        return string2Array(sData, ppData, parseBool, iFrom);
    }

    export  /**@inline*/  function string2StringArray(sData: string, ppData: string[], iFrom?:  number ):  number  {
        return string2Array(sData, ppData, parseString, iFrom);
    }


    export function string2Any(sData: string, n:  number , sType: string, isArray = false): any {
        var ppData: any = new (pConvFormats[sType].type)(n);

        pConvFormats[sType].converter(sData, ppData);

        if (n == 1 && !isArray) {
            return ppData[0];
        }

        return ppData;
    };

    export interface Pair {
        first: any;
        second: any;
    };

// if (!isDef(console.assert)) {
//     console.assert = function (isOK?: bool, ...pParams: any[]): void {
//         if (!isOK) {
//             trace('---------------------------');
//             trace.apply(null, pParams);
//             throw new Error("[assertion failed]");
//         }
//     }
// }

// export var trace = console.log.bind(console);
// export var assert = console.assert.bind(console);
// export var warning = console.warn.bind(console);
// export var error = console.error.bind(console); 









// export var debug_print = (pArg:any, ...pParams: any[]): void => {
//         trace.apply(null, arguments);
// }

// export var debug_assert = (isOK: bool, ...pParams: any[]): void => {
//         assert.apply(null, arguments);
// }

// export var debug_warning = (pArg:any, ...pParams: any[]): void => {
//         warning.apply(null, arguments);
// }

// export var debug_error = (pArg:any, ...pParams: any[]): void => {
//         error.apply(null, arguments);
// }




    export function genArray(pType: any, nSize:  number ) {
        var tmp = new Array(nSize);

        for (var i:  number  = 0; i < nSize; ++i) {
            tmp[i] = (pType? new pType: null);
        }

        return tmp;
    }


    export  /**@const*/var  INVALID_INDEX:  number  =  0xffff;

// (-2147483646);
    export  /**@const*/var  MIN_INT32:  number  = 0xffffffff;
// ( 2147483647);
    export  /**@const*/var  MAX_INT32:  number  = 0x7fffffff;
// (-32768);
    export  /**@const*/var  MIN_INT16:  number  = 0xffff;
// ( 32767);  
    export  /**@const*/var  MAX_INT16:  number  = 0x7fff;
// (-128);
    export  /**@const*/var  MIN_INT8:  number  = 0xff;
// ( 127);        
    export  /**@const*/var  MAX_INT8:  number  = 0x7f;
    export  /**@const*/var  MIN_UINT32:  number  = 0;
    export  /**@const*/var  MAX_UINT32:  number  = 0xffffffff;
    export  /**@const*/var  MIN_UINT16:  number  = 0;
    export  /**@const*/var  MAX_UINT16:  number  = 0xffff;
    export  /**@const*/var  MIN_UINT8:  number  = 0;
    export  /**@const*/var  MAX_UINT8:  number  = 0xff;


    export  /**@const*/var  SIZE_FLOAT64:  number  = 8;
    export  /**@const*/var  SIZE_REAL64:  number  = 8;
    export  /**@const*/var  SIZE_FLOAT32:  number  = 4;
    export  /**@const*/var  SIZE_REAL32:  number  = 4;
    export  /**@const*/var  SIZE_INT32:  number  = 4;
    export  /**@const*/var  SIZE_UINT32:  number  = 4;
    export  /**@const*/var  SIZE_INT16:  number  = 2;
    export  /**@const*/var  SIZE_UINT16:  number  = 2;
    export  /**@const*/var  SIZE_INT8:  number  = 1;
    export  /**@const*/var  SIZE_UINT8:  number  = 1;
    export  /**@const*/var  SIZE_BYTE:  number  = 1;
    export  /**@const*/var  SIZE_UBYTE:  number  = 1;

//1.7976931348623157e+308
    export  /**@const*/var  MAX_FLOAT64:  number  = Number.MAX_VALUE;
//-1.7976931348623157e+308
    export  /**@const*/var  MIN_FLOAT64:  number  = -Number.MAX_VALUE;
//5e-324
    export  /**@const*/var  TINY_FLOAT64:  number  = Number.MIN_VALUE;

//    export const MAX_REAL64: number = Number.MAX_VALUE;   //1.7976931348623157e+308
//    export const MIN_REAL64: number = -Number.MAX_VALUE;  //-1.7976931348623157e+308
//    export const TINY_REAL64: number = Number.MIN_VALUE;  //5e-324


//3.4e38
    export  /**@const*/var  MAX_FLOAT32:  number  = 3.4e38;
//-3.4e38
    export  /**@const*/var  MIN_FLOAT32:  number  = -3.4e38;
//1.5e-45  
    export  /**@const*/var  TINY_FLOAT32:  number  = 1.5e-45;

//    export const MAX_REAL32: number = 3.4e38;     //3.4e38
//    export const MIN_REAL32: number = -3.4e38;    //-3.4e38
//    export const TINY_REAL32: number = 1.5e-45;   //1.5e-45

    export  /**@const*/var  DEFAULT_MATERIAL_NAME: string =  "default" ;

    export enum EDataTypes {
        BYTE = 0x1400,
        UNSIGNED_BYTE = 0x1401,
        SHORT = 0x1402,
        UNSIGNED_SHORT = 0x1403,
        INT = 0x1404,
        UNSIGNED_INT = 0x1405,
        FLOAT = 0x1406
    };

    export enum EDataTypeSizes {
        BYTES_PER_BYTE = 1,
        BYTES_PER_UNSIGNED_BYTE = 1,
        BYTES_PER_UBYTE = 1,

        BYTES_PER_SHORT = 2,
        BYTES_PER_UNSIGNED_SHORT = 2,
        BYTES_PER_USHORT = 2,

        BYTES_PER_INT = 4,
        BYTES_PER_UNSIGNED_INT = 4,
        BYTES_PER_UINT = 4,

        BYTES_PER_FLOAT = 4
    };

/*
    export enum EResourceTypes {
        SURFACE = 1,
        VOLUME,
        TEXTURE,   
        VOLUMETEXTURE,
        CUBETEXTURE,
        VERTEXBUFFER,
        INDEXBUFFER,
        FORCE_DWORD = 0x7fffffff
    };

*/


    export interface StringMap {
        [index: string]: string;
        [index: number]: string;
    };

    export interface IntMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface UintMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface FloatMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface BoolMap {
        [index: string]: bool;
        [index: number]: bool;
    };

    export interface BoolDMap{
        [index: string]: BoolMap;
        [index: number]: BoolMap;
    };

    export interface StringDMap{
        [index: string]: StringMap;
        [index: number]: StringMap;
    }

/**
     * Возвращет размер типа в байтах
     **/

//export function getTypeSize(eType: EImageTypes): uint;
    export function getTypeSize(eType: EDataTypes):  number ;
    export function getTypeSize(eType):  number  {
        switch (eType) {
            case EDataTypes.BYTE:
            case EDataTypes.UNSIGNED_BYTE:
                return 1;
            case EDataTypes.SHORT:
            case EDataTypes.UNSIGNED_SHORT:
//case EImageTypes.UNSIGNED_SHORT_4_4_4_4:
//case EImageTypes.UNSIGNED_SHORT_5_5_5_1:
//case EImageTypes.UNSIGNED_SHORT_5_6_5:
                return 2;
            case EDataTypes.INT:
            case EDataTypes.UNSIGNED_INT:
            case EDataTypes.FLOAT:
                return 4;
            default:
                { logger.setSourceLocation( "common.ts" , 591 ); logger.error('unknown data/image type used'); } ;
        }
    }


    export var sid = ():  number  => (++ sid._iTotal);
    sid._iTotal = 0;


    export  /**@inline*/  function now():  number  {
        return Date.now();
    }



    export  /**@inline*/  function memcpy(pDst: ArrayBuffer, iDstOffset:  number , pSrc: ArrayBuffer, iSrcOffset:  number , nLength:  number ) {
      var dstU8 = new Uint8Array(pDst, iDstOffset, nLength);
      var srcU8 = new Uint8Array(pSrc, iSrcOffset, nLength);
      dstU8.set(srcU8);
    };


//export function 

	(<any>window).URL = (<any>window).URL ? (<any>window).URL : (<any>window).webkitURL ? (<any>window).webkitURL : null;
	(<any>window).BlobBuilder = (<any>window).WebKitBlobBuilder || (<any>window).MozBlobBuilder || (<any>window).BlobBuilder;
	(<any>window).requestFileSystem = (<any>window).requestFileSystem || (<any>window).webkitRequestFileSystem;
	(<any>window).requestAnimationFrame = (<any>window).requestAnimationFrame || (<any>window).webkitRequestAnimationFrame ||
		(<any>window).mozRequestAnimationFrame;
	(<any>window).WebSocket = (<any>window).WebSocket || (<any>window).MozWebSocket;
// (<any>window).storageInfo = (<any>window).storageInfo || (<any>window).webkitPersistentStorage ;
    (<any>window).storageInfo = (<any>window).storageInfo || (<any>window).webkitTemporaryStorage ;
    (<any>navigator).gamepads = (<any>navigator).gamepads || (<any>navigator).webkitGamepads;
    (<any>navigator).getGamepads = (<any>navigator).getGamepads || (<any>navigator).webkitGetGamepads;

    Worker.prototype.postMessage = (<any>Worker).prototype.webkitPostMessage || Worker.prototype.postMessage;
};






function utf8_encode (argString: string): string {
// Encodes an ISO-8859-1 string to UTF-8  
// 
// version: 1109.2015
// discuss at: http://phpjs.org/functions/utf8_encode
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +   improved by: sowberry
// +    tweaked by: Jack
// +   bugfixed by: Onno Marsman
// +   improved by: Yves Sucaet
// +   bugfixed by: Onno Marsman
// +   bugfixed by: Ulrich
// +   bugfixed by: Rafal Kukawski
// *     example 1: utf8_encode('Kevin van Zonneveld');
// *     returns 1: 'Kevin van Zonneveld'
    if (argString === null || typeof argString === "undefined") {
        return "";
    }
// .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    var string = (argString + "");
    var utftext = "",
        start, end, stringl = 0;

    start = end = 0;
    stringl = string.length;
    for (var n = 0; n < stringl; n++) {
        var c1 = string.charCodeAt(n);
        var enc = null;

        if (c1 < 128) {
            end++;
        } else if (c1 > 127 && c1 < 2048) {
            enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
        }
        else {
            enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128)
                + String.fromCharCode((c1 & 63) | 128);
        }
        if (enc !== null) {
            if (end > start) {
                utftext += string.slice(start, end);
            }
            utftext += enc;
            start = end = n + 1;
        }
    }

    if (end > start) {
        utftext += string.slice(start, stringl);
    }

    return utftext;
}


function utf8_decode (str_data: string): string {
// http://kevin.vanzonneveld.net
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// +      input by: Aman Gupta
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +   improved by: Norman "zEh" Fuchs
// +   bugfixed by: hitwork
// +   bugfixed by: Onno Marsman
// +      input by: Brett Zamir (http://brett-zamir.me)
// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// *     example 1: utf8_decode('Kevin van Zonneveld');
// *     returns 1: 'Kevin van Zonneveld'
    var tmp_arr = [],
        i = 0,
        ac = 0,
        c1 = 0,
        c2 = 0,
        c3 = 0;

    str_data += "";

    while (i < str_data.length) {
        c1 = str_data.charCodeAt(i);
        if (c1 < 128) {
            tmp_arr[ac++] = String.fromCharCode(c1);
            i++;
        } else if (c1 > 191 && c1 < 224) {
            c2 = str_data.charCodeAt(i + 1);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
            i += 2;
        }
        else {
            c2 = str_data.charCodeAt(i + 1);
            c3 = str_data.charCodeAt(i + 2);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }

    return tmp_arr.join("");
}



interface String {
    toUTF8(): string;
    fromUTF8(): string;



    replaceAt(n:  number , s: string);

}

interface Array {
    last: any;
    first: any;
    el(i : number ): any;
    clear(): any[];
    swap(i:  number , j:  number ): any[];
    insert(elements: any[]): any[];
    find(pElement: any): bool;
}

interface Number {
    toHex(length:  number ): string;
    printBinary(isPretty?: bool);
}

module akra.libs {
/**
     * Encodes an ISO-8859-1 string to UTF-8
     * @treturn String
     */

    String.prototype.toUTF8 = function () {
        return utf8_encode(this);
    };

/**
     * Converts a UTF-8 encoded string to ISO-8859-1
     * @treturn String
     */

    String.prototype.fromUTF8 = function () {
        return utf8_decode(this);
    };



    String.prototype.replaceAt = function (n, chr) {
        return this.substr(0, n) + chr + this.substr(n + chr.length);
    };


    Object.defineProperty(Array.prototype, 'first', {
        enumerable: false,
        configurable: true,
        get: function() {
            return this[0];
        }
    });

    Object.defineProperty(Array.prototype, 'last', {
        enumerable: false,
        configurable: true,
        get: function() {
            return this[this.length - 1];
        }
    });

    Object.defineProperty(Array.prototype, 'el', {
        enumerable: false,
        configurable: true,
        value: function (i) {i = i || 0; return this[i < 0? this.length + i: i];}
    });

    Object.defineProperty(Array.prototype, 'clear', {
        enumerable: false,
        configurable: true,
        value: function () {this.length = 0;}
    });

    Object.defineProperty(Array.prototype, 'swap', {
        enumerable: false,
        configurable: true,
        value: function (i, j) {
            if (i < this.length && j < this.length) {
                var t = this[i]; this[i] = this[j]; this[j] = t;
            }
        }
    });

    Object.defineProperty(Array.prototype, 'insert', {
        enumerable: false,
        configurable: true,
        value: function (pElement) {
            if (typeof pElement.length === 'number') {
                for (var i = 0, n = pElement.length; i < n; ++ i) {
                    this.push(pElement[i]);
                };
            }
            else {
                this.push(pElement);
            }

            return this;
        }
    });

    Number.prototype.toHex = function (iLength:  number ): string {
        var sValue = this.toString(16);

        for (var i = 0; i < iLength - sValue.length; ++ i) {
            sValue = '0' + sValue;
        }

        return sValue;
    };

    Number.prototype.printBinary = function (isPretty: bool = true): string {
        var res: string = "";
        for (var i = 0; i < 32; ++i) {
            if (i && (i % 4) == 0 && isPretty) {
                res = ' ' + res;
            }
            (this >> i & 0x1 ? res = '1' + res : res = '0' + res);
        }
        return res;
    };
}
















/**
 * FLAG(x)
 * Сдвиг единицы на @a x позиций влево.
 */



/**
 * TEST_BIT(value, bit)
 * Проверка того что у @a value бит под номером @a bit равен единице.
 */



/**
 * TEST_ALL(value, set)
 * Проверка того что у @a value равны единице все биты,
 * которые равны единице у @a set.
 */



/**
 * TEST_ANY(value, set)
 * Проверка того что у @a value равны единице хотя бы какие то из битов,
 * которые равны единице у @a set.
 */



/**
 * SET_BIT(value, bit)
 * Выставляет бит под номером @a bit у числа @a value равным единице
 */






/**
 * CLEAR_BIT(value, bit)
 * Выставляет бит под номером @a bit у числа @a value равным нулю
 */



/**
 * SET_ALL(value, set)
 * Выставляет все биты у числа @a value равными единице,
 * которые равны единице у числа @a set
 */



/**
 * CLEAR_ALL(value, set)
 * Выставляет все биты у числа @a value равными нулю,
 * которые равны единице у числа @a set
 */



//#define SET_ALL(value, set, setting) (setting ? SET_ALL(value, set) : CLEAR_ALL(value, set))



module akra.bf {
/**
	 * Сдвиг единицы на @a x позиций влево.
	 * @inline
	 */

	export var flag = (x:  number ) => (1 << (x));
/**
	 * Проверка того что у @a value бит под номером @a bit равен единице.
	 * @inline
	 */

	export var testBit = (value:  number , bit:  number ) => ((value & flag(bit)) != 0);
/**
	 * Проверка того что у @a value равны единице все биты,
 	 * которые равны единице у @a set.
	 * @inline
	 */

	export var testAll = (value:  number , set:  number ) => (((value) & (set)) == (set));
/**
	 * Проверка того что у @a value равны единице хотя бы какие то из битов,
 	 * которые равны единице у @a set.
	 * @inline
	 */

	export var testAny = (value:  number , set:  number ) => (((value) & (set)) != 0);
/**
	 * Выставляет бит под номером @a bit у числа @a value равным единице
	 * @inline
	 */

	export var setBit = (value:  number , bit:  number , setting: bool = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));
/**
	 * 
	 * @inline
	 */

	export var clearBit = (value:  number , bit:  number ) => ((value) &= ~flag((bit)));
/**
	 * Выставляет бит под номером @a bit у числа @a value равным нулю
	 * @inline
	 */

	export var setAll = (value:  number , set:  number , setting: bool = true) => (setting ?  ((value) |= (set))  :  ((value) &= ~(set)) );
/**
	 * Выставляет все биты у числа @a value равными единице,
 	 * которые равны единице у числа @a set
	 * @inline
	 */

	export var clearAll = (value:  number , set:  number ) => ((value) &= ~(set));
/**
	 * Выставляет все биты у числа @a value равными нулю,
 	 * которые равны единице у числа @a set
	 * @inline
	 */

	export var equal = (value:  number , src:  number ) => { value = src; };
/**
	 * Прирасваивает числу @a value число @a src
	 * @inline
	 */

	export var isEqual = (value:  number , src:  number ) => value == src;
/**
	 * Если число @a value равно числу @a src возвращается true
	 * @inline
	 */

	export var isNotEqaul = (value:  number , src:  number ) => value != src;
/**
	 * Прирасваивает числу @a value число @a src
	 * @inline
	 */

	export var set = (value:  number , src:  number ) => { value = src; };
/**
	 * Обнуляет число @a value
	 * @inline
	 */

	export var clear = (value:  number ) => { value = 0; };
/**
	 * Выставляет все биты у числа @a value равными единице,
 	 * которые равны единице у числа @a src
	 * @inline
	 */

	export var setFlags = (value:  number , src:  number ) => (value |= src);
/**
	 * Выставляет все биты у числа @a value равными нулю,
 	 * которые равны единице у числа @a src
	 * @inline
	 */

	export var clearFlags = (value:  number , src:  number ) => value &= ~src;
/**
	 * Проверяет равно ли число @a value нулю. Если равно возвращает true.
 	 * Если не равно возвращает false.
	 * @inline
	 */

	export var isEmpty = (value:  number ) => (value == 0);
/**
	 * Возвращает общее количество бит числа @a value.
 	 * На самом деле возвращает всегда 32.
	 * @inline
	 */

	export var totalBits = (value:  number ) => 32;
/**
	 * Возвращает общее количество ненулевых бит числа @a value.
	 * @inline
	 */

	export var totalSet = (value:  number ):  number  => {
		var count:  number  = 0;
        var total:  number  = totalBits(value);

        for (var i:  number  = total; i; --i) {
            count += (value & 1);
            value >>= 1;
        }

        return(count);
	}

/**
     * Convert N bit colour channel value to P bits. It fills P bits with the
     * bit pattern repeated. (this is /((1<<n)-1) in fixed point)
     */

    export  /**@inline*/  function fixedToFixed(value:  number , n:  number , p:  number ):  number  {
        if(n > p) {
// Less bits required than available; this is easy
            value >>= n-p;
        }
        else if(n < p) {
// More bits required than are there, do the fill
// Use old fashioned division, probably better than a loop
            if(value == 0)
                    value = 0;
            else if(value == (< number >(1)<<n)-1)
                    value = (1<<p)-1;
            else    value = value*(1<<p)/((1<<n)-1);
        }
        return value;
    }

/**
     * Convert floating point colour channel value between 0.0 and 1.0 (otherwise clamped) 
     * to integer of a certain number of bits. Works for any value of bits between 0 and 31.
     */

    export  /**@inline*/  function floatToFixed(value:  number , bits:  number ):  number  {
        if(value <= 0.0) return 0;
        else if (value >= 1.0) return (1<<bits)-1;
        else return < number >(value * (1<<bits));
    }

/**
     * Fixed point to float
     */

    export  /**@inline*/  function fixedToFloat(value:  number , bits:  number ):  number  {
        return < number >(value&((1<<bits)-1))/< number >((1<<bits)-1);
    }

/**
     * Write a n*8 bits integer value to memory in native endian.
     */

    export  /**@inline*/  function intWrite(pDest: Uint8Array, n:  number , value:  number ): void {
        switch(n) {
            case 1:
                pDest[0] = value;
                break;
            case 2:
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
            case 3:
                pDest[2] = ((value >> 16) & 0xFF);
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
            case 4:
                pDest[3] = ((value >> 24) & 0xFF);
                pDest[2] = ((value >> 16) & 0xFF);
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
        }
    }

/**
     * Read a n*8 bits integer value to memory in native endian.
     */

    export  /**@inline*/  function intRead(pSrc: Uint8Array, n:  number ):  number  {
        switch(n) {
            case 1:
                return pSrc[0];
            case 2:
                return pSrc[0] | pSrc[1]<<8;
            case 3:
                return pSrc[0] | pSrc[1]<<8 | pSrc[2]<<16;
            case 4:
                return (pSrc[0]) | (pSrc[1]<<8) | (pSrc[2]<<16) | (pSrc[3]<<24);
        }
        return 0;
    }

    export function floatToHalfI(i:  number ):  number ;

//float32/uint32 union
    var _u32 = new Uint32Array(1);
    var _f32 = new Float32Array(_u32.buffer);

    export  /**@inline*/  function floatToHalf(f:  number ) {
    	_f32[0] = f;
    	return floatToHalfI(_u32[0]);
    }
    export  /**@inline*/  function floatToHalfI(i:  number ):  number  {

        var s:  number  =  (i >> 16) & 0x00008000;
        var e:  number  = ((i >> 23) & 0x000000ff) - (127 - 15);
        var m:  number  =   i        & 0x007fffff;

        if (e <= 0) {
            if (e < -10)
            {
                return 0;
            }
            m = (m | 0x00800000) >> (1 - e);

            return < number >(s | (m >> 13));
        }
        else if (e == 0xff - (127 - 15)) {
// Inf
            if (m == 0)
            {
                return < number >(s | 0x7c00);
            }
// NAN
            else
            {
                m >>= 13;
                return < number >(s | 0x7c00 | m | < number ><any>(m == 0));
            }
        }
        else {
// Overflow
            if (e > 30)
            {
                return < number >(s | 0x7c00);
            }

            return < number >(s | (e << 10) | (m >> 13));
        }
    }

/**
     * Convert a float16 (NV_half_float) to a float32
     * Courtesy of OpenEXR
     */

    export  /**@inline*/  function halfToFloat(y:  number ):  number  {
        _u32[0] = halfToFloatI(y);
        return _f32[0];
    }

/** Converts a half in uint16 format to a float
	 	in uint32 format
	 */

    export  /**@inline*/  function halfToFloatI(y:  number ):  number  {
        var s:  number  = (y >> 15) & 0x00000001;
        var e:  number  = (y >> 10) & 0x0000001f;
        var m:  number  =  y        & 0x000003ff;

        if (e == 0) {
// Plus or minus zero
            if (m == 0)  {
                return s << 31;
            }
// Denormalized number -- renormalize it
            else {
                while (!(m & 0x00000400)) {
                    m <<= 1;
                    e -=  1;
                }

                e += 1;
                m &= ~0x00000400;
            }
        }
        else if (e == 31) {
//Inf
            if (m == 0) {
                return (s << 31) | 0x7f800000;
            }
//NaN
            else {
                return (s << 31) | 0x7f800000 | (m << 13);
            }
        }

        e = e + (127 - 15);
        m = m << 13;

        return (s << 31) | (e << 23) | m;
    }

}


// #include "Singleton.ts"

module akra.util {

    export interface ILogRoutineMap {
        [eLogLevel:  number ]: ILogRoutineFunc;
    }

    export  interface ICodeFamily {
        familyName: string;
        codeMin:  number ;
        codeMax:  number ;
    }

    export  interface ICodeFamilyMap{
        [familyName: string]: ICodeFamily;
    }

    export interface ICodeInfo{
        code:  number ;
        message: string;
        familyName: string;
    }

    export interface ICodeInfoMap{
        [code:  number ] : ICodeInfo;
    }

    export interface ICodeFamilyRoutineDMap{
        [familyName: string]: ILogRoutineMap;
    }

/* extends Singleton*/
    export class Logger                       implements ILogger {
        private _eLogLevel: ELogLevel;
        private _pGeneralRoutineMap: ILogRoutineMap;

        private _pCurrentSourceLocation: ISourceLocation;
        private _pLastLogEntity: ILoggerEntity;

        private _pCodeFamilyList: ICodeFamily[];
        private _pCodeFamilyMap: ICodeFamilyMap;
        private _pCodeInfoMap: ICodeInfoMap;

        private _pCodeFamilyRoutineDMap: ICodeFamilyRoutineDMap;

        private _nFamilyGenerator:  number ;
        static private _sDefaultFamilyName: string = "CodeFamily";

        private _eUnknownCode:  number ;
        private _sUnknownMessage: string;

        constructor () {
//super();

            this._eUnknownCode = 0;
            this._sUnknownMessage = "Unknown code";

            this._eLogLevel = ELogLevel.ALL;
            this._pGeneralRoutineMap = <ILogRoutineMap>{};

            this._pCurrentSourceLocation = <ISourceLocation>{
                                            file: "",
                                            line: 0
                                        };

            this._pLastLogEntity = <ILoggerEntity>{
                                    code: this._eUnknownCode,
                                    location: this._pCurrentSourceLocation,
                                    message: this._sUnknownMessage,
                                    info: null,
                                   };

            this._pCodeFamilyMap = <ICodeFamilyMap>{};
            this._pCodeFamilyList = <ICodeFamily[]>[];
            this._pCodeInfoMap = <ICodeInfoMap>{};

            this._pCodeFamilyRoutineDMap = <ICodeFamilyRoutineDMap>{};

            this._nFamilyGenerator = 0;


        }

        init(): bool {
//TODO: Load file
            return true;
        }

        setLogLevel(eLevel: ELogLevel): void {
            this._eLogLevel = eLevel;
        }

        getLogLevel(): ELogLevel {
            return this._eLogLevel;
        }

        registerCode(eCode:  number , sMessage?: string = this._sUnknownMessage): bool{
            if(this.isUsedCode(eCode)){
                return false;
            }

            var sFamilyName: string = this.getFamilyName(eCode);
            if(isNull(sFamilyName)){
                return false;
            }

            var pCodeInfo: ICodeInfo = <ICodeInfo>{
                                            code: eCode,
                                            message: sMessage,
                                            familyName: sFamilyName
                                            };

            this._pCodeInfoMap[eCode] = pCodeInfo;

            return true;
        }

        setUnknownCode(eCode:  number , sMessage: string):void{
            this._eUnknownCode = eCode;
            this._sUnknownMessage = sMessage;
        }

        registerCodeFamily(eCodeMin:  number , eCodeMax:  number , sFamilyName?: string): bool{
            if(!isDef(sFamilyName)){
                sFamilyName = this.generateFamilyName();
            }

            if(this.isUsedFamilyName(sFamilyName)){
                return false;
            }

            if(!this.isValidCodeInterval(eCodeMin, eCodeMax)){
                return false;
            }

            var pCodeFamily: ICodeFamily = <ICodeFamily>{
                                                    familyName: sFamilyName,
                                                    codeMin: eCodeMin,
                                                    codeMax: eCodeMax
                                                    };

            this._pCodeFamilyMap[sFamilyName] = pCodeFamily;
            this._pCodeFamilyList.push(pCodeFamily);

            return true;
        }

        getFamilyName(eCode): string{
            var i:  number  = 0;
            var pCodeFamilyList: ICodeFamily[] = this._pCodeFamilyList;
            var pCodeFamily: ICodeFamily;

            for(i = 0; i < pCodeFamilyList.length; i++){
                pCodeFamily = pCodeFamilyList[i];

                if(pCodeFamily.codeMin <= eCode && pCodeFamily.codeMax >= eCode){
                    return pCodeFamily.familyName;
                }
            }

            return null;
        }

        setCodeFamilyRoutine(eCodeFromFamily:  number , fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine(sFamilyName: string, fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine():bool {
            var sFamilyName: string = null;
            var fnLogRoutine: ILogRoutineFunc = null;
            var eLevel: ELogLevel = ELogLevel.LOG;

            if(isInt(arguments[0])){
                sFamilyName = this.getFamilyName(arguments[0]);
                fnLogRoutine = arguments[1];
                eLevel = arguments[2];

                if(isNull(sFamilyName)){
                    return false;
                }
            }
            else if(isString(arguments[0])){
                sFamilyName = arguments[0];
                fnLogRoutine = arguments[1];
                eLevel = arguments[2];
            }

            if(!this.isUsedFamilyName(sFamilyName)){
                return false;
            }

            var pCodeFamilyRoutineMap: ILogRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName];

            if(!isDef(pCodeFamilyRoutineMap)){
                pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName] = <ILogRoutineMap>{};
            }

            if (bf.testAll(eLevel, ELogLevel.LOG)) {
               pCodeFamilyRoutineMap[ELogLevel.LOG] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.INFORMATION)) {
               pCodeFamilyRoutineMap[ELogLevel.INFORMATION] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.WARNING)) {
               pCodeFamilyRoutineMap[ELogLevel.WARNING] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.ERROR)) {
               pCodeFamilyRoutineMap[ELogLevel.ERROR] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.CRITICAL)) {
               pCodeFamilyRoutineMap[ELogLevel.CRITICAL] = fnLogRoutine;
            }

            return true;
        }

        setLogRoutine(fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): void {

            if (bf.testAll(eLevel, ELogLevel.LOG)) {
               this._pGeneralRoutineMap[ELogLevel.LOG] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.INFORMATION)) {
               this._pGeneralRoutineMap[ELogLevel.INFORMATION] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.WARNING)) {
               this._pGeneralRoutineMap[ELogLevel.WARNING] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.ERROR)) {
               this._pGeneralRoutineMap[ELogLevel.ERROR] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.CRITICAL)) {
               this._pGeneralRoutineMap[ELogLevel.CRITICAL] = fnLogRoutine;
            }
        }

        setSourceLocation(sFile: string, iLine:  number ): void;
        setSourceLocation(pLocation: ISourceLocation): void;
        setSourceLocation(): void {
            var sFile: string;
            var iLine:  number ;

            if(arguments.length === 2){
                sFile = arguments[0];
                iLine = arguments[1];
            }
            else {
                if(isDef(arguments[0]) && !(isNull(arguments[0]))){
                    sFile = arguments[0].file;
                    iLine = arguments[0].line;
                }
                else{
                    sFile = "";
                    iLine = 0;
                }
            }

            this._pCurrentSourceLocation.file = sFile;
            this._pCurrentSourceLocation.line = iLine;
        }


        log(...pArgs: any[]): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.LOG)){
                return;
            }

            var fnLogRoutine:ILogRoutineFunc = this._pGeneralRoutineMap[ELogLevel.LOG];
            if(!isDef(fnLogRoutine)){
                return;
            }

            var pLogEntity: ILoggerEntity = this._pLastLogEntity;

            pLogEntity.code = this._eUnknownCode;
            pLogEntity.location = this._pCurrentSourceLocation;
            pLogEntity.info = pArgs;
            pLogEntity.message = this._sUnknownMessage;

            fnLogRoutine.call(null, pLogEntity);
        }

        info(pEntity: ILoggerEntity): void;
        info(eCode:  number , ...pArgs: any[]): void;
        info(...pArgs: any[]): void;
        info(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.INFORMATION)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.INFORMATION);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        warning(pEntity: ILoggerEntity): void;
        warning(eCode:  number , ...pArgs: any[]): void;
        warning(...pArgs: any[]): void;
        warning(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.WARNING)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.WARNING);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        error(pEntity: ILoggerEntity): void;
        error(eCode:  number , ...pArgs: any[]): void;
        error(...pArgs: any[]): void;
        error(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.ERROR)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.ERROR);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        criticalError(pEntity: ILoggerEntity): void;
        criticalError(eCode:  number , ...pArgs: any[]): void;
        criticalError(...pArgs: any[]):void;
        criticalError():void {

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.CRITICAL);

            var sSystemMessage: string = "A Critical error has occured! Code: " + pLogEntity.code.toString();

            if(bf.testAll(this._eLogLevel, ELogLevel.CRITICAL) && !isNull(fnLogRoutine)){
                fnLogRoutine.call(null, pLogEntity);
            }

            alert(sSystemMessage);
            throw new Error(sSystemMessage);
        }

        assert(bCondition: bool, pEntity: ILoggerEntity): void;
        assert(bCondition: bool, eCode:  number , ...pArgs: any[]): void;
        assert(bCondition: bool, ...pArgs: any[]):void;
        assert():void{
            var bCondition: bool = <bool> arguments[0];

            if(!bCondition){
                var pLogEntity: ILoggerEntity;
                var fnLogRoutine: ILogRoutineFunc;

                var pArgs: any[] = [];

                for(var i = 1; i < arguments.length; i++){
                    pArgs[i - 1] = arguments[i];
                }

                pLogEntity = this.prepareLogEntity.apply(this, pArgs);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.CRITICAL);

                var sSystemMessage: string = "A error has occured! Code: " + pLogEntity.code.toString() +
                                             "\n Accept to exit, refuse to continue.";

                if(bf.testAll(this._eLogLevel, ELogLevel.CRITICAL) && !isNull(fnLogRoutine)){
                    fnLogRoutine.call(null, pLogEntity);
                }

                if(confirm(sSystemMessage)){
                    throw new Error(sSystemMessage);
                }
            }
        }


        private generateFamilyName(): string {
            var sSuffix: string = <string><any>(this._nFamilyGenerator++);
            var sName: string = Logger._sDefaultFamilyName + sSuffix;

            if(this.isUsedFamilyName(sName)){
                return this.generateFamilyName();
            }
            else {
                return sName;
            }
        }

        private isValidCodeInterval(eCodeMin:  number , eCodeMax:  number ): bool{
            if(eCodeMin > eCodeMax){
                return false;
            }

            var i:  number  = 0;
            var pCodeFamilyList: ICodeFamily[] = this._pCodeFamilyList;
            var pCodeFamily: ICodeFamily;

            for(i = 0; i < pCodeFamilyList.length; i++){
                pCodeFamily = pCodeFamilyList[i];

                if((pCodeFamily.codeMin <= eCodeMin && pCodeFamily.codeMax >= eCodeMin) ||
                   (pCodeFamily.codeMin <= eCodeMax && pCodeFamily.codeMax >= eCodeMax)){

                    return false;
                }
            }

            return true;
        }

        private  /**@inline*/  isUsedFamilyName(sFamilyName: string): bool{
            return isDef(this._pCodeFamilyMap[sFamilyName]);
        }

        private  /**@inline*/  isUsedCode(eCode:  number ): bool{
            return isDef(this._pCodeInfoMap[eCode]);
        }

        private isLogEntity(pObj:any):bool {
            if(isObject(pObj) && isDef(pObj.code) && isDef(pObj.location)){
                return true;
            }

            return false;
        }

        private  /**@inline*/  isLogCode(eCode:any):bool {
            return isInt(eCode);
        }

        private prepareLogEntity(pEntity: ILoggerEntity): ILoggerEntity;
        private prepareLogEntity(eCode:  number , ...pArgs: any[]): ILoggerEntity;
        private prepareLogEntity(...pArgs:any[]): ILoggerEntity;
        private prepareLogEntity(): ILoggerEntity{
            var eCode:  number  = this._eUnknownCode;
            var sMessage:string = this._sUnknownMessage;
            var pInfo: any = null;

            if(arguments.length === 1 && this.isLogEntity(arguments[0])){
                var pEntity: ILoggerEntity = arguments[0];

                eCode = pEntity.code;
                pInfo = pEntity.info;
                this.setSourceLocation(pEntity.location);

                if(!isDef(pEntity.message)){
                    var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
                    if(isDef(pCodeInfo)){
                        sMessage = pCodeInfo.message;
                    }
                }

            }
            else {
                if(this.isLogCode(arguments[0])){
                    eCode = < number >arguments[0];
                    if(arguments.length > 1){
                        pInfo = new Array(arguments.length - 1);
                        var i:  number  = 0;

                        for(i = 0; i < pInfo.length; i++){
                            pInfo[i] = arguments[i+1];
                        }
                    }
                }
                else {
                    eCode = this._eUnknownCode;
// if(arguments.length > 0){
                        pInfo = new Array(arguments.length);
                        var i:  number  = 0;

                        for(i = 0; i < pInfo.length; i++){
                            pInfo[i] = arguments[i];
                        }
// }
// else {
//     pInfo = null;    
// }
                }

                var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
                if(isDef(pCodeInfo)){
                    sMessage = pCodeInfo.message;
                }
            }

            var pLogEntity: ILoggerEntity = this._pLastLogEntity;

            pLogEntity.code = eCode;
            pLogEntity.location = this._pCurrentSourceLocation;
            pLogEntity.message = sMessage;
            pLogEntity.info = pInfo;

            return pLogEntity;
        }

        private getCodeRoutineFunc(eCode:  number , eLevel: ELogLevel): ILogRoutineFunc{
            var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
            var fnLogRoutine: ILogRoutineFunc;

            if(!isDef(pCodeInfo)){
                fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                return isDef(fnLogRoutine) ? fnLogRoutine : null;
            }

            var pCodeFamilyRoutineMap: ILogRoutineMap = this._pCodeFamilyRoutineDMap[pCodeInfo.familyName];

            if(!isDef(pCodeFamilyRoutineMap) || !isDef(pCodeFamilyRoutineMap[eLevel])) {
                fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                return isDef(fnLogRoutine) ? fnLogRoutine : null;
            }

            fnLogRoutine = pCodeFamilyRoutineMap[eLevel];

            return fnLogRoutine;
        }

    }
}

module akra.util {
    export var logger: ILogger = new Logger();

    logger.init();
    logger.setUnknownCode( 0 ,  "Unknown code." );
    logger.setLogLevel(ELogLevel.ALL);

//Default code families

    logger.registerCodeFamily(0, 100, "SystemCodes");
    logger.registerCodeFamily(2000, 2199, "ParserSyntaxErrors");
    logger.registerCodeFamily(2200, 2500, "EffectSyntaxErrors");

//Default log routines

    function sourceLocationToString(pLocation: ISourceLocation): string {
        var pDate: Date = new Date;
        var sTime: string = pDate.getHours() + ":" + pDate.getMinutes() + "." + pDate.getSeconds();
        var sLocation:string = "[" + pLocation.file + ":" + pLocation.line.toString() + " " + sTime + "]: ";
        return sLocation;
    }

    function logRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        var sLocation: string = sourceLocationToString(pLogEntity.location);

        if(isString(pArgs[0])){
           pArgs[0] = sLocation + " " + pArgs[0];
        }
        else {
            pArgs.unshift(sLocation);
        }

        console["log"].apply(console, pArgs);
    }

    function warningRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        var sCodeInfo: string = "Code: " + pLogEntity.code.toString() + ".";
        var sLocation: string = sourceLocationToString(pLogEntity.location);

        if(isString(pArgs[0])){
            pArgs[0] = sLocation + " " + sCodeInfo + " " + pArgs[0];
        }
        else {
            pArgs.unshift(sLocation + " " + sCodeInfo);
        }

        console["warn"].apply(console, pArgs);
    }

    function errorRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        var sMessage: string = pLogEntity.message;
        var sCodeInfo: string = "Error code: " + pLogEntity.code.toString() + ".";
        var sLocation: string = sourceLocationToString(pLogEntity.location);

        if(isString(pArgs[0])){
            pArgs[0] = sLocation + " " + sCodeInfo + " " + sMessage + " " + pArgs[0];
        }
        else {
            pArgs.unshift(sLocation + " " + sCodeInfo + " " + sMessage);
        }

        console["error"].apply(console, pArgs);
    }


    logger.setLogRoutine(logRoutine, ELogLevel.LOG | ELogLevel.INFORMATION);
    logger.setLogRoutine(warningRoutine, ELogLevel.WARNING);
    logger.setLogRoutine(errorRoutine, ELogLevel.ERROR | ELogLevel.CRITICAL);
}

module akra {
    logger = util.logger;
}













///@CORE_ARA: core.map










module akra {

	;
	;
	;
    ;
    ;
	;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;

    export interface IEngineOptions {
        depsRoot?: string;
        deps?: IDependens;
        gamepads?: bool;
        renderer?: IRendererOptions;
        loader?: {
            loaded?: (manager: IDepsManager, pDeps: IDependens) => void;
            changed?: (manager: IDepsManager, pFile: IDep, pInfo: any) => void;
        };
    }

    export interface IEngine extends IEventProvider {
        time:  number ;
        elapsedTime:  number ;

        getScene(): IScene3d;

        getSceneManager(): ISceneManager;
        getParticleManager(): IParticleManager;
        getResourceManager(): IResourcePoolManager;
        getSpriteManager(): ISpriteManager;

        getRenderer(): IRenderer;

        getComposer(): IAFXComposer;
        getDepsManager(): IDepsManager;

        pause(): bool;
        play(): bool;

/** Render one frame. */

        renderFrame(): bool;

/** Start exucution(rendering loop). */

        exec(): void;
/** Определяет, находитсяли Engine в цикле рендеринга */

        isActive(): bool;
        isDepsLoaded(): bool;


        getTimer(): IUtilTimer;

        enableGamepads(): bool;
        getGamepads(): IGamepadMap;

        createMesh(sName?: string, eOptions?:  number , pDataBuffer?: IRenderDataCollection): IMesh;
        createRenderDataCollection(iOptions?:  number ): IRenderDataCollection;
        createBufferMap(): IBufferMap;
        createAnimationController(sName?: string, iOptions?:  number ): IAnimationController;
    };

    export var createEngine: (options?: IEngineOptions) => IEngine;
}











module akra {
    export interface IManager {
        initialize(): bool;
        destroy(): void;
    }
}



















module akra {
	export interface IUnique {
		getGuid():  number ;
	}
}



module akra {
	;

	export enum EEventTypes {
		BROADCAST,
		UNICAST
	};

	export interface IEventProvider extends IUnique {
		getEventTable(): IEventTable;

		connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool;
		disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool;

		bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool;
		unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool;

		_syncTable(pFrom: IEventProvider): void;
	}
}





module akra {
	export enum ESceneTypes {
		TYPE_3D,
		TYPE_2D
	}

	export interface IScene extends IEventProvider {
		type: ESceneTypes;
		name: string;

		getManager(): ISceneManager;
	}
}





module akra {

    ;
    ;
    ;
    ;

    export interface ISceneManager extends IManager {
        createScene3D(sName?: string): IScene3d;
// createScene2D(): IScene2d;

        createUI(): IUI;

        getEngine(): IEngine;

        getScene3D(): IScene3d;
        getScene3D(sName: string): IScene3d;
        getScene3D(iScene:  number ): IScene3d;

        getScene2D(): IScene2d;
        getScene2D(sName: string): IScene2d;
        getScene2D(iScene:  number ): IScene2d;

        getScene(iScene?:  number , eType?: ESceneTypes): IScene;

        update(): void;
// preUpdate(): void;
        notifyUpdateScene(): void;
        notifyPreUpdateScene(): void;
    }
}









module akra {
    export interface IParticleManager extends IManager {

    }
}










module akra {

    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;




/** Семейства ресурсов */

	export enum EResourceFamilies {
		VIDEO_RESOURCE = 0,
		AUDIO_RESOURCE,
		GAME_RESOURCE,
		TOTAL_RESOURCE_FAMILIES
	};

/** Члены семейства видео ресурсов */

	export enum EVideoResources {
		TEXTURE_RESOURCE,
		VIDEOBUFFER_RESOURCE,
		VERTEXBUFFER_RESOURCE,
		INDEXBUFFER_RESOURCE,
		EFFECT_RESOURCE,
		RENDERMETHOD_RESOURCE,
		MODEL_RESOURCE,
		EFFECTFILEDATA_RESOURCE,
		IMAGE_RESOURCE,
		SURFACEMATERIAL_RESOURCE,
		SHADERPROGRAM_RESOURCE,
		COMPONENT_RESOURCE,
        EFFECTDATA_RESOURCE,
		TOTAL_VIDEO_RESOURCES
	};

	export enum EAudioResources {
		TOTAL_AUDIO_RESOURCES
	};

	export enum EGameResources {
		TOTAL_GAME_RESOURCES
	};

/** Конструктор класса, занимается очисткой списков пулов по семействам ресурсвов и краты пулов по коду ресурсов */

    export interface IResourcePoolManager extends IManager {
    	texturePool: IResourcePool;
    	surfaceMaterialPool: IResourcePool;
    	vertexBufferPool: IResourcePool;
    	videoBufferPool: IResourcePool;
    	indexBufferPool: IResourcePool;
        textureBufferPool: IResourcePool;
    	renderMethodPool: IResourcePool;
        colladaPool: IResourcePool;
    	objPool: IResourcePool;
    	imagePool: IResourcePool;
//ex: private
    	shaderProgramPool: IResourcePool;
//ex: private
    	effectPool: IResourcePool;
//ex: private
    	componentPool: IResourcePool;
        effectDataPool: IResourcePool;

        renderBufferPool: IResourcePool;

/** Регистрируется пул ресурсов опредленного типа в менеджере русурсов */

    	registerResourcePool(pCode: IResourceCode, pPool: IResourcePool): void;
/** Удаляет пул ресурсов опредленного типа в менеджере русурсов */

    	unregisterResourcePool(pCode: IResourceCode): IResourcePool;

/** Удаление ресурсов определенного семества */

    	destroyResourceFamily(eFamily: EResourceFamilies): void;
    	restoreResourceFamily(eFamily: EResourceFamilies): void;
    	disableResourceFamily(eFamily: EResourceFamilies): void;
    	cleanResourceFamily(eFamily: EResourceFamilies): void;

    	destroyResourceType(pCode: IResourceCode): void;
    	restoreResourceType(pCode: IResourceCode): void;
    	disableResourceType(pCode: IResourceCode): void;
    	cleanResourceType(pCode: IResourceCode): void;
/** Возвращает пул ресурса опредленного типа по его коду */

    	findResourcePool(pCode: IResourceCode): IResourcePool;
/**
		 * Возвращает хендл конкретного ресурса по его имени из конкретного пула опредленного типа
		 **/

    	findResourceHandle(pCode: IResourceCode, sName: string):  number ;
/** Возвращает конкретный ресурс по его имени из конкретного пула опредленного типа */

    	findResource(pCode: IResourceCode, sName: string): IResourcePoolItem;
        findResource(pCode: IResourceCode, iHandle:  number ): IResourcePoolItem;

        getModelPoolByFormat(eFormat: EModelFormats): IResourcePool;

/**
         * @deprecated
         */

    	monitorInitResources(fnMonitor: IResourceWatcherFunc): void;
/**
         * @deprecated
         */

    	setLoadedAllRoutine(fnCallback: Function): void;

/** Удаление всех ресурсов */

    	destroyAll(): void;
    	restoreAll(): void;
    	disableAll(): void;

    	clean(): void;

    	createDeviceResources(): bool;
    	destroyDeviceResources(): bool;
    	restoreDeviceResources(): bool;
    	disableDeviceResources(): bool;

        getEngine(): IEngine;

        createRenderMethod(sResourceName: string): IRenderMethod;
        createTexture(sResourceName: string): ITexture;
        createSurfaceMaterial(sResourceName: string): ISurfaceMaterial;
        createEffect(sResourceName: string): IEffect;
        createVertexBuffer(sResourceName: string): IVertexBuffer;
        createVideoBuffer(sResourceName: string): IVertexBuffer;
        createIndexBuffer(sResourceName: string): IIndexBuffer;
        createShaderProgram(sResourceName: string): IShaderProgram;
        createModel(sResourceName: string, eFormat?: EModelFormats): IModel;

        createImg(sResourceName: string): IImg;
        loadModel(sFilename: string, pOptions?: IModelLoadOptions): IModel;
        loadImage(sFilename: string): IImg;

    }
}












module akra {
	;

	export interface IRenderQueue {
		execute(bSort?: bool): void;
		push(pEntry: IRenderEntry): void;
		createEntry(): IRenderEntry;
		releaseEntry(pEntry: IRenderEntry): void;
	}
}






module akra {
	export enum ECompareFunction {
		ALWAYS_FAIL,
		ALWAYS_PASS,
		LESS,
		LESS_EQUAL,
		EQUAL,
		NOT_EQUAL,
		GREATER_EQUAL,
		GREATER
	}

	export enum ECullingMode {
		NONE = 1,
		CLOCKWISE = 2,
		ANTICLOCKWISE = 3
	}

	export enum EFrameBufferTypes {
		COLOR  = 0x1,
        DEPTH   = 0x2,
        STENCIL = 0x4
	}

	export interface IViewportState {
		cullingMode: ECullingMode;

		depthTest: bool;
		depthWrite: bool;
		depthFunction: ECompareFunction;

		clearColor: IColor;
		clearDepth:  number ;
		clearBuffers:  number ;
	}
}



module akra {

    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;



    export interface IRendererOptions extends WebGLContextAttributes {
        canvas?: HTMLCanvasElement;
    }

//API SPECIFIFC CONSTANTS

    export enum EPrimitiveTypes {
        POINTLIST = 0,
        LINELIST,
        LINELOOP,
        LINESTRIP,
        TRIANGLELIST,
        TRIANGLESTRIP,
        TRIANGLEFAN
    };

    export enum ERenderCapabilitiesCategory {
        C_COMMON = 0,
        C_COMMON_2 = 1,
        C_WEBGL = 2,

        COUNT = 3
    }

    export enum ERenderCapabilities{
        AUTOMIPMAP              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 0)) ,
        BLENDING                =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 1)) ,
/// Supports anisotropic texture filtering
        ANISOTROPY              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 2)) ,
/// Supports fixed-function DOT3 texture blend
        DOT3                    =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 3)) ,
/// Supports cube mapping
        CUBEMAPPING             =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 4)) ,
/// Supports hardware stencil buffer
        HWSTENCIL               =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 5)) ,
/// Supports hardware vertex and index buffers
        VBO                     =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 7)) ,
/// Supports vertex programs (vertex shaders)
        VERTEX_PROGRAM          =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 9)) ,
/// Supports fragment programs (pixel shaders)
        FRAGMENT_PROGRAM        =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 10)) ,
/// Supports performing a scissor test to exclude areas of the screen
        SCISSOR_TEST            =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 11)) ,
/// Supports separate stencil updates for both front and back faces
        TWO_SIDED_STENCIL       =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 12)) ,
/// Supports wrapping the stencil value at the range extremeties
        STENCIL_WRAP            =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 13)) ,
/// Supports hardware occlusion queries
        HWOCCLUSION             =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 14)) ,
/// Supports user clipping planes
        USER_CLIP_PLANES        =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 15)) ,
/// Supports the VET_UBYTE4 vertex element type
        VERTEX_FORMAT_UBYTE4    =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 16)) ,
/// Supports infinite far plane projection
        INFINITE_FAR_PLANE      =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 17)) ,
/// Supports hardware render-to-texture (bigger than framebuffer)
        HWRENDER_TO_TEXTURE     =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 18)) ,
/// Supports float textures and render targets
        TEXTURE_FLOAT           =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 19)) ,
/// Supports non-power of two textures
        NON_POWER_OF_2_TEXTURES =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 20)) ,
/// Supports 3d (volume) textures
        TEXTURE_3D              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 21)) ,
/// Supports basic point sprite rendering
        POINT_SPRITES           =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 22)) ,
/// Supports extra point parameters (minsize, maxsize, attenuation)
        POINT_EXTENDED_PARAMETERS =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 23)) ,
/// Supports vertex texture fetch
        VERTEX_TEXTURE_FETCH =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 24)) ,
/// Supports mipmap LOD biasing
        MIPMAP_LOD_BIAS =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 25)) ,
/// Supports hardware geometry programs
        GEOMETRY_PROGRAM =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 26)) ,
/// Supports rendering to vertex buffers
        HWRENDER_TO_VERTEX_BUFFER =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 27)) ,

/// Supports compressed textures
        TEXTURE_COMPRESSION =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 0)) ,
/// Supports compressed textures in the DXT/ST3C formats
        TEXTURE_COMPRESSION_DXT =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 1)) ,
/// Supports compressed textures in the VTC format
        TEXTURE_COMPRESSION_VTC =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 2)) ,
/// Supports compressed textures in the PVRTC format
        TEXTURE_COMPRESSION_PVRTC =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 3)) ,
/// Supports fixed-function pipeline
        FIXED_FUNCTION =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 4)) ,
/// Supports MRTs with different bit depths
        MRT_DIFFERENT_BIT_DEPTHS =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 5)) ,
/// Supports Alpha to Coverage (A2C)
        ALPHA_TO_COVERAGE =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 6)) ,
/// Supports Blending operations other than +
        ADVANCED_BLEND_OPERATIONS =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 7)) ,
/// Supports a separate depth buffer for RTTs. D3D 9 & 10, OGL w/FBO (FBO implies this flag)
        RTT_SEPARATE_DEPTHBUFFER =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 8)) ,
/// Supports using the MAIN depth buffer for RTTs. D3D 9&10, OGL w/FBO support unknown
/// (undefined behavior?), OGL w/ copy supports it
        RTT_MAIN_DEPTHBUFFER_ATTACHABLE =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 9)) ,
/// Supports attaching a depth buffer to an RTT that has width & height less or equal than RTT's.
/// Otherwise must be of _exact_ same resolution. D3D 9, OGL 3.0 (not 2.0, not D3D10)
        RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 10)) ,
/// Supports using vertex buffers for instance data
        VERTEX_BUFFER_INSTANCE_DATA =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 11)) ,
/// Supports using vertex buffers for instance data
        CAN_GET_COMPILED_SHADER_BUFFER =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 12)) ,


// ***** GL Specific Caps *****
/// Supports openGL GLEW version 1.5
        GL1_5_NOVBO    =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 1)) ,
/// Support for Frame Buffer Objects (FBOs)
        FBO              =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 2)) ,
/// Support for Frame Buffer Objects ARB implementation (regular FBO is higher precedence)
        FBO_ARB          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 3)) ,
/// Support for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence)
        FBO_ATI          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 4)) ,
/// Support for PBuffer
        PBUFFER          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 5)) ,
/// Support for GL 1.5 but without HW occlusion workaround
        GL1_5_NOHWOCCLUSION =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 6)) ,
/// Support for point parameters ARB implementation
        POINT_EXTENDED_PARAMETERS_ARB =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 7)) ,
/// Support for point parameters EXT implementation
        POINT_EXTENDED_PARAMETERS_EXT =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 8)) ,
/// Support for Separate Shader Objects
        SEPARATE_SHADER_OBJECTS =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 9))
    }

// export enum EGLSpecifics {
//     UNPACK_ALIGNMENT = 0x0CF5,
//     PACK_ALIGNMENT = 0x0D05,
//     UNPACK_FLIP_Y_WEBGL = 0x9240,
//     UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241,
//     CONTEXT_LOST_WEBGL = 0x9242,
//     UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243,
//     BROWSER_DEFAULT_WEBGL = 0x9244
// };

// export enum EBufferMasks {
//     DEPTH_BUFFER_BIT               = 0x00000100,
//     STENCIL_BUFFER_BIT             = 0x00000400,
//     COLOR_BUFFER_BIT               = 0x00004000
// };

// export enum EBufferUsages {
//     STREAM_DRAW = 0x88E0,
//     STATIC_DRAW = 0x88E4,
//     DYNAMIC_DRAW = 0x88E8
// };

// export enum EBufferTypes {
//     ARRAY_BUFFER = 0x8892,
//     ELEMENT_ARRAY_BUFFER = 0x8893,
//     FRAME_BUFFER = 0x8D40,
//     RENDER_BUFFER = 0x8D41
// };

    export enum EAttachmentTypes {
         COLOR_ATTACHMENT0 = 0x8CE0,
         DEPTH_ATTACHMENT = 0x8D00,
         STENCIL_ATTACHMENT = 0x8D20,
         DEPTH_STENCIL_ATTACHMENT = 0x821A
    };

    export enum ERenderStates {
        BLENDENABLE,
        CULLFACEENABLE,
        ZENABLE,
        ZWRITEENABLE,
        DITHERENABLE,
        SCISSORTESTENABLE,
        STENCILTESTENABLE,
        POLYGONOFFSETFILLENABLE,

        CULLFACE,
        FRONTFACE,

        SRCBLEND,
        DESTBLEND,

        ZFUNC,

        ALPHABLENDENABLE,
        ALPHATESTENABLE,

//CULLMODE = FRONTFACE,
    };

    export enum ERenderStateValues {
        UNDEF = 0,

        TRUE,
        FALSE,
        ZERO,
        ONE,
        SRCCOLOR,
        INVSRCCOLOR,
        SRCALPHA,
        INVSRCALPHA,
        DESTALPHA,
        INVDESTALPHA,
        DESTCOLOR,
        INVDESTCOLOR,
        SRCALPHASAT,
        NONE,
        CW,
        CCW,
        FRONT,
        BACK,
        FRONT_AND_BACK,
        NEVER,
        LESS,
        EQUAL,
        LESSEQUAL,
        GREATER,
        NOTEQUAL,
        GREATEREQUAL,
        ALWAYS
    };

    export interface IRenderStateMap {
        [index:  number ]: ERenderStateValues;
    }

// export enum ERenderStates {
//     ZENABLE = 7,
//     ZWRITEENABLE = 14,
//     SRCBLEND = 19,
//     DESTBLEND = 20,
//     CULLMODE = 22,
//     ZFUNC = 23,
//     DITHERENABLE = 26,
//     ALPHABLENDENABLE = 27,
//     ALPHATESTENABLE
// };

// export enum EBlendModes {
//     ZERO = 0,
//     ONE = 1,
//     SRCCOLOR = 0x0300,
//     INVSRCCOLOR = 0x301,
//     SRCALPHA = 0x0302,
//     INVSRCALPHA = 0x0303,
//     DESTALPHA = 0x0304,
//     INVDESTALPHA = 0x0305,
//     DESTCOLOR = 0x0306,
//     INVDESTCOLOR = 0x0307,
//     SRCALPHASAT = 0x0308
// };

// export enum ECmpFuncs {
//     NEVER = 1,
//     LESS = 2,
//     EQUAL = 3,
//     LESSEQUAL = 4,
//     GREATER = 5,
//     NOTEQUAL = 6,
//     GREATEREQUAL = 7,
//     ALWAYS = 8
// };

// export enum ECullModes {
//     NONE = 0,
//     CW = 0x404, //FRONT
//     CCW = 0x0405, //BACK
//     FRONT_AND_BACK = 0x0408
// };

//END OF API SPECIFIC

// export enum ERenderStages {
//  SHADOWS = 2,
//  LIGHTING,
//  GLOBALPOSTEFFECTS,
//  DEFAULT
// }

    export interface IRenderer extends IEventProvider {
        getEngine(): IEngine;

        debug(bValue?: bool, useApiTrace?: bool): bool;

        isDebug(): bool;
        isValid(): bool;

        getError();

        clearFrameBuffer(iBuffer:  number , cColor: IColor, fDepth:  number , iStencil:  number ): void;

        _beginRender(): void;
        _renderEntry(pEntry: IRenderEntry): void;
        _endRender(): void;

        _disableAllTextureUnits(): void;
        _disableTextureUnitsFrom(iUnit:  number ): void;

        _initRenderTargets(): void;
        _updateAllRenderTargets(): void;

        _setViewport(pViewport: IViewport): void;
        _setViewportForRender(pViewport: IViewport): void;
        _getViewport(): IViewport;

        _setRenderTarget(pTarget: IRenderTarget): void;

        _setCullingMode(eMode: ECullingMode): void;
        _setDepthBufferParams(bDepthTest: bool, bDepthWrite: bool,
                              eDepthFunction: ECompareFunction, fClearDepth?:  number ): void;

        hasCapability(eCapability: ERenderCapabilities): bool;

        attachRenderTarget(pTarget: IRenderTarget): bool;
        detachRenderTarget(pTarget: IRenderTarget): bool;
        destroyRenderTarget(pTarget: IRenderTarget): void;

        getActiveProgram(): IShaderProgram;

        getDefaultCanvas(): ICanvas3d;

        createEntry(): IRenderEntry;
        releaseEntry(pEntry: IRenderEntry): void;
        pushEntry(pEntry: IRenderEntry): void;
        executeQueue(bSort?: bool): void;

        _lockRenderTarget(): void;
        _unlockRenderTarget(): void;
        _isLockRenderTarget(): bool;

    }



}






module akra {
	export enum EUtilTimerCommands {
//! <to reset the timer
		TIMER_RESET,
//! <to start the timer
		TIMER_START,
//! <to stop (or pause) the timer
		TIMER_STOP,
//! <to advance the timer by 0.1 seconds
		TIMER_ADVANCE,
//! <to get the absolute system time
		TIMER_GET_ABSOLUTE_TIME,
//! <to get the current time
		TIMER_GET_APP_TIME,
		TIMER_GET_ELAPSED_TIME
//! to get the time that elapsed between TIMER_GETELAPSEDTIME calls
	}

    export interface IUtilTimer {
        absoluteTime:  number ;
        appTime:  number ;
        elapsedTime:  number ;

        start(): bool;
        stop(): bool;
        reset(): bool;
        execCommand(e: EUtilTimerCommands):  number ;

//static start(): IUtilTimer;
    }
}












module akra {

	;
	;
	;

	export interface ILightParameters {
//default parameters
// ambient: IColor;
// diffuse: IColor;
// specular: IColor;
// attenuation: IVec3;
	}

	export enum ELightTypes {
		UNKNOWN,
		PROJECT,
		OMNI,
		SUN
	}

	export interface ILightPoint extends ISceneNode {
		params: ILightParameters;
		enabled: bool;
		lightType: ELightTypes;

		isShadowCaster: bool;
		lightingDistance:  number ;

//optimized camera frustum for better shadow casting
		 optimizedCameraFrustum: IFrustum;

		create(isShadowCaster?: bool, iMaxShadowResolution?:  number ): bool;

//false if lighting not active 
//or it's effect don't seen
		_prepareForLighting(pCamera: ICamera): bool;

		_calculateShadows(): void;
	}
}







module akra {
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;

	export interface IScene3d extends IScene {
		totalDL:  number ;

		getRootNode(): ISceneNode;

		recursivePreUpdate(): void;
		updateCamera(): bool;
		updateScene(): bool;
		recursiveUpdate(): void;

		isUpdated(): bool;


		createObject(sName?: string): ISceneObject;


		createNode(sName?: string): ISceneNode;
		createModel(sName?: string): ISceneModel;
		createCamera(sName?: string): ICamera;
		createLightPoint(eType?: ELightTypes, isShadowCaster?: bool,
						 iMaxShadowResolution?:  number , sName?: string): ILightPoint;
		createSprite(sName?: string): ISprite;
		createJoint(sName?: string): IJoint;
		createText3d(sName?: string): IText3d;

		createTerrain(sName?: string): ITerrain;
		createTerrainROAM(sName?: string): ITerrainROAM;
		createTerrainSection(sName?: string): ITerrainSection;
		createTerrainSectionROAM(sName?: string): ITerrainSectionROAM;

		_createModelEntry(pModel: IModel): IModelEntry;

		_createShadowCaster(pLightPoint: ILightPoint, iFace?:  number , sName?: string): IShadowCaster;

		getDisplayList(index:  number ): IDisplayList;
		getDisplayListByName(csName: string):  number ;
		addDisplayList(pList: IDisplayList):  number ;
		delDisplayList(index:  number ): bool;

		 nodeAttachment(pNode: ISceneNode): void;
		 nodeDetachment(pNode: ISceneNode): void;

		 displayListAdded(pList: IDisplayList, index:  number ): void;
		 displayListRemoved(pList: IDisplayList, index:  number ): void;

		 beforeUpdate(): void;
		 postUpdate(): void;
		 preUpdate(): void;

		_render(pCamera: ICamera, pViewport: IViewport): void;
	}
}














module akra {

















    export enum ENodeCreateMode {
        k_Default,
        k_Necessary,
        k_Not
    }

    export enum EParserCode {
        k_Pause,
        k_Ok,
        k_Error
    }

    export enum EParserType {
        k_LR0,
        k_LR1,
        k_LALR
    }

    export enum EParseMode {
        k_AllNode = 0x0001,
        k_Negate = 0x0002,
        k_Add = 0x0004,
        k_Optimize = 0x0008,
        k_DebugMode = 0x0010
    }

    export enum ETokenType {
        k_NumericLiteral = 1,
        k_CommentLiteral,
        k_StringLiteral,
        k_PunctuatorLiteral,
        k_WhitespaceLiteral,
        k_IdentifierLiteral,
        k_KeywordLiteral,
        k_Unknown,
        k_End
    }

    export interface IToken {
        value: string;
        start:  number ;
        end:  number ;
        line:  number ;

        name?: string;
        type?: ETokenType;
    }


    export interface IRule {
        left: string;
        right: string[];
        index:  number ;
    }

    export interface IFinishFunc {
        (eCode: EParserCode, sFileName: string): void;
    }

    export enum EOperationType {
        k_Error = 100,
        k_Shift,
        k_Reduce,
        k_Success,
        k_Pause,
        k_Ok
    }

    export interface IRuleFunction {
        (): EOperationType;
    }

    export interface IParseNode {
        children: IParseNode[];
        parent: IParseNode;
        name: string;
        value: string;

//Data for next-step analyze
        isAnalyzed: bool;
        position:  number ;

        start?:  number ;
        end?:  number ;
        line?:  number ;
    }

    export interface IParseTree {
        setRoot(): void;

        setOptimizeMode(isOptimize: bool): void;

        addNode(pNode: IParseNode): void;
        reduceByRule(pRule: IRule, eCreate: ENodeCreateMode);

        toString(): string;

        clone(): IParseTree;

        getNodes(): IParseNode[];
        getLastNode(): IParseNode;

        root: IParseNode;
    }

    export interface ILexer {
        addPunctuator(sValue: string, sName?: string): string;
        addKeyword(sValue: string, sName: string): string;

        getTerminalValueByName(sName: string): string;

        init(sSource: string): void;

        getNextToken(): IToken;
        _getIndex():  number ;
        _setSource(sSource: string): void;
        _setIndex(iIndex:  number ): void;
    }

    export interface IParserState {
        source: string;
        index:  number ;
        fileName: string;
        tree: IParseTree;
        types: BoolMap;
        stack:  number [];
        token: IToken;
        fnCallback: IFinishFunc;
        caller: any;
    }

    export interface IParser {

        isTypeId(sValue: string): bool;

        returnCode(pNode: IParseNode): string;

        init(sGrammar: string, eMode?: EParseMode, eType?: EParserType): bool;

        parse(sSource: string, fnFinishCallback?: IFinishFunc, pCaller?: any): EParserCode;

        setParseFileName(sFileName: string): void;
        getParseFileName(): string;

        pause(): EParserCode;
        resume(): EParserCode;

        getSyntaxTree(): IParseTree;

        printStates(isPrintOnlyBase?: bool): void;
        printState(iStateIndex:  number , isPrintOnlyBase?: bool): void;

        getGrammarSymbols(): StringMap;

        _saveState(): IParserState;
        _loadState(pState: IParserState): void;

// _getLexer(): ILexer;
// _getSource(): string;
// _getIndex(): uint;
// _getTypeMap(): BoolMap;
// _getStack(): uint[];
// _getToken(): IToken;
// _getCallback(): IFinishFunc;
// _getCaller(): any;

// _setParserState(sSource: string,
//                 iIndex: uint,
//                 sFileName: string,
//                 pTree: IParseTree,
//                 pTypes: BoolMap,
//                 pStack: uint[],
//                 pToken: IToken,
//                 fnCallback: IFinishFunc,
//                 pCaller: any): void;
    }
}

























module akra {
	export interface IReferenceCounter {
/**
		 * Текущее количесвто ссылок  на объект
		 **/

		referenceCount():  number ;

/** Предупреждает если объект еще используется */

		destructor(): void;


/**
		 * Добаволение ссылки  на объект, увеличивает внутренний счетчки на 1,
		 * проверяет не достигнуто ли максимальное количесвто
		 **/

		addRef():  number ;

/**
		 * Уведомление об удалении ссылки  на объект, уменьшает внутренний счетчки на 1,
		 * проверяет есть ли ее объекты
		 **/

		release():  number ;


/** 
		 * Данная функция нужна чтобы обеспечить наследникам ее возможность,
		 * само количестdо ссылок не копируется
		 */

		eq(pSrc: IReferenceCounter): IReferenceCounter;
	}
}





module akra {

	;
	;
	;
	;
	;
	;

/**
     * Отражает состояние ресурса
     **/

    export enum EResourceItemEvents{
//ресур создан
		CREATED,
//ресур заполнен данным и готов к использованию
		LOADED,
//ресур в данный момент отключен для использования
		DISABLED,
//ресур был изменен после загрузки		
		ALTERED,
		TOTALRESOURCEFLAGS
	};

	export interface IResourcePoolItem extends IReferenceCounter, IEventProvider {
/** resource code */

		 resourceCode: IResourceCode;
/** resource pool */

		 resourcePool: IResourcePool;
/** resource handle */

		 resourceHandle:  number ;
/** resource flags */

		 resourceFlags:  number ;
/** Проверка был ли изменен ресур после загрузки */

		 alteredFlag: bool;

		 manager: IResourcePoolManager;



/** Get current Engine. */

		getEngine(): IEngine;
		getManager(): IResourcePoolManager;

/** Инициализация ресурса, вызывается один раз. Виртуальная. */

		createResource(): bool;
/** Уничтожение ресурса. Виртуальная. */

		destroyResource(): bool;
/**  Удаление ресурса из энергозависимой памяти. Виртуальная. */

		disableResource(): bool;
/** Возвращение ресурса в энегрозависимю память. Виртуальная. */

		restoreResource(): bool;

/** Загрузка ресурса из файла, или null при использовании имени ресурса. Виртуальная. */

		loadResource(sFilename?: string): bool;
/** Сохранение ресурса в файл, или null при использовании имени ресурса. */

		saveResource(sFilename?: string): bool;

/** Добавление и удаление функции, которая будет вызываться при изменении состояния ресурса( fnFunc(iNewSost,iOldSost) ) */

		setChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void;
		delChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void;

		setStateWatcher(eEvent: EResourceItemEvents, fnWatcher: IResourceWatcherFunc): void;

/** sinchronize events with other resourse */

		isSyncedTo(eSlot: EResourceItemEvents): bool;
//sync(pResourceItem: IResourcePoolItem, sSignal: string, sSlot?: string): bool;
		sync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool;

//unsync(pResourceItem: IResourcePoolItem, sSignal: string, sSlot?: string): bool;
		unsync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool;

/** Установка состояния в созданный */

		notifyCreated(): void;
/** Установка в состояние не созданный */

		notifyDestroyed(): void;
/** Уставнока в состояние загруженный */

		notifyLoaded(): void;
/** Уставнока в состояние незагруженный */

		notifyUnloaded(): void;
/** Установка в состояние используемый */

		notifyRestored(): void;
/** Установка в состояние не используемый */

		notifyDisabled(): void;
/** Установка в состояние не используемый */

		notifyAltered(): void;
/** Установка в состояние сохраненый */

		notifySaved(): void;

		notifyStateChange(eEvent: EResourceItemEvents, pTarget?: IResourcePoolItem);

/** Проверка создан ли ресурс */

		isResourceCreated(): bool;
/** Проверка загружен ли ресурс */

		isResourceLoaded(): bool;
/** Проверка активен ли ресурс */

		isResourceDisabled(): bool;
/** Проверка обновлен ли ресурс */

		isResourceAltered(): bool;

/** Установка состояния в изменен после загружки */

		setAlteredFlag(isOn?: bool): bool;

/** Пиписывание ресурсу имени */

		setResourceName(sName: string);

/** Поиск имени ресурса */

		findResourceName(): string;

/** оповещение о уменьшении количесва ссылок на ресурс */

		release():  number ;

		setResourceCode(pCode: IResourceCode): void;
		setResourcePool(pPool: IResourcePool): void;
		setResourceHandle(iHandle:  number ): void;

		setResourceFlag(eFlagBit: EResourceItemEvents, isSetting: bool): bool;
		setResourceFlag(iFlagBit:  number , isSetting: bool): bool;

		 created(): void;
		 destroyed(): void;
		 loaded(): void;
		 unloaded(): void;
		 restored(): void;
		 disabled(): void;
		 altered(): void;
		 saved(): void;

	}

	export interface IResourcePoolItemType {
		new (pManager: IResourcePoolManager): IResourcePoolItem;
	}
}





















module akra {


    export enum EAFXInstructionTypes {
        k_Instruction = 0,
        k_InstructionCollector,
        k_SimpleInstruction,
        k_VariableTypeInstruction,
        k_SystemTypeInstruction,
        k_ComplexTypeInstruction,
        k_TypedInstruction,
        k_DeclInstruction,
        k_IntInstruction,
        k_FloatInstruction,
        k_BoolInstruction,
        k_StringInstruction,
        k_IdInstruction,
        k_KeywordInstruction,
        k_TypeDeclInstruction,
        k_VariableDeclInstruction,
        k_AnnotationInstruction,
        k_UsageTypeInstruction,
        k_BaseTypeInstruction,
        k_StructDeclInstruction,
        k_StructFieldsInstruction,
        k_ExprInstruction,
        k_IdExprInstruction,
        k_ArithmeticExprInstruction,
        k_AssignmentExprInstruction,
        k_RelationalExprInstruction,
        k_LogicalExprInstruction,
        k_ConditionalExprInstruction,
        k_CastExprInstruction,
        k_UnaryExprInstruction,
        k_PostfixIndexInstruction,
        k_PostfixPointInstruction,
        k_PostfixArithmeticInstruction,
        k_PrimaryExprInstruction,
        k_ComplexExprInstruction,
        k_FunctionCallInstruction,
        k_SystemCallInstruction,
        k_ConstructorCallInstruction,
        k_CompileExprInstruction,
        k_InitExprInstruction,
        k_SamplerStateBlockInstruction,
        k_SamplerStateInstruction,
        k_ExtractExprInstruction,
        k_MemExprInstruction,
        k_FunctionDeclInstruction,
        k_ShaderFunctionInstruction,
        k_SystemFunctionInstruction,
        k_FunctionDefInstruction,
        k_StmtInstruction,
        k_StmtBlockInstruction,
        k_ExprStmtInstruction,
        k_BreakStmtInstruction,
        k_WhileStmtInstruction,
        k_ForStmtInstruction,
        k_IfStmtInstruction,
        k_DeclStmtInstruction,
        k_ReturnStmtInstruction,
        k_ExtractStmtInstruction,
        k_SemicolonStmtInstruction,
        k_PassInstruction,
        k_TechniqueInstruction
    }


    export enum EFunctionType{
        k_Vertex = 0,
        k_Pixel = 1,
        k_Fragment = 1,
        k_Function = 2,
        k_PassFunction = 3
    }

    export enum ECheckStage {
/* Отсутсвуют конструкции не поддерживаемые языком назначения (GLSL) */
        CODE_TARGET_SUPPORT,
/* Код замкнут, нет не определенных функций, пассов, техник. Нет мертвых функций. */
        SELF_CONTAINED
// VALIDATION  /* Код не содерит синтаксиески неправильных выражений, то что не исчерпывается */ 
    }

    export enum EVarUsedMode {
        k_Read,
        k_Write,
        k_ReadWrite,
        k_Undefined,
        k_Default = k_ReadWrite
    }

    export interface IAFXInstructionStateMap extends StringMap{
	}

	export interface IAFXInstructionRoutine {
		(): void;
	}

    export interface IAFXInstructionError {
        code:  number ;
        info: any;
    }

    export interface IAFXInstructionMap {
        [index:  number ]: IAFXInstruction;
    }

    export interface IAFXSimpleInstructionMap {
        [index: string]: IAFXSimpleInstruction;
        [index:  number ]: IAFXSimpleInstruction;
    }

    export interface IAFXIdExprMap {
        [index: string]: IAFXIdExprInstruction;
    }

    export interface IAFXVariableTypeMap {
        [index: string]: IAFXVariableTypeInstruction;
        [index:  number ]: IAFXVariableTypeInstruction;
    }

    export interface IAFXTypeMap {
        [index: string]: IAFXTypeInstruction;
        [index:  number ]: IAFXTypeInstruction;
    }

    export interface IAFXTypeListMap {
        [index: string] : IAFXTypeInstruction[];
        [index:  number ] : IAFXTypeInstruction[];
    }

    export interface IAFXTypeDeclMap {
        [index: string] : IAFXTypeDeclInstruction;
        [index:  number ] : IAFXTypeDeclInstruction;
    }

    export interface IAFXVariableDeclMap {
        [index:  number ]: IAFXVariableDeclInstruction;
        [index: string]: IAFXVariableDeclInstruction;
    }

    export interface IAFXVariableDeclListMap {
        [index:  number ]: IAFXVariableDeclInstruction[];
        [index: string]: IAFXVariableDeclInstruction[];
    }

    export interface IAFXVarUsedModeMap {
        [index: string]: EVarUsedMode;
    }

    export interface IAFXFunctionDeclMap {
        [index: string]: IAFXFunctionDeclInstruction;
        [index:  number ]: IAFXFunctionDeclInstruction;
    }

    export interface IAFXTypeUseInfoContainer {
        type: IAFXVariableTypeInstruction;
        isRead: bool;
        isWrite: bool;
        numRead:  number ;
        numWrite:  number ;
        numUsed:  number ;
    }

    export interface IAFXTypeUseInfoMap {
        [index:  number ]: IAFXTypeUseInfoContainer;
    }

    export enum EExtractExprType {
        k_Header,

        k_Float,
        k_Int,
        k_Bool,

        k_Float2,
        k_Int2,
        k_Bool2,

        k_Float3,
        k_Int3,
        k_Bool3,

        k_Float4,
        k_Int4,
        k_Bool4,

        k_Float4x4
    }

    export enum EAFXBlendMode {
        k_Shared,
        k_Uniform,
        k_Attribute,
        k_Foreign,
        k_Global,
        k_Varying,
        k_TypeDecl,
        k_VertexOut
    }

    export interface IAFXImportedTechniqueInfo {
        technique: IAFXTechniqueInstruction;
        component: IAFXComponent;
        shift:  number ;
    }

/**
	 * All opertion are represented by: 
	 * operator : arg1 ... argn
	 * Operator and instructions may be empty.
	 */

	export interface IAFXInstruction extends IUnique {
        setParent(pParent: IAFXInstruction): void;
        getParent(): IAFXInstruction;

        setOperator(sOperator: string): void;
        getOperator(): string;

        setInstructions(pInstructionList: IAFXInstruction[]): void;
        getInstructions(): IAFXInstruction[];

        _getInstructionType(): EAFXInstructionTypes;
        _getInstructionID():  number ;
        _getScope():  number ;
        _setScope(iScope:  number ): void;
        _isInGlobalScope(): bool;

        check(eStage: ECheckStage): bool;
        getLastError(): IAFXInstructionError;
        setError(eCode:  number , pInfo?: any): void;
        clearError(): void;
        isErrorOccured(): bool;

        setVisible(isVisible: bool): void;
        isVisible(): bool;

        initEmptyInstructions(): void;

// /**
//  * Contain states of instruction
//  */
// stateMap: IAFXInstructionStateMap;

    	push(pInstruction: IAFXInstruction, isSetParent?: bool): void;

// changeState(sStateName: string, sValue: string): void;
// changeState(iStateIndex: int, sValue: string): void;

// stateChange(): void;
// isStateChange(): bool;

    	addRoutine(fnRoutine: IAFXInstructionRoutine, iPriority?:  number );
        prepareFor(eUsedType: EFunctionType): void;

    	toString(): string;
        toFinalCode(): string;

        clone(pRelationMap?: IAFXInstructionMap): IAFXInstruction;
    }

    export interface IAFXSimpleInstruction extends IAFXInstruction {
        setValue(sValue: string): void;
        isValue(sValue: string): bool;
    }

    export interface IAFXTypeInstruction extends IAFXInstruction {
        _toDeclString(): string;

        isBuiltIn(): bool;
        setBuiltIn(isBuiltIn: bool): void;

/**
         * Simple tests
         */

        isBase(): bool;
        isArray(): bool;
        isNotBaseArray(): bool;
        isComplex(): bool;
        isEqual(pType: IAFXTypeInstruction): bool;
        isStrongEqual(pType: IAFXTypeInstruction): bool;
        isConst(): bool;

        isSampler(): bool;
        isSamplerCube(): bool;
        isSampler2D(): bool;

        isWritable(): bool;
        isReadable(): bool;

        _containArray(): bool;
        _containSampler(): bool;
        _containPointer(): bool;
        _containComplexType(): bool;
/**
         * Set private params
         */

        setName(sName: string): void;
        _canWrite(isWritable: bool): void;
        _canRead(isReadable: bool): void;

// markAsUsed(): void;

/**
         * get type info
         */

        getName(): string;
        getRealName(): string;
        getHash(): string;
        getStrongHash(): string;
        getSize():  number ;
        getBaseType(): IAFXTypeInstruction;
        getLength():  number ;
        getArrayElementType(): IAFXTypeInstruction;
        getTypeDecl(): IAFXTypeDeclInstruction;

// Fields

        hasField(sFieldName: string): bool;
        hasFieldWithSematic(sSemantic: string);
        hasAllUniqueSemantics(): bool;
        hasFieldWithoutSemantic(): bool;

        getField(sFieldName: string): IAFXVariableDeclInstruction;
        getFieldBySemantic(sSemantic: string): IAFXVariableDeclInstruction;
        getFieldType(sFieldName: string): IAFXVariableTypeInstruction;
        getFieldNameList(): string[];

/**
         * System
         */

        clone(pRelationMap?: IAFXInstructionMap): IAFXTypeInstruction;
        blend(pType: IAFXTypeInstruction, eMode: EAFXBlendMode): IAFXTypeInstruction;
    }

    export interface IAFXVariableTypeInstruction extends IAFXTypeInstruction {
        _setCollapsed(bValue: bool): void;
        _isCollapsed(): bool;

/**
         * Simple tests
         */

        isPointer(): bool;
        isStrictPointer(): bool;
        isPointIndex(): bool;

        isFromVariableDecl(): bool;
        isFromTypeDecl(): bool;

        isUniform(): bool;
        isGlobal(): bool;
        isConst(): bool;
        isShared(): bool;
        isForeign(): bool;

        _isTypeOfField(): bool;
        _isUnverifiable(): bool;

// /**
//  * set type info
//  */
// _markUsedForWrite(): bool;
// _markUsedForRead(): bool;
// _goodForRead(): bool;

// _markAsField(): void;

/**
         * init api
         */

        setPadding(iPadding:  number ): void;
        pushType(pType: IAFXTypeInstruction): void;
        addUsage(sUsage: string): void;
        addArrayIndex(pExpr: IAFXExprInstruction): void;
        addPointIndex(isStrict?:bool): void;
        setVideoBuffer(pBuffer: IAFXVariableDeclInstruction): void;
        initializePointers(): void;

        _setPointerToStrict(): void;
        _addPointIndexInDepth(): void;
        _setVideoBufferInDepth(): void;
        _markAsUnverifiable(isUnverifiable: bool): void;
        _addAttrOffset(pOffset: IAFXVariableDeclInstruction): void;

/**
         * Type info
         */

        getPadding():  number ;
        getArrayElementType(): IAFXVariableTypeInstruction;

        getUsageList(): string[];
        getSubType(): IAFXTypeInstruction;

        hasUsage(sUsageName: string): bool;
        hasVideoBuffer(): bool;

        getPointDim():  number ;
        getPointer(): IAFXVariableDeclInstruction;
        getVideoBuffer():IAFXVariableDeclInstruction;
        getFieldExpr(sFieldName: string): IAFXIdExprInstruction;
        getFieldIfExist(sFieldName: string): IAFXVariableDeclInstruction;

        getSubVarDecls(): IAFXVariableDeclInstruction[];

        _getFullName(): string;
        _getVarDeclName(): string;
        _getTypeDeclName(): string;

        _getParentVarDecl(): IAFXVariableDeclInstruction;
        _getParentContainer(): IAFXVariableDeclInstruction;
        _getMainVariable(): IAFXVariableDeclInstruction;

        _getMainPointer(): IAFXVariableDeclInstruction;
        _getUpPointer(): IAFXVariableDeclInstruction;
        _getDownPointer(): IAFXVariableDeclInstruction;
        _getAttrOffset(): IAFXVariableDeclInstruction;

/**
         * System
         */

        wrap(): IAFXVariableTypeInstruction;
        clone(pRelationMap?: IAFXInstructionMap): IAFXVariableTypeInstruction;
        blend(pVariableType: IAFXVariableTypeInstruction, eMode: EAFXBlendMode): IAFXVariableTypeInstruction;

        _setCloneHash(sHash: string, sStrongHash: string): void;
        _setCloneArrayIndex(pElementType: IAFXVariableTypeInstruction,
                            pIndexExpr: IAFXExprInstruction, iLength:  number ): void;
        _setClonePointeIndexes(nDim:  number , pPointerList: IAFXVariableDeclInstruction[]): void;
        _setCloneFields(pFieldMap: IAFXVariableDeclMap): void;

        _setUpDownPointers(pUpPointer: IAFXVariableDeclInstruction,
                           pDownPointer: IAFXVariableDeclInstruction): void;
    }

    export interface IAFXTypedInstruction extends IAFXInstruction{
        getType(): IAFXTypeInstruction;
        setType(pType: IAFXTypeInstruction): void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXTypedInstruction;
    }

    export interface IAFXDeclInstruction extends IAFXTypedInstruction {
        setSemantic(sSemantic: string);
        setAnnotation(pAnnotation: IAFXAnnotationInstruction): void;
        getName(): string;
        getRealName(): string;
        getNameId(): IAFXIdInstruction;
        getSemantic(): string;

        isBuiltIn(): bool;
        setBuiltIn(isBuiltIn: bool): void;

        _isForAll(): bool;
        _isForPixel(): bool;
        _isForVertex(): bool;

        _setForAll(canUse: bool): void;
        _setForPixel(canUse: bool): void;
        _setForVertex(canUse: bool): void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXDeclInstruction;
    }

    export interface IAFXTypeDeclInstruction extends IAFXDeclInstruction {
        clone(pRelationMap?: IAFXInstructionMap): IAFXTypeDeclInstruction;
        blend(pDecl: IAFXTypeDeclInstruction, eBlendMode: EAFXBlendMode): IAFXTypeDeclInstruction;
    }

    export interface IAFXVariableDeclInstruction extends IAFXDeclInstruction {
        hasInitializer(): bool;
        getInitializeExpr(): IAFXInitExprInstruction;
        hasConstantInitializer(): bool;

        lockInitializer(): void;
        unlockInitializer(): void;

        getDefaultValue(): any;
        prepareDefaultValue(): void;

        getValue(): any;
        setValue(pValue: any): any;

        getType(): IAFXVariableTypeInstruction;
        setType(pType: IAFXVariableTypeInstruction): void;

        isUniform(): bool;
        isField(): bool;
        isPointer(): bool;
        isVideoBuffer(): bool;
        isSampler(): bool;

        getSubVarDecls(): IAFXVariableDeclInstruction[];

        isDefinedByZero(): bool;
        defineByZero(isDefine: bool): void;

        _setAttrExtractionBlock(pCodeBlock: IAFXInstruction): void;
        _getAttrExtractionBlock(): IAFXInstruction;

        _markAsVarying(bValue: bool): void;
        _markAsShaderOutput(isShaderOutput: bool): void;
        _isShaderOutput(): bool;

        _getNameIndex():  number ;
        _getFullNameExpr(): IAFXExprInstruction;
        _getFullName(): string;
        _getVideoBufferSampler(): IAFXVariableDeclInstruction;
        _getVideoBufferHeader(): IAFXVariableDeclInstruction;
        _getVideoBufferInitExpr(): IAFXInitExprInstruction;

        setName(sName: string): void;
        setRealName(sName: string): void;
        setVideoBufferRealName(sSampler: string, sHeader: string): void;

        _setCollapsed(bValue: bool): void;
        _isCollapsed(): bool;

        clone(pRelationMap?: IAFXInstructionMap): IAFXVariableDeclInstruction;
        blend(pVariableDecl: IAFXVariableDeclInstruction, eMode: EAFXBlendMode): IAFXVariableDeclInstruction;
    }

    export interface IAFXFunctionDeclInstruction extends IAFXDeclInstruction {
        toFinalDefCode(): string;

//getNameId(): IAFXIdInstruction;
        hasImplementation(): bool;
        getArguments(): IAFXTypedInstruction[];
        getNumNeededArguments():  number ;
        getReturnType(): IAFXVariableTypeInstruction;
        getFunctionType(): EFunctionType;
        setFunctionType(eType: EFunctionType): void;

        _getVertexShader(): IAFXFunctionDeclInstruction;
        _getPixelShader(): IAFXFunctionDeclInstruction;

// closeArguments(pArguments: IAFXInstruction[]): IAFXTypedInstruction[];
        setFunctionDef(pFunctionDef: IAFXDeclInstruction): void;
        setImplementation(pImplementation: IAFXStmtInstruction): void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXFunctionDeclInstruction;

//addUsedVariableType(pType: IAFXVariableTypeInstruction, eUsedMode: EVarUsedMode): bool;

        _addOutVariable(pVariable: IAFXVariableDeclInstruction): bool;
        _getOutVariable(): IAFXVariableDeclInstruction;

        _markUsedAs(eUsedType: EFunctionType): void;
        _isUsedAs(eUsedType: EFunctionType): bool;
        _isUsedAsFunction(): bool;
        _isUsedAsVertex(): bool;
        _isUsedAsPixel(): bool;
        _isUsed(): bool;
        _markUsedInVertex(): void;
        _markUsedInPixel(): void;
        _isUsedInVertex(): bool;
        _isUsedInPixel(): bool;
        _checkVertexUsage(): bool;
        _checkPixelUsage(): bool;

        _checkDefenitionForVertexUsage(): bool;
        _checkDefenitionForPixelUsage(): bool;

        _canUsedAsFunction(): bool;
        _notCanUsedAsFunction(): void;

        _addUsedFunction(pFunction: IAFXFunctionDeclInstruction): bool;
        _getUsedFunctionList(): IAFXFunctionDeclInstruction[];
        _addUsedVariable(pVariable: IAFXVariableDeclInstruction): void;

        _isBlackListFunction(): bool;
        _addToBlackList(): void;
        _getStringDef(): string;

        _convertToVertexShader(): IAFXFunctionDeclInstruction;
        _convertToPixelShader(): IAFXFunctionDeclInstruction;

        _prepareForVertex(): void;
        _prepareForPixel(): void;

        _generateInfoAboutUsedData(): void;

        _getAttributeVariableMap(): IAFXVariableDeclMap;
        _getVaryingVariableMap(): IAFXVariableDeclMap;

        _getSharedVariableMap(): IAFXVariableDeclMap;
        _getGlobalVariableMap(): IAFXVariableDeclMap;
        _getUniformVariableMap(): IAFXVariableDeclMap;
        _getForeignVariableMap(): IAFXVariableDeclMap;
        _getTextureVariableMap(): IAFXVariableDeclMap;
        _getUsedComplexTypeMap(): IAFXTypeMap;

        _getAttributeVariableKeys():  number [];
        _getVaryingVariableKeys():  number [];

        _getSharedVariableKeys():  number [];
        _getUniformVariableKeys():  number [];
        _getForeignVariableKeys():  number [];
        _getGlobalVariableKeys():  number [];
        _getTextureVariableKeys():  number [];
        _getUsedComplexTypeKeys():  number [];

        _getExtSystemFunctionList(): IAFXFunctionDeclInstruction[];
        _getExtSystemMacrosList(): IAFXSimpleInstruction[];
        _getExtSystemTypeList(): IAFXTypeDeclInstruction[];
    }

    export interface IAFXStructDeclInstruction extends IAFXInstruction {
//id: IAFXIdInstruction
//structFields: IAFXStructInstruction
    }

// export interface IAFXBaseTypeInstruction extends IAFXInstruction {
//     //id: IAFXIdInstruction
//     //...
// }

    export interface IAFXIdInstruction extends IAFXInstruction {
        getName(): string;
        getRealName(): string;

        setName(sName: string): void;
        setRealName(sName: string): void;

        _markAsVarying(bValue: bool): void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXIdInstruction;
    }

    export interface IAFXKeywordInstruction extends IAFXInstruction {
        setValue(sValue: string): void;
        isValue(sTestValue: string): bool;
    }

    export interface IAFXAnalyzedInstruction extends IAFXInstruction {
        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap, eUsedMode?: EVarUsedMode): void;
    }

    export interface IAFXExprInstruction extends IAFXTypedInstruction, IAFXAnalyzedInstruction {
        evaluate(): bool;
        simplify(): bool;
        getEvalValue(): any;
        isConst(): bool;
        getType(): IAFXVariableTypeInstruction;

        clone(pRelationMap?: IAFXInstructionMap): IAFXExprInstruction;
    }

    export interface IAFXInitExprInstruction extends IAFXExprInstruction {
        optimizeForVariableType(pType: IAFXVariableTypeInstruction): bool;
// getExternalValue(pType: IAFXVariableTypeInstruction): any;
    }

    export interface IAFXIdExprInstruction extends IAFXExprInstruction {
        clone(pRelationMap?: IAFXInstructionMap): IAFXIdExprInstruction;
    }

    export interface IAFXLiteralInstruction extends IAFXExprInstruction {
        setValue(pValue: any): void;
        clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction;
    }

    export interface IAFXAnnotationInstruction extends IAFXInstruction{

    }

    export interface IAFXStmtInstruction extends IAFXInstruction, IAFXAnalyzedInstruction{
    }

    export interface IAFXPassInstruction extends IAFXDeclInstruction {
        _addFoundFunction(pNode: IParseNode, pShader: IAFXFunctionDeclInstruction, eType: EFunctionType): void;
        _getFoundedFunction(pNode: IParseNode): IAFXFunctionDeclInstruction;
        _getFoundedFunctionType(pNode: IParseNode): EFunctionType;
        _setParseNode(pNode: IParseNode): void;
        _getParseNode(): IParseNode;
        _markAsComplex(isComplex: bool): void;
        _addCodeFragment(sCode: string): void;

        _getSharedVariableMapV(): IAFXVariableDeclMap;
        _getGlobalVariableMapV(): IAFXVariableDeclMap;
        _getUniformVariableMapV(): IAFXVariableDeclMap;
        _getForeignVariableMapV(): IAFXVariableDeclMap;
        _getTextureVariableMapV(): IAFXVariableDeclMap;
        _getUsedComplexTypeMapV(): IAFXTypeMap;

        _getSharedVariableMapP(): IAFXVariableDeclMap;
        _getGlobalVariableMapP(): IAFXVariableDeclMap;
        _getUniformVariableMapP(): IAFXVariableDeclMap;
        _getForeignVariableMapP(): IAFXVariableDeclMap;
        _getTextureVariableMapP(): IAFXVariableDeclMap;
        _getUsedComplexTypeMapP(): IAFXTypeMap;

        _getFullUniformMap(): IAFXVariableDeclMap;
        _getFullForeignMap(): IAFXVariableDeclMap;
        _getFullTextureMap(): IAFXVariableDeclMap;


        getVertexShader(): IAFXFunctionDeclInstruction;
        getPixelShader(): IAFXFunctionDeclInstruction;

        addShader(pShader: IAFXFunctionDeclInstruction): void;
        setState(eType:  ERenderStates , eValue:  ERenderStateValues ): void;
        finalizePass(): void;

        isComplexPass(): bool;
        evaluate(pEngineStates: any, pForeigns: any, pUniforms: any): bool;

        getState(eType:  ERenderStates ):  ERenderStateValues ;
        _getRenderStates(): IRenderStateMap;
    }

    export interface IAFXTechniqueInstruction extends IAFXDeclInstruction{
        setName(sName: string, isComplexName: bool): void;
        getName(): string;
        hasComplexName(): bool;

        isPostEffect(): bool;

        addPass(pPass: IAFXPassInstruction): void;
        getPassList(): IAFXPassInstruction[];
        getPass(iPass:  number ): IAFXPassInstruction;

        totalOwnPasses():  number ;
        totalPasses():  number ;

        getSharedVariablesForVertex(): IAFXVariableDeclInstruction[];
        getSharedVariablesForPixel(): IAFXVariableDeclInstruction[];

        addTechniqueFromSameEffect(pTechnique: IAFXTechniqueInstruction, iShift:  number ): void;
        addComponent(pComponent: IAFXComponent, iShift:  number ): void;

        getFullComponentList(): IAFXComponent[];
        getFullComponentShiftList():  number [];

        checkForCorrectImports(): bool;

        setGlobalParams(sProvideNameSpace: string,
                        pGloabalImportList: IAFXImportedTechniqueInfo[]): void;

        finalize(pComposer: IAFXComposer): void;
    }

}



module akra {
	export interface IAFXComponentMap {
		[index:  number ]: IAFXComponent;
		[index: string]: IAFXComponent;
	}

	export interface IAFXComponent extends IResourcePoolItem {
		create(): void;

		getTechnique(): IAFXTechniqueInstruction;
		setTechnique(pTechnique: IAFXTechniqueInstruction): void;

		isPostEffect(): bool;

		getName(): string;
		getTotalPasses():  number ;
		getHash(iShift:  number , iPass:  number ): string;

	}
}






module akra {

	;

	export interface IEffect extends IResourcePoolItem {
		totalComponents:  number ;
		totalPasses:  number ;

		isEqual(pEffect: IEffect): bool;
		isReplicated(): bool;
		isMixid(): bool;
		isParameterUsed(pParam: any, iPass?:  number ): bool;

		replicable(bValue: bool): void;
		miscible(bValue: bool): void;

		addComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		addComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;
		addComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;

		delComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		delComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;

		hasComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;

		activate(iShift?:  number ): bool;
		deactivate(): bool;

		findParameter(pParam: any, iPass?:  number ): any;
	}
}































module akra {
	;

    export interface IRenderResource extends IResourcePoolItem {
//getHardwareObject(): IHardwareObject;
    };
}









module akra {
	export enum EPixelFormats {
/*Unknown pixel format.*/
        UNKNOWN = 0,

/*8-bit pixel format, all bits luminance.*/
        L8 = 1,
        BYTE_L = L8,
/*16-bit pixel format, all bits luminance.*/
        L16 = 2,
        SHORT_L = L16,
/*8-bit pixel format, all bits alpha.*/
        A8 = 3,
        BYTE_A = A8,
/*8-bit pixel format, 4 bits alpha, 4 bits luminance.*/
        A4L4 = 4,
/*2 byte pixel format, 1 byte luminance, 1 byte alpha*/
        BYTE_LA = 5,

/*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        R5G6B5 = 6,
/*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        B5G6R5 = 7,
/*8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.*/
        R3G3B2 = 31,
/*16-bit pixel format, 4 bits for alpha, red, green and blue.*/
        A4R4G4B4 = 8,
/*16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.*/
        A1R5G5B5 = 9,
/*24-bit pixel format, 8 bits for red, green and blue.*/
        R8G8B8 = 10,
/*24-bit pixel format, 8 bits for blue, green and red.*/
        B8G8R8 = 11,
/*32-bit pixel format, 8 bits for alpha, red, green and blue.*/
        A8R8G8B8 = 12,
/*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        A8B8G8R8 = 13,
/*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        B8G8R8A8 = 14,
/*32-bit pixel format, 8 bits for red, green, blue and alpha.*/
        R8G8B8A8 = 28,

/*32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue like A8R8G8B8, but alpha will get discarded*/
        X8R8G8B8 = 26,
/*32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red like A8B8G8R8, but alpha will get discarded*/
        X8B8G8R8 = 27,

/*3 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue*/
        BYTE_RGB = R8G8B8,
/*3 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red*/
        BYTE_BGR = B8G8R8,
/*4 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red and one byte for alpha*/
        BYTE_BGRA = B8G8R8A8,
/*4 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue, and one byte for alpha*/
        BYTE_RGBA = R8G8B8A8,

        BYTE_ABGR = A8B8G8R8,
        BYTE_ARGB = A8R8G8B8,

/*32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.*/
        A2R10G10B10 = 15,
/*32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.*/
        A2B10G10R10 = 16,

/*DDS (DirectDraw Surface) DXT1 format.*/
        DXT1 = 17,
/*DDS (DirectDraw Surface) DXT2 format.*/
        DXT2 = 18,
/*DDS (DirectDraw Surface) DXT3 format.*/
        DXT3 = 19,
/*DDS (DirectDraw Surface) DXT4 format.*/
        DXT4 = 20,
/*DDS (DirectDraw Surface) DXT5 format.*/
        DXT5 = 21,

/*16-bit pixel format, 16 bits (float) for red*/
        FLOAT16_R = 32,
/*48-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue*/
        FLOAT16_RGB = 22,
/*64-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue, 16 bits (float) for alpha*/
        FLOAT16_RGBA = 23,
/*32-bit pixel format, 32 bits (float) for red*/
        FLOAT32_R = 33,
/*96-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue*/
        FLOAT32_RGB = 24,
/*128-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue, 32 bits (float) for alpha*/
        FLOAT32_RGBA = 25,
/*32-bit, 2-channel s10e5 floating point pixel format, 16-bit green, 16-bit red*/
        FLOAT16_GR = 35,
/*64-bit, 2-channel floating point pixel format, 32-bit green, 32-bit red*/
        FLOAT32_GR = 36,

/*Float Depth texture format*/
        FLOAT32_DEPTH = 29,
        DEPTH8 = 44,
/*Byte Depth texture format */
        BYTE_DEPTH = DEPTH8,

        DEPTH16 = 45,
        SHORT_DEPTH = DEPTH16,
        DEPTH32 = 46,
        DEPTH24STENCIL8=47,


/*64-bit pixel format, 16 bits for red, green, blue and alpha*/
        SHORT_RGBA = 30,
/*32-bit pixel format, 16-bit green, 16-bit red*/
        SHORT_GR = 34,
/*48-bit pixel format, 16 bits for red, green and blue*/
        SHORT_RGB = 37,

/*PVRTC (PowerVR) RGB 2 bpp.*/
        PVRTC_RGB2 = 38,
/*PVRTC (PowerVR) RGBA 2 bpp.*/
        PVRTC_RGBA2 = 39,
/*PVRTC (PowerVR) RGB 4 bpp.*/
        PVRTC_RGB4 = 40,
/*PVRTC (PowerVR) RGBA 4 bpp.*/
        PVRTC_RGBA4 = 41,

/*8-bit pixel format, all bits red.*/
        R8 = 42,
/*16-bit pixel format, 8 bits red, 8 bits green.*/
        RG8 = 43,
        TOTAL = 48
    };

    export interface PixelFormatList {
    	[index:  number ]: EPixelFormats;
    }


/**
     * Flags defining some on/off properties of pixel formats
     */

    export enum  EPixelFormatFlags {
// This format has an alpha channel
        HASALPHA        = 0x00000001,
// This format is compressed. This invalidates the values in elemBytes,
// elemBits and the bit counts as these might not be fixed in a compressed format.
        COMPRESSED    = 0x00000002,
// This is a floating point format
        FLOAT           = 0x00000004,
// This is a depth format (for depth textures)
        DEPTH           = 0x00000008,
// Format is in native endian. Generally true for the 16, 24 and 32 bits
// formats which can be represented as machine integers.
        NATIVEENDIAN    = 0x00000010,
// This is an intensity format instead of a RGB one. The luminance
// replaces R,G and B. (but not A)
        LUMINANCE       = 0x00000020,
        STENCIL         = 0x00000040
    }

/** Pixel component format */

    export enum EPixelComponentTypes
    {
/*Byte per component (8 bit fixed 0.0..1.0)*/
        BYTE = 0,
/*Short per component (16 bit fixed 0.0..1.0))*/
        SHORT = 1,
        INT = 2,
/*16 bit float per component*/
        FLOAT16 = 3,
/*32 bit float per component*/
        FLOAT32 = 4,
/*Number of pixel types*/
        COUNT = 5
    };

    export enum EFilters {
        NEAREST,
        LINEAR,
        BILINEAR,
        BOX,
        TRIANGLE,
        BICUBIC
    };
}










module akra {
	export interface IBuffer {
//number of elements
		 length:  number ;

//size in bytes
		 byteLength:  number ;


	}
}



module akra {

	export enum EHardwareBufferFlags {
		STATIC 		= 0x01,
		DYNAMIC 	= 0x02,
		STREAM 		= 0x80,

		READABLE	= 0x04,

		BACKUP_COPY = 0x08,
/** indicate, that buffer does not use GPU memory or other specific memory. */

		SOFTWARE 	= 0x10,
/** Indicate, tha buffer uses specific data aligment */

		ALIGNMENT	= 0x20,
/** Indicates that the application will be refilling the contents
            of the buffer regularly (not just updating, but generating the
            contents from scratch), and therefore does not mind if the contents 
            of the buffer are lost somehow and need to be recreated. This
            allows and additional level of optimisation on the buffer.
            This option only really makes sense when combined with 
            DYNAMIC and without READING.
            */

		DISCARDABLE = 0x40,

		STATIC_READABLE = STATIC | READABLE,
		DYNAMIC_DISCARDABLE = DYNAMIC | DISCARDABLE
	}

	export enum ELockFlags {
		READ 			= 0x01,
		WRITE 			= 0x02,
		DISCARD 		= 0x04,
		NO_OVERWRITE	= 0x08,

		NORMAL			= READ | WRITE
	}

	export interface IHardwareBuffer extends IBuffer {
		clone(pSrc: IHardwareBuffer): bool;

		isValid(): bool;
		isDynamic(): bool;
		isStatic(): bool;
		isStream(): bool;
		isReadable(): bool;
		isBackupPresent(): bool;
		isSoftware(): bool;
		isAligned(): bool;
		isLocked(): bool;

		getFlags():  number ;

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;

		 writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
//writeData(pData: ArrayBuffer, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer?: bool): bool;

		copyData(pSrcBuffer: IHardwareBuffer, iSrcOffset:  number ,
				 iDstOffset:  number , iSize:  number , bDiscardWholeBuffer?: bool): bool;

		create(iSize:  number , iFlags?:  number ): bool;
// create(iByteSize: uint, iFlags: int, pData: Uint8Array): bool;
// create(iByteSize: uint, iFlags: int, pData: ArrayBuffer): bool;

		destroy(): void;

		resize(iSize:  number ): bool;

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags?:  number ): any;
		unlock(): void;

		restoreFromBackup(): bool;
	}
}









module akra {
	;
	;
	;

	export interface IPixelBuffer extends IHardwareBuffer {
		 width:  number ;
		 height:  number ;
		 depth:  number ;

		 format: EPixelFormats;

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;

		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer);

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox?: IBox): bool;

		blitToMemory(pDest: IPixelBox): bool;
		blitToMemory(pSrcBox: IBox, pDest: IPixelBox): bool;

		getRenderTarget(): IRenderTarget;

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags?:  number ): any;
		lock(pLockBox: IBox, iLockFlags?:  number ): IPixelBox;

		readPixels(pDestBox: IPixelBox): bool;

		_clearRTT(iZOffset:  number ): void;

		reset(): void;
        reset(iSize:  number ): void;
        reset(iWidth:  number , iHeight:  number ): void;
	}
}







module akra {

    ;

    export enum ETextureFlags {
        STATIC = < number >EHardwareBufferFlags.STATIC,
        DYNAMIC = < number >EHardwareBufferFlags.DYNAMIC,
        READEBLE = < number >EHardwareBufferFlags.READABLE,
        DYNAMIC_DISCARDABLE = < number >EHardwareBufferFlags.DYNAMIC_DISCARDABLE,
/// mipmaps will be automatically generated for this texture
        AUTOMIPMAP = 0x100,
/// this texture will be a render target, i.e. used as a target for render to texture
/// setting this flag will ignore all other texture usages except AUTOMIPMAP
        RENDERTARGET = 0x200,
/// default to automatic mipmap generation static textures
        DEFAULT = STATIC
    }

    export enum ETextureFilters {
        UNDEF = 0x0000,
        NEAREST = 0x2600,
        LINEAR = 0x2601,
        NEAREST_MIPMAP_NEAREST = 0x2700,
        LINEAR_MIPMAP_NEAREST = 0x2701,
        NEAREST_MIPMAP_LINEAR = 0x2702,
        LINEAR_MIPMAP_LINEAR = 0x2703
    };

    export enum ETextureWrapModes {
        UNDEF = 0x0000,
        REPEAT = 0x2901,
        CLAMP_TO_EDGE = 0x812F,
        MIRRORED_REPEAT = 0x8370
    };

    export enum ETextureParameters {
        MAG_FILTER = 0x2800,
        MIN_FILTER,
        WRAP_S,
        WRAP_T
    };

    export enum ETextureTypes {
        TEXTURE_2D = 0x0DE1,
        TEXTURE_CUBE_MAP = 0x8513,
    };

    export enum ECubeFace{
        POSITIVE_X = 0,
        NEGATIVE_X = 1,
        POSITIVE_Y = 2,
        NEGATIVE_Y = 3,
        POSITIVE_Z = 4,
        NEGATIVE_Z = 5,
        };

    export enum ETextureCubeFlags{
        POSITIVE_X = 0x00000001,
        NEGATIVE_X = 0x00000002,
        POSITIVE_Y = 0x00000004,
        NEGATIVE_Y = 0x00000008,
        POSITIVE_Z = 0x0000000c,
        NEGATIVE_Z = 0x000000010,
        };

    export enum ETextureUnits {
        TEXTURE0 = 0x84C0
    };

// export interface ITextureParameters {
//     minFilter: ETextureFilters;
//     magFilter: ETextureFilters;

//     wrapS: ETextureWrapModes;
//     wrapT: ETextureWrapModes;
// }

    export interface ITexture extends IRenderResource {
    	width:  number ;
        height:  number ;
        depth:  number ;

        format: EPixelFormats;
        mipLevels:  number ;

        textureType: ETextureTypes;

         byteLength:  number ;

//desiredIntegerBitDepth: uint;
//desiredFloatBitDepth: uint;     

//readonly desiredFormat: EPixelFormats;
//readonly srcFormat: EPixelFormats;
//readonly srcWidth: uint;
//readonly srcHeight: uint;
//readonly srcDepth: uint;

        setFlags(iTextureFlag:  number ): void;
        getFlags():  number ;

// calculateSize(): uint;
        getNumFaces():  number ;
        getSize():  number ;

        isTexture2D(): bool;
        isTextureCube(): bool;
        isCompressed(): bool;
        isValid(): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , cFillColor?: IColor,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: Array,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: ArrayBufferView,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        getBuffer(iFace?:  number , iMipmap?:  number ): IPixelBuffer;

        setFilter(eParam: ETextureParameters, eValue: ETextureFilters): bool;
        setWrapMode(eParam: ETextureParameters, eValue: ETextureWrapModes): bool;
        getFilter(eParam: ETextureParameters): ETextureFilters;
        getWrapMode(eParam: ETextureParameters): ETextureWrapModes;

        loadRawData(pData: ArrayBufferView, iWidth:  number , iHeight:  number , iDepth?:  number , eFormat?: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): bool;
        loadImage(pImage: IImg): bool;
        loadImages(pImages: IImg[]): bool;

        convertToImage(pDestImage: IImg, bIncludeMipMaps: bool): void;

        copyToTexture(pTarget: ITexture): void;

        createInternalTexture(cFillColor?: IColor): bool;
        freeInternalTexture(): bool;

        reset(): void;
        reset(iSize:  number ): void;
        reset(iWidth:  number , iHeight:  number ): void;

    }
}



module akra {
	export interface IAFXSamplerStateMap {
		[index: string]: IAFXSamplerState;
		[index:  number ]: IAFXSamplerState;
	}

	export interface IAFXSamplerStateListMap {
		[index: string]: IAFXSamplerState[];
		[index:  number ]: IAFXSamplerState[];
	}

	export interface IAFXSamplerState {
		textureName: string;
		texture: ITexture;

		wrap_s: ETextureWrapModes;
		wrap_t: ETextureWrapModes;

		mag_filter: ETextureFilters;
		min_filter: ETextureFilters;
	}
}






module akra {
	;
	;

	export enum ESurfaceMaterialTextures {
		TEXTURE0 = 0,
        TEXTURE1,
        TEXTURE2,
        TEXTURE3,
        TEXTURE4,
        TEXTURE5,
        TEXTURE6,
        TEXTURE7,
        TEXTURE8,
        TEXTURE9,
        TEXTURE10,
        TEXTURE11,
        TEXTURE12,
        TEXTURE13,
        TEXTURE14,
        TEXTURE15,
        DIFFUSE = TEXTURE0,
        AMBIENT = TEXTURE1,
        SPECULAR = TEXTURE2,
        EMISSIVE = TEXTURE3,
        NORMAL = TEXTURE4,
        EMISSION = EMISSIVE,
	};



    export interface ISurfaceMaterial extends IResourcePoolItem {
         totalUpdatesOfTextures:  number ;
         totalUpdatesOfTexcoords:  number ;

    	totalTextures:  number ;
    	material: IMaterial;
    	textureFlags:  number ;
    	textureMatrixFlags:  number ;

        setTexture(iIndex:  number , sTexture: string, iTexcoord?:  number ): bool;
        setTexture(iIndex:  number , iTextureHandle:  number , iTexcoord?:  number ): bool;
    	setTexture(iIndex:  number , pTexture: ITexture, iTexcoord?:  number ): bool;
    	setTextureMatrix(iIndex:  number , m4fValue: IMat4): bool;
    	setMaterial(pMaterial: IMaterial): void;
    	isEqual(pSurface: ISurfaceMaterial): bool;

    	texture(iSlot:  number ): ITexture;
    	texcoord(iSlot:  number ):  number ;
    	textureMatrix(iSlot:  number ): IMat4;
    }

}






module akra {



	export interface IAFXPassInputStateInfo {
		uniformKey:  number ;
		foreignKey:  number ;
		samplerKey:  number ;
		renderStatesKey:  number ;
	};

	export interface IAFXPassInputBlend extends IUnique {
		samplers: IAFXSamplerStateMap;
		samplerArrays: IAFXSamplerStateListMap;
		samplerArrayLength: IntMap;

/* all uniforms without samlers */
		uniforms: any;
		foreigns: any;
		textures: any;

		samplerKeys:  number [];
		samplerArrayKeys:  number [];

		uniformKeys:  number [];
		foreignKeys:  number [];
		textureKeys:  number [];

		renderStates: IRenderStateMap;

		 statesInfo: IAFXPassInputStateInfo;

		hasUniform(sName: string): bool;
		hasTexture(sName: string): bool;
		hasForeign(sName: string): bool;

		setUniform(sName: string, pValue: any): void;
		setTexture(sName: string, pValue: any): void;
		setForeign(sName: string, pValue: any): void;

		setSampler(sName: string, pState: IAFXSamplerState): void;
		setSamplerArray(sName: string, pSamplerArray: IAFXSamplerState[]): void;

		setSamplerTexture(sName: string, sTexture: string): void;
		setSamplerTexture(sName: string, pTexture: ITexture): void;

		setStruct(sName: string, pValue: any): void;

		setSurfaceMaterial(pMaterial: ISurfaceMaterial): void;

		setRenderState(eState: ERenderStates, eValue: ERenderStateValues): void;

		_getForeignVarNameIndex(sName: string):  number ;
		_getForeignVarNameByIndex(iNameIndex:  number ): string;

		_getUniformVarNameIndex(sName: string):  number ;
		_getUniformVarNameByIndex(iNameIndex:  number ): string;

		_getUniformVar(iNameIndex:  number ): IAFXVariableDeclInstruction;
		_getUniformLength(iNameIndex:  number ):  number ;
		_getUniformType(iNameIndex:  number ): EAFXShaderVariableType;

		_getSamplerState(iNameIndex:  number ): IAFXSamplerState;
		_getSamplerTexture(iNameIndex:  number ): ITexture;

		_getTextureForSamplerState(pSamplerState: IAFXSamplerState): ITexture;


		_release(): void;

		_isFromSameBlend(pInput: IAFXPassInputBlend): bool;
		_getBlend(): IAFXComponentPassInputBlend;
		_copyFrom(pInput: IAFXPassInputBlend): void;

		_copyUniformsFromInput(pInput: IAFXPassInputBlend): void;
		_copySamplersFromInput(pInput: IAFXPassInputBlend): void;
		_copyForeignsFromInput(pInput: IAFXPassInputBlend): void;
		_copyRenderStatesFromInput(pInput: IAFXPassInputBlend): void;

		_getLastPassBlendId():  number ;
		_getLastShaderId():  number ;
		_setPassBlendId(id:  number ): void;
		_setShaderId(id:  number ): void;
	}
}






module akra {
	export enum EAFXShaderVariableType {
        k_NotVar = 0,

        k_Texture = 2,

        k_Float,
        k_Int,
        k_Bool,

        k_Float2,
        k_Int2,
        k_Bool2,

        k_Float3,
        k_Int3,
        k_Bool3,

        k_Float4,
        k_Int4,
        k_Bool4,

        k_Float2x2,
        k_Float3x3,
        k_Float4x4,

        k_Sampler2D,
        k_SamplerCUBE,
        k_SamplerVertexTexture,

        k_CustomSystem,
        k_Complex
    }

	export interface IAFXShaderVarTypeMap {
//[index: string]: EAFXShaderVariableType;
		[index:  number ]: EAFXShaderVariableType;
	}

	export interface IAFXVariableInfo {
		variable: IAFXVariableDeclInstruction;
		type: EAFXShaderVariableType;
		name: string;
		realName: string;
		isArray: bool;
	}

	export interface IAFXVariableContainer {
		indices:  number [];

		add(pVar: IAFXVariableDeclInstruction): void;
		addSystemEntry(sName: string, eType: EAFXShaderVariableType): void;

		finalize(): void;

		getVarInfoByIndex(iIndex:  number ): IAFXVariableInfo;
		getVarByIndex(iIndex:  number ): IAFXVariableDeclInstruction;
		getTypeByIndex(iIndex:  number ): EAFXShaderVariableType;
		isArrayVariable(iIndex:  number ): bool;

		getIndexByName(sName: string):  number ;
		getIndexByRealName(sName: string):  number ;

		hasVariableWithName(sName: string): bool;
		hasVariableWithRealName(sName: string): bool;

		getVarByName(sName: string): IAFXVariableDeclInstruction;
		getVarByRealName(sName: string): IAFXVariableDeclInstruction;
	}
}





module akra {


	export interface IAFXComponentBlendMap {
		[index:  number ]: IAFXComponentBlend;
		[index: string]: IAFXComponentBlend;
	}

	export interface IAFXComponentInfo {
		component: IAFXComponent;
		shift:  number ;
		pass:  number ;
		hash: string;
	}


	export interface IAFXComponentPassInputBlend {
		uniforms: IAFXVariableContainer;
		textures: IAFXVariableContainer;
		foreigns: IAFXVariableContainer;

		addDataFromPass(pPass: IAFXPassInstruction): void;
		finalizeInput(): void;

		getPassInput(): IAFXPassInputBlend;
		releasePassInput(pPassInput: IAFXPassInputBlend): void;
	}

	export interface IAFXComponentBlend extends IUnique {
		isReadyToUse(): bool;
		isEmpty(): bool;

		getComponentCount():  number ;
		getTotalPasses():  number ;
		getHash(): string;

		_getMinShift():  number ;
		_getMaxShift():  number ;

		hasPostEffect(): bool;
		getPostEffectStartPass():  number ;

		containComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number );
		containComponentHash(sComponentHash: string): bool;

		findAddedComponentInfo(pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentInfo;

		addComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): void;
		removeComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): void;

		finalizeBlend(): bool;

		getPassInputForPass(iPass:  number ): IAFXPassInputBlend;
		getPassListAtPass(iPass:  number ): IAFXPassInstruction[];

		clone(): IAFXComponentBlend;

		_getComponentInfoList(): IAFXComponentInfo[];

		_setDataForClone(pAddedComponentInfoList: IAFXComponentInfo[],
						 pComponentHashMap: BoolMap,
						 nShiftMin:  number , nShiftMax:  number ): void;
	}
}













module akra {
	;
	;
	;

	export enum EDataFlowTypes {
/*!< The data stream can be marked up its index.*/
        MAPPABLE   = 1,
/*!< The data stream cannot be marked up its index.*/
        UNMAPPABLE = 0
    };

    export interface IDataFlow {
    	flow:    number ;
        data:   IVertexData;
        type:   EDataFlowTypes;
        mapper: IDataMapper;
    }

    export interface IDataMapper {
    	data: IVertexData;
    	semantics: string;
    	addition:  number ;
    }

	export interface IBufferMap extends IReferenceCounter, IEventProvider {
		primType: EPrimitiveTypes;
		index: IIndexData;
		length:  number ;

//FIXME: hack for terraing, for force limiting length of drawinf index.
/** writeonly */
		                 _length:  number ;

		 totalUpdates:  number ;

/** Number of primitives. */

		 primCount:  number ;
/** Maximum flow available in buffer map. */

		 limit:  number ;
/** Start index for drawning. */

		 startIndex:  number ;
/** Number of completed flows. */

		 size:  number ;
/** Completed flows. */

		 flows: IDataFlow[];
/** 
		 * Mappers. 
		 * @private
		 */

		 mappers: IDataMapper[];
/** 
		 * Offset in bytes for drawing with global idnex. 
		 * @deprecated
		 */

		 offset:  number ;

/**
		 * Find flow by semantics in.
		 * @param sSemantics VertexElement usage or semantics.
		 * @param {bool=} bComplete Find only in completed flows. Default is TRUE.
		 */

		getFlow(sSemantics: string, bComplete?: bool): IDataFlow;
		getFlow(iFlow:  number , bComplete?: bool): IDataFlow;

		findFlow(sSemantics: string): IDataFlow;

		reset(): void;

/**
		 * Add data to flow.
		 */

		flow(pVertexData: IVertexData):  number ;
		flow(iFlow:  number , pVertexData: IVertexData):  number ;
/**
		 * Add index for flow.
		 */

		mapping(iFlow:  number , pMap: IVertexData, sSemantics: string, iAddition?:  number ): bool;

/**
		 * Check, Is pData already used as flow or mapper.
		 */

		checkData(pData: IVertexData): bool;

/**
		 * Recals all statistics in buffer map.
		 */

		update(): bool;

		clone(bWithMapping?: bool): IBufferMap;

/**
		 * Draw buffer map.
		 */

		_draw(): void;

		toString(bListAll?: bool): string;

//some data, such as VertexTexture or VertexBuffer have been modified.
		 modified(): void;
	}
}









module akra {
//RID - renderable ID, for fast searching renderable object

	export interface IRIDTable {
		[iSceneObjectGuid:  number ]: IntMap;
	}

	export interface IRIDPair {
		renderable: IRenderableObject;
		object: ISceneObject;
	}

	export interface IRIDMap {
		[rid:  number ]: IRIDPair;
	}
}



module akra {

	export interface IAFXComposer {
		getComponentByName(sComponentName: string): IAFXComponent;
		getEngine(): IEngine;

//API for Effect-resource

		getComponentCountForEffect(pEffectResource: IEffect):  number ;
		getTotalPassesForEffect(pEffectResource: IEffect):  number ;
		addComponentToEffect(pEffectResource: IEffect,
							 pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;
		removeComponentFromEffect(pEffectResource: IEffect,
								  pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;
		hasComponentForEffect(pEffectResource:IEffect,
							  pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;

		activateEffectResource(pEffectResource: IEffect, iShift:  number ): bool;
		deactivateEffectResource(pEffectResource: IEffect): bool;

		getPassInputBlendForEffect(pEffectResource: IEffect, iPass:  number ): IAFXPassInputBlend;
//API for RenderTechnique
		getMinShiftForOwnTechniqueBlend(pRenderTechnique: IRenderTechnique):  number ;

		getTotalPassesForTechnique(pRenderTechnique: IRenderTechnique):  number ;

		addOwnComponentToTechnique(pRenderTechnique: IRenderTechnique,
								   pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;
		removeOwnComponentToTechnique(pRenderTechnique: IRenderTechnique,
									  pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;
		hasOwnComponentInTechnique(pRenderTechnique: IRenderTechnique,
								   pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;

		prepareTechniqueBlend(pRenderTechnique: IRenderTechnique): bool;

		markTechniqueAsNeedUpdate(pRenderTechnique: IRenderTechnique): void;

		getPassInputBlendForTechnique(pRenderTechnique: IRenderTechnique, iPass:  number ): IAFXPassInputBlend;

//API for render

		applyBufferMap(pBufferMap: IBufferMap): bool;
		applySurfaceMaterial(pSurfaceMaterial: ISurfaceMaterial): bool;

		_calcRenderID(pSceneObject: ISceneObject, pRenderable: IRenderableObject, bCreateIfNotExists?: bool):  number ;

		_getRenderableByRid(iRid:  number ): IRenderableObject;
		_getObjectByRid(iRid:  number ): ISceneObject;

		_setCurrentSceneObject(pSceneObject: ISceneObject): void;
		_setCurrentViewport(pViewport: IViewport): void;
		_setCurrentRenderableObject(pRenderable: IRenderableObject): void;

		_getCurrentSceneObject(): ISceneObject;
		_getCurrentViewport(): IViewport;
		_getCurrentRenderableObject(): IRenderableObject;

		_setDefaultCurrentState(): void;

		renderTechniquePass(pRenderTechnique: IRenderTechnique, iPass:  number ): void;

//API for load components/AFXEffects


		_loadEffectFromSyntaxTree(pTree: IParseTree, sFileName: string): bool;

		_loadEffectFromBinary(pData: Uint8Array, sFileName: string): bool;
	}
}






module akra {
	;
	;

	export interface ISpriteManager {
		_allocateSprite(pSprite: ISprite): IRenderData;
	}
}
















module akra {

        ;
        ;
        ;
        ;

        export interface IResourcePool extends IEventProvider {
                iFourcc:  number ;
                 manager: IResourcePoolManager;

/** Добавление данного пула в менеджер ресурсво по его коду */

                registerResourcePool(pCode: IResourceCode): void;
/** Удаление данного пула в менеджер ресурсво по его коду */

                unregisterResourcePool(): void;
/** По имени ресурса возвращает его хендл */

                findResourceHandle(sName: string):  number ;
/** По хендлу ресурва возвращает его имя */

                findResourceName(iHandle:  number ): string;

/** set resource name */

                setResourceName(iHandle:  number , sName: string): void;

                initialize(iGrowSize:  number ): void;
                destroy(): void;
                clean(): void;

                destroyAll(): void;
                restoreAll(): void;
                disableAll(): void;

                isInitialized(): bool;

//callbackDestroy(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackDisable(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackRestore(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackClean(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;

                createResource(sResourceName: string): IResourcePoolItem;
                loadResource(sResourceName: string): IResourcePoolItem;
                saveResource(pResource: IResourcePoolItem): bool;
                destroyResource(pResource: IResourcePoolItem): void;

                findResource(sName: string): IResourcePoolItem;
                getResource(iHandle:  number ): IResourcePoolItem;
                getResources(): IResourcePoolItem[];

                 createdResource(pResource: IResourcePoolItem): void;
        }
}








module akra {

	;

	export interface IResourceWatcherFunc {
		(nLoaded?:  number , nTotal?:  number , pTarget?: IResourcePoolItem): void;
	}
}













// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;

// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;

// getAnimationController(): IAnimationController;

// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;

// addNode(pNode: ISceneNode): void;

// addSkeleton(pSkeleton: ISkeleton): void;

// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;

// getRootNodes(): ISceneNode[];

// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;

// //instead old method: applyShadow();
// _setup(): bool;

// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;

module akra {
	;
	;
	;
    ;
    ;
    ;
    ;

//=============================================
// COLLADA LOAD OPTIONS
//=============================================

    export interface ICollada extends IModel {
        options: IColladaLoadOptions;

        getAsset(): IColladaAsset;
        getAnimations(): IColladaAnimation[];
        getAnimation(i:  number ): IColladaAnimation;

        getFilename(): string;
        getBasename(): string;

        isVisualSceneLoaded(): bool;
        isAnimationLoaded(): bool;

        attachToScene(pNode: ISceneNode): IModelEntry;
        attachToScene(pScene: IScene3d): IModelEntry;

        extractAnimations(): IAnimation[];
        extractAnimation(i:  number ): IAnimation;

        parse(sXMLData: string, pOptions?: IColladaLoadOptions): bool;
        loadResource(sFilename?: string, pOptions?: IColladaLoadOptions): bool;
    }

    export interface IColladaCache {
        meshMap: IMeshMap;
        sharedBuffer: IRenderDataCollection;
    }

	export interface IColladaAnimationLoadOptions {
		pose?: bool;
	}

    export interface IColladaImageLoadOptions {
        flipY?: bool;
    }

	export interface IColladaLoadOptions extends IModelLoadOptions {
/** Add nodes, that visualize joints in animated models. */

    	drawJoints?: bool;
/** Convert all meshed to wireframe. */

    	wireframe?: bool;
        shadows?: bool;
/** 
    	 * Use common buffer for all data 
    	 * @deprecated
    	 */

    	sharedBuffer?: bool;

    	animation?: IColladaAnimationLoadOptions;
    	scene?: bool;
    	extractPoses?: bool;
    	skeletons?: ISkeleton[];

        images?: IColladaImageLoadOptions;

        name?: string;


/*remove me*/
        debug?: bool;

    }

// xml

    export interface IXMLExplorer {
        (pXML: Element, sName?: string): void;
    }

//----------------------

    export interface IColladaTarget {
        value: number;
        object?: IColladaEntry;
        source?: IColladaEntry;
    }

    export interface IColladaEntry {
        id?: string;
        sid?: string;
        name?: string;
    }

    export interface IColladaEntryMap {
        [id: string]: IColladaEntry;
    }

    export interface IColladaLibrary extends IColladaEntry {
        [element: string]: IColladaEntryMap;
    }

    export interface IColladaEffectLibrary extends IColladaLibrary {
        effect: { [id: string]: IColladaEffect; };
    }

    export interface IColladaEntryLoader {
        (pXML: Element): IColladaEntry;
    }


    export interface IColladaUnknownFormat {
    	name: string[];
    	type: string[];
    }

/** Stride for collada formats, discretized at 32 bits. */

    export interface IColladaFormatStrideTable {
    	[format: string]:  number ;
    }

    export interface IColladaLinkMap {
    	[link: string]: any;
    }

    export interface IColladaLibraryMap {
    	[library: string]: IColladaLibrary;
    }

    export interface IColladaLibraryTemplate {
/** library tag name.*/
    	lib: string;
/** element in liibrary. */
    	element: string;
/** loader function */
    	loader: string;
    }


//=============================================
// COLLADA NODES / VISUAL SCENE AND COMMON
//=============================================

    export interface IColladaArray extends IColladaEntry {
        [i:  number ]: any;
    }

    export interface IColladaUnit extends IColladaEntry {
        name: string;
        meter:  number ;
    }

    export interface IColladaContributor extends IColladaEntry {
        author?: string;
        authoringTool?: string;
        comments?: string;
        copyright?: string;
        sourceData?: any;
    }

    export interface IColladaAsset extends IColladaEntry {
        unit: IColladaUnit;
        upAxis: string;
        title?: string;
        subject?: string;
        created: string;
        modified: string;
        keywords?: string[];
        contributor?: IColladaContributor;
    }

    export interface IColladaInstance extends IColladaEntry {
        url?: string;
    }

    export interface IColladaAnnotate extends IColladaEntry {
        name: string;
        value: string;
    }

    export interface IColladaNewParam extends IColladaEntry {
        sid: string;
        annotate: IColladaAnnotate;
        semantics: string;
        modifier: string;
        value: any;
        type: string;
    }

    export interface IColladaNewParamMap {
        [sid: string]: IColladaNewParam;
    }

    export interface IColladaParam extends IColladaEntry {
        name: string;
        type: string;
    }

    export interface IColladaAccessor extends IColladaEntry {
        source?: string;
        data: IColladaArray;
        count:  number ;
        stride:  number ;
        params: IColladaParam[];
    }


    export interface IColladaTechniqueCommon extends IColladaEntry {
        accessor: IColladaAccessor;
        perspective: IColladaPerspective;
    }


    export interface IColladaSource extends IColladaEntry {
        name: string;

        array: Object;
        techniqueCommon: IColladaTechniqueCommon;
    }

    export interface IColladaInput extends IColladaEntry {
        semantics: string;
        source: IColladaSource;
        offset:  number ;
        set: string;

        array?: any[];
//arrayId?: string;
        accessor?: IColladaAccessor;
    }

    export interface IColladaTransform extends IColladaEntry {
/* transform name: rotate, translate, scale or matrix */
        transform: string;
        value: any;
    }

    export interface IColladaRotate extends IColladaTransform {
        value: IVec4;
    }

    export interface IColladaTranslate extends IColladaTransform {
        value: IVec3;
    }

    export interface IColladaScale extends IColladaTransform {
        value: IVec3;
    }

    export interface IColladaMatrix extends IColladaTransform {
        value: IMat4;
    }

    export interface IColladaVertices extends IColladaEntry {
        inputs: { [semantics: string]: IColladaInput; };
    }

    export interface IColladaJoints extends IColladaEntry {
        inputs: { [input: string]: IColladaInput; };

    }

    export interface IColladaPolygons extends IColladaEntry {
        name: string;

        inputs: IColladaInput[];
        p:  number [];
        material: string;

        type?: EPrimitiveTypes;

        count:  number ;
    }

    export interface IColladaMesh extends IColladaEntry {
        sources: IColladaSource[];
        polygons: IColladaPolygons[];
    }

    export interface IColladaConvexMesh extends IColladaEntry {
//TODO: IColladaConvexMesh
    }

    export interface IColladaSpline extends IColladaEntry {
//TODO: IColladaSpline
    }

    export interface IColladaGeometrie extends IColladaEntry {
        name: string;

        mesh: IColladaMesh;
        convexMesh: IColladaConvexMesh;
        spline: IColladaSpline;
    }

    export interface IColladaMorph extends IColladaEntry {
//TODO: IColladaMorph
    }

    export interface IColladaVertexWeights extends IColladaEntry {
        count:  number ;
        inputs: IColladaInput[];
        weightInput: IColladaInput;
        vcount:  number [];
        v:  number [];
    }

    export interface IColladaSkin extends IColladaEntry {
        shapeMatrix: IMat4;
        sources: IColladaSource[];
        geometry: IColladaGeometrie;
        joints: IColladaJoints;
        vertexWeights: IColladaVertexWeights;
    }

    export interface IColladaController extends IColladaEntry {
        name: string;

        skin: IColladaSkin;
        morph: IColladaMorph;
    }

    export interface IColladaImage extends IColladaEntry {
        name: string;

        data: any;
        path: string;

        format?: string;
        depth?:  number ;
        height?:  number ;
        width?:  number ;
    }

//effects

    export interface IColladaSurface extends IColladaEntry {
        initFrom: string;
    }

    export interface IColladaSampler2D extends IColladaEntry {
        source: string;
        wrapS: string;
        wrapT: string;
        minFilter: string;
        mipFilter: string;
        magFilter: string;
    }

    export interface IColladaTexture extends IColladaEntry {
        texcoord: string;
        sampler: IColladaNewParam;
        surface: IColladaNewParam;
        image: IColladaImage;
    }


    export interface IColladaInstanceEffect extends IColladaInstance {
        parameters: Object;
        techniqueHint: StringMap;
        effect: IColladaEffect;
    }


    export interface IColladaPhong extends IColladaEntry {
        diffuse: IColorValue;
        specular: IColorValue;
        ambient: IColorValue;
        emissive: IColorValue;
        shininess:  number ;

        reflective: IColorValue;
        reflectivity:  number ;
        transparent: IColorValue;
        transparency:  number ;

        indexOfRefraction:  number ;

//------------------
        textures?: {
            diffuse: IColladaTexture;
            specular: IColladaTexture;
            ambient: IColladaTexture;
            emissive: IColladaTexture;
//additional, from oppen collada export
            normal: IColladaTexture;
        };
    }

    export interface IColladaEffectTechnique extends IColladaEntry {
        sid: string;
        type: string;
        value: IColladaEntry;
    }

    export interface IColladaProfileCommon extends IColladaEntry {
        technique: IColladaEffectTechnique;
        newParam: IColladaNewParamMap;
    }

    export interface IColladaEffect extends IColladaEntry {
        profileCommon: IColladaProfileCommon;
    }

// materials

    export interface IColladaMaterial extends IColladaEntry {
        name: string;

        instanceEffect: IColladaInstanceEffect;
    }



    export interface IColladaTechniqueValue extends IColladaEntry {

    }


    export interface IColladaBindVertexInput extends IColladaEntry {
        semantics: string;
        inputSemantic: string;
        inputSet:  number ;
    }

    export interface IColladaBindVertexInputMap {
        [semantics: string]: IColladaBindVertexInput;
    }

    export interface IColladaInstanceMaterial extends IColladaInstance {
        symbol: string;
        target: string;
        vertexInput: IColladaBindVertexInputMap;
        material: IColladaMaterial;
    }

    export interface IColladaInstanceCamera extends IColladaInstance {
        camera: IColladaCamera;
    }

    export interface IColladaInstanceLight extends IColladaInstance {
        light: IColladaLight;
    }

    export interface IColladaBindMaterial extends IColladaEntry {
        [symbol: string]: IColladaInstanceMaterial;
    }

    export interface IColladaInstanceGeometry extends IColladaInstance {
        geometry: IColladaGeometrie;
        material: IColladaBindMaterial;
    }


    export interface IColladaInstanceController extends IColladaInstance {
        controller: IColladaController;
        material: IColladaBindMaterial;
        skeletons: string[];
    }

    export interface IColladaPerspective extends IColladaEntry {
        xfov:  number ;
        yfov:  number ;
        znear:  number ;
        zfar:  number ;
        aspect:  number ;
    }

    export interface IColladaOptics extends IColladaEntry {
        techniqueCommon: IColladaTechniqueCommon;
    }


    export interface IColladaCamera extends IColladaEntry {
        optics: IColladaOptics;
    }

    export interface IColladaLight extends IColladaEntry {

    }

    export interface IColladaNode extends IColladaEntry {
        sid: string;
        name: string;
        type: string;
        layer: string;

        transform: IMat4;
        geometry: IColladaInstanceGeometry[];
        controller: IColladaInstanceController[];
        camera: IColladaInstanceCamera[];

        childNodes: IColladaNode[];
        depth:  number ;
        transforms: IColladaTransform[];

        constructedNode: ISceneNode;
    }


    export interface IColladaVisualScene extends IColladaEntry {
        name: string;

        nodes: IColladaNode[];
    }



/// animation

    export interface IColladaAnimationSampler extends IColladaEntry {
        inputs: { [semantics: string]: IColladaInput; };
    }

    export interface IColladaAnimationChannel extends IColladaEntry {
        target: IColladaTarget;
        sampler: IColladaAnimationSampler;
    }

    export interface IColladaAnimation extends IColladaEntry {
        name: string;

        sources: IColladaSource[];
        samplers: IColladaAnimationSampler[];
        channels: IColladaAnimationChannel[];

        animations?: IColladaAnimation[];
    }


    export interface IColladaScene {

    }

    export interface IColladaDocument {
        asset?: IColladaAsset;

        libEffects?: IColladaEffectLibrary;
        libMaterials?: IColladaLibrary;
        libGeometries?: IColladaLibrary;
        libVisualScenes?: IColladaLibrary;
        libAnimations?: IColladaLibrary;

        scene?: IColladaScene;
    }

    export interface IColladaAnimationClip extends IColladaEntry {
        name?: string;
        start:  number ;
        end:  number ;
    }




}



module akra {
    ;
    ;
    ;
    ;
    ;
    ;

    export enum EModelFormats {
        UNKNOWN,
        COLLADA = 0x1000,
        OBJ = 0x2000
    }

    export interface IModelLoadOptions {

    }

    export interface IModel extends IResourcePoolItem {
        byteLength:  number ;

        modelFormat: EModelFormats;

        loadResource(sFilename?: string, pOptions?: IModelLoadOptions): bool;
        attachToScene(pNode: ISceneNode): IModelEntry;
        attachToScene(pScene: IScene3d): IModelEntry;
    }
}



// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;

// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;

// getAnimationController(): IAnimationController;

// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;

// addNode(pNode: ISceneNode): void;

// addSkeleton(pSkeleton: ISkeleton): void;

// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;

// getRootNodes(): ISceneNode[];

// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;

// //instead old method: applyShadow();
// _setup(): bool;

// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;











module akra {
	export enum EResourceCodes {
		INVALID_CODE = 0xFFFFFFFF
	};

	export interface IResourceCode {
		family:  number ;
		type:  number ;
/** Пеерводит текущее состояние идентифиакора в невалидное */

		setInvalid(): void;
/** operator "<" */

		less(pSrc: IResourceCode): bool;
/** operator = */

		eq(pSrc: IResourceCode): IResourceCode;

		valueOf():  number ;
		toNumber():  number ;
	}
}



module akra.core.pool {
	export class ResourceCode implements IResourceCode {
		private iValue:  number  = <number>(EResourceCodes.INVALID_CODE);

		get family():  number  {
			return this.iValue >> 16;
		}

		set family(iNewFamily:  number ) {
			this.iValue &= 0x0000FFFF;
	        this.iValue |= iNewFamily << 16;
		}

		get type():  number  {
			return this.iValue & 0x0000FFFF;
		}

		set type(iNewType:  number ) {
			this.iValue &= 0xFFFF0000;
            this.iValue |= iNewType & 0x0000FFFF;
		}

		constructor ();
		constructor(iCode:  number );
		constructor(eCode: EResourceCodes);
		constructor(pCode: IResourceCode);
		constructor(iFamily:  number , iType:  number );
		constructor (iFamily?, iType?) {
			switch (arguments.length) {
		        case 0:
		            this.iValue = <number>EResourceCodes.INVALID_CODE;
		            break;
		        case 1:
		            if (arguments[0] instanceof ResourceCode) {
		                this.iValue = arguments[0].iValue;
		            }
		            else {
		                this.iValue = arguments[0];
		            }
		            break;
		        case 2:
		            this.family = arguments[0];
		            this.type = arguments[1];
		            break;
		    }
		}

		setInvalid(): void {
		    this.iValue = <number>EResourceCodes.INVALID_CODE;
		}

		less (pSrc: IResourceCode): bool {
		    return this.iValue < pSrc.valueOf();
		}

		eq(pSrc: IResourceCode): IResourceCode {
		    this.iValue = pSrc.valueOf();
		    return this;
		};

		valueOf():  number  {
		    return this.iValue;
		};

		toNumber():  number  {
			return this.iValue;
		}
	}


}
















module akra {

	;
	;

	export interface IDataPool {
		manager: IResourcePoolManager;
/** Инициализация пула данных */

		initialize(iGrowSize:  number ): void;

/** Инициализирован ли пул */

		isInitialized(): bool;

/** Очистка пула и пометка о том что он больш не инициализирован */

		destroy(): void;

/** Высвобождаем элемент в пуле по его номеру */

		release(iHandle:  number ): void;
/*
		 * даление всех групп
 		 * Все группы должны быть пусты, иначе во время удаления произойдет ошибка
		 **/

		clear(): void;
/** Добавляет новый элемент в пул */

		add(pMembers: IResourcePoolItem):  number ;

/** Цикл по всем объектам с приминением к ним функции, как fFunction(текущий пул данных, объект к торому применяется); */

		forEach(fFunction: (pPool: IDataPool, iHandle:  number , pMember: IResourcePoolItem) => void): void;

/** Ищет первый свободный элемент в пуле */

		nextHandle():  number ;
/** Проверяется используется лм этот элемент */

		isHandleValid(iHandle:  number ): bool;

/** Возвратитть элемент по хендлу */

		get(iHandle:  number ): IResourcePoolItem;
/** Возвратитть элемент по хендлу */

		getPtr(iHandle:  number ): IResourcePoolItem;
/** Возвратитть элемент по хендлу */

		getGenericPtr(iHandle:  number ): IResourcePoolItem;
	}
}













module akra.util {
	export class ReferenceCounter implements IReferenceCounter {
		private nReferenceCount:  number  = 0;

/** Выстанавливает чило ссылок  на объект в ноль */

		constructor ();
/** 
		 * Выстанавливает чило ссылок  на объект в ноль
 		 * количесвто ссылок привязаны к конкретному экземпляру, поэтому никогда не копируются 
 		 */

		constructor (pSrc: IReferenceCounter);
		constructor (pSrc?) {}

/** @inline */

		referenceCount():  number  {
			return this.nReferenceCount;
		}

/** @inline */

		destructor(): void {
			{ logger.setSourceLocation( "util/ReferenceCounter.ts" , 26 ); logger.assert(this.nReferenceCount === 0, 'object is used'); } ;
		}

		release():  number  {
			{ logger.setSourceLocation( "util/ReferenceCounter.ts" , 30 ); logger.assert(this.nReferenceCount > 0, 'object is used'); } ;
		    this.nReferenceCount--;
		    return this.nReferenceCount;
		}

		addRef():  number  {
			{ logger.setSourceLocation( "util/ReferenceCounter.ts" , 36 ); logger.assert(this.nReferenceCount != MIN_INT32, 'reference fail'); } ;

    		this.nReferenceCount ++;

			return this.nReferenceCount;
		}

/** @inline */

		eq (pSrc: IReferenceCounter): IReferenceCounter {
		    return this;
		};
	}
}






/***********************************************
 * TODO: check, if event exists on target!!!!!
 *************************************************/






module akra {
	export interface IEventSlot {
		target: any;
		callback: string;
		listener: Function;
	}

	export interface IEventSlotListMap {
		[index: string]: IEventSlot[];
	}
	export interface IEventSlotMap {
		[index: string]: IEventSlot;
	}

	export interface IEventSlotTable {
		[index: number]: IEventSlotListMap;
		[index: string]: IEventSlotListMap;
	}

	export interface IEventSlotList {
		[index: number]: IEventSlotMap;
		[index: string]: IEventSlotMap;
	}

	export interface IEventTable {
		broadcast: IEventSlotTable;
		unicast: IEventSlotList;

		addDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType?: EEventTypes): bool;
		removeDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType?: EEventTypes): bool;
		addListener(iGuid:  number , sSignal: string, fnListener: Function, eType?: EEventTypes): bool;
		removeListener(iGuid:  number , sSignal: string, fnListener?: Function, eType?: EEventTypes): bool;

		findUnicastList(iGuid:  number ): IEventSlotMap;
		findBroadcastList(iGuid:  number ): IEventSlotListMap;

		findBroadcastSignalMap(iGuid:  number , sSignal: string): IEventSlot[];

		_sync(pTarget: IEventProvider, pFrom: IEventProvider): void;
	}
}

















/*console.error(this.getEventTable());*/











/**event, signal, slot*/


/**event, signal, slot*/









//#define END_EVENT_TABLE()

module akra.events {
	export class EventTable implements IEventTable {
		broadcast: IEventSlotTable = <IEventSlotTable>{};
		unicast: IEventSlotList = <IEventSlotList>{};

		addDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {

				if (this.findDestinationIndexBC(iGuid, sSignal, pTarget, sSlot) === -1) {
					this.findBroadcastSignalMap(iGuid, sSignal).push({target: pTarget, callback: sSlot, listener: null});
				}

				return true;
			}
			else {
				this.unicast[iGuid] = this.unicast[iGuid] || {};
//console.log(iGuid, sSignal, pTarget, sSlot, eType);
//console.warn(this.unicast);
				if (!isDef(this.unicast[iGuid][sSignal])) {
					this.unicast[iGuid][sSignal] = {target: pTarget, callback: sSlot, listener: null};
					return true;
				}
			}
			return false;
		}

		private findDestinationIndexBC(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string):  number  {

			var pList: IEventSlot[] = this.findBroadcastSignalMap(iGuid, sSignal);

			for (var i:  number  = 0; i < pList.length; ++ i) {
				if (pList[i].target === pTarget && pList[i].callback === sSlot) {
					return i;
				}
			}

			return -1;
		}

		removeDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
				var pList: IEventSlot[] = this.findBroadcastSignalMap(iGuid, sSignal);
				var i:  number  = this.findDestinationIndexBC(iGuid, sSignal, pTarget, sSlot);

				if (i != -1) {
					pList.splice(i, 1);
					return true;
				}
			}
			else {
				if (this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
					delete this.unicast[iGuid][sSignal];
					return true;
				}
			}
			{ logger.setSourceLocation( "events/events.ts" , 134 ); logger.warning("cannot remove destination for GUID <%s> with signal <%s>", iGuid, sSignal); } ;
			return false;
		}

		addListener(iGuid:  number , sSignal: string, fnListener: Function, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
// console.log("add listener(", iGuid, "):: ", "listener: ", fnListener, "signal: ", sSignal);
				this.findBroadcastSignalMap(iGuid, sSignal).push({target: null, callback: null, listener: fnListener});
				return true;
			}
			else {
				this.unicast[iGuid] = this.unicast[iGuid] || {};
				if (!isDef(this.unicast[iGuid][sSignal])) {
					this.unicast[iGuid][sSignal] = {target: null, callback: null, listener: fnListener};
					return true;
				}
			}
			{ logger.setSourceLocation( "events/events.ts" , 151 ); logger.warning("cannot add listener for GUID <%s> with signal <%s>", iGuid, sSignal); } ;
			return false;
		}

		removeListener(iGuid:  number , sSignal: string, fnListener?: Function, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
				var pList: IEventSlot[] = this.findBroadcastSignalMap(iGuid, sSignal);
				for (var i:  number  = 0; i < pList.length; ++ i) {
					if (pList[i].listener === fnListener) {
						pList.splice(i, 1);
						return true;
					}
				}
			}
			else {
				if (this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
					delete this.unicast[iGuid][sSignal];
					return true;
				}
			}
			return false;
		}

		/**@inline*/  findBroadcastList(iGuid:  number ): IEventSlotListMap {
			return (this.broadcast[iGuid] = this.broadcast[iGuid] || {});
		}

		findUnicastList(iGuid:  number ): IEventSlotMap {
//console.error(iGuid,this.unicast[iGuid]);

			this.unicast[iGuid] = this.unicast[iGuid] || {};
			return this.unicast[iGuid];
		}

		_sync(pTarget: IEventProvider, pFrom: IEventProvider): void {
//FIXME: release events of target...
			this.broadcast[pTarget.getGuid()] = this.broadcast[pFrom.getGuid()];
			this.unicast[pTarget.getGuid()] = this.unicast[pFrom.getGuid()];
		}

		findBroadcastSignalMap(iGuid:  number , sSignal: string): IEventSlot[] {
			this.broadcast[iGuid] = this.broadcast[iGuid] || {};
			this.broadcast[iGuid][sSignal] = this.broadcast[iGuid][sSignal] || [];
			return this.broadcast[iGuid][sSignal];
		}
	}


	export class EventProvider implements IEventProvider {
		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return EventProvider._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
	}
}




module akra.core.pool {
    export class ResourcePool extends util.ReferenceCounter implements IResourcePool {
        private pManager: IResourcePoolManager = null;
/** Конструктор для создания данных в пуле ресурсов */

        private tTemplate: IResourcePoolItemType = null;
        private sExt: string = null;
        private pRegistrationCode: IResourceCode = new ResourceCode(EResourceCodes.INVALID_CODE);
/*{[index: number]: string;}*/
        private pNameMap: string[]                               = new Array();
        private pDataPool: IDataPool = null;


        /**@inline*/  get iFourcc():  number  {
            return (this.sExt.charCodeAt(3) << 24)
                      | (this.sExt.charCodeAt(2) << 16)
                      | (this.sExt.charCodeAt(1) << 8)
                      | (this.sExt.charCodeAt(0));
        }



        set iFourcc(iNewFourcc:  number ) {
            this.sExt = String.fromCharCode((iNewFourcc & 0x000000FF),
                                             (iNewFourcc & 0x0000FF00) >>> 8,
                                             (iNewFourcc & 0x00FF0000) >>> 16,
                                             (iNewFourcc & 0xFF000000) >>> 24);
        }

        /**@inline*/  get manager(): IResourcePoolManager {
            return this.pManager;
        }

        constructor (pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType) {
            super();

            this.pManager = pManager;
            this.tTemplate = tTemplate;
            this.pDataPool = new DataPool(this.pManager, tTemplate);
        }

/** Добавление данного пула в менеджер ресурсво по его коду */

        registerResourcePool(pCode: IResourceCode): void {
            this.pRegistrationCode.eq(pCode);
            this.pManager.registerResourcePool(this.pRegistrationCode, this);
        }

/** Удаление данного пула в менеджер ресурсво по его коду */

        unregisterResourcePool(): void {
            this.pManager.unregisterResourcePool(this.pRegistrationCode);
            this.pRegistrationCode.setInvalid();
        }

/** По имени ресурса возвращает его хендл */

        findResourceHandle(sName: string):  number  {
// look up the name in our map
            var iNewHandle = INVALID_INDEX;

            for (var iHandle:  number  = 0; iHandle < this.pNameMap.length; ++ iHandle) {
                if (this.pNameMap[iHandle] === sName) {
                    return iHandle;
                }
            }

            return iNewHandle;
        }

/** 
         * Get resource name by handle.
         * @inline
         */

        findResourceName(iHandle:  number ): string {
            return this.pNameMap[iHandle];
        }

        setResourceName(iHandle:  number , sName: string): void {
            this.pNameMap[iHandle] = sName;
        }


        initialize(iGrowSize:  number ): void {
            this.pDataPool.initialize(iGrowSize);
        }

/** @inline */

        destroy(): void {
            this.pDataPool.destroy();
        }


        clean(): void {
            this.pDataPool.forEach(ResourcePool.callbackClean);
        }

        destroyAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackDestroy);
        }

        restoreAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackRestore);
        }

        disableAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackDisable);
        }

/** @inline */

        isInitialized(): bool {
            return this.pDataPool.isInitialized();
        }



        createResource(sResourceName: string): IResourcePoolItem {
            var iHandle:  number  = this.internalCreateResource(sResourceName);

            if (iHandle !== INVALID_INDEX) {
                var pResource: IResourcePoolItem = this.getResource(iHandle);

                pResource.setResourcePool(this);
                pResource.setResourceHandle(iHandle);
                pResource.setResourceCode(this.pRegistrationCode);

                this.createdResource(pResource);

                return pResource;
            }

            return null;
        }

        loadResource(sResourceName: string): IResourcePoolItem {
// does the resource already exist?
            var pResource: IResourcePoolItem = this.findResource(sResourceName);

            if (pResource == null) {
// create a new resource
                pResource = this.createResource(sResourceName);

                if (pResource != null) {
// attempt to load the desired data
                    if (pResource.loadResource(sResourceName)) {
// ok!
                        return pResource;
                    }

// loading failed.
// destroy the resource we created
// destroyResource(pResource);
                    pResource.release();
                    pResource = null;
                }
            }

            return pResource;
        }

        saveResource(pResource: IResourcePoolItem): bool {
            if (pResource != null) {
// save the resource using it's own name as the file path
                return pResource.saveResource();
            }
            return false;
        }

        destroyResource(pResource: IResourcePoolItem): void {
            if (pResource != null) {
                var iReferenceCount:  number  = pResource.referenceCount();

                { logger.setSourceLocation( "ResourcePool.ts" , 180 ); logger.assert(iReferenceCount == 0, "destruction of non-zero reference count!"); } ;

                if (iReferenceCount <= 0) {
                    var iHandle:  number  = pResource.resourceHandle;
                    this.internalDestroyResource(iHandle);
                }
            }
        }

        findResource(sName: string): IResourcePoolItem {

// look up the name in our map
            for (var iHandle:  number  = 0; iHandle < this.pNameMap.length; ++ iHandle) {
                if (this.pNameMap[iHandle] == sName) {
                    if (iHandle != INVALID_INDEX) {
                        var pResource = this.getResource(iHandle);
                        return pResource;
                    }
                }
            }

            return null;
        }

        getResource(iHandle:  number ): IResourcePoolItem {
            var pResource: IResourcePoolItem = this.internalGetResource(iHandle);

            if (pResource != null) {
                pResource.addRef();
            }

            return pResource;
        }

        getResources(): IResourcePoolItem[] {
            var pResources: IResourcePoolItem[] = [];

            for (var iHandleResource in this.pNameMap) {
                pResources.push(this.getResource(parseInt(iHandleResource)));
            }

            return pResources;
        }


        private internalGetResource(iHandle:  number ): IResourcePoolItem {
            return this.pDataPool.getPtr(iHandle);
        }

        private internalDestroyResource(iHandle:  number ): void {
// get a pointer to the resource and call it's destruction handler
            var pResource = this.pDataPool.getPtr(iHandle);

            pResource.destroyResource();

            delete this.pNameMap[iHandle];

// free the resource slot associated with the handle
            this.pDataPool.release(iHandle);
        };

        private internalCreateResource(sResourceName: string):  number  {
            var iHandle:  number  = this.pDataPool.nextHandle();

// make sure this name is not already in use
            for (var iter in this.pNameMap) {
                { logger.setSourceLocation( "ResourcePool.ts" , 247 ); logger.assert((this.pNameMap[iter] != sResourceName), "A resource with this name already exists: " + sResourceName); }
                                                                                         ;
            }

// add this resource name to our map of handles
            this.pNameMap[iHandle] = sResourceName;

// get a pointer to the resource and call it's creation function
            var pResource = this.pDataPool.getPtr(iHandle);

            pResource.createResource();

            return iHandle;
        }

        private static callbackDestroy(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.destroyResource();
        }

        private static callbackDisable(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.disableResource();
        }

        private static callbackRestore(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.restoreResource();
        }

        private static callbackClean(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            if (pResource.referenceCount() == 0) {
                pPool.release(iHandle);
            }
        }

        protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return ResourcePool._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
        createdResource (pResource): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).createdResource; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pResource) : _broadcast[i].listener (_recivier, pResource) ; } } } ; ;

    }
}
















module akra.core.pool {

	export interface IGroupNumber {
		value:  number ;
	}

	export class PoolGroup {
		private pManager: IResourcePoolManager;

/** Конструктор для создания данных в группе */

		private tTemplate: IResourcePoolItemType;

/** Число свободных элементов группы */

		private iTotalOpen:  number  = 0;
/** Первый свободный элемент группы */

		private iFirstOpen:  number  = 0;
/** Колмичество элементов в группе */

		private iMaxCount:  number  = 0;

/** Список свободных элементов группы */

		private pNextOpenList:  number [] = null;
/** Массив элементов группы */

		private pMemberList: IResourcePoolItem[] = null;

		/**@inline*/  get manager(): IResourcePoolManager { return this.pManager; }

/** 
		 * Возвращает количесвто свободных мест в группе 
		 * @inline
		 */

		get totalOpen():  number  {
			return this.iTotalOpen;
		}

/** 
		 * Возвращает количесвто занятых мест в группе 
		 * @inline
		 */

		get totalUsed():  number  {
			return this.iMaxCount - this.iTotalOpen;
		}

/**
		 * Номер первого свободного элемента в группе
		 * @inline
		 */

		get firstOpen():  number  {
			return this.iFirstOpen;
		}

		constructor (pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType, iMaxCount:  number ) {
			this.pManager = pManager;
			this.tTemplate = tTemplate;
			this.iMaxCount = iMaxCount;
		}

/** Создание группы, создается массив элементов, инициализирется список свободный и т.д. */

		create(): void {
			var i:  number ;

		    { logger.setSourceLocation( "DataPool.ts" , 70 ); logger.assert(this.pMemberList == null && this.pNextOpenList == null, "Group has already been created"); } ;

		    this.pNextOpenList = new Array(this.iMaxCount);

		    { logger.setSourceLocation( "DataPool.ts" , 74 ); logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!"); } ;

		    this.pMemberList = new Array(this.iMaxCount);


		    for (i = 0; i < this.iMaxCount; i++) {
		        this.pMemberList[i] = new this.tTemplate(this.pManager);
		    }

		    { logger.setSourceLocation( "DataPool.ts" , 83 ); logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!"); } ;

		    for (i = 0; i < this.iMaxCount - 1; i++) {
		        this.pNextOpenList[i] = i + 1;
		    }

		    this.pNextOpenList[i] = i;
		    this.iTotalOpen = this.iMaxCount;
		    this.iFirstOpen = 0;
		}

/**  
		 * Удаление группы: удаление массива элементов, списка совбодных элементов и т.д.
		 * Выдается ошибка если группа не пуста 
		 * */

		destroy(): void {
		    { logger.setSourceLocation( "DataPool.ts" , 99 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 100 ); logger.assert(this.iTotalOpen == this.iMaxCount, "Group is not empty"); } ;

		    delete this.pMemberList;
		    this.pMemberList = null;

		    delete this.pNextOpenList;
		    this.pNextOpenList = null;

		    this.iTotalOpen = 0;
		    this.iMaxCount = 0;
		}

/** Возвращает номер следующего совбодного элемента в списке, и помечает его как используемый */

		nextMember() {
		    { logger.setSourceLocation( "DataPool.ts" , 114 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 115 ); logger.assert(this.iTotalOpen != null, "no open slots"); } ;
//Возвращает номер первого свободного элемента в группе,
//и изменяет номер первого свободного на следующего свободного

		    var iSlot = this.iFirstOpen;
		    this.iFirstOpen = this.pNextOpenList[iSlot];
		    this.iTotalOpen --;

		    { logger.setSourceLocation( "DataPool.ts" , 123 ); logger.assert(this.iFirstOpen != INVALID_INDEX, "Invalid Open Index"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 124 ); logger.assert(this.isOpen(iSlot), "invalid index"); } ;

//помечаем что элемент который отдали является используемым
		    this.pNextOpenList[iSlot] = INVALID_INDEX;

		    return iSlot;
		}

/** Добавляем новый элемент в список */

		addMember(pMember: IResourcePoolItem):  number  {
			var iSlot:  number  = this.nextMember();
		    this.pMemberList[iSlot] = pMember;

		    return iSlot;
		}

/** Исключение элемента из списка по его номеру */

		release(iIndex:  number ): void {
			{ logger.setSourceLocation( "DataPool.ts" , 142 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 143 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 144 ); logger.assert(this.isOpen(iIndex) == false, "invalid index to release"); } ;

		    this.pNextOpenList[iIndex] = this.iTotalOpen > 0 ? this.iFirstOpen : iIndex;
		    this.iTotalOpen ++;
		    this.iFirstOpen = iIndex;
		}


/** Проверить свободна ли эта ячейка в группе */

		isOpen (iIndex:  number ): bool {
		    { logger.setSourceLocation( "DataPool.ts" , 154 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 155 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); } ;

		    return this.pNextOpenList[iIndex] != INVALID_INDEX;
		}

/** Получение элемента по его номеру */

		member(iIndex:  number ): IResourcePoolItem {
		    { logger.setSourceLocation( "DataPool.ts" , 162 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 163 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); } ;
		    return this.pMemberList[iIndex];
		}

		memberPtr(iIndex:  number ): IResourcePoolItem {
		    { logger.setSourceLocation( "DataPool.ts" , 168 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 169 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); } ;
		    return this.pMemberList[iIndex];
		}
	}

	export class DataPool implements IDataPool {
		private pManager: IResourcePoolManager;
		private tTemplate: IResourcePoolItemType;
		private bInitialized: bool = false;

/** Массив групп */

		private pGroupList: PoolGroup[] = [];

/** Общее число ячеек */

		private iTotalMembers:  number  = 0;
/** Количесвто свободных ячеек */

		private iTotalOpen:  number  = 0;
/** Количесвто элементов в группе */

		private iGroupCount:  number  = 0;
/**
		 * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
    	 * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
		 */

		private iIndexMask:  number  = 0;
/**
		 * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
     	 * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
		 */

		private iIndexShift:  number  = 0;


		/**@inline*/  get manager(): IResourcePoolManager { return this.pManager; }

		constructor(pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType) {
			this.pManager = pManager;
			this.tTemplate = tTemplate;
		}


		initialize(iGrowSize:  number ): void {
			{ logger.setSourceLocation( "DataPool.ts" , 209 ); logger.assert(this.isInitialized() == false, "the cDataPool is already initialized"); } ;

		    this.bInitialized = true;
		    this.iGroupCount = math.nearestPowerOfTwo(iGrowSize);
		    this.iIndexShift = math.lowestBitSet(this.iGroupCount);
		    this.iIndexShift = math.clamp(this.iIndexShift, 1, 15);
		    this.iGroupCount = 1 << this.iIndexShift;
		    this.iIndexMask = this.iGroupCount - 1;
		}


/** @inline */

		isInitialized(): bool {
			return this.bInitialized;
		}


		destroy(): void {
			this.clear();
    		this.bInitialized = false;
		}


		release(iHandle:  number ): void {
			{ logger.setSourceLocation( "DataPool.ts" , 233 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); } ;

		    if (this.isHandleValid(iHandle) == true) {
		        { logger.setSourceLocation( "DataPool.ts" , 236 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); } ;

		        var iGroupIndex:  number  = this.getGroupNumber(iHandle);
		        var iItemIndex:  number  = this.getItemIndex(iHandle);

		        var pGroup: PoolGroup = this.getGroup(iGroupIndex);
		        pGroup.release(iItemIndex);
		        var pGroupBack: PoolGroup = this.pGroupList[this.pGroupList.length - 1];

		        if (pGroupBack.totalOpen == this.iGroupCount) {
		            pGroupBack.destroy();
		            this.pGroupList.splice(this.pGroupList.length - 1, 1);
		        }

		        this.iTotalOpen ++;
		    }
		}

		clear(): void {
// destroy all groups in the list
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; ++ iGroupIter) {
		        this.pGroupList[iGroupIter].destroy();
		    }

// now clear the list itself
		    this.pGroupList.clear();
		}

		add(pMembers: IResourcePoolItem):  number  {
			{ logger.setSourceLocation( "DataPool.ts" , 265 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); } ;

		    var iGroupNumber: IGroupNumber = {value: 0};

		    var pOpenGroup: PoolGroup = this.findOpenGroup(iGroupNumber);
		    var iIndex:  number  = pOpenGroup.addMember(pMembers);

		    this.iTotalOpen --;

		    return this.buildHandle(iGroupNumber.value, iIndex);
		}

		forEach(fFunction: (pPool: IDataPool, iHandle:  number , pMember: IResourcePoolItem) => void): void {
			{ logger.setSourceLocation( "DataPool.ts" , 278 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); } ;
// iterate through every group

		    var iGroupNumber:  number  = 0;
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {

		        var nCallbackCount:  number  = this.pGroupList[iGroupIter].totalUsed;
		        var iItemIndex:  number  = 0;

		        while (nCallbackCount != 0 && iItemIndex < this.iGroupCount) {
		            if (this.pGroupList[iGroupIter].isOpen(iItemIndex) == false) {
		                fFunction(
		                	this,
		                	this.buildHandle(iGroupNumber, iItemIndex),
		                	this.pGroupList[iGroupIter].member(iItemIndex)
		                	);
		                nCallbackCount--;
		            }

		            ++iItemIndex;
		        }

		        ++iGroupNumber;
		    }
		}

		nextHandle():  number  {
			{ logger.setSourceLocation( "DataPool.ts" , 305 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); } ;

		    var iGroupNumber: IGroupNumber = {value: 0};
		    var pOpenGroup: PoolGroup = this.findOpenGroup(iGroupNumber);
		    var iIndex:  number  = pOpenGroup.nextMember();

		    this.iTotalOpen --;

		    return this.buildHandle(iGroupNumber.value, iIndex);
		}

		isHandleValid(iHandle:  number ): bool {
			{ logger.setSourceLocation( "DataPool.ts" , 317 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); } ;

		    if (iHandle !== INVALID_INDEX) {
		        { logger.setSourceLocation( "DataPool.ts" , 320 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); } ;

		        var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));

		        return !pGroup.isOpen(this.getItemIndex(iHandle));
		    }

		    return false;
		}

		get(iHandle:  number ): IResourcePoolItem {
			{ logger.setSourceLocation( "DataPool.ts" , 331 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 332 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); } ;

		    var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));
		    var iItemIndex:  number  = this.getItemIndex(iHandle);

		    return pGroup.member(iItemIndex);
		}

		getPtr(iHandle:  number ): IResourcePoolItem {
			{ logger.setSourceLocation( "DataPool.ts" , 341 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); } ;
		    { logger.setSourceLocation( "DataPool.ts" , 342 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); } ;

		    var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));
		    var iItemIndex:  number  = this.getItemIndex(iHandle);

		    return pGroup.memberPtr(iItemIndex);
		}

		getGenericPtr(iHandle:  number ): IResourcePoolItem {
			{ logger.setSourceLocation( "DataPool.ts" , 351 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); } ;

    		return this.getPtr(iHandle);
		}


/** 
		 * @inline 
		 * Получение номера группы по номеру элемента
		 */

		private getGroupNumber(iHandle:  number ):  number  {
			return iHandle >> this.iIndexShift;
		}

/** 
		 * @inline 
		 * Получение номера элеменат в группе по его номеру
		 */

		private getItemIndex(iHandle:  number ):  number  {
			return iHandle & this.iIndexMask;
		}

/** 
		 * @inline 
		 * Полученяи номера элеменат по его номеру группы и группе
		 */

		private buildHandle(iGroup, iIndex):  number  {
			return (iGroup << this.iIndexShift) + iIndex;
		}

/** Добавление группы в пул */

		private addGroup(): PoolGroup {
// append a new group to the list to start things off
		    var pNewGroup: PoolGroup = new PoolGroup(this.pManager, this.tTemplate, this.iGroupCount);
		    this.pGroupList.push(pNewGroup);
// gain access to the new group and innitialize it
		    pNewGroup.create();
// increment our internal counters
		    this.iTotalMembers += this.iGroupCount;
		    this.iTotalOpen += this.iGroupCount;

		    return pNewGroup;
		}

/** Поиск первой группы которая имеет свободную область */

		private findOpenGroup(pGroupNumber: IGroupNumber): PoolGroup {
			pGroupNumber.value = 0;

//найдем и вренем первую группу имеющую свободную группу
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
		        if (this.pGroupList[iGroupIter].totalOpen > 0) {
		            return this.pGroupList[iGroupIter];
		        }

		        pGroupNumber.value ++;
		    }

//свободных областей нет, поэтому мы должны добавить новую группу в пул,
//но пержде чем содавать убедимся что не достигли максимума

		    { logger.setSourceLocation( "DataPool.ts" , 411 ); logger.assert((this.pGroupList.length + 1) < MAX_UINT16, "the cDataPool is full!!!!"); } ;
//добавим новую группу

		    return this.addGroup();
		}

/** 
		 * @inline 
		 * Возвращает группу по ее номеру
		 */

		private getGroup(iIndex:  number ): PoolGroup {
			{ logger.setSourceLocation( "DataPool.ts" , 422 ); logger.assert(iIndex < this.pGroupList.length, "Invalid group index requested"); } ;
    		return this.pGroupList[iIndex];
		}


	}
}















module akra {

	;
	;


	export interface IRenderMethod extends IResourcePoolItem {
		effect: IEffect;
		surfaceMaterial: ISurfaceMaterial;
		material: IMaterial;

		setForeign(sName: string, pValue: any, iPass?:  number ): void;
		setUniform(sName: string, pValue: any, iPass?:  number ): void;
		setTexture(sName: string, pValue: ITexture, iPass?:  number ): void;
		setRenderState(eState: ERenderStates, eValue: ERenderStateValues, iPass?:  number ): void;

		setSamplerTexture(sName: string, pTexture: ITexture, iPass?:  number ): void;
		setSamplerTexture(sName: string, sTexture: string, iPass?:  number ): void;

		isEqual(pRenderMethod: IRenderMethod): bool;

		_getPassInput(iPass:  number ): IAFXPassInputBlend;
	}
}























module akra {
	export interface IResourceNotifyRoutineFunc {
		(iFlagBit?:  number , iResourceFlags?:  number , isSet?: bool): void;
		(eEvent?: EResourceItemEvents, iResourceFlags?:  number , isSet?: bool): void;
	}
}









module akra.core.pool {

	export interface ICallbackSlot {
		bState: bool;
		fn: IResourceNotifyRoutineFunc;
		pResourceItem: IResourcePoolItem;
	}

	export class ResourcePoolItem extends util.ReferenceCounter implements IResourcePoolItem {
//private pManager: IResourcePoolManager;
		private pResourceCode: IResourceCode;
		private pResourcePool: IResourcePool = null;
		private iResourceHandle:  number  = 0;
		private iResourceFlags:  number  = 0;
		private pCallbackFunctions: IResourceNotifyRoutineFunc[];
		private pStateWatcher: IResourceWatcherFunc[];
		private pCallbackSlots: ICallbackSlot[][];


		/**@inline*/  get resourceCode(): IResourceCode {
			return this.pResourceCode;
		}

		/**@inline*/  get resourcePool(): IResourcePool {
			return this.pResourcePool;
		}

		/**@inline*/  get resourceHandle():  number  {
			return this.iResourceHandle;
		}

		/**@inline*/  get resourceFlags():  number  {
			return this.iResourceFlags;
		}

		/**@inline*/  get alteredFlag(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.ALTERED);
		}

		/**@inline*/  get manager(): IResourcePoolManager { return this.getManager(); }

/** Constructor of ResourcePoolItem class */

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
			super();

//this.pManager = pManager;
			this.pResourceCode = new ResourceCode(0);
			this.pCallbackFunctions = [];
			this.pStateWatcher = [];
			this.pCallbackSlots = genArray(null, <number>EResourceItemEvents.TOTALRESOURCEFLAGS);
		}

		/**@inline*/  getEngine(): IEngine {
			var pManager: IResourcePoolManager = this.getManager();

			if (pManager) {
				return pManager.getEngine();
			}

			return null;
		}

		/**@inline*/  getManager(): core.pool.ResourcePoolManager {
			return <ResourcePoolManager>(<ResourcePool>this.pResourcePool).manager;
		}

		createResource(): bool {
			return false;
		}

		destroyResource(): bool {
			return false;
		}

		disableResource(): bool {
			return false;
		}

		restoreResource(): bool {
			return false;
		}

		loadResource(sFilename: string = null): bool {
			return false;
		}

		saveResource(sFilename: string = null): bool {
			return false;
		}


		setChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void {
			for (var i:  number  = 0; i < this.pCallbackFunctions.length; i ++) {

			    if (this.pCallbackFunctions[i] == fn) {
			        return;
			    }
			}

			this.pCallbackFunctions.push(fn);
		}

		delChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void {
			for (var i:  number  = 0; i < this.pCallbackFunctions.length; i ++) {
		        if (this.pCallbackFunctions[i] == fn) {
		            this.pCallbackFunctions[i] = null;
		        }
		    }
		}

		setStateWatcher(eEvent: EResourceItemEvents, fnWatcher: IResourceWatcherFunc): void {
			this.pStateWatcher[eEvent] = fnWatcher;
		}

		isSyncedTo(eSlot: EResourceItemEvents): bool {
			return !isNull(this.pCallbackSlots[eSlot]) && this.pCallbackSlots[eSlot].length > 0;
		}

		sync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool {
			eSlot = isDef(eSlot)? eSlot: eSignal;

		    eSlot = ResourcePoolItem.parseEvent(<number>eSlot);
		    eSignal = ResourcePoolItem.parseEvent(<number>eSignal);

		    var pSlots: ICallbackSlot[][] = this.pCallbackSlots, pSignSlots: ICallbackSlot[];

		    var me: IResourcePoolItem = this;
		    var n:  number ;
		    var fn: IResourceNotifyRoutineFunc;
		    var bState: bool;

		    if (isNull(pSlots[eSlot])) {
		        pSlots[eSlot] = [];
		    }

		    pSignSlots = pSlots[eSlot];
		    n = pSignSlots.length;
		    bState = bf.testBit(pResourceItem.resourceFlags, <number>eSignal);

		    fn = function (eFlag?: EResourceItemEvents, iResourceFlags?:  number , isSet?: bool) {
		        if (eFlag == <number>eSignal) {
		            pSignSlots[n].bState = isSet;
		            me.notifyStateChange(eSlot, this);

		            for (var i:  number  = 0; i < pSignSlots.length; ++i) {
		                if (pSignSlots[i].bState === false) {

		                    if (bf.testBit(me.resourceFlags, <number>eFlag)) {
		                        me.setResourceFlag(eFlag, false);
		                    }

		                    return;
		                }
		            }

		            me.setResourceFlag(eFlag, true);
		        }
		    };

		    pSignSlots.push({bState : bState, fn : fn, pResourceItem : pResourceItem});

		    fn.call(pResourceItem, eSignal, pResourceItem.resourceFlags, bState);
		    pResourceItem.setChangesNotifyRoutine(fn);

		    return true;
		}

		unsync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool {
			eSlot = isDef(eSlot)? eSlot: eSignal;
		    eSlot = ResourcePoolItem.parseEvent(<number>eSlot);
		    eSignal = ResourcePoolItem.parseEvent(<number>eSignal);

		    var pSlots: ICallbackSlot[][] = this.pCallbackSlots, pSignSlots: ICallbackSlot[];
		    var me: IResourcePoolItem = this;
		    var isRem: bool = false;

		    pSignSlots = pSlots[eSlot];


		    for (var i:  number  = 0, n:  number  = pSignSlots.length; i < n; ++i) {
		        if (pSignSlots[i].pResourceItem === pResourceItem) {
		            pSignSlots[i].pResourceItem.delChangesNotifyRoutine(pSignSlots[i].fn);
		            pSignSlots.splice(i, 1);

		            --n;
		            --i;

		            isRem = true;
		        }
		    }

		    return isRem;
		}


		/**@inline*/  isResourceCreated(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.CREATED);
		}

		/**@inline*/  isResourceLoaded(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.LOADED);
		}

		/**@inline*/  isResourceDisabled(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.DISABLED);
		}

		/**@inline*/  isResourceAltered(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.ALTERED );
		}

		setAlteredFlag(isOn: bool = true): bool {
//notify always, when altered called
    		if (this.setResourceFlag(EResourceItemEvents.ALTERED, isOn) || isOn) {
    			isOn? this.altered(): this.saved();
    			return true;
    		}

    		return false;
		}

		/**@inline*/  setResourceName(sName: string) {
			if (this.pResourcePool != null) {
		        this.pResourcePool.setResourceName(this.iResourceHandle, sName);
		    }
		}

		findResourceName(): string {
			if (this.pResourcePool != null) {
		        return this.pResourcePool.findResourceName(this.iResourceHandle);
		    }

		    return null;
		}

		release():  number  {
			var iRefCount = super.release();

		    if (iRefCount == 0) {
//Если у нас есть менеджер попросим его удалить нас
		        if (this.pResourcePool != null) {
		            this.pResourcePool.destroyResource(this);
		        }
		    }

		    return iRefCount;
		}
		/**@inline*/  notifyCreated(): void {
			if (this.setResourceFlag(EResourceItemEvents.CREATED, true)) {
				this.created();
			}
		}

		/**@inline*/  notifyDestroyed(): void {
			if (this.setResourceFlag(EResourceItemEvents.CREATED, false)) {
				this.destroyed();
			}
		}

		/**@inline*/  notifyLoaded(): void {
			this.setAlteredFlag(false);
// LOG("ResourcePoolItem::notifyLoaded();");
    		if (this.setResourceFlag(EResourceItemEvents.LOADED, true)) {
// LOG("ResourcePoolItem::loaded();");
    			this.loaded();
    		}
		}

		/**@inline*/  notifyUnloaded(): void {
			if (this.setResourceFlag(EResourceItemEvents.LOADED, false)) {
				this.unloaded();
			}
		}

		/**@inline*/  notifyRestored(): void {
			if (this.setResourceFlag(EResourceItemEvents.DISABLED, false)) {
				this.restored();
			}
		}

		/**@inline*/  notifyDisabled(): void {
			if (this.setResourceFlag(EResourceItemEvents.DISABLED, true)) {
				this.disabled();
			}
		}

		/**@inline*/  notifyAltered(): void {
			this.setAlteredFlag(true);
		}

		/**@inline*/  notifySaved(): void {
			this.setAlteredFlag(false);
		}

/**
		 * Назначение кода ресурсу
		 * @inline
		 */

		setResourceCode(pCode: IResourceCode): void {
			this.pResourceCode.eq(pCode);
		}

/**
		 * Чтобы ресурс знал какому пулу ресурсов принадлжит
		 * @inline
		 */

		setResourcePool(pPool: IResourcePool): void {
			this.pResourcePool = pPool;
		}

/**
		 * Назначение хендла ресурсу
		 * @inline
		 */

		setResourceHandle(iHandle:  number ): void {
			this.iResourceHandle = iHandle;
		}

		notifyStateChange(eEvent: EResourceItemEvents, pTarget: IResourcePoolItem = null): void {
			if (!this.pStateWatcher[eEvent]) {
		        return;
		    }

		    var pSignSlots: ICallbackSlot[]  = this.pCallbackSlots[eEvent];
		    var nTotal:  number  = pSignSlots.length, nLoaded:  number  = 0;

		    for (var i:  number  = 0; i < nTotal; ++i) {
		        if (pSignSlots[i].bState) {
		            ++ nLoaded;
		        }
		    }

		    this.pStateWatcher[eEvent](nLoaded, nTotal, pTarget);
		}

		setResourceFlag(eFlagBit: EResourceItemEvents, isSetting: bool): bool;
		setResourceFlag(iFlagBit:  number , isSetting: bool): bool;
		setResourceFlag(iFlagBit, isSetting: bool): bool {
			var iTempFlags:  number  = this.iResourceFlags;

		    this.iResourceFlags = bf.setBit(this.iResourceFlags, iFlagBit, isSetting);
// LOG("before !=", iFlagBit, "(" + EResourceItemEvents.LOADED + ")", iTempFlags, "==>", this.iResourceFlags);

		    if (iTempFlags != this.iResourceFlags) {
// LOG("!+");
		        for (var i:  number  = 0; i < this.pCallbackFunctions.length; i++) {
		            if (this.pCallbackFunctions[i]) {
		                this.pCallbackFunctions[i].call(this, iFlagBit, this.iResourceFlags, isSetting);
		            }
		        }

		        return true;
		    }

		    return false;
		}

		static private parseEvent(sEvent: string): EResourceItemEvents;
		static private parseEvent(iEvent:  number ): EResourceItemEvents;
		static private parseEvent(pEvent) {
		 	if (isInt(pEvent)) {
		        return <EResourceItemEvents>pEvent;
		    }

		    switch (pEvent.toLowerCase()) {
		        case 'loaded':
		            return EResourceItemEvents.LOADED;
		        case 'created':
		            return EResourceItemEvents.CREATED;
		        case 'disabled':
		            return EResourceItemEvents.DISABLED;
		        case 'altered':
		            return EResourceItemEvents.ALTERED;
		        default:
		            { logger.setSourceLocation( "../ResourcePoolItem.ts" , 389 ); logger.error('Использовано неизвестное событие для ресурса.'); } ;
		            return 0;
		    }
		}


		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return ResourcePoolItem._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		created (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).created; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		destroyed (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).destroyed; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		loaded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).loaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		unloaded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).unloaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		restored (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).restored; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		disabled (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).disabled; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		altered (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).altered; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		saved (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).saved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
	}


	export  /**@inline*/  function isVideoResource(pItem: IResourcePoolItem): bool {
		return !isNull(pItem) && pItem.resourceCode.family === EResourceFamilies.VIDEO_RESOURCE;
	}

}







module akra.core.pool.resources {
	export class RenderMethod extends ResourcePoolItem implements IRenderMethod {
		protected _pEffect: IEffect = null;
		protected _pSurfaceMaterial: ISurfaceMaterial = null;

		protected _pPassInputList: IAFXPassInputBlend[] = null;
		protected _nTotalPasses:  number  = 0;

		/**@inline*/  get effect(): IEffect{
			return this._pEffect;
		}

		set effect(pEffect: IEffect) {
			if(!isNull(this._pEffect)){
				this.unsync(this._pEffect, EResourceItemEvents.LOADED);
				this.disconnect(this._pEffect,  "altered" ,  "updateEffect" , EEventTypes.BROADCAST);
				this._pEffect.release();
			}

			this._pEffect = pEffect;

			if(!isNull(pEffect)){
				this.sync(this._pEffect, EResourceItemEvents.LOADED);
				this.connect(this._pEffect,  "altered" ,  "updateEffect" , EEventTypes.BROADCAST);
				this._pEffect.addRef();
			}

			this.updateEffect(pEffect);
		}

		/**@inline*/  get surfaceMaterial(): ISurfaceMaterial {
			return this._pSurfaceMaterial;
		}

		/**@inline*/  set surfaceMaterial(pMaterial: ISurfaceMaterial) {
			if(!isNull(this._pSurfaceMaterial)){
				this.unsync(this._pSurfaceMaterial, EResourceItemEvents.LOADED);
				this.disconnect(this._pSurfaceMaterial,  "altered" ,  "notifyAltered" , EEventTypes.BROADCAST);
				this._pSurfaceMaterial.release();
			}

			this._pSurfaceMaterial = pMaterial;

			if(!isNull(pMaterial)){
				this.sync(this._pSurfaceMaterial, EResourceItemEvents.LOADED);
				this.connect(this._pSurfaceMaterial,  "altered" ,  "notifyAltered" , EEventTypes.BROADCAST);
			}

			this._pSurfaceMaterial.addRef();

			this.notifyAltered();
		}

		/**@inline*/  get material(): IMaterial {
			return this.surfaceMaterial.material;
		}

		isEqual(pRenderMethod: IRenderMethod): bool {return false;}

		setForeign(sName: string, pValue: any, iPass?:  number  =  0xffffff ): void {
			if(iPass ===  0xffffff ){
				for(var i:  number  = 0; i < this._nTotalPasses; i++){
					this.setForeign(sName, pValue, i);
				}

				return;
			}

			if(iPass < 0 || iPass >= this._nTotalPasses){
				{ logger.setSourceLocation( "resources/RenderMethod.ts" , 78 ); logger.error("RenderMethod::setForeign : wrong number of pass (" + iPass + ")"); } ;
				return;
			}

			this._pPassInputList[iPass].setForeign(sName, pValue);
		}

		setUniform(sName: string, pValue: any, iPass?:  number  =  0xffffff ): void {
			if(iPass ===  0xffffff ){
				for(var i:  number  = 0; i < this._nTotalPasses; i++){
					this.setUniform(sName, pValue, i);
				}

				return;
			}

			if(iPass < 0 || iPass >= this._nTotalPasses){
				{ logger.setSourceLocation( "resources/RenderMethod.ts" , 95 ); logger.error("RenderMethod::setUniform : wrong number of pass (" + iPass + ")"); } ;
				return;
			}

			this._pPassInputList[iPass].setUniform(sName, pValue);
		}

		setTexture(sName: string, pValue: ITexture, iPass?:  number  =  0xffffff ): void {
			if(iPass ===  0xffffff ){
				for(var i:  number  = 0; i < this._nTotalPasses; i++){
					this.setTexture(sName, pValue, i);
				}

				return;
			}

			if(iPass < 0 || iPass >= this._nTotalPasses){
				{ logger.setSourceLocation( "resources/RenderMethod.ts" , 112 ); logger.error("RenderMethod::setTexture : wrong number of pass (" + iPass + ")"); } ;
				return;
			}

			this._pPassInputList[iPass].setTexture(sName, pValue);
		}

		setRenderState(eState: ERenderStates, eValue: ERenderStateValues, iPass?:  number  =  0xffffff ): void {
			if(iPass ===  0xffffff ){
				for(var i:  number  = 0; i < this._nTotalPasses; i++){
					this.setRenderState(eState, eValue, i);
				}

				return;
			}

			if(iPass < 0 || iPass >= this._nTotalPasses){
				{ logger.setSourceLocation( "resources/RenderMethod.ts" , 129 ); logger.error("RenderMethod::setRenderState : wrong number of pass (" + iPass + ")"); } ;
				return;
			}

			this._pPassInputList[iPass].setRenderState(eState, eValue);
		}

		setSamplerTexture(sName: string, sTexture: string, iPass?:  number ): void;
		setSamplerTexture(sName: string, pTexture: ITexture, iPass?:  number ): void;
		setSamplerTexture(sName: string, pTexture: any, iPass?:  number  =  0xffffff ): void {
			if(iPass ===  0xffffff ){
				for(var i:  number  = 0; i < this._nTotalPasses; i++){
					this.setSamplerTexture(sName, pTexture, i);
				}

				return;
			}

			if(iPass < 0 || iPass >= this._nTotalPasses){
				{ logger.setSourceLocation( "resources/RenderMethod.ts" , 148 ); logger.error("RenderMethod::setSamplerTexture : wrong number of pass (" + iPass + ")"); } ;
				return;
			}

			this._pPassInputList[iPass].setSamplerTexture(sName, pTexture);
		}

		_getPassInput(iPass:  number ): IAFXPassInputBlend {
			return this._pPassInputList[iPass];
		}

		protected updateEffect(pEffect: IEffect): void {
			if(isNull(pEffect)){
				for(var i:  number  = 0; i < this._nTotalPasses; i++){
					var pOldInput: IAFXPassInputBlend = this._pPassInputList[i];

					if(isDefAndNotNull(pOldInput)){
						pOldInput._release();
						this._pPassInputList[i] = null;
					}
				}

				this._nTotalPasses = 0;
				this.notifyAltered();
				return;
			}

			var pComposer: IAFXComposer = this.manager.getEngine().getComposer();
			var iTotalPasses:  number  = pEffect.totalPasses;

			if(isNull(this._pPassInputList)){
				this._pPassInputList = new Array(iTotalPasses);
				this._nTotalPasses = 0;
			}

			for(var i:  number  = 0; i < iTotalPasses; i++){
				var pNewInput: IAFXPassInputBlend = pComposer.getPassInputBlendForEffect(pEffect, i);
				var pOldInput: IAFXPassInputBlend = this._pPassInputList[i];

				if(isDefAndNotNull(pOldInput) && isDefAndNotNull(pNewInput)){
					if(pNewInput._isFromSameBlend(pOldInput)){
						return;
					}

					pNewInput._copyFrom(pOldInput);
					pOldInput._release();
				}

				this._pPassInputList[i] = pNewInput;
			}

			if(this._nTotalPasses > iTotalPasses){
				for(var i:  number  = iTotalPasses; i < this._nTotalPasses; i++){
					var pOldInput: IAFXPassInputBlend = this._pPassInputList[i];

					if(isDefAndNotNull(pOldInput)){
						pOldInput._release();
						this._pPassInputList[i] = null;
					}
				}
			}

			this._nTotalPasses = iTotalPasses;

			this.notifyAltered();
		}
	}


}



















module akra {
	;

	export interface IMaterialBase {
		diffuse: IColorValue;
		ambient: IColorValue;
		specular: IColorValue;
		emissive: IColorValue;
		shininess:  number ;
	}

	export interface IMaterial extends IMaterialBase {
		name: string;

		set(pMat: IMaterialBase): IMaterial;
		isEqual(pMat: IMaterialBase): bool;
	}

	export interface IFlexMaterial extends IMaterial {
		data: IVertexData;
	}

// export interface IMaterialEx extends IMaterial {
// 	reflective: 
// 	reflectivity
// 	transparent
// 	transparency
// 	indexofrefraction
// }
}












module akra {

	;

	export  /**@const*/var  DeclarationUsages = {
		POSITION 	: "POSITION",
	    POSITION1	: "POSITION1",
	    POSITION2	: "POSITION2",
	    POSITION3	: "POSITION3",

	    BLENDWEIGHT	: "BLENDWEIGHT",
	    BLENDINDICES: "BLENDINDICES",
	    BLENDMETA	: "BLENDMETA",

	    NORMAL 		: "NORMAL",
	    NORMAL1		: "NORMAL1",
	    NORMAL2		: "NORMAL2",
	    NORMAL3		: "NORMAL3",

	    PSIZE		: "PSIZE",

	    TEXCOORD 	: "TEXCOORD",
	    TEXCOORD1	: "TEXCOORD1",
	    TEXCOORD2	: "TEXCOORD2",
	    TEXCOORD3	: "TEXCOORD3",
	    TEXCOORD4	: "TEXCOORD4",
	    TEXCOORD5	: "TEXCOORD5",

	    TANGENT		: "TANGENT",
	    BINORMAL 	: "BINORMAL",

	    TESSFACTOR	: "TESSFACTOR",
	    COLOR 		: "COLOR",
	    FOG 		: "FOG",
	    DEPTH 		: "DEPTH",
	    SAMPLE 		: "SAMPLE",

	    INDEX 		: "INDEX",
		INDEX0 		: "INDEX0",
	    INDEX1 		: "INDEX1",
	    INDEX2 		: "INDEX2",
	    INDEX3 		: "INDEX3",
//system indices starts from 10
	    INDEX10 	: "INDEX10",
	    INDEX11 	: "INDEX11",
	    INDEX12 	: "INDEX12",
	    INDEX13 	: "INDEX13",

	    MATERIAL 	: "MATERIAL",
	    MATERIAL1 	: "MATERIAL1",
	    MATERIAL2 	: "MATERIAL2",

	    DIFFUSE		: "DIFFUSE",
	    AMBIENT 	: "AMBIENT",
	    SPECULAR 	: "SPECULAR",
	    EMISSIVE 	: "EMISSIVE",
	    SHININESS 	: "SHININESS",

//special semantic for video buffer
	    TEXTURE_HEADER : "TEXTURE_HEADER",

	    UNKNOWN 	: "UNKNOWN",
	    END 		: "\a\n\r"
	};

	export  /**@const*/var  DeclUsages = DeclarationUsages;

	export interface IVertexDeclaration {
		stride:  number ;
		 length:  number ;


//[index: number]: IVertexElement;

		append(...pElement: IVertexElementInterface[]): bool;
		append(pElements: IVertexElementInterface[]): bool;

		extend(pDecl: IVertexDeclaration): bool;

		hasSemantics(sSemantics: string): bool;
		findElement(sSemantics: string, iCount?:  number ): IVertexElement;
		clone(): IVertexDeclaration;

		element(i:  number ): IVertexElement;

		_update(): bool;

///DEBUG!!!
		toString(): string;
	}



	export  /**@inline*/  function VE_CUSTOM(sUsage: string, eType: EDataTypes = EDataTypes.FLOAT, iCount:  number  = 1, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface {
		return {count: iCount, type: eType, usage: sUsage, offset: iOffset};
	}

	export  /**@inline*/  function VE_FLOAT(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 1, iOffset); };
	export  /**@inline*/  function VE_FLOAT2(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 2, iOffset); };
	export  /**@inline*/  function VE_FLOAT3(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 3, iOffset); };
	export  /**@inline*/  function VE_FLOAT4(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 4, iOffset); };
	export  /**@inline*/  function VE_FLOAT4x4(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 16, iOffset); };
	export  /**@inline*/  function VE_VEC2(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 2, iOffset); };
	export  /**@inline*/  function VE_VEC3(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 3, iOffset); };
	export  /**@inline*/  function VE_VEC4(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 4, iOffset); };
	export  /**@inline*/  function VE_MAT4(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 16, iOffset); };
	export  /**@inline*/  function VE_INT(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.INT, 1, iOffset);};

	export  /**@inline*/  function VE_END(iOffset:  number  = 0): IVertexElementInterface { return VE_CUSTOM(DeclUsages.END, EDataTypes.UNSIGNED_BYTE, 0, iOffset); };

//export var createVertexDeclaration: (pData?) => IVertexDeclaration;
}












module akra {
	export interface IVertexElementInterface {
/**
		 * Number of uint.
		 */

		count:  number ;
/**
		 * Type of units. 
		 */

		type: EDataTypes;
/**
		 * Usage of element.
		 * For ex., basicly for vertices is 'POSITION'.
		 */

		usage: string;
/**
		 * Offset in bytes.
		 */

		offset?:  number ;
	}

	export interface IVertexElement extends IVertexElementInterface {
/**
		 * Size in bytes.
		 */

		size:  number ;
/**
		 * numerical index of declaration. 
		 * For ex. for usage INDEX10, index is 10, semantics is 'INDEX'.
		 */

		index:  number ;
/**
		 * Semantics of declaration.
		 * @see DelcarationUsages.
		 */

		semantics: string;

		clone(): IVertexElement;

		isEnd(): bool;

//DEBUG!!
		toString(): string;
	}
}




module akra.data {
	export class VertexElement implements IVertexElement {
		count:  number ;
		type: EDataTypes;
		usage: string;
		offset:  number ;

// this properties is readonly for public usage.
		size:  number  = 0;
		index:  number  = 0;
		semantics: string = DeclarationUsages.UNKNOWN;

		constructor (
			nCount:  number  = 1,
			eType: EDataTypes = EDataTypes.FLOAT,
			eUsage: string = DeclarationUsages.POSITION,
//mark invalid offset, for determine true offset in VertexDeclaration::_update();
			iOffset:  number  =  MAX_INT32 ) {

			this.count = nCount;
			this.type = eType;
			this.usage = eUsage;
			this.offset = iOffset;

			this.update();
		}

		private update(): void {
			this.size = this.count * getTypeSize(this.type);
		    this.index = 0;
		    this.semantics = null;

		    var pMatches: string[] = this.usage.match(/^(.*?\w)(\d+)$/i);

		    if (!isNull(pMatches)) {
		        this.semantics = pMatches[1];
		        this.index = parseInt(pMatches[2]);

// To avoid the colosseum between the "usage" of the element as POSITION & POSITION0, 
// given that this is the same thing, here are the elements with index 0 
// for "usage" with the POSITION.
// if (this.index === 0) {
// 	this.usage = this.semantics;
// }
		    }
		    else {
		        this.semantics = this.usage;
		    }
		};

		clone(): IVertexElement {
			return new VertexElement(this.count, this.type, this.usage, this.offset);
		};

		/**@inline*/  static hasUnknownOffset(pElement: IVertexElementInterface): bool {
			return (!isDef(pElement.offset) || (pElement.offset ===  MAX_INT32 ));
		};

		/**@inline*/  isEnd(): bool {
			return this.semantics === DeclUsages.END;
		}

		toString(): string {

			function _an(data: any, n:  number , bBackward: bool = false): string {
		        var s: string = String(data);

		        for (var i = 0, t = n - s.length; i < t; ++ i) {
		            if (bBackward) {
		                s = " " + s;
		            }
		            else {
		                s += " ";
		            }
		        }
		        return s;
		    }

		    var s = "[ USAGE: " + _an(this.usage == DeclUsages.END? "<END>": this.usage, 12) + ", OFFSET " + _an(this.offset, 4)
		    				+ ", SIZE " + _an(this.size, 4) +" ]";

		    return s;

		}
	}
}

module akra {
	export var VertexElement = data.VertexElement;
}



module akra.data {

	export class VertexDeclaration implements IVertexDeclaration {
//readonly property for public usage
		stride:  number  = 0;

		private _pElements: IVertexElement[] = [];

		/**@inline*/  get length():  number  {
			return this._pElements.length;
		}

//FIXME: typescript error "Overload signature is not compatible with function definition" ???
//constructor (...pElement: IVertexElement[]) 
		constructor (...pElements: IVertexElementInterface[]);
		constructor (pElements: IVertexElementInterface[]);
		constructor (pElements: any) {
			if (arguments.length > 0 && isDefAndNotNull(pElements)) {
				this.append.apply(this, arguments);
			}
		}

		/**@inline*/  element(i:  number ): IVertexElement {
			return this._pElements[i] || null;
		}

		append(...pElement: IVertexElementInterface[]): bool;
		append(pElements: IVertexElementInterface[]): bool;
		append(pData: any) {
			var pElements: IVertexElementInterface[];

			if (!isArray(arguments[0])) {
				pElements = <IVertexElementInterface[]><any>arguments;
			}
			else {
				pElements = <IVertexElementInterface[]><any>arguments[0];
			}

			for (var i:  number  = 0; i < pElements.length; i++) {
				var pElement: IVertexElementInterface = pElements[i];
				var iOffset:  number ;

				if (VertexElement.hasUnknownOffset(pElement)) {
//add element to end
					iOffset = this.stride;
				}
				else{
					iOffset = pElement.offset;
				}

				var pVertexElement: IVertexElement = new VertexElement(
															pElement.count,
												            pElement.type,
												            pElement.usage,
												            iOffset);

				this._pElements.push(pVertexElement);

				var iStride:  number  = iOffset + pVertexElement.size;

				if(this.stride < iStride){
					this.stride = iStride;
				}
			}

			return this._update();
		}

		_update(): bool {
			var iStride:  number ;

			for (var i:  number  = 0; i < this.length; ++ i) {
//move "END" element to end of declaration
				if (this._pElements[i].usage === DeclUsages.END) {
		            this._pElements.swap(i, i + 1);
		        }

//recalc total stride
		        iStride = this._pElements[i].size + this._pElements[i].offset;

		        if (this.stride < iStride) {
		            this.stride = iStride
		        }
			}

			var pLast: IVertexElement = this._pElements.last;

		    if (pLast.usage === DeclUsages.END && pLast.offset < this.stride) {
		        pLast.offset = this.stride;
		    }

		    return true;
		}



		extend(decl: IVertexDeclaration): bool {
			var pDecl: VertexDeclaration = <VertexDeclaration>decl;
			var pElement: IVertexElement;

		    for (var i = 0; i < this.length; ++ i) {
		        for (var j = 0; j < pDecl.length; ++ j) {
		            if (pDecl.element(j).usage == this._pElements[i].usage) {
		                { logger.setSourceLocation( "data/VertexDeclaration.ts" , 110 ); logger.log('inconsistent declarations:', this, pDecl); } ;
		                { logger.setSourceLocation( "data/VertexDeclaration.ts" , 111 ); logger.error('The attempt to combine the declaration containing the exact same semantics.'); } ;
		                return false;
		            }
		        }
		    }

		    for (var i = 0; i < pDecl.length; i++) {
		        pElement = pDecl.element(i).clone();
		        pElement.offset += this.stride;
		        this._pElements.push(pElement);
		    }

		    return this._update();
		}

		/**@inline*/  hasSemantics(sSemantics: string): bool {
			return this.findElement(sSemantics) !== null;
		}

		findElement(sSemantics: string, iCount:  number  = MAX_INT32): IVertexElement {
			sSemantics = sSemantics.toUpperCase();

			for (var i = 0; i < this.length; ++i) {
				if (this._pElements[i].usage === sSemantics && (iCount === MAX_INT32 || this._pElements[i].count == iCount)) {
					return this._pElements[i];
				}
			}

			return null;
		}

		clone(): IVertexDeclaration {
			var pElements: IVertexElement[] = [];
			var pDecl: VertexDeclaration;

		    for (var i = 0; i < this.length; ++ i) {
		        pElements.push(this._pElements[i].clone());
		    }

		    pDecl = new VertexDeclaration(pElements);

		    if (pDecl._update()) {
		    	return pDecl;
		    }

		    return null;
		}

///DEBUG!!!
		toString(): string {

			var s = "\n";

	    	s += "  VERTEX DECLARATION ( " + this.stride +" b. ) \n";
		    s += "---------------------------------------\n";

		    for (var i = 0; i < this.length; ++ i) {
		        s += this._pElements[i].toString() + '\n';
		    }

		    return s;

		}
	}
}

module akra {
	export var VertexDeclaration = data.VertexDeclaration;

	export var createVertexDeclaration = function (pData?): data.VertexDeclaration {
		if (!(pData instanceof VertexDeclaration)) {
	        if (!(pData instanceof Array) && isDefAndNotNull(pData)) {
	            pData = [pData];
	        }

	        pData = new VertexDeclaration(pData);
	    }

	    return pData;
	}

}






// #define color(...) Color.stackCeil.set(__VA_ARGS__)









module akra {

	export interface IColorIValue {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;
	}

	export interface IColorValue {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;
	}
}



module akra {

	export interface IColor extends IColorValue {
		rgba:  number ;
		argb:  number ;
		bgra:  number ;
		abgr:  number ;

		 html: string;
		 htmlRgba: string;

		set(cColor: IColorValue): IColor;
		set(cColor: IColor): IColor;
		set(r?:  number , g?:  number , b?:  number , a?:  number ): IColor;
		set(fGray:  number , fAlpha:  number ): IColor;

/** Clamps colour value to the range [0, 1].
         */

        saturate(): void;

/** As saturate, except that this colour value is unaffected and
		    the saturated colour value is returned as a copy. */

		saturateCopy(): IColor;

		add(cColor: IColor, ppDest?: IColor): IColor;
		subtract(cColor: IColor, ppDest?: IColor): IColor;
		multiply(cColor: IColor, ppDest?: IColor): IColor;
		multiply(fScalar:  number , ppDest?: IColor): IColor;
		divide(cColor: IColor, ppDest?: IColor): IColor;
		divide(fScalar:  number , ppDest?: IColor): IColor;

/** Set a colour value from Hue, Saturation and Brightness.
			@param hue Hue value, scaled to the [0,1] range as opposed to the 0-360
			@param saturation Saturation level, [0,1]
			@param brightness Brightness level, [0,1]
		*/

		setHSB(fHue:  number , fSaturation:  number , fBrightness:  number ): IColor;

/** Convert the current colour to Hue, Saturation and Brightness values. 
			@param hue Output hue value, scaled to the [0,1] range as opposed to the 0-360
			@param saturation Output saturation level, [0,1]
			@param brightness Output brightness level, [0,1]
		*/


		getHSB(pHsb?:  number []):  number [];

		toString(): string;
	}
}











module akra {
	export var __11:  number  = 0;
	export var __12:  number  = 4;
	export var __13:  number  = 8;
	export var __14:  number  = 12;
	export var __21:  number  = 1;
	export var __22:  number  = 5;
	export var __23:  number  = 9;
	export var __24:  number  = 13;
	export var __31:  number  = 2;
	export var __32:  number  = 6;
	export var __33:  number  = 10;
	export var __34:  number  = 14;
	export var __41:  number  = 3;
	export var __42:  number  = 7;
	export var __43:  number  = 11;
	export var __44:  number  = 15;
}

module akra.math {
//
// BASIC MATH AND UNIT CONVERSION CONSTANTS
//

	export var E:  number  								= < number >Math.E;
	export var LN2:  number  								= < number >Math.LN2;
	export var LOG2E:  number  							= < number >Math.LOG2E;
	export var LOG10E:  number  							= < number >Math.LOG10E;
	export var PI:  number  								= < number >Math.PI;
	export var SQRT1_2:  number  							= < number >Math.SQRT1_2;
	export var SQRT2:  number  							= < number >Math.SQRT2;
	export var LN10:  number  								= < number >Math.LN10;

	export var POSITIVE_INFINITY:  number                  = < number >Number.POSITIVE_INFINITY;
	export var NEGATIVE_INFINITY:  number                  = < number >Number.NEGATIVE_INFINITY;


	export var FLOAT_PRECISION:  number 					= < number >(3.4e-8);
	export var TWO_PI:  number 							= < number >(2.0*PI);
	export var HALF_PI:  number 							= < number >(PI/2.0);
	export var QUARTER_PI:  number 						= < number >(PI/4.0);
	export var EIGHTH_PI:  number 							= < number >(PI/8.0);
	export var PI_SQUARED:  number 						= < number >(9.86960440108935861883449099987615113531369940724079);
	export var PI_INVERSE:  number 						= < number >(0.31830988618379067153776752674502872406891929148091);
	export var PI_OVER_180:  number 						= < number >(PI/180);
	export var PI_DIV_180:  number 						= < number >(180/PI);
	export var NATURAL_LOGARITHM_BASE:  number 			= < number >(2.71828182845904523536028747135266249775724709369996);
	export var EULERS_CONSTANT:  number 					= < number >(0.57721566490153286060651);
	export var SQUARE_ROOT_2:  number 						= < number >(1.41421356237309504880168872420969807856967187537695);
	export var INVERSE_ROOT_2:  number 					= < number >(0.707106781186547524400844362105198);
	export var SQUARE_ROOT_3:  number 						= < number >(1.73205080756887729352744634150587236694280525381038);
	export var SQUARE_ROOT_5:  number 						= < number >(2.23606797749978969640917366873127623544061835961153);
	export var SQUARE_ROOT_10:  number 					= < number >(3.16227766016837933199889354443271853371955513932522);
	export var CUBE_ROOT_2:  number 						= < number >(1.25992104989487316476721060727822835057025146470151);
	export var CUBE_ROOT_3:  number 						= < number >(1.44224957030740838232163831078010958839186925349935);
	export var FOURTH_ROOT_2:  number 						= < number >(1.18920711500272106671749997056047591529297209246382);
	export var NATURAL_LOG_2:  number 						= < number >(0.69314718055994530941723212145817656807550013436026);
	export var NATURAL_LOG_3:  number 						= < number >(1.09861228866810969139524523692252570464749055782275);
	export var NATURAL_LOG_10:  number 					= < number >(2.30258509299404568401799145468436420760110148862877);
	export var NATURAL_LOG_PI:  number 					= < number >(1.14472988584940017414342735135305871164729481291531);
	export var BASE_TEN_LOG_PI:  number 					= < number >(0.49714987269413385435126828829089887365167832438044);
	export var NATURAL_LOGARITHM_BASE_INVERSE:  number 	= < number >(0.36787944117144232159552377016146086744581113103177);
	export var NATURAL_LOGARITHM_BASE_SQUARED:  number 	= < number >(7.38905609893065022723042746057500781318031557055185);
	export var GOLDEN_RATIO:  number 						= < number >((SQUARE_ROOT_5 + 1.0) / 2.0);
	export var DEGREE_RATIO:  number 						= < number >(PI_DIV_180);
	export var RADIAN_RATIO:  number 						= < number >(PI_OVER_180);
	export var GRAVITY_CONSTANT:  number  					= 9.81;
}


















module akra {

	export interface IVec2Constructor {
        ();
        (fValue:  number );
        (v2fVec: IVec2);
        (pArray:  number []);
        (fValue1:  number , fValue2:  number );
    }


	export interface IVec2 {
		x:  number ;
		y:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;

		set(): IVec2;
		set(fValue:  number ): IVec2;
		set(v2fVec: IVec2): IVec2;
		set(pArray:  number []): IVec2;
		set(fValue1:  number , fValue2:  number ): IVec2;

		clear(): IVec2;

		add(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;
		subtract(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;
		dot(v2fVec: IVec2):  number ;

		isEqual(v2fVec: IVec2, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v2fDestination?: IVec2): IVec2;
		scale(fScale:  number , v2fDestination?: IVec2): IVec2;
		normalize(v2fDestination?: IVec2): IVec2;
		length():  number ;
		lengthSquare():  number ;


		direction(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;

		mix(v2fVec: IVec2, fA:  number , v2fDestination?: IVec2): IVec2;

		toString(): string;
	};
};



module akra.math {

    export class Vec2 implements IVec2{
        x:  number  = 0.;
        y:  number  = 0.;



get xx(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.x) ;
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.y) ;
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get yx(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.x) ;
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.y) ;
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

        constructor();
        constructor(fValue:  number );
        constructor(v2fVec: IVec2);
        constructor(pArray:  number []);
        constructor(fValue1:  number , fValue2:  number );
        constructor(fValue1?, fValue2?){
            var nArgumentsLength:  number  = arguments.length;

            var v2fVec: IVec2 = this;

// if (<any>this === window || <any>this === akra || <any>this === akra.math) {
//     v2fVec = Vec2.stack[Vec2.stackPosition ++];

//     if(Vec2.stackPosition == Vec2.stackSize){
//         Vec2.stackPosition = 0;
//     }
// }

            switch(nArgumentsLength){
                case 1:
                    v2fVec.set(arguments[0]);
                    break;
                case 2:
                    v2fVec.set(arguments[0], arguments[1]);
                    break;
                default:
                    v2fVec.x = v2fVec.y = 0.;
                    break;
            }

        };

        set(): IVec2;
        set(fValue:  number ): IVec2;
        set(v2fVec: IVec2): IVec2;
        set(pArray:  number []): IVec2;
        set(fValue1:  number , fValue2:  number ): IVec2;
        set(fValue1?, fValue2?): IVec2{
            var nArgumentsLength:  number  = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec2){
                        var v2fVec: IVec2 = arguments[0];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                    }
                    else{
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                    }
                    break;
                case 2:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    break;
            };

            return this;
        };

        /**@inline*/  clear(): IVec2{
            this.x = this.y = 0.;
            return this;
        };

        add(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x + v2fVec.x;
            v2fDestination.y = this.y + v2fVec.y;

            return v2fDestination;
        };

        subtract(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x - v2fVec.x;
            v2fDestination.y = this.y - v2fVec.y;

            return v2fDestination;
        };

        /**@inline*/  dot(v2fVec: IVec2):  number {
            return this.x*v2fVec.x + this.y*v2fVec.y;
        };

        isEqual(v2fVec: IVec2, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v2fVec.x
                    || this.y != v2fVec.y){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v2fVec.x) > fEps
                    || abs(this.y - v2fVec.y) > fEps){

                    return false;
                }
            }

            return true;
        };

        isClear(fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.){

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps){

                    return false;
                }
            }

            return true;
        };

        negate(v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = -this.x;
            v2fDestination.y = -this.y;

            return v2fDestination;
        };

        scale(fScale:  number , v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x*fScale;
            v2fDestination.y = this.y*fScale;

            return v2fDestination;
        };

        normalize(v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y;
            var fLength:  number  = sqrt(x*x + y*y);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
            }

            v2fDestination.x = x;
            v2fDestination.y = y;

            return v2fDestination;
        };

        /**@inline*/  length():  number {
            var x:  number  = this.x, y:  number  = this.y;
            return sqrt(x*x + y*y);
        };

        /**@inline*/  lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y;
            return x*x + y*y;
        };

        direction(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            var x:  number  = v2fVec.x - this.x;
            var y:  number  = v2fVec.y - this.y;

            var fLength:  number  = sqrt(x*x + y*y);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
            }

            v2fDestination.x = x;
            v2fDestination.y = y;

            return v2fDestination;
        };

        mix(v2fVec: IVec2, fA:  number , v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v2fDestination.x = fA1*this.x + fA2*v2fVec.x;
            v2fDestination.y = fA1*this.y + fA2*v2fVec.y;

            return v2fDestination;
        };

        /**@inline*/  toString(): string{
            return "[x: " + this.x + ", y: " + this.y + "]";
        };

        static get stackCeil(): Vec2 { Vec2.stackPosition = Vec2.stackPosition === Vec2.stackSize - 1? 0: Vec2.stackPosition; return Vec2.stack[Vec2.stackPosition ++]; } static stackSize: number = 256 ; static stackPosition: number = 0; static stack: Vec2[] = (function(): Vec2[]{ var pStack: Vec2[] = new Array(Vec2.stackSize); for(var i: number = 0; i<Vec2.stackSize; i++){ pStack[i] = new Vec2(); } return pStack})();
   }
}












module akra {

	;
	;

	export interface IVec3Constructor {
        ();
        (fValue:  number );
        (v3fVec: IVec3);
        (pArray:  number []);
        (fValue:  number , v2fVec: IVec2);
        (v2fVec: IVec2, fValue:  number );
        (fValue1:  number , fValue2:  number , fValue3:  number );
    }


	export interface IVec3 {
		x:  number ;
		y:  number ;
		z:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

xz: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;
/*represents two-component vector from original vector*/

yz: IVec2;
/*represents two-component vector from original vector*/

zx: IVec2;
/*represents two-component vector from original vector*/

zy: IVec2;
/*represents two-component vector from original vector*/

zz: IVec2;

/*represents three-component vector from original vector*/

xxx: IVec3;
/*represents three-component vector from original vector*/

xxy: IVec3;
/*represents three-component vector from original vector*/

xxz: IVec3;
/*represents three-component vector from original vector*/

xyx: IVec3;
/*represents three-component vector from original vector*/

xyy: IVec3;
/*represents three-component vector from original vector*/

xyz: IVec3;
/*represents three-component vector from original vector*/

xzx: IVec3;
/*represents three-component vector from original vector*/

xzy: IVec3;
/*represents three-component vector from original vector*/

xzz: IVec3;
/*represents three-component vector from original vector*/

yxx: IVec3;
/*represents three-component vector from original vector*/

yxy: IVec3;
/*represents three-component vector from original vector*/

yxz: IVec3;
/*represents three-component vector from original vector*/

yyx: IVec3;
/*represents three-component vector from original vector*/

yyy: IVec3;
/*represents three-component vector from original vector*/

yyz: IVec3;
/*represents three-component vector from original vector*/

yzx: IVec3;
/*represents three-component vector from original vector*/

yzy: IVec3;
/*represents three-component vector from original vector*/

yzz: IVec3;
/*represents three-component vector from original vector*/

zxx: IVec3;
/*represents three-component vector from original vector*/

zxy: IVec3;
/*represents three-component vector from original vector*/

zxz: IVec3;
/*represents three-component vector from original vector*/

zyx: IVec3;
/*represents three-component vector from original vector*/

zyy: IVec3;
/*represents three-component vector from original vector*/

zyz: IVec3;
/*represents three-component vector from original vector*/

zzx: IVec3;
/*represents three-component vector from original vector*/

zzy: IVec3;
/*represents three-component vector from original vector*/

zzz: IVec3;

		set(): IVec3;
		set(fValue:  number ): IVec3;
		set(v3fVec: IVec3): IVec3;
		set(pArray:  number []): IVec3;
		set(fValue:  number , v2fVec: IVec2): IVec3;
		set(v2fVec: IVec2, fValue:  number ): IVec3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IVec3;

		clear(): IVec3;

		add(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;
		subtract(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;
		dot(v3fVec: IVec3):  number ;
		cross(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		isEqual(v3fVec: IVec3, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v3fDestination?: IVec3): IVec3;
		scale(fScale:  number , v3fDestination?: IVec3): IVec3;
		scale(v3fScale: IVec3, v3fDestination?: IVec3): IVec3;
		normalize(v3fDestination?: IVec3): IVec3;
		length():  number ;
		lengthSquare():  number ;

		direction(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		mix(v3fVec: IVec3, fA:  number , v3fDestination?: IVec3): IVec3;

		toString(): string;
		toArray():  number [];
		toTranslationMatrix(m4fDestination?: IMat4);

		vec3TransformCoord(m4fTransformation: IMat4, v3fDestination?: IVec3): IVec3;
	};
};






/**
 * @important Если внезапно задумаем перейти обратно на 
 * хранение данных в матрицах по строкам, как собственно и было в начале,
 * то необходимо раскомментить definы и переписать метод set, 
 * так как он ложит по столбцам
 */


// #define __11 0
// #define __12 1
// #define __13 2
// #define __14 3
// #define __21 4
// #define __22 5
// #define __23 6
// #define __24 7
// #define __31 8
// #define __32 9
// #define __33 10
// #define __34 11
// #define __41 12
// #define __42 13
// #define __43 14
// #define __44 15


















module akra {

	;
	;
	;
	;


	export interface IMat4Constructor {
		();
		(fValue:  number );
		(v4fVec: IVec4);
		(m4fMat: IMat4);
		(pArray:  number []);
		(m3fMat: IMat3, v3fTranslation?: IVec3);
		(pArray: Float32Array, bFlag: bool);
		(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
		(v4fVec1: IVec4, v4fVec2: IVec4, v4fVec3: IVec4, v4fVec4: IVec4);
		(pArray1:  number [], pArray2:  number [], pArray3:  number [], pArray4:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
				fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
				fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
				fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number );
	}

	export interface IMat4 {
		data: Float32Array;

		set(): IMat4;
		set(fValue:  number ): IMat4;
		set(v4fVec: IVec4): IMat4;
		set(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
		set(m4fMat: IMat4): IMat4;
		set(pArray:  number []): IMat4;
		set(fValue1:  number , fValue2:  number ,
			fValue3:  number , fValue4:  number ): IMat4;
		set(v4fVec1: IVec4, v4fVec2: IVec4,
			v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
		set(pArray1:  number [], pArray2:  number [],
			pArray3:  number [], pArray4:  number []): IMat4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
			fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
			fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
			fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number ): IMat4;

		identity(): IMat4;

		add(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		subtract(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiply(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiplyLeft(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiplyVec4(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;

		transpose(m4fDestination?: IMat4): IMat4;
		determinant():  number ;
		inverse(m4fDestination?: IMat4): IMat4;
		trace():  number ;

		isEqual(m4fMat: IMat4, fEps?:  number ): bool;
		isDiagonal(fEps?:  number ): bool;

		toMat3(m3fDestination?: IMat3): IMat3;
		toQuat4(q4fDestination?: IQuat4): IQuat4;
		toRotationMatrix(m4fDestination?: IMat4): IMat4;
		toString(): string;
		toArray(pDest?:  number []):  number [];

		rotateRight(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4;
		rotateLeft(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4;

//rotateXRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateXLeft(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateYRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateYLeft(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateZRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateZLeft(fAngle: float, m4fDestination?: IMat4): IMat4;

		setTranslation(v3fTranslation: IVec3): IMat4;
		getTranslation(v3fTranslation?: IVec3): IVec3;

		translateRight(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4;
		translateLeft(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4;

		scaleRight(v3fScale: IVec3, m4fDestination?: IMat4): IMat4;
		scaleLeft(v3fScale: IVec3, m4fDestination?: IMat4): IMat4;

		decompose(q4fRotation: IQuat4, v3fScale: IVec3, v3fTranslation: IVec3): bool;

		row(iRow:  number , v4fDestination?: IVec4): IVec4;
		column(iColumn:  number , v4fDestination?: IVec4): IVec4;

/*v3fScreen - coordinates in screen space from -1 to 1
		* returns vec4(wsCoord,1.), where wsCoord - coordinates in world space
		* use with projection matrix only
		*/

		unproj(v3fScreen: IVec3, v4fDestination?: IVec4): IVec4;
		unproj(v4fScreen: IVec4, v4fDestination?: IVec4): IVec4;

		unprojZ(fZ:  number ):  number ;

/**
		 * use only this projection matrix otherwise result doesn't have any sense
		 */

		isOrthogonalProjection(): bool;
	};
};



module akra.math {

    export class Vec3 {
        x:  number ;
        y:  number ;
        z:  number ;


get xx(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.x) ;
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.y) ;
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get xz(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.z) ;
};
set xz(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.z = v2fVec.y;
};

get yx(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.x) ;
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.y) ;
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

get yz(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.z) ;
};
set yz(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.z = v2fVec.y;
};

get zx(): IVec2{
	return  Vec2.stackCeil.set(this.z, this.x) ;
};
set zx(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.x = v2fVec.y;
};

get zy(): IVec2{
	return  Vec2.stackCeil.set(this.z, this.y) ;
};
set zy(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.y = v2fVec.y;
};

get zz(): IVec2{
	return  Vec2.stackCeil.set(this.z, this.z) ;
};
set zz(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.z = v2fVec.y;
};


get xxx(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.x, this.x) ;
};
set xxx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get xxy(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.x, this.y) ;
};
set xxy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get xxz(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.x, this.z) ;
};
set xxz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get xyx(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.y, this.x) ;
};
set xyx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get xyy(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.y, this.y) ;
};
set xyy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get xyz(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.y, this.z) ;
};
set xyz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get xzx(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.z, this.x) ;
};
set xzx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get xzy(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.z, this.y) ;
};
set xzy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get xzz(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.z, this.z) ;
};
set xzz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get yxx(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.x, this.x) ;
};
set yxx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get yxy(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.x, this.y) ;
};
set yxy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get yxz(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.x, this.z) ;
};
set yxz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get yyx(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.y, this.x) ;
};
set yyx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get yyy(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.y, this.y) ;
};
set yyy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get yyz(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.y, this.z) ;
};
set yyz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get yzx(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.z, this.x) ;
};
set yzx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get yzy(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.z, this.y) ;
};
set yzy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get yzz(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.z, this.z) ;
};
set yzz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get zxx(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.x, this.x) ;
};
set zxx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get zxy(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.x, this.y) ;
};
set zxy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get zxz(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.x, this.z) ;
};
set zxz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get zyx(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.y, this.x) ;
};
set zyx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get zyy(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.y, this.y) ;
};
set zyy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get zyz(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.y, this.z) ;
};
set zyz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get zzx(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.z, this.x) ;
};
set zzx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get zzy(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.z, this.y) ;
};
set zzy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get zzz(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.z, this.z) ;
};
set zzz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

        constructor();
        constructor(fValue:  number );
        constructor(v3fVec: IVec3);
        constructor(pArray:  number []);
        constructor(fValue:  number , v2fVec: IVec2);
        constructor(v2fVec: IVec2, fValue:  number );
        constructor(fValue1:  number , fValue2:  number , fValue3:  number );
        constructor(fValue1?, fValue2?, fValue3?){
            var nArgumentsLength:  number  = arguments.length;


            switch(nArgumentsLength){
                case 1:
                    this.set(arguments[0]);
                    break;
                case 2:
                    this.set(arguments[0], arguments[1]);
                    break;
                case 3:
                    this.set(arguments[0], arguments[1], arguments[2]);
                    break;
                default:
                    this.x = this.y = this.z = 0.;
                    break;
            }
        };

        set(): IVec3;
        set(fValue:  number ): IVec3;
        set(v3fVec: IVec3): IVec3;
        set(pArray:  number []): IVec3;
        set(fValue:  number , v2fVec: IVec2): IVec3;
        set(v2fVec: IVec2, fValue:  number ): IVec3;
        set(fValue1:  number , fValue2:  number , fValue3:  number ): IVec3;
        set(fValue1?, fValue2?, fValue3?): IVec3{
            var nArgumentsLength = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = this.z = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = this.z = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec3){
                        var v3fVec: IVec3 = arguments[0];

                        this.x = v3fVec.x;
                        this.y = v3fVec.y;
                        this.z = v3fVec.z;
                    }
                    else{
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                        this.z = pArray[2];
                    }
                    break;
                case 2:
                    if(isFloat(arguments[0])){
                        var fValue:  number  = arguments[0];
                        var v2fVec: IVec2 = arguments[1];

                        this.x = fValue;
                        this.y = v2fVec.x;
                        this.z = v2fVec.y;
                    }
                    else{
                        var v2fVec: IVec2 = arguments[0];
                        var fValue:  number  = arguments[1];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                        this.z = fValue;
                    }
                    break;
                case 3:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    break;
            }

            return this;
        };

        /**@inline*/  clear(): IVec3{
            this.x = this.y = this.z = 0.;
            return this;
        };


        add(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = this.x + v3fVec.x;
            v3fDestination.y = this.y + v3fVec.y;
            v3fDestination.z = this.z + v3fVec.z;

            return v3fDestination;
        };


        subtract(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = this.x - v3fVec.x;
            v3fDestination.y = this.y - v3fVec.y;
            v3fDestination.z = this.z - v3fVec.z;

            return v3fDestination;
        };

        /**@inline*/  dot(v3fVec: IVec3):  number {
            return this.x*v3fVec.x + this.y*v3fVec.y + this.z*v3fVec.z;
        };


        cross(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z;
            var x2:  number  = v3fVec.x, y2:  number  = v3fVec.y, z2:  number  = v3fVec.z;

            v3fDestination.x = y1*z2 - z1*y2;
            v3fDestination.y = z1*x2 - x1*z2;
            v3fDestination.z = x1*y2 - y1*x2;

            return v3fDestination;
        };

        isEqual(v3fVec: IVec3, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v3fVec.x
                    || this.y != v3fVec.y
                    || this.z != v3fVec.z){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v3fVec.x) > fEps
                    || abs(this.y - v3fVec.y) > fEps
                    || abs(this.z - v3fVec.z) > fEps){

                    return false;
                }
            }
            return true;
        };


        isClear(fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.
                    || this.z != 0.) {

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps
                    || abs(this.z) > fEps){

                    return false;
                }
            }

            return true;
        };

        negate(v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = -this.x;
            v3fDestination.y = -this.y;
            v3fDestination.z = -this.z;

            return v3fDestination;
        };

        scale(v3fScale: IVec3, v3fDestination?: IVec3): IVec3;
        scale(fScale:  number , v3fDestination?: IVec3): IVec3;
        scale(): IVec3{
            var v3fDestination: IVec3 = (arguments.length === 2 && isDef(arguments[1])) ? arguments[1]: this;

            if(isNumber(arguments[0])){
                var fScale:  number  = arguments[0];
                v3fDestination.x = this.x*fScale;
                v3fDestination.y = this.y*fScale;
                v3fDestination.z = this.z*fScale;
            }
            else{
                var v3fScale: IVec3 = arguments[0];
                v3fDestination.x = this.x*v3fScale.x;
                v3fDestination.y = this.y*v3fScale.y;
                v3fDestination.z = this.z*v3fScale.z;
            }

            return v3fDestination;
        };

        normalize(v3fDestination?: IVec3): IVec3{
            if(!v3fDestination){
                v3fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;
            var fLength:  number  = sqrt(x*x + y*y + z*z);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
            }

            v3fDestination.x = x;
            v3fDestination.y = y;
            v3fDestination.z = z;

            return v3fDestination;
        };

        /**@inline*/  length():  number  {
            return sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
        };

        /**@inline*/  lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;
            return x*x + y*y + z*z;
        };

        direction(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            var x:  number  = v3fVec.x - this.x;
            var y:  number  = v3fVec.y - this.y;
            var z:  number  = v3fVec.z - this.z;

            var fLength:  number  = sqrt(x*x + y*y + z*z);

            if(fLength !== 0.){
                var fInvLength = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
            }

            v3fDestination.x = x;
            v3fDestination.y = y;
            v3fDestination.z = z;

            return v3fDestination;
        };

        mix(v3fVec: IVec3, fA:  number , v3fDestination?: IVec3): IVec3{
           if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v3fDestination.x = fA1*this.x + fA2*v3fVec.x;
            v3fDestination.y = fA1*this.y + fA2*v3fVec.y;
            v3fDestination.z = fA1*this.z + fA2*v3fVec.z;

            return v3fDestination;
        };

        /**@inline*/  toString(): string{
            return "[x: " + this.x + " ,y: " + this.y + ", z: " + this.z + "]";
        };

        /**@inline*/  toArray(pDest:  number [] = []):  number [] {
            pDest[0] = this.x;
            pDest[1] = this.y;
            pDest[2] = this.z;
            return pDest;
        }

        toTranslationMatrix(m4fDestination?: IMat4): IMat4{
            if(!isDef(m4fDestination)){
                m4fDestination = new Mat4(1.);
            }
            else{
                m4fDestination.set(1.);
            }

            var pData: Float32Array = m4fDestination.data;

            pData[ 12 ] = this.x;
            pData[ 13 ] = this.y;
            pData[ 14 ] = this.z;

            return m4fDestination;
        };

        vec3TransformCoord(m4fTransformation: IMat4, v3fDestination?: IVec3): IVec3{
            if(!v3fDestination){
                v3fDestination = this;
            }

            var pData: Float32Array = m4fTransformation.data;

            var x:  number  = this.x;
            var y:  number  = this.y;
            var z:  number  = this.z;
            var w:  number ;

            x = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ];
            y = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ];
            z = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ];
            w = pData[ 2 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ];

            var fInvW:  number  = 1./w;

            v3fDestination.x = x*fInvW;
            v3fDestination.y = y*fInvW;
            v3fDestination.z = z*fInvW;

            return v3fDestination;
        };

        static X: IVec3 = new Vec3(1., 0., 0.);
        static Y: IVec3 = new Vec3(0., 1., 0.);
        static Z: IVec3 = new Vec3(0., 0., 1.);

        static get stackCeil(): Vec3 { Vec3.stackPosition = Vec3.stackPosition === Vec3.stackSize - 1? 0: Vec3.stackPosition; return Vec3.stack[Vec3.stackPosition ++]; } static stackSize: number = 256 ; static stackPosition: number = 0; static stack: Vec3[] = (function(): Vec3[]{ var pStack: Vec3[] = new Array(Vec3.stackSize); for(var i: number = 0; i<Vec3.stackSize; i++){ pStack[i] = new Vec3(); } return pStack})();
    }
}











module akra.math {

    export class Vec4 implements IVec4{
        x:  number ;
        y:  number ;
        z:  number ;
        w:  number ;


get xx(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.x) ;
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.y) ;
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get xz(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.z) ;
};
set xz(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.z = v2fVec.y;
};

get xw(): IVec2{
	return  Vec2.stackCeil.set(this.x, this.w) ;
};
set xw(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.w = v2fVec.y;
};

get yx(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.x) ;
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.y) ;
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

get yz(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.z) ;
};
set yz(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.z = v2fVec.y;
};

get yw(): IVec2{
	return  Vec2.stackCeil.set(this.y, this.w) ;
};
set yw(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.w = v2fVec.y;
};

get zx(): IVec2{
	return  Vec2.stackCeil.set(this.z, this.x) ;
};
set zx(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.x = v2fVec.y;
};

get zy(): IVec2{
	return  Vec2.stackCeil.set(this.z, this.y) ;
};
set zy(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.y = v2fVec.y;
};

get zz(): IVec2{
	return  Vec2.stackCeil.set(this.z, this.z) ;
};
set zz(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.z = v2fVec.y;
};

get zw(): IVec2{
	return  Vec2.stackCeil.set(this.z, this.w) ;
};
set zw(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.w = v2fVec.y;
};

get wx(): IVec2{
	return  Vec2.stackCeil.set(this.w, this.x) ;
};
set wx(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.x = v2fVec.y;
};

get wy(): IVec2{
	return  Vec2.stackCeil.set(this.w, this.y) ;
};
set wy(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.y = v2fVec.y;
};

get wz(): IVec2{
	return  Vec2.stackCeil.set(this.w, this.z) ;
};
set wz(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.z = v2fVec.y;
};

get ww(): IVec2{
	return  Vec2.stackCeil.set(this.w, this.w) ;
};
set ww(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.w = v2fVec.y;
};


get xxx(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.x, this.x) ;
};
set xxx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get xxy(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.x, this.y) ;
};
set xxy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get xxz(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.x, this.z) ;
};
set xxz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get xxw(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.x, this.w) ;
};
set xxw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get xyx(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.y, this.x) ;
};
set xyx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get xyy(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.y, this.y) ;
};
set xyy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get xyz(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.y, this.z) ;
};
set xyz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get xyw(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.y, this.w) ;
};
set xyw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get xzx(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.z, this.x) ;
};
set xzx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get xzy(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.z, this.y) ;
};
set xzy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get xzz(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.z, this.z) ;
};
set xzz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get xzw(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.z, this.w) ;
};
set xzw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get xwx(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.w, this.x) ;
};
set xwx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get xwy(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.w, this.y) ;
};
set xwy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get xwz(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.w, this.z) ;
};
set xwz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get xww(): IVec3{
	return  Vec3.stackCeil.set(this.x, this.w, this.w) ;
};
set xww(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get yxx(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.x, this.x) ;
};
set yxx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get yxy(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.x, this.y) ;
};
set yxy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get yxz(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.x, this.z) ;
};
set yxz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get yxw(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.x, this.w) ;
};
set yxw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get yyx(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.y, this.x) ;
};
set yyx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get yyy(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.y, this.y) ;
};
set yyy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get yyz(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.y, this.z) ;
};
set yyz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get yyw(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.y, this.w) ;
};
set yyw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get yzx(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.z, this.x) ;
};
set yzx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get yzy(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.z, this.y) ;
};
set yzy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get yzz(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.z, this.z) ;
};
set yzz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get yzw(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.z, this.w) ;
};
set yzw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get ywx(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.w, this.x) ;
};
set ywx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get ywy(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.w, this.y) ;
};
set ywy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get ywz(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.w, this.z) ;
};
set ywz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get yww(): IVec3{
	return  Vec3.stackCeil.set(this.y, this.w, this.w) ;
};
set yww(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get zxx(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.x, this.x) ;
};
set zxx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get zxy(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.x, this.y) ;
};
set zxy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get zxz(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.x, this.z) ;
};
set zxz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get zxw(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.x, this.w) ;
};
set zxw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get zyx(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.y, this.x) ;
};
set zyx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get zyy(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.y, this.y) ;
};
set zyy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get zyz(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.y, this.z) ;
};
set zyz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get zyw(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.y, this.w) ;
};
set zyw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get zzx(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.z, this.x) ;
};
set zzx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get zzy(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.z, this.y) ;
};
set zzy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get zzz(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.z, this.z) ;
};
set zzz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get zzw(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.z, this.w) ;
};
set zzw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get zwx(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.w, this.x) ;
};
set zwx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get zwy(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.w, this.y) ;
};
set zwy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get zwz(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.w, this.z) ;
};
set zwz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get zww(): IVec3{
	return  Vec3.stackCeil.set(this.z, this.w, this.w) ;
};
set zww(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get wxx(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.x, this.x) ;
};
set wxx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get wxy(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.x, this.y) ;
};
set wxy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get wxz(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.x, this.z) ;
};
set wxz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get wxw(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.x, this.w) ;
};
set wxw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get wyx(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.y, this.x) ;
};
set wyx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get wyy(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.y, this.y) ;
};
set wyy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get wyz(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.y, this.z) ;
};
set wyz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get wyw(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.y, this.w) ;
};
set wyw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get wzx(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.z, this.x) ;
};
set wzx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get wzy(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.z, this.y) ;
};
set wzy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get wzz(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.z, this.z) ;
};
set wzz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get wzw(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.z, this.w) ;
};
set wzw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get wwx(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.w, this.x) ;
};
set wwx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get wwy(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.w, this.y) ;
};
set wwy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get wwz(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.w, this.z) ;
};
set wwz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get www(): IVec3{
	return  Vec3.stackCeil.set(this.w, this.w, this.w) ;
};
set www(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};


get xxxx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.x, this.x) ;
};
set xxxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xxxy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.x, this.y) ;
};
set xxxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xxxz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.x, this.z) ;
};
set xxxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xxxw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.x, this.w) ;
};
set xxxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xxyx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.y, this.x) ;
};
set xxyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xxyy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.y, this.y) ;
};
set xxyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xxyz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.y, this.z) ;
};
set xxyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xxyw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.y, this.w) ;
};
set xxyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xxzx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.z, this.x) ;
};
set xxzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xxzy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.z, this.y) ;
};
set xxzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xxzz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.z, this.z) ;
};
set xxzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xxzw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.z, this.w) ;
};
set xxzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xxwx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.w, this.x) ;
};
set xxwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xxwy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.w, this.y) ;
};
set xxwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xxwz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.w, this.z) ;
};
set xxwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xxww(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.x, this.w, this.w) ;
};
set xxww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xyxx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.x, this.x) ;
};
set xyxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xyxy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.x, this.y) ;
};
set xyxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xyxz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.x, this.z) ;
};
set xyxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xyxw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.x, this.w) ;
};
set xyxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xyyx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.y, this.x) ;
};
set xyyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xyyy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.y, this.y) ;
};
set xyyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xyyz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.y, this.z) ;
};
set xyyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xyyw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.y, this.w) ;
};
set xyyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xyzx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.z, this.x) ;
};
set xyzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xyzy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.z, this.y) ;
};
set xyzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xyzz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.z, this.z) ;
};
set xyzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xyzw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.z, this.w) ;
};
set xyzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xywx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.w, this.x) ;
};
set xywx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xywy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.w, this.y) ;
};
set xywy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xywz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.w, this.z) ;
};
set xywz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xyww(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.y, this.w, this.w) ;
};
set xyww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xzxx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.x, this.x) ;
};
set xzxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xzxy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.x, this.y) ;
};
set xzxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xzxz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.x, this.z) ;
};
set xzxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xzxw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.x, this.w) ;
};
set xzxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xzyx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.y, this.x) ;
};
set xzyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xzyy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.y, this.y) ;
};
set xzyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xzyz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.y, this.z) ;
};
set xzyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xzyw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.y, this.w) ;
};
set xzyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xzzx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.z, this.x) ;
};
set xzzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xzzy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.z, this.y) ;
};
set xzzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xzzz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.z, this.z) ;
};
set xzzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xzzw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.z, this.w) ;
};
set xzzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xzwx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.w, this.x) ;
};
set xzwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xzwy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.w, this.y) ;
};
set xzwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xzwz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.w, this.z) ;
};
set xzwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xzww(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.z, this.w, this.w) ;
};
set xzww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xwxx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.x, this.x) ;
};
set xwxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xwxy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.x, this.y) ;
};
set xwxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xwxz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.x, this.z) ;
};
set xwxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xwxw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.x, this.w) ;
};
set xwxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xwyx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.y, this.x) ;
};
set xwyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xwyy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.y, this.y) ;
};
set xwyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xwyz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.y, this.z) ;
};
set xwyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xwyw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.y, this.w) ;
};
set xwyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xwzx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.z, this.x) ;
};
set xwzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xwzy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.z, this.y) ;
};
set xwzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xwzz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.z, this.z) ;
};
set xwzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xwzw(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.z, this.w) ;
};
set xwzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xwwx(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.w, this.x) ;
};
set xwwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xwwy(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.w, this.y) ;
};
set xwwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xwwz(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.w, this.z) ;
};
set xwwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xwww(): IVec4{
	return  Vec4.stackCeil.set(this.x, this.w, this.w, this.w) ;
};
set xwww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yxxx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.x, this.x) ;
};
set yxxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yxxy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.x, this.y) ;
};
set yxxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yxxz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.x, this.z) ;
};
set yxxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yxxw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.x, this.w) ;
};
set yxxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yxyx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.y, this.x) ;
};
set yxyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yxyy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.y, this.y) ;
};
set yxyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yxyz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.y, this.z) ;
};
set yxyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yxyw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.y, this.w) ;
};
set yxyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yxzx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.z, this.x) ;
};
set yxzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yxzy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.z, this.y) ;
};
set yxzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yxzz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.z, this.z) ;
};
set yxzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yxzw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.z, this.w) ;
};
set yxzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yxwx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.w, this.x) ;
};
set yxwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yxwy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.w, this.y) ;
};
set yxwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yxwz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.w, this.z) ;
};
set yxwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yxww(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.x, this.w, this.w) ;
};
set yxww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yyxx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.x, this.x) ;
};
set yyxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yyxy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.x, this.y) ;
};
set yyxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yyxz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.x, this.z) ;
};
set yyxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yyxw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.x, this.w) ;
};
set yyxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yyyx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.y, this.x) ;
};
set yyyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yyyy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.y, this.y) ;
};
set yyyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yyyz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.y, this.z) ;
};
set yyyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yyyw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.y, this.w) ;
};
set yyyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yyzx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.z, this.x) ;
};
set yyzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yyzy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.z, this.y) ;
};
set yyzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yyzz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.z, this.z) ;
};
set yyzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yyzw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.z, this.w) ;
};
set yyzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yywx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.w, this.x) ;
};
set yywx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yywy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.w, this.y) ;
};
set yywy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yywz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.w, this.z) ;
};
set yywz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yyww(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.y, this.w, this.w) ;
};
set yyww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yzxx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.x, this.x) ;
};
set yzxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yzxy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.x, this.y) ;
};
set yzxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yzxz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.x, this.z) ;
};
set yzxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yzxw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.x, this.w) ;
};
set yzxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yzyx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.y, this.x) ;
};
set yzyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yzyy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.y, this.y) ;
};
set yzyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yzyz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.y, this.z) ;
};
set yzyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yzyw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.y, this.w) ;
};
set yzyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yzzx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.z, this.x) ;
};
set yzzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yzzy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.z, this.y) ;
};
set yzzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yzzz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.z, this.z) ;
};
set yzzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yzzw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.z, this.w) ;
};
set yzzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yzwx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.w, this.x) ;
};
set yzwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yzwy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.w, this.y) ;
};
set yzwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yzwz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.w, this.z) ;
};
set yzwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yzww(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.z, this.w, this.w) ;
};
set yzww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get ywxx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.x, this.x) ;
};
set ywxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get ywxy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.x, this.y) ;
};
set ywxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get ywxz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.x, this.z) ;
};
set ywxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get ywxw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.x, this.w) ;
};
set ywxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get ywyx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.y, this.x) ;
};
set ywyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get ywyy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.y, this.y) ;
};
set ywyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get ywyz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.y, this.z) ;
};
set ywyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get ywyw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.y, this.w) ;
};
set ywyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get ywzx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.z, this.x) ;
};
set ywzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get ywzy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.z, this.y) ;
};
set ywzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get ywzz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.z, this.z) ;
};
set ywzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get ywzw(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.z, this.w) ;
};
set ywzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get ywwx(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.w, this.x) ;
};
set ywwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get ywwy(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.w, this.y) ;
};
set ywwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get ywwz(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.w, this.z) ;
};
set ywwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get ywww(): IVec4{
	return  Vec4.stackCeil.set(this.y, this.w, this.w, this.w) ;
};
set ywww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zxxx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.x, this.x) ;
};
set zxxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zxxy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.x, this.y) ;
};
set zxxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zxxz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.x, this.z) ;
};
set zxxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zxxw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.x, this.w) ;
};
set zxxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zxyx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.y, this.x) ;
};
set zxyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zxyy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.y, this.y) ;
};
set zxyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zxyz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.y, this.z) ;
};
set zxyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zxyw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.y, this.w) ;
};
set zxyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zxzx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.z, this.x) ;
};
set zxzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zxzy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.z, this.y) ;
};
set zxzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zxzz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.z, this.z) ;
};
set zxzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zxzw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.z, this.w) ;
};
set zxzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zxwx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.w, this.x) ;
};
set zxwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zxwy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.w, this.y) ;
};
set zxwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zxwz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.w, this.z) ;
};
set zxwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zxww(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.x, this.w, this.w) ;
};
set zxww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zyxx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.x, this.x) ;
};
set zyxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zyxy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.x, this.y) ;
};
set zyxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zyxz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.x, this.z) ;
};
set zyxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zyxw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.x, this.w) ;
};
set zyxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zyyx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.y, this.x) ;
};
set zyyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zyyy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.y, this.y) ;
};
set zyyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zyyz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.y, this.z) ;
};
set zyyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zyyw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.y, this.w) ;
};
set zyyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zyzx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.z, this.x) ;
};
set zyzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zyzy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.z, this.y) ;
};
set zyzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zyzz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.z, this.z) ;
};
set zyzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zyzw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.z, this.w) ;
};
set zyzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zywx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.w, this.x) ;
};
set zywx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zywy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.w, this.y) ;
};
set zywy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zywz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.w, this.z) ;
};
set zywz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zyww(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.y, this.w, this.w) ;
};
set zyww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zzxx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.x, this.x) ;
};
set zzxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zzxy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.x, this.y) ;
};
set zzxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zzxz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.x, this.z) ;
};
set zzxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zzxw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.x, this.w) ;
};
set zzxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zzyx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.y, this.x) ;
};
set zzyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zzyy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.y, this.y) ;
};
set zzyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zzyz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.y, this.z) ;
};
set zzyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zzyw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.y, this.w) ;
};
set zzyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zzzx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.z, this.x) ;
};
set zzzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zzzy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.z, this.y) ;
};
set zzzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zzzz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.z, this.z) ;
};
set zzzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zzzw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.z, this.w) ;
};
set zzzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zzwx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.w, this.x) ;
};
set zzwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zzwy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.w, this.y) ;
};
set zzwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zzwz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.w, this.z) ;
};
set zzwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zzww(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.z, this.w, this.w) ;
};
set zzww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zwxx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.x, this.x) ;
};
set zwxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zwxy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.x, this.y) ;
};
set zwxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zwxz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.x, this.z) ;
};
set zwxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zwxw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.x, this.w) ;
};
set zwxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zwyx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.y, this.x) ;
};
set zwyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zwyy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.y, this.y) ;
};
set zwyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zwyz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.y, this.z) ;
};
set zwyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zwyw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.y, this.w) ;
};
set zwyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zwzx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.z, this.x) ;
};
set zwzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zwzy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.z, this.y) ;
};
set zwzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zwzz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.z, this.z) ;
};
set zwzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zwzw(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.z, this.w) ;
};
set zwzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zwwx(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.w, this.x) ;
};
set zwwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zwwy(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.w, this.y) ;
};
set zwwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zwwz(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.w, this.z) ;
};
set zwwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zwww(): IVec4{
	return  Vec4.stackCeil.set(this.z, this.w, this.w, this.w) ;
};
set zwww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wxxx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.x, this.x) ;
};
set wxxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wxxy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.x, this.y) ;
};
set wxxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wxxz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.x, this.z) ;
};
set wxxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wxxw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.x, this.w) ;
};
set wxxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wxyx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.y, this.x) ;
};
set wxyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wxyy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.y, this.y) ;
};
set wxyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wxyz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.y, this.z) ;
};
set wxyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wxyw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.y, this.w) ;
};
set wxyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wxzx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.z, this.x) ;
};
set wxzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wxzy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.z, this.y) ;
};
set wxzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wxzz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.z, this.z) ;
};
set wxzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wxzw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.z, this.w) ;
};
set wxzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wxwx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.w, this.x) ;
};
set wxwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wxwy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.w, this.y) ;
};
set wxwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wxwz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.w, this.z) ;
};
set wxwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wxww(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.x, this.w, this.w) ;
};
set wxww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wyxx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.x, this.x) ;
};
set wyxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wyxy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.x, this.y) ;
};
set wyxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wyxz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.x, this.z) ;
};
set wyxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wyxw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.x, this.w) ;
};
set wyxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wyyx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.y, this.x) ;
};
set wyyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wyyy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.y, this.y) ;
};
set wyyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wyyz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.y, this.z) ;
};
set wyyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wyyw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.y, this.w) ;
};
set wyyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wyzx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.z, this.x) ;
};
set wyzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wyzy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.z, this.y) ;
};
set wyzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wyzz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.z, this.z) ;
};
set wyzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wyzw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.z, this.w) ;
};
set wyzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wywx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.w, this.x) ;
};
set wywx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wywy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.w, this.y) ;
};
set wywy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wywz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.w, this.z) ;
};
set wywz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wyww(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.y, this.w, this.w) ;
};
set wyww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wzxx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.x, this.x) ;
};
set wzxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wzxy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.x, this.y) ;
};
set wzxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wzxz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.x, this.z) ;
};
set wzxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wzxw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.x, this.w) ;
};
set wzxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wzyx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.y, this.x) ;
};
set wzyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wzyy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.y, this.y) ;
};
set wzyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wzyz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.y, this.z) ;
};
set wzyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wzyw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.y, this.w) ;
};
set wzyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wzzx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.z, this.x) ;
};
set wzzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wzzy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.z, this.y) ;
};
set wzzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wzzz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.z, this.z) ;
};
set wzzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wzzw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.z, this.w) ;
};
set wzzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wzwx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.w, this.x) ;
};
set wzwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wzwy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.w, this.y) ;
};
set wzwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wzwz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.w, this.z) ;
};
set wzwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wzww(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.z, this.w, this.w) ;
};
set wzww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wwxx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.x, this.x) ;
};
set wwxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wwxy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.x, this.y) ;
};
set wwxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wwxz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.x, this.z) ;
};
set wwxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wwxw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.x, this.w) ;
};
set wwxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wwyx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.y, this.x) ;
};
set wwyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wwyy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.y, this.y) ;
};
set wwyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wwyz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.y, this.z) ;
};
set wwyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wwyw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.y, this.w) ;
};
set wwyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wwzx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.z, this.x) ;
};
set wwzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wwzy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.z, this.y) ;
};
set wwzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wwzz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.z, this.z) ;
};
set wwzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wwzw(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.z, this.w) ;
};
set wwzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wwwx(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.w, this.x) ;
};
set wwwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wwwy(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.w, this.y) ;
};
set wwwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wwwz(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.w, this.z) ;
};
set wwwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wwww(): IVec4{
	return  Vec4.stackCeil.set(this.w, this.w, this.w, this.w) ;
};
set wwww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

        constructor();
        constructor(fValue:  number );
        constructor(v4fVec: IVec4);
        constructor(pArray:  number []);
        constructor(fValue:  number , v3fVec: IVec3);
        constructor(v2fVec1: IVec2, v2fVec2: IVec2);
        constructor(v3fVec: IVec3, fValue:  number );
        constructor(fValue1:  number , fValue2:  number , v2fVec: IVec2);
        constructor(fValue1:  number , v2fVec: IVec2, fValue2:  number );
        constructor(v2fVec: IVec2 ,fValue1:  number , fValue2:  number );
        constructor(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
        constructor(fValue1?, fValue2?, fValue3?, fValue4?){
            var nArgumentsLength:  number  = arguments.length;
            var v4fVec: IVec4 = this;

// if (<any>this === window || <any>this === akra || <any>this === akra.math) {
//     v4fVec = Vec4.stack[Vec4.stackPosition ++];

//     if(Vec4.stackPosition == Vec4.stackSize){
//         Vec4.stackPosition = 0;
//     }
// }

            switch(nArgumentsLength) {
                case 1:
                    v4fVec.set(arguments[0]);
                    break;
                case 2:
                    v4fVec.set(arguments[0],arguments[1]);
                    break;
                case 3:
                    v4fVec.set(arguments[0],arguments[1], arguments[2]);
                    break;
                case 4:
                    v4fVec.set(arguments[0],arguments[1], arguments[2], arguments[3]);
                    break;
                default:
                    v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
                    break;
            }
        };

        set(): IVec4;
        set(fValue:  number ): IVec4;
        set(v4fVec: IVec4): IVec4;
        set(c4fColor: IColorValue): IVec4;
        set(pArray:  number []): IVec4;
        set(fValue:  number , v3fVec: IVec3): IVec4;
        set(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
        set(v3fVec: IVec3, fValue:  number ): IVec4;
        set(fValue1:  number , fValue2:  number , v2fVec: IVec2): IVec4;
        set(fValue1:  number , v2fVec: IVec2, fValue2:  number ): IVec4;
        set(v2fVec: IVec2, fValue1:  number , fValue2:  number ): IVec4;
        set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ): IVec4;
        set(): IVec4{
            var nArgumentsLength:  number  = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = this.z = this.w = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = this.z = this.w = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec4){
                        var v4fVec: IVec4 = arguments[0];

                        this.x = v4fVec.x;
                        this.y = v4fVec.y;
                        this.z = v4fVec.z;
                        this.w = v4fVec.w;
                    }
//color
                    else if (isDef(arguments[0].r)) {
                        this.x = arguments[0].r;
                        this.y = arguments[0].g;
                        this.z = arguments[0].b;
                        this.w = arguments[0].a;
                    }
                    else{
//array
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                        this.z = pArray[2];
                        this.w = pArray[3];
                    }
                    break;
                case 2:
                    if(isFloat(arguments[0])){
                        var fValue:  number  = arguments[0];
                        var v3fVec: IVec3 = arguments[1];

                        this.x = fValue;
                        this.y = v3fVec.x;
                        this.z = v3fVec.y;
                        this.w = v3fVec.z;
                    }
                    else if(arguments[0] instanceof Vec2){
                        var v2fVec1: IVec2 = arguments[0];
                        var v2fVec2: IVec2 = arguments[1];

                        this.x = v2fVec1.x;
                        this.y = v2fVec1.y;
                        this.z = v2fVec2.x;
                        this.w = v2fVec2.y;
                    }
                    else{
                        var v3fVec: IVec3 = arguments[0];
                        var fValue:  number  = arguments[1];

                        this.x = v3fVec.x;
                        this.y = v3fVec.y;
                        this.z = v3fVec.z;
                        this.w = fValue;
                    }
                    break;
                case 3:
                    if(isFloat(arguments[0])){
                        var fValue1:  number  = arguments[0];

                        if(isFloat(arguments[1])){
                            var fValue2:  number  = arguments[1];
                            var v2fVec: IVec2 = arguments[2];

                            this.x = fValue1;
                            this.y = fValue2;
                            this.z = v2fVec.x;
                            this.w = v2fVec.y;
                        }
                        else{
                            var v2fVec: IVec2 = arguments[1];
                            var fValue2:  number  = arguments[2];

                            this.x = fValue1;
                            this.y = v2fVec.x;
                            this.z = v2fVec.y;
                            this.w = fValue2;
                        }
                    }
                    else{
                        var v2fVec: IVec2 = arguments[0];
                        var fValue1:  number  = arguments[1];
                        var fValue2:  number  = arguments[2];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                        this.z = fValue1;
                        this.w = fValue2;
                    }
                    break;
                case 4:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    this.w = arguments[3];
                    break;
            }

            return this;
        };

        /**@inline*/  clear(): IVec4{
            this.x = this.y = this.z = this.w = 0.;
            return this;
        };

        add(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x + v4fVec.x;
            v4fDestination.y = this.y + v4fVec.y;
            v4fDestination.z = this.z + v4fVec.z;
            v4fDestination.w = this.w + v4fVec.w;

            return v4fDestination;
        };

        subtract(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x - v4fVec.x;
            v4fDestination.y = this.y - v4fVec.y;
            v4fDestination.z = this.z - v4fVec.z;
            v4fDestination.w = this.w - v4fVec.w;

            return v4fDestination;
        };

        /**@inline*/  dot(v4fVec: IVec4):  number {
            return this.x*v4fVec.x + this.y*v4fVec.y + this.z*v4fVec.z + this.w*v4fVec.w;
        };

        isEqual(v4fVec: IVec4, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v4fVec.x
                    || this.y != v4fVec.y
                    || this.z != v4fVec.z
                    || this.w != v4fVec.w){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v4fVec.x) > fEps
                    || abs(this.y - v4fVec.y) > fEps
                    || abs(this.z - v4fVec.z) > fEps
                    || abs(this.w - v4fVec.w) > fEps){

                    return false;
                }
            }
            return true;
        };

        isClear(fEps:  number  = 0.): bool{

            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.
                    || this.z != 0.
                    || this.w != 0.){

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps
                    || abs(this.z) > fEps
                    || abs(this.w) > fEps){

                    return false;
                }
            }
            return true;
        };

        negate(v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = -this.x;
            v4fDestination.y = -this.y;
            v4fDestination.z = -this.z;
            v4fDestination.w = -this.w;

            return v4fDestination;
        };

        scale(fScale:  number , v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x*fScale;
            v4fDestination.y = this.y*fScale;
            v4fDestination.z = this.z*fScale;
            v4fDestination.w = this.w*fScale;

            return v4fDestination;
        };

        normalize(v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            var fLength:  number  = sqrt(x*x + y*y +z*z + w*w);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                w *= fInvLength;
            }

            v4fDestination.x = x;
            v4fDestination.y = y;
            v4fDestination.z = z;
            v4fDestination.w = w;

            return v4fDestination;
        };

        /**@inline*/  length():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            return sqrt(x*x + y*y + z*z + w*w);
        };

        /**@inline*/  lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            return x*x + y*y + z*z + w*w;
        };

        direction(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            var x:  number  = v4fVec.x - this.x;
            var y:  number  = v4fVec.y - this.y;
            var z:  number  = v4fVec.z - this.z;
            var w:  number  = v4fVec.w - this.w;

            var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);

            if(fLength !== 0.){
                var fInvLength = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                w *= fInvLength;
            }

            v4fDestination.x = x;
            v4fDestination.y = y;
            v4fDestination.z = z;
            v4fDestination.w = w;

            return v4fDestination;
        };

        mix(v4fVec: IVec4, fA:  number , v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v4fDestination.x = fA1*this.x + fA2*v4fVec.x;
            v4fDestination.y = fA1*this.y + fA2*v4fVec.y;
            v4fDestination.z = fA1*this.z + fA2*v4fVec.z;
            v4fDestination.w = fA1*this.w + fA2*v4fVec.w;

            return v4fDestination;
        };

        /**@inline*/  toString(): string{
            return "[x: " + this.x + ", y: " + this.y
                        + ", z: " + this.z + ", w: " + this.w + "]";
        };

        static get stackCeil(): Vec4 { Vec4.stackPosition = Vec4.stackPosition === Vec4.stackSize - 1? 0: Vec4.stackPosition; return Vec4.stack[Vec4.stackPosition ++]; } static stackSize: number = 256 ; static stackPosition: number = 0; static stack: Vec4[] = (function(): Vec4[]{ var pStack: Vec4[] = new Array(Vec4.stackSize); for(var i: number = 0; i<Vec4.stackSize; i++){ pStack[i] = new Vec4(); } return pStack})();

    }
}





// module akra.math {
//     export class Mat2 {
//         private pData: Float32Array = new Float32Array(4);

//         constructor ();
//         constructor (m2f: Mat2);
//         constructor (f11: float, f12: float, f21: float, f22: float);
//         constructor (f11? , f12? , f21? , f22? ) {
//             switch (arguments.length) {
//                 case 1:
//                     this.set(f11);
//                     break;
//                 case 4:
//                     this.set(f11, f12, f21, f22);
//                     break;
//             }
//         }

//         set(): Mat2;
//         set(m2f: Mat2): Mat2;
//         set(f11: float, f12: float, f21: float, f22: float): Mat2;
//         set(f11? , f12? , f21? , f22? ): Mat2 {

//             var pData: Float32Array = this.pData;

//             switch (arguments.length) {
//                 case 1:
//                     if (isFloat(f11)) {
//                         pData[0] = pData[1] = pData[2] = pData[3] = f11;
//                     }
//                     else {
//                         //pData.set(f11.pData);
//                     }
//                     break;
//                 case 4:
//                     pData[0] = f11;
//                     pData[1] = f21;
//                     pData[2] = f12;
//                     pData[3] = f22;
//                     break;
//             }
//             return this;
//         }
//     }
// }









/**
 * @important Если внезапно задумаем перейти обратно на 
 * хранение данных в матрицах по строкам, как собственно и было в начале,
 * то необходимо раскомментить definы и переписать метод set, 
 * так как он ложит по столбцам
 */


// #define __a11 0
// #define __a12 1
// #define __a13 2
// #define __a21 3
// #define __a22 4
// #define __a23 5
// #define __a31 6
// #define __a32 7
// #define __a33 8











module akra {
	;
	;
	;

	export interface IMat3Constructor {
		();
		(fValue:  number );
		(v3fVec: IVec3);
		(m3fMat: IMat3);
		(m4fMat: IMat4);
		(pArray:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number );
		(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3);
		(pArray1:  number [], pArray2:  number [], pArray3:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number ,
					fValue4:  number , fValue5:  number , fValue6:  number ,
					fValue7:  number , fValue8:  number , fValue9:  number );
	}

	export interface IMat3 {
		data: Float32Array;

		set(): IMat3;
		set(fValue:  number ): IMat3;
		set(v3fVec: IVec3): IMat3;
		set(m3fMat: IMat3): IMat3;
		set(m4fMat: IMat4): IMat3;
		set(pArray:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IMat3;
		set(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
		set(pArray1:  number [], pArray2:  number [], pArray3:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ,
			fValue4:  number , fValue5:  number , fValue6:  number ,
			fValue7:  number , fValue8:  number , fValue9:  number ): IMat3;

		identity(): IMat3;

		add(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		subtract(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		multiply(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		transpose(m3fDestination?: IMat3): IMat3;
		determinant():  number ;
		inverse(m3fDestination?: IMat3): IMat3;

		isEqual(m3fMat: IMat3, fEps?:  number ): bool;
		isDiagonal(fEps?:  number ) : bool;

		toMat4(m4fDestination?: IMat4): IMat4;
		toQuat4(q4fDestination?: IQuat4): IQuat4;
		toString(): string;

		decompose(q4fRotation: IQuat4, v3fScale: IVec3): bool;
		row(iRow:  number , v3fDestination?: IVec3): IVec3;
		column(iColumn:  number , v3fDestination?: IVec3): IVec3;
	};
};










module akra {

	;
	;
	;

	export interface IQuat4Constructor {
		();
    	(q4fQuat: IQuat4);
    	(pArray:  number []);
    	(fValue:  number , fW:  number );
    	(v3fValue: IVec3, fW:  number );
    	(fX:  number , fY:  number , fZ:  number , fW:  number );
	}

	export interface IQuat4 {
		x:  number ;
		y:  number ;
		z:  number ;
		w:  number ;

		set(): IQuat4;
		set(q4fQuat: IQuat4): IQuat4;
		set(pArray:  number []): IQuat4;
		set(fValue:  number , fW:  number ): IQuat4;
		set(v3fValue: IVec3, fW:  number ): IQuat4;
		set(fX:  number , fY:  number , fZ:  number , fW:  number ): IQuat4;

		multiply(q4fQuat: IQuat4, q4fDestination?: IQuat4): IQuat4;
		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		conjugate(q4fDestination?: IQuat4): IQuat4;
		inverse(q4fDestination?: IQuat4): IQuat4;

		length():  number ;
		normalize(q4fDestination?: IQuat4): IQuat4;

		calculateW(q4fDestination?: IQuat4): IQuat4;

		isEqual(q4fQuat: IQuat4, fEps?:  number , asMatrix?: bool): bool;

		getYaw():  number ;
		getPitch():  number ;
		getRoll():  number ;
		toYawPitchRoll(v3fDestination?: IVec3): IVec3;

		toMat3(m3fDestination?: IMat3): IMat3;
		toMat4(m4fDestination?: IMat4): IMat4;
		toString(): string;

		mix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath?: bool);
		smix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath?: bool);
	};
};



module akra.math {

    export class Mat3 {
	    data : Float32Array;

	    constructor();
		constructor(fValue:  number );
		constructor(v3fVec: IVec3);
		constructor(m3fMat: IMat3);
		constructor(m4fMat: IMat4);
		constructor(pArray:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number );
		constructor(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3);
		constructor(pArray1:  number [], pArray2:  number [], pArray3:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number ,
					fValue4:  number , fValue5:  number , fValue6:  number ,
					fValue7:  number , fValue8:  number , fValue9:  number );

		constructor(fValue1?, fValue2?, fValue3?,
					fValue4?, fValue5?, fValue6?,
					fValue7?, fValue8?, fValue9?){


			var nArgumentsLength:  number  = arguments.length;

			this.data = new Float32Array(9);

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				case 9:
					this.set(arguments[0], arguments[1], arguments[2],
							 arguments[3], arguments[4], arguments[5],
							 arguments[6], arguments[7], arguments[8]);
					break;
				default:
					break;
			}
		};

		set(): IMat3;
		set(fValue:  number ): IMat3;
		set(v3fVec: IVec3): IMat3;
		set(m3fMat: IMat3): IMat3;
		set(m4fMat: IMat4): IMat3;
		set(pArray:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IMat3;
		set(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
		set(pArray1:  number [], pArray2:  number [], pArray3:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ,
			fValue4:  number , fValue5:  number , fValue6:  number ,
			fValue7:  number , fValue8:  number , fValue9:  number ): IMat3;

		set(fValue1?, fValue2?, fValue3?,
			fValue4?, fValue5?, fValue6?,
			fValue7?, fValue8?, fValue9?): IMat3{

			var pData: Float32Array = this.data;

//без аргументов инициализируется нулями

		    var nArgumentsLength:  number  = arguments.length;
		    if(nArgumentsLength == 0){
		        pData[ 0 ] = pData[ 3 ] = pData[ 6 ] = 0;
		        pData[ 1 ] = pData[ 4 ] = pData[ 7 ] = 0;
		        pData[ 2 ] = pData[ 5 ] = pData[ 8 ] = 0;
		    }
		    if(nArgumentsLength == 1){
		        if(isFloat(arguments[0])){
		            var nValue:  number  = arguments[0];

		            pData[ 0 ] = nValue;
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = nValue;
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = nValue;
		        }

		        else if(isDef(arguments[0].data)){
		            var pElements: Float32Array = arguments[0].data;

		            if(pElements.length === 9){
//Mat3
			            pData[ 0 ] = pElements[ 0 ];
			            pData[ 3 ] = pElements[ 3 ];
			            pData[ 6 ] = pElements[ 6 ];

			            pData[ 1 ] = pElements[ 1 ];
			            pData[ 4 ] = pElements[ 4 ];
			            pData[ 7 ] = pElements[ 7 ];

			            pData[ 2 ] = pElements[ 2 ];
			            pData[ 5 ] = pElements[ 5 ];
			            pData[ 8 ] = pElements[ 8 ];
		        	}
		        	else{
//Mat4
		        		pData[ 0 ] = pElements[ 0 ];
			            pData[ 3 ] = pElements[ 4 ];
			            pData[ 6 ] = pElements[ 8 ];

			            pData[ 1 ] = pElements[ 1 ];
			            pData[ 4 ] = pElements[ 5 ];
			            pData[ 7 ] = pElements[ 9 ];

			            pData[ 2 ] = pElements[ 2 ];
			            pData[ 5 ] = pElements[ 6 ];
			            pData[ 8 ] = pElements[ 10 ];
		        	}
		        }
		        else if(arguments[0] instanceof Vec3){
		            var v3fVec: IVec3 = arguments[0];

//диагональ

		            pData[ 0 ] = v3fVec.x;
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = v3fVec.y;
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = v3fVec.z;
		        }
		        else{
		            var pElements:  number [] = arguments[0];

		            if(pElements.length == 3){
//ложим диагональ
		                pData[ 0 ] = pElements[0];
		                pData[ 3 ] = 0;
		                pData[ 6 ] = 0;

		                pData[ 1 ] = 0;
		                pData[ 4 ] = pElements[1];
		                pData[ 7 ] = 0;

		                pData[ 2 ] = 0;
		                pData[ 5 ] = 0;
		                pData[ 8 ] = pElements[2];
		            }
		            else{
		                pData[ 0 ] = pElements[ 0 ];
		                pData[ 3 ] = pElements[ 3 ];
		                pData[ 6 ] = pElements[ 6 ];

		                pData[ 1 ] = pElements[ 1 ];
		                pData[ 4 ] = pElements[ 4 ];
		                pData[ 7 ] = pElements[ 7 ];

		                pData[ 2 ] = pElements[ 2 ];
		                pData[ 5 ] = pElements[ 5 ];
		                pData[ 8 ] = pElements[ 8 ];
		            }
		        }
		    }
		    else if(nArgumentsLength == 3){
		        if(isFloat(arguments[0])){
//выставляем диагональ
		            pData[ 0 ] = arguments[0];
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = arguments[1];
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = arguments[2];
		        }
		        else{
		            var pData1,pData2,pData3;
		            if(arguments[0] instanceof Vec3){

		                var v3fVec1: IVec3 = arguments[0];
		                var v3fVec2: IVec3 = arguments[1];
		                var v3fVec3: IVec3 = arguments[2];

//ложим по столбцам

		                pData[ 0 ] = v3fVec1.x;
		                pData[ 3 ] = v3fVec2.x;
		                pData[ 6 ] = v3fVec3.x;

		                pData[ 1 ] = v3fVec1.y;
		                pData[ 4 ] = v3fVec2.y;
		                pData[ 7 ] = v3fVec3.y;

		                pData[ 2 ] = v3fVec1.z;
		                pData[ 5 ] = v3fVec2.z;
		                pData[ 8 ] = v3fVec3.z;
		            }
		            else{

		                var v3fVec1:  number [] = arguments[0];
		                var v3fVec2:  number [] = arguments[1];
		                var v3fVec3:  number [] = arguments[2];

//ложим по столбцам

		                pData[ 0 ] = v3fVec1[0];
		                pData[ 3 ] = v3fVec2[0];
		                pData[ 6 ] = v3fVec3[0];

		                pData[ 1 ] = v3fVec1[1];
		                pData[ 4 ] = v3fVec2[1];
		                pData[ 7 ] = v3fVec3[1];

		                pData[ 2 ] = v3fVec1[2];
		                pData[ 5 ] = v3fVec2[2];
		                pData[ 8 ] = v3fVec3[2];
		            }
		        }
		    }
		    else if(nArgumentsLength == 9){
//просто числа
		        pData[ 0 ] = arguments[ 0 ];
		        pData[ 3 ] = arguments[ 3 ];
		        pData[ 6 ] = arguments[ 6 ];

		        pData[ 1 ] = arguments[ 1 ];
		        pData[ 4 ] = arguments[ 4 ];
		        pData[ 7 ] = arguments[ 7 ];

		        pData[ 2 ] = arguments[ 2 ];
		        pData[ 5 ] = arguments[ 5 ];
		        pData[ 8 ] = arguments[ 8 ];
		    }

		    return this;
		};

		identity(): IMat3{
			var pData: Float32Array = this.data;

		    pData[ 0 ] = 1.;
		    pData[ 3 ] = 0.;
		    pData[ 6 ] = 0.;

		    pData[ 1 ] = 0.;
		    pData[ 4 ] = 1.;
		    pData[ 7 ] = 0.;

		    pData[ 2 ] = 0.;
		    pData[ 5 ] = 0.;
		    pData[ 8 ] = 1.;

		    return this;
		};

		add(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData1[ 0 ] + pData2[ 0 ];
		    pDataDestination[ 3 ] = pData1[ 3 ] + pData2[ 3 ];
		    pDataDestination[ 6 ] = pData1[ 6 ] + pData2[ 6 ];

		    pDataDestination[ 1 ] = pData1[ 1 ] + pData2[ 1 ];
		    pDataDestination[ 4 ] = pData1[ 4 ] + pData2[ 4 ];
		    pDataDestination[ 7 ] = pData1[ 7 ] + pData2[ 7 ];

		    pDataDestination[ 2 ] = pData1[ 2 ] + pData2[ 2 ];
		    pDataDestination[ 5 ] = pData1[ 5 ] + pData2[ 5 ];
		    pDataDestination[ 8 ] = pData1[ 8 ] + pData2[ 8 ];

		    return m3fDestination;
		};

		subtract(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData1[ 0 ] - pData2[ 0 ];
		    pDataDestination[ 3 ] = pData1[ 3 ] - pData2[ 3 ];
		    pDataDestination[ 6 ] = pData1[ 6 ] - pData2[ 6 ];

		    pDataDestination[ 1 ] = pData1[ 1 ] - pData2[ 1 ];
		    pDataDestination[ 4 ] = pData1[ 4 ] - pData2[ 4 ];
		    pDataDestination[ 7 ] = pData1[ 7 ] - pData2[ 7 ];

		    pDataDestination[ 2 ] = pData1[ 2 ] - pData2[ 2 ];
		    pDataDestination[ 5 ] = pData1[ 5 ] - pData2[ 5 ];
		    pDataDestination[ 8 ] = pData1[ 8 ] - pData2[ 8 ];

		    return m3fDestination;
		};

		multiply(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			var pData1: Float32Array = this.data;
	        var pData2: Float32Array = m3fMat.data;

	        if(!isDef(m3fDestination)){
	            m3fDestination = this;
	        }
	        var pDataDestination = m3fDestination.data;

// Cache the matrix values (makes for huge speed increases!)
	        var a11:  number  = pData1[ 0 ], a12:  number  = pData1[ 3 ], a13:  number  = pData1[ 6 ];
	        var a21:  number  = pData1[ 1 ], a22:  number  = pData1[ 4 ], a23:  number  = pData1[ 7 ];
	        var a31:  number  = pData1[ 2 ], a32:  number  = pData1[ 5 ], a33:  number  = pData1[ 8 ];

	        var b11:  number  = pData2[ 0 ], b12:  number  = pData2[ 3 ], b13:  number  = pData2[ 6 ];
	        var b21:  number  = pData2[ 1 ], b22:  number  = pData2[ 4 ], b23:  number  = pData2[ 7 ];
	        var b31:  number  = pData2[ 2 ], b32:  number  = pData2[ 5 ], b33:  number  = pData2[ 8 ];

	        pDataDestination[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
	        pDataDestination[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
	        pDataDestination[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

	        pDataDestination[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
	        pDataDestination[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
	        pDataDestination[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

	        pDataDestination[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
	        pDataDestination[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
	        pDataDestination[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		    return m3fDestination;
		};

		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
			var pData: Float32Array = this.data;

	        if(!isDef(v3fDestination)){
	            v3fDestination = v3fVec;
	        }

	        var x:  number  = v3fVec.x, y:  number  = v3fVec.y, z:  number  = v3fVec.z;

	        v3fDestination.x = pData[ 0 ] * x + pData[ 3 ] * y + pData[ 6 ] * z;
	        v3fDestination.y = pData[ 1 ] * x + pData[ 4 ] * y + pData[ 7 ] * z;
	        v3fDestination.z = pData[ 2 ] * x + pData[ 5 ] * y + pData[ 8 ] * z;

		    return v3fDestination;
		};

		transpose(m3fDestination?: IMat3): IMat3{
			var pData: Float32Array = this.data;
		    if(!isDef(m3fDestination)){
//быстрее будет явно обработать оба случая
		        var a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ], a23:  number  = pData[ 7 ];

		        pData[ 3 ] = pData[ 1 ];
		        pData[ 6 ] = pData[ 2 ];

		        pData[ 1 ] = a12;
		        pData[ 7 ] = pData[ 5 ];

		        pData[ 2 ] = a13;
		        pData[ 5 ] = a23;

		        return this;
		    }

		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 3 ] = pData[ 1 ];
		    pDataDestination[ 6 ] = pData[ 2 ];

		    pDataDestination[ 1 ] = pData[ 3 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 7 ] = pData[ 5 ];

		    pDataDestination[ 2 ] = pData[ 6 ];
		    pDataDestination[ 5 ] = pData[ 7 ];
		    pDataDestination[ 8 ] = pData[ 8 ];

		    return m3fDestination;
		};

		determinant():  number {
			var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

		    return  a11 * (a22 * a33 - a23 * a32)
		            - a12 * (a21 * a33 - a23 * a31)
		            + a13 * (a21 * a32 - a22 * a31);
		};

		inverse(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

		    var A11:  number  = a22 * a33 - a23 * a32;
		    var A12:  number  = a21 * a33 - a23 * a31;
		    var A13:  number  = a21 * a32 - a22 * a31;

		    var A21:  number  = a12 * a33 - a13 * a32;
		    var A22:  number  = a11 * a33 - a13 * a31;
		    var A23:  number  = a11 * a32 - a12 * a31;

		    var A31:  number  = a12 * a23 - a13 * a22;
		    var A32:  number  = a11 * a23 - a13 * a21;
		    var A33:  number  = a11 * a22 - a12 * a21;

		    var fDeterminant:  number  = a11*A11 - a12 * A12 + a13 * A13;

		    if(fDeterminant == 0.){
		        { logger.setSourceLocation( "Mat3.ts" , 445 ); logger.error("обращение матрицы с нулевым детеминантом:\n", this.toString()); }
                                      ;

		        return m3fDestination.set(1.);
//чтоб все не навернулось
		    }

		    var fInverseDeterminant:  number  = 1./fDeterminant;

		    pDataDestination[ 0 ] = A11 * fInverseDeterminant;
		    pDataDestination[ 3 ] = -A21 * fInverseDeterminant;
		    pDataDestination[ 6 ] = A31 * fInverseDeterminant;

		    pDataDestination[ 1 ] = -A12 * fInverseDeterminant;
		    pDataDestination[ 4 ] = A22 * fInverseDeterminant;
		    pDataDestination[ 7 ] = -A32 * fInverseDeterminant;

		    pDataDestination[ 2 ] = A13 * fInverseDeterminant;
		    pDataDestination[ 5 ] = -A23 * fInverseDeterminant;
		    pDataDestination[ 8 ] = A33 * fInverseDeterminant;

		    return m3fDestination;
		};

		isEqual(m3fMat: IMat3, fEps:  number  = 0.): bool{
			var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;

		    if(fEps == 0){
		        if(    pData1[ 0 ] != pData2[ 0 ]
		            || pData1[ 3 ] != pData2[ 3 ]
		            || pData1[ 6 ] != pData2[ 6 ]
		            || pData1[ 1 ] != pData2[ 1 ]
		            || pData1[ 4 ] != pData2[ 4 ]
		            || pData1[ 7 ] != pData2[ 7 ]
		            || pData1[ 2 ] != pData2[ 2 ]
		            || pData1[ 5 ] != pData2[ 5 ]
		            || pData1[ 8 ] != pData2[ 8 ]){

		            return false;
		        }
		    }
		    else{
		        if(    Math.abs(pData1[ 0 ] - pData2[ 0 ]) > fEps
		            || Math.abs(pData1[ 3 ] - pData2[ 3 ]) > fEps
		            || Math.abs(pData1[ 6 ] - pData2[ 6 ]) > fEps
		            || Math.abs(pData1[ 1 ] - pData2[ 1 ]) > fEps
		            || Math.abs(pData1[ 4 ] - pData2[ 4 ]) > fEps
		            || Math.abs(pData1[ 7 ] - pData2[ 7 ]) > fEps
		            || Math.abs(pData1[ 2 ] - pData2[ 2 ]) > fEps
		            || Math.abs(pData1[ 5 ] - pData2[ 5 ]) > fEps
		            || Math.abs(pData1[ 8 ] - pData2[ 8 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		isDiagonal(fEps:  number  = 0.) : bool{
			var pData: Float32Array = this.data;

		    if(fEps == 0){
		        if(    pData[ 3 ] != 0 || pData[ 6 ] != 0
		            || pData[ 1 ] != 0 || pData[ 7 ] != 0
		            || pData[ 2 ] != 0 || pData[ 5 ] != 0){

		            return false;
		        }
		    }
		    else{
		        if(    Math.abs(pData[ 3 ]) > fEps || Math.abs(pData[ 6 ]) > fEps
		            || Math.abs(pData[ 1 ]) > fEps || Math.abs(pData[ 7 ]) > fEps
		            || Math.abs(pData[ 2 ]) > fEps || Math.abs(pData[ 5 ]) > fEps){

		            return false;
		        }
		    }

		    return true;
		};

		toMat4(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 3 ];
		    pDataDestination[ 8 ] = pData[ 6 ];
		    pDataDestination[ 12 ] = 0;

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 4 ];
		    pDataDestination[ 9 ] = pData[ 7 ];
		    pDataDestination[ 13 ] = 0;

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 5 ];
		    pDataDestination[ 10 ] = pData[ 8 ];
		    pDataDestination[ 14 ] = 0;

		    pDataDestination[ 3 ] = 0;
		    pDataDestination[ 7 ] = 0;
		    pDataDestination[ 11 ] = 0;
		    pDataDestination[ 15 ] = 1;

		    return m4fDestination;
		};

		toQuat4(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

/*x^2*/
		    var x2:  number  = ((a11 - a22 - a33) + 1)/4;
/*y^2*/
		    var y2:  number  = ((a22 - a11 - a33) + 1)/4;
/*z^2*/
		    var z2:  number  = ((a33 - a11 - a22) + 1)/4;
/*w^2*/
		    var w2:  number  = ((a11 + a22 + a33) + 1)/4;

		    var fMax:  number  = Math.max(x2,Math.max(y2,Math.max(z2,w2)));

		    if(fMax == x2){
//максимальная компонента берется положительной
		        var x:  number  = Math.sqrt(x2);

		        q4fDestination.x = x;
		        q4fDestination.y = (a21 + a12)/4/x;
		        q4fDestination.z = (a31 + a13)/4/x;
		        q4fDestination.w = (a32 - a23)/4/x;
		    }
		    else if(fMax == y2){
//максимальная компонента берется положительной
		        var y:  number  = Math.sqrt(y2);

		        q4fDestination.x = (a21 + a12)/4/y;
		        q4fDestination.y = y;
		        q4fDestination.z = (a32 + a23)/4/y;
		        q4fDestination.w = (a13 - a31)/4/y;
		    }
		    else if(fMax == z2){
//максимальная компонента берется положительной
		        var z:  number  = Math.sqrt(z2);

		        q4fDestination.x = (a31 + a13)/4/z;
		        q4fDestination.y = (a32 + a23)/4/z;
		        q4fDestination.z = z;
		        q4fDestination.w = (a21 - a12)/4/z;
		    }
		    else{
//максимальная компонента берется положительной
		        var w:  number  = Math.sqrt(w2);

		        q4fDestination.x = (a32 - a23)/4/w;
		        q4fDestination.y = (a13 - a31)/4/w;
		        q4fDestination.z = (a21 - a12)/4/w;
		        q4fDestination.w = w;
		    }

		    return q4fDestination;
		};

		toString(): string{
			var pData = this.data;
		    return '[' + pData[ 0 ] + ', ' + pData[ 3 ] + ', ' + pData[ 6 ] + ',\n' +
		               + pData[ 1 ] + ', ' + pData[ 4 ] + ', ' + pData[ 7 ] + ',\n' +
		               + pData[ 2 ] + ', ' + pData[ 5 ] + ', ' + pData[ 8 ] + ']';
		};

		decompose(q4fRotation: IQuat4, v3fScale: IVec3): bool{
//изначально предполагаем, что порядок умножения был rot * scale
			var m3fRotScale: IMat3 = this;
			var m3fRotScaleTransposed: IMat3 = this.transpose( Mat3.stackCeil.set() );
			var isRotScale: bool = true;

//понадобятся если порядок умножения был другим
		    var m3fScaleRot: IMat3 = null, m3fScaleRotTransposed: IMat3 = null;

//было отражение или нет
    		var scaleSign:  number  = (m3fRotScale.determinant() >= 0.) ? 1 : -1;

    		var m3fResult: IMat3 =  Mat3.stackCeil.set() ;

//first variant rot * scale
// (rot * scale)T * (rot * scale) = 
// scaleT * rotT * rot * scale = scaleT *rot^-1 * rot * scale = 
// scaleT * scale
		    m3fRotScaleTransposed.multiply(m3fRotScale, m3fResult);
		   	if(!m3fResult.isDiagonal(1e-4)){
//предположение было неверным
		   		isRotScale = false;
//просто переобозначения чтобы не было путаницы
		        m3fScaleRot = m3fRotScale;
		        m3fScaleRotTransposed = m3fRotScaleTransposed;

//second variant scale * rot
// (scale * rot) * (scale * rot)T = 
// scale * rot * rotT * scaleT = scale *rot * rot^-1 * scaleT = 
// scale * scaleT

		        m3fScaleRot.multiply(m3fScaleRotTransposed,m3fResult);
		   	}

		   	var pResultData: Float32Array = m3fResult.data;

		   	var x:  number  = sqrt(pResultData[ 0 ]);
/*если было отражение, считается что оно было по y*/
		   	var y:  number  = sqrt(pResultData[ 4 ])*scaleSign;
		   	var z:  number  = sqrt(pResultData[ 8 ]);

		   	v3fScale.x = x;
		   	v3fScale.y = y;
		   	v3fScale.z = z;

		   	var m3fInverseScale: IMat3 =  Mat3.stackCeil.set(1./x,1./y,1./z) ;

		   	if(isRotScale){
		   		m3fRotScale.multiply(m3fInverseScale, Mat3.stackCeil.set() ).toQuat4(q4fRotation);
		   		return true;
		   	}
		   	else{
		   		m3fInverseScale.multiply(m3fScaleRot, Mat3.stackCeil.set() ).toQuat4(q4fRotation);
		   		{ logger.setSourceLocation( "Mat3.ts" , 674 ); logger.assert(false,"порядок умножения scale rot в данный момент не поддерживается"); } ;
		   		return false;
		   	}
		};

		row(iRow:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var pData: Float32Array = this.data;

			switch(iRow){
				case 1:
					v3fDestination.x = pData[ 0 ];
					v3fDestination.y = pData[ 3 ];
					v3fDestination.z = pData[ 6 ];
					break;
				case 2:
					v3fDestination.x = pData[ 1 ];
					v3fDestination.y = pData[ 4 ];
					v3fDestination.z = pData[ 7 ];
					break;
				case 3:
					v3fDestination.x = pData[ 2 ];
					v3fDestination.y = pData[ 5 ];
					v3fDestination.z = pData[ 8 ];
					break;
			}

			return v3fDestination;
		};

		column(iColumn:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var pData: Float32Array = this.data;

			switch(iColumn){
				case 1:
					v3fDestination.x = pData[ 0 ];
					v3fDestination.y = pData[ 1 ];
					v3fDestination.z = pData[ 2 ];
					break;
				case 2:
					v3fDestination.x = pData[ 3 ];
					v3fDestination.y = pData[ 4 ];
					v3fDestination.z = pData[ 5 ];
					break;
				case 3:
					v3fDestination.x = pData[ 6 ];
					v3fDestination.y = pData[ 7 ];
					v3fDestination.z = pData[ 8 ];
					break;
			}

			return v3fDestination;
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number , m3fDestination?: IMat3): IMat3;
		static fromYawPitchRoll(v3fAngles: IVec3, m3fDestination?: IMat3): IMat3;
		static fromYawPitchRoll(fYaw?,fPitch?,fRoll?,m3fDestination?): IMat3{
			if(arguments.length <= 2){
//Vec3 + m3fDestination
		        var v3fVec: IVec3 = arguments[0];

		        fYaw   = v3fVec.x;
		        fPitch = v3fVec.y;
		        fRoll  = v3fVec.z;

		        m3fDestination = arguments[1];
		    }

		    if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }

		    var pDataDestination: Float32Array = m3fDestination.data;

		    var fSin1:  number  = Math.sin(fYaw);
		    var fSin2:  number  = Math.sin(fPitch);
		    var fSin3:  number  = Math.sin(fRoll);

		    var fCos1:  number  = Math.cos(fYaw);
		    var fCos2:  number  = Math.cos(fPitch);
		    var fCos3:  number  = Math.cos(fRoll);

		    pDataDestination[ 0 ] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
		    pDataDestination[ 3 ] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
		    pDataDestination[ 6 ] = fCos2 * fSin1;

		    pDataDestination[ 1 ] = fCos2 * fSin3;
		    pDataDestination[ 4 ] = fCos2 * fCos3;
		    pDataDestination[ 7 ] = -fSin2;

		    pDataDestination[ 2 ] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
		    pDataDestination[ 5 ] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
		    pDataDestination[ 8 ] = fCos1 * fCos2;

		    return m3fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , m3fDestination?: IMat3): IMat3;
		static fromXYZ(v3fAngles: IVec3, m3fDestination?: IMat3): IMat3;
		static fromXYZ(fX?, fY?, fZ?, m3fDestination?) : IMat3{
			if(arguments.length <= 2){
//Vec3 + m3fDestination
				var v3fVec: IVec3 = arguments[0];
				return Mat3.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m3fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Mat3.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static get stackCeil(): Mat3 { Mat3.stackPosition = Mat3.stackPosition === Mat3.stackSize - 1? 0: Mat3.stackPosition; return Mat3.stack[Mat3.stackPosition ++]; } static stackSize: number = 256 ; static stackPosition: number = 0; static stack: Mat3[] = (function(): Mat3[]{ var pStack: Mat3[] = new Array(Mat3.stackSize); for(var i: number = 0; i<Mat3.stackSize; i++){ pStack[i] = new Mat3(); } return pStack})(); ;
    };
};
















module akra {

	;
	;
	;

	export interface IVec4Constructor {
        ();
        (fValue:  number );
        (v4fVec: IVec4);
        (pArray:  number []);
        (fValue:  number , v3fVec: IVec3);
        (v2fVec1: IVec2, v2fVec2: IVec2);
        (v3fVec: IVec3, fValue:  number );
        (fValue1:  number , fValue2:  number , v2fVec: IVec2);
        (fValue1:  number , v2fVec: IVec2, fValue2:  number );
        (v2fVec: IVec2 ,fValue1:  number , fValue2:  number );
        (fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
    }


	export interface IVec4 {
		x:  number ;
		y:  number ;
		z:  number ;
		w:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

xz: IVec2;
/*represents two-component vector from original vector*/

xw: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;
/*represents two-component vector from original vector*/

yz: IVec2;
/*represents two-component vector from original vector*/

yw: IVec2;
/*represents two-component vector from original vector*/

zx: IVec2;
/*represents two-component vector from original vector*/

zy: IVec2;
/*represents two-component vector from original vector*/

zz: IVec2;
/*represents two-component vector from original vector*/

zw: IVec2;
/*represents two-component vector from original vector*/

wx: IVec2;
/*represents two-component vector from original vector*/

wy: IVec2;
/*represents two-component vector from original vector*/

wz: IVec2;
/*represents two-component vector from original vector*/

ww: IVec2;

/*represents three-component vector from original vector*/

xxx: IVec3;
/*represents three-component vector from original vector*/

xxy: IVec3;
/*represents three-component vector from original vector*/

xxz: IVec3;
/*represents three-component vector from original vector*/

xxw: IVec3;
/*represents three-component vector from original vector*/

xyx: IVec3;
/*represents three-component vector from original vector*/

xyy: IVec3;
/*represents three-component vector from original vector*/

xyz: IVec3;
/*represents three-component vector from original vector*/

xyw: IVec3;
/*represents three-component vector from original vector*/

xzx: IVec3;
/*represents three-component vector from original vector*/

xzy: IVec3;
/*represents three-component vector from original vector*/

xzz: IVec3;
/*represents three-component vector from original vector*/

xzw: IVec3;
/*represents three-component vector from original vector*/

xwx: IVec3;
/*represents three-component vector from original vector*/

xwy: IVec3;
/*represents three-component vector from original vector*/

xwz: IVec3;
/*represents three-component vector from original vector*/

xww: IVec3;
/*represents three-component vector from original vector*/

yxx: IVec3;
/*represents three-component vector from original vector*/

yxy: IVec3;
/*represents three-component vector from original vector*/

yxz: IVec3;
/*represents three-component vector from original vector*/

yxw: IVec3;
/*represents three-component vector from original vector*/

yyx: IVec3;
/*represents three-component vector from original vector*/

yyy: IVec3;
/*represents three-component vector from original vector*/

yyz: IVec3;
/*represents three-component vector from original vector*/

yyw: IVec3;
/*represents three-component vector from original vector*/

yzx: IVec3;
/*represents three-component vector from original vector*/

yzy: IVec3;
/*represents three-component vector from original vector*/

yzz: IVec3;
/*represents three-component vector from original vector*/

yzw: IVec3;
/*represents three-component vector from original vector*/

ywx: IVec3;
/*represents three-component vector from original vector*/

ywy: IVec3;
/*represents three-component vector from original vector*/

ywz: IVec3;
/*represents three-component vector from original vector*/

yww: IVec3;
/*represents three-component vector from original vector*/

zxx: IVec3;
/*represents three-component vector from original vector*/

zxy: IVec3;
/*represents three-component vector from original vector*/

zxz: IVec3;
/*represents three-component vector from original vector*/

zxw: IVec3;
/*represents three-component vector from original vector*/

zyx: IVec3;
/*represents three-component vector from original vector*/

zyy: IVec3;
/*represents three-component vector from original vector*/

zyz: IVec3;
/*represents three-component vector from original vector*/

zyw: IVec3;
/*represents three-component vector from original vector*/

zzx: IVec3;
/*represents three-component vector from original vector*/

zzy: IVec3;
/*represents three-component vector from original vector*/

zzz: IVec3;
/*represents three-component vector from original vector*/

zzw: IVec3;
/*represents three-component vector from original vector*/

zwx: IVec3;
/*represents three-component vector from original vector*/

zwy: IVec3;
/*represents three-component vector from original vector*/

zwz: IVec3;
/*represents three-component vector from original vector*/

zww: IVec3;
/*represents three-component vector from original vector*/

wxx: IVec3;
/*represents three-component vector from original vector*/

wxy: IVec3;
/*represents three-component vector from original vector*/

wxz: IVec3;
/*represents three-component vector from original vector*/

wxw: IVec3;
/*represents three-component vector from original vector*/

wyx: IVec3;
/*represents three-component vector from original vector*/

wyy: IVec3;
/*represents three-component vector from original vector*/

wyz: IVec3;
/*represents three-component vector from original vector*/

wyw: IVec3;
/*represents three-component vector from original vector*/

wzx: IVec3;
/*represents three-component vector from original vector*/

wzy: IVec3;
/*represents three-component vector from original vector*/

wzz: IVec3;
/*represents three-component vector from original vector*/

wzw: IVec3;
/*represents three-component vector from original vector*/

wwx: IVec3;
/*represents three-component vector from original vector*/

wwy: IVec3;
/*represents three-component vector from original vector*/

wwz: IVec3;
/*represents three-component vector from original vector*/

www: IVec3;

/*represents four-component vector from original vector*/

xxxx: IVec4;
/*represents four-component vector from original vector*/

xxxy: IVec4;
/*represents four-component vector from original vector*/

xxxz: IVec4;
/*represents four-component vector from original vector*/

xxxw: IVec4;
/*represents four-component vector from original vector*/

xxyx: IVec4;
/*represents four-component vector from original vector*/

xxyy: IVec4;
/*represents four-component vector from original vector*/

xxyz: IVec4;
/*represents four-component vector from original vector*/

xxyw: IVec4;
/*represents four-component vector from original vector*/

xxzx: IVec4;
/*represents four-component vector from original vector*/

xxzy: IVec4;
/*represents four-component vector from original vector*/

xxzz: IVec4;
/*represents four-component vector from original vector*/

xxzw: IVec4;
/*represents four-component vector from original vector*/

xxwx: IVec4;
/*represents four-component vector from original vector*/

xxwy: IVec4;
/*represents four-component vector from original vector*/

xxwz: IVec4;
/*represents four-component vector from original vector*/

xxww: IVec4;
/*represents four-component vector from original vector*/

xyxx: IVec4;
/*represents four-component vector from original vector*/

xyxy: IVec4;
/*represents four-component vector from original vector*/

xyxz: IVec4;
/*represents four-component vector from original vector*/

xyxw: IVec4;
/*represents four-component vector from original vector*/

xyyx: IVec4;
/*represents four-component vector from original vector*/

xyyy: IVec4;
/*represents four-component vector from original vector*/

xyyz: IVec4;
/*represents four-component vector from original vector*/

xyyw: IVec4;
/*represents four-component vector from original vector*/

xyzx: IVec4;
/*represents four-component vector from original vector*/

xyzy: IVec4;
/*represents four-component vector from original vector*/

xyzz: IVec4;
/*represents four-component vector from original vector*/

xyzw: IVec4;
/*represents four-component vector from original vector*/

xywx: IVec4;
/*represents four-component vector from original vector*/

xywy: IVec4;
/*represents four-component vector from original vector*/

xywz: IVec4;
/*represents four-component vector from original vector*/

xyww: IVec4;
/*represents four-component vector from original vector*/

xzxx: IVec4;
/*represents four-component vector from original vector*/

xzxy: IVec4;
/*represents four-component vector from original vector*/

xzxz: IVec4;
/*represents four-component vector from original vector*/

xzxw: IVec4;
/*represents four-component vector from original vector*/

xzyx: IVec4;
/*represents four-component vector from original vector*/

xzyy: IVec4;
/*represents four-component vector from original vector*/

xzyz: IVec4;
/*represents four-component vector from original vector*/

xzyw: IVec4;
/*represents four-component vector from original vector*/

xzzx: IVec4;
/*represents four-component vector from original vector*/

xzzy: IVec4;
/*represents four-component vector from original vector*/

xzzz: IVec4;
/*represents four-component vector from original vector*/

xzzw: IVec4;
/*represents four-component vector from original vector*/

xzwx: IVec4;
/*represents four-component vector from original vector*/

xzwy: IVec4;
/*represents four-component vector from original vector*/

xzwz: IVec4;
/*represents four-component vector from original vector*/

xzww: IVec4;
/*represents four-component vector from original vector*/

xwxx: IVec4;
/*represents four-component vector from original vector*/

xwxy: IVec4;
/*represents four-component vector from original vector*/

xwxz: IVec4;
/*represents four-component vector from original vector*/

xwxw: IVec4;
/*represents four-component vector from original vector*/

xwyx: IVec4;
/*represents four-component vector from original vector*/

xwyy: IVec4;
/*represents four-component vector from original vector*/

xwyz: IVec4;
/*represents four-component vector from original vector*/

xwyw: IVec4;
/*represents four-component vector from original vector*/

xwzx: IVec4;
/*represents four-component vector from original vector*/

xwzy: IVec4;
/*represents four-component vector from original vector*/

xwzz: IVec4;
/*represents four-component vector from original vector*/

xwzw: IVec4;
/*represents four-component vector from original vector*/

xwwx: IVec4;
/*represents four-component vector from original vector*/

xwwy: IVec4;
/*represents four-component vector from original vector*/

xwwz: IVec4;
/*represents four-component vector from original vector*/

xwww: IVec4;
/*represents four-component vector from original vector*/

yxxx: IVec4;
/*represents four-component vector from original vector*/

yxxy: IVec4;
/*represents four-component vector from original vector*/

yxxz: IVec4;
/*represents four-component vector from original vector*/

yxxw: IVec4;
/*represents four-component vector from original vector*/

yxyx: IVec4;
/*represents four-component vector from original vector*/

yxyy: IVec4;
/*represents four-component vector from original vector*/

yxyz: IVec4;
/*represents four-component vector from original vector*/

yxyw: IVec4;
/*represents four-component vector from original vector*/

yxzx: IVec4;
/*represents four-component vector from original vector*/

yxzy: IVec4;
/*represents four-component vector from original vector*/

yxzz: IVec4;
/*represents four-component vector from original vector*/

yxzw: IVec4;
/*represents four-component vector from original vector*/

yxwx: IVec4;
/*represents four-component vector from original vector*/

yxwy: IVec4;
/*represents four-component vector from original vector*/

yxwz: IVec4;
/*represents four-component vector from original vector*/

yxww: IVec4;
/*represents four-component vector from original vector*/

yyxx: IVec4;
/*represents four-component vector from original vector*/

yyxy: IVec4;
/*represents four-component vector from original vector*/

yyxz: IVec4;
/*represents four-component vector from original vector*/

yyxw: IVec4;
/*represents four-component vector from original vector*/

yyyx: IVec4;
/*represents four-component vector from original vector*/

yyyy: IVec4;
/*represents four-component vector from original vector*/

yyyz: IVec4;
/*represents four-component vector from original vector*/

yyyw: IVec4;
/*represents four-component vector from original vector*/

yyzx: IVec4;
/*represents four-component vector from original vector*/

yyzy: IVec4;
/*represents four-component vector from original vector*/

yyzz: IVec4;
/*represents four-component vector from original vector*/

yyzw: IVec4;
/*represents four-component vector from original vector*/

yywx: IVec4;
/*represents four-component vector from original vector*/

yywy: IVec4;
/*represents four-component vector from original vector*/

yywz: IVec4;
/*represents four-component vector from original vector*/

yyww: IVec4;
/*represents four-component vector from original vector*/

yzxx: IVec4;
/*represents four-component vector from original vector*/

yzxy: IVec4;
/*represents four-component vector from original vector*/

yzxz: IVec4;
/*represents four-component vector from original vector*/

yzxw: IVec4;
/*represents four-component vector from original vector*/

yzyx: IVec4;
/*represents four-component vector from original vector*/

yzyy: IVec4;
/*represents four-component vector from original vector*/

yzyz: IVec4;
/*represents four-component vector from original vector*/

yzyw: IVec4;
/*represents four-component vector from original vector*/

yzzx: IVec4;
/*represents four-component vector from original vector*/

yzzy: IVec4;
/*represents four-component vector from original vector*/

yzzz: IVec4;
/*represents four-component vector from original vector*/

yzzw: IVec4;
/*represents four-component vector from original vector*/

yzwx: IVec4;
/*represents four-component vector from original vector*/

yzwy: IVec4;
/*represents four-component vector from original vector*/

yzwz: IVec4;
/*represents four-component vector from original vector*/

yzww: IVec4;
/*represents four-component vector from original vector*/

ywxx: IVec4;
/*represents four-component vector from original vector*/

ywxy: IVec4;
/*represents four-component vector from original vector*/

ywxz: IVec4;
/*represents four-component vector from original vector*/

ywxw: IVec4;
/*represents four-component vector from original vector*/

ywyx: IVec4;
/*represents four-component vector from original vector*/

ywyy: IVec4;
/*represents four-component vector from original vector*/

ywyz: IVec4;
/*represents four-component vector from original vector*/

ywyw: IVec4;
/*represents four-component vector from original vector*/

ywzx: IVec4;
/*represents four-component vector from original vector*/

ywzy: IVec4;
/*represents four-component vector from original vector*/

ywzz: IVec4;
/*represents four-component vector from original vector*/

ywzw: IVec4;
/*represents four-component vector from original vector*/

ywwx: IVec4;
/*represents four-component vector from original vector*/

ywwy: IVec4;
/*represents four-component vector from original vector*/

ywwz: IVec4;
/*represents four-component vector from original vector*/

ywww: IVec4;
/*represents four-component vector from original vector*/

zxxx: IVec4;
/*represents four-component vector from original vector*/

zxxy: IVec4;
/*represents four-component vector from original vector*/

zxxz: IVec4;
/*represents four-component vector from original vector*/

zxxw: IVec4;
/*represents four-component vector from original vector*/

zxyx: IVec4;
/*represents four-component vector from original vector*/

zxyy: IVec4;
/*represents four-component vector from original vector*/

zxyz: IVec4;
/*represents four-component vector from original vector*/

zxyw: IVec4;
/*represents four-component vector from original vector*/

zxzx: IVec4;
/*represents four-component vector from original vector*/

zxzy: IVec4;
/*represents four-component vector from original vector*/

zxzz: IVec4;
/*represents four-component vector from original vector*/

zxzw: IVec4;
/*represents four-component vector from original vector*/

zxwx: IVec4;
/*represents four-component vector from original vector*/

zxwy: IVec4;
/*represents four-component vector from original vector*/

zxwz: IVec4;
/*represents four-component vector from original vector*/

zxww: IVec4;
/*represents four-component vector from original vector*/

zyxx: IVec4;
/*represents four-component vector from original vector*/

zyxy: IVec4;
/*represents four-component vector from original vector*/

zyxz: IVec4;
/*represents four-component vector from original vector*/

zyxw: IVec4;
/*represents four-component vector from original vector*/

zyyx: IVec4;
/*represents four-component vector from original vector*/

zyyy: IVec4;
/*represents four-component vector from original vector*/

zyyz: IVec4;
/*represents four-component vector from original vector*/

zyyw: IVec4;
/*represents four-component vector from original vector*/

zyzx: IVec4;
/*represents four-component vector from original vector*/

zyzy: IVec4;
/*represents four-component vector from original vector*/

zyzz: IVec4;
/*represents four-component vector from original vector*/

zyzw: IVec4;
/*represents four-component vector from original vector*/

zywx: IVec4;
/*represents four-component vector from original vector*/

zywy: IVec4;
/*represents four-component vector from original vector*/

zywz: IVec4;
/*represents four-component vector from original vector*/

zyww: IVec4;
/*represents four-component vector from original vector*/

zzxx: IVec4;
/*represents four-component vector from original vector*/

zzxy: IVec4;
/*represents four-component vector from original vector*/

zzxz: IVec4;
/*represents four-component vector from original vector*/

zzxw: IVec4;
/*represents four-component vector from original vector*/

zzyx: IVec4;
/*represents four-component vector from original vector*/

zzyy: IVec4;
/*represents four-component vector from original vector*/

zzyz: IVec4;
/*represents four-component vector from original vector*/

zzyw: IVec4;
/*represents four-component vector from original vector*/

zzzx: IVec4;
/*represents four-component vector from original vector*/

zzzy: IVec4;
/*represents four-component vector from original vector*/

zzzz: IVec4;
/*represents four-component vector from original vector*/

zzzw: IVec4;
/*represents four-component vector from original vector*/

zzwx: IVec4;
/*represents four-component vector from original vector*/

zzwy: IVec4;
/*represents four-component vector from original vector*/

zzwz: IVec4;
/*represents four-component vector from original vector*/

zzww: IVec4;
/*represents four-component vector from original vector*/

zwxx: IVec4;
/*represents four-component vector from original vector*/

zwxy: IVec4;
/*represents four-component vector from original vector*/

zwxz: IVec4;
/*represents four-component vector from original vector*/

zwxw: IVec4;
/*represents four-component vector from original vector*/

zwyx: IVec4;
/*represents four-component vector from original vector*/

zwyy: IVec4;
/*represents four-component vector from original vector*/

zwyz: IVec4;
/*represents four-component vector from original vector*/

zwyw: IVec4;
/*represents four-component vector from original vector*/

zwzx: IVec4;
/*represents four-component vector from original vector*/

zwzy: IVec4;
/*represents four-component vector from original vector*/

zwzz: IVec4;
/*represents four-component vector from original vector*/

zwzw: IVec4;
/*represents four-component vector from original vector*/

zwwx: IVec4;
/*represents four-component vector from original vector*/

zwwy: IVec4;
/*represents four-component vector from original vector*/

zwwz: IVec4;
/*represents four-component vector from original vector*/

zwww: IVec4;
/*represents four-component vector from original vector*/

wxxx: IVec4;
/*represents four-component vector from original vector*/

wxxy: IVec4;
/*represents four-component vector from original vector*/

wxxz: IVec4;
/*represents four-component vector from original vector*/

wxxw: IVec4;
/*represents four-component vector from original vector*/

wxyx: IVec4;
/*represents four-component vector from original vector*/

wxyy: IVec4;
/*represents four-component vector from original vector*/

wxyz: IVec4;
/*represents four-component vector from original vector*/

wxyw: IVec4;
/*represents four-component vector from original vector*/

wxzx: IVec4;
/*represents four-component vector from original vector*/

wxzy: IVec4;
/*represents four-component vector from original vector*/

wxzz: IVec4;
/*represents four-component vector from original vector*/

wxzw: IVec4;
/*represents four-component vector from original vector*/

wxwx: IVec4;
/*represents four-component vector from original vector*/

wxwy: IVec4;
/*represents four-component vector from original vector*/

wxwz: IVec4;
/*represents four-component vector from original vector*/

wxww: IVec4;
/*represents four-component vector from original vector*/

wyxx: IVec4;
/*represents four-component vector from original vector*/

wyxy: IVec4;
/*represents four-component vector from original vector*/

wyxz: IVec4;
/*represents four-component vector from original vector*/

wyxw: IVec4;
/*represents four-component vector from original vector*/

wyyx: IVec4;
/*represents four-component vector from original vector*/

wyyy: IVec4;
/*represents four-component vector from original vector*/

wyyz: IVec4;
/*represents four-component vector from original vector*/

wyyw: IVec4;
/*represents four-component vector from original vector*/

wyzx: IVec4;
/*represents four-component vector from original vector*/

wyzy: IVec4;
/*represents four-component vector from original vector*/

wyzz: IVec4;
/*represents four-component vector from original vector*/

wyzw: IVec4;
/*represents four-component vector from original vector*/

wywx: IVec4;
/*represents four-component vector from original vector*/

wywy: IVec4;
/*represents four-component vector from original vector*/

wywz: IVec4;
/*represents four-component vector from original vector*/

wyww: IVec4;
/*represents four-component vector from original vector*/

wzxx: IVec4;
/*represents four-component vector from original vector*/

wzxy: IVec4;
/*represents four-component vector from original vector*/

wzxz: IVec4;
/*represents four-component vector from original vector*/

wzxw: IVec4;
/*represents four-component vector from original vector*/

wzyx: IVec4;
/*represents four-component vector from original vector*/

wzyy: IVec4;
/*represents four-component vector from original vector*/

wzyz: IVec4;
/*represents four-component vector from original vector*/

wzyw: IVec4;
/*represents four-component vector from original vector*/

wzzx: IVec4;
/*represents four-component vector from original vector*/

wzzy: IVec4;
/*represents four-component vector from original vector*/

wzzz: IVec4;
/*represents four-component vector from original vector*/

wzzw: IVec4;
/*represents four-component vector from original vector*/

wzwx: IVec4;
/*represents four-component vector from original vector*/

wzwy: IVec4;
/*represents four-component vector from original vector*/

wzwz: IVec4;
/*represents four-component vector from original vector*/

wzww: IVec4;
/*represents four-component vector from original vector*/

wwxx: IVec4;
/*represents four-component vector from original vector*/

wwxy: IVec4;
/*represents four-component vector from original vector*/

wwxz: IVec4;
/*represents four-component vector from original vector*/

wwxw: IVec4;
/*represents four-component vector from original vector*/

wwyx: IVec4;
/*represents four-component vector from original vector*/

wwyy: IVec4;
/*represents four-component vector from original vector*/

wwyz: IVec4;
/*represents four-component vector from original vector*/

wwyw: IVec4;
/*represents four-component vector from original vector*/

wwzx: IVec4;
/*represents four-component vector from original vector*/

wwzy: IVec4;
/*represents four-component vector from original vector*/

wwzz: IVec4;
/*represents four-component vector from original vector*/

wwzw: IVec4;
/*represents four-component vector from original vector*/

wwwx: IVec4;
/*represents four-component vector from original vector*/

wwwy: IVec4;
/*represents four-component vector from original vector*/

wwwz: IVec4;
/*represents four-component vector from original vector*/

wwww: IVec4;

		set(): IVec4;
		set(fValue:  number ): IVec4;
		set(v4fVec: IVec4): IVec4;
		set(c4fColor: IColorValue): IVec4;
		set(pArray:  number []): IVec4;
		set(fValue:  number , v3fVec: IVec3): IVec4;
		set(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
		set(v3fVec: IVec3, fValue:  number ): IVec4;
		set(fValue1:  number , fValue2:  number , v2fVec: IVec2): IVec4;
		set(fValue1:  number , v2fVec: IVec2, fValue2:  number ): IVec4;
		set(v2fVec: IVec2, fValue1:  number , fValue2:  number ): IVec4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ): IVec4;

		clear(): IVec4;

		add(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;
		subtract(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;
		dot(v4fVec: IVec4):  number ;

		isEqual(v4fVec: IVec4, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v4fDestination?: IVec4): IVec4;
		scale(fScale:  number , v4fDestination?: IVec4): IVec4;
		normalize(v4fDestination?: IVec4): IVec4;
		length():  number ;
		lengthSquare():  number ;

		direction(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;

		mix(v4fVec: IVec4, fA:  number , v4fDestination?: IVec4): IVec4;

		toString(): string;
	};
};





module akra.math {
    export class Mat4 implements IMat4 {
    	data: Float32Array;

		constructor();
		constructor(fValue:  number );
		constructor(v4fVec: IVec4);
		constructor(m3fMat: IMat3, v3fTranslation?: IVec3);
		constructor(m4fMat: IMat4);
		constructor(pArray:  number []);
		constructor(pArray: Float32Array, bFlag: bool);
		constructor(fValue1:  number , fValue2:  number ,
				fValue3:  number , fValue4:  number );
		constructor(v4fVec1: IVec4, v4fVec2: IVec4,
				v4fVec3: IVec4, v4fVec4: IVec4);
		constructor(pArray1:  number [], pArray2:  number [],
				pArray3:  number [], pArray4:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
				fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
				fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
				fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number );
		constructor(fValue1?, fValue2?, fValue3?, fValue4?,
					fValue5?, fValue6?, fValue7?, fValue8?,
					fValue9?, fValue10?, fValue11?, fValue12?,
					fValue13?, fValue14?, fValue15?, fValue16?){
			var nArgumentsLength:  number  = arguments.length;

			if(nArgumentsLength === 2){
				if(isBoolean(arguments[1])){
					if(arguments[1]){
						this.data = arguments[0];
					}
					else{
						this.data = new Float32Array(16);
						this.set(arguments[0]);
					}
				}
				else{
					this.data = new Float32Array(16);
					this.set(arguments[0], arguments[1]);
				}
			}
			else{
				this.data = new Float32Array(16);

				switch(nArgumentsLength){
					case 1:
						if(arguments[0] instanceof Mat3){
							this.set(arguments[0], Vec3.stackCeil.set(0.) );
						}
						else{
							this.set(arguments[0]);
						}
						break;
					case 4:
						this.set(arguments[0],arguments[1],arguments[2],arguments[3]);
						break;
					case 16:
						this.set(arguments[0], arguments[1], arguments[2], arguments[3],
							 arguments[4], arguments[5], arguments[6], arguments[7],
							 arguments[8], arguments[9], arguments[10], arguments[11],
							 arguments[12], arguments[13], arguments[14], arguments[15]);
						 break;
					 default:
					 	break;
				}
			}
		};

		set(): IMat4;
		set(fValue:  number ): IMat4;
		set(v4fVec: IVec4): IMat4;
		set(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
		set(m4fMat: IMat4): IMat4;
		set(pArray:  number []): IMat4;
		set(fValue1:  number , fValue2:  number ,
			fValue3:  number , fValue4:  number ): IMat4;
		set(v4fVec1: IVec4, v4fVec2: IVec4,
			v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
		set(pArray1:  number [], pArray2:  number [],
			pArray3:  number [], pArray4:  number []): IMat4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
			fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
			fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
			fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number ): IMat4;
		set(): IMat4{

			var nArgumentsLength:  number  = arguments.length;
			var pData: Float32Array = this.data;

			if(nArgumentsLength === 0){
				pData[ 0 ] = pData[ 4 ] = pData[ 8 ] = pData[ 12 ] =
				pData[ 1 ] = pData[ 5 ] = pData[ 9 ] = pData[ 13 ] =
				pData[ 2 ] = pData[ 6 ] = pData[ 10 ] = pData[ 14 ] =
				pData[ 3 ] = pData[ 7 ] = pData[ 11 ] = pData[ 15 ] = 0.;

				return this;
			}

			if(nArgumentsLength === 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					pData[ 0 ] = fValue;
					pData[ 4 ] = 0.;
					pData[ 8 ] = 0.;
					pData[ 12 ] = 0.;

					pData[ 1 ] = 0.;
					pData[ 5 ] = fValue;
					pData[ 9 ] = 0.;
					pData[ 13 ] = 0.;

					pData[ 2 ] = 0.;
					pData[ 6 ] = 0.;
					pData[ 10 ] = fValue;
					pData[ 14 ] = 0.;

					pData[ 3 ] = 0.;
					pData[ 7 ] = 0.;
					pData[ 11 ] = 0.
					pData[ 15 ] = fValue;
				}
				else if(arguments[0] instanceof Vec4){
					var v4fVec = arguments[0];

					pData[ 0 ] = v4fVec.x;
					pData[ 4 ] = 0.;
					pData[ 8 ] = 0.;
					pData[ 12 ] = 0.;

					pData[ 1 ] = 0.;
					pData[ 5 ] = v4fVec.y;
					pData[ 9 ] = 0.;
					pData[ 13 ] = 0.;

					pData[ 2 ] = 0.;
					pData[ 6 ] = 0.;
					pData[ 10 ] = v4fVec.z;
					pData[ 14 ] = 0.;

					pData[ 3 ] = 0.;
					pData[ 7 ] = 0.;
					pData[ 11 ] = 0.
					pData[ 15 ] = v4fVec.w;
				}
				else if(isDef(arguments[0].data)){
					var pMatrixData: Float32Array = arguments[0].data;
					if(pMatrixData.length == 16){
//Mat4
						pData.set(pMatrixData);
					}
					else{
//Mat3
						pData[ 0 ] = pMatrixData[ 0 ];
						pData[ 4 ] = pMatrixData[ 3 ];
						pData[ 8 ] = pMatrixData[ 6 ];

						pData[ 1 ] = pMatrixData[ 1 ];
						pData[ 5 ] = pMatrixData[ 4 ];
						pData[ 9 ] = pMatrixData[ 7 ];

						pData[ 2 ] = pMatrixData[ 2 ];
						pData[ 6 ] = pMatrixData[ 5 ];
						pData[ 10 ] = pMatrixData[ 8 ];

						pData[ 3 ] = 0.;
						pData[ 7 ] = 0.;
						pData[ 11 ] = 0.;
						pData[ 15 ] = 1.;
					}
				}
				else{
//array
					var pArray:  number [] = arguments[0];

					if(pArray.length === 4){
						pData[ 0 ] = pArray[0];
						pData[ 4 ] = 0.;
						pData[ 8 ] = 0.;
						pData[ 12 ] = 0.;

						pData[ 1 ] = 0.;
						pData[ 5 ] = pArray[1];
						pData[ 9 ] = 0.;
						pData[ 13 ] = 0.;

						pData[ 2 ] = 0.;
						pData[ 6 ] = 0.;
						pData[ 10 ] = pArray[2];
						pData[ 14 ] = 0.;

						pData[ 3 ] = 0.;
						pData[ 7 ] = 0.;
						pData[ 11 ] = 0.
						pData[ 15 ] = pArray[3];
					}
					else{
//length == 16

						pData[ 0 ] = pArray[ 0 ];
						pData[ 4 ] = pArray[ 4 ];
						pData[ 8 ] = pArray[ 8 ];
						pData[ 12 ] = pArray[ 12 ];

						pData[ 1 ] = pArray[ 1 ];
						pData[ 5 ] = pArray[ 5 ];
						pData[ 9 ] = pArray[ 9 ];
						pData[ 13 ] = pArray[ 13 ];

						pData[ 2 ] = pArray[ 2 ];
						pData[ 6 ] = pArray[ 6 ];
						pData[ 10 ] = pArray[ 10 ];
						pData[ 14 ] = pArray[ 14 ];

						pData[ 3 ] = pArray[ 3 ];
						pData[ 7 ] = pArray[ 7 ];
						pData[ 11 ] = pArray[ 11 ];
						pData[ 15 ] = pArray[ 15 ];
					}
				}
			}
			else if(nArgumentsLength == 2){
				var pMatrixData: Float32Array = arguments[0];
				var v3fTranslation : IVec3 = arguments[1];

				pData[ 0 ] = pMatrixData[ 0 ];
				pData[ 4 ] = pMatrixData[ 3 ];
				pData[ 8 ] = pMatrixData[ 6 ];
				pData[ 12 ] = v3fTranslation.x;

				pData[ 1 ] = pMatrixData[ 1 ];
				pData[ 5 ] = pMatrixData[ 4 ];
				pData[ 9 ] = pMatrixData[ 7 ];
				pData[ 13 ] = v3fTranslation.y;

				pData[ 2 ] = pMatrixData[ 2 ];
				pData[ 6 ] = pMatrixData[ 5 ];
				pData[ 10 ] = pMatrixData[ 8 ];
				pData[ 14 ] = v3fTranslation.z;

				pData[ 3 ] = 0.;
				pData[ 7 ] = 0.;
				pData[ 11 ] = 0.;
				pData[ 15 ] = 1.;

			}
			else if(nArgumentsLength == 4){
				if(isFloat(arguments[0])){

					pData[ 0 ] = arguments[0];
					pData[ 4 ] = 0;
					pData[ 8 ] = 0;
					pData[ 12 ] = 0;

					pData[ 1 ] = 0;
					pData[ 5 ] = arguments[1];
					pData[ 9 ] = 0;
					pData[ 13 ] = 0;

					pData[ 2 ] = 0;
					pData[ 6 ] = 0;
					pData[ 10 ] = arguments[2];
					pData[ 14 ] = 0;

					pData[ 3 ] = 0;
					pData[ 7 ] = 0;
					pData[ 11 ] = 0;
					pData[ 15 ] = arguments[3];
				}
				else if(arguments[0] instanceof Vec4){

					var v4fColumn1: IVec4 = arguments[0];
					var v4fColumn2: IVec4 = arguments[1];
					var v4fColumn3: IVec4 = arguments[2];
					var v4fColumn4: IVec4 = arguments[3];

					pData[ 0 ] = v4fColumn1.x;
					pData[ 4 ] = v4fColumn2.x;
					pData[ 8 ] = v4fColumn3.x;
					pData[ 12 ] = v4fColumn4.x;

					pData[ 1 ] = v4fColumn1.y;
					pData[ 5 ] = v4fColumn2.y;
					pData[ 9 ] = v4fColumn3.y;
					pData[ 13 ] = v4fColumn4.y;

					pData[ 2 ] = v4fColumn1.z;
					pData[ 6 ] = v4fColumn2.z;
					pData[ 10 ] = v4fColumn3.z;
					pData[ 14 ] = v4fColumn4.z;

					pData[ 3 ] = v4fColumn1.w;
					pData[ 7 ] = v4fColumn2.w;
					pData[ 11 ] = v4fColumn3.w;
					pData[ 15 ] = v4fColumn4.w;
				}
				else{
//arrays

					var v4fColumn1:  number [] = arguments[0];
					var v4fColumn2:  number [] = arguments[1];
					var v4fColumn3:  number [] = arguments[2];
					var v4fColumn4:  number [] = arguments[3];

					pData[ 0 ] = v4fColumn1[0];
					pData[ 4 ] = v4fColumn2[0];
					pData[ 8 ] = v4fColumn3[0];
					pData[ 12 ] = v4fColumn4[0];

					pData[ 1 ] = v4fColumn1[1];
					pData[ 5 ] = v4fColumn2[1];
					pData[ 9 ] = v4fColumn3[1];
					pData[ 13 ] = v4fColumn4[1];

					pData[ 2 ] = v4fColumn1[2];
					pData[ 6 ] = v4fColumn2[2];
					pData[ 10 ] = v4fColumn3[2];
					pData[ 14 ] = v4fColumn4[2];

					pData[ 3 ] = v4fColumn1[3];
					pData[ 7 ] = v4fColumn2[3];
					pData[ 11 ] = v4fColumn3[3];
					pData[ 15 ] = v4fColumn4[3];

				}
			}
			else{
//nArgumentsLength === 16

				pData[ 0 ] = arguments[ 0 ];
				pData[ 4 ] = arguments[ 4 ];
				pData[ 8 ] = arguments[ 8 ];
				pData[ 12 ] = arguments[ 12 ];

				pData[ 1 ] = arguments[ 1 ];
				pData[ 5 ] = arguments[ 5 ];
				pData[ 9 ] = arguments[ 9 ];
				pData[ 13 ] = arguments[ 13 ];

				pData[ 2 ] = arguments[ 2 ];
				pData[ 6 ] = arguments[ 6 ];
				pData[ 10 ] = arguments[ 10 ];
				pData[ 14 ] = arguments[ 14 ];

				pData[ 3 ] = arguments[ 3 ];
				pData[ 7 ] = arguments[ 7 ];
				pData[ 11 ] = arguments[ 11 ];
				pData[ 15 ] = arguments[ 15 ];
			}
			return this;
		};

		identity() : IMat4{
			var pData: Float32Array = this.data;

			pData[ 0 ] = 1.;
			pData[ 4 ] = 0.;
			pData[ 8 ] = 0.;
			pData[ 12 ] = 0.;

			pData[ 1 ] = 0.;
			pData[ 5 ] = 1.;
			pData[ 9 ] = 0.;
			pData[ 13 ] = 0.;

			pData[ 2 ] = 0.;
			pData[ 6 ] = 0.;
			pData[ 10 ] = 1.;
			pData[ 14 ] = 0.;

			pData[ 3 ] = 0.;
			pData[ 7 ] = 0.;
			pData[ 11 ] = 0.;
			pData[ 15 ] = 1.;

			return this;
		};

		add(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}

			var pData1: Float32Array = this.data;
			var pData2: Float32Array = m4fMat.data;
			var pDataDestination: Float32Array = m4fDestination.data;

			pDataDestination[ 0 ] = pData1[ 0 ] + pData2[ 0 ];
			pDataDestination[ 4 ] = pData1[ 4 ] + pData2[ 4 ];
			pDataDestination[ 8 ] = pData1[ 8 ] + pData2[ 8 ];
			pDataDestination[ 12 ] = pData1[ 12 ] + pData2[ 12 ];

			pDataDestination[ 1 ] = pData1[ 1 ] + pData2[ 1 ];
			pDataDestination[ 5 ] = pData1[ 5 ] + pData2[ 5 ];
			pDataDestination[ 9 ] = pData1[ 9 ] + pData2[ 9 ];
			pDataDestination[ 13 ] = pData1[ 13 ] + pData2[ 13 ];

			pDataDestination[ 2 ] = pData1[ 2 ] + pData2[ 2 ];
			pDataDestination[ 6 ] = pData1[ 6 ] + pData2[ 6 ];
			pDataDestination[ 10 ] = pData1[ 10 ] + pData2[ 10 ];
			pDataDestination[ 14 ] = pData1[ 14 ] + pData2[ 14 ];

			pDataDestination[ 3 ] = pData1[ 3 ] + pData2[ 3 ];
			pDataDestination[ 7 ] = pData1[ 7 ] + pData2[ 7 ];
			pDataDestination[ 11 ] = pData1[ 11 ] + pData2[ 11 ];
			pDataDestination[ 15 ] = pData1[ 15 ] + pData2[ 15 ];

			return m4fDestination;
		};

		subtract(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}

			var pData1: Float32Array = this.data;
			var pData2: Float32Array = m4fMat.data;
			var pDataDestination: Float32Array = m4fDestination.data;

			pDataDestination[ 0 ] = pData1[ 0 ] - pData2[ 0 ];
			pDataDestination[ 4 ] = pData1[ 4 ] - pData2[ 4 ];
			pDataDestination[ 8 ] = pData1[ 8 ] - pData2[ 8 ];
			pDataDestination[ 12 ] = pData1[ 12 ] - pData2[ 12 ];

			pDataDestination[ 1 ] = pData1[ 1 ] - pData2[ 1 ];
			pDataDestination[ 5 ] = pData1[ 5 ] - pData2[ 5 ];
			pDataDestination[ 9 ] = pData1[ 9 ] - pData2[ 9 ];
			pDataDestination[ 13 ] = pData1[ 13 ] - pData2[ 13 ];

			pDataDestination[ 2 ] = pData1[ 2 ] - pData2[ 2 ];
			pDataDestination[ 6 ] = pData1[ 6 ] - pData2[ 6 ];
			pDataDestination[ 10 ] = pData1[ 10 ] - pData2[ 10 ];
			pDataDestination[ 14 ] = pData1[ 14 ] - pData2[ 14 ];

			pDataDestination[ 3 ] = pData1[ 3 ] - pData2[ 3 ];
			pDataDestination[ 7 ] = pData1[ 7 ] - pData2[ 7 ];
			pDataDestination[ 11 ] = pData1[ 11 ] - pData2[ 11 ];
			pDataDestination[ 15 ] = pData1[ 15 ] - pData2[ 15 ];

			return m4fDestination;
		};

		multiply(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
	            m4fDestination = this;
	        }

			var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m4fMat.data;
	        var pDataDestination: Float32Array = m4fDestination.data;

//кешируем значения матриц для ускорения

	        var a11:  number  = pData1[ 0 ], a12:  number  = pData1[ 4 ], a13:  number  = pData1[ 8 ], a14:  number  = pData1[ 12 ];
	        var a21:  number  = pData1[ 1 ], a22:  number  = pData1[ 5 ], a23:  number  = pData1[ 9 ], a24:  number  = pData1[ 13 ];
	        var a31:  number  = pData1[ 2 ], a32:  number  = pData1[ 6 ], a33:  number  = pData1[ 10 ], a34:  number  = pData1[ 14 ];
	        var a41:  number  = pData1[ 3 ], a42:  number  = pData1[ 7 ], a43:  number  = pData1[ 11 ], a44:  number  = pData1[ 15 ];

	        var b11:  number  = pData2[ 0 ], b12:  number  = pData2[ 4 ], b13:  number  = pData2[ 8 ], b14:  number  = pData2[ 12 ];
	        var b21:  number  = pData2[ 1 ], b22:  number  = pData2[ 5 ], b23:  number  = pData2[ 9 ], b24:  number  = pData2[ 13 ];
	        var b31:  number  = pData2[ 2 ], b32:  number  = pData2[ 6 ], b33:  number  = pData2[ 10 ], b34:  number  = pData2[ 14 ];
	        var b41:  number  = pData2[ 3 ], b42:  number  = pData2[ 7 ], b43:  number  = pData2[ 11 ], b44:  number  = pData2[ 15 ];

	        pDataDestination[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	        pDataDestination[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	        pDataDestination[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	        pDataDestination[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

	        pDataDestination[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	        pDataDestination[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	        pDataDestination[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	        pDataDestination[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

	        pDataDestination[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	        pDataDestination[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	        pDataDestination[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	        pDataDestination[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

	        pDataDestination[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	        pDataDestination[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	        pDataDestination[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	        pDataDestination[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		    return m4fDestination;
		};

		/**@inline*/  multiplyLeft(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}
			return m4fMat.multiply(this,m4fDestination);
		};

		multiplyVec4(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = v4fVec;
			}

			var pData: Float32Array = this.data;

			var x:  number  = v4fVec.x, y:  number  = v4fVec.y, z:  number  = v4fVec.z, w:  number  = v4fVec.w;

			v4fDestination.x = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ]*w;
	        v4fDestination.y = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ]*w;
	        v4fDestination.z = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ]*w;
	        v4fDestination.w = pData[ 3 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ]*w;

	        return v4fDestination;
		};

		transpose(m4fDestination?: IMat4): IMat4{

			var pData = this.data;

		    if(!isDef(m4fDestination)){
		        var a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		        var a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		        var a34:  number  = pData[ 14 ];

		        pData[ 4 ] = pData[ 1 ];
		        pData[ 8 ] = pData[ 2 ];
		        pData[ 12 ] = pData[ 3 ];

		        pData[ 1 ] = a12;
		        pData[ 9 ] = pData[ 6 ];
		        pData[ 13 ] = pData[ 7 ];

		        pData[ 2 ] = a13;
		        pData[ 6 ] = a23;
		        pData[ 14 ] = pData[ 11 ];

		        pData[ 3 ] = a14;
		        pData[ 7 ] = a24;
		        pData[ 11 ] = a34;

		        return this;
		    }

		    var pDataDestination = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 1 ];
		    pDataDestination[ 8 ] = pData[ 2 ];
		    pDataDestination[ 12 ] = pData[ 3 ];

		    pDataDestination[ 1 ] = pData[ 4 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 6 ];
		    pDataDestination[ 13 ] = pData[ 7 ];

		    pDataDestination[ 2 ] = pData[ 8 ];
		    pDataDestination[ 6 ] = pData[ 9 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = pData[ 11 ];

		    pDataDestination[ 3 ] = pData[ 12 ];
		    pDataDestination[ 7 ] = pData[ 13 ];
		    pDataDestination[ 11 ] = pData[ 14 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		determinant():  number {
			var pData = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];
		    var a41:  number  = pData[ 3 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ], a44:  number  = pData[ 15 ];

		    return  a41*a32*a23*a14 - a31*a42*a23*a14 - a41*a22*a33*a14 + a21*a42*a33*a14 +
			        a31*a22*a43*a14 - a21*a32*a43*a14 - a41*a32*a13*a24 + a31*a42*a13*a24 +
			        a41*a12*a33*a24 - a11*a42*a33*a24 - a31*a12*a43*a24 + a11*a32*a43*a24 +
			        a41*a22*a13*a34 - a21*a42*a13*a34 - a41*a12*a23*a34 + a11*a42*a23*a34 +
			        a21*a12*a43*a34 - a11*a22*a43*a34 - a31*a22*a13*a44 + a21*a32*a13*a44 +
			        a31*a12*a23*a44 - a11*a32*a23*a44 - a21*a12*a33*a44 + a11*a22*a33*a44;
		};

		inverse(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = this;
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

// Cache the matrix values (makes for huge speed increases!)
		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];
		    var a41:  number  = pData[ 3 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ], a44:  number  = pData[ 15 ];

		    var b00:  number  = a11*a22 - a12*a21;
		    var b01:  number  = a11*a23 - a13*a21;
		    var b02:  number  = a11*a24 - a14*a21;
		    var b03:  number  = a12*a23 - a13*a22;
		    var b04:  number  = a12*a24 - a14*a22;
		    var b05:  number  = a13*a24 - a14*a23;
		    var b06:  number  = a31*a42 - a32*a41;
		    var b07:  number  = a31*a43 - a33*a41;
		    var b08:  number  = a31*a44 - a34*a41;
		    var b09:  number  = a32*a43 - a33*a42;
		    var b10:  number  = a32*a44 - a34*a42;
		    var b11:  number  = a33*a44 - a34*a43;

		    var fDeterminant:  number  = b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06;

		    if(fDeterminant === 0.){
		        { logger.setSourceLocation( "Mat4.ts" , 621 ); logger.assert(false,"inversion of a matrix with zero determinant:\n" + this.toString()); }
                                            ;
//чтоб все не навернулось
		        return m4fDestination.set(1.);
		    }

		    var fInverseDeterminant:  number  = 1/fDeterminant;

		    pDataDestination[ 0 ] = (a22 * b11 - a23 * b10 + a24 * b09) * fInverseDeterminant;
		    pDataDestination[ 4 ] = (-a12 * b11 + a13 * b10 - a14 * b09) * fInverseDeterminant;
		    pDataDestination[ 8 ] = (a42 * b05 - a43 * b04 + a44 * b03) * fInverseDeterminant;
		    pDataDestination[ 12 ] = (-a32 * b05 + a33 * b04 - a34 * b03) * fInverseDeterminant;

		    pDataDestination[ 1 ] = (-a21 * b11 + a23 * b08 - a24 * b07) * fInverseDeterminant;
		    pDataDestination[ 5 ] = (a11 * b11 - a13 * b08 + a14 * b07) * fInverseDeterminant;
		    pDataDestination[ 9 ] = (-a41 * b05 + a43 * b02 - a44 * b01) * fInverseDeterminant;
		    pDataDestination[ 13 ] = (a31 * b05 - a33 * b02 + a34 * b01) * fInverseDeterminant;

		    pDataDestination[ 2 ] = (a21 * b10 - a22 * b08 + a24 * b06) * fInverseDeterminant;
		    pDataDestination[ 6 ] = (-a11 * b10 + a12 * b08 - a14 * b06) * fInverseDeterminant;
		    pDataDestination[ 10 ] = (a41 * b04 - a42 * b02 + a44 * b00) * fInverseDeterminant;
		    pDataDestination[ 14 ] = (-a31 * b04 + a32 * b02 - a34 * b00) * fInverseDeterminant;

		    pDataDestination[ 3 ] = (-a21 * b09 + a22 * b07 - a23 * b06) * fInverseDeterminant;
		    pDataDestination[ 7 ] = (a11 * b09 - a12 * b07 + a13 * b06) * fInverseDeterminant;
		    pDataDestination[ 11 ] = (-a41 * b03 + a42 * b01 - a43 * b00) * fInverseDeterminant;
		    pDataDestination[ 15 ] = (a31 * b03 - a32 * b01 + a33 * b00) * fInverseDeterminant;

		    return m4fDestination;
		};

		/**@inline*/  trace():  number {
			var pData: Float32Array = this.data;
			return pData[ 0 ] + pData[ 5 ] + pData[ 10 ] + pData[ 15 ];
		};

		isEqual(m4fMat: IMat4, fEps:  number  = 0.): bool{
		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m4fMat.data;

		    if(fEps === 0.){
		        if(    pData1[ 0 ] !== pData2[ 0 ]
		            || pData1[ 4 ] !== pData2[ 4 ]
		            || pData1[ 8 ] !== pData2[ 8 ]
		            || pData1[ 12 ] !== pData2[ 12 ]
		            || pData1[ 1 ] !== pData2[ 1 ]
		            || pData1[ 5 ] !== pData2[ 5 ]
		            || pData1[ 9 ] !== pData2[ 9 ]
		            || pData1[ 13 ] !== pData2[ 13 ]
		            || pData1[ 2 ] !== pData2[ 2 ]
		            || pData1[ 6 ] !== pData2[ 6 ]
		            || pData1[ 10 ] !== pData2[ 10 ]
		            || pData1[ 14 ] !== pData2[ 14 ]
		            || pData1[ 3 ] !== pData2[ 3 ]
		            || pData1[ 7 ] !== pData2[ 7 ]
		            || pData1[ 11 ] !== pData2[ 11 ]
		            || pData1[ 15 ] !== pData2[ 15 ]){

		            return false;
		        }
		    }
		    else{
		        if(    abs(pData1[ 0 ] - pData2[ 0 ]) > fEps
		            || abs(pData1[ 4 ] - pData2[ 4 ]) > fEps
		            || abs(pData1[ 8 ] - pData2[ 8 ]) > fEps
		            || abs(pData1[ 12 ] - pData2[ 12 ]) > fEps
		            || abs(pData1[ 1 ] - pData2[ 1 ]) > fEps
		            || abs(pData1[ 5 ] - pData2[ 5 ]) > fEps
		            || abs(pData1[ 9 ] - pData2[ 9 ]) > fEps
		            || abs(pData1[ 13 ] - pData2[ 13 ]) > fEps
		            || abs(pData1[ 2 ] - pData2[ 2 ]) > fEps
		            || abs(pData1[ 6 ] - pData2[ 6 ]) > fEps
		            || abs(pData1[ 10 ] - pData2[ 10 ]) > fEps
		            || abs(pData1[ 14 ] - pData2[ 14 ]) > fEps
		            || abs(pData1[ 3 ] - pData2[ 3 ]) > fEps
		            || abs(pData1[ 7 ] - pData2[ 7 ]) > fEps
		            || abs(pData1[ 11 ] - pData2[ 11 ]) > fEps
		            || abs(pData1[ 15 ] - pData2[ 15 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		isDiagonal(fEps:  number  = 0.): bool{
			var pData: Float32Array = this.data;

		    if(fEps === 0.){
		        if(    pData[ 4 ] !== 0. || pData[ 8 ] !== 0. || pData[ 12 ] != 0.
		            || pData[ 1 ] !== 0. || pData[ 9 ] !== 0. || pData[ 13 ] != 0.
		            || pData[ 2 ] !== 0. || pData[ 6 ] !== 0. || pData[ 14 ] != 0.
		            || pData[ 3 ] !== 0. || pData[ 7 ] !== 0. || pData[ 11 ] != 0.){

		            return false;
		        }
		    }
		    else{
		        if(    abs(pData[ 4 ]) > fEps || abs(pData[ 8 ]) > fEps || abs(pData[ 12 ]) > fEps
		            || abs(pData[ 1 ]) > fEps || abs(pData[ 9 ]) > fEps || abs(pData[ 13 ]) > fEps
		            || abs(pData[ 2 ]) > fEps || abs(pData[ 6 ]) > fEps || abs(pData[ 14 ]) > fEps
		            || abs(pData[ 3 ]) > fEps || abs(pData[ 7 ]) > fEps || abs(pData[ 11 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		toMat3(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 3 ] = pData[ 4 ];
		    pDataDestination[ 6 ] = pData[ 8 ];

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 4 ] = pData[ 5 ];
		    pDataDestination[ 7 ] = pData[ 9 ];

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 5 ] = pData[ 6 ];
		    pDataDestination[ 8 ] = pData[ 10 ];

		    return m3fDestination;
		};

		toQuat4(q4fDestination?: IQuat4) {
			if(!isDef(q4fDestination)){
				q4fDestination = new Quat4();
			}

			var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];

/*x^2*/
		    var x2:  number  = ((a11 - a22 - a33) + 1.)/4.;
/*y^2*/
		    var y2:  number  = ((a22 - a11 - a33) + 1.)/4.;
/*z^2*/
		    var z2:  number  = ((a33 - a11 - a22) + 1.)/4.;
/*w^2*/
		    var w2:  number  = ((a11 + a22 + a33) + 1.)/4.;

		    var fMax:  number  = max(x2,max(y2,max(z2,w2)));

		    if(fMax == x2){
//максимальная компонента берется положительной
		        var x:  number  = sqrt(x2);

		        q4fDestination.x = x;
		        q4fDestination.y = (a21 + a12)/4./x;
		        q4fDestination.z = (a31 + a13)/4./x;
		        q4fDestination.w = (a32 - a23)/4./x;
		    }
		    else if(fMax == y2){
//максимальная компонента берется положительной
		        var y:  number  = sqrt(y2);

		        q4fDestination.x = (a21 + a12)/4./y;
		        q4fDestination.y = y;
		        q4fDestination.z = (a32 + a23)/4./y;
		        q4fDestination.w = (a13 - a31)/4./y;
		    }
		    else if(fMax == z2){
//максимальная компонента берется положительной
		        var z:  number  = sqrt(z2);

		        q4fDestination.x = (a31 + a13)/4./z;
		        q4fDestination.y = (a32 + a23)/4./z;
		        q4fDestination.z = z;
		        q4fDestination.w = (a21 - a12)/4./z;
		    }
		    else{
//максимальная компонента берется положительной
		        var w:  number  = sqrt(w2);

		        q4fDestination.x = (a32 - a23)/4./w;
		        q4fDestination.y = (a13 - a31)/4./w;
		        q4fDestination.z = (a21 - a12)/4./w;
		        q4fDestination.w = w;
		    }

		    return q4fDestination;
		};

		toRotationMatrix(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 8 ] = pData[ 8 ];
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 9 ];
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 6 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		toString(iFixed:  number  = 2): string{
			var pData: Float32Array = this.data;

		    return '['  + pData[ 0 ].toFixed(iFixed) + ", " + pData[ 4 ].toFixed(iFixed) + ', ' + pData[ 8 ].toFixed(iFixed) + ', ' + pData[ 12 ].toFixed(iFixed) + ',\n'
		                + pData[ 1 ].toFixed(iFixed) + ", " + pData[ 5 ].toFixed(iFixed) + ', ' + pData[ 9 ].toFixed(iFixed) + ', ' + pData[ 13 ].toFixed(iFixed) + ',\n'
		                + pData[ 2 ].toFixed(iFixed) + ", " + pData[ 6 ].toFixed(iFixed) + ', ' + pData[ 10 ].toFixed(iFixed) + ', ' + pData[ 14 ].toFixed(iFixed) + ',\n'
		                + pData[ 3 ].toFixed(iFixed) + ", " + pData[ 7 ].toFixed(iFixed) + ', ' + pData[ 11 ].toFixed(iFixed) + ', ' + pData[ 15 ].toFixed(iFixed)+ ']';
		};

		toArray(pDest:  number [] = new Array(16)):  number [] {
//TODO: too slow :(
			return retrieve(< number []><any>this.data, pDest, 1, 0, 16) && pDest;
		}

		rotateRight(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;
		    var fLength:  number  = Math.sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		    	{ logger.setSourceLocation( "Mat4.ts" , 862 ); logger.assert(false,"попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString()); } ;
		    	if(isDef(m4fDestination)){
		    		m4fDestination.set(this);
		    	}
		    	else{
		    		m4fDestination = this;
		    	}
		    	return m4fDestination;
		    }

		    var fInvLength:  number  = 1./fLength;

		    x*=fInvLength;
		    y*=fInvLength;
		    z*=fInvLength;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];

		    var fSin:  number  = sin(fAngle);
		    var fCos:  number  = cos(fAngle);
		    var fTmp:  number  = 1. - fCos;

//build Rotation matrix

		    var b11:  number  = fCos + fTmp*x*x, b12:  number  = fTmp*x*y - fSin*z, b13:  number  = fTmp*x*z + fSin*y;
		    var b21:  number  = fTmp*y*z + fSin*z, b22:  number  = fCos + fTmp*y*y, b23:  number  = fTmp*y*z - fSin*x;
		    var b31:  number  = fTmp*z*x - fSin*y, b32:  number  = fTmp*z*y + fSin*x, b33:  number  = fCos + fTmp*z*z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] = a11*b11 + a12*b21 + a13*b31;
		        pData[ 4 ] = a11*b12 + a12*b22 + a13*b32;
		        pData[ 8 ] = a11*b13 + a12*b23 + a13*b33;

		        pData[ 1 ] = a21*b11 + a22*b21 + a23*b31;
		        pData[ 5 ] = a21*b12 + a22*b22 + a23*b32;
		        pData[ 9 ] = a21*b13 + a22*b23 + a23*b33;

		        pData[ 2 ] = a31*b11 + a32*b21 + a33*b31;
		        pData[ 6 ] = a31*b12 + a32*b22 + a33*b32;
		        pData[ 10 ] = a31*b13 + a32*b23 + a33*b33;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = a11*b11 + a12*b21 + a13*b31;
		    pDataDestination[ 4 ] = a11*b12 + a12*b22 + a13*b32;
		    pDataDestination[ 8 ] = a11*b13 + a12*b23 + a13*b33;
		    pDataDestination[ 12 ] = pData[ 12 ];

		    pDataDestination[ 1 ] = a21*b11 + a22*b21 + a23*b31;
		    pDataDestination[ 5 ] = a21*b12 + a22*b22 + a23*b32;
		    pDataDestination[ 9 ] = a21*b13 + a22*b23 + a23*b33;
		    pDataDestination[ 13 ] = pData[ 13 ];

		    pDataDestination[ 2 ] = a31*b11 + a32*b21 + a33*b31;
		    pDataDestination[ 6 ] = a31*b12 + a32*b22 + a33*b32;
		    pDataDestination[ 10 ] = a31*b13 + a32*b23 + a33*b33;
		    pDataDestination[ 14 ] = pData[ 14 ];

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		rotateLeft(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;
		    var fLength:  number  = Math.sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		    	{ logger.setSourceLocation( "Mat4.ts" , 940 ); logger.assert(false,"попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString()); } ;
		    	if(isDef(m4fDestination)){
		    		m4fDestination.set(this);
		    	}
		    	else{
		    		m4fDestination = this;
		    	}
		    	return m4fDestination;
		    }

		    var fInvLength:  number  = 1./fLength;

		    x*=fInvLength;
		    y*=fInvLength;
		    z*=fInvLength;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];

		    var fSin:  number  = sin(fAngle);
		    var fCos:  number  = cos(fAngle);
		    var fTmp:  number  = 1. - fCos;

//build Rotation matrix

		    var b11:  number  = fCos + fTmp*x*x, b12:  number  = fTmp*x*y - fSin*z, b13:  number  = fTmp*x*z + fSin*y;
		    var b21:  number  = fTmp*y*z + fSin*z, b22:  number  = fCos + fTmp*y*y, b23:  number  = fTmp*y*z - fSin*x;
		    var b31:  number  = fTmp*z*x - fSin*y, b32:  number  = fTmp*z*y + fSin*x, b33:  number  = fCos + fTmp*z*z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] = b11*a11 + b12*a21 + b13*a31;
		        pData[ 4 ] = b11*a12 + b12*a22 + b13*a32;
		        pData[ 8 ] = b11*a13 + b12*a23 + b13*a33;
		        pData[ 12 ] = b11*a14 + b12*a24 + b13*a34;

		        pData[ 1 ] = b21*a11 + b22*a21 + b23*a31;
		        pData[ 5 ] = b21*a12 + b22*a22 + b23*a32;
		        pData[ 9 ] = b21*a13 + b22*a23 + b23*a33;
		        pData[ 13 ] = b21*a14 + b22*a24 + b23*a34;

		        pData[ 2 ] = b31*a11 + b32*a21 + b33*a31;
		        pData[ 6 ] = b31*a12 + b32*a22 + b33*a32;
		        pData[ 10 ] = b31*a13 + b32*a23 + b33*a33;
		        pData[ 14 ] = b31*a14 + b32*a24 + b33*a34;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = b11*a11 + b12*a21 + b13*a31;
		    pDataDestination[ 4 ] = b11*a12 + b12*a22 + b13*a32;
		    pDataDestination[ 8 ] = b11*a13 + b12*a23 + b13*a33;
		    pDataDestination[ 12 ] = b11*a14 + b12*a24 + b13*a34;

		    pDataDestination[ 1 ] = b21*a11 + b22*a21 + b23*a31;
		    pDataDestination[ 5 ] = b21*a12 + b22*a22 + b23*a32;
		    pDataDestination[ 9 ] = b21*a13 + b22*a23 + b23*a33;
		    pDataDestination[ 13 ] = b21*a14 + b22*a24 + b23*a34;

		    pDataDestination[ 2 ] = b31*a11 + b32*a21 + b33*a31;
		    pDataDestination[ 6 ] = b31*a12 + b32*a22 + b33*a32;
		    pDataDestination[ 10 ] = b31*a13 + b32*a23 + b33*a33;
		    pDataDestination[ 14 ] = b31*a14 + b32*a24 + b33*a34;

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		/**@inline*/  setTranslation(v3fTranslation: IVec3): IMat4{
			var pData: Float32Array = this.data;

			pData[ 12 ] = v3fTranslation.x;
			pData[ 13 ] = v3fTranslation.y;
			pData[ 14 ] = v3fTranslation.z;

			return this;
		};

		/**@inline*/  getTranslation(v3fTranslation?: IVec3): IVec3{
			if(!isDef(v3fTranslation)){
				v3fTranslation = new Vec3();
			}

			var pData: Float32Array = this.data;

			v3fTranslation.x = pData[ 12 ];
			v3fTranslation.y = pData[ 13 ];
			v3fTranslation.z = pData[ 14 ];

			return v3fTranslation;
		};

		translateRight(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fTranslation.x, y:  number  = v3fTranslation.y, z:  number  = v3fTranslation.z;

		    if(!isDef(m4fDestination)){
		        pData[ 12 ] = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ];
		        pData[ 13 ] = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ];
		        pData[ 14 ] = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ];
		        pData[ 15 ] = pData[ 3 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ];
//строго говоря последнюю строчку умножать не обязательно, так как она должна быть -> 0 0 0 1
		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

//кешируем матрицу вращений
		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 0 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 0 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];
		    var a41:  number  = pData[ 0 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ];

		    pDataDestination[ 0 ] = a11;
		    pDataDestination[ 4 ] = a12;
		    pDataDestination[ 8 ] = a13;
		    pDataDestination[ 12 ] = a11*x + a12*y + a13*z + pData[ 12 ];

		    pDataDestination[ 1 ] = a21;
		    pDataDestination[ 5 ] = a22;
		    pDataDestination[ 9 ] = a23;
		    pDataDestination[ 13 ] = a21*x + a22*y + a23*z + pData[ 13 ];

		    pDataDestination[ 2 ] = a31;
		    pDataDestination[ 6 ] = a32;
		    pDataDestination[ 10 ] = a33;
		    pDataDestination[ 14 ] = a31*x + a32*y + a33*z + pData[ 14 ];

		    pDataDestination[ 3 ] = a41;
		    pDataDestination[ 7 ] = a42;
		    pDataDestination[ 11 ] = a43;
		    pDataDestination[ 15 ] = a41*x + a42*y + a43*z + pData[ 15 ];

		    return m4fDestination;
		};

		translateLeft(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fTranslation.x, y:  number  = v3fTranslation.y, z:  number  = v3fTranslation.z;

		    if(!isDef(m4fDestination)){
		        pData[ 12 ] = x + pData[ 12 ];
		        pData[ 13 ] = y + pData[ 13 ];
		        pData[ 14 ] = z + pData[ 14 ];
		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 8 ] = pData[ 8 ];
		    pDataDestination[ 12 ] = x + pData[ 12 ];

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 9 ];
		    pDataDestination[ 13 ] = y + pData[ 13 ];

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 6 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = z + pData[ 14 ];

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		scaleRight(v3fScale: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fScale.x, y:  number  = v3fScale.y, z:  number  = v3fScale.z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] *= x;
		        pData[ 4 ] *= y;
		        pData[ 8 ] *= z;

		        pData[ 1 ] *= x;
		        pData[ 5 ] *= y;
		        pData[ 9 ] *= z;

		        pData[ 2 ] *= x;
		        pData[ 6 ] *= y;
		        pData[ 10 ] *= z;

//скейлить эти компоненты необязательно, так как там должны лежать нули
		        pData[ 3 ] *= x;
		        pData[ 7 ] *= y;
		        pData[ 11 ] *= z;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ]*x;
		    pDataDestination[ 4 ] = pData[ 4 ]*y;
		    pDataDestination[ 8 ] = pData[ 8 ]*z;
		    pDataDestination[ 12 ] = pData[ 12 ];

		    pDataDestination[ 1 ] = pData[ 1 ]*x;
		    pDataDestination[ 5 ] = pData[ 5 ]*y;
		    pDataDestination[ 9 ] = pData[ 9 ]*z;
		    pDataDestination[ 13 ] = pData[ 13 ];

		    pDataDestination[ 2 ] = pData[ 2 ]*x;
		    pDataDestination[ 6 ] = pData[ 6 ]*y;
		    pDataDestination[ 10 ] = pData[ 10 ]*z;
		    pDataDestination[ 14 ] = pData[ 14 ];

//скейлить эти компоненты необязательно, так как там должны лежать нули
		    pDataDestination[ 3 ] = pData[ 3 ]*x;
		    pDataDestination[ 7 ] = pData[ 7 ]*y;
		    pDataDestination[ 11 ] = pData[ 11 ]*z;
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		scaleLeft(v3fScale: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fScale.x, y:  number  = v3fScale.y, z:  number  = v3fScale.z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] *= x;
		        pData[ 4 ] *= x;
		        pData[ 8 ] *= x;
		        pData[ 12 ] *= x;

		        pData[ 1 ] *= y;
		        pData[ 5 ] *= y;
		        pData[ 9 ] *= y;
		        pData[ 13 ] *= y;

		        pData[ 2 ] *= z;
		        pData[ 6 ] *= z;
		        pData[ 10 ] *= z;
		        pData[ 14 ] *= z;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ]*x;
		    pDataDestination[ 4 ] = pData[ 4 ]*x;
		    pDataDestination[ 8 ] = pData[ 8 ]*x;
		    pDataDestination[ 12 ] = pData[ 12 ]*x;

		    pDataDestination[ 1 ] = pData[ 1 ]*y;
		    pDataDestination[ 5 ] = pData[ 5 ]*y;
		    pDataDestination[ 9 ] = pData[ 9 ]*y;
		    pDataDestination[ 13 ] = pData[ 13 ]*y;

		    pDataDestination[ 2 ] = pData[ 2 ]*z;
		    pDataDestination[ 6 ] = pData[ 6 ]*z;
		    pDataDestination[ 10 ] = pData[ 10 ]*z;
		    pDataDestination[ 14 ] = pData[ 14 ]*z;

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		/**@inline*/  decompose(q4fRotation: IQuat4, v3fScale: IVec3, v3fTranslation: IVec3): bool {
			this.getTranslation(v3fTranslation);
			var m3fRotScale = this.toMat3( Mat3.stackCeil.set() );
			return m3fRotScale.decompose(q4fRotation,v3fScale);
		};

		row(iRow:  number , v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;

			switch(iRow){
				case 1:
					v4fDestination.x = pData[ 0 ];
					v4fDestination.y = pData[ 4 ];
					v4fDestination.z = pData[ 8 ];
					v4fDestination.w = pData[ 12 ];
					break;
				case 2:
					v4fDestination.x = pData[ 1 ];
					v4fDestination.y = pData[ 5 ];
					v4fDestination.z = pData[ 9 ];
					v4fDestination.w = pData[ 13 ];
					break;
				case 3:
					v4fDestination.x = pData[ 2 ];
					v4fDestination.y = pData[ 6 ];
					v4fDestination.z = pData[ 10 ];
					v4fDestination.w = pData[ 14 ];
					break;
				case 4:
					v4fDestination.x = pData[ 3 ];
					v4fDestination.y = pData[ 7 ];
					v4fDestination.z = pData[ 11 ];
					v4fDestination.w = pData[ 15 ];
					break;
			}

			return v4fDestination;
		};

		column(iColumn:  number , v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;

			switch(iColumn){
				case 1:
					v4fDestination.x = pData[ 0 ];
					v4fDestination.y = pData[ 1 ];
					v4fDestination.z = pData[ 2 ];
					v4fDestination.w = pData[ 3 ];
					break;
				case 2:
					v4fDestination.x = pData[ 4 ];
					v4fDestination.y = pData[ 5 ];
					v4fDestination.z = pData[ 6 ];
					v4fDestination.w = pData[ 7 ];
					break;
				case 3:
					v4fDestination.x = pData[ 8 ];
					v4fDestination.y = pData[ 9 ];
					v4fDestination.z = pData[ 10 ];
					v4fDestination.w = pData[ 11 ];
					break;
				case 4:
					v4fDestination.x = pData[ 12 ];
					v4fDestination.y = pData[ 13 ];
					v4fDestination.z = pData[ 14 ];
					v4fDestination.w = pData[ 15 ];
					break;
			}

			return v4fDestination;
		};

		unproj(v3fScreen: IVec3, v4fDestination?: IVec4): IVec4;
		unproj(v4fScreen: IVec4, v4fDestination?: IVec4): IVec4;
		unproj(v: any, v4fDestination?: IVec4): IVec4 {
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;
			var v3fScreen: IVec3 = <IVec3>v;
			var x:  number , y:  number , z:  number ;

			if(this.isOrthogonalProjection()){
//orthogonal projection case

				z = (v3fScreen.z - pData[ 14 ])/pData[ 10 ];
				y = (v3fScreen.y - pData[ 13 ])/pData[ 5 ];
				x = (v3fScreen.x - pData[ 12 ])/pData[ 0 ];
			}
			else{
//frustum case

				z = -pData[ 14 ]/(pData[ 10 ] + v3fScreen.z);
			    y = -(v3fScreen.y + pData[ 9 ])*z/pData[ 5 ];
			    x = -(v3fScreen.x + pData[ 8 ])*z/pData[ 0 ];
			}

			v4fDestination.x = x;
			v4fDestination.y = y;
			v4fDestination.z = z;
			v4fDestination.w = 1.;

			return v4fDestination;
		};

		unprojZ(fZ:  number ):  number {
			var pData: Float32Array = this.data;

			if(this.isOrthogonalProjection()){
//orthogonal projection case
				return (fZ - pData[ 14 ])/pData[ 10 ];
			}
			else{
//pData[__43] === -1
//frustum case
				return -pData[ 14 ]/(pData[ 10 ] + fZ);
			}
		};

		/**@inline*/  isOrthogonalProjection(): bool{
// var pData: Float32Array = this.data;

// if(pData[__44] === 1){
// 	//orthogonal projection
// 	return true;
// }
// else{
// 	//pData[__43] === -1
// 	//frustum projection
// 	return false;
// }
			return ((this.data[ 15 ] === 1) ? true : false);
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number , m4fDestination?: IMat4): IMat4;
		static fromYawPitchRoll(v3fAngles: IVec3, m4fDestination?: IMat4): IMat4;
		static fromYawPitchRoll(): IMat4{
			var fYaw:  number  = 0.0,
				fPitch:  number  = 0.0,
				fRoll:  number  = 0.0,
				m4fDestination: IMat4 = null;

			if(arguments.length <= 2){
//Vec3 + m4fDestination
		        var v3fVec: IVec3 = arguments[0];

		        fYaw   = v3fVec.x;
		        fPitch = v3fVec.y;
		        fRoll  = v3fVec.z;

		        m4fDestination = arguments[1];
		    }
		    else {
		    	fYaw = arguments[0];
		    	fPitch = arguments[1];
		    	fRoll = arguments[2];
		    	m4fDestination = arguments[3];
		    }

		    if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fSin1:  number  = Math.sin(fYaw);
		    var fSin2:  number  = Math.sin(fPitch);
		    var fSin3:  number  = Math.sin(fRoll);

		    var fCos1:  number  = Math.cos(fYaw);
		    var fCos2:  number  = Math.cos(fPitch);
		    var fCos3:  number  = Math.cos(fRoll);

		    pDataDestination[ 0 ] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
		    pDataDestination[ 4 ] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
		    pDataDestination[ 8 ] = fCos2 * fSin1;
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = fCos2 * fSin3;
		    pDataDestination[ 5 ] = fCos2 * fCos3;
		    pDataDestination[ 9 ] = -fSin2;
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
		    pDataDestination[ 6 ] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
		    pDataDestination[ 10 ] = fCos1 * fCos2;
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , m4fDestination?: IMat4): IMat4;
		static fromXYZ(v3fAngles: IVec3, m4fDestination?: IMat4): IMat4;
		static fromXYZ(fX?, fY?, fZ?, m4fDestination?) : IMat4{
			if(arguments.length <= 2){
//Vec3 + m4fDestination
				var v3fVec: IVec3 = arguments[0];
				return Mat4.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m4fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Mat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static frustum(fLeft:  number , fRight:  number , fBottom:  number , fTop:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fRL:  number  = fRight - fLeft;
		    var fTB:  number  = fTop - fBottom;
		    var fFN:  number  = fFar - fNear;

		    pDataDestination[ 0 ] = 2.*fNear/fRL;
		    pDataDestination[ 4 ] = 0.;
		    pDataDestination[ 8 ] = (fRight + fLeft)/fRL;
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = 0.;
		    pDataDestination[ 5 ] = 2.*fNear/fTB;
		    pDataDestination[ 9 ] = (fTop + fBottom)/fTB;
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = 0.;
		    pDataDestination[ 6 ] = 0.;
		    pDataDestination[ 10 ] = -(fFar + fNear)/fFN;
		    pDataDestination[ 14 ] = -2.*fFar*fNear/fFN;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = -1.;
		    pDataDestination[ 15 ] = 0.;

		    return m4fDestination;
		};

		/**@inline*/  static perspective(fFovy:  number , fAspect:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			var fTop:  number  = fNear*tan(fFovy/2.);
			var fRight:  number  = fTop*fAspect;

			return Mat4.frustum(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
		};

		static orthogonalProjectionAsymmetric(fLeft:  number , fRight:  number , fBottom:  number ,
												 fTop:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{

			 if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fRL:  number  = fRight - fLeft;
		    var fTB:  number  = fTop - fBottom;
		    var fFN:  number  = fFar - fNear;

		    pDataDestination[ 0 ] = 2./fRL;
		    pDataDestination[ 4 ] = 0.;
		    pDataDestination[ 8 ] = 0.;
		    pDataDestination[ 12 ] = -(fRight + fLeft)/fRL;

		    pDataDestination[ 1 ] = 0.;
		    pDataDestination[ 5 ] = 2./fTB;
		    pDataDestination[ 9 ] = 0.;
		    pDataDestination[ 13 ] = -(fTop + fBottom)/fTB;

		    pDataDestination[ 2 ] = 0.;
		    pDataDestination[ 6 ] = 0.;
		    pDataDestination[ 10 ] = -2./fFN;
		    pDataDestination[ 14 ] = -(fFar + fNear)/fFN;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		/**@inline*/  static orthogonalProjection(fWidth:  number , fHeight:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			var fRight:  number  = fWidth/2.;
		    var fTop:  number  = fHeight/2.;
		    return Mat4.orthogonalProjectionAsymmetric(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
		};

		static lookAt(v3fEye: IVec3, v3fCenter: IVec3, v3fUp: IVec3, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4(1.);
		    }

		    var fEyeX:  number  = v3fEye.x, fEyeY:  number  = v3fEye.y, fEyeZ:  number  = v3fEye.z;
		    var fCenterX:  number  = v3fCenter.x, fCenterY:  number  = v3fCenter.y, fCenterZ:  number  = v3fCenter.z;
		    var fUpX:  number  = v3fUp.x, fUpY:  number  = v3fUp.y, fUpZ:  number  = v3fUp.z;

		    var fLength:  number ;
		    var fInvLength:  number ;

		    if(fEyeX === fCenterX && fEyeY === fCenterY && fEyeZ === fCenterZ){
		        return m4fDestination;
		    }

		    var fXNewX:  number , fXNewY:  number , fXNewZ:  number ;
		    var fYNewX:  number , fYNewY:  number , fYNewZ:  number ;
		    var fZNewX:  number , fZNewY:  number , fZNewZ:  number ;

//ось Z направлена на наблюдателя
		    fZNewX = fEyeX - fCenterX;
		    fZNewY = fEyeY - fCenterY;
		    fZNewZ = fEyeZ - fCenterZ;

		    fLength = sqrt(fZNewX*fZNewX + fZNewY*fZNewY + fZNewZ*fZNewZ);
		    fInvLength = 1./fLength;

//новая ось Z
		    fZNewX = fZNewX*fInvLength;
		    fZNewY = fZNewY*fInvLength;
		    fZNewZ = fZNewZ*fInvLength;

//новая ось X
		    fXNewX = fUpY*fZNewZ - fUpZ*fZNewY;
		    fXNewY = fUpZ*fZNewX - fUpX*fZNewZ;
		    fXNewZ = fUpX*fZNewY - fUpY*fZNewX;

		    fLength = sqrt(fXNewX*fXNewX + fXNewY*fXNewY + fXNewZ*fXNewZ);
		    if(fLength){
		    	fInvLength = 1./fLength;

		        fXNewX = fXNewX*fInvLength;
		        fXNewY = fXNewY*fInvLength;
		        fXNewZ = fXNewZ*fInvLength;
		    }

//новая ось Y

		    fYNewX = fZNewY*fXNewZ - fZNewZ*fXNewY;
		    fYNewY = fZNewZ*fXNewX - fZNewX*fXNewZ;
		    fYNewZ = fZNewX*fXNewY - fZNewY*fXNewX;

//нормировать ненужно, так как было векторное умножение двух ортонормированных векторов

//положение камеры в новых осях
		    var fEyeNewX:  number  = fEyeX*fXNewX + fEyeY*fXNewY + fEyeZ*fXNewZ;
		    var fEyeNewY:  number  = fEyeX*fYNewX + fEyeY*fYNewY + fEyeZ*fYNewZ;
		    var fEyeNewZ:  number  = fEyeX*fZNewX + fEyeY*fZNewY + fEyeZ*fZNewZ;

		    var pDataDestination: Float32Array = m4fDestination.data;

//lookAt matrix === camera view matrix 
//почему новый базис записывается по строкам?
//это сзязано с тем, что это получающаяся матрица - 
//это viewMatrix камеры, а на эту матрицу умножается при рендеринге, то есть
//модель должна испытать преобразования противоположные тем, которые испытывает камера
//то есть вращение в другую сторону(базис по строкам) и сдвиг в противоположную сторону

		    pDataDestination[ 0 ] = fXNewX;
		    pDataDestination[ 4 ] = fXNewY;
		    pDataDestination[ 8 ] = fXNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 12 ] = -fEyeNewX;

		    pDataDestination[ 1 ] = fYNewX;
		    pDataDestination[ 5 ] = fYNewY;
		    pDataDestination[ 9 ] = fYNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 13 ] = -fEyeNewY;

		    pDataDestination[ 2 ] = fZNewX;
		    pDataDestination[ 6 ] = fZNewY;
		    pDataDestination[ 10 ] = fZNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 14 ] = -fEyeNewZ;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		static get stackCeil(): Mat4 { Mat4.stackPosition = Mat4.stackPosition === Mat4.stackSize - 1? 0: Mat4.stackPosition; return Mat4.stack[Mat4.stackPosition ++]; } static stackSize: number = 256 ; static stackPosition: number = 0; static stack: Mat4[] = (function(): Mat4[]{ var pStack: Mat4[] = new Array(Mat4.stackSize); for(var i: number = 0; i<Mat4.stackSize; i++){ pStack[i] = new Mat4(); } return pStack})();
    }
}

















module akra.math {
    export class Quat4 implements IQuat4{
    	x:  number ;
    	y:  number ;
    	z:  number ;
    	w:  number ;

    	constructor();
    	constructor(q4fQuat: IQuat4);
    	constructor(pArray:  number []);
    	constructor(fValue:  number , fW:  number );
    	constructor(v3fValue: IVec3, fW:  number );
    	constructor(fX:  number , fY:  number , fZ:  number , fW:  number );
    	constructor(fX?, fY?, fZ?, fW?){
    		var nArgumentsLength:  number  = arguments.length;

    		switch(nArgumentsLength){
    			case 1:
    				this.set(arguments[0]);
    				break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 4:
					this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
					break;
				default:
					this.x = this.y = this.z = 0.;
					this.w = 1.;
					break;
    		}
    	};

    	set(): IQuat4;
		set(q4fQuat: IQuat4): IQuat4;
		set(pArray:  number []): IQuat4;
		set(fValue:  number , fW:  number ): IQuat4;
		set(v3fValue: IVec3, fW:  number ): IQuat4;
		set(fX:  number , fY:  number , fZ:  number , fW:  number ): IQuat4;
		set(fX?, fY?, fZ?, fW?): IQuat4{
			var nArgumentsLength:  number  = arguments.length;

		    if(nArgumentsLength === 0){
		        this.x = this.y = this.z = 0.;
		        this.w = 1.;
		    }
		    if(nArgumentsLength === 1){
		        if(arguments[0] instanceof Quat4){
		        	var q4fQuat: IQuat4 = arguments[0];

		            this.x = q4fQuat.x;
		            this.y = q4fQuat.y;
		            this.z = q4fQuat.z;
		            this.w = q4fQuat.w;
		        }
		        else{
//Array
		            var pElements:  number [] = arguments[0];

		            this.x = pElements[0];
		            this.y = pElements[1];
		            this.z = pElements[2];
		            this.w = pElements[3];
		        }
		    }
		    else if(nArgumentsLength === 2){
//float float
//vec3 float
		        if(isFloat(arguments[0])){
//float float
		            var fValue:  number  = arguments[0];

		            this.x = fValue;
		            this.y = fValue;
		            this.z = fValue;
		            this.w = arguments[1];
		        }
		        else{
//vec3 float
		            var v3fValue: IVec3 = arguments[0];

		            this.x = v3fValue.x;
		            this.y = v3fValue.y;
		            this.z = v3fValue.z;
		            this.w = arguments[1];
		        }
		    }
		    else if(nArgumentsLength === 4){
		        this.x = arguments[0];
		        this.y = arguments[1];
		        this.z = arguments[2];
		        this.w = arguments[3];
		    }

		    return this;
		};

		multiply(q4fQuat: IQuat4, q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

		    q4fDestination.x = x1*w2 + x2*w1 + y1*z2 - z1*y2;
		    q4fDestination.y = y1*w2 + y2*w1 + z1*x2 - x1*z2;
		    q4fDestination.z = z1*w2 + z2*w1 + x1*y2 - y1*x2;
		    q4fDestination.w = w1*w2 - x1*x2 - y1*y2 - z1*z2;

		    return q4fDestination;
		};

		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
		        v3fDestination = v3fVec;
		    }

		    var q4fVec: IQuat4 =  Quat4.stackCeil.set(v3fVec, 0.) ;
		    var qInverse: IQuat4 = this.inverse( Quat4.stackCeil.set() );
		    var qResult: IQuat4 = this.multiply(q4fVec.multiply(qInverse),  Quat4.stackCeil.set() );

		    v3fDestination.x = qResult.x;
		    v3fDestination.y = qResult.y;
		    v3fDestination.z = qResult.z;

		    return v3fDestination;
		};

		conjugate(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
			    this.x = -this.x;
			    this.y = -this.y;
			    this.z = -this.z;

			    return this;
			}

			q4fDestination.x = -this.x;
			q4fDestination.y = -this.y;
			q4fDestination.z = -this.z;
			q4fDestination.w = this.w;

			return q4fDestination;
		};

		inverse(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
		    var fSqLength:  number  = x*x + y*y + z*z + w*w;

		    if(fSqLength === 0.){
		        q4fDestination.x = 0.;
		        q4fDestination.y = 0.;
		        q4fDestination.z = 0.;
		        q4fDestination.w = 0.;
		    }
		    else{
		        var fInvSqLength :  number = 1./fSqLength;
		        q4fDestination.x = -x*fInvSqLength;
		        q4fDestination.y = -y*fInvSqLength;
		        q4fDestination.z = -z*fInvSqLength;
		        q4fDestination.w =  w*fInvSqLength;
		    }

		    return q4fDestination;
		};

		/**@inline*/  length() :  number {
			var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
    		return sqrt(x*x + y*y + z*z + w*w);
		};

		normalize(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);

		    if(fLength === 0.){
		    	q4fDestination.x = 0.;
		    	q4fDestination.y = 0.;
		    	q4fDestination.z = 0.;
		    	q4fDestination.w = 0.;

		    }
		    else{
		    	var fInvLength:  number  = 1/fLength;

		    	q4fDestination.x = x*fInvLength;
		    	q4fDestination.y = y*fInvLength;
		    	q4fDestination.z = z*fInvLength;
		    	q4fDestination.w = w*fInvLength;
		    }

		    return q4fDestination;
		};

		calculateW(q4fDestination?: IQuat4): IQuat4{
			var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;

		    if(!isDef(q4fDestination)){
		        this.w = sqrt(1. - x*x - y*y - z*z);
		        return this;
		    }

		    q4fDestination.x = x;
		    q4fDestination.y = y;
		    q4fDestination.z = z;
		    q4fDestination.w = sqrt(1. - x*x - y*y - z*z);

		    return q4fDestination;
		};

		isEqual(q4fQuat: IQuat4, fEps:  number  = 0., asMatrix: bool = false): bool{

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

		    var fLength1:  number  = sqrt(x1*x1 + y1*y1 + z1*z1 + w1*w1);
		    var fLength2:  number  = sqrt(x2*x2 + y2*y2 + z2*z2 + w2*w2);

		    if(abs(fLength2 - fLength2) > fEps){
		        return false;
		    }

		    var cosHalfTheta:  number  = (x1*x2 + y1*y2 + z1*z2 + w1*w2)/fLength1/fLength2;

		    if(asMatrix){
		        cosHalfTheta = abs(cosHalfTheta);
		    }

		    if(1. - cosHalfTheta > fEps){
		        return false;
		    }
		    return true;
		};

		getYaw():  number {
		    var fYaw:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;

		    if(abs(x) == abs(w)){
//вырожденный случай обрабатывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        fYaw = atan2(yTemp,wTemp)*2.;
//fRoll = 0;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
		            fYaw -= pi;
//fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
		            fYaw += pi;
//fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
		        fYaw = atan2(fx2*z + fy2*w, 1. - (fx2*x + fy2*y));
		    }

		    return fYaw;
		};

		getPitch():  number {
			var fPitch:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;

/*в очень редких случаях из-за ошибок округления получается результат > 1*/
		    var fSinPitch:  number  = clamp(fx2*w - fy2*z,-1.,1.);
		    fPitch = asin(fSinPitch)

		    return fPitch;
		};

		getRoll():  number {
		    var fRoll:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fz2:  number  = z*2.;

		    if(abs(x) == abs(w)){
//вырожденный случай обрабатывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        var fYaw:  number  = atan2(yTemp,wTemp)*2.;
		        fRoll = 0.;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
//fYaw -= pi;
		            fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
//fYaw += pi;
		            fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
		        fRoll = atan2(fx2*y + fz2*w, 1. - (fx2*x + fz2*z));
		    }

		    return fRoll;
		};

		toYawPitchRoll(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
		        v3fDestination = new Vec3();
		    }

		    var fYaw:  number , fPitch:  number , fRoll:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;
		    var fz2:  number  = z*2.;
		    var fw2:  number  = w*2.;

/*в очень редких случаях из-за ошибок округления получается результат > 1*/
		    var fSinPitch:  number  = clamp(fx2*w - fy2*z,-1.,1.);
		    fPitch = asin(fSinPitch);
//не известен знак косинуса, как следствие это потребует дополнительной проверки.
//как показала практика - это не на что не влияет, просто один и тот же кватернион можно получить двумя разными вращениями

		    if(abs(x) == abs(w)){
//вырожденный случай обрабатывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        fYaw = atan2(yTemp,wTemp)*2.;
		        fRoll = 0.;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
		            fYaw -= pi;
		            fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
		            fYaw += pi;
		            fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
		        fYaw = atan2(fx2*z + fy2*w, 1. - (fx2*x + fy2*y));
//Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
		        fRoll = atan2(fx2*y + fz2*w, 1. - (fx2*x + fz2*z));
		    }

		    v3fDestination.x = fYaw;
		    v3fDestination.y = fPitch;
		    v3fDestination.z = fRoll;

		    return v3fDestination;
		};

		toMat3(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }
		    var pDataDestination: Float32Array = m3fDestination.data;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

//потом необходимо ускорить

		    pDataDestination[ 0 ] = 1. - 2.*(y*y + z*z);
		    pDataDestination[ 3 ] = 2.*(x*y - z*w);
		    pDataDestination[ 6 ] = 2.*(x*z + y*w);

		    pDataDestination[ 1 ] = 2.*(x*y + z*w);
		    pDataDestination[ 4 ] = 1. - 2.*(x*x + z*z);
		    pDataDestination[ 7 ] = 2.*(y*z - x*w);

		    pDataDestination[ 2 ] = 2.*(x*z - y*w);
		    pDataDestination[ 5 ] = 2.*(y*z + x*w);
		    pDataDestination[ 8 ] = 1. - 2.*(x*x + y*y);

		    return m3fDestination;
		};

		toMat4(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }
		    var pDataDestination: Float32Array = m4fDestination.data;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

//потом необходимо ускорить

		    pDataDestination[ 0 ] = 1. - 2.*(y*y + z*z);
		    pDataDestination[ 4 ] = 2.*(x*y - z*w);
		    pDataDestination[ 8 ] = 2.*(x*z + y*w);
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = 2.*(x*y + z*w);
		    pDataDestination[ 5 ] = 1. - 2.*(x*x + z*z);
		    pDataDestination[ 9 ] = 2.*(y*z - x*w);
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = 2.*(x*z - y*w);
		    pDataDestination[ 6 ] = 2.*(y*z + x*w);
		    pDataDestination[ 10 ] = 1. - 2.*(x*x + y*y);
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

    		return m4fDestination;
		};

		/**@inline*/  toString(): string{
			return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
		};

		mix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath: bool = true){
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    fA = clamp(fA,0,1);

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

//скалярное произведение
		    var fCos:  number  = x1*x2 + y1*y2 + z1*z2 + w1*w2;

		    if(fCos < 0. && bShortestPath){
		        x2 = -x2;
		        y2 = -y2;
		        z2 = -z2;
		        w2 = -w2;
		    }

		    var k1:  number  = 1. - fA;
		    var k2:  number  = fA;

		    q4fDestination.x = x1*k1 + x2*k2;
		    q4fDestination.y = y1*k1 + y2*k2;
		    q4fDestination.z = z1*k1 + z2*k2;
		    q4fDestination.w = w1*k1 + w2*k2;

		    return q4fDestination;
		};

		smix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath: bool = true){
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    fA = clamp(fA,0,1);

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

//скалярное произведение
		    var fCos:  number  = x1*x2 + y1*y2 + z1*z2 + w1*w2;

		    if(fCos < 0 && bShortestPath){
		        fCos = -fCos;
		        x2 = -x2;
		        y2 = -y2;
		        z2 = -z2;
		        w2 = -w2;
		    }

		    var fEps:  number  = 1e-3;
		    if(abs(fCos) < 1. - fEps){
		        var fSin:  number  = sqrt(1. - fCos*fCos);
		        var fInvSin:  number  = 1./fSin;

		        var fAngle:  number  = atan2(fSin,fCos);

		        var k1:  number  = sin((1. - fA) * fAngle)*fInvSin;
		        var k2:  number  = sin(fA * fAngle)*fInvSin;

		        q4fDestination.x = x1*k1 + x2*k2;
		        q4fDestination.y = y1*k1 + y2*k2;
		        q4fDestination.z = z1*k1 + z2*k2;
		        q4fDestination.w = w1*k1 + w2*k2;
		    }
		    else{
//два кватерниона или очень близки (тогда можно делать линейную интерполяцию) 
//или два кватениона диаметрально противоположны, тогда можно интерполировать любым способом
//позже надо будет реализовать какой-нибудь, а пока тоже линейная интерполяция

		        var k1:  number  = 1 - fA;
		        var k2:  number  = fA;

		        var x:  number  = x1*k1 + x2*k2;
		        var y:  number  = y1*k1 + y2*k2;
		        var z:  number  = z1*k1 + z2*k2;
		        var w:  number  = w1*k1 + w2*k2;

// и нормализуем так-как мы сошли со сферы

		        var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);
		        var fInvLen:  number  = fLength ? 1/fLength : 0;

		        q4fDestination.x = x*fInvLen;
		        q4fDestination.y = y*fInvLen;
		        q4fDestination.z = z*fInvLen;
		        q4fDestination.w = w*fInvLen;
		    }

		    return q4fDestination;
		};

		static fromForwardUp(v3fForward: IVec3, v3fUp: IVec3, q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var fForwardX:  number  = v3fForward.x, fForwardY:  number  = v3fForward.y, fForwardZ:  number  = v3fForward.z;
		    var fUpX:  number  = v3fUp.x, fUpY:  number  = v3fUp.y, fUpZ:  number  = v3fUp.z;

		    var m3fTemp: IMat3 =  Mat3.stackCeil.set() ;
		    var pTempData: Float32Array = m3fTemp.data;

		    pTempData[ 0 ] = fUpY * fForwardZ - fUpZ * fForwardY;
		    pTempData[ 3 ] = fUpX;
		    pTempData[ 6 ] = fForwardX;

		    pTempData[ 1 ] = fUpZ * fForwardX - fUpX * fForwardZ;
		    pTempData[ 4 ] = fUpY;
		    pTempData[ 7 ] = fForwardY;

		    pTempData[ 2 ] = fUpX * fForwardY - fUpY * fForwardX;
		    pTempData[ 5 ] = fUpZ;
		    pTempData[ 8 ] = fForwardZ;

		    return m3fTemp.toQuat4(q4fDestination);
		};

		static fromAxisAngle(v3fAxis: IVec3, fAngle:  number , q4fDestination?: IQuat4): IQuat4{

			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;

		    var fLength:  number  = sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		        q4fDestination.x = q4fDestination.y = q4fDestination.z = 0;
		        q4fDestination.w = 1;
		        return q4fDestination;
		    }

		    var fInvLength = 1/fLength;

		    x *= fInvLength;
		    y *= fInvLength;
		    z *= fInvLength;

		    var fSin:  number  = sin(fAngle/2);
		    var fCos:  number  = cos(fAngle/2);

		    q4fDestination.x = x * fSin;
		    q4fDestination.y = y * fSin;
		    q4fDestination.z = z * fSin;
		    q4fDestination.w = fCos;

		    return q4fDestination;
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number ,q4fDestination?: IQuat4): IQuat4;
		static fromYawPitchRoll(v3fAngles: IVec3,q4fDestination?: IQuat4): IQuat4;
		static fromYawPitchRoll(fYaw? ,fPitch?, fRoll?, q4fDestination?): IQuat4{
			if(arguments.length <= 2){
				var v3fVec: IVec3 = arguments[0];

				fYaw = v3fVec.x;
				fPitch = v3fVec.y;
				fRoll = v3fVec.z;

				q4fDestination = arguments[1];
			}

			if(!isDef(q4fDestination)){
				q4fDestination = new Quat4();
			}

		    var fHalfYaw:  number  = fYaw * 0.5;
		    var fHalfPitch:  number  = fPitch * 0.5;
		    var fHalfRoll:  number  = fRoll * 0.5;

		    var fCos1:  number  = cos(fHalfYaw), fSin1:  number  = sin(fHalfYaw);
		    var fCos2:  number  = cos(fHalfPitch), fSin2:  number  = sin(fHalfPitch);
		    var fCos3:  number  = cos(fHalfRoll), fSin3:  number  = sin(fHalfRoll);

		    q4fDestination.x = fCos1 * fSin2 * fCos3 + fSin1 * fCos2 * fSin3;
		    q4fDestination.y = fSin1 * fCos2 * fCos3 - fCos1 * fSin2 * fSin3;
		    q4fDestination.z = fCos1 * fCos2 * fSin3 - fSin1 * fSin2 * fCos3;
		    q4fDestination.w = fCos1 * fCos2 * fCos3 + fSin1 * fSin2 * fSin3;

		    return q4fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , q4fDestination?: IQuat4): IQuat4;
		static fromXYZ(v3fAngles: IVec3, q4fDestination?: IQuat4): IQuat4;
		static fromXYZ(fX?, fY?, fZ?, q4fDestination?) : IQuat4{
			if(arguments.length <= 2){
//Vec3 + m4fDestination
				var v3fVec: IVec3 = arguments[0];
				return Quat4.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m4fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Quat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static get stackCeil(): Quat4 { Quat4.stackPosition = Quat4.stackPosition === Quat4.stackSize - 1? 0: Quat4.stackPosition; return Quat4.stack[Quat4.stackPosition ++]; } static stackSize: number = 256; static stackPosition: number = 0; static stack: Quat4[] = (function(): Quat4[]{ var pStack: Quat4[] = new Array(Quat4.stackSize); for(var i: number = 0; i<Quat4.stackSize; i++){ pStack[i] = new Quat4(); } return pStack})();
    }
}











module akra.math {
//
// MATH AND UNIT CONVERSION FUNCTION PROTOTYPES
//

	export var abs = Math.abs;
	export var acos = Math.acos;
	export var asin = Math.asin;
	export var atan = Math.atan;
	export var atan2 = Math.atan2;
	export var exp = Math.exp;
	export var min = Math.min;
	export var random = Math.random;
	export var sqrt = Math.sqrt;
	export var log = Math.log;
	export var round = Math.round;
	export var floor = Math.floor;
	export var ceil = Math.ceil;
	export var sin = Math.sin;
	export var cos = Math.cos;
	export var tan = Math.tan;
	export var pow = Math.pow;
	export var max = Math.max;

/*	
	-----------------------------------------------------------------
	    
		Floating Point Macros
	    
	-----------------------------------------------------------------
	*/

// reinterpret a float as an int32
/** @inline */

	export var fpBits = (f:  number ):  number  => floor(f);

// reinterpret an int32 as a float
/** @inline */

	export var intBits = (i:  number ):  number  => < number > i;

// return 0 or -1 based on the sign of the float
/** @inline */

	export var fpSign = (f:  number ) => (f >> 31);

// extract the 8 bits of exponent as a signed integer
// by masking out this bits, shifting down by 23,
// and subtracting the bias value of 127
/** @inline */

	export var fpExponent = (f:  number ):  number  => (((fpBits(f) & 0x7fffffff) >> 23) - 127);

// return 0 or -1 based on the sign of the exponent
/** @inline */

	export var fpExponentSign = (f:  number ):  number  => (fpExponent(f) >> 31) ;

// get the 23 bits of mantissa without the implied bit
/** @inline */

	export var fpPureMantissa = (f:  number ):  number  => ((fpBits(f) & 0x7fffff));

// get the 23 bits of mantissa with the implied bit replaced
/** @inline */

	export var fpMantissa = (f:  number ):  number  => (fpPureMantissa(f) | (1 << 23));

	export var fpOneBits = 0x3F800000;

// flipSign is a helper Macro to
// invert the sign of i if flip equals -1, 
// if flip equals 0, it does nothing
//export var flipSign = (i, flip) ((i^ flip) - flip)
/** @inline */

	export var flipSign = (i: number, flip: number):  number  => ((flip == -1) ? -i : i);

/**
	 * Абсолютное значение числа
	 */

	export var absoluteValue = abs;
/**
	 * Pow
	 */

	export var raiseToPower = pow;
/**
	 * Число положительно?
	 */

	export var isPositive = (a: number) => (a >= 0);
/**
	 * Число отрицательно?
	 */

	export var isNegative = (a: number) => (a < 0);
/**
	 * Число одного знака?
	 */

	export var sameSigns = (a: number, b: number): bool => (isNegative(a) == isNegative(b));
/**
	 * Копировать знак
	 */

	export var copySign = (a: number, b: number): number => (isNegative(b) ? -absoluteValue(a) : absoluteValue(a));
/**
	 * Растояние между а и b меньше epsilon?
	 */

	export var deltaRangeTest = (a: number, b: number, epsilon: number = 0.0000001): bool => ((absoluteValue(a - b) < epsilon) ? true : false);

/**
	 * Ограничивает value интервалом [low,high]
	 */

	export var clamp = (value: number, low: number, high: number): number => max(low, min(value, high));
/**
	 * Ограничивает value интервалом [0,+Infinity]
	 */

	export var clampPositive = (value: number): number => (value < 0 ? 0 : value);
/**
	 * Ограничивает value интервалом [-Infinity,0]
	 */

	export var clampNegative = (value: number): number => (value > 0 ? 0 : value);
/**
	 * Ограничивает value интервалом [-1,1]
	 */

	export var clampUnitSize = (value: number): number => clamp(value, -1, 1);

	export var sign = (value: number): number => value >= 0? 1: -1;

/**
	 * Номер с права начиная от нуля, самого левого установленного бита
	 */

	export var highestBitSet = (value: number):  number  => value == 0 ? (null) : (value < 0 ? 31 : ((log(value) / LN2) << 0));
/**
	 * Номер с права начиная от нуля, самого правого установленного бита
	 */

	export var lowestBitSet = (value:  number ):  number  => {
		var temp:  number ;

	    if (value == 0) {
	        return null;
	    }

	    for (temp = 0; temp <= 31; temp++) {
	        if (value & (1 << temp)) {
	            return temp;
	        }
	    }

	    return null;
	}

/**
	 * Является ли число степенью двойки
	 */

	export var isPowerOfTwo = (value:  number ): bool => (value > 0 && highestBitSet(value) == lowestBitSet(value));
/**
	 * Округление до числа наиболее близкого к степени двойки
	 */

	export var nearestPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
        	return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);
	    var roundingTest:  number  = value & (1 << (highestBit - 1));

	    if (roundingTest != 0) {
	        ++ highestBit;
	    }

	    return 1 << highestBit;
	}

/**
	 * Округление до следующего числа являющегося к степени двойки
	 */

	export var ceilingPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
	        return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);
	    var mask:  number  = value & ((1 << highestBit) - 1);
	    highestBit += mask && 1;
	    return 1 << highestBit;
	}
/**
	 * Округление до предыдущего числа являющегося к степени двойки
	 */

	export var floorPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
        	return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);

	    return 1 << highestBit;
	}

/**
	 * Деление по модулю
	 */

	export var modulus = (e:  number , divisor:  number ):  number  => (e - floor(e / divisor) * divisor);
/**
	 * 
	 */

	export var mod = modulus;

/**
	 * Вырвнивание числа на alignment вверх
	 */

	export var alignUp = (value:  number , alignment:  number ):  number  => {
		var iRemainder:  number  = modulus(value, alignment);
	    if (iRemainder == 0) {
	        return(value);
	    }

	    return(value + (alignment - iRemainder));
	}


/**
	 * Вырвнивание числа на alignment вниз
	 */

	export var alignDown = (value:  number , alignment:  number ):  number  => {
		var remainder:  number  = modulus(value, alignment);
	    if (remainder == 0) {
	        return(value);
	    }

	    return(value - remainder);
	}

/**
	 * пнвертировать число
	 */

	export var inverse = (a: number): number => 1. / a;
/**
	 * log base 2
	 */

	export var log2 = (f:  number ):  number  => log(f) / LN2;
/**
	 * Округлени числа с определенной точностью, где округляется до значащих чисел как 1/(2^precision)
	 */

	export var trimFloat = (f:  number , precision:  number ):  number  => f;

/**
	 * Перевод дробного в целое с усеением
	 */

	export var realToInt32_chop = (a:  number ):  number  => round(a);
/**
	 * Перевод дробного в целое до меньшего
	 */

	export var realToInt32_floor = (a:  number ):  number  => floor(a);
/**
	 * Перевод дробного в целое до большего
	 */

	export var realToInt32_ceil = (a:  number ):  number  => ceil(a);

/**
	 * Наибольший общий делитель
	 */

	export var nod = (n:  number , m:  number ):  number  => {
		var p:  number  = n % m;

		while (p != 0) {
			n = m
			m = p
			p = n % m
		}

		return m;
	}
/**
	 * Наименьшее общее кратное
	 */

	export var nok = (n:  number , m:  number ):  number  => abs(n * m) / nod(n , m);
/**
	 * Greatest common devider
	 */

	export var gcd = nod;
/**
	 * Least common multiple
	 */

	export var lcm = nok;

// var pMat3Stack = new Array(100);
// var iMat3StackIndex = 0;

	export var isRealEqual = (a:  number , b:  number , tolerance:  number  = 1.19209e-007): bool => {
        if (math.abs(b - a) <= tolerance)
            return true;
        else
            return false;
    }

    export function calcPOTtextureSize (nPixels:  number ):  number [] {
	    var w:  number , h:  number ;
	    var n:  number  = nPixels;


	    w = Math.ceil(Math.log(n) / Math.LN2 / 2.0);
	    h = Math.ceil(Math.log(n / Math.pow(2, w)) / Math.LN2);
	    w = Math.pow(2, w);
	    h = Math.pow(2, h);
	    n = w * h;
	    return [w, h, n];
	}
}



module akra.math {


//    export function vec2(): IVec2;
//    export function vec2(fValue: float): IVec2;
//    export function vec2(v2fVec: IVec2): IVec2;
//    export function vec2(pArray: float[]): IVec2;
//    export function vec2(fValue1: float, fValue2: float): IVec2;
//    export function vec2(fValue1?, fValue2?): IVec2{
//        var nArgumentsLength: uint = arguments.length;
//        var v2fVec: IVec2 = Vec2.stack[Vec2.stackPosition ++];

//        if(Vec2.stackPosition == Vec2.stackSize){
//            Vec2.stackPosition = 0;
//        }

//        switch(nArgumentsLength){
//            case 1:
//                v2fVec.set(arguments[0]);
//                break;
//            case 2:
//                v2fVec.set(arguments[0], arguments[1]);
//                break;
//            default:
//                v2fVec.x = v2fVec.y = 0.;
//                break;
//        }

//        return v2fVec;
//    };

//    export function vec3(): IVec3;
//    export function vec3(fValue: float): IVec3;
//    export function vec3(v3fVec: IVec3): IVec3;
//    export function vec3(pArray: float[]): IVec3;
//    export function vec3(fValue: float, v2fVec: IVec2): IVec3;
//    export function vec3(v2fVec: IVec2, fValue: float): IVec3;
//    export function vec3(fValue1: float, fValue2: float, fValue3: float): IVec3;
//    export function vec3(fValue1?, fValue2?, fValue3?): IVec3{
//        var nArgumentsLength: uint = arguments.length;
//        var v3fVec: IVec3 = Vec3.stack[Vec3.stackPosition ++];

//        if(Vec3.stackPosition == Vec3.stackSize){
//            Vec3.stackPosition = 0;
//        }

//        switch(nArgumentsLength){
//            case 1:
//                v3fVec.set(arguments[0]);
//                break;
//            case 2:
//                v3fVec.set(arguments[0], arguments[1]);
//                break;
//            case 3: 
//                v3fVec.set(arguments[0], arguments[1], arguments[2]);
//                break;
//            default:
//                v3fVec.x = v3fVec.y = v3fVec.z = 0.;
//                break;
//        }

//        return v3fVec;
//    };

//    export function vec4(): IVec4;
//    export function vec4(fValue: float): IVec4;
//    export function vec4(v4fVec: IVec4): IVec4;
//    export function vec4(pArray: float[]): IVec4;
//    export function vec4(fValue: float, v3fVec: IVec3): IVec4;
//    export function vec4(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
//    export function vec4(v3fVec: IVec3, fValue: float): IVec4;
//    export function vec4(fValue1: float, fValue2: float, v2fVec: IVec2): IVec4;
//    export function vec4(fValue1: float, v2fVec: IVec2, fValue2: float): IVec4;
//    export function vec4(v2fVec: IVec2 ,fValue1: float, fValue2: float): IVec4;
//    export function vec4(fValue1: float, fValue2: float, fValue3: float, fValue4: float): IVec4;
//    export function vec4(fValue1?, fValue2?, fValue3?, fValue4?): IVec4{
//        var nArgumentsLength: uint = arguments.length;
//        var v4fVec: IVec4 = Vec4.stack[Vec4.stackPosition ++];

//        if(Vec4.stackPosition == Vec4.stackSize){
//            Vec4.stackPosition = 0;
//        }

//        switch(nArgumentsLength){
//            case 1:
//                v4fVec.set(arguments[0]);
//                break;
//            case 2:
//                v4fVec.set(arguments[0],arguments[1]);
//                break;
//            case 3:
//                v4fVec.set(arguments[0],arguments[1], arguments[2]);
//                break;
//            case 4:
//                v4fVec.set(arguments[0],arguments[1], arguments[2], arguments[3]);
//                break;
//            default: 
//                v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
//                break;
//        }

//        return v4fVec;
//    };

//    export function quat4(): IQuat4;
// export function quat4(q4fQuat: IQuat4): IQuat4;
// export function quat4(pArray: float[]): IQuat4;
// export function quat4(fValue: float, fW: float): IQuat4;
// export function quat4(v3fValue: IVec3, fW: float): IQuat4;
// export function quat4(fX: float, fY: float, fZ: float, fW: float): IQuat4;
// export function quat4(fX?, fY?, fZ?, fW?): IQuat4{
// 	var nArgumentsLength: uint = arguments.length;
// 	var q4fQuat: IQuat4 = Quat4.stack[Quat4.stackPosition ++];

// 	if(Quat4.stackPosition == Quat4.stackSize){
//            Quat4.stackPosition = 0;
// 	}

// 	switch(nArgumentsLength){
// 		case 1:
// 			q4fQuat.set(arguments[0]);
// 			break;
// 		case 2:
// 			q4fQuat.set(arguments[0], arguments[1]);
// 			break;
// 		case 4:
// 			q4fQuat.set(arguments[0], arguments[1], arguments[2], arguments[3]);
// 			break;
// 		default:
// 			q4fQuat.x = q4fQuat.y = q4fQuat.z = 0.;
// 			q4fQuat.w = 1.;
// 			break;
// 	}

// 	return q4fQuat;
// };

// export function mat3(): IMat3;
// export function mat3(fValue: float): IMat3;
// export function mat3(v3fVec: IVec3): IMat3;
// export function mat3(m3fMat: IMat3): IMat3;
// export function mat3(m4fMat: IMat4): IMat3;
// export function mat3(pArray: float[]): IMat3;
// export function mat3(fValue1: float, fValue2: float, fValue3: float): IMat3;
// export function mat3(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
// export function mat3(pArray1: float[], pArray2: float[], pArray3: float[]): IMat3;
// export function mat3(fValue1: float, fValue2: float, fValue3: float,
// 			fValue4: float, fValue5: float, fValue6: float,
// 			fValue7: float, fValue8: float, fValue9: float): IMat3;
// export function mat3(fValue1?, fValue2?, fValue3?,
// 			fValue4?, fValue5?, fValue6?,
// 			fValue7?, fValue8?, fValue9?): IMat3{

// 	var nArgumentsLength: uint = arguments.length;
// 	var m3fMat: IMat3 = Mat3.stack[Mat3.stackPosition ++];

//        if(Mat3.stackPosition == Mat3.stackSize){
//            Mat3.stackPosition = 0;
// 	}

// 	switch(nArgumentsLength){
// 		case 1:
// 			m3fMat.set(arguments[0]);
// 			break;
// 		case 3:
// 			m3fMat.set(arguments[0], arguments[1], arguments[2]);
// 			break;
// 		case 9:
// 			m3fMat.set(arguments[0], arguments[1], arguments[2],
// 					 arguments[3], arguments[4], arguments[5],
// 					 arguments[6], arguments[7], arguments[8]);
// 			break;
// 		default:
// 			m3fMat.set(0.);
// 			break;
// 	}

// 	return m3fMat;
// };

// export function mat4(): IMat4;
// export function mat4(fValue: float): IMat4;
// export function mat4(v4fVec: IVec4): IMat4;
// export function mat4(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
// export function mat4(m4fMat: IMat4): IMat4;
// export function mat4(pArray: float[]): IMat4;
// export function mat4(pArray: Float32Array, bFlag: bool): IMat4;
// export function mat4(fValue1: float, fValue2: float,
// 		fValue3: float, fValue4: float): IMat4;
// export function mat4(v4fVec1: IVec4, v4fVec2: IVec4,
// 		v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
// export function mat4(pArray1: float[], pArray2: float[],
// 		pArray3: float[], pArray4: float[]): IMat4;
// export function mat4(fValue1: float, fValue2: float, fValue3: float, fValue4: float,
// 		fValue5: float, fValue6: float, fValue7: float, fValue8: float,
// 		fValue9: float, fValue10: float, fValue11: float, fValue12: float,
// 		fValue13: float, fValue14: float, fValue15: float, fValue16: float): IMat4;
// export function mat4(fValue1?, fValue2?, fValue3?, fValue4?,
// 			fValue5?, fValue6?, fValue7?, fValue8?,
// 			fValue9?, fValue10?, fValue11?, fValue12?,
// 			fValue13?, fValue14?, fValue15?, fValue16?): IMat4{

// 	var nArgumentsLength: uint = arguments.length;
// 	var m4fMat: IMat4 = Mat4.stack[Mat4.stackPosition ++];

//        if(Mat4.stackPosition == Mat4.stackSize){
//            Mat4.stackPosition = 0;
// 	}

// 	if(nArgumentsLength === 2){
// 		if(isBoolean(arguments[1])){
// 			if(arguments[1]){
// 				m4fMat.data = arguments[0];
// 			}
// 			else{
// 				m4fMat.set(arguments[0]);			
// 			}
// 		}
// 		else{
// 			m4fMat.set(arguments[0], arguments[1]);
// 		}
// 	}
// 	else{
// 		switch(nArgumentsLength){
// 			case 1:
// 				if(arguments[0] instanceof Mat3){
// 					m4fMat.set(arguments[0],vec3(0.));	
// 				}
// 				else{
// 					m4fMat.set(arguments[0]);	
// 				}	
// 				break;
// 			case 4:
// 				m4fMat.set(arguments[0],arguments[1],arguments[2],arguments[3]);
// 				break;
// 			case 16:
// 				m4fMat.set(arguments[0], arguments[1], arguments[2], arguments[3],
// 					 arguments[4], arguments[5], arguments[6], arguments[7],
// 					 arguments[8], arguments[9], arguments[10], arguments[11],
// 					 arguments[12], arguments[13], arguments[14], arguments[15]);
// 				 break;
// 			 default:
// 			 	break;	
// 		}
// 	}

// 	return m4fMat;
// };

	export function floatToFloat3(value:  number ): IVec3 {
		var data:  number  = value;
		var result: IVec3 =  Vec3.stackCeil.set(0.) ;

		if (data == 0.) {
			var signedZeroTest:  number  = 1. / value;

			if(signedZeroTest < 0.) {
				result.x = 128.;
			}

			return result;
		}

		if(data < 0.) {
			result.x = 128.;
			data = -data;
		}

		var power:  number  = 0.;
		var counter:  number  = 0.;

		while (counter < 64.) {
			counter += 1.;

			if(data >= 2.) {
				data = data * 0.5;
				power += 1.;
				if (power == 63.) {
					counter = 65.;
				}
			}
			else{
				if(data < 1.) {
					data = data * 2.;
					power -= 1.;
					if (power == -62.) {
						counter = 65.;
					}
				}
				else {
					counter = 65.;
				}
			}
		}

		if (power == -62. && data < 1.) {
			power = 0.;
		}
		else {
			power = power + 63.;
			data = data - 1.;
		}

		result.x += power;

		data *= 256.;

		result.y = floor(data);

		data -= floor(data);
		data *= 256.;

		result.z = floor(data);

		return result;
	}

}

module akra {
	export var Vec2 = math.Vec2;
	export var Vec3 = math.Vec3;
	export var Vec4 = math.Vec4;

	export var Mat3 = math.Mat3;
	export var Mat4 = math.Mat4;
	export var Quat4 = math.Quat4;

// export var vec2 = math.vec2;
// export var vec3 = math.vec3;
// export var vec4 = math.vec4;
// export var quat4 = math.quat4;
// export var mat3 = math.mat3;
// export var mat4 = math.mat4;
}




module akra.util {

	export class Color implements IColor {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;

		constructor ();
		constructor (cColor: IColor);
		constructor (pData: ArrayBufferView);
		constructor (r:  number , g:  number , b:  number , a:  number );
		constructor (r:  number , g:  number , b:  number );
		constructor (fGray:  number , fAlpha:  number );
		constructor (fGray:  number );
		constructor (r?: any, g?: any, b?: any, a?: any) {
			this.set.apply(this, arguments);
		}

		get html(): string {
// LOG(this.r, this.g, this.b);
			var r = math.round(this.r * 255).toString(16);
			var g = math.round(this.g * 255).toString(16);
			var b = math.round(this.b * 255).toString(16);
			r = r.length < 2? "0" + r: r;
			g = g.length < 2? "0" + g: g;
			b = b.length < 2? "0" + b: b;
// LOG(r, g, b);
			return "#" + r + g + b;
		}

		get htmlRgba(): string {
			return "rgba(" +
				math.floor(255 * this.r) + ", " +
				math.floor(255 * this.g) + ", " +
				math.floor(255 * this.b) + ", "
				+ this.a + ")"
		}

		get rgba():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.a * 255) << 24;
	        val32 += < number >(this.b * 255) << 16;
	        val32 += < number >(this.g * 255) << 8;
	        val32 += < number >(this.r * 255);
	        val32 = val32 >>> 0;
	        return val32;
		}

		get argb():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.b * 255) << 24;
	        val32 += < number >(this.g * 255) << 16;
	        val32 += < number >(this.r * 255) << 8;
	        val32 += < number >(this.a * 255);
	        val32 = val32 >>> 0;
	        return val32;
		}

		get bgra():  number  {
	        var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.a * 255) << 24;
	        val32 += < number >(this.r * 255) << 16;
	        val32 += < number >(this.g * 255) << 8;
	        val32 += < number >(this.b * 255);
	        val32 = val32 >>> 0;
	        return val32;
		}

		get abgr():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.r * 255) << 24;
	        val32 += < number >(this.g * 255) << 16;
	        val32 += < number >(this.b * 255) << 8;
	        val32 += < number >(this.a * 255);
	        val32 = val32 >>> 0;
	        return val32;
		}

		set rgba(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.a = ((val32 >> 24) & 0xFF) / 255.0;
	        this.b = ((val32 >> 16) & 0xFF) / 255.0;
	        this.g = ((val32 >> 8) & 0xFF) / 255.0;
	        this.r = (val32 & 0xFF) / 255.0;

		}

		set argb(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.b = ((val32 >> 24) & 0xFF) / 255.0;
	        this.g = ((val32 >> 16) & 0xFF) / 255.0;
	        this.r = ((val32 >> 8) & 0xFF) / 255.0;
	        this.a = (val32 & 0xFF) / 255.0;

		}

		set bgra(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.a = ((val32 >> 24) & 0xFF) / 255.0;
	        this.r = ((val32 >> 16) & 0xFF) / 255.0;
	        this.g = ((val32 >> 8) & 0xFF) / 255.0;
	        this.b = (val32 & 0xFF) / 255.0;

		}

		set abgr(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.r = ((val32 >> 24) & 0xFF) / 255.0;
	        this.g = ((val32 >> 16) & 0xFF) / 255.0;
	        this.b = ((val32 >> 8) & 0xFF) / 255.0;
	        this.a = (val32 & 0xFF) / 255.0;

		}

		set(): IColor;
		set(cColor: IColorValue): IColor;
		set(pData: ArrayBufferView): IColor;
		set(cColor: IColor): IColor;
		set(r:  number , g:  number , b:  number , a:  number ): IColor;
		set(r:  number , g:  number , b:  number ): IColor;
		set(fGray:  number , fAlpha:  number ): IColor;
		set(fGray:  number ): IColor;
		set(r?: any, g?: any, b?: any, a?: any): IColor {
			switch (arguments.length) {
				case 0:
					this.r = this.g = this.b = 0.;
					this.a = 1.;
					break;
				case 1:
					if (isInt(arguments[0])) {
						this.r = this.g = this.b = < number >r;
						this.a = 1.;
					}
					else if (isDef(arguments[0].buffer)) {
						var c: ArrayBufferView = <ArrayBufferView>arguments[0];
						this.r = c[0];
						this.g = c[1];
						this.b = c[2];
						this.a = c[3];
					}
					else {
						var v: IColorValue = <IColorValue>arguments[0];
						this.r = v.r;
						this.g = v.g;
						this.b = v.b;
						this.a = v.a;
					}
					break;
				case 2:
					this.r = this.g = this.b = < number >r;
					this.a = < number >g;
					break;
				case 3:
				case 4:
					this.r = < number >r;
					this.g = < number >g;
					this.b = < number >b;
					this.a = isDef(a)? < number >a: 1.;
					break;
			}

			return this;
		}

        saturate(): IColor {
        	if (this.r < 0.)
                this.r = 0.;
            else if (this.r > 1.)
                this.r = 1.;

            if (this.g < 0.)
                this.g = 0.;
            else if (this.g > 1.)
                this.g = 1.;

            if (this.b < 0.)
                this.b = 0.;
            else if (this.b > 1.)
                this.b = 1.;

            if (this.a < 0.)
                this.a = 0.;
            else if (this.a > 1.)
                this.a = 1.;

        	return this;
        }

/** As saturate, except that this colour value is unaffected and
		    the saturated colour value is returned as a copy. */

		saturateCopy(): IColor {
			var ret: IColor = new Color(this);
            ret.saturate();
            return ret;
		}

		add(cColor: IColor, ppDest: IColor = new Color): IColor {

            ppDest.r = this.r + cColor.r;
            ppDest.g = this.g + cColor.g;
            ppDest.b = this.b + cColor.b;
            ppDest.a = this.a + cColor.a;

            return ppDest;
		}

		subtract(cColor: IColor, ppDest: IColor = new Color): IColor {
			ppDest.r = this.r - cColor.r;
            ppDest.g = this.g - cColor.g;
            ppDest.b = this.b - cColor.b;
            ppDest.a = this.a - cColor.a;

            return ppDest;
		}

		multiply(cColor: IColor, ppDest?: IColor): IColor;
		multiply(fScalar:  number , ppDest?: IColor): IColor;
		multiply(fScalar: any, ppDest: IColor = new Color): IColor {
			if (isNumber(fScalar)) {
				var f:  number  = < number >fScalar;
				ppDest.r = this.r * f;
	            ppDest.g = this.g * f;
	            ppDest.b = this.b * f;
	            ppDest.a = this.a * f;
			}
			else {
				var c: IColor = <IColor>arguments[0];
				ppDest.r = this.r * c.r;
	            ppDest.g = this.g * c.g;
	            ppDest.b = this.b * c.b;
	            ppDest.a = this.a * c.a;
			}

            return ppDest;
		}


		divide(cColor: IColor, ppDest?: IColor): IColor;
		divide(fScalar:  number , ppDest?: IColor): IColor;
		divide(fScalar: any, ppDest: IColor = new Color): IColor {
			if (isNumber(fScalar)) {
				var f:  number  = < number >fScalar;
				ppDest.r = this.r / f;
	            ppDest.g = this.g / f;
	            ppDest.b = this.b / f;
	            ppDest.a = this.a / f;
			}
			else {
				var c: IColor = <IColor>arguments[0];
				ppDest.r = this.r / c.r;
	            ppDest.g = this.g / c.g;
	            ppDest.b = this.b / c.b;
	            ppDest.a = this.a / c.a;
			}

            return ppDest;
		}

		setHSB(fHue:  number , fSaturation:  number , fBrightness:  number ): IColor {
// wrap hue
			if (fHue > 1.0) {
				fHue -= < number >fHue;
			}
			else if (fHue < 0.0) {
				fHue += < number >fHue + 1;
			}

// clamp saturation / fBrightness
			fSaturation = math.min(fSaturation, 1.0);
			fSaturation = math.max(fSaturation, 0.0);
			fBrightness = math.min(fBrightness, 1.0);
			fBrightness = math.max(fBrightness, 0.0);

			if (fBrightness == 0.0) {
// early exit, this has to be black
				this.r = this.g = this.b = 0.0;
				return;
			}

			if (fSaturation == 0.0) {
// early exit, this has to be grey

				this.r = this.g = this.b = fBrightness;
				return;
			}


			var fHueDomain:  number   = fHue * 6.0;
			if (fHueDomain >= 6.0)
			{
// wrap around, and allow mathematical errors
				fHueDomain = 0.0;
			}

			var domain:  number  = < number >fHueDomain;
			var f1:  number  = fBrightness * (1 - fSaturation);
			var f2:  number  = fBrightness * (1 - fSaturation * (fHueDomain - domain));
			var f3:  number  = fBrightness * (1 - fSaturation * (1 - (fHueDomain - domain)));

			switch (domain) {
			case 0:
// red domain; green ascends
				this.r = fBrightness;
				this.g = f3;
				this.b = f1;
				break;
			case 1:
// yellow domain; red descends
				this.r = f2;
				this.g = fBrightness;
				this.b = f1;
				break;
			case 2:
// green domain; blue ascends
				this.r = f1;
				this.g = fBrightness;
				this.b = f3;
				break;
			case 3:
// cyan domain; green descends
				this.r = f1;
				this.g = f2;
				this.b = fBrightness;
				break;
			case 4:
// blue domain; red ascends
				this.r = f3;
				this.g = f1;
				this.b = fBrightness;
				break;
			case 5:
// magenta domain; blue descends
				this.r = fBrightness;
				this.g = f1;
				this.b = f2;
				break;
			}

			return this;
		}

		getHSB(pHsb:  number [] = [0., 0., 0.]):  number [] {
			var vMin:  number  = math.min(this.r, math.min(this.g, this.b));
			var vMax:  number  = math.max(this.r, math.max(this.g, this.b));
			var delta:  number  = vMax - vMin;

			var brightness:  number  = vMax;
			var hue:  number  = 0.;
			var saturation:  number ;

			if (math.isRealEqual(delta, 0.0, 1e-6)) {
// grey
				hue = 0.;
				saturation = 0.;
			}
			else {
// a colour
				saturation = delta / vMax;

				var deltaR:  number  = (((vMax - this.r) / 6.0) + (delta / 2.0)) / delta;
				var deltaG:  number  = (((vMax - this.g) / 6.0) + (delta / 2.0)) / delta;
				var deltaB:  number  = (((vMax - this.b) / 6.0) + (delta / 2.0)) / delta;

				if (math.isRealEqual(this.r, vMax))
					hue = deltaB - deltaG;
				else if (math.isRealEqual(this.g, vMax))
					hue = 0.3333333 + deltaR - deltaB;
				else if (math.isRealEqual(this.b, vMax))
					hue = 0.6666667 + deltaG - deltaR;

				if (hue < 0.0)
					hue += 1.0;
				if (hue > 1.0)
					hue -= 1.0;
			}

			pHsb[0] = hue;
			pHsb[1] = saturation;
			pHsb[2] = brightness;

			return pHsb;
		}

		toString(): string {
			return "{R: " + this.r + ", G: " + this.g + ", B: " + this.b + ", A: " + this.a + "} " +
			"( 0x" + this.rgba.toString(16) + " )";
		}

		static toFloat32Array(pValue: IColorValue): Float32Array {
			var pArr: Float32Array = new Float32Array(4);

			pArr[0] = pValue.r;
			pArr[1] = pValue.g;
			pArr[2] = pValue.b;
			pArr[3] = pValue.a;

			return pArr;
		}

		static BLACK: IColor = new Color(0);
		static WHITE: IColor = new Color(0xFF, 0xFF, 0xFF);
		static ZERO: IColor = new Color(0., 0., 0., 0.);

		static isEqual(c1: IColorValue, c2: IColorValue): bool {
			return 	c1.r === c2.r &&
					c1.g === c2.g &&
					c1.b === c2.b &&
					c1.a === c2.a;
		}


static ALICE_BLUE: IColor = new Color(0xF0 / 255., 0xF8 / 255., 0xFF / 255.);
static ANTIQUE_WHITE: IColor = new Color(0xFA / 255., 0xEB / 255., 0xD7 / 255.);
static AQUA: IColor = new Color(0x00 / 255., 0xFF / 255., 0xFF / 255.);
static AQUA_MARINE: IColor = new Color(0x7F / 255., 0xFF / 255., 0xD4 / 255.);
static AZURE: IColor = new Color(0xF0 / 255., 0xFF / 255., 0xFF / 255.);
static BEIGE: IColor = new Color(0xF5 / 255., 0xF5 / 255., 0xDC / 255.);
static BISQUE: IColor = new Color(0xFF / 255., 0xE4 / 255., 0xC4 / 255.);
// static BLACK: IColor = new Color(0x00 / 255., 0x00 / 255., 0x00 / 255.);
static BLANCHED_ALMOND: IColor = new Color(0xFF / 255., 0xEB / 255., 0xCD / 255.);
static BLUE: IColor = new Color(0x00 / 255., 0x00 / 255., 0xFF / 255.);
static BLUE_VIOLET: IColor = new Color(0x8A / 255., 0x2B / 255., 0xE2 / 255.);
static BROWN: IColor = new Color(0xA5 / 255., 0x2A / 255., 0x2A / 255.);
static BURLY_WOOD: IColor = new Color(0xDE / 255., 0xB8 / 255., 0x87 / 255.);
static CADET_BLUE: IColor = new Color(0x5F / 255., 0x9E / 255., 0xA0 / 255.);
static CHARTREUSE: IColor = new Color(0x7F / 255., 0xFF / 255., 0x00 / 255.);
static CHOCOLATE: IColor = new Color(0xD2 / 255., 0x69 / 255., 0x1E / 255.);
static CORAL: IColor = new Color(0xFF / 255., 0x7F / 255., 0x50 / 255.);
static CORNFLOWER_BLUE: IColor = new Color(0x64 / 255., 0x95 / 255., 0xED / 255.);
static CORNSILK: IColor = new Color(0xFF / 255., 0xF8 / 255., 0xDC / 255.);
static CRIMSON: IColor = new Color(0xDC / 255., 0x14 / 255., 0x3C / 255.);
static CYAN: IColor = new Color(0x00 / 255., 0xFF / 255., 0xFF / 255.);
static DARK_BLUE: IColor = new Color(0x00 / 255., 0x00 / 255., 0x8B / 255.);
static DARK_CYAN: IColor = new Color(0x00 / 255., 0x8B / 255., 0x8B / 255.);
static DARK_GOLDEN_ROD: IColor = new Color(0xB8 / 255., 0x86 / 255., 0x0B / 255.);
static DARK_GRAY: IColor = new Color(0xA9 / 255., 0xA9 / 255., 0xA9 / 255.);
static DARK_GREEN: IColor = new Color(0x00 / 255., 0x64 / 255., 0x00 / 255.);
static DARK_KHAKI: IColor = new Color(0xBD / 255., 0xB7 / 255., 0x6B / 255.);
static DARK_MAGENTA: IColor = new Color(0x8B / 255., 0x00 / 255., 0x8B / 255.);
static DARK_OLIVE_GREEN: IColor = new Color(0x55 / 255., 0x6B / 255., 0x2F / 255.);
static DARK_ORANGE: IColor = new Color(0xFF / 255., 0x8C / 255., 0x00 / 255.);
static DARK_ORCHID: IColor = new Color(0x99 / 255., 0x32 / 255., 0xCC / 255.);
static DARK_RED: IColor = new Color(0x8B / 255., 0x00 / 255., 0x00 / 255.);
static DARK_SALMON: IColor = new Color(0xE9 / 255., 0x96 / 255., 0x7A / 255.);
static DARK_SEA_GREEN: IColor = new Color(0x8F / 255., 0xBC / 255., 0x8F / 255.);
static DARK_SLATE_BLUE: IColor = new Color(0x48 / 255., 0x3D / 255., 0x8B / 255.);
static DARK_SLATE_GRAY: IColor = new Color(0x2F / 255., 0x4F / 255., 0x4F / 255.);
static DARK_TURQUOISE: IColor = new Color(0x00 / 255., 0xCE / 255., 0xD1 / 255.);
static DARK_VIOLET: IColor = new Color(0x94 / 255., 0x00 / 255., 0xD3 / 255.);
static DEEP_PINK: IColor = new Color(0xFF / 255., 0x14 / 255., 0x93 / 255.);
static DEEP_SKY_BLUE: IColor = new Color(0x00 / 255., 0xBF / 255., 0xFF / 255.);
static DIM_GRAY: IColor = new Color(0x69 / 255., 0x69 / 255., 0x69 / 255.);
static DIM_GREY: IColor = new Color(0x69 / 255., 0x69 / 255., 0x69 / 255.);
static DODGER_BLUE: IColor = new Color(0x1E / 255., 0x90 / 255., 0xFF / 255.);
static FIRE_BRICK: IColor = new Color(0xB2 / 255., 0x22 / 255., 0x22 / 255.);
static FLORAL_WHITE: IColor = new Color(0xFF / 255., 0xFA / 255., 0xF0 / 255.);
static FOREST_GREEN: IColor = new Color(0x22 / 255., 0x8B / 255., 0x22 / 255.);
static FUCHSIA: IColor = new Color(0xFF / 255., 0x00 / 255., 0xFF / 255.);
static GAINSBORO: IColor = new Color(0xDC / 255., 0xDC / 255., 0xDC / 255.);
static GHOST_WHITE: IColor = new Color(0xF8 / 255., 0xF8 / 255., 0xFF / 255.);
static GOLD: IColor = new Color(0xFF / 255., 0xD7 / 255., 0x00 / 255.);
static GOLDEN_ROD: IColor = new Color(0xDA / 255., 0xA5 / 255., 0x20 / 255.);
static GRAY: IColor = new Color(0x80 / 255., 0x80 / 255., 0x80 / 255.);
static GREEN: IColor = new Color(0x00 / 255., 0x80 / 255., 0x00 / 255.);
static GREEN_YELLOW: IColor = new Color(0xAD / 255., 0xFF / 255., 0x2F / 255.);
static HONEY_DEW: IColor = new Color(0xF0 / 255., 0xFF / 255., 0xF0 / 255.);
static HOT_PINK: IColor = new Color(0xFF / 255., 0x69 / 255., 0xB4 / 255.);
static INDIAN_RED: IColor = new Color(0xCD / 255., 0x5C / 255., 0x5C / 255.);
static INDIGO: IColor = new Color(0x4B / 255., 0x00 / 255., 0x82 / 255.);
static IVORY: IColor = new Color(0xFF / 255., 0xFF / 255., 0xF0 / 255.);
static KHAKI: IColor = new Color(0xF0 / 255., 0xE6 / 255., 0x8C / 255.);
static LAVENDER: IColor = new Color(0xE6 / 255., 0xE6 / 255., 0xFA / 255.);
static LAVENDER_BLUSH: IColor = new Color(0xFF / 255., 0xF0 / 255., 0xF5 / 255.);
static LAWN_GREEN: IColor = new Color(0x7C / 255., 0xFC / 255., 0x00 / 255.);
static LEMON_CHIFFON: IColor = new Color(0xFF / 255., 0xFA / 255., 0xCD / 255.);
static LIGHT_BLUE: IColor = new Color(0xAD / 255., 0xD8 / 255., 0xE6 / 255.);
static LIGHT_CORAL: IColor = new Color(0xF0 / 255., 0x80 / 255., 0x80 / 255.);
static LIGHT_CYAN: IColor = new Color(0xE0 / 255., 0xFF / 255., 0xFF / 255.);
static LIGHT_GOLDEN_ROD_YELLOW: IColor = new Color(0xFA / 255., 0xFA / 255., 0xD2 / 255.);
static LIGHT_GRAY: IColor = new Color(0xD3 / 255., 0xD3 / 255., 0xD3 / 255.);
static LIGHT_GREEN: IColor = new Color(0x90 / 255., 0xEE / 255., 0x90 / 255.);
static LIGHT_PINK: IColor = new Color(0xFF / 255., 0xB6 / 255., 0xC1 / 255.);
static LIGHT_SALMON: IColor = new Color(0xFF / 255., 0xA0 / 255., 0x7A / 255.);
static LIGHT_SEA_GREEN: IColor = new Color(0x20 / 255., 0xB2 / 255., 0xAA / 255.);
static LIGHT_SKY_BLUE: IColor = new Color(0x87 / 255., 0xCE / 255., 0xFA / 255.);
static LIGHT_SLATE_GRAY: IColor = new Color(0x77 / 255., 0x88 / 255., 0x99 / 255.);
static LIGHT_STEEL_BLUE: IColor = new Color(0xB0 / 255., 0xC4 / 255., 0xDE / 255.);
static LIGHT_YELLOW: IColor = new Color(0xFF / 255., 0xFF / 255., 0xE0 / 255.);
static LIME: IColor = new Color(0x00 / 255., 0xFF / 255., 0x00 / 255.);
static LIME_GREEN: IColor = new Color(0x32 / 255., 0xCD / 255., 0x32 / 255.);
static LINEN: IColor = new Color(0xFA / 255., 0xF0 / 255., 0xE6 / 255.);
static MAGENTA: IColor = new Color(0xFF / 255., 0x00 / 255., 0xFF / 255.);
static MAROON: IColor = new Color(0x80 / 255., 0x00 / 255., 0x00 / 255.);
static MEDIUM_AQUA_MARINE: IColor = new Color(0x66 / 255., 0xCD / 255., 0xAA / 255.);
static MEDIUM_BLUE: IColor = new Color(0x00 / 255., 0x00 / 255., 0xCD / 255.);
static MEDIUM_ORCHID: IColor = new Color(0xBA / 255., 0x55 / 255., 0xD3 / 255.);
static MEDIUM_PURPLE: IColor = new Color(0x93 / 255., 0x70 / 255., 0xDB / 255.);
static MEDIUM_SEA_GREEN: IColor = new Color(0x3C / 255., 0xB3 / 255., 0x71 / 255.);
static MEDIUM_SLATE_BLUE: IColor = new Color(0x7B / 255., 0x68 / 255., 0xEE / 255.);
static MEDIUM_SPRING_GREEN: IColor = new Color(0x00 / 255., 0xFA / 255., 0x9A / 255.);
static MEDIUM_TURQUOISE: IColor = new Color(0x48 / 255., 0xD1 / 255., 0xCC / 255.);
static MEDIUM_VIOLET_RED: IColor = new Color(0xC7 / 255., 0x15 / 255., 0x85 / 255.);
static MIDNIGHT_BLUE: IColor = new Color(0x19 / 255., 0x19 / 255., 0x70 / 255.);
static MINT_CREAM: IColor = new Color(0xF5 / 255., 0xFF / 255., 0xFA / 255.);
static MISTY_ROSE: IColor = new Color(0xFF / 255., 0xE4 / 255., 0xE1 / 255.);
static MOCCASIN: IColor = new Color(0xFF / 255., 0xE4 / 255., 0xB5 / 255.);
static NAVAJO_WHITE: IColor = new Color(0xFF / 255., 0xDE / 255., 0xAD / 255.);
static NAVY: IColor = new Color(0x00 / 255., 0x00 / 255., 0x80 / 255.);
static OLD_LACE: IColor = new Color(0xFD / 255., 0xF5 / 255., 0xE6 / 255.);
static OLIVE: IColor = new Color(0x80 / 255., 0x80 / 255., 0x00 / 255.);
static OLIVE_DRAB: IColor = new Color(0x6B / 255., 0x8E / 255., 0x23 / 255.);
static ORANGE: IColor = new Color(0xFF / 255., 0xA5 / 255., 0x00 / 255.);
static ORANGE_RED: IColor = new Color(0xFF / 255., 0x45 / 255., 0x00 / 255.);
static ORCHID: IColor = new Color(0xDA / 255., 0x70 / 255., 0xD6 / 255.);
static PALE_GOLDEN_ROD: IColor = new Color(0xEE / 255., 0xE8 / 255., 0xAA / 255.);
static PALE_GREEN: IColor = new Color(0x98 / 255., 0xFB / 255., 0x98 / 255.);
static PALE_TURQUOISE: IColor = new Color(0xAF / 255., 0xEE / 255., 0xEE / 255.);
static PALE_VIOLET_RED: IColor = new Color(0xDB / 255., 0x70 / 255., 0x93 / 255.);
static PAPAYA_WHIP: IColor = new Color(0xFF / 255., 0xEF / 255., 0xD5 / 255.);
static PEACH_PUFF: IColor = new Color(0xFF / 255., 0xDA / 255., 0xB9 / 255.);
static PERU: IColor = new Color(0xCD / 255., 0x85 / 255., 0x3F / 255.);
static PINK: IColor = new Color(0xFF / 255., 0xC0 / 255., 0xCB / 255.);
static PLUM: IColor = new Color(0xDD / 255., 0xA0 / 255., 0xDD / 255.);
static POWDER_BLUE: IColor = new Color(0xB0 / 255., 0xE0 / 255., 0xE6 / 255.);
static PURPLE: IColor = new Color(0x80 / 255., 0x00 / 255., 0x80 / 255.);
static RED: IColor = new Color(0xFF / 255., 0x00 / 255., 0x00 / 255.);
static ROSY_BROWN: IColor = new Color(0xBC / 255., 0x8F / 255., 0x8F / 255.);
static ROYAL_BLUE: IColor = new Color(0x41 / 255., 0x69 / 255., 0xE1 / 255.);
static SADDLE_BROWN: IColor = new Color(0x8B / 255., 0x45 / 255., 0x13 / 255.);
static SALMON: IColor = new Color(0xFA / 255., 0x80 / 255., 0x72 / 255.);
static SANDY_BROWN: IColor = new Color(0xF4 / 255., 0xA4 / 255., 0x60 / 255.);
static SEA_GREEN: IColor = new Color(0x2E / 255., 0x8B / 255., 0x57 / 255.);
static SEA_SHELL: IColor = new Color(0xFF / 255., 0xF5 / 255., 0xEE / 255.);
static SIENNA: IColor = new Color(0xA0 / 255., 0x52 / 255., 0x2D / 255.);
static SILVER: IColor = new Color(0xC0 / 255., 0xC0 / 255., 0xC0 / 255.);
static SKY_BLUE: IColor = new Color(0x87 / 255., 0xCE / 255., 0xEB / 255.);
static SLATE_BLUE: IColor = new Color(0x6A / 255., 0x5A / 255., 0xCD / 255.);
static SLATE_GRAY: IColor = new Color(0x70 / 255., 0x80 / 255., 0x90 / 255.);
static SNOW: IColor = new Color(0xFF / 255., 0xFA / 255., 0xFA / 255.);
static SPRING_GREEN: IColor = new Color(0x00 / 255., 0xFF / 255., 0x7F / 255.);
static STEEL_BLUE: IColor = new Color(0x46 / 255., 0x82 / 255., 0xB4 / 255.);
static TAN: IColor = new Color(0xD2 / 255., 0xB4 / 255., 0x8C / 255.);
static TEAL: IColor = new Color(0x00 / 255., 0x80 / 255., 0x80 / 255.);
static THISTLE: IColor = new Color(0xD8 / 255., 0xBF / 255., 0xD8 / 255.);
static TOMATO: IColor = new Color(0xFF / 255., 0x63 / 255., 0x47 / 255.);
static TURQUOISE: IColor = new Color(0x40 / 255., 0xE0 / 255., 0xD0 / 255.);
static VIOLET: IColor = new Color(0xEE / 255., 0x82 / 255., 0xEE / 255.);
static WHEAT: IColor = new Color(0xF5 / 255., 0xDE / 255., 0xB3 / 255.);
// static WHITE: IColor = new Color(0xFF / 255., 0xFF / 255., 0xFF / 255.);
static WHITE_SMOKE: IColor = new Color(0xF5 / 255., 0xF5 / 255., 0xF5 / 255.);
static YELLOW: IColor = new Color(0xFF / 255., 0xFF / 255., 0x00 / 255.);
static YELLOW_GREEN: IColor = new Color(0x9A / 255., 0xCD / 255., 0x32 / 255.);

		static get stackCeil(): Color { Color.stackPosition = Color.stackPosition === Color.stackSize - 1? 0: Color.stackPosition; return Color.stack[Color.stackPosition ++]; } static stackSize: number = 20; static stackPosition: number = 0; static stack: Color[] = (function(): Color[]{ var pStack: Color[] = new Array(Color.stackSize); for(var i: number = 0; i<Color.stackSize; i++){ pStack[i] = new Color(); } return pStack})(); ;
	}

	var pVariousColors: string[] = ["BLUE", "BLUE_VIOLET", "BROWN", "CADET_BLUE", "CHARTREUSE", "CRIMSON", "CYAN",
		"DEEP_PINK", "DEEP_SKY_BLUE", "DODGER_BLUE", "FIRE_BRICK", "FUCHSIA", "GOLD", "GREEN", "GREEN_YELLOW",
		"HOT_PINK", "LAWN_GREEN", "LIME", "LIME_GREEN", "MAGENTA", "MEDIUM_BLUE", "MEDIUM_ORCHID", "MEDIUM_SPRING_GREEN",
		"MEDIUM_VIOLET_RED", "ORANGE", "ORANGE_RED", "PURPLE", "RED", "SPRING_GREEN", "STEEL_BLUE", "TOMATO", "TURQUOISE",
		"VIOLET", "WHEAT", "YELLOW", "YELLOW_GREEN"];
	var iVariousColor:  number  = 0;

	export function randomColor(bVarious: bool = false): IColor {
		if (!bVarious) {
			return new Color(Math.random(), Math.random(), Math.random(), 1.);
		}

		if (iVariousColor === pVariousColors.length) {
			iVariousColor = 0;
		}

		return (<any>Color)[pVariousColors[iVariousColor ++]] || Color.WHITE;
	}

	export  /**@inline*/  function colorToVec4(pValue: IColorValue): IVec4 {
		return  Vec4.stackCeil.set(pValue.r, pValue.g, pValue.b, pValue.a) ;
	}

	export function color(...argv: any[]): IColor {
		var pColor: IColor = Color.stackCeil;
		return pColor.set.apply(pColor, arguments);
	}
}

module akra {
	export var Color = util.Color;
	export var color = util.color;
}





module akra.material {
	export class Material implements IMaterial {
		name: string = null;

		diffuse: IColor = new Color(.5);
		ambient: IColor = new Color(.5);
		specular: IColor = new Color(.5);
		emissive: IColor = new Color(.5);
		shininess:  number  = 50.;

		constructor (sName: string = null, pMat?: IMaterial) {
			this.name = sName;

			if (isDefAndNotNull(pMat)) {
				this.set(pMat);
			}
		}

		set(pMat: IMaterialBase): IMaterial {
//this.name = pMat.name;

			this.diffuse.set(pMat.diffuse);
			this.ambient.set(pMat.ambient);
			this.specular.set(pMat.specular);
			this.emissive.set(pMat.emissive);
			this.shininess = pMat.shininess;

			return this;
		}

		isEqual(pMat: IMaterialBase): bool {
			return Color.isEqual(this.diffuse, pMat.diffuse) &&
			Color.isEqual(this.ambient, pMat.ambient) &&
			Color.isEqual(this.specular, pMat.specular) &&
			Color.isEqual(this.emissive, pMat.emissive) &&
				this.shininess === pMat.shininess;
		}



		toString(): string {
			var s = "\nMATERIAL - " + this.name + "\n";
			s += "------------------------------------\n";
			s += "diffuse:   " + this.diffuse.toString() + "\n";
			s += "ambient:   " + this.ambient.toString() + "\n";
			s += "specular:  " + this.ambient.toString() + "\n";
			s += "emissive:  " + this.emissive.toString() + "\n";
			s += "shininess: " + this.shininess + "\n";

			return s;
		}


	}

	class FlexMaterial implements IFlexMaterial {
		name: string = null;

		protected _pData: IVertexData;

		/**@inline*/  get diffuse(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.DIFFUSE, 0, 1)); }
		/**@inline*/  get ambient(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.AMBIENT, 0, 1)); }
		/**@inline*/  get specular(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.SPECULAR, 0, 1)); }
		/**@inline*/  get emissive(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.EMISSIVE, 0, 1)); }
		/**@inline*/  get shininess():  number  { return this._pData.getTypedData(DeclUsages.SHININESS, 0, 1)[0]; }

		/**@inline*/  set diffuse(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.DIFFUSE); }
		/**@inline*/  set ambient(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.AMBIENT); }
		/**@inline*/  set specular(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.SPECULAR); }
		/**@inline*/  set emissive(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.EMISSIVE); }
		/**@inline*/  set shininess(pValue:  number ) { this._pData.setData(new Float32Array([pValue]), DeclUsages.SHININESS); }

		/**@inline*/  get data(): IVertexData { return this._pData; }

		constructor (sName: string, pData: IVertexData) {
			this._pData = pData;
			this.name = sName;
		}

		set(pMat: IMaterial): IMaterial {
//this.name = 

			this.diffuse = pMat.diffuse;
			this.ambient = pMat.ambient;
			this.specular = pMat.specular;
			this.emissive = pMat.emissive;
			this.shininess = pMat.shininess;

			return this;

		}

		isEqual(pMat: IMaterial): bool {
			return Color.isEqual(this.diffuse, pMat.diffuse) &&
			Color.isEqual(this.ambient, pMat.ambient) &&
			Color.isEqual(this.specular, pMat.specular) &&
			Color.isEqual(this.emissive, pMat.emissive) &&
				this.shininess === pMat.shininess;
		}



		toString(): string {
			var s = "\nFLEX MATERIAL - " + this.name + "\n";
			s += "------------------------------------\n";
			s += "diffuse:   " + this.diffuse.toString() + "\n";
			s += "ambient:   " + this.ambient.toString() + "\n";
			s += "specular:  " + this.ambient.toString() + "\n";
			s += "emissive:  " + this.emissive.toString() + "\n";
			s += "shininess: " + this.shininess + "\n";

			return s;
		}


	}

	export  /**@const*/var  VERTEX_DECL: IVertexDeclaration = createVertexDeclaration(
		[
			VE_CUSTOM(DeclUsages.MATERIAL,  EDataTypes.FLOAT, 17),
			VE_CUSTOM(DeclUsages.DIFFUSE,   EDataTypes.FLOAT, 4, 0),
			VE_CUSTOM(DeclUsages.AMBIENT,   EDataTypes.FLOAT, 4, 16),
			VE_CUSTOM(DeclUsages.SPECULAR,  EDataTypes.FLOAT, 4, 32),
			VE_CUSTOM(DeclUsages.EMISSIVE,  EDataTypes.FLOAT, 4, 48),
			VE_CUSTOM(DeclUsages.SHININESS, EDataTypes.FLOAT, 1, 64)
        ]);

	export  /**@const*/var  DEFAULT: IMaterial = new Material;

	export function create(sName: string = null, pMat: IMaterial = null): IMaterial {
		return new Material(sName, pMat);
	}

	export function _createFlex(sName: string, pData: IVertexData): IMaterial {
		return new FlexMaterial(sName, pData);
	}
}

module akra {
	export var Material = material.Material;
}



module akra.core.pool.resources {
	export class SurfaceMaterial extends ResourcePoolItem implements ISurfaceMaterial {
		protected _pMaterial: IMaterial = new Material;
		protected _nTotalTextures:  number  = 0;
		protected _iTextureFlags:  number  = 0;
		protected _iTextureMatrixFlags:  number  = 0;
		protected _pTextures: ITexture[] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
		protected _pTexcoords:  number [] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
		protected _pTextureMatrices: IMat4[] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);

//For acceleration of PassInpuBlend.setSurfaceMaterial and PassBlend.generateFXMaker
		protected _nTextureUpdates:  number  = 0;
		protected _nTexcoordUpdates:  number  = 0;

		/**@inline*/  get totalUpdatesOfTextures():  number  { return this._nTextureUpdates; }
		/**@inline*/  get totalUpdatesOfTexcoords():  number  { return this._nTexcoordUpdates; }

		/**@inline*/  get totalTextures():  number  { return this._nTotalTextures; }
    	/**@inline*/  get material(): IMaterial { return this._pMaterial; }
    	/**@inline*/  set material(pMaterial: IMaterial) { this._pMaterial.set(pMaterial); }
    	/**@inline*/  get textureFlags():  number  { return this._iTextureFlags; }
    	/**@inline*/  get textureMatrixFlags():  number  { return this._iTextureMatrixFlags; }

    	constructor () {
    		super();

    		for (var i:  number  = 0; i < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE; ++ i) {
    			this._pTexcoords[i] = i;
    		}
    	}

    	createResource(): bool {
    		this.notifyLoaded();
    		return super.createResource();
    	}

    	setTexture(iIndex:  number , iTextureHandle:  number , iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , sTexture: string, iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , pTexture: ITexture, iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , texture: any, iTexcoord:  number  = 0): bool {
//LOG(iIndex, pTexture, iTexcoord);
		    { logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 50 ); logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot"); }
                                          ;

		    var pRmgr: IResourcePoolManager = this.getManager();
		    var pTexture: ITexture = null;

		    this._pTexcoords[iIndex] = iTexcoord;

		    if(iIndex !== iTexcoord) {
		    	this._nTexcoordUpdates = 0;
		    }

		    this._nTextureUpdates++;

		    if (isString(texture)) {
		    	pTexture = this._pTextures[iIndex];

		        if (pTexture) {
//realise first

		            if (pTexture.release() == 0) {
		            	this._pTextures[iIndex] = null;
//pTexture.destroyResource();
		            }
		            else {
		            	{ logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 74 ); logger.warning("cannot destroy resource..."); }
		            }

		            ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		            -- this._nTotalTextures;
		        }


		        this._pTextures[iIndex] = <ITexture>pRmgr.texturePool.loadResource(<string>texture);

		        if (this._pTextures[iIndex]) {
		            ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;

		            ++ this._nTotalTextures;

		            this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);
		        }

		        return true;
		    }
		    else if (texture instanceof Texture) {
		        if (!this._pTextures[iIndex] || pTexture != this._pTextures[iIndex]) {
		            pTexture = texture;
		            if (this._pTextures[iIndex]) {
// realise first
// DisplayManager.texturePool().releaseResource(this._pTextures[iIndex]);

		                if (this._pTextures[iIndex].release() == 0) {
// this._pTextureMatrices[iIndex].destroyResource();
		                	this._pTextures[iIndex] = null;
		                }
		                else {
		                	{ logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 106 ); logger.warning("cannot destroy resource..."); } ;
		                }

		                ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		                -- this._nTotalTextures;
		            }

		            this._pTextures[iIndex] = pTexture;

		            this._pTextures[iIndex].addRef();
		            ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;
		            ++this._nTotalTextures;
		            this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);

// var me = this;
// trace('me get texture :)');
// pTexture.setChangesNotifyRoutine(function() {
//                 if (pTexture.isResourceLoaded()) {
//                     trace(arguments);
//                     trace('Texture <', pTexture.findResourceName(), '> loaded');
//                     if (me.isResourceLoaded()) {
//                         trace('Surface material loaded too.')
//                     }
//                 }
//             });
		        }

		        return true;
		    }
//similar to [cPoolHandle texture]
		    else if (isNumber(texture)) {
		        if (!this._pTextures[iIndex] || this._pTextures[iIndex].resourceHandle != < number >texture) {
		            if (this._pTextures[iIndex]) {
//TheGameHost.displayManager().texturePool().releaseResource(m_pTextures[index]);
		                if (this._pTextures[iIndex].release() === 0) {
// this._pTextures[iIndex].destroyResource();
		                	this._pTextures[iIndex] = null;
		                }
		                else {
		                	{ logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 145 ); logger.warning("cannot destroy resource..."); } ;
		                }

		                ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		                -- this._nTotalTextures;
		            }

		            this._pTextures[iIndex] = <ITexture>pRmgr.texturePool.getResource(< number >texture);

		            if (this._pTextures[iIndex]) {
		                ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;
		                ++ this._nTotalTextures;
		                this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);
		            }
		        }

		        return true;
		    }

		    this._pTexcoords[iIndex] = iIndex;

		    return false;
    	}

    	setTextureMatrix(iIndex:  number , m4fValue: IMat4): bool {
    		{ logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 171 ); logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot"); }
                                        ;

		    if (!m4fValue) {
		        this._pTextureMatrices[iIndex] = new Mat4();
		    }
		    else {
		        this._pTextureMatrices[iIndex] = new Mat4(m4fValue);
		    }

		    ((this._iTextureMatrixFlags) |= (1 << ((iIndex))) ) ;
		    return true;
    	}

    	/**@inline*/  setMaterial(pMaterial: IMaterial): void {
    		this._pMaterial.set(pMaterial);
    	}

    	isEqual(pSurfaceMaterial: ISurfaceMaterial): bool {
    		if (this._nTotalTextures === pSurfaceMaterial.totalTextures &&
		        this._iTextureFlags === pSurfaceMaterial.textureFlags &&
		        this._iTextureMatrixFlags === pSurfaceMaterial.textureMatrixFlags) {

		        if ((this._pMaterial && this._pMaterial.isEqual(pSurfaceMaterial.material))
		            || (pSurfaceMaterial.material === null)) {

		            for (var i = 0; i < this._pTextures.length; i++) {
		                if (this._pTextures[i] !== pSurfaceMaterial.texture[i]) {
		                    return false;
		                }
		            };

		            for (var i = 0; i< this._pTextureMatrices.length; ++ i) {
		                for (var j = 0; j < this._pTextureMatrices[i].data.length; j++) {
		                    if (this._pTextureMatrices[i].data[j] !== pSurfaceMaterial.textureMatrix[i].data[j]) {
		                        return false;
		                    }
		                };
		            }

		            return true;
		        }
		    }

		    return false;
    	}

    	/**@inline*/  texture(iSlot:  number ): ITexture {
// debug_assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE),
//            "invalid texture slot");
    		return this._pTextures[iSlot];
    	}

    	/**@inline*/  texcoord(iSlot:  number ):  number  {
// debug_assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE),
//            "invalid texture slot");
    		return this._pTexcoords[iSlot];
    	}

    	/**@inline*/  textureMatrix(iSlot:  number ): IMat4 {
    		{ logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 231 ); logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot"); }
                                        ;
    		return this._pTextureMatrices[iSlot];
    	}

    	static MAX_TEXTURES_PER_SURFACE:  number  = 16;


// _getHash(): string {
// 	if(this._isNeedToUpdateHash){
// 		this._sLastHash = this.calcHash();
// 	this._isNeedToUpdateHash = false;
// 	}

// 	return this._sLastHash;
// }

// private calcHash(): string {
// 	// var iHash: uint = 0;
// 	// for(var i: uint = 0; i < this._pTexcoords.length; i++){
// 	// 	if(this._pTexcoords[i] !== i){
// 	// 		iHash += (this._pTexcoords[i] + 1) << i;
// 	// 	}
// 	// }

// 	// return iHash.toString();
// 	var sHash: string = "";

// 	for(var i = 0; i < this._pTexcoords.length; i++){
// 		if(this._pTexcoords[i] !== i){
// 			sHash += i.toString() + "<" + this._pTexcoords[i].toString() + ".";
// 		}
// 	}

// 	return sHash;
// }
	}
}


//#include "resources/Model.ts"











module akra.core.pool.resources {
	export class Effect implements IEffect extends ResourcePoolItem {
		protected _nTotalPasses:  number  = 0;
		protected _nTotalComponents:  number  = 0;

		get totalComponents():  number {
			return this._nTotalComponents;
		}

		get totalPasses():  number {
			return this._nTotalPasses;
		}

		constructor () {
            super();
        }

		isEqual(pEffect: IEffect): bool {return false;}
		isReplicated(): bool {return false;}
		isMixid(): bool {return false;}
		isParameterUsed(pParam: any, iPass?:  number ): bool {return false;}

		createResource(): bool {
			this.notifyLoaded();
			return true;
		}

		replicable(bValue: bool): void {return;}
		miscible(bValue: bool): void {return;}

		addComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		addComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;
		addComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		addComponent(pComponent: any, iShift?:  number  =  0xfffffc , iPass?:  number  =  0xffffff ): bool {
			var pComponentPool: IResourcePool = this.manager.componentPool;

			if(isInt(pComponent)) {
				pComponent = pComponentPool.getResource(< number >pComponent);
			}
			else if(isString(pComponent)){
				pComponent = pComponentPool.findResource(<string>pComponent);
			}

			if(!isDef(pComponent) || isNull(pComponent)){
				{ logger.setSourceLocation( "resources/Effect.ts" , 52 ); logger.error("Bad component for add: ", pComponent); } ;
				return false;
			}

			if(!this.getComposer().addComponentToEffect(this, <IAFXComponent>pComponent, iShift, iPass)){
				{ logger.setSourceLocation( "resources/Effect.ts" , 57 ); logger.error("Can not add component '" + <IAFXComponent>pComponent.findResourceName() + "'"); } ;
				return false;
			}

			this._nTotalComponents = this.getComposer().getComponentCountForEffect(this);
			this._nTotalPasses = this.getComposer().getTotalPassesForEffect(this);

			this.notifyAltered();

		    if (this.totalComponents === 1) {
		        this.notifyRestored();
		    }

			return true;
		}

		delComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		delComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: any, iShift?:  number  =  0xfffffc , iPass?:  number  =  0xffffff ): bool {
			var pComponentPool: IResourcePool = this.manager.componentPool;

			if(isInt(pComponent)) {
				pComponent = pComponentPool.getResource(< number >pComponent);
			}
			else if(isString(pComponent)){
				pComponent = pComponentPool.findResource(<string>pComponent);
			}

			if(!isDef(pComponent) || isNull(pComponent)){
				{ logger.setSourceLocation( "resources/Effect.ts" , 87 ); logger.error("Bad component for delete: ", pComponent); } ;
				return false;
			}

			if(!this.getComposer().removeComponentFromEffect(this, <IAFXComponent>pComponent, iShift, iPass)){
				{ logger.setSourceLocation( "resources/Effect.ts" , 92 ); logger.error("Can not delete component '" + <IAFXComponent>pComponent.findResourceName() + "'"); } ;
				return false;
			}

			this._nTotalComponents = this.getComposer().getComponentCountForEffect(this);
			this._nTotalPasses = this.getComposer().getTotalPassesForEffect(this);

			this.notifyAltered();

			if (this.totalComponents === 0) {
		        this.notifyDisabled();
		    }

			return true;
		}

		hasComponent(sComponent: string, iShift?:  number  =  0xfffffb , iPass?:  number  =  0xfffffa ): bool {
			var pComponentPool: IResourcePool = this.manager.componentPool;
			var pComponent: IAFXComponent = null;

			pComponent = <IAFXComponent>pComponentPool.findResource(sComponent);

			if(isNull(pComponent)){
				return false;
			}

			return this.getComposer().hasComponentForEffect(this, pComponent, iShift, iPass);
		}

		activate(iShift?:  number  = 0): bool {
 			return this.getComposer().activateEffectResource(this, iShift);
		}

		deactivate(): bool {
			return this.getComposer().deactivateEffectResource(this);
		}

		findParameter(pParam: any, iPass?:  number ): any {return null;}

		private  /**@inline*/  getComposer(): IAFXComposer {
			return this.manager.getEngine().getComposer();
		}
	}
}


























module akra {
	export interface IBox {
		width:  number ;
		height:  number ;
		depth:  number ;

		left:  number ;
		top:  number ;
		right:  number ;
		bottom:  number ;
		front:  number ;
		back:  number ;

		contains(pDest: IBox): bool;
		isEqual(pDest: IBox): bool;
		setPosition(iLeft:  number , iTop:  number , iWidth:  number , iHeight:  number , iFront?:  number , iDepth?:  number ): void;

		toString(): string;
	}
}




module akra {
	;

	export interface IPixelBox extends IBox {
		format: EPixelFormats;
		data: Uint8Array;
		rowPitch:  number ;
		slicePitch:  number ;

		setConsecutive(): void;

		getRowSkip():  number ;
		getSliceSkip():  number ;

		isConsecutive(): bool;
		getConsecutiveSize():  number ;

		getSubBox(pDest: IBox, pDestPixelBox?: IPixelBox): IPixelBox;
		getColorAt(pColor: IColor, x:  number , y:  number , z?:  number ): IColor;
		setColorAt(pColor: IColor, x:  number , y:  number , z?:  number ): void;

		scale(pDest: IPixelBox, eFilter?: EFilters): bool;

		refresh(pExtents: IBox, ePixelFormat: EPixelFormats, pPixelData: Uint8Array): void;
	}
}




module akra
{



    export enum EImageFlags {
		COMPRESSED = 0x00000001,
        CUBEMAP    = 0x00000002,
        TEXTURE_3D = 0x00000004,
	};

    export enum EImageCubeFlags{
        POSITIVE_X = 0x00000001,
        NEGATIVE_X = 0x00000002,
        POSITIVE_Y = 0x00000004,
        NEGATIVE_Y = 0x00000008,
        POSITIVE_Z = 0x000000010,
        NEGATIVE_Z = 0x000000020,
        };

    export interface IImg extends IResourcePoolItem {
    	byteLength:  number ;

    	width:  number ;
    	height:  number ;
    	depth:  number ;

    	numFaces:  number ;
    	numMipMaps:  number ;
    	format: EPixelFormats;

        flags:  number ;
        cubeFlags: number ;


    	set(pSrc: IImg): IImg;

/** @param Destination image. If destination not specified, original image will be modified.*/

    	flipY(pDest?: IImg): IImg;
    	flipX(pDest?: IImg): IImg;


    	load(sFileName: string,  fnCallBack?: Function): IImg;
    	load(pData: Uint8Array, sType?: string,  fnCallBack?: Function): IImg;
        load(pCanvas: HTMLCanvasElement, fnCallBack?: Function): IImg;


    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth?:  number , eFormat?: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): IImg;

        loadDynamicImage(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth?:  number ,
                         eFormat?: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): IImg;


    	create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, nFaces:  number , nMipMaps:  number ): IImg ;

    	convert(eFormat: EPixelFormats): bool;

//Gets the physical width in bytes of each row of pixels.
    	getRawSpan():  number ;
        getPixelSize():  number ;
    	getBPP():  number ;
    	getData(): Uint8Array;

    	hasFlag(eFlag: EImageFlags): bool;

    	hasAlpha(): bool;
    	isCompressed(): bool;
    	isLuminance(): bool;

    	freeMemory();

    	getColorAt(pColor: IColor, x:  number , y:  number , z?: number ): IColor;
    	setColorAt(pColor: IColor, x:  number , y:  number , z?:  number ): void;

    	getPixels(nFace?:  number , iMipMap?:  number ): IPixelBox;

    	scale(pDest: IPixelBox, eFilter?: EFilters): bool;

    	resize(iWidth:  number , iHeight:  number , eFilter?: EFilters): bool;

    	generatePerlinNoise(fScale:  number , iOctaves:  number , fFalloff:  number ): void;
    	randomChannelNoise(iChannel:  number , iMinRange:  number , iMaxRange:  number ): void;
    }

}































module akra {
	export interface IPathinfo {
		path: string;
		dirname: string;
		filename: string;
		ext: string;
		basename: string;


		set(sPath: string): void;
		set(pPath: IPathinfo): void;
		isAbsolute(): bool;

		toString(): string;
	}

}



module akra.path {
	function normalizeArray(parts, allowAboveRoot) {
// if the path tries to go above the root, `up` ends up > 0
		var up = 0;
		for (var i = parts.length - 1; i >= 0; i--) {
			var last = parts[i];
			if (last === '.') {
				parts.splice(i, 1);
			} else if (last === "..") {
				parts.splice(i, 1);
				up++;
			} else if (up) {
				parts.splice(i, 1);
				up--;
			}
		}

// if the path is allowed to go above the root, restore leading ..s
		if (allowAboveRoot) {
			for (; up--; up) {
				parts.unshift("..");
			}
		}

		return parts;
	}

	export class Info implements IPathinfo {
		private _sDirname: string = null;
		private _sExtension: string = null;
		private _sFilename: string = null;

		/**@inline*/  get path(): string { return this.toString(); }
		/**@inline*/  set path(sPath: string) { this.set(sPath); }

		/**@inline*/  get dirname(): string { return this._sDirname; }
		/**@inline*/  set dirname(sDirname: string) { this._sDirname = sDirname; }

		/**@inline*/  get filename(): string { return this._sFilename; }
		/**@inline*/  set filename(sFilename: string) { this._sFilename = sFilename; }

		/**@inline*/  get ext(): string { return this._sExtension; }
		/**@inline*/  set ext(sExtension: string) { this._sExtension = sExtension; }

		/**@inline*/  get basename(): string {
			return (this._sFilename ? this._sFilename + (this._sExtension ? "." + this._sExtension : "") : "");
		}

		/**@inline*/  set basename(sBasename: string) {
			var nPos:  number  = sBasename.lastIndexOf(".");

	        if (nPos < 0) {
	            this._sFilename = sBasename.substr(0);
	            this._sExtension = null;
	        }
	        else {
	            this._sFilename = sBasename.substr(0, nPos);
	            this._sExtension = sBasename.substr(nPos + 1);
	        }
		}


		constructor (pPath: IPathinfo);
		constructor (sPath: string);
		constructor (pPath?: any) {
			if (isDef(pPath)) {
				this.set(<string>pPath);
			}
		}


		set(sPath: string): void;
		set(pPath: IPathinfo): void;
		set(sPath?: any) {
			if (isString(sPath)) {
		        var pParts: string[] = sPath.replace('\\', '/').split('/');

		        this.basename = pParts.pop();

		        this._sDirname = pParts.join('/');
		    }
		    else if (sPath instanceof path.Info) {
		        this._sDirname = sPath.dirname;
		        this._sFilename = sPath.filename;
		        this._sExtension = sPath.ext;
		    }
		    else if (isNull(sPath)) {
		    	return null;
		    }
		    else {
//critical_error
		        { logger.setSourceLocation( "Pathinfo.ts" , 97 ); logger.error("Unexpected data type was used.", sPath); } ;
		    }
		}

		isAbsolute(): bool { return this._sDirname[0] === "/"; }


		toString(): string {
			return (this._sDirname ? this._sDirname + "/" : "") + (this.basename);
		}
	}

	export var info: (info?) => IPathinfo;

	export function normalize(sPath: string): string {
		var info: IPathinfo = path.info(sPath);
		var isAbsolute: bool = info.isAbsolute();
		var tail: string = info.dirname;
		var trailingSlash: bool = /[\\\/]$/.test(tail);

		tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
	      return !!p;
	    }), !isAbsolute).join("/");

	    if (tail && trailingSlash) {
	      tail += "/";
	    }

	    info.dirname = (isAbsolute ? "/" : "") + tail;

	    return info.toString();
	}

// export var pathinfo: (sPath: string) => IPathinfo;
// export var pathinfo: (info: IPathinfo) => IPathinfo;

	info = function (info?): IPathinfo {
		return new Info(info);
	}
}











module akra {
	export interface IURI {
		scheme: string;
		userinfo: string;
		host: string;
		port:  number ;
		path: string;
		query: string;
		fragment: string;
		urn: string;
		url: string;
		authority: string;
		protocol: string;

		toString(): string;
	}
}






module akra {
	export interface IDataURI {
		base64: bool;
		data: string;
		mediatype: string;
		charset: string;
	}
}



module akra.path {
	export class URI implements IURI {
		private sScheme: string = null;
		private sUserinfo: string = null;
		private sHost: string = null;
		private nPort:  number  = 0;
		private sPath: string = null;
		private sQuery: string = null;
		private sFragment: string = null;

		get urn(): string {
			return (this.sPath ? this.sPath : "") +
			(this.sQuery ? '?' + this.sQuery : "") +
			(this.sFragment ? '#' + this.sFragment : "");
		}

		get url(): string {
			return (this.sScheme ? this.sScheme : "") + this.authority;
		}

		get authority(): string {
			return (this.sHost ? '//' + (this.sUserinfo ? this.sUserinfo + '@' : "") +
				this.sHost + (this.nPort ? ':' + this.nPort : "") : "");
		}

		/**@inline*/  get scheme(): string {
			return this.sScheme;
		}

		get protocol(): string {
			if (!this.sScheme) {
				return this.sScheme;
			}

			return (this.sScheme.substr(0, this.sScheme.lastIndexOf(':')));
		}

		/**@inline*/  get userinfo(): string {
			return this.sUserinfo;
		}

		/**@inline*/  get host(): string {
			return this.sHost;
		}

		/**@inline*/  set host(sHost: string) {
//TODO: check host format
			this.sHost = sHost;
		}

		/**@inline*/  get port():  number  {
			return this.nPort;
		}

		/**@inline*/  set port(iPort:  number ) {
			this.nPort = iPort;
		}

		/**@inline*/  get path(): string {
			return this.sPath;
		}

		/**@inline*/  set path(sPath: string) {
// debug_assert(!isNull(sPath.match(new RegExp("^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$"))), 
// 	"invalid path used: " + sPath);
//TODO: check path format
			this.sPath = sPath;
		}

		/**@inline*/  get query(): string {
//TODO: check query format
			return this.sQuery;
		}

		/**@inline*/  set query(sQuery: string) {
			this.sQuery = sQuery;
		}

		/**@inline*/  get fragment(): string {
			return this.sFragment;
		}


		constructor (pUri: URI);
		constructor (sUri: string);
		constructor (pUri?) {
			if (pUri) {
				this.set(pUri);
			}
		}

		set(pUri: URI);
		set(sUri: string);
		set(pData?): URI {
			if (isString(pData)) {
				var pUri:RegExpExecArray = URI.uriExp.exec(<string>pData);

				{ logger.setSourceLocation( "URI.ts" , 104 ); logger.assert(pUri !== null, 'Invalid URI format used.\nused uri: ' + pData); } ;

				if (!pUri) {
					return null;
				}

				this.sScheme = pUri[1] || null;
				this.sUserinfo = pUri[2] || null;
				this.sHost = pUri[3] || null;
				this.nPort = parseInt(pUri[4]) || null;
				this.sPath = pUri[5] || pUri[6] || null;
				this.sQuery = pUri[7] || null;
				this.sFragment = pUri[8] || null;

				return this;

			}
			else if (pData instanceof URI) {
				return this.set(pData.toString());
			}

			{ logger.setSourceLocation( "URI.ts" , 125 ); logger.error('Unexpected data type was used.'); } ;

			return null;
		}

		toString(): string {
			return this.url + this.urn;
		}

		static here(): IURI {
			return new URI(document.location.href);
		}

//------------------------------------------------------------------//
//----- Validate a URI -----//
//------------------------------------------------------------------//
//- The different parts are kept in their own groups and can be recombined
//  depending on the scheme:
//  - http as $1://$3:$4$5?$7#$8
//  - ftp as $1://$2@$3:$4$5
//  - mailto as $1:$6?$7
//- groups are as follows:
//  1   == scheme
//  2   == userinfo
//  3   == host
//  4   == port
//  5,6 == path (5 if it has an authority, 6 if it doesn't)
//  7   == query
//  8   == fragment


		static private uriExp:RegExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");

/*
		 composed as follows:
		 ^
		 ([a-z0-9+.-]+):							#scheme
		 (?:
		 //							#it has an authority:
		 (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?	#userinfo
		 ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)		#host
		 (?::(\d*))?						#port
		 (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
		 |
		 #it doesn't have an authority:
		 (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
		 )
		 (?:
		 \?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#query string
		 )?
		 (?:
		 #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#fragment
		 )?
		 $
		 */

	}


	function normalizeURIPath(pFile: IURI): IURI {
		if (!isNull(pFile.path)) {
			if (pFile.scheme === "filesystem:") {
				var pUri: IURI = path.uri(pFile.path);

				pUri.path = path.normalize(pUri.path);
				pFile.path = pUri.toString();
			}
			else {
				pFile.path = path.normalize(pFile.path);
			}
		}

		return pFile;
	}


	export function decodeDataURI(sUri: string): IDataURI {
		var re: RegExp = /^data:([\w\d\-\/]+)?(;charset=[\w\d\-]*)?(;base64)?,(.*)$/;
		var m: string[] = sUri.match(re);

		return {
//like [text/plain]
			mediatype: m[1] || null,
//like [;charset=windows-1251]
			charset: isString(m[2])? m[2].substr(9): null,
//like [;base64]
			base64: isDef(m[3]),
			data: m[4] || null
		};
	}

	export function resolve(sFile, sAbsolutePath: string = document.location.href): string {

		var pCurrentPath: IURI = uri(sAbsolutePath);
		var pFile: IURI = uri(sFile);
		var sDirname: string;

// if (!isNull(pFile.path)) 
// 	pFile.path = path.normalize(pFile.path);

// if (!isNull(pCurrentPath.path))
// 	pCurrentPath.path = path.normalize(pCurrentPath.path);
		normalizeURIPath(pFile);
		normalizeURIPath(pCurrentPath);

		if (!isNull(pFile.scheme) || !isNull(pFile.host) || path.info(pFile.path).isAbsolute()) {
//another server or absolute path
			return sFile;
		}

		sDirname = path.info(pCurrentPath.path).dirname;
		pCurrentPath.path = sDirname? sDirname + "/" + sFile: sFile;

		return normalizeURIPath(pCurrentPath).toString();
	}

	export var uri = (sUri:string): IURI => new URI(sUri);
}

module akra {
	export var uri = path.uri;
}



// #include "ReferenceCounter.ts"
// #include "Singleton.ts"

// #include "BrowserInfo.ts"
// #include "ApiInfo.ts"
// #include "ScreenInfo.ts"
// #include "DeviceInfo.ts"

// #include "UtilTimer.ts"

// #include "Entity.ts"

// #include "ThreadManager.ts"

module akra.util {
//string to array buffer
	export var stoab = function (s: string): ArrayBuffer {
		var len:  number  = s.length;
		var pCodeList: Uint8Array = new Uint8Array(len);

	    for (var i:  number  = 0; i < len; ++i) {
/*& 0xFF;*/
	        pCodeList[ i ] = s.charCodeAt(i);
	    }

	    return pCodeList.buffer;
	}

	export var abtos = function (pBuf: ArrayBuffer): string {
		var pData: Uint8Array = new Uint8Array(pBuf);
	    var s: string = "";

	    for (var n:  number  = 0; n < pData.length; ++ n) {
	        s += String.fromCharCode(pData[n]);
	    }

	    return s;
// return String.fromCharCode.apply(null, Array.prototype.slice.call(new Uint8Array(pBuf), 0));
	}

	export var abtos_blobreader = function(buf: ArrayBuffer, callback: Function) {
        var bb = new Blob([buf]);
        var f = new FileReader();

        f.onload = function(e) {
          callback(e.target.result);
        }

        f.readAsText(bb);
    }


	export function abtota(pBuffer: ArrayBuffer, eType: EDataTypes): ArrayBufferView {
        switch (eType) {
            case EDataTypes.FLOAT:
                return new Float32Array(pBuffer);
            case EDataTypes.SHORT:
                return new Int16Array(pBuffer);
            case EDataTypes.UNSIGNED_SHORT:
                return new Uint16Array(pBuffer);
            case EDataTypes.INT:
                return new Int32Array(pBuffer);
            case EDataTypes.UNSIGNED_INT:
                return new Uint32Array(pBuffer);
            case EDataTypes.BYTE:
                return new Int8Array(pBuffer);
            default:
            case EDataTypes.UNSIGNED_BYTE:
                return new Uint8Array(pBuffer);
        }
    }

	export function parseJSON(sJSON: string): Object {
		return eval('(' + sJSON + ')');
	}

	export function btoa(pBlob: Blob, fn: (e: ErrorEvent, pBuffer: ArrayBuffer) => void): void {
		var pReader: FileReader = new FileReader();

		pReader.onload = function(e) {
			fn(null, e.target.result);
		};

		pReader.onerror = function(e: ErrorEvent) {
			fn(e, null);
		};

		pReader.readAsArrayBuffer(pBlob);

	}

/**
	 * Преобразование html-сформированного текста
	 * в dom.
	 */

	export function parseHTML(sHTML: string, useDocFragment: bool = true): any {
	    var pDivEl: HTMLDivElement = <HTMLDivElement>document.createElement('div');
	    var pDocFrag: DocumentFragment;

	    pDivEl.innerHTML = sHTML;

	    if (!useDocFragment) {
	        return pDivEl.childNodes;
	    }

	    pDocFrag = document.createDocumentFragment();

	    for (var i = 0, len:  number  = pDivEl.childNodes.length; i < len; ++ i) {
	        if (!isDef(pDivEl.childNodes[i])) {
	            continue;
	        }

	        pDocFrag.appendChild(pDivEl.childNodes[i]);
	    }

	    return pDocFrag;
	};

	export function blobFromDataURL(sBlobURL: string, fn: (b: Blob) => void): void {
		var xhr = new XMLHttpRequest();
		xhr.open("GET", sBlobURL, true);
		xhr.responseType = "blob";

		xhr.onload = function(e) {
			if (this.status == 200) {
				fn(<Blob>this.response);
			}
		};

		xhr.send();
	}


	export function jsonFromDataURL(sBlobURL: string, fn: (json: Object) => void): void {
		var xhr = new XMLHttpRequest();

		xhr.open("GET", sBlobURL, true);
		xhr.overrideMimeType('application/json');
		xhr.responseType = "json";

		xhr.onload = function(e) {
			if (this.status == 200) {
				fn(<Object>this.response);
			}
		};

		xhr.send();
	}

	export function dataURItoBlob(dataURI) {
// convert base64 to raw binary data held in a string
// doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
	    var byteString = atob(dataURI.split(',')[1]);

// separate out the mime component
	    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

// write the bytes of the string to an ArrayBuffer
	    var ab = new ArrayBuffer(byteString.length);
	    var ia = new Uint8Array(ab);
	    for (var i = 0; i < byteString.length; i++) {
	        ia[i] = byteString.charCodeAt(i);
	    }

// write the ArrayBuffer to a blob, and you're done
	    var bb = new Blob([ab], {type: mimeString});
	    return bb;
	}

	export function dataToURL(data: any, mime: string = "text/plain"): string {
		var blob: Blob;

		try {
		    blob = new Blob([data], {type: mime});
		} catch (e) {
// Backwards-compatibility
		    var bb: BlobBuilder = new BlobBuilder();
		    bb.append(data);
		    blob = bb.getBlob(mime);
		}

		return URL.createObjectURL(blob);
	}

}










module akra {
	export interface ICanvasInfo {
		width:  number ;
		height:  number ;
		id: string;
	}
}












module akra {
	export interface IBrowserInfo {
		name: string;
		version: string;
		os: string;
	}
}






module akra.util {
	export class Singleton {
		constructor () {
			var _constructor = (<any>this).constructor;

			{ logger.setSourceLocation( "Singleton.ts" , 10 ); logger.assert(!isDef(_constructor._pInstance), 'Singleton class may be created only one time.'); }
                                                    ;

			_constructor._pInstance = this;
		}
	}
}




module akra.util {
	export interface IBrowserData {
		string: string;
		subString: string;
		identity: string;
		versionSearch?: string;
		prop?: string;
	}

	export class BrowserInfo extends Singleton implements IBrowserInfo {
		private sBrowser: string = null;
		private sVersion: string = null;
		private sOS: string = null;
		private sVersionSearch: string = null;

		constructor() {
			super();
			this.init();
		}

		get name(): string {
			return this.sBrowser;
		}

		get version(): string {
			return this.sVersion;
		}

		get os(): string {
			return this.sOS;
		}

		private init(): void {
			this.sBrowser = this.searchString(BrowserInfo.dataBrowser) || "An unknown browser";
			this.sVersion = this.searchVersion(navigator.userAgent)
								|| this.searchVersion(navigator.appVersion)
				|| "an unknown version";
			this.sOS = this.searchString(BrowserInfo.dataOS) || "an unknown OS";
		}

		private searchString(pDataBrowser: IBrowserData[]): string {
			for (var i: number  = 0; i < pDataBrowser.length; i++) {
				var sData:string = pDataBrowser[i].string;
				var dataProp:string = pDataBrowser[i].prop;

				this.sVersionSearch = pDataBrowser[i].versionSearch || pDataBrowser[i].identity;

				if (sData) {
					if (sData.indexOf(pDataBrowser[i].subString) != -1) {
						return pDataBrowser[i].identity;
					}
				}
				else if (dataProp) {
					return pDataBrowser[i].identity;
				}
			}
			return null;
		}

		private searchVersion(sData: string): string {
			var iStartIndex: number  = sData.indexOf(this.sVersionSearch);

			if (iStartIndex == -1) {
				return null;
			}

			iStartIndex = sData.indexOf('/', iStartIndex + 1);

			if (iStartIndex == -1) {
				return null;
			}

			var iEndIndex: number  = sData.indexOf(' ', iStartIndex + 1);

			if (iEndIndex == -1) {
				iEndIndex = sData.indexOf(';', iStartIndex + 1);
				if (iEndIndex == -1) {
					return null;
				}
				return sData.slice(iStartIndex + 1);
			}

			return sData.slice((iStartIndex + 1), iEndIndex);
		}

		static private dataBrowser: IBrowserData[] = [
			{
				string: navigator.userAgent,
				subString: "Chrome",
				identity: "Chrome"
			},
			{
				string: navigator.userAgent,
				subString: "OmniWeb",
				versionSearch: "OmniWeb/",
				identity: "OmniWeb"
			},
			{
				string: navigator.vendor,
				subString: "Apple",
				identity: "Safari",
				versionSearch: "Version"
			},
			{
				prop: window.opera,
				identity: "Opera",
				versionSearch: "Version"
			},
			{
				string: navigator.vendor,
				subString: "iCab",
				identity: "iCab"
			},
			{
				string: navigator.vendor,
				subString: "KDE",
				identity: "Konqueror"
			},
			{
				string: navigator.userAgent,
				subString: "Firefox",
				identity: "Firefox"
			},
			{
				string: navigator.vendor,
				subString: "Camino",
				identity: "Camino"
			},
			{
// for newer Netscapes (6+)
				string: navigator.userAgent,
				subString: "Netscape",
				identity: "Netscape"
			},
			{
				string: navigator.userAgent,
				subString: "MSIE",
				identity: "Explorer",
				versionSearch: "MSIE"
			},
			{
				string: navigator.userAgent,
				subString: "Gecko",
				identity: "Mozilla",
				versionSearch: "rv"
			},
			{
// for older Netscapes (4-)
				string: navigator.userAgent,
				subString: "Mozilla",
				identity: "Netscape",
				versionSearch: "Mozilla"
			}
		];

		static private dataOS: IBrowserData[] = [
			{
				string    : navigator.platform,
				subString : "Win",
				identity  : "Windows"
			},
			{
				string    : navigator.platform,
				subString : "Mac",
				identity  : "Mac"
			},
			{
				string    : navigator.userAgent,
				subString : "iPhone",
				identity  : "iPhone/iPod"
			},
			{
				string    : navigator.platform,
				subString : "Linux",
				identity  : "Linux"
			}
		];
	}
}











module akra {
	export interface IScreenInfo {
		width:  number ;
		height:  number ;
		aspect:  number ;
		pixelDepth:  number ;
		colorDepth:  number ;
	}
}



module akra.util {
	export class ScreenInfo implements IScreenInfo {
		get width():  number  {
			return screen.width;
		}

		get height():  number  {
			return screen.height;
		}

		get aspect():  number  {
			return screen.width / screen.height;
		}

		get pixelDepth():  number  {
			return screen.pixelDepth;
		}

		get colorDepth():  number  {
			return screen.colorDepth;
		}
	}
}










module akra {
	export interface IApiInfo {
		gamepad: bool;
		webGL: bool;
		webAudio: bool;
		file: bool;
		fileSystem: bool;
		webWorker: bool;
		transferableObjects: bool;
		localStorage: bool;
		webSocket: bool;
		zip: bool;
	}
}









// see: http://www.khronos.org/registry/webgl/specs/latest/

interface WebGLObject
{
};

interface WebGLBuffer extends WebGLObject
{
};

interface WebGLFramebuffer extends WebGLObject
{
};

interface WebGLProgram extends WebGLObject
{
};

interface WebGLRenderbuffer extends WebGLObject
{
};

interface WebGLShader extends WebGLObject
{
};

interface WebGLTexture extends WebGLObject
{
};

interface WebGLUniformLocation
{
};

interface WebGLActiveInfo
{
	size: number;
	type: number;
	name: string;
};

interface WebGLShaderPrecisionFormat
{
	rangeMin: number;
	rangeMax: number;
	precision: number;
};


interface WebGLContextAttributes
{
	alpha?: bool;
	depth?: bool;
	stencil?: bool;
	antialias?: bool;
	premultipliedAlpha?: bool;
	preserveDrawingBuffer?: bool;
};

interface WebGLRenderingContext
{
/* ClearBufferMask */

	DEPTH_BUFFER_BIT: number;
	STENCIL_BUFFER_BIT: number;
	COLOR_BUFFER_BIT: number;

/* BeginMode */

	POINTS: number;
	LINES: number;
	LINE_LOOP: number;
	LINE_STRIP: number;
	TRIANGLES: number;
	TRIANGLE_STRIP: number;
	TRIANGLE_FAN: number;

/* AlphaFunction (not supported in ES20) */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* BlendingFactorDest */

	ZERO: number;
	ONE: number;
	SRC_COLOR: number;
	ONE_MINUS_SRC_COLOR: number;
	SRC_ALPHA: number;
	ONE_MINUS_SRC_ALPHA: number;
	DST_ALPHA: number;
	ONE_MINUS_DST_ALPHA: number;

/* BlendingFactorSrc */

/*      ZERO */

/*      ONE */

	DST_COLOR: number;
	ONE_MINUS_DST_COLOR: number;
	SRC_ALPHA_SATURATE: number;
/*      SRC_ALPHA */

/*      ONE_MINUS_SRC_ALPHA */

/*      DST_ALPHA */

/*      ONE_MINUS_DST_ALPHA */


/* BlendEquationSeparate */

	FUNC_ADD: number;
	BLEND_EQUATION: number;
	BLEND_EQUATION_RGB: number;
	BLEND_EQUATION_ALPHA: number;

/* BlendSubtract */

	FUNC_SUBTRACT: number;
	FUNC_REVERSE_SUBTRACT: number;

/* Separate Blend Functions */

	BLEND_DST_RGB: number;
	BLEND_SRC_RGB: number;
	BLEND_DST_ALPHA: number;
	BLEND_SRC_ALPHA: number;
	CONSTANT_COLOR: number;
	ONE_MINUS_CONSTANT_COLOR: number;
	CONSTANT_ALPHA: number;
	ONE_MINUS_CONSTANT_ALPHA: number;
	BLEND_COLOR: number;

/* Buffer Objects */

	ARRAY_BUFFER: number;
	ELEMENT_ARRAY_BUFFER: number;
	ARRAY_BUFFER_BINDING: number;
	ELEMENT_ARRAY_BUFFER_BINDING: number;

	STREAM_DRAW: number;
	STATIC_DRAW: number;
	DYNAMIC_DRAW: number;

	BUFFER_SIZE: number;
	BUFFER_USAGE: number;

	CURRENT_VERTEX_ATTRIB: number;

/* CullFaceMode */

	FRONT: number;
	BACK: number;
	FRONT_AND_BACK: number;

/* DepthFunction */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* EnableCap */

/* TEXTURE_2D */

	CULL_FACE: number;
	BLEND: number;
	DITHER: number;
	STENCIL_TEST: number;
	DEPTH_TEST: number;
	SCISSOR_TEST: number;
	POLYGON_OFFSET_FILL: number;
	SAMPLE_ALPHA_TO_COVERAGE: number;
	SAMPLE_COVERAGE: number;

/* ErrorCode */

	NO_ERROR: number;
	INVALID_ENUM: number;
	INVALID_VALUE: number;
	INVALID_OPERATION: number;
	OUT_OF_MEMORY: number;

/* FrontFaceDirection */

	CW: number;
	CCW: number;

/* GetPName */

	LINE_WIDTH: number;
	ALIASED_POINT_SIZE_RANGE: number;
	ALIASED_LINE_WIDTH_RANGE: number;
	CULL_FACE_MODE: number;
	FRONT_FACE: number;
	DEPTH_RANGE: number;
	DEPTH_WRITEMASK: number;
	DEPTH_CLEAR_VALUE: number;
	DEPTH_FUNC: number;
	STENCIL_CLEAR_VALUE: number;
	STENCIL_FUNC: number;
	STENCIL_FAIL: number;
	STENCIL_PASS_DEPTH_FAIL: number;
	STENCIL_PASS_DEPTH_PASS: number;
	STENCIL_REF: number;
	STENCIL_VALUE_MASK: number;
	STENCIL_WRITEMASK: number;
	STENCIL_BACK_FUNC: number;
	STENCIL_BACK_FAIL: number;
	STENCIL_BACK_PASS_DEPTH_FAIL: number;
	STENCIL_BACK_PASS_DEPTH_PASS: number;
	STENCIL_BACK_REF: number;
	STENCIL_BACK_VALUE_MASK: number;
	STENCIL_BACK_WRITEMASK: number;
	VIEWPORT: number;
	SCISSOR_BOX: number;
/*      SCISSOR_TEST */

	COLOR_CLEAR_VALUE: number;
	COLOR_WRITEMASK: number;
	UNPACK_ALIGNMENT: number;
	PACK_ALIGNMENT: number;
	MAX_TEXTURE_SIZE: number;
	MAX_VIEWPORT_DIMS: number;
	SUBPIXEL_BITS: number;
	RED_BITS: number;
	GREEN_BITS: number;
	BLUE_BITS: number;
	ALPHA_BITS: number;
	DEPTH_BITS: number;
	STENCIL_BITS: number;
	POLYGON_OFFSET_UNITS: number;
/*      POLYGON_OFFSET_FILL */

	POLYGON_OFFSET_FACTOR: number;
	TEXTURE_BINDING_2D: number;
	SAMPLE_BUFFERS: number;
	SAMPLES: number;
	SAMPLE_COVERAGE_VALUE: number;
	SAMPLE_COVERAGE_INVERT: number;

/* GetTextureParameter */

/*      TEXTURE_MAG_FILTER */

/*      TEXTURE_MIN_FILTER */

/*      TEXTURE_WRAP_S */

/*      TEXTURE_WRAP_T */


	COMPRESSED_TEXTURE_FORMATS: number;

/* HintMode */

	DONT_CARE: number;
	FASTEST: number;
	NICEST: number;

/* HintTarget */

	GENERATE_MIPMAP_HINT: number;

/* DataType */

	BYTE: number;
	UNSIGNED_BYTE: number;
	SHORT: number;
	UNSIGNED_SHORT: number;
	INT: number;
	UNSIGNED_INT: number;
	FLOAT: number;

/* PixelFormat */

	DEPTH_COMPONENT: number;
	ALPHA: number;
	RGB: number;
	RGBA: number;
	LUMINANCE: number;
	LUMINANCE_ALPHA: number;

/* PixelType */

/*      UNSIGNED_BYTE */

	UNSIGNED_SHORT_4_4_4_4: number;
	UNSIGNED_SHORT_5_5_5_1: number;
	UNSIGNED_SHORT_5_6_5: number;

/* Shaders */

	FRAGMENT_SHADER: number;
	VERTEX_SHADER: number;
	MAX_VERTEX_ATTRIBS: number;
	MAX_VERTEX_UNIFORM_VECTORS: number;
	MAX_VARYING_VECTORS: number;
	MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;
	MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;
	MAX_TEXTURE_IMAGE_UNITS: number;
	MAX_FRAGMENT_UNIFORM_VECTORS: number;
	SHADER_TYPE: number;
	DELETE_STATUS: number;
	LINK_STATUS: number;
	VALIDATE_STATUS: number;
	ATTACHED_SHADERS: number;
	ACTIVE_UNIFORMS: number;
	ACTIVE_ATTRIBUTES: number;
	SHADING_LANGUAGE_VERSION: number;
	CURRENT_PROGRAM: number;

/* StencilFunction */

	NEVER: number;
	LESS: number;
	EQUAL: number;
	LEQUAL: number;
	GREATER: number;
	NOTEQUAL: number;
	GEQUAL: number;
	ALWAYS: number;

/* StencilOp */

/*      ZERO */

	KEEP: number;
	REPLACE: number;
	INCR: number;
	DECR: number;
	INVERT: number;
	INCR_WRAP: number;
	DECR_WRAP: number;

/* StringName */

	VENDOR: number;
	RENDERER: number;
	VERSION: number;

/* TextureMagFilter */

	NEAREST: number;
	LINEAR: number;

/* TextureMinFilter */

/*      NEAREST */

/*      LINEAR */

	NEAREST_MIPMAP_NEAREST: number;
	LINEAR_MIPMAP_NEAREST: number;
	NEAREST_MIPMAP_LINEAR: number;
	LINEAR_MIPMAP_LINEAR: number;

/* TextureParameterName */

	TEXTURE_MAG_FILTER: number;
	TEXTURE_MIN_FILTER: number;
	TEXTURE_WRAP_S: number;
	TEXTURE_WRAP_T: number;

/* TextureTarget */

	TEXTURE_2D: number;
	TEXTURE: number;

	TEXTURE_CUBE_MAP: number;
	TEXTURE_BINDING_CUBE_MAP: number;
	TEXTURE_CUBE_MAP_POSITIVE_X: number;
	TEXTURE_CUBE_MAP_NEGATIVE_X: number;
	TEXTURE_CUBE_MAP_POSITIVE_Y: number;
	TEXTURE_CUBE_MAP_NEGATIVE_Y: number;
	TEXTURE_CUBE_MAP_POSITIVE_Z: number;
	TEXTURE_CUBE_MAP_NEGATIVE_Z: number;
	MAX_CUBE_MAP_TEXTURE_SIZE: number;

/* TextureUnit */

	TEXTURE0: number;
	TEXTURE1: number;
	TEXTURE2: number;
	TEXTURE3: number;
	TEXTURE4: number;
	TEXTURE5: number;
	TEXTURE6: number;
	TEXTURE7: number;
	TEXTURE8: number;
	TEXTURE9: number;
	TEXTURE10: number;
	TEXTURE11: number;
	TEXTURE12: number;
	TEXTURE13: number;
	TEXTURE14: number;
	TEXTURE15: number;
	TEXTURE16: number;
	TEXTURE17: number;
	TEXTURE18: number;
	TEXTURE19: number;
	TEXTURE20: number;
	TEXTURE21: number;
	TEXTURE22: number;
	TEXTURE23: number;
	TEXTURE24: number;
	TEXTURE25: number;
	TEXTURE26: number;
	TEXTURE27: number;
	TEXTURE28: number;
	TEXTURE29: number;
	TEXTURE30: number;
	TEXTURE31: number;
	ACTIVE_TEXTURE: number;

/* TextureWrapMode */

	REPEAT: number;
	CLAMP_TO_EDGE: number;
	MIRRORED_REPEAT: number;

/* Uniform Types */

	FLOAT_VEC2: number;
	FLOAT_VEC3: number;
	FLOAT_VEC4: number;
	INT_VEC2: number;
	INT_VEC3: number;
	INT_VEC4: number;
	BOOL: number;
	BOOL_VEC2: number;
	BOOL_VEC3: number;
	BOOL_VEC4: number;
	FLOAT_MAT2: number;
	FLOAT_MAT3: number;
	FLOAT_MAT4: number;
	SAMPLER_2D: number;
	SAMPLER_CUBE: number;

/* Vertex Arrays */

	VERTEX_ATTRIB_ARRAY_ENABLED: number;
	VERTEX_ATTRIB_ARRAY_SIZE: number;
	VERTEX_ATTRIB_ARRAY_STRIDE: number;
	VERTEX_ATTRIB_ARRAY_TYPE: number;
	VERTEX_ATTRIB_ARRAY_NORMALIZED: number;
	VERTEX_ATTRIB_ARRAY_POINTER: number;
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;

/* Shader Source */

	COMPILE_STATUS: number;

/* Shader Precision-Specified Types */

	LOW_FLOAT: number;
	MEDIUM_FLOAT: number;
	HIGH_FLOAT: number;
	LOW_INT: number;
	MEDIUM_INT: number;
	HIGH_INT: number;

/* Framebuffer Object. */

	FRAMEBUFFER: number;
	RENDERBUFFER: number;

	RGBA4: number;
	RGB5_A1: number;
	RGB565: number;
	DEPTH_COMPONENT16: number;
	STENCIL_INDEX: number;
	STENCIL_INDEX8: number;
	DEPTH_STENCIL: number;

	RENDERBUFFER_WIDTH: number;
	RENDERBUFFER_HEIGHT: number;
	RENDERBUFFER_INTERNAL_FORMAT: number;
	RENDERBUFFER_RED_SIZE: number;
	RENDERBUFFER_GREEN_SIZE: number;
	RENDERBUFFER_BLUE_SIZE: number;
	RENDERBUFFER_ALPHA_SIZE: number;
	RENDERBUFFER_DEPTH_SIZE: number;
	RENDERBUFFER_STENCIL_SIZE: number;

	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;

	COLOR_ATTACHMENT0: number;
	DEPTH_ATTACHMENT: number;
	STENCIL_ATTACHMENT: number;
	DEPTH_STENCIL_ATTACHMENT: number;

	NONE: number;

	FRAMEBUFFER_COMPLETE: number;
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;
	FRAMEBUFFER_UNSUPPORTED: number;

	FRAMEBUFFER_BINDING: number;
	RENDERBUFFER_BINDING: number;
	MAX_RENDERBUFFER_SIZE: number;

	INVALID_FRAMEBUFFER_OPERATION: number;

/* WebGL-specific enums */

	UNPACK_FLIP_Y_WEBGL: number;
	UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;
	CONTEXT_LOST_WEBGL: number;
	UNPACK_COLORSPACE_CONVERSION_WEBGL: number;
	BROWSER_DEFAULT_WEBGL: number;




	canvas: HTMLCanvasElement;
	drawingBufferWidth: number;
	drawingBufferHeight: number;

	getContextAttributes(): WebGLContextAttributes;
	isContextLost(): bool;

	getSupportedExtensions(): string[];
	getExtension(name: string): any;

	activeTexture(texture: number): void;
	attachShader(program: WebGLProgram, shader: WebGLShader): void;
	bindAttribLocation(program: WebGLProgram, index: number, name: string): void;
	bindBuffer(target: number, buffer: WebGLBuffer): void;
	bindFramebuffer(target: number, framebuffer: WebGLFramebuffer): void;
	bindRenderbuffer(target: number, renderbuffer: WebGLRenderbuffer): void;
	bindTexture(target: number, texture: WebGLTexture): void;
	blendColor(red: number, green: number, blue: number, alpha: number): void;
	blendEquation(mode: number): void;
	blendEquationSeparate(modeRGB: number, modeAlpha: number): void;
	blendFunc(sfactor: number, dfactor: number): void;
	blendFuncSeparate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;

	bufferData(target: number, size: number, usage: number): void;
	bufferData(target: number, data: ArrayBufferView, usage: number): void;
	bufferData(target: number, data: ArrayBuffer, usage: number): void;
	bufferSubData(target: number, offset: number, data: ArrayBufferView): void;
	bufferSubData(target: number, offset: number, data: ArrayBuffer): void;

	checkFramebufferStatus(target: number): number;
	clear(mask: number): void;
	clearColor(red: number, green: number, blue: number, alpha: number): void;
	clearDepth(depth: number): void;
	clearStencil(s: number): void;
	colorMask(red: bool, green: bool, blue: bool, alpha: bool): void;
	compileShader(shader: WebGLShader): void;

	compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, data: ArrayBufferView): void;
	compressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, data: ArrayBufferView): void;

	copyTexImage2D(target: number, level: number, internalformat: number, x: number, y: number, width: number, height: number, border: number): void;
	copyTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;

	createBuffer(): WebGLBuffer;
	createFramebuffer(): WebGLFramebuffer;
	createProgram(): WebGLProgram;
	createRenderbuffer(): WebGLRenderbuffer;
	createShader(type: number): WebGLShader;
	createTexture(): WebGLTexture;

	cullFace(mode: number): void;

	deleteBuffer(buffer: WebGLBuffer): void;
	deleteFramebuffer(framebuffer: WebGLFramebuffer): void;
	deleteProgram(program: WebGLProgram): void;
	deleteRenderbuffer(renderbuffer: WebGLRenderbuffer): void;
	deleteShader(shader: WebGLShader): void;
	deleteTexture(texture: WebGLTexture): void;

	depthFunc(func: number): void;
	depthMask(flag: bool): void;
	depthRange(zNear: number, zFar: number): void;
	detachShader(program: WebGLProgram, shader: WebGLShader): void;
	disable(cap: number): void;
	disableVertexAttribArray(index: number): void;
	drawArrays(mode: number, first: number, count: number): void;
	drawElements(mode: number, count: number, type: number, offset: number): void;

	enable(cap: number): void;
	enableVertexAttribArray(index: number): void;
	finish(): void;
	flush(): void;
	framebufferRenderbuffer(target: number, attachment: number, renderbuffertarget: number, renderbuffer: WebGLRenderbuffer): void;
	framebufferTexture2D(target: number, attachment: number, textarget: number, texture: WebGLTexture, level: number): void;
	frontFace(mode: number): void;

	generateMipmap(target: number): void;

	getActiveAttrib(program: WebGLProgram, index: number): WebGLActiveInfo;
	getActiveUniform(program: WebGLProgram, index: number): WebGLActiveInfo;
	getAttachedShaders(program: WebGLProgram): WebGLShader[];

	getAttribLocation(program: WebGLProgram, name: string): number;

	getBufferParameter(target: number, pname: number): any;
	getParameter(pname: number): any;

	getError(): number;

	getFramebufferAttachmentParameter(target: number, attachment: number, pname: number): any;
	getProgramParameter(program: WebGLProgram, pname: number): any;
	getProgramInfoLog(program: WebGLProgram): string;
	getRenderbufferParameter(target: number, pname: number): any;
	getTranslatedShaderSource(shader: WebGLShader): string;
	getShaderParameter(shader: WebGLShader, pname: number): any;
	getShaderPrecisionFormat(shadertype: number, precisiontype: number): WebGLShaderPrecisionFormat;
	getShaderInfoLog(shader: WebGLShader): string;

	getShaderSource(shader: WebGLShader): string;

	getTexParameter(target: number, pname: number): any;

	getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;

	getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation;

	getVertexAttrib(index: number, pname: number): any;

	getVertexAttribOffset(index: number, pname: number): number;

	hint(target: number, mode: number): void;
	isBuffer(buffer: WebGLBuffer): bool;
	isEnabled(cap: number): bool;
	isFramebuffer(framebuffer: WebGLFramebuffer): bool;
	isProgram(program: WebGLProgram): bool;
	isRenderbuffer(renderbuffer: WebGLRenderbuffer): bool;
	isShader(shader: WebGLShader): bool;
	isTexture(texture: WebGLTexture): bool;
	lineWidth(width: number): void;
	linkProgram(program: WebGLProgram): void;
	pixelStorei(pname: number, param: number): void;
	polygonOffset(factor: number, units: number): void;

	readPixels(x: number, y: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView): void;

	renderbufferStorage(target: number, internalformat: number, width: number, height: number): void;
	sampleCoverage(value: number, invert: bool): void;
	scissor(x: number, y: number, width: number, height: number): void;

	shaderSource(shader: WebGLShader, source: string): void;

	stencilFunc(func: number, ref: number, mask: number): void;
	stencilFuncSeparate(face: number, func: number, ref: number, mask: number): void;
	stencilMask(mask: number): void;
	stencilMaskSeparate(face: number, mask: number): void;
	stencilOp(fail: number, zfail: number, zpass: number): void;
	stencilOpSeparate(face: number, fail: number, zfail: number, zpass: number): void;

	texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView): void;
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, pixels: ImageData): void;
/* May throw DOMException*/
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, image: HTMLImageElement): void;
/* May throw DOMException*/
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, canvas: HTMLCanvasElement): void;
/* May throw DOMException*/
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, video: HTMLVideoElement): void;

	texParameterf(target: number, pname: number, param: number): void;
	texParameteri(target: number, pname: number, param: number): void;

	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView): void;
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, pixels: ImageData): void;
/* May throw DOMException*/
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, image: HTMLImageElement): void;
/* May throw DOMException*/
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, canvas: HTMLCanvasElement): void;
/* May throw DOMException*/
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, video: HTMLVideoElement): void;

	uniform1f(location: WebGLUniformLocation, x: number): void;
	uniform1fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform1fv(location: WebGLUniformLocation, v: number[]): void;
	uniform1i(location: WebGLUniformLocation, x: number): void;
	uniform1iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform1iv(location: WebGLUniformLocation, v: number[]): void;
	uniform2f(location: WebGLUniformLocation, x: number, y: number): void;
	uniform2fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform2fv(location: WebGLUniformLocation, v: number[]): void;
	uniform2i(location: WebGLUniformLocation, x: number, y: number): void;
	uniform2iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform2iv(location: WebGLUniformLocation, v: number[]): void;
	uniform3f(location: WebGLUniformLocation, x: number, y: number, z: number): void;
	uniform3fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform3fv(location: WebGLUniformLocation, v: number[]): void;
	uniform3i(location: WebGLUniformLocation, x: number, y: number, z: number): void;
	uniform3iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform3iv(location: WebGLUniformLocation, v: number[]): void;
	uniform4f(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
	uniform4fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform4fv(location: WebGLUniformLocation, v: number[]): void;
	uniform4i(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
	uniform4iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform4iv(location: WebGLUniformLocation, v: number[]): void;

	uniformMatrix2fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix2fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;

	useProgram(program: WebGLProgram): void;
	validateProgram(program: WebGLProgram): void;

	vertexAttrib1f(indx: number, x: number): void;
	vertexAttrib1fv(indx: number, values: Float32Array): void;
	vertexAttrib1fv(indx: number, value: number[]): void;
	vertexAttrib2f(indx: number, x: number, y: number): void;
	vertexAttrib2fv(indx: number, values: Float32Array): void;
	vertexAttrib2fv(indx: number, value: number[]): void;
	vertexAttrib3f(indx: number, x: number, y: number, z: number): void;
	vertexAttrib3fv(indx: number, values: Float32Array): void;
	vertexAttrib3fv(indx: number, value: number[]): void;
	vertexAttrib4f(indx: number, x: number, y: number, z: number, w: number): void;
	vertexAttrib4fv(indx: number, values: Float32Array): void;
	vertexAttrib4fv(indx: number, value: number[]): void;
	vertexAttribPointer(indx: number, size: number, type: number, normalized: bool, stride: number, offset: number): void;

	viewport(x: number, y: number, width: number, height: number): void;
};

interface CanvasRenderingContext {

}

interface WebGLRenderingContext extends CanvasRenderingContext {

}



declare var WebGLRenderingContext: {
    prototype: WebGLRenderingContext;
    new(): WebGLRenderingContext;
}

interface HTMLCanvasElement extends HTMLElement {
    getContext(contextId: string, args: WebGLContextAttributes): WebGLRenderingContext;
}

interface WEBGL_debug_shaders {
      getTranslatedShaderSource(shader: WebGLShader): DOMString;
};

interface WEBGL_debug_renderer_info {
    UNMASKED_VENDOR_WEBGL: number;
    UNMASKED_RENDERER_WEBGL: number;
};

interface WEBGL_compressed_texture_pvrtc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: number;
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: number;
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: number;
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: number;
};

interface WEBGL_compressed_texture_atc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_ATC_WEBGL: number;
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: number;
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: number;
};

interface WEBGL_compressed_texture_s3tc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_S3TC_DXT1_EXT : number;
    COMPRESSED_RGBA_S3TC_DXT1_EXT: number;
    COMPRESSED_RGBA_S3TC_DXT3_EXT: number;
    COMPRESSED_RGBA_S3TC_DXT5_EXT: number;
};

interface WEBGL_depth_texture {
  UNSIGNED_INT_24_8_WEBGL: number;
};

interface OES_element_index_uint {
};

interface WebGLVertexArrayObjectOES extends WebGLObject {
};

interface OES_vertex_array_object {
    VERTEX_ARRAY_BINDING_OES: number;

    createVertexArrayOES(): WebGLVertexArrayObjectOES;
    deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
    isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): bool;
    bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
};

interface OES_standard_derivatives {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: number;
};

interface OES_texture_half_float {
 	HALF_FLOAT_OES: number;
};

interface OES_texture_float {
};

interface WEBGL_lose_context {
      loseContext(): void;
      restoreContext(): void;
};

interface WEBGL_multiple_render_targets {
    COLOR_ATTACHMENT0_WEBGL: number;
    COLOR_ATTACHMENT1_WEBGL: number;
    COLOR_ATTACHMENT2_WEBGL: number;
    COLOR_ATTACHMENT3_WEBGL: number;
    COLOR_ATTACHMENT4_WEBGL: number;
    COLOR_ATTACHMENT5_WEBGL: number;
    COLOR_ATTACHMENT6_WEBGL: number;
    COLOR_ATTACHMENT7_WEBGL: number;
    COLOR_ATTACHMENT8_WEBGL: number;
    COLOR_ATTACHMENT9_WEBGL: number;
    COLOR_ATTACHMENT10_WEBGL: number;
    COLOR_ATTACHMENT11_WEBGL: number;
    COLOR_ATTACHMENT12_WEBGL: number;
    COLOR_ATTACHMENT13_WEBGL: number;
    COLOR_ATTACHMENT14_WEBGL: number;
    COLOR_ATTACHMENT15_WEBGL: number;

    DRAW_BUFFER0_WEBGL: number;
    DRAW_BUFFER1_WEBGL: number;
    DRAW_BUFFER2_WEBGL: number;
    DRAW_BUFFER3_WEBGL: number;
    DRAW_BUFFER4_WEBGL: number;
    DRAW_BUFFER5_WEBGL: number;
    DRAW_BUFFER6_WEBGL: number;
    DRAW_BUFFER7_WEBGL: number;
    DRAW_BUFFER8_WEBGL: number;
    DRAW_BUFFER9_WEBGL: number;
    DRAW_BUFFER10_WEBGL: number;
    DRAW_BUFFER11_WEBGL: number;
    DRAW_BUFFER12_WEBGL: number;
    DRAW_BUFFER13_WEBGL: number;
    DRAW_BUFFER14_WEBGL: number;
    DRAW_BUFFER15_WEBGL: number;

    MAX_COLOR_ATTACHMENTS_WEBGL: number;
    MAX_DRAW_BUFFERS_WEBGL: number;

    drawBuffersWEBGL(buffers: number[]): void;
};

interface WEBGL_fbo_color_attachments {
    COLOR_ATTACHMENT0: number;
    COLOR_ATTACHMENT1: number;
    COLOR_ATTACHMENT2: number;
    COLOR_ATTACHMENT3: number;
    COLOR_ATTACHMENT4: number;
    COLOR_ATTACHMENT5: number;
    COLOR_ATTACHMENT6: number;
    COLOR_ATTACHMENT7: number;
    COLOR_ATTACHMENT8: number;
    COLOR_ATTACHMENT9: number;
    COLOR_ATTACHMENT10: number;
    COLOR_ATTACHMENT11: number;
    COLOR_ATTACHMENT12: number;
    COLOR_ATTACHMENT13: number;
    COLOR_ATTACHMENT14: number;
    COLOR_ATTACHMENT15: number;

    MAX_COLOR_ATTACHMENTS: number;
};

// debug


declare var WebGLDebugUtils: {
/**
	 * Initializes this module. Safe to call more than once.
	 *    you have more than one context it doesn't matter which one
     *    you pass in, it is only used to pull out constants.
	 */

	init: (ctx: WebGLRenderingContext) => void;
/**
	 * Returns true or false if value matches any WebGL enum
	 */

	mightBeEnum: (value: any) => bool;
/**
	 * Gets an string version of an WebGL enum.
	 *
	 * Example:
	 *   WebGLDebugUtil.init(ctx);
	 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
	 *
	 */

	glEnumToString: (value: number) => string;
/**
     * Converts the argument of a WebGL function to a string.
     * Attempts to convert enum arguments to strings.
     *
     * Example:
     *   WebGLDebugUtil.init(ctx);
     *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);
     *
     * would return 'TEXTURE_2D'
     */

    glFunctionArgToString: (functionName: string, argumentIndex:  number , value: any) => string;
/**
     * Converts the arguments of a WebGL function to a string.
     * Attempts to convert enum arguments to strings.
     */

    glFunctionArgsToString: (functionName: string, args: IArguments) => string;
/**
     * Given a WebGL context returns a wrapped context that calls
     * gl.getError after every command and calls a function if the
     * result is not NO_ERROR.
     *
     * You can supply your own function if you want. For example, if you'd like
     * an exception thrown on any GL error you could do this
     *
     *    function throwOnGLError(err, funcName, args) {
     *      throw WebGLDebugUtils.glEnumToString(err) +
     *            " was caused by call to " + funcName;
     *    };
     *
     *    ctx = WebGLDebugUtils.makeDebugContext(
     *        canvas.getContext("webgl"), throwOnGLError);
     */

	makeDebugContext: (
		ctx: WebGLRenderingContext,
		onErrorFunc?: (err:  number , funcName: string, args: IArguments) => void,
		onFunc?: (funcName: string, args: IArguments) => void) => WebGLRenderingContext;

/**
	 * Given a canvas element returns a wrapped canvas element that will
	 * simulate lost context. The canvas returned adds the following functions.
	 *
	 * loseContext:
	 *   simulates a lost context event.
	 *
	 * restoreContext:
	 *   simulates the context being restored.
	 *
	 * lostContextInNCalls:
	 *   loses the context after N gl calls.
	 *
	 * getNumCalls:
	 *   tells you how many gl calls there have been so far.
	 *
	 * setRestoreTimeout:
	 *   sets the number of milliseconds until the context is restored
	 *   after it has been lost. Defaults to 0. Pass -1 to prevent
	 *   automatic restoring.
	 */

	makeLostContextSimulatingCanvas: (canvas: HTMLCanvasElement) => HTMLCanvasElement;
/**
     * Resets a context to the initial state.
     */

	resetToInitialState: (ctx: WebGLRenderingContext) => void;

}


/* ClearBufferMask */





/* BeginMode */









/* AlphaFunction (not supported in ES20) */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* BlendingFactorDest */










/* BlendingFactorSrc */

/*      ZERO */

/*      ONE */




/*      SRC_ALPHA */

/*      ONE_MINUS_SRC_ALPHA */

/*      DST_ALPHA */

/*      ONE_MINUS_DST_ALPHA */


/* BlendEquationSeparate */



/* same as BLEND_EQUATION */



/* BlendSubtract */




/* Separate Blend Functions */











/* Buffer Objects */















/* CullFaceMode */





/* DepthFunction */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* EnableCap */

/* TEXTURE_2D */











/* ErrorCode */







/* FrontFaceDirection */




/* GetPName */



























/*      SCISSOR_TEST */















/*      POLYGON_OFFSET_FILL */








/* GetTextureParameter */

/*      TEXTURE_MAG_FILTER */

/*      TEXTURE_MIN_FILTER */

/*      TEXTURE_WRAP_S */

/*      TEXTURE_WRAP_T */




/* HintMode */





/* HintTarget */



/* DataType */











/* PixelFormat */










/* PixelType */

/*      UNSIGNED_BYTE */





/* Shaders */




















/* StencilFunction */










/* StencilOp */

/*      ZERO */









/* StringName */





/* TextureMagFilter */




/* TextureMinFilter */

/*      NEAREST */

/*      LINEAR */






/* TextureParameterName */






/* TextureTarget */














/* TextureUnit */



































/* TextureWrapMode */





/* Uniform Types */

















/* Vertex Arrays */









/* Shader Source */



/* Shader Precision-Specified Types */








/* Framebuffer Object. */














































/* WebGL-specific enums */





























//WebGL Extensions 










//draft











//Future























































// #define box(...) Box.stackCeil.setPosition(__VA_ARGS__)

module akra.geometry {
	export class Box implements IBox {
		left:  number  = 0;
		top:  number  = 0;
		front:  number  = 0;
		right:  number  = 0;
		bottom:  number  = 0;
		back:  number  = 0;

		/**@inline*/  get width():  number  {
			return this.right - this.left;
		}

		/**@inline*/  get height():  number  {
			return this.bottom - this.top;
		}

		/**@inline*/  get depth():  number  {
			return this.back - this.front;
		}

		constructor ();
		constructor (pExtents: IBox);
		constructor (iLeft:  number , iTop:  number , iRight:  number , iBottom:  number );
		constructor (iLeft:  number , iTop:  number , iFront:  number , iRight:  number , iBottom:  number , iBack:  number );
		constructor (l:  number  = 0, t:  number  = 0, ff:  number  = 0, r:  number  = 1, b:  number  = 1, bb:  number  = 1) {
			switch (arguments.length) {
				case 1:
					this.left 	= arguments[0].left;
					this.top 	= arguments[0].top;
					this.front 	= arguments[0].front;

					this.right 	= arguments[0].right;
					this.bottom = arguments[0].bottom;
					this.back 	= arguments[0].back;
					break;

				case 0:
					this.left 	= 0;
					this.top 	= 0;
					this.front 	= 0;

					this.right 	= 1;
					this.bottom = 1;
					this.back 	= 1;
					break;

				case 3:
					this.left 	= arguments[0];
					this.top 	= arguments[1];
					this.front 	= arguments[2];

					this.right 	= arguments[0] + 1;
					this.bottom = arguments[1] + 1;
					this.back 	= arguments[2] + 1;
					break;
				case 6:
					this.left 	= arguments[0];
					this.top 	= arguments[1];
					this.front 	= arguments[2];

					this.right 	= arguments[3];
					this.bottom = arguments[4];
					this.back 	= arguments[5];
					break;
				case 4:
					this.left 	= arguments[0];
					this.top 	= arguments[1];
					this.right 	= arguments[2];
					this.bottom = arguments[3];

					this.back 	= 1;
					this.front 	= 0;
					break;
				case 5:
					{ logger.setSourceLocation( "geometry/Box.ts" , 82 ); logger.error("invalid number of arguments"); } ;
			}

			{ logger.setSourceLocation( "geometry/Box.ts" , 85 ); logger.assert(this.right >= this.left && this.bottom >= this.top && this.back >= this.front); } ;
		}

		contains(pDest: IBox): bool {
			return (pDest.left >= this.left && pDest.top >= this.top && pDest.front >= this.front &&
	    		pDest.right <= this.right && pDest.bottom <= this.bottom && pDest.back <= this.back);
		}

		setPosition(iLeft:  number , iTop:  number , iWidth:  number , iHeight:  number , iFront?:  number  = 0, iDepth?:  number  = 1): void {
			this.left   = iLeft;
			this.top    = iTop;
			this.right  = iLeft + iWidth;
			this.bottom = iTop + iHeight;
			this.front 	= iFront;
			this.back 	= iFront + iDepth;
		}

		isEqual(pDest: IBox): bool {
			return (pDest.left == this.left && pDest.top == this.top && pDest.front == this.front &&
	    		pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back);
		}

		toString(): string {
			return "---------------------------\n" +
				   "left: " + this.left + ", right: " + this.right + "\n" +
				   "top: " + this.top + ", bottom: " + this.bottom + "\n" +
				   "front: " + this.front + ", back: " + this.back + "\n" +
				   "---------------------------";
		}

		static get stackCeil(): Box { Box.stackPosition = Box.stackPosition === Box.stackSize - 1? 0: Box.stackPosition; return Box.stack[Box.stackPosition ++]; } static stackSize: number = 20; static stackPosition: number = 0; static stack: Box[] = (function(): Box[]{ var pStack: Box[] = new Array(Box.stackSize); for(var i: number = 0; i<Box.stackSize; i++){ pStack[i] = new Box(); } return pStack})();
	}

	export function box(): IBox;
	export function box(pBox: IBox): IBox;
	export function box(iLeft:  number , iTop:  number , iFront:  number ): IBox;
	export function box(iLeft:  number , iTop:  number , iRight:  number , iBottom:  number ): IBox;
	export function box(iLeft:  number , iTop:  number , iFront:  number , iRight:  number , iBottom:  number , iBack:  number ): IBox;
	export function box(): IBox {
		var pBox: IBox = Box.stack[Box.stackPosition ++];

        if(Box.stackPosition === Box.stackSize){
            Box.stackPosition = 0;
        }

        var iLeft:  number  = 0,
        	iTop:  number  = 0,
        	iFront:  number  = 0,
        	iWidth:  number  = 0,
        	iHeight:  number  = 0,
        	iDepth:  number  = 0;

		switch(arguments.length){
			case 1:
				iLeft 	= arguments[0].left;
				iTop 	= arguments[0].top;
				iFront 	= arguments[0].front;
				iWidth 	= arguments[0].width;
				iHeight = arguments[0].height;
				iDepth 	= arguments[0].depth;
				break;
			case 0:
				iLeft 	= 0;
				iTop 	= 0;
				iFront 	= 0;
				iWidth 	= 1;
				iHeight = 1;
				iDepth 	= 1;
				break;
			case 3:
				iLeft 	= arguments[0];
				iTop 	= arguments[1];
				iFront 	= arguments[2];
				iWidth 	= arguments[0] + 1;
				iHeight = arguments[1] + 1;
				iDepth 	= arguments[2] + 1;
				break;
/*case 0:
			case 3:
			case 6:
				pBox.setPosition(l, t, r - l, b - t, ff, bb - ff);
				break;
			case 4:
				pBox.setPosition(l, t, arguments[2] - l, arguments[3]- t, 0, 1);
				break;
			default:
				ERROR("Inavlid number of arguments");*/

			case 6:
				iLeft 	= arguments[0];
				iTop 	= arguments[1];
				iFront 	= arguments[2];
				iWidth 	= arguments[3] - arguments[0];
				iHeight = arguments[4] - arguments[1];
				iDepth 	= arguments[5] - arguments[2];
				break;
			case 4:
				iLeft 	= arguments[0];
				iTop 	= arguments[1];
				iFront 	= 0;
				iWidth 	= arguments[2] - arguments[0];
				iHeight = arguments[3] - arguments[1];
				iDepth 	= 1;
				break;
			default:
				{ logger.setSourceLocation( "geometry/Box.ts" , 189 ); logger.error("Inavlid number of arguments"); } ;
				return null;
		}

		pBox.setPosition(iLeft, iTop, iWidth, iHeight, iFront, iDepth);

		return pBox;
	}
}







module akra.pixelUtil {
	export class PixelBox extends geometry.Box implements IPixelBox {
		data: Uint8Array;
		format: EPixelFormats;
		rowPitch:  number ;
		slicePitch:  number ;

		constructor();
		constructor(iWidth:  number , iHeight:  number , iDepth:  number , ePixelFormat: EPixelFormats, pPixelData: any = null);
		constructor (pExtents: IBox, ePixelFormat: EPixelFormats, pPixelData: Uint8Array = null);
		constructor (iWidth?: any, iHeight?: any, iDepth?: any, ePixelFormat?: any, pPixelData: Uint8Array = null) {
			if (arguments.length === 0) {
				super();
				this.data = null;
				this.format = EPixelFormats.UNKNOWN;
				this.setConsecutive();
				return;
			}

			if (arguments.length >= 4) {
				super(0, 0, 0, < number >iWidth, < number >iHeight, < number >iDepth);
				this.data = isDef(arguments[4]) ? (<Uint8Array>arguments[4]) : null;
				this.format = <EPixelFormats>arguments[3];
			}
			else {
				super(<IBox>arguments[0]);
				this.data = <Uint8Array>arguments[2];
				this.format = <EPixelFormats>arguments[1];
			}

			this.setConsecutive();
		}

		setConsecutive(): void {
			this.rowPitch = this.width;
			this.slicePitch = this.width * this.height;
		}

		getRowSkip():  number  { return this.rowPitch - this.width; }
		getSliceSkip():  number  { return this.slicePitch - (this.height * this.rowPitch); }

		isConsecutive(): bool {
			return this.rowPitch == this.width && this.slicePitch == this.width * this.height;
		}

		getConsecutiveSize():  number  {
			return pixelUtil.getMemorySize(this.width, this.height, this.depth, this.format);
		}

		getSubBox(pDest: IBox, pDestPixelBox?: IPixelBox = null): PixelBox {
			if(pixelUtil.isCompressed(this.format)) {
				if(pDest.left == this.left && pDest.top == this.top && pDest.front == this.front &&
				   pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back) {
// Entire buffer is being queried
					return this;
				}

				{ logger.setSourceLocation( "PixelBox.ts" , 69 ); logger.error("Cannot return subvolume of compressed PixelBuffer", "PixelBox::getSubVolume"); } ;
			}

			if(!this.contains(pDest))
			{
				{ logger.setSourceLocation( "PixelBox.ts" , 74 ); logger.error("Bounds out of range", "PixelBox::getSubVolume"); } ;
			}

			var elemSize:  number  = pixelUtil.getNumElemBytes(this.format);
// Calculate new data origin
// Notice how we do not propagate left/top/front from the incoming box, since
// the returned pointer is already offset

			var rval: PixelBox = null;

			if(isNull(pDestPixelBox)){
				rval = new PixelBox();
			}
			else {
				rval = <PixelBox>pDestPixelBox;
			}

			rval.setPosition(0, 0, pDest.width, pDest.height, 0, pDest.depth);
			rval.format = this.format;
			rval.data =	(<Uint8Array> this.data).subarray(((pDest.left - this.left) * elemSize)
						+ ((pDest.top - this.top) * this.rowPitch * elemSize)
						+ ((pDest.front - this.front) * this.slicePitch * elemSize));

			rval.rowPitch = this.rowPitch;
			rval.slicePitch = this.slicePitch;
			rval.format = this.format;

			return rval;
		}

		getColorAt(pColor: IColor, x:  number , y:  number , z?:  number =0): IColor {
			if (isNull(pColor)) {
				pColor = new Color(0.);
			}

	        var pixelSize:  number  = pixelUtil.getNumElemBytes(this.format);
	        var pixelOffset:  number  = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);

	        pixelUtil.unpackColour(pColor, this.format, this.data.subarray(pixelOffset,pixelOffset+pixelSize));

	        return pColor;
		}

		setColorAt(pColor: IColor, x:  number , y:  number , z?:  number =0): void {
			var pixelSize:  number  = pixelUtil.getNumElemBytes(this.format);
	        var pixelOffset:  number  = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);
	        pixelUtil.packColour(pColor, this.format, this.data.subarray(pixelOffset,pixelOffset+pixelSize));
		}

		scale(pDest: IPixelBox, eFilter: EFilters = EFilters.BILINEAR): bool {
			return false;
		}

		refresh(pExtents: IBox, ePixelFormat: EPixelFormats, pPixelData: Uint8Array): void {
			this.left 	= pExtents.left;
			this.top 	= pExtents.top;
			this.front 	= pExtents.front;

			this.right 	= pExtents.right;
			this.bottom = pExtents.bottom;
			this.back 	= pExtents.back;

			this.data = pPixelData;
			this.format = ePixelFormat;

			this.setConsecutive();
		}

		toString(): string{
			return "|---------------------------|\n" +
				   super.toString() + "\n" +
				   "length: " + (this.data ? this.data.length : 0) + "\n" +
				   "|---------------------------|";
		}

		static get stackCeil(): PixelBox { PixelBox.stackPosition = PixelBox.stackPosition === PixelBox.stackSize - 1? 0: PixelBox.stackPosition; return PixelBox.stack[PixelBox.stackPosition ++]; } static stackSize: number = 20; static stackPosition: number = 0; static stack: PixelBox[] = (function(): PixelBox[]{ var pStack: PixelBox[] = new Array(PixelBox.stackSize); for(var i: number = 0; i<PixelBox.stackSize; i++){ pStack[i] = new PixelBox(); } return pStack})();
	}

	export function pixelBox(): IPixelBox;
	export function pixelBox(iWidth:  number , iHeight:  number , iDepth:  number , ePixelFormat: EPixelFormats, pPixelData?: Uint8Array = null): IPixelBox;
	export function pixelBox(pExtents: IBox, ePixelFormat: EPixelFormats, pPixelData?: Uint8Array = null): IPixelBox;
	export function pixelBox(): IPixelBox {
		var pPixelBox: IPixelBox = PixelBox.stack[PixelBox.stackPosition ++];

        if(PixelBox.stackPosition === PixelBox.stackSize){
            PixelBox.stackPosition = 0;
        }

        var pBox: IBox = null;
        var pPixelData: Uint8Array = null;
        var ePixelFormat: EPixelFormats = EPixelFormats.UNKNOWN;

        switch(arguments.length){
        	case 2:
        	case 3:
        		pBox = arguments[0];
        		ePixelFormat = arguments[1];
        		pPixelData = arguments[2] || null;
        		break;
        	case 4:
        	case 5:
        		pBox = geometry.box(0, 0, 0, arguments[0], arguments[1], arguments[2]);
        		ePixelFormat = arguments[3];
        		pPixelData = arguments[4] || null;
        		break;
        	default:
        		pBox = geometry.box(0, 0, 0, 1, 1, 1);
        		break;
        }

        pPixelBox.refresh(pBox, ePixelFormat, pPixelData);

        return pPixelBox;
	}

}










module akra {

	export interface IPixelFormatDescription {
/* Name of the format, as in the enum */

        name: string;
/* Number of bytes one element (colour value) takes. */

        elemBytes:  number ;
/* Pixel format flags, see enum PixelFormatFlags for the bit field
        * definitions
        */

        flags:  number ;
/** Component type
         */

        componentType: EPixelComponentTypes;
/** Component count
         */

        componentCount:  number ;
/* Number of bits for red(or luminance), green, blue, alpha
        */

        rbits:  number ;
        gbits:  number ;
        bbits:  number ;
/*, ibits, dbits, ... */
        abits:  number ;

/* Masks and shifts as used by packers/unpackers */

        rmask:  number ;
        gmask:  number ;
        bmask:  number ;
        amask:  number ;

        rshift:  number ;
        gshift:  number ;
        bshift:  number ;
        ashift:  number ;
	}


	function fillPixelFormats(pData: any[][]): IPixelFormatDescription[] {
		var pPixelFormats: IPixelFormatDescription[] = [];

		for (var i:  number  = 0; i < pData.length; ++ i) {
			var pEl: any[] = pData[i];
			pPixelFormats.push({
					name: 			<string>pEl[0],
					elemBytes: 		< number >	pEl[1],
					flags: 			< number >	pEl[2],
					componentType: 	<EPixelComponentTypes>pEl[3],
					componentCount: < number >	pEl[4],

					rbits: < number >pEl[5],
					gbits: < number >pEl[6],
					bbits: < number >pEl[7],
					abits: < number >pEl[8],

					rmask: < number >pEl[9],
					gmask: < number >pEl[10],
					bmask: < number >pEl[11],
					amask: < number >pEl[12],

					rshift: < number >pEl[13],
					gshift: < number >pEl[14],
					bshift: < number >pEl[15],
					ashift: < number >pEl[16]
				});
		}

		return pPixelFormats;
	}

	var pPixelFormats: IPixelFormatDescription[] = fillPixelFormats([
		["PF_UNKNOWN",
/* Bytes per element */

        0,
/* Flags */

        0,
/* Component type and count */

        EPixelComponentTypes.BYTE, 0,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//1-----------------------------------------------------------------------
        ["PF_L8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF, 0, 0, 0, 0, 0, 0, 0
        ],
//2-----------------------------------------------------------------------
        ["PF_L16",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.SHORT, 1,
/* rbits, gbits, bbits, abits */

        16, 0, 0, 0,
/* Masks and shifts */

        0xFFFF, 0, 0, 0, 0, 0, 0, 0
        ],
//3-----------------------------------------------------------------------
        ["PF_A8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 8,
/* Masks and shifts */

        0, 0, 0, 0xFF, 0, 0, 0, 0
        ],
//4-----------------------------------------------------------------------
        ["PF_A4L4",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        4, 0, 0, 4,
/* Masks and shifts */

        0x0F, 0, 0, 0xF0, 0, 0, 0, 4
        ],
//5-----------------------------------------------------------------------
        ["PF_BYTE_LA",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.LUMINANCE,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 8,
/* Masks and shifts */

        0,0,0,0,0,0,0,0
        ],
//6-----------------------------------------------------------------------
        ["PF_R5G6B5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        5, 6, 5, 0,
/* Masks and shifts */

        0xF800, 0x07E0, 0x001F, 0,
        11, 5, 0, 0
        ],
//7-----------------------------------------------------------------------
		["PF_B5G6R5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        5, 6, 5, 0,
/* Masks and shifts */

        0x001F, 0x07E0, 0xF800, 0,
        0, 5, 11, 0
        ],
//8-----------------------------------------------------------------------
        ["PF_A4R4G4B4",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        4, 4, 4, 4,
/* Masks and shifts */

        0x0F00, 0x00F0, 0x000F, 0xF000,
        8, 4, 0, 12
        ],
//9-----------------------------------------------------------------------
        ["PF_A1R5G5B5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        5, 5, 5, 1,
/* Masks and shifts */

        0x7C00, 0x03E0, 0x001F, 0x8000,
        10, 5, 0, 15,
        ],
//10-----------------------------------------------------------------------
        ["PF_R8G8B8",
/* Bytes per element */

/* 24 bit integer -- special*/
        3,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0xFF0000, 0x00FF00, 0x0000FF, 0,
        16, 8, 0, 0
        ],
//11-----------------------------------------------------------------------
        ["PF_B8G8R8",
/* Bytes per element */

/* 24 bit integer -- special*/
        3,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x0000FF, 0x00FF00, 0xFF0000, 0,
        0, 8, 16, 0
        ],
//12-----------------------------------------------------------------------
        ["PF_A8R8G8B8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
        16, 8, 0, 24
        ],
//13-----------------------------------------------------------------------
        ["PF_A8B8G8R8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000,
        0, 8, 16, 24,
        ],
//14-----------------------------------------------------------------------
        ["PF_B8G8R8A8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x0000FF00, 0x00FF0000, 0xFF000000, 0x000000FF,
        8, 16, 24, 0
        ],
//15-----------------------------------------------------------------------
        ["PF_A2R10G10B10",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        10, 10, 10, 2,
/* Masks and shifts */

        0x3FF00000, 0x000FFC00, 0x000003FF, 0xC0000000,
        20, 10, 0, 30
        ],
//16-----------------------------------------------------------------------
        ["PF_A2B10G10R10",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        10, 10, 10, 2,
/* Masks and shifts */

        0x000003FF, 0x000FFC00, 0x3FF00000, 0xC0000000,
        0, 10, 20, 30
        ],
//17-----------------------------------------------------------------------
        ["PF_DXT1",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

/* No alpha*/
        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//18-----------------------------------------------------------------------
        ["PF_DXT2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//19-----------------------------------------------------------------------
        ["PF_DXT3",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//20-----------------------------------------------------------------------
        ["PF_DXT4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//21-----------------------------------------------------------------------
        ["PF_DXT5",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//22-----------------------------------------------------------------------
        ["PF_FLOAT16_RGB",
/* Bytes per element */

        6,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 3,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//23-----------------------------------------------------------------------
        ["PF_FLOAT16_RGBA",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.FLOAT | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 4,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 16,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//24-----------------------------------------------------------------------
        ["PF_FLOAT32_RGB",
/* Bytes per element */

        12,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 3,
/* rbits, gbits, bbits, abits */

        32, 32, 32, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//25-----------------------------------------------------------------------
        ["PF_FLOAT32_RGBA",
/* Bytes per element */

        16,
/* Flags */

        EPixelFormatFlags.FLOAT | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 4,
/* rbits, gbits, bbits, abits */

        32, 32, 32, 32,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//26-----------------------------------------------------------------------
        ["PF_X8R8G8B8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
        16, 8, 0, 24
        ],
//27-----------------------------------------------------------------------
        ["PF_X8B8G8R8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000,
        0, 8, 16, 24
        ],
//28-----------------------------------------------------------------------
        ["PF_R8G8B8A8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF,
        24, 16, 8, 0
        ],
//29-----------------------------------------------------------------------
		["PF_FLOAT32_DEPTH",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

/* ?*/
        EPixelComponentTypes.FLOAT32, 1,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//30-----------------------------------------------------------------------
		["PF_SHORT_RGBA",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.SHORT, 4,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 16,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//31-----------------------------------------------------------------------
        ["PF_R3G3B2",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        3, 3, 2, 0,
/* Masks and shifts */

        0xE0, 0x1C, 0x03, 0,
        5, 2, 0, 0
        ],
//32-----------------------------------------------------------------------
        ["PF_FLOAT16_R",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 1,
/* rbits, gbits, bbits, abits */

        16, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//33-----------------------------------------------------------------------
        ["PF_FLOAT32_R",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 1,
/* rbits, gbits, bbits, abits */

        32, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//34-----------------------------------------------------------------------
        ["PF_SHORT_GR",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.SHORT, 2,
/* rbits, gbits, bbits, abits */

        16, 16, 0, 0,
/* Masks and shifts */

        0x0000FFFF, 0xFFFF0000, 0, 0,
		0, 16, 0, 0
        ],
//35-----------------------------------------------------------------------
        ["PF_FLOAT16_GR",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 2,
/* rbits, gbits, bbits, abits */

        16, 16, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//36-----------------------------------------------------------------------
        ["PF_FLOAT32_GR",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 2,
/* rbits, gbits, bbits, abits */

        32, 32, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//37-----------------------------------------------------------------------
		["PF_SHORT_RGB",
/* Bytes per element */

        6,
/* Flags */

        0,
/* Component type and count */

        EPixelComponentTypes.SHORT, 3,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 0,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//38-----------------------------------------------------------------------
		["PF_PVRTC_RGB2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//39-----------------------------------------------------------------------
		["PF_PVRTC_RGBA2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//40-----------------------------------------------------------------------
		["PF_PVRTC_RGB4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//41-----------------------------------------------------------------------
		["PF_PVRTC_RGBA4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//42-----------------------------------------------------------------------
        ["PF_R8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF0000, 0, 0, 0,
        0, 0, 0, 0
        ],
//43-----------------------------------------------------------------------
        ["PF_RG8",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        8, 8, 0, 0,
/* Masks and shifts */

        0xFF0000, 0x00FF00, 0, 0,
        8, 0, 0, 0
        ],
//44-----------------------------------------------------------------------
        ["PF_DEPTH_BYTE",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF, 0, 0, 0, 0, 0, 0, 0
        ],
//45-----------------------------------------------------------------------    
        ["PF_DEPTH_SHORT",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

        EPixelComponentTypes.SHORT, 1,
/* rbits, gbits, bbits, abits */

        16, 0, 0, 0,
/* Masks and shifts */

        0xFFFF, 0, 0, 0, 0, 0, 0, 0
        ],
//46-----------------------------------------------------------------------    
        ["PF_DEPTH_INT",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

        EPixelComponentTypes.INT, 1,
/* rbits, gbits, bbits, abits */

        32, 0, 0, 0,
/* Masks and shifts */

        0xFFFFFFFF, 0, 0, 0, 0, 0, 0, 0
        ],
//47-----------------------------------------------------------------------   
        ["PF_DEPTH24STENCIL8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.DEPTH|EPixelFormatFlags.STENCIL,
/* Component type and count */

        EPixelComponentTypes.INT, 1,
/* rbits, gbits, bbits, abits */

        24, 8, 0, 0,
/* Masks and shifts */

        0x00FFFFFF, 0xFF000000, 0, 0,
        0, 24, 0, 0
        ],
	]);

    var _pColorValue: IColorValue = {r: 0., g: 0., b: 0., a: 1.};

	export module pixelUtil {
        export  /**@inline*/  function getDescriptionFor(eFmt: EPixelFormats): IPixelFormatDescription {
            var ord:  number  = < number >eFmt;
            { logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 736 ); logger.assert(ord>=0 && ord<EPixelFormats.TOTAL,"getDescriptionFor:"+ord); } ;

            return pPixelFormats[ord];
        }

/** Returns the size in bytes of an element of the given pixel format.
         @return
               The size in bytes of an element. See Remarks.
         @remarks
               Passing PF_UNKNOWN will result in returning a size of 0 bytes.
        */

        export  /**@inline*/  function getNumElemBytes(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).elemBytes;
        }

/** Returns the size in bits of an element of the given pixel format.
          @return
               The size in bits of an element. See Remarks.
           @remarks
               Passing PF_UNKNOWN will result in returning a size of 0 bits.
        */

        export  /**@inline*/  function getNumElemBits(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).elemBytes * 8;
        }



/** Returns the size in memory of a region with the given extents and pixel
			format with consecutive memory layout.
			@param width
				The width of the area
			@param height
				The height of the area
			@param depth
				The depth of the area
			@param format
				The format of the area
		  	@return
		  		The size in bytes
			@remarks
				In case that the format is non-compressed, this simply returns
				width*height*depth*PixelUtil::getNumElemBytes(format). In the compressed
				case, this does serious magic.
		*/

		export function getMemorySize(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats):  number  {
			if(isCompressed(eFormat)) {
				switch(eFormat) {
// DXT formats work by dividing the image into 4x4 blocks, then encoding each
// 4x4 block with a certain number of bytes. 
					case EPixelFormats.DXT1:
						return Math.floor((iWidth + 3) / 4) * Math.floor((iHeight + 3) / 4) * 8 * iDepth;
					case EPixelFormats.DXT2:
					case EPixelFormats.DXT3:
					case EPixelFormats.DXT4:
					case EPixelFormats.DXT5:
						return Math.floor((iWidth + 3) / 4) * Math.floor((iHeight + 3) / 4) * 16 * iDepth;

// Size calculations from the PVRTC OpenGL extension spec
// http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc.txt
// Basically, 32 bytes is the minimum texture size.  Smaller textures are padded up to 32 bytes
	                case EPixelFormats.PVRTC_RGB2:
	                case EPixelFormats.PVRTC_RGBA2:
						{ logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 798 ); logger.assert(iDepth == 1); } ;
	                    return (math.max(< number >iWidth, 16) * math.max(< number >iHeight, 8) * 2 + 7) / 8;
	                case EPixelFormats.PVRTC_RGB4:
	                case EPixelFormats.PVRTC_RGBA4:
						{ logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 802 ); logger.assert(iDepth == 1); } ;
	                    return (math.max(< number >iWidth, 8) * math.max(< number >iHeight, 8) * 4 + 7) / 8;
					default:
						{ logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 805 ); logger.error("Invalid compressed pixel format", "PixelUtil::getMemorySize"); } ;
				}
			}
			else {
				return iWidth * iHeight * iDepth * getNumElemBytes(eFormat);
			}
		}

/** Returns the property flags for this pixel format
          @return
               A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED,
               PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE
          @remarks
               This replaces the separate functions for formatHasAlpha, formatIsFloat, ...
        */

        export   /**@inline*/  function getFlags(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).flags;
        }

/** Shortcut method to determine if the format has an alpha component */

        export  /**@inline*/  function hasAlpha(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.HASALPHA) > 0;
        }
/** Shortcut method to determine if the format is floating point */

        export  /**@inline*/  function isFloatingPoint(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.FLOAT) > 0;
        }
/** Shortcut method to determine if the format is compressed */

        export  /**@inline*/  function isCompressed(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.COMPRESSED) > 0;
        }
/** Shortcut method to determine if the format is a depth format. */

        export  /**@inline*/  function isDepth(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.DEPTH) > 0;
        }
/** Shortcut method to determine if the format is in native endian format. */

        export  /**@inline*/  function isNativeEndian(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.NATIVEENDIAN) > 0;
        }
/** Shortcut method to determine if the format is a luminance format. */

        export  /**@inline*/  function isLuminance(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.LUMINANCE) > 0;
        }

/** Return wether a certain image extent is valid for this image format.
			@param width
				The width of the area
			@param height
				The height of the area
			@param depth
				The depth of the area
			@param format
				The format of the area
			@remarks For non-compressed formats, this is always true. For DXT formats,
			only sizes with a width and height multiple of 4 and depth 1 are allowed.
		*/

		export function isValidExtent(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats): bool {
			if(isCompressed(eFormat)) {
				switch(eFormat) {
					case EPixelFormats.DXT1:
					case EPixelFormats.DXT2:
					case EPixelFormats.DXT3:
					case EPixelFormats.DXT4:
					case EPixelFormats.DXT5:
						return ((iWidth&3)==0 && (iHeight&3)==0 && iDepth==1);
					default:
						return true;
				}
			}
			else
			{
				return true;
			}
		}

/** Gives the number of bits (RGBA) for a format. See remarks.          
          @remarks      For non-colour formats (dxt, depth) this returns [0,0,0,0].
        */

        export function getBitDepths(eFormat: EPixelFormats):  number [] {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rbits;
	        rgba[1] = des.gbits;
	        rgba[2] = des.bbits;
	        rgba[3] = des.abits;

	        return rgba;
        }

/** Gives the masks for the R, G, B and A component
		  @note			Only valid for native endian formats
        */

        export function getBitMasks(eFormat: EPixelFormats):  number [] {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rmask;
	        rgba[1] = des.gmask;
	        rgba[2] = des.bmask;
	        rgba[3] = des.amask;

	        return rgba;
        }

/** Gives the bit shifts for R, G, B and A component
		@note			Only valid for native endian formats
		*/

		export function getBitShifts(eFormat: EPixelFormats):  number [] {
			/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rshift;
	        rgba[1] = des.gshift;
	        rgba[2] = des.bshift;
	        rgba[3] = des.ashift;

	        return rgba;
		}

/** Gets the name of an image format
        */

        export  /**@inline*/  function getFormatName(eSrcFormat: EPixelFormats): string {
        	return getDescriptionFor(eSrcFormat).name;
        }

/** Returns wether the format can be packed or unpacked with the packColour()
        and unpackColour() functions. This is generally not true for compressed and
        depth formats as they are special. It can only be true for formats with a
        fixed element size.
          @return 
               true if yes, otherwise false
        */

        export function isAccessible(eSrcFormat: EPixelFormats): bool {
        	if (eSrcFormat == EPixelFormats.UNKNOWN)
	            return false;
	        var flags:  number  = getFlags(eSrcFormat);
	        return !((flags & EPixelFormatFlags.COMPRESSED) || (flags & EPixelFormatFlags.DEPTH));
        }

/** Returns the component type for a certain pixel format. Returns PCT_BYTE
            in case there is no clear component type like with compressed formats.
            This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32.
        */

        export  /**@inline*/  function getComponentType(eFmt: EPixelFormats): EPixelComponentTypes {
        	return getDescriptionFor(eFmt).componentType;
        }

/** Returns the component count for a certain pixel format. Returns 3(no alpha) or 
            4 (has alpha) in case there is no clear component type like with compressed formats.
         */

        export  /**@inline*/  function getComponentCount(eFmt: EPixelFormats):  number  {
        	return getDescriptionFor(eFmt).componentCount;
        }

        export  /**@inline*/  function getComponentTypeBits(eFormat: EPixelFormats):  number  {
            var eType: EPixelComponentTypes = getComponentType(eFormat);

            switch(eType) {
/*Byte per component (8 bit fixed 0.0..1.0)*/
                case EPixelComponentTypes.BYTE:      return 8;
/*Short per component (16 bit fixed 0.0..1.0))*/
                case EPixelComponentTypes.SHORT:     return 16;
/*16 bit float per component*/
                case EPixelComponentTypes.FLOAT16:   return 16;
/*32 bit float per component*/
                case EPixelComponentTypes.FLOAT32:   return 32;
            }

            return 0;
        }

/** Gets the format from given name.
            @param  name            The string of format name
            @param  accessibleOnly  If true, non-accessible format will treat as invalid format,
                                    otherwise, all supported format are valid.
            @param  caseSensitive   Should be set true if string match should use case sensitivity.
            @return                The format match the format name, or PF_UNKNOWN if is invalid name.
        */

        export function getFormatFromName(sName: string, isAccessibleOnly: bool = false, isCaseSensitive: bool = false): EPixelFormats {
        	var tmp: string = sName;

	        if (!isCaseSensitive) {
// We are stored upper-case format names.
	            tmp = tmp.toUpperCase();
	        }

	        for (var i:  number  = 0; i < EPixelFormats.TOTAL; ++i) {
	            var ePf: EPixelFormats = <EPixelFormats>i;
	            if (!isAccessibleOnly || isAccessible(ePf)) {
	                if (tmp == getFormatName(ePf))
	                    return ePf;
	            }
	        }

	        return EPixelFormats.UNKNOWN;
        }

/** Gets the BNF expression of the pixel-formats.
            @note                   The string returned by this function is intended to be used as a BNF expression
                                    to work with Compiler2Pass.
            @param  accessibleOnly  If true, only accessible pixel format will take into account, otherwise all
                                    pixel formats list in EPixelFormats enumeration will being returned.
            @return                A string contains the BNF expression.
        */

        export function getBNFExpressionOfPixelFormats(isAccessibleOnly: bool = false): string {
// Collect format names sorted by length, it's required by BNF compiler
// that similar tokens need longer ones comes first.

	        var formatNames: Pair[] = new Pair[];
	        for (var i:  number  = 0; i < EPixelFormats.TOTAL; ++i) {
	            var ePf: EPixelFormats = <EPixelFormats>(i);
	            if (!isAccessibleOnly || isAccessible(ePf))
	            {
	                var formatName: string = getFormatName(ePf);
	                formatNames.push({first: formatName.length, second: formatName});
	            }
	        }

// Populate the BNF expression in reverse order
	        var result: string = "";
// Note: Stupid M$ VC7.1 can't dealing operator!= with FormatNameMap::const_reverse_iterator.
	        for (var j in formatNames) {
	            if (!isEmpty(result))
	                result += " | ";
	            result += "'" + formatNames[j] + "'";
	        }

	        return result;
        }

/** Returns the similar format but acoording with given bit depths.
            @param fmt      The original foamt.
            @param integerBits Preferred bit depth (pixel bits) for integer pixel format.
                            Available values: 0, 16 and 32, where 0 (the default) means as it is.
            @param floatBits Preferred bit depth (channel bits) for float pixel format.
                            Available values: 0, 16 and 32, where 0 (the default) means as it is.
            @return        The format that similar original format with bit depth according
                            with preferred bit depth, or original format if no conversion occurring.
        */

        export function getFormatForBitDepths(eFmt: EPixelFormats, iIntegerBits:  number , iFloatBits:  number ): EPixelFormats {
        	switch (iIntegerBits)
            {
	        case 16:
	            switch (eFmt) {
	            case EPixelFormats.R8G8B8:
	            case EPixelFormats.X8R8G8B8:
	                return EPixelFormats.R5G6B5;

	            case EPixelFormats.B8G8R8:
	            case EPixelFormats.X8B8G8R8:
	                return EPixelFormats.B5G6R5;

	            case EPixelFormats.A8R8G8B8:
	            case EPixelFormats.R8G8B8A8:
	            case EPixelFormats.A8B8G8R8:
	            case EPixelFormats.B8G8R8A8:
	                return EPixelFormats.A4R4G4B4;

	            case EPixelFormats.A2R10G10B10:
	            case EPixelFormats.A2B10G10R10:
	                return EPixelFormats.A1R5G5B5;

	            default:
// use original image format
	                break;
	            }
	            break;

	        case 32:
	            switch (eFmt) {
	            case EPixelFormats.R5G6B5:
	                return EPixelFormats.X8R8G8B8;

	            case EPixelFormats.B5G6R5:
	                return EPixelFormats.X8B8G8R8;

	            case EPixelFormats.A4R4G4B4:
	                return EPixelFormats.A8R8G8B8;

	            case EPixelFormats.A1R5G5B5:
	                return EPixelFormats.A2R10G10B10;

	            default:
// use original image format
	                break;
	            }
	            break;

	        default:
// use original image format
	            break;
	        }

	        switch (iFloatBits) {
	        case 16:
	            switch (eFmt) {
	            case EPixelFormats.FLOAT32_R:
	                return EPixelFormats.FLOAT16_R;

	            case EPixelFormats.FLOAT32_RGB:
	                return EPixelFormats.FLOAT16_RGB;

	            case EPixelFormats.FLOAT32_RGBA:
	                return EPixelFormats.FLOAT16_RGBA;

	            default:
// use original image format
	                break;
	            }
	            break;

	        case 32:
	            switch (eFmt) {
	            case EPixelFormats.FLOAT16_R:
	                return EPixelFormats.FLOAT32_R;

	            case EPixelFormats.FLOAT16_RGB:
	                return EPixelFormats.FLOAT32_RGB;

	            case EPixelFormats.FLOAT16_RGBA:
	                return EPixelFormats.FLOAT32_RGBA;

	            default:
// use original image format
	                break;
	            }
	            break;

	        default:
// use original image format
	            break;
	        }

	        return eFmt;
        }

/** Pack a colour value to memory
        	@param colour	The colour
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export  /**@inline*/  function packColour(cColour: IColor, ePf: EPixelFormats,  pDest: Uint8Array): void {
        	packColourFloat(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
        }
/** Pack a colour value to memory
        	@param r,g,b,a	The four colour components, range 0x00 to 0xFF
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export function packColourUint(r:  number , g:  number , b:  number , a:  number , ePf: EPixelFormats,  pDest: Uint8Array): void {
// if (arguments.length < 4) {
// 	var cColour: IColor = arguments[0];
// 	packColour(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
// 	return;
// }

        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats packing
	            var value:  number  =
	            	((bf.fixedToFixed(r, 8, des.rbits)<<des.rshift) & des.rmask) |
	                ((bf.fixedToFixed(g, 8, des.gbits)<<des.gshift) & des.gmask) |
	                ((bf.fixedToFixed(b, 8, des.bbits)<<des.bshift) & des.bmask) |
	                ((bf.fixedToFixed(a, 8, des.abits)<<des.ashift) & des.amask);
// And write to memory
	            bf.intWrite(pDest, des.elemBytes, value);
	        } else {
// Convert to float
	            packColourFloat(< number >r/255.0,< number >g/255.0,< number >b/255.0,< number >a/255.0, ePf, pDest);
	        }
        }
/** Pack a colour value to memory
        	@param r,g,b,a	The four colour components, range 0.0f to 1.0f
        					(an exception to this case exists for floating point pixel
        					formats, which don't clamp to 0.0f..1.0f)
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export function packColourFloat(r:  number , g:  number , b:  number , a:  number , ePf: EPixelFormats,  pDest: Uint8Array): void {
// Catch-it-all here
	        /**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Do the packing
//std::cerr << dest << " " << r << " " << g <<  " " << b << " " << a << std::endl;
	            /**@const*/var  value:  number  = ((bf.floatToFixed(r, des.rbits)<<des.rshift) & des.rmask) |
	                ((bf.floatToFixed(g, des.gbits)<<des.gshift) & des.gmask) |
	                ((bf.floatToFixed(b, des.bbits)<<des.bshift) & des.bmask) |
	                ((bf.floatToFixed(a, des.abits)<<des.ashift) & des.amask);
// And write to memory
	            bf.intWrite(pDest, des.elemBytes, value);
	        } else {
	            switch(ePf) {
	            case EPixelFormats.FLOAT32_R:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                break;
				case EPixelFormats.FLOAT32_GR:
					(new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = g;
					(new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = r;
					break;
	            case EPixelFormats.FLOAT32_RGB:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = g;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 3)) [2] = b;
	                break;
	            case EPixelFormats.FLOAT32_RGBA:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = g;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 3)) [2] = b;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 4)) [3] = a;
	                break;
	            case EPixelFormats.FLOAT16_R:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                break;
				case EPixelFormats.FLOAT16_GR:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(g);
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(r);
					break;
	            case EPixelFormats.FLOAT16_RGB:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(g);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToHalf(b);
	                break;
	            case EPixelFormats.FLOAT16_RGBA:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(g);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToHalf(b);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 4)) [3] = bf.floatToHalf(a);
	                break;
	            case EPixelFormats.SHORT_RGB:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToFixed(r, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToFixed(g, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToFixed(b, 16);
	                break;
				case EPixelFormats.SHORT_RGBA:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToFixed(r, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToFixed(g, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToFixed(b, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 4)) [3] = bf.floatToFixed(a, 16);
					break;
				case EPixelFormats.BYTE_LA:
					pDest[0] = bf.floatToFixed(r, 8);
	                pDest[1] = bf.floatToFixed(a, 8);
					break;
	            default:
// Not yet supported
	                { logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 1249 ); logger.error("pack to "+ getFormatName(ePf)+" not implemented", "PixelUtil::packColour"); }
                                             ;
	                break;
	            }
	        }
        }



/** Unpack a colour value from memory
        	@param colour	The colour is returned here
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        */

        export function unpackColour(cColour: IColor, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	unpackColourFloat(cColour, ePf, pSrc);
        }
/** Unpack a colour value from memory
        	@param r,g,b,a	The colour is returned here (as byte)
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        	@remarks 	This function returns the colour components in 8 bit precision,
        		this will lose precision when coming from PF_A2R10G10B10 or floating
        		point formats.  
        */

        export function unpackColourUint(rgba: IColorIValue, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
        	var r:  number  = 0, g:  number  = 0, b:  number  = 0, a:  number  = 0;

	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats unpacking
	            /**@const*/var  value:  number  = bf.intRead(pSrc, des.elemBytes);
	            if(des.flags & EPixelFormatFlags.LUMINANCE) {
// Luminance format -- only rbits used
	                r = g = b = < number >bf.fixedToFixed(
	                    (value & des.rmask) >> des.rshift, des.rbits, 8);
	            }
	            else {
	                r = < number >bf.fixedToFixed((value & des.rmask)>>des.rshift, des.rbits, 8);
	                g = < number >bf.fixedToFixed((value & des.gmask)>>des.gshift, des.gbits, 8);
	                b = < number >bf.fixedToFixed((value & des.bmask)>>des.bshift, des.bbits, 8);
	            }
	            if(des.flags & EPixelFormatFlags.HASALPHA) {
	                a = < number >bf.fixedToFixed((value & des.amask)>>des.ashift, des.abits, 8);
	            }
	            else {
/* No alpha, default a component to full*/
	                a = 255;
	            }

	        } else {
// Do the operation with the more generic floating point
	            var pRGBA: IColorValue = _pColorValue;
	            unpackColourFloat(pRGBA, ePf, pSrc);


	            r = bf.floatToFixed(pRGBA.r, 8);
	            g = bf.floatToFixed(pRGBA.g, 8);
	            b = bf.floatToFixed(pRGBA.b, 8);
	            a = bf.floatToFixed(pRGBA.a, 8);
	        }

	        rgba[0] = r;
	        rgba[1] = g;
	        rgba[2] = b;
	        rgba[3] = a;
        }



/** Unpack a colour value from memory
        	@param r,g,b,a	The colour is returned here (as float)
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        */

        export function unpackColourFloat(rgba: IColorValue, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
        	var r:  number  = 0., g:  number  = 0., b:  number  = 0., a:  number  = 0.;

	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats unpacking
	            /**@const*/var  value:  number  = bf.intRead(pSrc, des.elemBytes);


	            if(des.flags & EPixelFormatFlags.LUMINANCE)
                {
// Luminance format -- only rbits used
	                r = g = b = bf.fixedToFloat(
	                    (value & des.rmask)>>>des.rshift, des.rbits);
	            }
	            else {
	                r = bf.fixedToFloat((value & des.rmask) >>> des.rshift, des.rbits);
	                g = bf.fixedToFloat((value & des.gmask) >>> des.gshift, des.gbits);
	                b = bf.fixedToFloat((value & des.bmask) >>> des.bshift, des.bbits);

	            }

	            if (des.flags & EPixelFormatFlags.HASALPHA)
                {

	                a = bf.fixedToFloat((value & des.amask) >>> des.ashift, des.abits);
	            }
	            else {

/* No alpha, default a component to full*/
	                a = 1.0;
	            }


	        }
            else {
	            switch(ePf) {
                case EPixelFormats.FLOAT32_DEPTH:
	            case EPixelFormats.FLOAT32_R:
	                r = g = b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                a = 1.0;
	                break;
				case EPixelFormats.FLOAT32_GR:
					g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
					r = b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
					a = 1.0;
					break;
	            case EPixelFormats.FLOAT32_RGB:
	                r =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
	                b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3)) [2];
	                a = 1.0;
	                break;
	            case EPixelFormats.FLOAT32_RGBA:
	                r =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
	                b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3)) [2];
	                a =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 4)) [3];
	                break;
	            case EPixelFormats.FLOAT16_R:
	                r = g = b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                a = 1.0;
	                break;
				case EPixelFormats.FLOAT16_GR:
					g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
					r = b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1]);
					a = 1.0;
					break;
	            case EPixelFormats.FLOAT16_RGB:
	                r = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[1]);
	                b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[2]);
	                a = 1.0;
	                break;
	            case EPixelFormats.FLOAT16_RGBA:
	                r = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1]);
	                b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2]);
	                a = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4)) )[3]);
	                break;
				case EPixelFormats.SHORT_RGB:
					r = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0], 16);
	                g = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1], 16);
					b = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2], 16);
					a = 1.0;
					break;
				case EPixelFormats.SHORT_RGBA:
					r = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0], 16);
	                g = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1], 16);
					b = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2], 16);
					a = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4)) )[3], 16);
					break;
				case EPixelFormats.BYTE_LA:
					r = g = b = bf.fixedToFloat((pSrc)[0], 8);
					a = bf.fixedToFloat((pSrc)[1], 8);
					break;
	            default:
// Not yet supported
	                { logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 1421 ); logger.error("unpack from "+ getFormatName(ePf) +" not implemented", "PixelUtil::unpackColour"); }
                                               ;
	                break;
	            }
	        }

	        rgba.r = r;
	        rgba.g = g;
	        rgba.b = b;
	        rgba.a = a;

        }

/** Convert consecutive pixels from one format to another. No dithering or filtering is being done. 
         	Converting from RGB to luminance takes the R channel.  In case the source and destination format match,
         	just a copy is done.
         	@param	src			Pointer to source region
         	@param	srcFormat	Pixel format of source region
         	@param   dst			Pointer to destination region
         	@param	dstFormat	Pixel format of destination region
         */

        export function bulkPixelConversion(pSrc: Uint8Array, eSrcFormat: EPixelFormats, pDest: Uint8Array, eDstFormat: EPixelFormats, iCount:  number ): void;


/** Convert pixels from one format to another. No dithering or filtering is being done. Converting
          	from RGB to luminance takes the R channel. 
		 	@param	src			PixelBox containing the source pixels, pitches and format
		 	@param	dst			PixelBox containing the destination pixels, pitches and format
		 	@remarks The source and destination boxes must have the same
         	dimensions. In case the source and destination format match, a plain copy is done.
        */


        export function bulkPixelConversion(pSrc: IPixelBox, pDest: IPixelBox): void;

        export function bulkPixelConversion(pSrc: any, eSrcFormat: any, pDest?: any, eDstFormat?: any, iCount?:  number ): void {
        	var src: IPixelBox = null,
        		dst: IPixelBox = null;

        	if (arguments.length > 2) {
	        	src = new PixelBox(iCount, 1, 1, <EPixelFormats>eSrcFormat, <Uint8Array>pSrc);
				dst = new PixelBox(iCount, 1, 1, <EPixelFormats>eDstFormat, <Uint8Array>pDest);
			}
            else
            {
                src = arguments[0];
                dst = arguments[1];
            }

            if(src.width !== dst.width || src.height !== dst.height || src.depth !== dst.depth){
                { logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 1469 ); logger.criticalError("Size dest and src pictures is different"); } ;
                return;
            }

// Check for compressed formats, we don't support decompression, compression or recoding
			if(isCompressed(src.format) || isCompressed(dst.format)) {
				if(src.format == dst.format) {
//_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
					dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
					return;
				}
				else {
					{ logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 1482 ); logger.error("This method can not be used to compress or decompress images", "PixelUtil::bulkPixelConversion"); }
                                       ;
				}
			}

// The easy case
	        if(src.format == dst.format) {
// Everything consecutive?
	            if(src.isConsecutive() && dst.isConsecutive())
	            {
//_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
					dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
	                return;
	            }

	            var srcPixelSize:  number  = getNumElemBytes(src.format);
	            var dstPixelSize:  number  = getNumElemBytes(dst.format);

	            var srcptr: Uint8Array = src.data.subarray(
	                (src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
	            var dstptr: Uint8Array = dst.data.subarray(
					(dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);

// Calculate pitches+skips in bytes
	            var srcRowPitchBytes:  number  = src.rowPitch * srcPixelSize;
//var size_t srcRowSkipBytes = src.getRowSkip()*srcPixelSize;
	            var srcSliceSkipBytes:  number  = src.getSliceSkip() * srcPixelSize;

	            var dstRowPitchBytes:  number  = dst.rowPitch * dstPixelSize;
//var size_t dstRowSkipBytes = dst.getRowSkip()*dstPixelSize;
	            var dstSliceSkipBytes:  number  = dst.getSliceSkip() * dstPixelSize;
// Otherwise, copy per row
	            /**@const*/var  rowSize:  number  = src.width * srcPixelSize;

	            for(var z:  number  = src.front; z < src.back; z++) {
	                for(var y:  number  = src.top; y < src.bottom; y++) {
//_memcpy(dstptr.buffer, srcptr.buffer, rowSize);
                        dstptr.set(srcptr.subarray(0, rowSize));

	                    srcptr = srcptr.subarray(srcRowPitchBytes);
	                    dstptr = dstptr.subarray(dstRowPitchBytes);
	                }

	                srcptr = srcptr.subarray(srcSliceSkipBytes);
	                dstptr = dstptr.subarray(dstSliceSkipBytes);
	            }

	            return;
	        }

// Converting to PF_X8R8G8B8 is exactly the same as converting to
// PF_A8R8G8B8. (same with PF_X8B8G8R8 and PF_A8B8G8R8)
			if(dst.format == EPixelFormats.X8R8G8B8 || dst.format == EPixelFormats.X8B8G8R8)
            {
// Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
// optimized conversions
				var tempdst: IPixelBox = dst;
				tempdst.format = (dst.format == EPixelFormats.X8R8G8B8) ? EPixelFormats.A8R8G8B8  :EPixelFormats.A8B8G8R8;
				bulkPixelConversion(src, tempdst);
				return;
			}


// Converting from EPixelFormats.X8R8G8B8 is exactly the same as converting from
// EPixelFormats.A8R8G8B8, given that the destination format does not have alpha.
			if((src.format == EPixelFormats.X8R8G8B8||src.format == EPixelFormats.X8B8G8R8) && !hasAlpha(dst.format)) {
// Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
// optimized conversions
				var tempsrc: IPixelBox = src;
				tempsrc.format = src.format == EPixelFormats.X8R8G8B8 ? EPixelFormats.A8R8G8B8 : EPixelFormats.A8B8G8R8;
				bulkPixelConversion(tempsrc, dst);
				return;
			}

	        var srcPixelSize:  number  = getNumElemBytes(src.format);
	        var dstPixelSize:  number  = getNumElemBytes(dst.format);

	        var srcptr: Uint8Array = src.data.subarray(
	            (src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
	        var dstptr: Uint8Array = dst.data.subarray(
	            (dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);

// Old way, not taking into account box dimensions
//uint8 *srcptr = static_cast<uint8*>(src.data), *dstptr = static_cast<uint8*>(dst.data);

// Calculate pitches+skips in bytes
	        var srcRowSkipBytes:  number  = src.getRowSkip() * srcPixelSize;
	        var srcSliceSkipBytes:  number  = src.getSliceSkip() * srcPixelSize;
	        var dstRowSkipBytes:  number  = dst.getRowSkip() * dstPixelSize;
	        var dstSliceSkipBytes:  number  = dst.getSliceSkip() * dstPixelSize;

// The brute force fallback
// var r: float = 0, g: float = 0, b: float = 0, a: float = 1;
	        var rgba = _pColorValue;
	        for(var z:  number  = src.front; z < src.back; z ++) {
	            for(var y:  number  = src.top; y < src.bottom; y ++) {
	                for(var x:  number  = src.left; x < src.right; x ++) {
	                    unpackColourFloat(rgba, src.format, srcptr);
	                    packColourFloat(rgba.r, rgba.g, rgba.b, rgba.a, dst.format, dstptr);
	                    srcptr = srcptr.subarray(srcPixelSize);
	                    dstptr = dstptr.subarray(dstPixelSize);
	                }
	                srcptr = srcptr.subarray(srcRowSkipBytes);
	                dstptr = dstptr.subarray(dstRowSkipBytes);
	            }
	            srcptr = srcptr.subarray(srcSliceSkipBytes);
	            dstptr = dstptr.subarray(dstSliceSkipBytes);
	        }
        }

        export function calculateSizeForImage(nMipLevels:  number , nFaces:  number ,
                                              iWidth:  number , iHeight:  number , iDepth:  number ,
                                              eFormat: EPixelFormats):  number  {
            var iSize:  number  = 0;
            var mip:  number  = 0;

            for(mip = 0; mip < nMipLevels; ++mip){
                iSize += getMemorySize(iWidth, iHeight, iDepth, eFormat) * nFaces;
                if(iWidth !== 1) iWidth /= 2;
                if(iHeight !== 1) iHeight /= 2;
                if(iDepth !== 1) iDepth /= 2;
            }

            return iSize;
        }
	}
}








module akra.webgl {
	export var maxTextureSize:  number  = 0;
	export var maxCubeMapTextureSize:  number  = 0;
	export var maxViewPortSize:  number  = 0;

	export var maxTextureImageUnits:  number  = 0;
	export var maxVertexAttributes:  number  = 0;
	export var maxVertexTextureImageUnits:  number  = 0;
	export var maxCombinedTextureImageUnits:  number  = 0;

	export var maxColorAttachments:  number  = 1;

	export var stencilBits:  number  = 0;
	export var colorBits:  number [] = [0, 0, 0];
	export var alphaBits:  number  = 0;
	export var multisampleType:  number  = 0.;

	export var shaderVersion:  number  = 0;
	export var hasNonPowerOf2Textures: bool = false;

    export var isANGLE: bool = false;

    var isSupported: bool = false;
	export var pSupportedExtensionList: string[] = null;
// var pLoadedExtensionList: Object = null;

    function makeDebugContext(pWebGLContext: WebGLRenderingContext): WebGLRenderingContext {
        if (isDef((<any>window).WebGLDebugUtils)) {
            pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLContext,
                (err:  number , funcName: string, args: IArguments): void => {
                    { logger.setSourceLocation( "webgl/WebGL.ts" , 54 ); logger.log(("\n" + (<any>new Error).stack.split("\n").slice(1).join("\n")) ); } ;
                    throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                },
                (funcName: string, args: IArguments): void => {
                   { logger.setSourceLocation( "webgl/WebGL.ts" , 58 ); logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")"); } ;
                });
        }

        return pWebGLContext;
    }

    export function loadExtension(pWebGLContext: WebGLRenderingContext, sExtName: string): bool {
        var pWebGLExtentionList: Object = (<any>pWebGLContext).extentionList = (<any>pWebGLContext).extentionList || {};
        var pWebGLExtension: Object;

        if (!hasExtension(sExtName)) {
            { logger.setSourceLocation( "webgl/WebGL.ts" , 70 ); logger.warning("Extension " + sExtName + " unsupported for this platform."); } ;
            return false;
        }
        if (pWebGLExtension = pWebGLContext.getExtension(sExtName)) {

            if (isDefAndNotNull(pWebGLExtentionList[sExtName])) {
// debug_print("Extension " + sExtName + " already loaded for this context.");
                return true;
            }

            pWebGLExtentionList[sExtName] = pWebGLExtension;

            { logger.setSourceLocation( "webgl/WebGL.ts" , 82 ); logger.log("loaded WebGL extension: ", sExtName); } ;

            for (var j in pWebGLExtension) {
                if (isFunction(pWebGLExtension[j])) {
//debug_print("created func WebGLRenderingContext::" + j + "(...)");
                    pWebGLContext[j] = function () {
                        pWebGLContext[j] = new Function(
                            "var t = this.extentionList[" + sExtName + "];" +
                            "t." + j + ".apply(t, arguments);");
                    }

                }
                else {
//debug_print("created const WebGLRenderingContext::" + j + " = " + pWebGLExtension[j]);
                    pWebGLContext[j] = pWebGLExtension[j];
                }
            }

            return true;
        }

        { logger.setSourceLocation( "webgl/WebGL.ts" , 103 ); logger.warning("cannot load extension: ", sExtName); } ;
        return false;
    }


    function checkIsAngle(pWebGLContext: WebGLRenderingContext): bool {
        var pProgram: WebGLProgram = pWebGLContext.createProgram();

        var sVertex: string = "            attribute vec3 pos;            struct S {              vec3 b[1];            };            uniform S s[1];            void main(void) {              float t = s[0].b[0].x;              gl_Position = vec4(pos, 1. + t);            }";

        var sFragment: string = "void main(void){}";

        var pVertexShader: WebGLShader = pWebGLContext.createShader( 0x8B31 );
        var pFragmentShader: WebGLShader = pWebGLContext.createShader( 0x8B30 );

        pWebGLContext.shaderSource(pVertexShader, sVertex);
        pWebGLContext.compileShader(pVertexShader);
        pWebGLContext.shaderSource(pFragmentShader, sFragment);
        pWebGLContext.compileShader(pFragmentShader);

        pWebGLContext.attachShader(pProgram, pVertexShader);
        pWebGLContext.attachShader(pProgram, pFragmentShader);

        pWebGLContext.linkProgram(pProgram);

        if (!pWebGLContext.getProgramParameter(pProgram,  0x8B82 )) {
            { logger.setSourceLocation( "webgl/WebGL.ts" , 138 ); logger.error("cannot compile GLSL shader for ANGLE renderer"); } ;

            { logger.setSourceLocation( "webgl/WebGL.ts" , 140 ); logger.log(pWebGLContext.getShaderInfoLog(pVertexShader)); } ;
            { logger.setSourceLocation( "webgl/WebGL.ts" , 141 ); logger.log(pWebGLContext.getShaderSource(pVertexShader) || sVertex); } ;

            { logger.setSourceLocation( "webgl/WebGL.ts" , 143 ); logger.log(pWebGLContext.getShaderInfoLog(pFragmentShader)); } ;
            { logger.setSourceLocation( "webgl/WebGL.ts" , 144 ); logger.log(pWebGLContext.getShaderSource(pFragmentShader) || sFragment); } ;

            return false;
        }

        { logger.setSourceLocation( "webgl/WebGL.ts" , 150 ); logger.assert(pWebGLContext.getProgramParameter(pProgram, 0x8B86 ) > 0, "no uniforms founded in angle test shader!"); }
                                                        ;

        return pWebGLContext.getActiveUniform(pProgram, 0).name != "s[0].b[0]";
    }

    function setupContext(pWebGLContext: WebGLRenderingContext): WebGLRenderingContext {
//test context not created yet
        if (isNull(pSupportedExtensionList)) {
            return pWebGLContext;
        }

        for (var i:  number  = 0; i < pSupportedExtensionList.length; ++ i) {
            if (!loadExtension(pWebGLContext, pSupportedExtensionList[i])) {
                pSupportedExtensionList.splice(i, 1);
            }
        }

        return pWebGLContext;
    }

    export var isEnabled = (): bool => isSupported;

    export function createContext(
            pCanvas: HTMLCanvasElement = <HTMLCanvasElement>document.createElement("canvas"),
            pOptions?: WebGLContextAttributes): WebGLRenderingContext {

    	var pWebGLContext: WebGLRenderingContext = null;

		try {
			pWebGLContext = pCanvas.getContext("webgl", pOptions) ||
				pCanvas.getContext("experimental-webgl", pOptions);
    	}
		catch (e) {

            throw e;

        }

		if (isDefAndNotNull(pWebGLContext)) {



            return setupContext(pWebGLContext);

		}

        { logger.setSourceLocation( "webgl/WebGL.ts" , 196 ); logger.warning("cannot get 3d device"); } ;

		return null;
    }

	(function (pWebGLContext: WebGLRenderingContext): void {
		if (!pWebGLContext) {
			return;
		}



		maxTextureSize 					= pWebGLContext.getParameter( 0x0D33 );
		maxCubeMapTextureSize 			= pWebGLContext.getParameter( 0x851C );
		maxViewPortSize 				= pWebGLContext.getParameter( 0x0D3A );

		maxTextureImageUnits 			= pWebGLContext.getParameter( 0x8872 );
		maxVertexAttributes 			= pWebGLContext.getParameter( 0x8869 );
		maxVertexTextureImageUnits 		= pWebGLContext.getParameter( 0x8B4C );
		maxCombinedTextureImageUnits 	= pWebGLContext.getParameter( 0x8B4D );

		stencilBits 					= pWebGLContext.getParameter( 0x0D57 );
		colorBits 						= [
									        pWebGLContext.getParameter( 0x0D52 ),
									        pWebGLContext.getParameter( 0x0D53 ),
									        pWebGLContext.getParameter( 0x0D54 )
	   									];

	    alphaBits 						= pWebGLContext.getParameter( 0x0D55 );
	    multisampleType 				= pWebGLContext.getParameter( 0x80AA );

	    pSupportedExtensionList 		= pWebGLContext.getSupportedExtensions();


//pSupportedExtensionList.push(WEBGL_DEBUG_SHADERS, WEBGL_DEBUG_RENDERER_INFO);

        isSupported = true;

        isANGLE = checkIsAngle(pWebGLContext);


        { logger.setSourceLocation( "webgl/WebGL.ts" , 237 ); logger.log("WebGL running under " + (isANGLE? "ANGLE/DirectX": "Native GL")); } ;


	})(createContext());

	export function hasExtension(sExtName: string): bool {
        for (var i:  number  = 0; i < pSupportedExtensionList.length; ++ i) {
            if (pSupportedExtensionList[i].search(sExtName) != -1) {
                return true;
            }
        }

        return false;
	}

	export function getWebGLUsage(iFlags:  number ):  number  {
		if ( (((iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ) {
	        return  0x88E8 ;
	    }
	    else if ( (((iFlags) & (EHardwareBufferFlags.STREAM)) != 0) ) {
	        return  0x88E0 ;
	    }

	    return  0x88E4 ;
	}


	export function getWebGLFormat(eFormat: EPixelFormats):  number  {

        switch(eFormat)
        {
			case EPixelFormats.L8:
            case EPixelFormats.L16:
                return  0x1909 ;

            case EPixelFormats.A8:
                return  0x1906 ;

            case EPixelFormats.A4L4:
            case EPixelFormats.BYTE_LA:
                return  0x190A ;

            case EPixelFormats.R5G6B5:
                return 0;
            case EPixelFormats.B5G6R5:
                return  0x1907 ;
            case EPixelFormats.R3G3B2:
                return 0;
            case EPixelFormats.A4R4G4B4:
            case EPixelFormats.A1R5G5B5:
                return  0x1908 ;

            case EPixelFormats.R8G8B8:
            case EPixelFormats.B8G8R8:
                return  0x1907 ;

            case EPixelFormats.A8R8G8B8:
            case EPixelFormats.A8B8G8R8:
                return  0x1908 ;

            case EPixelFormats.B8G8R8A8:
            case EPixelFormats.R8G8B8A8:
            case EPixelFormats.X8R8G8B8:
            case EPixelFormats.X8B8G8R8:
               return  0x1908 ;

            case EPixelFormats.A2R10G10B10:
                return 0;
            case EPixelFormats.A2B10G10R10:
                return  0x1908 ;

            case EPixelFormats.DXT1:
                return  0x83F1 ;
            case EPixelFormats.DXT2:
                return 0;
            case EPixelFormats.DXT3:
                return  0x83F2 ;
            case EPixelFormats.DXT4:
                return 0;
            case EPixelFormats.DXT5:
                return  0x83F3 ;
            case EPixelFormats.FLOAT16_R:
                return 0;
            case EPixelFormats.FLOAT16_RGB:
                return  0x1907 ;
            case EPixelFormats.FLOAT16_RGBA:
                 return  0x1908 ;
            case EPixelFormats.FLOAT32_R:
                return 0;
            case EPixelFormats.FLOAT32_RGB:
                return  0x1907 ;
            case EPixelFormats.FLOAT32_RGBA:
                return  0x1908 ;
            case EPixelFormats.FLOAT16_GR:
            case EPixelFormats.FLOAT32_GR:
                return 0;

            case EPixelFormats.FLOAT32_DEPTH:
            case EPixelFormats.DEPTH32:
            case EPixelFormats.DEPTH16:
            case EPixelFormats.DEPTH8:
                return  0x1902 ;

            case EPixelFormats.DEPTH24STENCIL8:
                return  0x84F9 ;

            case EPixelFormats.SHORT_RGBA:
                return  0x1908 ;
            case EPixelFormats.SHORT_GR:
                return 0;
            case EPixelFormats.SHORT_RGB:
                return  0x1907 ;

            case EPixelFormats.PVRTC_RGB2:
                return  0x8C01
            case EPixelFormats.PVRTC_RGBA2:
                return  0x8C03
            case EPixelFormats.PVRTC_RGB4:
                return  0x8C00
            case EPixelFormats.PVRTC_RGBA4:
                return  0x8C02 ;

            case EPixelFormats.R8:
            case EPixelFormats.RG8:
                return 0;

            default:
                { logger.setSourceLocation( "webgl/WebGL.ts" , 364 ); logger.warning("getWebGLFormat unknown format",eFormat); } ;
                return 0;
        }

	}

    export function isWebGLFormatSupport(eFormat: EPixelFormats):bool
    {
        switch(eFormat)
        {
            case EPixelFormats.DXT1:
            case EPixelFormats.DXT3:
            case EPixelFormats.DXT5:
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" );
            case EPixelFormats.PVRTC_RGB2:
            case EPixelFormats.PVRTC_RGBA2:
            case EPixelFormats.PVRTC_RGB4:
            case EPixelFormats.PVRTC_RGBA4:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" );
            case EPixelFormats.DEPTH32:
            case EPixelFormats.DEPTH16:
            case EPixelFormats.DEPTH24STENCIL8:
                return webgl.hasExtension( "WEBGL_depth_texture" );
            case EPixelFormats.DEPTH32:
            case EPixelFormats.DEPTH16:
            case EPixelFormats.DEPTH24STENCIL8:
                return webgl.hasExtension( "WEBGL_depth_texture" );
            case EPixelFormats.FLOAT16_RGB:
            case EPixelFormats.FLOAT16_RGBA:
                 return webgl.hasExtension( "OES_texture_half_float" );
            case EPixelFormats.FLOAT32_RGB:
            case EPixelFormats.FLOAT32_RGBA:
                 return webgl.hasExtension( "OES_texture_float" );

        }

        if(getWebGLFormat(eFormat) && getWebGLDataType(eFormat))
        {
// switch(eFormat)
// {
//     case EPixelFormats.FLOAT32_DEPTH:
//     case EPixelFormats.L16:
//         return false;
// }
            return true;
        }

        return false;
    }


	export function getWebGLDataType(eFormat: EPixelFormats):  number  {
		switch(eFormat)
        {
            case EPixelFormats.L8:
                return  0x1401 ;
            case EPixelFormats.L16:
//return GL_UNSIGNED_SHORT;
                return  0x1401 ;

            case EPixelFormats.A8:
                return  0x1401 ;

            case EPixelFormats.A4L4:
                return 0;
            case EPixelFormats.BYTE_LA:
                return  0x1401 ;

            case EPixelFormats.R5G6B5:
            case EPixelFormats.B5G6R5:
                return  0x8363 ;
            case EPixelFormats.R3G3B2:
                return 0;
            case EPixelFormats.A4R4G4B4:
                return  0x8033 ;
            case EPixelFormats.A1R5G5B5:
                return  0x8034 ;

            case EPixelFormats.R8G8B8:
            case EPixelFormats.B8G8R8:
            case EPixelFormats.A8R8G8B8:
            case EPixelFormats.A8B8G8R8:
            case EPixelFormats.B8G8R8A8:
            case EPixelFormats.R8G8B8A8:
            case EPixelFormats.X8R8G8B8:
            case EPixelFormats.X8B8G8R8:
               return  0x1401 ;

            case EPixelFormats.A2R10G10B10:
                return 0;
            case EPixelFormats.A2B10G10R10:
                return 0;

            case EPixelFormats.DXT1:
            case EPixelFormats.DXT2:
            case EPixelFormats.DXT3:
            case EPixelFormats.DXT4:
            case EPixelFormats.DXT5:
                return 0;

            case EPixelFormats.FLOAT16_R:
            case EPixelFormats.FLOAT16_RGB:
            case EPixelFormats.FLOAT16_RGBA:
                 return  0x8D61 ;

            case EPixelFormats.FLOAT32_R:
            case EPixelFormats.FLOAT32_RGB:
            case EPixelFormats.FLOAT32_RGBA:
            case EPixelFormats.FLOAT16_GR:
            case EPixelFormats.FLOAT32_GR:
                return  0x1406 ;

            case EPixelFormats.FLOAT32_DEPTH:
                return  0x1406 ;

            case EPixelFormats.DEPTH8:
                return  0x1401 ;
            case EPixelFormats.DEPTH16:
                return  0x1403 ;
            case EPixelFormats.DEPTH32:
                return  0x1405 ;
            case EPixelFormats.DEPTH24STENCIL8:
                return  0x8367 ;

            case EPixelFormats.SHORT_RGBA:
            case EPixelFormats.SHORT_GR:
            case EPixelFormats.SHORT_RGB:
               return  0x1403 ;

            case EPixelFormats.PVRTC_RGB2:
            case EPixelFormats.PVRTC_RGBA2:
            case EPixelFormats.PVRTC_RGB4:
            case EPixelFormats.PVRTC_RGBA4:
                return 0;

            case EPixelFormats.R8:
            case EPixelFormats.RG8:
                return  0x1401 ;

            default:
                { logger.setSourceLocation( "webgl/WebGL.ts" , 504 ); logger.criticalError("getWebGLFormat unknown format"); } ;
                return 0;
        }
	}



	export function getWebGLInternalFormat(eFormat: EPixelFormats):  number
    {
        if(!pixelUtil.isCompressed(eFormat))
        {
            return getWebGLFormat(eFormat);
        }
        else
        {
            switch(eFormat)
            {
                case EPixelFormats.DXT1:
                    return  0x83F1 ;
                case EPixelFormats.DXT2:
                    return 0;
                case EPixelFormats.DXT3:
                    return  0x83F2 ;
                case EPixelFormats.DXT4:
                    return 0;
                case EPixelFormats.DXT5:
                    return  0x83F3 ;
                case EPixelFormats.PVRTC_RGB2:
                    return  0x8C01
                case EPixelFormats.PVRTC_RGBA2:
                    return  0x8C03
                case EPixelFormats.PVRTC_RGB4:
                    return  0x8C00
                case EPixelFormats.PVRTC_RGBA4:
                    return  0x8C02 ;
            }
        }
    }

    export function getWebGLPrimitiveType(eType: EPrimitiveTypes):  number  {
        switch (eType) {
            case EPrimitiveTypes.POINTLIST:
                return  0x0000 ;
            case EPrimitiveTypes.LINELIST:
                return  0x0001 ;
            case EPrimitiveTypes.LINELOOP:
                return  0x0002 ;
            case EPrimitiveTypes.LINESTRIP:
                return  0x0003 ;
            case EPrimitiveTypes.TRIANGLELIST:
                return  0x0004 ;
            case EPrimitiveTypes.TRIANGLESTRIP:
                return  0x0005 ;
            case EPrimitiveTypes.TRIANGLEFAN:
                return  0x0006 ;
        }

        return  0x0000 ;
    }

//не знаю что делает эта функция
    export function getClosestWebGLInternalFormat(eFormat: EPixelFormats, isHWGamma?: bool = false):  number  {
        var iGLFormat: number  = webgl.getWebGLInternalFormat(eFormat);

        if (iGLFormat ===  0 )
        {
            if (isHWGamma) {
// TODO not supported
                return 0;
            }
            else {
                return  0x1908 ;
            }
        }
        else
        {
            return iGLFormat;
        }
    }

/**
     * Convert GL format to EPixelFormat.
     */

    export function getClosestAkraFormat(iGLFormat:  number , iGLDataType:  number ): EPixelFormats {
        switch (iGLFormat) {

            case  0x8C01 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGB2 : EPixelFormats.A8R8G8B8;
            case  0x8C03 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGBA2 : EPixelFormats.A8R8G8B8;
            case  0x8C00 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGB4 : EPixelFormats.A8R8G8B8;
            case  0x8C02 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGBA4 : EPixelFormats.A8R8G8B8;

            case  0x1909 :
                return EPixelFormats.L8;
            case  0x1906 :
                return EPixelFormats.A8;
            case  0x190A :
                return EPixelFormats.BYTE_LA;

            case  0x1907 :
                switch(iGLDataType) {
	                case  0x8363 :
	                    return EPixelFormats.B5G6R5;
	                default:
	                    return EPixelFormats.R8G8B8;
            	}

            case  0x1908 :
                switch(iGLDataType) {
	                case  0x8034 :
	                    return EPixelFormats.A1R5G5B5;
	                case  0x8033 :
	                    return EPixelFormats.A4R4G4B4;
                    case  0x1406 :
                        return EPixelFormats.FLOAT32_RGBA;
	                default:
                        return EPixelFormats.R8G8B8A8;
// return EPixelFormats.A8B8G8R8;
	            }

            case  0x80E1 :
                return EPixelFormats.A8B8G8R8;

            case  0x83F0 :
            case  0x83F1 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT1 : EPixelFormats.A8R8G8B8;

            case  0x83F2 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT3 : EPixelFormats.A8R8G8B8;
            case  0x83F3 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT5 : EPixelFormats.A8R8G8B8;

            case  0x8229 :
                return webgl.hasExtension( "EXT_texture_rg" ) ? EPixelFormats.R8 : EPixelFormats.A8R8G8B8;
            case  0x822B :
                return webgl.hasExtension( "EXT_texture_rg" ) ? EPixelFormats.RG8 : EPixelFormats.A8R8G8B8;

            case  0x1902 :
                switch(iGLDataType) {
                    case  0x1406 :
                        return EPixelFormats.FLOAT32_DEPTH;
                    case  0x1405 :
                        return EPixelFormats.DEPTH32;
                    case  0x1403 :
                        return EPixelFormats.DEPTH16;
                    case  0x1401 :
                        return EPixelFormats.DEPTH8;
                }

            case  0x84F9 :
                return EPixelFormats.DEPTH24STENCIL8;


            default:
//TODO: not supported
                return EPixelFormats.A8R8G8B8;
        }
    }

    export function optionalPO2(iValue:  number ) :  number  {
        if (webgl.hasNonPowerOf2Textures) {
            return iValue;
        }
        else {
            return math.ceilingPowerOfTwo(< number >iValue);
        }
    }


	export function convertToWebGLformat(pSource: IPixelBox, pDest: IPixelBox): void {
// Always need to convert PF_A4R4G4B4, GL expects the colors to be in the 
// reverse order
        if (pDest.format == EPixelFormats.A4R4G4B4) {
// Convert PF_A4R4G4B4 -> PF_B4G4R4A4
// Reverse pixel order
            var iSrcPtr:  number  = (pSource.left + pSource.top * pSource.rowPitch + pSource.front * pSource.slicePitch);
            var iDstPtr:  number  = (pDest.left + pDest.top * pDest.rowPitch + pDest.front * pDest.slicePitch);
            var iSrcSliceSkip:  number  = pSource.getSliceSkip();
            var iDstSliceSkip:  number  = pDest.getSliceSkip();
            var k:  number  = pSource.right - pSource.left;
            var x:  number  = 0,
            	y:  number  = 0,
            	z:  number  = 0;

            for(z = pSource.front; z < pSource.back; z++) {
                for(y = pSource.top; y < pSource.bottom; y++) {
                    for(x = 0; x < k; x++) {
/* B*/
                        pDest[iDstPtr + x] = ((pSource[iSrcPtr + x]&0x000F)<<12) |
/* G*/
                                    		 ((pSource[iSrcPtr + x]&0x00F0)<<4)  |
/* R*/
                                    		 ((pSource[iSrcPtr + x]&0x0F00)>>4)  |
/* A*/
                                    	     ((pSource[iSrcPtr + x]&0xF000)>>12);
                    }

                    iSrcPtr += pSource.rowPitch;
                    iDstPtr += pDest.rowPitch;
                }

                iSrcPtr += iSrcSliceSkip;
                iDstPtr += iDstSliceSkip;
            }
        }
	}

	export function checkFBOAttachmentFormat(eFormat: EPixelFormats): bool
    {
        if(eFormat === EPixelFormats.R8G8B8A8 || eFormat === EPixelFormats.R8G8B8)
        {
            return true;
        }
        else if(eFormat === EPixelFormats.A8B8G8R8){
            return true;
        }
        else if(eFormat === EPixelFormats.FLOAT32_RGBA)
        {
// return hasExtension(WEBGL_COLOR_BUFFER_FLOAT);
            return hasExtension( "OES_texture_float" );
        }
        else if(eFormat === EPixelFormats.FLOAT16_RGBA)
        {
// return hasExtension(EXT_COLOR_BUFFER_HALF_FLOAT);
            return hasExtension( "OES_texture_half_float" );
        }
        else if (eFormat === EPixelFormats.DEPTH32) {
            return true;
        }
        else
        {
            return false;
        }

	}

    export function checkReadPixelFormat(eFormat: EPixelFormats): bool
    {
        if(eFormat === EPixelFormats.R8G8B8A8 || eFormat === EPixelFormats.R8G8B8) {
            return true;
        }
// else if(eFormat === EPixelFormats.A8B8G8R8){
//     return true;
// }
        else if(eFormat === EPixelFormats.FLOAT32_RGBA)
        {
//hasExtension(WEBGL_COLOR_BUFFER_FLOAT) || hasExtension(EXT_COLOR_BUFFER_HALF_FLOAT);
            return false;
        }
        else
        {
            return false;
        }

    }



    export function checkCopyTexImage(eFormat: EPixelFormats): bool {
        switch(eFormat){
            case EPixelFormats.R8G8B8A8:
            case EPixelFormats.R8G8B8:
            case EPixelFormats.L8:
            case EPixelFormats.L16:
            case EPixelFormats.A8:
                return true;

            default:
                return false;
        }
    }

	export function getSupportedAlternative(eFormat: EPixelFormats): EPixelFormats {
		if (checkFBOAttachmentFormat(eFormat)) {
            return eFormat;
        }

/// Find first alternative
        var pct: EPixelComponentTypes = pixelUtil.getComponentType(eFormat);

        switch (pct) {
            case EPixelComponentTypes.BYTE:
                eFormat = EPixelFormats.A8R8G8B8;
                break;
            case EPixelComponentTypes.SHORT:
                eFormat = EPixelFormats.SHORT_RGBA;
                break;
            case EPixelComponentTypes.FLOAT16:
                eFormat = EPixelFormats.FLOAT16_RGBA;
                break;
            case EPixelComponentTypes.FLOAT32:
                eFormat = EPixelFormats.FLOAT32_RGBA;
                break;
            case EPixelComponentTypes.COUNT:
            default:
                break;
        }

        if (checkFBOAttachmentFormat(eFormat)){
            return eFormat;
        }

/// If none at all, return to default
		return EPixelFormats.A8R8G8B8;
	}

}



interface ZipEntry {
	filename: string;
	directory: bool;
	compressedSize: number;
	uncompressedSize: number;
	lastModDate: Date;
	lastModDateRaw: number;
	comment: string;
	crc32: number;

	getData(
		writer: ZipWriter,
		onend: (data: any) => void,
		onprogress?: (index: number, maxValue: number) => void,
		checkCrc32?: bool): void;
}

interface ZipWriter {

}

interface ZipReader {
	getEntries(callback: (entries: ZipEntry[]) => void): void;
	close(callback?: Function): void;
}

interface ZipWriter {

}

interface ZipBlobReaderConstructor {
	new (blob: Blob): ZipReader;
}

interface ZipArrayBufferReaderConstructor {
	new (ab: ArrayBuffer): ZipReader;
}

interface ZipData64URIReaderConstructor {
	new (dataURI: string): ZipReader;
}

interface Zip {

}

interface ZipStatic {
	workerScriptsPath: string;

	BlobReader: ZipBlobReaderConstructor;
	ArrayBufferReader: ZipArrayBufferReaderConstructor;
	Data64URIReader: ZipData64URIReaderConstructor;

	BlobWriter: {new (entry?: ZipEntry): ZipWriter;};
	TextWriter: {new (entry?: ZipEntry): ZipWriter;};
	ArrayBufferWriter: {new (entry?: ZipEntry): ZipWriter;};

	createReader(
		reader: ZipReader,
		callback: (reader: ZipReader) => void,
		onerror?: (err: Error) => void): void;
}

declare var zip: ZipStatic;

module akra.util {
	export class ApiInfo extends Singleton implements IApiInfo {
		private bWebGL: bool = false;
		private bWebAudio: bool = false;
		private bFile: bool = false;
		private bFileSystem: bool = false;
		private bWebWorker: bool = false;
		private bTransferableObjects: bool = false;
		private bLocalStorage: bool = false;
		private bWebSocket: bool = false;
		private bGamepad: bool = false;

		/**@inline*/  get webGL(): bool {
			return webgl.isEnabled();
		}

		get transferableObjects(): bool {
			if (!this.bTransferableObjects) {
				this.bTransferableObjects = (this.bWebWorker && this.chechTransferableObjects() ? true : false);
			}

			return this.bTransferableObjects;
		}

		/**@inline*/  get file(): bool {
			return this.bFile;
		}

		/**@inline*/  get fileSystem(): bool {
			return this.bFileSystem;
		}

		/**@inline*/  get webAudio(): bool {
			return this.bWebAudio;
		}

		/**@inline*/  get webWorker(): bool {
			return this.bWebWorker;
		}

		/**@inline*/  get localStorage(): bool {
			return this.bLocalStorage;
		}

		/**@inline*/  get webSocket(): bool {
			return this.bWebSocket;
		}

		/**@inline*/  get gamepad(): bool {
			return this.bGamepad;
		}

		/**@inline*/  get zip(): bool {
			return isDefAndNotNull(window["zip"]);
		}

		constructor () {
			super();

			var pApi = {};

			this.bWebAudio = ((<any>window).AudioContext && (<any>window).webkitAudioContext ? true : false);
			this.bFile = ((<any>window).File && (<any>window).FileReader && (<any>window).FileList && (<any>window).Blob ? true : false);
			this.bFileSystem = (this.bFile && (<any>window).URL && (<any>window).requestFileSystem ? true : false);
			this.bWebWorker = isDef((<any>window).Worker);
			this.bLocalStorage = isDef((<any>window).localStorage);
			this.bWebSocket = isDef((<any>window).WebSocket);
			this.bGamepad = !! (<any>navigator).webkitGetGamepads || !! (<any>navigator).webkitGamepads || (navigator.userAgent.indexOf('Firefox/') != -1);
		}

		private chechTransferableObjects(): bool {
			var pBlob: Blob = new Blob(["onmessage = function(e) { postMessage(true); }"], { "type" : "text\/javascript" });
			var sBlobURL: string = (<any>window).URL.createObjectURL(pBlob);
			var pWorker: Worker = new Worker(sBlobURL);

			var pBuffer: ArrayBuffer = new ArrayBuffer(1);

		    try {
		        pWorker.postMessage(pBuffer, [pBuffer]);
		    }
		    catch (e) {
		        { logger.setSourceLocation( "util/ApiInfo.ts" , 90 ); logger.log('transferable objects not supported in your browser...'); } ;
		    }

		    pWorker.terminate();

		    if (pBuffer.byteLength) {
		        return false
		    }

		    return true;
		}
	}
}





module akra.info {
	export function canvas(pCanvas: HTMLCanvasElement): ICanvasInfo;
	export function canvas(id: string): ICanvasInfo;
	export function canvas(id): ICanvasInfo {
		var pCanvas: HTMLCanvasElement = isString(id) ? document.getElementById(id) : id;

		return {
			width: isInt(pCanvas.width) ? pCanvas.width : parseInt(pCanvas.style.width),
			height: isInt(pCanvas.height) ? pCanvas.height : parseInt(pCanvas.style.height),
			id: pCanvas.id
		};
	}

	export var browser: IBrowserInfo = new util.BrowserInfo;
	export var api: IApiInfo = new util.ApiInfo;
	export var screen: IScreenInfo = new util.ScreenInfo;

	export var uri: IURI = path.uri(document.location.href);

	export module is {
/**
         * show status - online or offline
         */

		export var online;
/**
         * perform test on mobile device
         */

		export var mobile: bool = (/mobile|iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i)
			.test(navigator.userAgent.toLowerCase());
		export var linux: bool = browser.os === 'Linux';
		export var windows: bool = browser.os === 'Windows';
		export var mac: bool = browser.os === 'Mac';
		export var iPhone: bool = browser.os === 'iPhone';

		export var Opera: bool = browser.name === "Opera";
	}


//TODO: move it to [akra.info.is] module, when typescript access this.
	Object.defineProperty(is, 'online', {
		get: function () {
			return navigator.onLine;
		}
	});
}


/*local and remote via thread*/








module akra {

	export interface IFileMeta {
		lastModifiedDate: string;
		size:  number ;
		eTag?: string;
	}

	export interface IFile {
		 path: string;
		 name: string;
		mode:  number ;

/** @deprecated */

		onread: (e: Error, data: any) => void;
/** @deprecated */

		onopen: Function;

		position:  number ;
		byteLength:  number ;

		 meta: IFileMeta;

// binarayType: EFileBinaryType;

		open(sFilename: string, iMode:  number , fnCallback?: Function): void;
		open(sFilename: string, sMode: string, fnCallback?: Function): void;
		open(sFilename: string, fnCallback?: Function): void;
		open(iMode:  number , fnCallback?: Function): void;
		open(fnCallback?: Function): void;

		close(): void;
		clear(fnCallback?: Function): void;
		read(fnCallback?: (e: Error, data: any) => void, fnProgress?: (bytesLoaded:  number , bytesTotal:  number ) => void): void;
		write(sData: string, fnCallback?: Function, sContentType?: string): void;
		write(pData: ArrayBuffer, fnCallback?: Function, sContentType?: string): void;
		move(sFilename: string, fnCallback?: Function): void;
		copy(sFilename: string, fnCallback?: Function): void;
		rename(sFilename: string, fnCallback?: Function): void;
		remove(fnCallback?: Function): void;

//return current position
		atEnd():  number ;
//return current position;
		seek(iOffset:  number ):  number ;

		isOpened(): bool;
		isExists(fnCallback: Function): void;
		isLocal(): bool;

		getMetaData(fnCallback: Function): void;
	}
}






module akra {
	export interface IThread {
		onmessage: Function;
		onerror: Function;
		id:  number ;

		send(pData: Object, pTransferables?: any[]): void;
		send(pData: ArrayBuffer, pTransferables?: any[]): void;
		send(pData: ArrayBufferView, pTransferables?: any[]): void;
	}
}



























//#define ERR_TM_REACHED_LIMIT 0



//seconds






module akra {

	;

	export interface IThreadManager extends IManager {
		waitForThread(fn: Function):  number ;
		createThread(): bool;
		occupyThread(): IThread;
		releaseThread(iThread:  number ): bool;
		releaseThread(pThread: IThread): bool;
	}
}








module akra.util {

	export enum EThreadStatuses {
		k_WorkerBusy,
		k_WorkerFree
	}

	export interface IThreadStats {
		status: EThreadStatuses;
		creationTime:  number ;
		releaseTime:  number ;
	}

	export class ThreadManager implements IThreadManager, IEventProvider {
		private _sDefaultScript: string;
		private _pWorkerList: IThread[] = [];
		private _pStatsList: IThreadStats[] = [];
		private _pWaiters: Function[] = [];
		private _iSysRoutine:  number  = -1;

		constructor (sScript: string = null) {

			this._sDefaultScript = sScript;


		}

		private startSystemRoutine(): void {
			if (this._iSysRoutine > 0) {
				return;
			}

			{ logger.setSourceLocation( "util/ThreadManager.ts" , 46 ); logger.log("start routine", this._sDefaultScript); } ;

			this._iSysRoutine = setInterval((): void => {
				var pStats: IThreadStats;
				var iNow:  number  = now();

				for (var i:  number  = 0, n:  number  = this._pStatsList.length; i < n; ++ i) {
					pStats = this._pStatsList[i];

					if (pStats.releaseTime > 0 && iNow - pStats.releaseTime >  30  * 1000) {
						if (this.terminateThread(i)) {
							{ logger.setSourceLocation( "util/ThreadManager.ts" , 57 ); logger.log("thread with id - " + i + " terminated. (" + i + "/" + n + ")"); } ;
							i --, n --;
							continue;
						}

						{ logger.setSourceLocation( "util/ThreadManager.ts" , 62 ); logger.warning("thread must be removed: " + i); } ;
					}
				};
			}, 5000);
		}

		private stopSystemRoutine(): void {
			{ logger.setSourceLocation( "util/ThreadManager.ts" , 69 ); logger.log("stop routine", this._sDefaultScript); } ;
			clearInterval(this._iSysRoutine);
		}

		createThread(): bool {
//console.log((new Error).stack)
			if (this._pWorkerList.length ===  4 ) {
				{ logger.setSourceLocation( "util/ThreadManager.ts" , 76 ); logger.warning("Reached limit the number of threads"); } ;
				return false;
			}

			if (!info.api.webWorker) {
				{ logger.setSourceLocation( "util/ThreadManager.ts" , 81 ); logger.error("WebWorkers unsupprted.."); } ;
				return false;
			}

			var pWorker: IThread = <IThread><any>(new Worker(this._sDefaultScript));

			pWorker.id = this._pWorkerList.length;
			pWorker.send = (<any>pWorker).postMessage;

			this._pWorkerList.push(<IThread>pWorker);
			this._pStatsList.push({
				status: EThreadStatuses.k_WorkerFree,
				creationTime: now(),
				releaseTime: now()
				});

			if (this._pWorkerList.length == 1) {
				this.startSystemRoutine();
			}

			return true;
		}

		occupyThread(): IThread {
			var pStats: IThreadStats;
			for (var i:  number  = 0, n:  number  = this._pWorkerList.length; i < n; ++i) {
				pStats = this._pStatsList[i];
		        if (pStats.status == EThreadStatuses.k_WorkerFree) {
		            pStats.status = EThreadStatuses.k_WorkerBusy;
		            pStats.releaseTime = 0;
		            return this._pWorkerList[i];
		        }
		    }

		    if (this.createThread()) {
		    	return this.occupyThread();
		    }
		    else {
		    	{ logger.setSourceLocation( "util/ThreadManager.ts" , 119 ); logger.warning("cannot occupy thread"); } ;
		    	return null;
		    }
		}

		terminateThread(iThread:  number ): bool {
			var pStats: IThreadStats = this._pStatsList[iThread];
			var pWorker: IThread = this._pWorkerList[iThread];

			if (!isDefAndNotNull(pWorker) && pStats.status != EThreadStatuses.k_WorkerFree) {
				return false;
			}

			(<Worker><any>pWorker).terminate();

			this._pStatsList.splice(iThread, 1);
			this._pWorkerList.splice(iThread, 1);

			if (this._pWorkerList.length == 0) {
				this.stopSystemRoutine();
			}

			return true;
		}

		private checkWaiters(pThread: IThread = null): void {
			if (this._pWaiters.length == 0) {
				return;
			}

			if (isNull(pThread)) {
				pThread = this.occupyThread();
			}

			if (!isNull(pThread)) {
				(this._pWaiters.shift())(pThread);
				return;
			}

// console.log("unreleased threads: ", this.countUnreleasedThreds());

			return;
		}

// private countUnreleasedThreds(): uint {
// 	var t = 0;
// 	var pStats: IThreadStats;
// 	for (var i: int = 0, n: int = this._pWorkerList.length; i < n; ++i) {
// 		pStats = this._pStatsList[i];
//         if (pStats.status != EThreadStatuses.k_WorkerFree) {
//         	t ++;
//         }
//     }

//     return t;
// }

		waitForThread(fnWaiter: Function):  number  {
			if (!isFunction(fnWaiter)) {
				return -1;
			}


			this._pWaiters.push(fnWaiter);
			this.checkWaiters();

			return this._pWaiters.length;
		}

		releaseThread(pThread: IThread): bool;
		releaseThread(iThread:  number ): bool;
		releaseThread(pThread: any): bool {
			var iThread:  number ;
			var pStats: IThreadStats;

			if (!isInt(pThread)) {
				iThread = pThread.id;
			}
			else {
				iThread = pThread;
			}

			if (isDef(this._pStatsList[iThread])) {
				pStats = this._pStatsList[iThread];

				pStats.status = EThreadStatuses.k_WorkerFree;
				pStats.releaseTime = now();

				this.checkWaiters();
				return true;
			}

			return false;
		}

		initialize(): bool { return true; }
        destroy(): void {}

        protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return ThreadManager._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); }
// BROADCAST(threadReleased, VOID);
	}
}





//переносим все зависисмости в папку js паки с данными
//обычно, это data/js



//copy threads from sources to {data} folder and modify path to relative

/// @FILE_INTERFACE_THREAD: {data}/js/FileInterface.t.js|src(inc/io/FileInterface.t.js)|data_location({data},DATA)
/// @FILE_LOCAL_THREAD: {data}/js/LocalFile.t.js|src(inc/io/LocalFile.t.js)|data_location({data},DATA)
/// @FILE_REMOTE_THREAD: {data}/js/RemoteFile.t.js|src(inc/io/RemoteFile.t.js)|data_location({data},DATA)










module akra.io {

	export enum EFileActions {
		k_Open = 1,
		k_Read = 2,
		k_Write,
		k_Clear,
		k_Exists,
		k_Remove
	};

	export enum EFileTransferModes {
		k_Normal,
		k_Fast,
		k_Slow
	}

	export interface IFileCommand {
		act: EFileActions;
		name: string;
		mode:  number ;
		pos?:  number ;
		transfer?: EFileTransferModes;
		data?: any;
		contentType?: string;
		progress?: bool;
	}


	var pLocalFileThreadManager = new  util.ThreadManager("@FILE_LOCAL_THREAD") ;
	var pRemoteFileThreadManager = new  util.ThreadManager("@FILE_REMOTE_THREAD") ;

	export var getLocalFileThreadManager = (): IThreadManager => pLocalFileThreadManager;
	export var getRemoteFileThreadManager = (): IThreadManager => pRemoteFileThreadManager;




	export class TFile implements IFile {
// binaryType: EFileBinaryType = EFileBinaryType.ARRAY_BUFFER;

		protected _iMode:  number ;
		protected _pUri: IURI = null;
		protected _nCursorPosition:  number  = 0;
		protected _bOpened: bool = false;
		protected _eTransferMode: EFileTransferModes = EFileTransferModes.k_Normal;
		protected _pFileMeta: IFileMeta = null;
		protected _isLocal: bool = false;



		/**@inline*/  get path(): string {
//ASSERT(isDefAndNotNull(this._pFileMeta), "There is no file handle open.");
        	return this._pUri.toString();
		}

		/**@inline*/  get name(): string {
			return path.info(this._pUri.path).basename;
		}

		/**@inline*/  get mode():  number  {
			return this._iMode;
		}

		/**@inline*/  get meta(): IFileMeta {
			{ logger.setSourceLocation( "TFile.ts" , 121 ); logger.assert(isDefAndNotNull(this._pFileMeta), 'There is no file handle open.'); } ;
			return this._pFileMeta;
		}

//set mode(sMode: string);
//set mode(iMode: int);
		set mode(sMode: any) {
			this._iMode = isString(sMode)? filemode(sMode): sMode;
		}

		/**@inline*/  set onread(fnCallback: (e: Error, data: any) => void) {
			this.read(fnCallback);
		}

		/**@inline*/  set onopen(fnCallback: Function) {
			this.open(fnCallback);
		}

		/**@inline*/  get position():  number  {
			{ logger.setSourceLocation( "TFile.ts" , 140 ); logger.assert(isDefAndNotNull(this._pFileMeta), 'There is no file handle open.'); } ;
        	return this._nCursorPosition;
		}

		set position(iOffset:  number ) {
			{ logger.setSourceLocation( "TFile.ts" , 145 ); logger.assert(isDefAndNotNull(this._pFileMeta), 'There is no file handle open.'); } ;
			this._nCursorPosition = iOffset;
		}

		/**@inline*/  get byteLength():  number  {
       		return this._pFileMeta? this._pFileMeta.size: 0;
		}

		constructor (sFilename?: string, sMode?: string, fnCallback: Function = TFile.defaultCallback);
		constructor (sFilename?: string, iMode?:  number , fnCallback: Function = TFile.defaultCallback);
		constructor (sFilename?: string, sMode?: any, fnCallback: Function = TFile.defaultCallback) {
			if (isDef(sMode)) {
				this._iMode = isString(sMode)? filemode(sMode): sMode;
			}

			this.setAndValidateUri(path.uri(sFilename));

			if (info.api.transferableObjects) {
				this._eTransferMode = EFileTransferModes.k_Fast;
			}
//OPERA MOVED TO WEBKIT, and this TRAP not more be needed!
// else if (info.browser.name == "Opera") {
// 	this._eTransferMode = EFileTransferModes.k_Slow;
// }

			if (arguments.length > 2) {
				this.open(sFilename, sMode, fnCallback);
			}
		}

		open(sFilename: string, iMode:  number , fnCallback?: Function): void;
//open(sFilename: string, sMode: string, fnCallback?: Function): void;
		open(sFilename: string, fnCallback?: Function): void;
		open(iMode:  number , fnCallback?: Function): void;
		open(fnCallback?: Function): void;
		open(sFilename?: any, iMode?: any, fnCallback?: any): void {
			var pFile: IFile = this;
			var hasMode: bool = !isFunction(iMode);

			 if (arguments.length < 3) {
		        if (isString(arguments[0])) {
		            this.setAndValidateUri(path.uri(sFilename));
		            fnCallback = arguments[1];
		        }
		        else if (isInt(arguments[0])) {
		            this._iMode = arguments[0];
		            fnCallback = arguments[1];
		        }
		        else {
		            fnCallback = arguments[0];
		        }

		        { logger.setSourceLocation( "TFile.ts" , 197 ); logger.assert(isDefAndNotNull(this._pUri), "No filename provided."); } ;


		        this.open(this._pUri.toString(), this._iMode, fnCallback);

		        return;
		    }

		    fnCallback = arguments[hasMode ? 2 : 1];
		    fnCallback = fnCallback || TFile.defaultCallback;

		    if (this.isOpened()) {
		        { logger.setSourceLocation( "TFile.ts" , 209 ); logger.warning("file already opened: " + this.name); } ;
		        (<Function>fnCallback).call(pFile, null, this._pFileMeta);
		    }

		    this.setAndValidateUri(path.uri(arguments[0]));

		    if (hasMode) {
		    	this._iMode = (isString(arguments[1]) ? filemode(<string>arguments[1]) : arguments[1]);
		    }

		    this.update(function (err) {
		    	if (err) {
		    		{ logger.setSourceLocation( "TFile.ts" , 221 ); logger.warning("file update err", err); } ;
		    		fnCallback.call(pFile, err);
		    		return;
		    	}

		        if ( ((this._iMode & (1 << (3)) ) != 0) ) {
		            this.position = this.size;
		        }

		        fnCallback.call(pFile, null, this._pFileMeta);
		    });
		}

		close(): void {
			this._pUri = null;
			this._iMode = EIO.IN | EIO.OUT;
			this._nCursorPosition = 0;
			this._pFileMeta = null;
		}

		clear(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.clear.apply(this, _pArgv); }); return; } ;

			var pCommand: IFileCommand = {
                act:  EFileActions.k_Clear,
                name: this.path,
                mode: this._iMode
            };

			this.execCommand(pCommand, fnCallback);
		}


		read(
			fnCallback?: (e: Error, data: any) => void = <any>TFile.defaultCallback,
			fnProgress?: (bytesLoaded:  number , bytesTotal:  number ) => void): void {

			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.read.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var eTransferMode: EFileTransferModes = this._eTransferMode;

		    { logger.setSourceLocation( "TFile.ts" , 263 ); logger.assert( ((this._iMode & (1 << (0)) ) != 0) , "The file is not readable."); } ;

		    var pCommand: IFileCommand = {
		                    act:      		EFileActions.k_Read,
		                    name:     		this.path,
		                    mode:    		this._iMode,
		                    pos:      		this._nCursorPosition,
		                    transfer: 		this._eTransferMode,
		                    progress: 		isDefAndNotNull(fnProgress)
		                 };

		    var fnCallbackSystem: Function = (err, pData: any): any => {
				if (err) {
					fnCallback.call(pFile, err);
					return;
				}

				if (pData.progress) {
					fnProgress(pData.loaded, pData.total);
					return false;
				}


		        pFile.atEnd();
		        fnCallback.call(pFile, null, pData.data);
		    };

		    this.execCommand(pCommand, fnCallbackSystem);
		}

		write(sData: string, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void;
		write(pData: ArrayBuffer, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void;
		write(pData: any, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.write.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var iMode:  number  = this._iMode;
		    var pCommand: IFileCommand;
			var fnCallbackSystem: Function = function (err, pMeta) {
				if (err) {
					fnCallback.call(pFile, err);
					return;
				}

		    	pFile.position += isString(pData)? pData.length: pData.byteLength;
		    	(<any>pFile)._pFileMeta = <IFileMeta>pMeta;

		    	fnCallback.call(pFile, null, pMeta);
		    };

		    { logger.setSourceLocation( "TFile.ts" , 313 ); logger.assert( ((iMode & (1 << (1)) ) != 0) , "The file is not writable."); } ;

		    sContentType = sContentType || ( ((iMode & (1 << (5)) ) != 0) ? "application/octet-stream" : "text/plain");

		    pCommand = {
                    act:         EFileActions.k_Write,
                    name:        this.path,
                    mode:        this._iMode,
                    data:        pData,
                    contentType: sContentType,
                    pos:         this._nCursorPosition
                 };

            if (!isString(pData)) {
            	this.execCommand(pCommand, fnCallbackSystem, [pData]);
            }
            else {
            	this.execCommand(pCommand, fnCallbackSystem);
        	}
		}

		move(sFilename: string, fnCallback: Function = TFile.defaultCallback): void {
			var pFile: IFile = this;

			this.copy(sFilename, function(err) {
				if (err) {
					fnCallback(err);
					return;
				}

				pFile.remove(fnCallback);
			});
		}

		copy(sFilename: string, fnCallback: Function = TFile.defaultCallback): void {
			var iMode:  number  = EIO.IN | EIO.OUT | EIO.TRUNC;
		    var pFile: IFile = this;
		    var pFileCopy: IFile;

		    if ( ((this._iMode & (1 << (5)) ) != 0) ) {
		        iMode |= EIO.BIN;
		    }

		    pFileCopy = new TFile(sFilename, iMode,
		                                     function (err) {
		                                     	if (err) {
		                                     		fnCallback(err);
		                                     	}

		                                        pFile.read((e: Error, pData: ArrayBuffer): void => {
		                                            pFile.write(pData, fnCallback);
		                                        });
		                                     });
		}

		rename(sFilename: string, fnCallback: Function = TFile.defaultCallback): void {
			var pName: IPathinfo = path.info(sFilename);

		    { logger.setSourceLocation( "TFile.ts" , 371 ); logger.assert(!pName.dirname, 'only filename can be specified.'); } ;

		    this.move(path.info(this._pUri.path).dirname + "/" + pName.basename, fnCallback);
		}

		remove(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.remove.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var pCommand: IFileCommand = {
		                     act:  EFileActions.k_Remove,
		                     name: this.path,
		                     mode: this._iMode
		                 };
		    var fnCallbackSystem: Function = function (err, pData) {
		        pFile.close();

		        if (isDef(fnCallback)) {
		            fnCallback.call(pFile, err, pData);
		        }
		    }

		    this.execCommand(pCommand, fnCallbackSystem);
		}

//return current position
		atEnd():  number  {
			this.position = this.byteLength;
			return this._nCursorPosition;
		}
//return current position;
		seek(iOffset:  number ):  number  {
			{ logger.setSourceLocation( "TFile.ts" , 403 ); logger.assert(isDefAndNotNull(this._pFileMeta), "There is no file handle open."); } ;

		    var nSeek:  number  = this._nCursorPosition + iOffset;
		    if (nSeek < 0) {
		        nSeek = this.byteLength - (math.abs(nSeek) % this.byteLength);
		    }

		    { logger.setSourceLocation( "TFile.ts" , 410 ); logger.assert(nSeek >= 0 && nSeek <= this.byteLength, "Invalid offset parameter"); } ;

		    this._nCursorPosition = nSeek;

		    return this._nCursorPosition;
		}

		isOpened(): bool {
			return this._pFileMeta !== null;
		}

		isExists(fnCallback: Function): void {
			var pCommand: IFileCommand = {
                                              act:  EFileActions.k_Exists,
                                              name: this.path,
                                              mode: this._iMode
                                          };
			this.execCommand(pCommand, fnCallback);
		}

		/**@inline*/  isLocal(): bool {
			return this._isLocal;
		}

		getMetaData(fnCallback: Function): void {
			{ logger.setSourceLocation( "TFile.ts" , 435 ); logger.assert(isDefAndNotNull(this._pFileMeta), 'There is no file handle open.'); } ;
		    fnCallback(null, {
		                  lastModifiedDate: this._pFileMeta.lastModifiedDate
		              });
		}
		private setAndValidateUri(sFilename: IURI);
		private setAndValidateUri(sFilename: string);
		private setAndValidateUri(sFilename: any) {
			var pUri: IURI = path.uri(sFilename);
			var pUriLocal: IURI;

			if (pUri.scheme === "filesystem:") {
		        pUriLocal = path.uri(pUri.path);
// console.log(pUriLocal.toString());
		        { logger.setSourceLocation( "TFile.ts" , 450 ); logger.assert(!(pUriLocal.protocol && pUriLocal.host != info.uri.host), "It supports only local files within the current domain."); }
                                                                           ;

		        var pFolders: string[] = pUriLocal.path.split('/');


		        if (pFolders[0] == "" || pFolders[0] == ".") {
		            pFolders = pFolders.slice(1);
		        }

		        { logger.setSourceLocation( "TFile.ts" , 460 ); logger.assert(pFolders[0] === "temporary", "Supported only \"temporary\" filesystems. " + pUri.toString()); }
                                                                                ;

//removing "temporary" from path...
		        pFolders = pFolders.slice(1);

		        this._pUri = path.uri(pFolders.join("/"));
// console.log(sFilename.toString(), "===>", this._pUri.toString());
		        this._isLocal = true;
		    }
		    else {
		    	this._pUri = pUri;
			}
		}

		private update(fnCallback: Function = TFile.defaultCallback) {
			var pFile: IFile = this;
			var pCommand: IFileCommand = {
                     act:  EFileActions.k_Open,
                     name: this._pUri.toString(),
                     mode: this._iMode
                 };
			var fnCallbackSystem: Function = function (err, pMeta) {
				(<any>pFile)._pFileMeta = <IFileMeta>pMeta;
// console.log(pMeta);
				fnCallback.call(pFile, err, pFile);
			};

			this.execCommand(pCommand, fnCallbackSystem);
		}

		private execCommand(pCommand: IFileCommand, fnCallback: Function, pTransferables?: any[]): void {
			TFile.execCommand(this, this.isLocal(), pCommand, fnCallback, pTransferables);
		}

		static defaultCallback: Function = function (err) {
			if (err) {
				throw err;
			}
		}


		private static execCommand(pFile: IFile, isLocal: bool, pCommand: IFileCommand, fnCallback: Function, pTransferables?: any[]): void {

// var pFile: IFile = this;
			var pManager: IThreadManager = isLocal? getLocalFileThreadManager(): getRemoteFileThreadManager();
			pManager.waitForThread((pThread: IThread) => {
				pThread.onmessage = function (e) {
					if (fnCallback.call(pFile, null, e.data) === false) {
						return;
					}

					pThread.onmessage = null;
					pManager.releaseThread(pThread);
				}

				pThread.onerror = function (e) {
					pThread.onmessage = null;
					fnCallback.call(pFile, e);
					pManager.releaseThread(pThread);
				}



				if (isDef(pTransferables)) {
// console.log(pCommand, pTransferables);
					pThread.send(pCommand, pTransferables);
				}
				else {
					pThread.send(pCommand);
				}
			});
		}

	}
}


/*local file via local files system(async)*/

/**
 * FIle implementation via <Local filesystem>.
 * ONLY FOR LOCAL FILES!!
 */



















module akra.io {

	class LocalFileSystem {
// binaryType: EFileBinaryType = EFileBinaryType.ARRAY_BUFFER;


		private _pFileSystem: FileSystem = null;
		private _pCallbackQueue: Function[] = [];

		setFileSystem(pFS: FileSystem): void {
			this._pFileSystem = pFS;
		}

/**
		 * Инициализация файловой системы.
		 * @tparam Function fnCallback Функция, вызываемая
		 * при успешной(получет в 1ом параметре fs)
		 * инициализации системы.
		 */

		get (fnCallback: Function): void {
			if (this._pFileSystem) {
		        fnCallback(this._pFileSystem);
		        return;
		    }

		    var pFileSystem: LocalFileSystem = this;
		    var pQueue: Function[] = this._pCallbackQueue;

		    pQueue.push(fnCallback);

		    if (pQueue.length > 1) {
		        return;
		    }

    		window.storageInfo.requestQuota(window.TEMPORARY,  (32 * 1024 * 1024) ,
				function (nGrantedBytes:  number ) {
					window.requestFileSystem(
						window.TEMPORARY,
						nGrantedBytes,
						function (pFs: FileSystem) {

						   pFileSystem.setFileSystem(pFs);

						   if (pQueue.length) {
						       for (var i:  number  = 0; i < pQueue.length; ++i) {
						           pQueue[i](pFs);
						       }
						   }


						}, LocalFileSystem.errorHandler);
				});
		}

		static errorHandler (e: FileError): void {
			var sMesg: string = "init filesystem: ";

	        switch (e.code) {
	            case FileError.QUOTA_EXCEEDED_ERR:
	                sMesg += 'QUOTA_EXCEEDED_ERR';
	                break;
	            case FileError.NOT_FOUND_ERR:
	                sMesg += 'NOT_FOUND_ERR';
	                break;
	            case FileError.SECURITY_ERR:
	                sMesg += 'SECURITY_ERR';
	                break;
	            case FileError.INVALID_MODIFICATION_ERR:
	                sMesg += 'INVALID_MODIFICATION_ERR';
	                break;
	            case FileError.INVALID_STATE_ERR:
	                sMesg += 'INVALID_STATE_ERR';
	                break;
	            default:
	                sMesg += 'Unknown Error';
	                break;
	        }

	        { logger.setSourceLocation( "LocalFile.ts" , 105 ); logger.error(sMesg); } ;
		}
	}

	var pLocalFileSystem: LocalFileSystem = new LocalFileSystem;

	export function getFileSystem(fnCallback: (pFileSystem: FileSystem) => void): void {
		pLocalFileSystem.get(fnCallback);
	}

	export class LocalFile implements IFile {
		private _pUri: IURI;
		private _iMode:  number ;

//File
		private _pFile: File;
//file reader
		private _pFileReader: FileReader;
//pointer to file entry in filsystem
		private _pFileEntry: FileEntry;

		private _nCursorPosition:  number  = 0;

		/**@inline*/  get path(): string {
			{ logger.setSourceLocation( "LocalFile.ts" , 129 ); logger.assert(isDefAndNotNull(this._pFile), "There is no file handle open."); } ;
        	return this._pUri.toString();
		}

		/**@inline*/  get name(): string {
			return path.info(this._pUri.path).basename;
		}

		/**@inline*/  get mode():  number  {
			return this._iMode;
		}

		/**@inline*/  get meta(): IFileMeta {
			return null;
		}

//set mode(sMode: string);
//set mode(iMode: int);
		set mode(sMode: any) {
			this._iMode = isString(sMode)? filemode(sMode): sMode;
		}

		/**@inline*/  set onread(fnCallback: (e: Error, data: any) => void) {
			this.read(fnCallback);
		}

		/**@inline*/  set onopen(fnCallback: Function) {
			this.open(fnCallback);
		}

		/**@inline*/  get position():  number  {
			{ logger.setSourceLocation( "LocalFile.ts" , 160 ); logger.assert(isDefAndNotNull(this._pFile), "There is no file handle open."); } ;
        	return this._nCursorPosition;
		}

		set position(iOffset:  number ) {
			{ logger.setSourceLocation( "LocalFile.ts" , 165 ); logger.assert(isDefAndNotNull(this._pFile), "There is no file handle open."); } ;
			this._nCursorPosition = iOffset;
		}

		/**@inline*/  get byteLength():  number  {
       		return this._pFile? this._pFile.size: 0;
		}


		constructor (sFilename?: string, sMode?: string, fnCallback: Function = LocalFile.defaultCallback);
		constructor (sFilename?: string, iMode?:  number , fnCallback: Function = LocalFile.defaultCallback);
		constructor (sFilename?: string, sMode?: any, fnCallback: Function = LocalFile.defaultCallback) {
			if (isDef(sMode)) {
				this._iMode = isString(sMode)? filemode(sMode): sMode;
			}

			this.setAndValidateUri(path.uri(sFilename));

			if (arguments.length > 2) {
				this.open(sFilename, sMode, fnCallback);
			}
		}


		open(sFilename: string, iMode:  number , fnCallback?: Function): void;
//open(sFilename: string, sMode: string, fnCallback?: Function): void;
		open(sFilename: string, fnCallback?: Function): void;
		open(iMode:  number , fnCallback?: Function): void;
		open(fnCallback?: Function): void;
		open(sFilename?: any, iMode?: any, fnCallback?: any): void {
			var pFile: IFile = this;
			var hasMode: bool = !isFunction(iMode);

			 if (arguments.length < 3) {
		        if (isString(arguments[0])) {
		            this.setAndValidateUri(path.uri(sFilename));
		            fnCallback = arguments[1];
		        }
		        else if (isInt(arguments[0])) {
		            this._iMode = arguments[0];
		            fnCallback = arguments[1];
		        }
		        else {
		            fnCallback = arguments[0];
		        }

		        { logger.setSourceLocation( "LocalFile.ts" , 211 ); logger.assert(isDefAndNotNull(this._pUri), "No filename provided."); } ;


		        this.open(this._pUri.toString(), this._iMode, fnCallback);

		        return;
		    }

		    fnCallback = arguments[hasMode ? 2 : 1];
		    fnCallback = fnCallback || LocalFile.defaultCallback;

		    if (this.isOpened()) {
		        { logger.setSourceLocation( "LocalFile.ts" , 223 ); logger.warning("file already opened: " + this.name); } ;
		        (<Function>fnCallback)(null, this._pFile);
		    }

		    this.setAndValidateUri(path.uri(arguments[0]));

		    if (hasMode) {
		    	this._iMode = (isString(arguments[1]) ? filemode(<string>arguments[1]) : arguments[1]);
		    }

		    var fnFSInited: Function;

		    var pFile: LocalFile = this;
		    var pFileSystem: FileSystem = null;
		    var fnErrorHandler: Function = function (e) {
		        if (e.code == FileError.NOT_FOUND_ERR &&  ((pFile.mode & (1 << (1)) ) != 0) ) {
					LocalFile.createDir(
						pFileSystem.root,
						path.info(pFile.path).dirname.split('/'),
		                function (e) {
		                	if (!isNull(e)) {
		                		fnCallback.call(pFile, e);
	                		}
	                		else {
	                			fnFSInited.call(pFile, pFileSystem);
	                		}
		                });
		        }
		        else {
		            fnCallback.call(pFile, e);
		        }
		    };

		    fnFSInited = function (pFs: FileSystem) {
		        { logger.setSourceLocation( "LocalFile.ts" , 257 ); logger.assert(isDefAndNotNull(pFs), "local file system not initialized"); } ;

		        pFileSystem = pFs;
		        pFs.root.getFile(this.path,
		                         {
		                             create:     ((this._iMode & (1 << (1)) ) != 0) ,
		                             exclusive: false
		                         },
		                         function (fileEntry: Entry) {
		                             (<LocalFile>pFile).setFileEntry(<FileEntry>fileEntry);

		                             (<FileEntry>fileEntry).file(function (file: File) {
		                                 (<LocalFile>pFile).setFile(file);

		                                 if ( ((pFile.mode & (1 << (4)) ) != 0)  && pFile.byteLength) {
		                                     pFile.clear(function (err) {
		                                     	if (err) {
		                                     		fnCallback(err);
		                                     	}
		                                     	else {
		                                        	fnCallback.call(pFile, null, file);
		                                        }
		                                     });
		                                     return;
		                                 }

		                                 if ( ((pFile.mode & (1 << (3)) ) != 0) ) {
		                                     pFile.position = pFile.byteLength;
		                                 }

		                                 fnCallback.call(pFile, null, file);
		                             }, <ErrorCallback>fnErrorHandler);

		                         },
		                         <ErrorCallback>fnErrorHandler);
		    };

		    getFileSystem(function (pFileSystem: FileSystem) {
		        fnFSInited.call(pFile, pFileSystem);
		    });
		}

		close (): void {
		    this._pUri = null;
		    this._iMode = EIO.IN | EIO.OUT;
		    this._nCursorPosition = 0;
		    this._pFile = null;
		};


		clear(fnCallback: Function = LocalFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.clear.apply(this, _pArgv); }); return; } ;

			{ logger.setSourceLocation( "LocalFile.ts" , 310 ); logger.assert(isDefAndNotNull(this._pFile), 'There is no file handle open'); } ;

		    var pFile: IFile = this;
		    var pFileEntry: FileEntry = this._pFileEntry;

		    pFileEntry.createWriter(
		    	function (pWriter: FileWriter) {
			        pWriter.seek(0);

			        pWriter.onwriteend = function () {
		                fnCallback.call(pFile, null);
		            }

			        pWriter.truncate(0);

			    },
			    function (e: FileError) {
			        fnCallback.call(pFile, e);
			    });
		}

		read(fnCallback: (e: Error, data: any) => void = <any>LocalFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.read.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var eTransferMode: EFileTransferModes = this._iMode;

		    { logger.setSourceLocation( "LocalFile.ts" , 337 ); logger.assert( ((this._iMode & (1 << (0)) ) != 0) , "The file is not readable."); } ;

			var pReader: FileReader = this._pFileReader;
			var pFileObject: File = this._pFile;

		    pReader.onloadend = function (e) {
		        var pData: any = (<any>(e.target)).result;
		        var nPos:  number  = pFile.position;

		        if (nPos) {
		            if ( ((pFile.mode & (1 << (5)) ) != 0) ) {
		                pData = (new Uint8Array((new Uint8Array(pData)).subarray(nPos))).buffer;
		            }
		            else {
		                pData = pData.substr(nPos);
		            }
		        }

		        pFile.atEnd();

		        fnCallback.call(pFile, null, pData);
		    };

		    if ( ((pFile.mode & (1 << (5)) ) != 0) ) {
		        pReader.readAsArrayBuffer(pFileObject);
		    }
		    else {
		        pReader.readAsText(pFileObject);
		    }
		}

		write(sData: string, fnCallback: Function = LocalFile.defaultCallback, sContentType?: string): void;
		write(pData: ArrayBuffer, fnCallback: Function = LocalFile.defaultCallback, sContentType?: string): void;
		write(pData: any, fnCallback: Function = LocalFile.defaultCallback, sContentType?: string): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.write.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var iMode:  number  = this._iMode;

		    { logger.setSourceLocation( "LocalFile.ts" , 376 ); logger.assert( ((iMode & (1 << (1)) ) != 0) , "The file is not writable."); } ;

		    sContentType = sContentType || ( ((iMode & (1 << (5)) ) != 0)  ? "application/octet-stream" : "text/plain");

		    var pFile: IFile = this;
		    var pFileEntry: FileEntry = this._pFileEntry;

		    pFileEntry.createWriter(function (pWriter: FileWriter) {
		        pWriter.seek(pFile.position);

		        pWriter.onerror = function (e: FileError) {
		            fnCallback.call(pFileEntry, e);
		        }


	            pWriter.onwriteend = function () {
	                if ( ((iMode & (1 << (5)) ) != 0) ) {
	                    pFile.seek(pData.byteLength);
	                }
	                else {
	                    pFile.seek(pData.length);
	                }

	                fnCallback.call(pFile, null);
	            };

		        pWriter.write(<Blob>(new (<any>Blob)(pData, {type: sContentType})));

		    },
		    function (e: FileError) {
		        fnCallback.call(pFile, e);
		    });
		}


		move(sFilename: string, fnCallback: Function = LocalFile.defaultCallback): void {
			var pFile: IFile = this;

			this.copy(sFilename, function(err) {
				if (err) {
					fnCallback(err);
					return;
				}

				pFile.remove(fnCallback);
			});
		}

		copy(sFilename: string, fnCallback: Function = LocalFile.defaultCallback): void {
			var iMode:  number  = EIO.IN | EIO.OUT | EIO.TRUNC;
		    var pFile: IFile = this;
		    var pFileCopy: IFile;

		    if ( ((this._iMode & (1 << (5)) ) != 0) ) {
		        iMode |= EIO.BIN;
		    }

		    pFileCopy = new LocalFile(sFilename, iMode, (e: Error): void => {
		                                     	if (e) fnCallback(e);
		                                        pFile.read((e: Error, pData: ArrayBuffer): void => {
		                                            pFile.write(pData, fnCallback);
		                                        });
		                                     });
		}

		rename(sFilename: string, fnCallback: Function = LocalFile.defaultCallback): void {
			var pName: IPathinfo = path.info(sFilename);

		    { logger.setSourceLocation( "LocalFile.ts" , 444 ); logger.assert(!pName.dirname, 'only filename can be specified.'); } ;

		    this.move(path.info(this._pUri.path).dirname + "/" + pName.basename, fnCallback);
		}

		remove(fnCallback: Function = LocalFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.remove.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    this._pFileEntry.remove(
		    <VoidCallback>function () {
		        pFile.close();
		        fnCallback.call(pFile, null);
		    }, <ErrorCallback>fnCallback);
		}

//return current position
		atEnd():  number  {
			this.position = this.byteLength;
			return this._nCursorPosition;
		}
//return current position;
		seek(iOffset:  number ):  number  {
			{ logger.setSourceLocation( "LocalFile.ts" , 467 ); logger.assert(isDefAndNotNull(this._pFile), "There is no file handle open."); } ;

		    var nSeek:  number  = this._nCursorPosition + iOffset;
		    if (nSeek < 0) {
		        nSeek = this.byteLength - (math.abs(nSeek) % this.byteLength);
		    }

		    { logger.setSourceLocation( "LocalFile.ts" , 474 ); logger.assert(nSeek >= 0 && nSeek <= this.byteLength, "Invalid offset parameter"); } ;

		    this._nCursorPosition = nSeek;

		    return this._nCursorPosition;
		}

		isOpened(): bool {
			return this._pFile !== null;
		}

		isExists(fnCallback: Function): void {
			this.open(function(e: FileError) {
				fnCallback(isNull(e)? true: false);
			});
		}

		isLocal(): bool {
			return true;
		}

		getMetaData(fnCallback: Function): void {
			{ logger.setSourceLocation( "LocalFile.ts" , 496 ); logger.assert(isDefAndNotNull(this._pFile), 'There is no file handle open.'); } ;
		    fnCallback(null, {
		                  lastModifiedDate: this._pFile.lastModifiedDate
		              });
		}

		setFileEntry(pFileEntry: FileEntry): bool {
			if (!isNull(this._pFileEntry)) {
				return false;
			}

			this._pFileEntry = pFileEntry;
			return true;
		}

		setFile(pFile: File): bool {
			if (!isNull(this._pFile)) {
				return false;
			}

			this._pFile = pFile;

			return true;
		}

		private setAndValidateUri(sFilename: IURI);
		private setAndValidateUri(sFilename: string);
		private setAndValidateUri(sFilename: any) {
			var pUri: IURI = path.uri(sFilename);
			var pUriLocal: IURI;

			if (pUri.protocol === "filesystem") {
		        pUriLocal = path.uri(pUri.path);

		        { logger.setSourceLocation( "LocalFile.ts" , 531 ); logger.assert(!(pUriLocal.protocol && pUriLocal.host != info.uri.host), "Поддерживаются только локальные файлы в пределах текущего домена."); }
                                                                                                                                              ;

		        var pFolders: string[] = pUriLocal.path.split('/');

		        if (pFolders[0] == "" || pFolders[0] == ".") {
		            pFolders = pFolders.slice(1);
		        }

		        { logger.setSourceLocation( "LocalFile.ts" , 540 ); logger.assert(pUri.host === "temporary", "Поддерживаются только файловые системы типа \"temporary\"."); }
                                                                                                                     ;

		        this._pUri = path.uri(pFolders.join("/"));
		    }
		    else {
		    	{ logger.setSourceLocation( "LocalFile.ts" , 545 ); logger.error("used non local uri"); } ;
			}
		}

		static errorHandler (e: FileError): void {
			var sMesg: string = "";

	        switch (e.code) {
	            case FileError.QUOTA_EXCEEDED_ERR:
	                sMesg += 'QUOTA_EXCEEDED_ERR';
	                break;
	            case FileError.NOT_FOUND_ERR:
	                sMesg += 'NOT_FOUND_ERR';
	                break;
	            case FileError.SECURITY_ERR:
	                sMesg += 'SECURITY_ERR';
	                break;
	            case FileError.INVALID_MODIFICATION_ERR:
	                sMesg += 'INVALID_MODIFICATION_ERR';
	                break;
	            case FileError.INVALID_STATE_ERR:
	                sMesg += 'INVALID_STATE_ERR';
	                break;
	            default:
	                sMesg += 'Unknown Error';
	                break;
	        }

	        { logger.setSourceLocation( "LocalFile.ts" , 573 ); logger.error(sMesg); } ;
		}

		static createDir(pRootDirEntry: DirectoryEntry, pFolders: string[], fnCallback) {
		    if (pFolders[0] == "." || pFolders[0] == "") {
		        pFolders = pFolders.slice(1);
		    }

		    pRootDirEntry.getDirectory(
		    	pFolders[0],
			    { create: true },
			    function (dirEntry: Entry) {
			        if (pFolders.length) {
			            LocalFile.createDir(<DirectoryEntry>dirEntry, pFolders.slice(1), fnCallback);
			        }
			        else {
			            fnCallback(null);
			        }
			    }, fnCallback);
		};

		static defaultCallback: Function = function (err) {
			if (err) {
				LocalFile.errorHandler(err);
			}
		}

	}
}


/*local file via local files system(async)*/

/**
 * FIle implementation via <Local Storage>.
 * ONLY FOR LOCAL FILES!!
 */















module akra.io {
	export class StorageFile extends TFile implements IFile {

// binaryType: EFileBinaryType = EFileBinaryType.ARRAY_BUFFER;

		constructor (sFilename?: string, sMode?: string, fnCallback: Function = TFile.defaultCallback);
		constructor (sFilename?: string, iMode?:  number , fnCallback: Function = TFile.defaultCallback);
		constructor (sFilename?: string, sMode?: any, fnCallback: Function = TFile.defaultCallback) {
			super(sFilename, sMode, fnCallback);
		}

		clear(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.clear.apply(this, _pArgv); }); return; } ;

			localStorage.setItem(this.path, "");
			this._pFileMeta.size = 0;

			fnCallback(null, this);
		}

		read(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.read.apply(this, _pArgv); }); return; } ;

			{ logger.setSourceLocation( "StorageFile.ts" , 38 ); logger.assert( ((this._iMode & (1 << (1)) ) != 0) , "The file is not readable."); } ;

		    var pData: any = this.readData();
		    var nPos:  number  = this._nCursorPosition;

		    if (nPos) {
		        if ( ((this._iMode & (1 << (5)) ) != 0) ) {
		            pData = (new Uint8Array((new Uint8Array(pData)).subarray(nPos))).buffer;
		        }
		        else {
		            pData = pData.substr(nPos);
		        }
		    }

		    this.atEnd();

		    if (fnCallback) {
		        fnCallback.call(this, null, pData);
		    }
		}

		write(sData: string, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void;
		write(pData: ArrayBuffer, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void;
		write(pData: any, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) (<Function>fnCallback)(err); this.write.apply(this, _pArgv); }); return; } ;

			var iMode:  number  = this._iMode;
			var nSeek:  number ;
			var pCurrentData: any;

		    { logger.setSourceLocation( "StorageFile.ts" , 68 ); logger.assert( ((iMode & (1 << (1)) ) != 0) , "The file is not writable."); } ;

		    sContentType = sContentType || ( ((iMode & (1 << (5)) ) != 0)  ? "application/octet-stream" : "text/plain");

		    pCurrentData = this.readData();

		    if (!isString(pCurrentData)) {
		        pCurrentData = util.abtos(pCurrentData);
		    }

		    nSeek = (isString(pData) ? pData.length : pData.byteLength);

		    if (!isString(pData)) {
		        pData = util.abtos(pData);
		    }

		    pData = (<string>pCurrentData).substr(0, this._nCursorPosition) + (<string>pData) +
		    	(<string>pCurrentData).substr(this._nCursorPosition + (<string>pData).length);

		    try {
		        localStorage.setItem(this.path, pData);
		    }
		    catch (e) {
		       fnCallback(e);
		    }

		    this._pFileMeta.size = pData.length;
		    this._nCursorPosition += nSeek;

		    fnCallback(null);
		}

		isExists(fnCallback: Function = TFile.defaultCallback): void {
			fnCallback.call(this, null, localStorage.getItem(this.path) == null);
		}

		remove(fnCallback: Function = TFile.defaultCallback): void {
			localStorage.removeItem(this.path);
    		fnCallback.call(this, null);
		}

		private readData(): any {
			var pFileMeta: IFileMeta = this._pFileMeta;
		    var pData: string = localStorage.getItem(this.path);
		    var pDataBin: ArrayBuffer;

		    if (pData == null) {
		        pData = "";
		        if ( ((this._iMode & (1 << (1)) ) != 0) ) {
		            localStorage.setItem(this.path, pData);
		        }
		    }


		    if ( ((this._iMode & (1 << (5)) ) != 0) ) {
		        pDataBin = util.stoab(pData);
		        pFileMeta.size = pDataBin.byteLength;
		        return pDataBin;
		    }
		    else {
		        pFileMeta.size = pData.length;
		        return pData;
		    }

//return null;
		}

		private update(fnCallback: Function): void {
			this._pFileMeta = null;
		    this.readData();
		    fnCallback.call(this, null);
		}
	}
}




module akra.io {

	export enum EIO {
		IN 		= 0x01,
		OUT 	= 0x02,
		ATE 	= 0x04,
		APP 	= 0x08,
		TRUNC 	= 0x10,
		BINARY 	= 0x20,
		TEXT 	= 0x40,
		JSON 	= 0x80,
		URL 	= 0x100,

		BIN = 0x20,
	};

	export function filemode(sMode: string):  number  {
		switch (sMode.toLowerCase()) {
//URL
			case "a+u":
	            return EIO.IN | EIO.OUT | EIO.APP | EIO.URL;
	        case "w+u":
	            return EIO.IN | EIO.OUT | EIO.TRUNC | EIO.URL;
	        case "r+u":
	            return EIO.IN | EIO.OUT | EIO.URL;

	        case "au":
	            return EIO.APP | EIO.URL;
	        case "wu":
	            return EIO.OUT | EIO.URL;
	        case "ru":
	            return EIO.IN | EIO.URL;

//JSON
			case "a+j":
	            return EIO.IN | EIO.OUT | EIO.APP | EIO.JSON;
	        case "w+j":
	            return EIO.IN | EIO.OUT | EIO.TRUNC | EIO.JSON;
	        case "r+j":
	            return EIO.IN | EIO.OUT | EIO.JSON;

	        case "aj":
	            return EIO.APP | EIO.JSON;
	        case "wj":
	            return EIO.OUT | EIO.JSON;
	        case "rj":
	            return EIO.IN | EIO.JSON;

//TEXT
	        case "a+t":
	            return EIO.IN | EIO.OUT | EIO.APP | EIO.TEXT;
	        case "w+t":
	            return EIO.IN | EIO.OUT | EIO.TRUNC | EIO.TEXT;
	        case "r+t":
	            return EIO.IN | EIO.OUT | EIO.TEXT;

	        case "at":
	            return EIO.APP | EIO.TEXT;
	        case "wt":
	            return EIO.OUT | EIO.TEXT;
	        case "rt":
	            return EIO.IN | EIO.TEXT;

	        case "a+b":
	            return EIO.IN | EIO.OUT | EIO.APP | EIO.BIN;
	        case "w+b":
	            return EIO.IN | EIO.OUT | EIO.TRUNC | EIO.BIN;
	        case "r+b":
	            return EIO.IN | EIO.OUT | EIO.BIN;

	        case "ab":
	            return EIO.APP | EIO.BIN;
	        case "wb":
	            return EIO.OUT | EIO.BIN;
	        case "rb":
	            return EIO.IN | EIO.BIN;

	        case "a+":
	            return EIO.IN | EIO.OUT | EIO.APP;
	        case "w+":
	            return EIO.IN | EIO.OUT | EIO.TRUNC;
	        case "r+":
	            return EIO.IN | EIO.OUT;

	        case "a":
	            return EIO.APP | EIO.OUT;
	        case "w":
	            return <number>EIO.OUT;
	        case "r":
	        default:
	            return <number>EIO.IN;
	    }
	}

// function _fopen (sUri: string, iMode?: int): IFile;
// function _fopen (sUri: string, sMode?: int): IFile;
// function _fopen (pUri: IURI, iMode: int): IFile;
// function _fopen (pUri: IURI, sMode: string): IFile;

	function _fopen(sUri: any, pMode: any = EIO.IN): IFile {
		sUri = path.resolve(sUri);

		if (info.api.webWorker) {
			return new TFile(<string>sUri, pMode);
		}
		else if (info.api.fileSystem) {
			return new LocalFile(<string>sUri, pMode);
		}
		else {
			return new StorageFile(<string>sUri, pMode);
		}
	}

	export var fopen = _fopen;
}

module akra {
	export var fopen = io.fopen;
}

















module akra {

	export interface ICodec{

		getType():string;
		getDataType():string;
		magicNumberMatch(pMagicNumber: Uint8Array):bool;
		magicNumberToFileExt(pMagicNumber: Uint8Array):string;

		code(pInput:Uint8Array,pData:ICodecData):Uint8Array;
		decode(pData:Uint8Array,pCodecData:ICodecData):Uint8Array;


	}


	export interface ICodecData{
		dataType: string;
	}

}





module akra {


	export interface IImgCodec extends ICodec{
	}

	export interface IImgData extends ICodecData{
		height:  number ;
		width: number ;
		depth: number ;
		size: number ;

		numMipMaps: number ;
		flags:  number ;
		cubeFlags: number ;

		format: EPixelFormats;
		numFace:  number ;

	}
}










module akra
{
	export interface ICodecMap {
        	[index: string]: ICodec;
    	};


	export class Codec implements ICodec
	{


		private static _pMapCodecs: ICodecMap =<ICodecMap>{};

		static registerCodec(pCodec: ICodec):void
		{

			if(!isDef(Codec._pMapCodecs[pCodec.getType()]))
			{
				Codec._pMapCodecs[pCodec.getType()]=pCodec;
			}
			else
			{
				{ logger.setSourceLocation( "Codec.ts" , 28 ); logger.criticalError(pCodec.getType() + " already has a registered codec. "); } ;
			}
		}

		static isCodecRegistered(pCodec: ICodec):bool
		{
			return isDef(Codec._pMapCodecs[pCodec.getType()]);
		}

		static unRegisterCodec(pCodec: ICodec):void
		{
			delete Codec._pMapCodecs[pCodec.getType()];
		}

		static getExtension():string[]
		{
			var pExt:string[]=<string[]>Array();
			var sExt:string="";
			for(sExt in Codec._pMapCodecs)
			{
				pExt.push(sExt)
			}
			return pExt;
		}

		static getCodec(sExt: string):ICodec;
		static getCodec(pMagicNumber: Uint8Array):ICodec;
		static getCodec(pMagicNumber: any):ICodec
		{
			var sExt: string="";
			if(isString(pMagicNumber))
			{
				if(isDef(Codec._pMapCodecs[pMagicNumber]))
				{
					return Codec._pMapCodecs[pMagicNumber];
				}
				else
				{
					{ logger.setSourceLocation( "Codec.ts" , 66 ); logger.criticalError("Can not find codec for "+pMagicNumber); } ;
					return null;
				}
			}
			else
			{
				for(sExt in Codec._pMapCodecs)
				{
					var sExt1:string=Codec._pMapCodecs[sExt].magicNumberToFileExt(pMagicNumber);
					if(sExt1)
					{
						if(sExt1==Codec._pMapCodecs[sExt].getType())
						{
							return Codec._pMapCodecs[sExt];
						}
						else
						{
							return Codec.getCodec(sExt1);
						}

					}
				}
			}
			return null;
		}


		magicNumberMatch(pMagicNumber: Uint8Array):bool
		{
			return !(this.magicNumberToFileExt(pMagicNumber).length==0);
		}

		magicNumberToFileExt(pMagicNumber: Uint8Array):string
		{
			{ logger.setSourceLocation( "Codec.ts" , 100 ); logger.criticalError("Codec.magicNumberToFileExt is virtual"); } ;
			return null;
		}

		getType():string
		{
			{ logger.setSourceLocation( "Codec.ts" , 106 ); logger.criticalError("Codec.getType is virtual"); } ;
			return null;
		}

		getDataType():string
		{
			{ logger.setSourceLocation( "Codec.ts" , 112 ); logger.criticalError("Codec.getDataType is virtual"); } ;
			return null;
		}

		code(pInput:Uint8Array,pData:ICodecData):Uint8Array
		{
			{ logger.setSourceLocation( "Codec.ts" , 118 ); logger.criticalError("Codec.code is virtual"); } ;
			return null;
		}
		decode(pData:Uint8Array,pCodecData:ICodecData):Uint8Array
		{
			{ logger.setSourceLocation( "Codec.ts" , 123 ); logger.criticalError("Codec.decode is virtual"); } ;
			return null;
		}



	}

	export class CodecData implements ICodecData
	{

		/**@inline*/  get dataType(): string{
			{ logger.setSourceLocation( "Codec.ts" , 135 ); logger.criticalError("CodecData.dataType is virtual"); } ;
			return "CodecData";
		}
	}

}







module akra {


	export class ImgCodec extends Codec implements IImgCodec{
		getDataType(): string
        {
            return "ImgData"
        }

	}

	export class ImgData extends CodecData implements IImgData{

        protected _iHeight: number =0;
		protected _iWidth: number =0;
		protected _iDepth: number =1;
		protected _iSize: number =0;
        protected _iCubeFlags: number ;

		protected _nMipMaps: number =0;
		protected _iFlags: number =0;

		protected _eFormat: EPixelFormats=EPixelFormats.UNKNOWN;


		/**@inline*/  get width():  number  {
			return this._iWidth;
		}
    	/**@inline*/  set width(iWidth: number ){
			this._iWidth=iWidth;
		}


    	/**@inline*/  get height():  number  {
    		return this._iHeight;
    	}
    	/**@inline*/  set height(iHeight: number ){
			this._iHeight=iHeight;
		}

    	/**@inline*/  get depth():  number  {
    		return this._iDepth;
    	}
    	/**@inline*/  set depth(iDepth: number ){
			this._iDepth=iDepth;
		}


    	/**@inline*/  get size():  number  {
    		return core.pool.resources.Img.calculateSize(this.numMipMaps, this.numFace, this.width, this.height, this.depth, this.format);
        }

    	/**@inline*/  get numMipMaps():  number
    	{
    		return this._nMipMaps;
    	}

    	/**@inline*/  set numMipMaps(nNumMipMaps: number ) {
    		this._nMipMaps=nNumMipMaps;
    	}

    	/**@inline*/  get format(): EPixelFormats {
    		return this._eFormat;
    	}

    	/**@inline*/  set format(ePixelFormat:EPixelFormats){
    		this._eFormat=ePixelFormat;
    	}

        /**@inline*/  get flags():  number  {
            return this._iFlags;
        }

        /**@inline*/  set flags(iFlags: number ){
            this._iFlags=iFlags;
        }

        /**@inline*/  get cubeFlags():  number  {
            return this._iCubeFlags;
        }

        /**@inline*/  set cubeFlags(iFlags: number ){
            this._iCubeFlags=iFlags;
        }

        /**@inline*/  get numFace(): number {
            if (this._iFlags&EImageFlags.CUBEMAP)
            {
                var nFace: number =0;
                for(var i: number =0;i<32;i++)
                {
                    nFace++;
                }
                return nFace;
            }
            else
            {
                return 1;
            }
        }

        /**@inline*/  get dataType():string
        {
             return "ImgData";
        }
	}
}








module akra.core.pool.resources {

	export class Img extends ResourcePoolItem implements IImg {
		protected _iWidth:         number           = 0;
		protected _iHeight:        number           = 0;
		protected _iDepth:         number           = 0;

		protected _nMipMaps:       number           = 0;
		protected _iFlags:         number           = 0;
        protected _iCubeFlags:     number           = 0;

		protected _eFormat:       EPixelFormats = EPixelFormats.UNKNOWN;

		protected _pBuffer:       Uint8Array    = null;

        /**@inline*/  get byteLength():  number  {
// console.log(__CALLSTACK__);
// console.log(this, this._pBuffer, this.isResourceLoaded(), "[", this.findResourceName(), "]");
			return this._pBuffer.buffer.byteLength;
		}

    	/**@inline*/  get width():  number  {
    		return this._iWidth;
    	}

    	/**@inline*/  get height():  number  {
    		return this._iHeight;
    	}

    	/**@inline*/  get depth():  number  {
    		return this._iDepth;
    	}

    	/**@inline*/  get numFaces(): number {
            if (this._iFlags&EImageFlags.CUBEMAP)
            {
                var nFace: number =0;
                for(var i: number =0;i<6;i++)
                {
                    if(this._iCubeFlags&(1<<i))
                    {
                        nFace++;

                    }

                }
                return nFace;
            }
            else
            {
                return 1;
            }
        }

    	/**@inline*/  get numMipMaps():  number  {
    		return this._nMipMaps;
    	}

    	/**@inline*/  get format(): EPixelFormats {
    		return this._eFormat;
    	}

         /**@inline*/  get flags():  number  {
            return this._iFlags;
        }

        /**@inline*/  get cubeFlags():  number  {
            return this._iCubeFlags;
        }

		constructor () {
			super();
		}

		createResource(): bool {
// innitialize the resource (called once)
		    { logger.setSourceLocation( "resources/Img.ts" , 89 ); logger.assert(!this.isResourceCreated(), "The resource has already been created."); }
                                                            ;

// signal that the resource is now created,
// but has not been enabled
		    this.notifyCreated();
		    this.notifyDisabled();

		    return true;
		}

		destroyResource(): bool {
// destroy the resource
//
// we permit redundant calls to destroy, so there are no asserts here
//
		    if (this.isResourceCreated()) {
// disable the resource
		        this.disableResource();

		        this.freeMemory();

		        this.notifyUnloaded();
		        this.notifyDestroyed();

		        return (true);
		    }

		    return (false);
		}

		restoreResource(): bool {
			{ logger.setSourceLocation( "resources/Img.ts" , 121 ); logger.assert(this.isResourceCreated(), "The resource has not been created."); }
                                                        ;

		    this.notifyRestored();
		    return true;
		}

		disableResource(): bool {
			{ logger.setSourceLocation( "resources/Img.ts" , 129 ); logger.assert(this.isResourceCreated(), "The resource has not been created."); }
                                                      ;

		    this.notifyDisabled();
		    return true;
		}

		loadResource(sFilename?: string): bool {
			return !isNull(this.load(sFilename));
		}

		saveResource(sFilename?: string): bool {
			return false;
		}


		create(iWidth:  number , iHeight:  number , iDepth?:  number  = 1, eFormat?: EPixelFormats = EPixelFormats.BYTE_RGBA,
                         nFaces?:  number  = 1, nMipMaps?:  number  = 0): IImg
        {
            var iSize :  number = Img.calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat);
            var pBuffer : Uint8Array = new Uint8Array(iSize);
            return this.loadDynamicImage(pBuffer, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
        }



    	freeMemory(): void {
    		this._iWidth = 0;
    		this._iHeight = 0;
    		this._iDepth = 0;
    		this._pBuffer = null;
    	}

    	set(pSrc: IImg): IImg {
    		this.freeMemory();

    		this._iWidth = pSrc.width;
    		this._iHeight = pSrc.height;
    		this._iDepth = pSrc.depth;
    		this._eFormat = pSrc.format;

    		this._iFlags = pSrc.flags;

    		this._nMipMaps = pSrc.numMipMaps;

    		this._pBuffer = new Uint8Array(pSrc.getData());

    		return this;
    	}


    	flipY(pDest?: IImg): IImg {
    		return this;
    	}

    	flipX(pDest?: IImg): IImg {
    		return this;
    	}

        load(sFileName: string,  fnCallBack?: Function): IImg;
        load(pData: Uint8Array, sType?: string,  fnCallBack?: Function): IImg;
        load(pCanvas: HTMLCanvasElement, fnCallBack?: Function): IImg;


/*pData: any, sType?: any, fnCallBack?: Function*/
    	load(                                                  ): IImg
        {
            var pMe: IImg=this;

            if (arguments[0] instanceof HTMLCanvasElement) {
                var pCanvas: HTMLCanvasElement = arguments[0];
                var fnCallBack: Function = arguments[1];

                var pTempContext : CanvasRenderingContext2D = pCanvas.getContext('2d');
                if (!pTempContext) {
                    if (isDefAndNotNull(fnCallBack)) {
                        fnCallBack(false);
                    }
                    return this;
                }

                var pImageData : ImageData = pTempContext.getImageData(0, 0, pCanvas.width, pCanvas.height);

                this.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)), pCanvas.width, pCanvas.height);

                if (isDefAndNotNull(fnCallBack)) {
                    fnCallBack(true);
                }
                return this;
            }
            else if (isString(arguments[0])) {
                var sFilename: string = arguments[0];
                var fnCallBack: Function = arguments[1];
                var sExt : string = path.info(sFilename).ext.toLowerCase();

                if(sExt === "png" || sExt === "jpg" || sExt === "jpeg" || sExt === "gif" || sExt === "bmp") {
                    var pImg:HTMLImageElement = new Image();

                    pImg.onload = function() {
                        var pTempCanvas: HTMLCanvasElement=<HTMLCanvasElement>document.createElement("canvas");
                        pTempCanvas.width = pImg.width;
                        pTempCanvas.height = pImg.height;

                        var pTempContext: CanvasRenderingContext2D=<CanvasRenderingContext2D>((<any>pTempCanvas).getContext("2d"));
                        pTempContext.drawImage(pImg,0,0);

                        var pImageData: ImageData = pTempContext.getImageData(0, 0, pImg.width, pImg.height);

                        pMe.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)),pImg.width, pImg.height,1, EPixelFormats.BYTE_RGBA);

                        if (isDefAndNotNull(fnCallBack)) {
                            fnCallBack(true);
                        }

                    }
                    pImg.onerror = function() {
                        if (isDefAndNotNull(fnCallBack)) {
                            fnCallBack(false);
                        }
                    }
                    pImg.onabort = function() {
                        if (isDefAndNotNull(fnCallBack)) {
                            fnCallBack(false);
                        }
                    }

                    pImg.src = sFilename;
                }
                else {
                    io.fopen(sFilename,"rb").onread = function(pError:Error, pDataInFile:ArrayBuffer) {
                        pMe.load(new Uint8Array(pDataInFile), sExt, fnCallBack);
                    }
                }

                return this;
            }
            else {
                var pData: Uint8Array = arguments[0];
                var sType: string = arguments[1];
                var fnCallBack: Function = arguments[2];
                var pCodec:ICodec = null;

                if(sType === "png" || sType === "jpg" || sType === "jpeg" || sType === "gif" || sType === "bmp") {

                    var pBlob = new Blob([pData], {'type': 'image\/' + sType});
                    var pObjectURL = (<any>window).URL.createObjectURL(pBlob);

                    var pImg:HTMLImageElement = new Image();

                    pImg.onload = function() {
                        var pTempCanvas: HTMLCanvasElement = <HTMLCanvasElement>document.createElement("canvas");
                        pTempCanvas.width = pImg.width;
                        pTempCanvas.height = pImg.height;
                        var pTempContext: CanvasRenderingContext2D = <CanvasRenderingContext2D>((<any>pTempCanvas).getContext("2d"));
                        pTempContext.drawImage(pImg,0,0);
                        var pImageData: ImageData = pTempContext.getImageData(0, 0, pImg.width, pImg.height);

                        pMe.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)),pImg.width, pImg.height,1, EPixelFormats.BYTE_RGBA);

                        if (isDefAndNotNull(fnCallBack)) {
                            fnCallBack(true);
                        }

                    }
                    pImg.onerror = function() {
                        if (isDefAndNotNull(fnCallBack)) {
                            fnCallBack(false);
                        }
                    }
                    pImg.onabort = function() {
                        if (isDefAndNotNull(fnCallBack)) {
                            fnCallBack(false);
                        }
                    }

                    pImg.src = pObjectURL;
                    return this;
                }

                if(sType) {
                    pCodec = Codec.getCodec(sType);
                }



                if(!pCodec) {
/*buffer.*/
                    var iMagicLen:  number  = Math.min(32, pData.           byteLength);
                    pCodec = Codec.getCodec(pData.subarray(pData.byteOffset, iMagicLen));
                }

                if(!pCodec) {
                    { logger.setSourceLocation( "resources/Img.ts" , 318 ); logger.criticalError("Unable to load image: Image format is unknown. Unable to identify codec. Check it or specify format explicitly.\n"+"Img.load"); } ;
                    if (fnCallBack) {
                        fnCallBack(false);
                    }
                    return this;
                }



                var pImgData: IImgData = new ImgData();

                this._pBuffer = pCodec.decode(pData, pImgData);

                this._iWidth = pImgData.width;
                this._iHeight = pImgData.height;
                this._iDepth = pImgData.depth;
                this._nMipMaps = pImgData.numMipMaps;
                this._iFlags = pImgData.flags;
                this._iCubeFlags = pImgData.cubeFlags;

//console.log(this._iCubeFlags.toString(16),this._iFlags.toString(16));

                this._eFormat = pImgData.format;

                this.notifyLoaded();


                if (fnCallBack) {
                    fnCallBack(true);
                }

                return this;
            }


    	}

    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number  = 1, eFormat: EPixelFormats = EPixelFormats.BYTE_RGB,
                         nFaces?:  number  = 1, nMipMaps?:  number  = 0): IImg
    	{
            var iSize :  number = Img.calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat);

            if (iSize != pData.buffer.byteLength)
            {
                { logger.setSourceLocation( "resources/Img.ts" , 362 ); logger.criticalError("Stream size does not match calculated image size\n"+"Img.loadRawData"); } ;
            }

            var pBuffer : Uint8Array = new Uint8Array(iSize);

            pBuffer.set(pData);

            return this.loadDynamicImage(pBuffer, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
     	}

        loadDynamicImage(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth?:  number  = 1,
                         eFormat?: EPixelFormats = EPixelFormats.BYTE_RGB, nFaces?:  number  = 1, nMipMaps?:  number  = 0): IImg
        {
//size
            this._iWidth=iWidth;
            this._iHeight=iHeight;
            this._iDepth=iDepth;

            this._eFormat=eFormat;
            this._nMipMaps=nMipMaps;
            this._iFlags=0;

            if (pixelUtil.isCompressed(this._eFormat))
            {
                this._iFlags |= EImageFlags.COMPRESSED;
            }
            if (this._iDepth != 1)
            {
                this._iFlags |= EImageFlags.TEXTURE_3D;
            }

            if(nFaces == 6)
            {
                this._iFlags |= EImageFlags.CUBEMAP;
            }

            if(nFaces != 6 && nFaces != 1)
            {
                { logger.setSourceLocation( "resources/Img.ts" , 400 ); logger.criticalError("Number of faces currently must be 6 or 1.\n"+"Img.loadDynamicImage"); } ;
            }

            this._pBuffer=pData;
            this.notifyLoaded();
            return this;
        }

    	convert(eFormat: EPixelFormats): bool {
    		return false;
    	}

//Gets the physical width in bytes of each row of pixels.
    	getRawSpan():  number  {
    		return this._iWidth*this.getPixelSize();
    	}

    	getBPP():  number  {
    		return this.getPixelSize()* 8;
    	}

        getPixelSize():  number {
            return pixelUtil.getNumElemBytes(this._eFormat);
        }



    	getData(): Uint8Array {
    		return this._pBuffer;
    	}

    	hasFlag(eFlag: EImageFlags): bool
        {
    		if(this._iFlags & eFlag)
            {
                return true;
            }
            else
            {
                return false;
            }
    	}

    	hasAlpha(): bool {
    		return pixelUtil.hasAlpha(this._eFormat);
    	}

    	isCompressed(): bool {
    		return  pixelUtil.isCompressed(this._eFormat);
    	}

    	isLuminance(): bool {
    		return pixelUtil.isLuminance(this._eFormat);
    	}



    	getColorAt(pColor:IColor, x: number , y:  number , z?: number =0): IColor
        {
            var iStart: number =this.getPixelSize()* (z * this._iWidth * this._iHeight + this._iWidth * y + x);
    		pixelUtil.unpackColour(pColor, this._eFormat, this._pBuffer.subarray(iStart,iStart+this.getPixelSize()));
            return pColor;
    	}

    	setColorAt(pColor: IColor, x:  number , y:  number , z?:  number =0): void
        {
            var iStart: number =this.getPixelSize()* (z * this._iWidth * this._iHeight + this._iWidth * y + x);
            pixelUtil.packColour(pColor, this._eFormat,this._pBuffer.subarray(iStart,iStart+this.getPixelSize()));
    	}

    	getPixels(iFace?:  number , iMipMap?:  number ): IPixelBox
        {

// Image data is arranged as:
// face 0, top level (mip 0)
// face 0, mip 1
// face 0, mip 2
// face 1, top level (mip 0)
// face 1, mip 1
// face 1, mip 2
// etc

            if(iMipMap > this.numMipMaps){
                { logger.setSourceLocation( "resources/Img.ts" , 483 ); logger.warning("Mipmap index out of range",iMipMap,this.numMipMaps); } ;
                return null;
            }

            if(iFace >= this.numFaces){
                { logger.setSourceLocation( "resources/Img.ts" , 488 ); logger.warning("Face index out of range",iFace,this.numFaces); } ;
                return null;
            }

// Calculate mipmap offset and size
            var pData:Uint8Array = this.getData();


// Base offset is number of full faces
            var iWidth:  number  = this._iWidth;
            var iHeight:  number  = this._iHeight;
            var iDepth:  number  = this._iDepth;


// Figure out the offsets 
            var iFullFaceSize:  number  = 0;
            var iFinalFaceSize:  number  = 0;
            var iFinalWidth:  number  = 0;
            var iFinalHeight:  number  = 0 ;
            var iFinalDepth:  number  = 0;
            var iMipSize: number =0;
            var iOffset: number  = 0;

            for(var iMip: number =0; iMip <= this.numMipMaps; ++iMip)
            {
                if (iMip == iMipMap)
                {
                    iFinalFaceSize = iFullFaceSize;
                    iFinalWidth = iWidth;
                    iFinalHeight = iHeight;
                    iFinalDepth = iDepth;
                    iMipSize = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this.format);
                }
                iFullFaceSize += pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this.format);

/// Half size in each dimension
                if(iWidth!=1) iWidth /= 2;
                if(iHeight!=1) iHeight /= 2;
                if(iDepth!=1) iDepth /= 2;
            }
// Advance pointer by number of full faces, plus mip offset into
            iOffset += iFace * iFullFaceSize;
            iOffset += iFinalFaceSize;

// Return subface as pixelbox
            var pSrc:IPixelBox=new pixelUtil.PixelBox(iFinalWidth, iFinalHeight, iFinalDepth, this.format, pData.subarray(iOffset,iOffset+iMipSize));
            return pSrc;
    	}

    	scale(pDest: IPixelBox, eFilter?: EFilters): bool {
    		return null;
    	}

    	resize(iWidth:  number , iHeight:  number , eFilter?: EFilters): bool {
    		return null;
    	}

    	generatePerlinNoise(fScale:  number , iOctaves:  number , fFalloff:  number ): void {

    	}

    	randomChannelNoise(iChannel:  number , iMinRange:  number , iMaxRange:  number ): void {

    	}

        static calculateSize(nMipMaps:  number , nFaces:  number , iWidth:  number , iHeight:  number , iDepth:  number  , eFormat: EPixelFormats):  number
        {
            var iSize: number  = 0;
            var iMip: number  = 0;

            for(iMip=0; iMip<=nMipMaps; iMip++)
            {
                iSize += pixelUtil.getMemorySize(iWidth, iHeight, iDepth, eFormat)*nFaces;
                if(iWidth!=1) iWidth = Math.floor(iWidth/2);
                if(iHeight!=1) iHeight = Math.floor(iHeight/2);
                if(iDepth!=1) iDepth = Math.floor(iDepth/2);
            }
            return iSize;
        }

        static getMaxMipmaps(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats) :  number
        {
            var iCount:  number  = 0;
            if((iWidth > 0) && (iHeight > 0))
            {
                do {
                    if(iWidth>1)
                    {
                        iWidth = iWidth>>>1;
                    }
                    if(iHeight>1)
                    {
                        iHeight = iHeight>>>1;
                    }
                    if(iDepth>1)
                    {
                        iDepth = iDepth>>>1;
                    }
/*
                     NOT needed, compressed formats will have mipmaps up to 1x1
                     if(PixelUtil::isValidExtent(width, height, depth, format))
                     count ++;
                     else
                     break;
                     */


                    iCount ++;
                } while(!(iWidth === 1 && iHeight === 1 && iDepth === 1));
            }
            return iCount;
        }
	}
}











module akra.core.pool.resources {
	export class Component extends ResourcePoolItem implements IAFXComponent{
		private _pTechnique: IAFXTechniqueInstruction = null;
		private _pComposer: IAFXComposer = null;

		constructor(){
			super();
		}

		create(): void {
			this._pComposer = this.manager.getEngine().getComposer();
		}

		/**@inline*/  getTechnique(): IAFXTechniqueInstruction {
			return this._pTechnique;
		}

		/**@inline*/  setTechnique(pTechnique: IAFXTechniqueInstruction): void {
			this._pTechnique = pTechnique;
		}

		/**@inline*/  isPostEffect(): bool {
			return isNull(this._pTechnique) ? false : this._pTechnique.isPostEffect();
		}

		/**@inline*/  getName(): string {
			return this._pTechnique.getName();
		}

		/**@inline*/  getTotalPasses():  number  {
			return this._pTechnique.totalOwnPasses();
		}

		/**@inline*/  getHash(iShift:  number , iPass:  number ): string {
			return this.getGuid() + ">" + iShift.toString() +
				   ">" + (iPass ===  0xffffff  ? "A" : iPass.toString());
		}
	}
}
























module akra {
    ;
    ;
    ;
    ;

	export enum ERenderDataTypes {
/*<! положить данные в текстуру, и больше ничего не делать.*/
        ISOLATED = 0,
/*<! обычные даннае из текстуры, доступные по индексу.*/
        INDEXED,
/*<! данные по 2йному индексу.*/
        I2I,
/*<! непосредственно данные для атрибута.*/
        DIRECT
    };

    export enum ERenderDataOptions {
/*<! использовать индекс на индекс упаковку данных*/
        ADVANCED_INDEX =  (1 << (0x10)) ,
        SINGLE_INDEX   =  (1 << (0x11)) ,
/*<! создать RenderData как классические данные, с данными только в аттрибутах, без использования видео буфферов.*/

/*<! определяет, будет ли объект редерится*/
        RENDERABLE     =  (1 << (0x12))
    }

    export interface IRenderDataType {
        new (): IRenderData;
    }

	export interface IRenderData extends IReferenceCounter {
		 buffer: IRenderDataCollection;

/**
         * Allocate data for rendering.
         */

        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBuffer, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBufferView, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, hasIndex?: bool):  number ;

/**
         * Remove data from this render data.
         */

        releaseData(iDataLocation:  number ): void;

        allocateAttribute(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateAttribute(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;

        allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
        allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
        allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;

        addIndexSet(usePreviousDataSet?: bool, ePrimType?: EPrimitiveTypes, sName?: string):  number ;
        getNumIndexSet():  number ;
        getIndexSetName(iSet:  number ): string;
        selectIndexSet(iSet:  number ): bool;
        selectIndexSet(sName: string): bool;
        getIndexSet():  number ;
        findIndexSet(sName: string):  number ;

/**
         * Specifies uses advanced index.
         */

        hasAttributes(): bool;
        useAdvancedIndex(): bool;
        useSingleIndex(): bool;
        useMultiIndex(): bool;

/** mark index set as renderable */

        setRenderable(iIndexSet:  number , bValue: bool): void;
        isRenderable(iIndexSet:  number ): bool;

/** Mark this RenderData as renderable. */

        isRenderable(): bool;
        setRenderable(bValue: bool): void;

        hasSemantics(sSemantics: string, bSearchComplete?: bool): bool;

        getDataLocation(iDataLocation:  number ):  number ;
        getDataLocation(sSemantics: string):  number ;
        getIndexFor(sSemantics: string): ArrayBufferView;
        getIndexFor(iDataLocation:  number ): ArrayBufferView;
        getIndices(): IBufferData;
        getPrimitiveCount():  number ;
        getPrimitiveType(): EPrimitiveTypes;
        getAdvancedIndexData(sSemantics: string): IVertexData;

        index(sData: string, sSemantics: string, useSame?: bool, iBeginWith?:  number , bForceUsage?: bool): bool;
        index(iData:  number , sSemantics: string, useSame?: bool, iBeginWith?:  number , bForceUsage?: bool): bool;


        toString(): string;

//applyMe(): bool;

        _draw(pTechnique: IRenderTechnique, pViewport: IViewport,
              pRenderable: IRenderableObject, pSceneObject: ISceneObject): void;

        _getFlow(iDataLocation:  number ): IDataFlow;
        _getFlow(sSemantics: string, bSearchComplete?: bool): IDataFlow;

        _getData(iDataLocation:  number , bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(sSemanticsn: string, bSearchOnlyInCurrentMap?: bool): IVertexData;

        _addData(pVertexData: IVertexData, iFlow?:  number , eType?: ERenderDataTypes):  number ;

        _setup(pCollection: IRenderDataCollection, iId:  number , ePrimType?: EPrimitiveTypes, eOptions?:  number ): bool;

//FIXME: hack for terrain, for force limitin drawing index length
        _setIndexLength(iLength:  number );
	}
}







module akra {
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;

	export enum EMeshOptions {
        HB_READABLE = < number >EHardwareBufferFlags.READABLE,
        RD_ADVANCED_INDEX = < number >ERenderDataOptions.ADVANCED_INDEX
    };

    export enum EMeshCloneOptions{
/*<! copy only geometry*/
        GEOMETRY_ONLY = 0x00,
/*<! use shared geometry*/
        SHARED_GEOMETRY = 0x01
    };

    export interface IMeshMap {
        [name: string]: IMesh;
    }

	export interface IMesh extends IEventProvider {
         flexMaterials: IMaterial[];
         name: string;
         data: IRenderDataCollection;
/*<! number of submeshes in. */
         length:  number ;
         boundingBox: IRect3d;
         boundingSphere: ISphere;

		skeleton: ISkeleton;
        shadow: bool;


        getOptions():  number ;
        getEngine(): IEngine;

//setup(sName: string, eOptions: int, pDataBuffer?: IRenderDataCollection): bool;
        destroy(): void;
        clone(iCloneOptions:  number ): IMesh;

/** @deprecated */

        replaceFlexMaterials(pFlexMaterials): void;
/** @deprecated */

        getFlexMaterial(iMaterial:  number ): IMaterial;
        getFlexMaterial(csName: string): IMaterial;
/** @deprecated */

        addFlexMaterial(sName: string, pMaterial?: IMaterial): bool;
/** @deprecated */

        setFlexMaterial(iMaterial:  number ): bool;
        setFlexMaterial(csName: string): bool;

        createSubset(sName: string, ePrimType: EPrimitiveTypes, eOptions?:  number );
        freeSubset(sName: string): bool;
        getSubset(sMesh: string): IMeshSubset;
        getSubset(i:  number ): IMeshSubset;
        appendSubset(sName: string, pData: IRenderData): IMeshSubset;

        setSkin(pSkin: ISkin): void;
        setSkeleton(pSkeleton: ISkeleton): void;
        createSkin(): ISkin;

        createBoundingBox(): bool;
        deleteBoundingBox(): bool;
        showBoundingBox(): bool;
        hideBoundingBox(): bool;
        isBoundingBoxVisible(): bool;
        createAndShowSubBoundingBox(): void;

        createBoundingSphere(): bool;
        deleteBoundingSphere(): bool;
        showBoundingSphere(): bool;
        hideBoundingSphere(): bool;
        isBoundingSphereVisible(): bool;
        createAndShowSubBoundingSphere(): void;

        isReadyForRender(): bool;


        toSceneModel(pParent: ISceneNode, sName?: string): ISceneModel;

/** Updtae all submeshes(apply bone matricie for skinned submeshes) */

        update(): bool;

        _drawSubset(iSubset:  number ): void;
        _draw(): void;

/** notify, when one of substets added or removed shadow */

         shadowed(pSubset: IMeshSubset, bShadow: bool): void;
	}
}











module akra {
    ;
    ;
    ;
    ;
    ;

	export enum ERenderDataBufferOptions {
        VB_READABLE       = < number >EHardwareBufferFlags.READABLE,
        RD_ADVANCED_INDEX = < number >ERenderDataOptions.ADVANCED_INDEX,
        RD_SINGLE_INDEX   = < number >ERenderDataOptions.SINGLE_INDEX,
        RD_RENDERABLE     = < number >ERenderDataOptions.RENDERABLE
    };

// export interface IRenderDataType {
//     new (): IRenderData;
// }

/*IHardwareBuffer*/
	export interface IRenderDataCollection extends                    IBuffer, IReferenceCounter {
		 buffer: IVertexBuffer;
         byteLength:  number ;
         length:  number ;

        getEngine(): IEngine;
        getOptions():  number ;

        getData(sUsage: string): IVertexData;
        getData(iOffset:  number ): IVertexData;
        getRenderData(iSubset:  number ): IRenderData;
        getEmptyRenderData(ePrimType: EPrimitiveTypes, eOptions?: ERenderDataBufferOptions): IRenderData;
        getDataLocation(sSemantics: string):  number ;

        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, isCommon?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, isCommon?: bool):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView, isCommon?: bool):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer, isCommon?: bool):  number ;

        destroy(): void;

        _draw(): void;
        _draw(iSubset:  number ): void;

// _setup(eOptions?: int): void;

        _allocateData(pVertexDecl: IVertexDeclaration, iSize:  number ): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBuffer): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], iSize:  number ): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer): IVertexData;
	}
}















module akra {
	;

	export interface IAnimationParameter {
		 totalFrames:  number ;
		 duration:  number ;
		 first:  number ;

/** Get keyframe by number */

		getKeyFrame(iFrame:  number ): IFrame;
/** Set keyframe */

		keyFrame(pFrame: IFrame): bool;
/** Find keyframe by time */

		findKeyFrame(fTime:  number ):  number ;
/** Calculate frame by time */

		frame(fTime:  number ): IFrame;
	}
}










module akra {
	;
	;
	;

//SLERP <==> slerp for rotation, MATRIX_LINEAR - linear between matrices

	export enum EAnimationInterpolations {
		LINEAR,
		SPHERICAL
	}

	export interface IFrame {
		type: EAnimationInterpolations;

		 time:  number ;
		 weight:  number ;

		reset(): IFrame;
		set(pFrame: IFrame): IFrame;
		add(pFrame: IFrame, isFirst: bool): IFrame;
		mult(fScalar:  number ): IFrame;
		normilize(): IFrame;

		interpolate(pStartFrame: IFrame, pEndFrame: IFrame, fBlend:  number ): IFrame;
	}
}



module akra {
	;
	;
	;

	export interface IPositionFrame extends IFrame {
		 rotation: IQuat4;
		 scale: IVec3;
		 translation: IVec3;

		toMatrix(): IMat4;
	}
}




module akra {
	;
	;

	export interface IAnimationTrack extends IAnimationParameter {
		targetName: string;

		 target: ISceneNode;

		keyFrame(pFrame: IPositionFrame): bool;
		keyFrame(fTime:  number , pMatrix: IMat4): bool;

		bind(sJoint: string, pSkeleton: ISkeleton);
		bind(pSkeleton: ISkeleton);
		bind(pNode: ISceneNode);
	}
}
















module akra {

	;
	;

	export enum  EEntityTypes {
		UNKNOWN,
		NODE,

		JOINT,

		SCENE_NODE,

		CAMERA,
		SHADOW_CASTER,

		MODEL_ENTRY,

		LIGHT = 37,

		SCENE_OBJECT = 64,

		MODEL,

		TERRAIN,
		TERRAIN_ROAM,
		TERRAIN_SECTION,
		TERRAIN_SECTION_ROAM,

		TEXT3D,
		SPRITE,
		EMITTER,

		UI_NODE = 100,
// UI_HTMLNODE,
// UI_DNDNODE,

// UI_COMPONENT,
// UI_BUTTON,
// UI_LABEL,
// UI_TREE,

		OBJECTS_LIMIT = 128
	}

	export interface IEntity extends IEventProvider, IReferenceCounter {
		name: string;

		parent: IEntity;
		sibling: IEntity;
		child: IEntity;

		 rightSibling: IEntity;

		 type: EEntityTypes;

		 depth:  number ;
		 root: IEntity;

//create(): bool;//moved to INode
		destroy(bRecursive?: bool, bPromoteChildren?: bool): void;

		findEntity(sName: string): IEntity;
		explore(fn: IExplorerFunc): void;
		childOf(pParent: IEntity): bool;
		siblingCount():  number ;
		childCount():  number ;
		children(): IEntity[];
		childAt(i:  number ): IEntity;
		descCount():  number ;

		update(): bool;
		recursiveUpdate(): bool;
		recursivePreUpdate(): void;
		prepareForUpdate(): void;

		hasParent(): bool;
		hasChild(): bool;
		hasSibling(): bool;

		isASibling(pSibling: IEntity): bool;
		isAChild(pChild: IEntity): bool;
		isInFamily(pEntity: IEntity, bSearchEntireTree?: bool): bool;

//обновлен ли сам узел
		isUpdated(): bool;
//есть ли обновления среди потомков?
		hasUpdatedSubNodes(): bool;


		addSibling(pSibling: IEntity): IEntity;
		addChild(pChild: IEntity): IEntity;
		removeChild(pChild: IEntity): IEntity;
		removeAllChildren(): void;

		attachToParent(pParent: IEntity): bool;
		detachFromParent(): bool;

		promoteChildren(): void;
		relocateChildren(pParent: IEntity): void;

		toString(isRecursive?: bool, iDepth?:  number ): string;

		 attached(): void;
		 detached(): void;

		 childAdded(pChild: IEntity): void;
		 childRemoved(pChild: IEntity): void;
	}

}



module akra {

	;
	;
	;
	;

	export enum ENodeInheritance {
		NONE,
//inheritance only position
		POSITION,
//inheritance rotation and scale only
        ROTSCALE,
//inheritance rotation ans position only
        ROTPOSITION,
//inheritance all
    	ALL
	};

	export interface INodeMap{
		[index: string]: INode;
	}

	export interface INode extends IEntity {
		localOrientation: IQuat4;
		localPosition: IVec3;
		localScale: IVec3;
		localMatrix: IMat4;

		 worldMatrix: IMat4;
		 worldPosition: IVec3;
		 worldOrientation: IQuat4;
		 worldScale: IVec3;

		 inverseWorldMatrix: IMat4;
		 normalMatrix: IMat3;

		parent: INode;
		sibling: INode;
		child: INode;

		create(): bool;

		setInheritance(eInheritance: ENodeInheritance);
		getInheritance(): ENodeInheritance;

		isWorldMatrixNew(): bool;
		isLocalMatrixNew(): bool;

		setWorldPosition(v3fPosition: IVec3): void;
		setWorldPosition(fX:  number , fY:  number , fZ:  number ): void;

		setPosition(v3fPosition: IVec3): void;
		setPosition(fX:  number , fY:  number , fZ:  number ): void;

		setRelPosition(v3fPosition: IVec3): void;
		setRelPosition(fX:  number , fY:  number , fZ:  number ): void;

		addPosition(v3fPosition: IVec3): void;
		addPosition(fX:  number , fY:  number , fZ:  number ): void;
		addRelPosition(v3fPosition: IVec3): void;
		addRelPosition(fX:  number , fY:  number , fZ:  number ): void;

		setRotationByMatrix(m3fRotation: IMat3): void;
		setRotationByMatrix(m4fRotation: IMat4): void;
		setRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		setRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		setRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		setRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		setRotation(q4fRotation: IQuat4): void;

		addRelRotationByMatrix(m4fRotation: IMat4): void;
		addRelRotationByMatrix(m3fRotation: IMat3): void;
		addRelRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		addRelRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		addRelRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		addRelRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		addRelRotation(q4fRotation: IQuat4): void;

		addRotationByMatrix(m4fRotation: IMat4): void;
		addRotationByMatrix(m3fRotation: IMat3): void;
		addRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		addRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		addRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		addRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		addRotation(q4fRotation: IQuat4): void;

		scale(fScale:  number ): void;
		scale(v3fScale: IVec3): void;
		scale(fX:  number , fY:  number , fZ:  number ): void;

		lookAt(v3fFrom: IVec3, v3fCenter: IVec3, v3fUp?: IVec3);
    	lookAt(v3fCenter: IVec3, v3fUp?: IVec3);
	}
}



module akra {
	;

    export interface ISceneNodeMap {
        [index: string]: ISceneNode;
    }

    export enum ESceneNodeFlags {
        FROZEN_PARENT,
        FROZEN_SELF,
        HIDDEN_PARENT,
        HIDDEN_SELF
    }

    export interface ISceneNode extends INode {
    	 scene: IScene3d;
    	 totalControllers:  number ;

    	getController(i?:  number ): IAnimationController;
    	addController(pController: IAnimationController): void;

        isFrozen(): bool;
        isSelfFrozen(): bool;
        isParentFrozen(): bool;
        freeze(value?: bool): void;

        isHidden(): bool;
        hide(value?: bool): void;

         frozen(value: bool): void;
         hidden(value: bool): void;
    }
}













module akra {
	;
	;

	export interface IJointMap{
		[index: string]: IJoint;
	}



	export interface ISkeleton {
		 totalBones:  number ;
		 totalNodes:  number ;
		 name: string;
		 root: IJoint;

		getRootJoint(): IJoint;
		getRootJoints(): IJoint[];
		getJointMap(): IJointMap;
		getNodeList(): ISceneNode[];
		addRootJoint(pJoint: IJoint): bool;
		update(): bool;
		findJoint(sName: string): IJoint;
		findJointByName(sName: string): IJoint;
		attachMesh(pMesh: IMesh): bool;
		detachMesh(): void;

	}
}















module akra {
	;

	export interface IJoint extends ISceneNode {
		boneName: string;
// getEngine(): IEngine;
		create(): bool;
// toString(isRecursive: bool, iDepth: int): string;
	}
}































module akra {

	;

	export interface IExplorerFunc {
		(pEntity: IEntity): bool;
	}
}







module akra.util {
	export enum EEntityStates {
//обновился ли сам узел?
		k_Updated = 0x01,
//есть ли среди потомков обновленные узлы
		k_DescendantsUpdtated = 0x02,
//если ли обновленные узлы среди братьев или их потомках
		k_SiblingsUpdated = 0x04
	}

	export class Entity extends ReferenceCounter implements IEntity {
		protected _sName: string = null;
		protected _pParent: IEntity = null;
		protected _pSibling: IEntity = null;
		protected _pChild: IEntity = null;
		protected _eType: EEntityTypes = EEntityTypes.UNKNOWN;
		protected _iStateFlags:  number  = 0;

		/**@inline*/  get name(): string { return this._sName; }
		/**@inline*/  set name(sName: string) { this._sName = sName; }

		/**@inline*/  get parent(): IEntity { return this._pParent; }
		/**@inline*/  set parent(pParent: IEntity) { this.attachToParent(pParent); }

		/**@inline*/  get sibling(): IEntity { return this._pSibling; }
		/**@inline*/  set sibling(pSibling: IEntity) { this._pSibling = pSibling; }

		/**@inline*/  get child(): IEntity { return this._pChild; }
		/**@inline*/  set child(pChild: IEntity) { this._pChild = pChild; }

		/**@inline*/  get type(): EEntityTypes { return this._eType; }

		get rightSibling(): IEntity {
			var pSibling: IEntity = this.sibling;

			if (pSibling) {
				while (pSibling.sibling) {
					pSibling = pSibling.sibling;
				}

				return pSibling;
			}

			return this;
		}

		constructor (eType: EEntityTypes) {
			super();
			this._eType = eType;
		}

		get depth():  number  {
			var iDepth:  number  = -1;
	        for (var pEntity: IEntity = this; pEntity; pEntity = pEntity.parent, ++ iDepth){};
	        return iDepth;
		}

		get root(): IEntity {
	        for (var pEntity: IEntity = this, iDepth:  number  = -1; pEntity.parent; pEntity = pEntity.parent, ++ iDepth){};
	        return pEntity;
		}



		destroy(bRecursive: bool = false, bPromoteChildren: bool = true): void {
			if (bRecursive) {
				if (this._pSibling) {
			        this._pSibling.destroy(true);
			    }

			    if (this._pChild) {
			        this._pChild.destroy(true);
			    }
			}

// destroy anything attached to this node
//	destroySceneObject();
// promote any children up to our parent
		    if (bPromoteChildren && !bRecursive) {
		    	this.promoteChildren();
		    }
// now remove ourselves from our parent
		    this.detachFromParent();
// we should now be removed from the tree, and have no dependants
		    { logger.setSourceLocation( "util/Entity.ts" , 93 ); logger.assert(this.referenceCount() == 0, "Attempting to delete a scene node which is still in use"); } ;
		    { logger.setSourceLocation( "util/Entity.ts" , 94 ); logger.assert(this._pSibling == null, "Failure Destroying Node"); } ;
		    { logger.setSourceLocation( "util/Entity.ts" , 95 ); logger.assert(this._pChild == null, "Failure Destroying Node"); } ;
		}

		findEntity(sName: string): IEntity {
			 var pEntity: IEntity = null;

		    if (this._sName === sName) {
		        return this;
		    }

		    if (this._pSibling) {
		        pEntity = this._pSibling.findEntity(sName);
		    }

		    if (pEntity == null && this._pChild) {
		        pEntity = this._pChild.findEntity(sName);
		    }

		    return pEntity;
		}

		explore(fn: IExplorerFunc): void {
			if (fn(this) === false) {
		        return;
		    }

		    if (this._pSibling) {
		        this._pSibling.explore(fn);
		    }

		    if (this._pChild) {
		        this._pChild.explore(fn);
		    }
		}


		childOf(pParent: IEntity): bool {
			for (var pEntity: IEntity = this; pEntity; pEntity = pEntity.parent) {
		        if (pEntity.parent === pParent) {
		            return true;
		        }
		    }

		    return false;
		}

		children(): IEntity[] {
			var pChildren: IEntity[] = [];
			var pChild: IEntity = this.child;

			while (!isNull(pChild)) {
				pChildren.push(pChild);
				pChild = pChild.sibling;
			}

			return pChildren;
		}

		childAt(i:  number ): IEntity {
			var pChild: IEntity = this.child;
			var n:  number  = 0;

			while (!isNull(pChild)) {
				if (n == i) {
					return pChild;
				}
				n ++;
				pChild = pChild.sibling;
			}

			return pChild;
		}

/**
		 * Returns the current number of siblings of this object.
		 */

		siblingCount():  number  {
			var iCount:  number  = 0;

		    if (this._pParent) {
		        var pNextSibling = this._pParent.child;
		        if (pNextSibling) {
		            while (pNextSibling) {
		                pNextSibling = pNextSibling.sibling;
		                ++ iCount;
		            }
		        }
		    }

		    return iCount;
		}


		descCount():  number  {
			var n:  number  = this.childCount();
			var pChild: IEntity = this.child;

			while(!isNull(pChild)) {
				n += pChild.descCount();
				pChild = pChild.sibling;
			}

			return n;
		}

/**
		 * Returns the current number of children of this object
		 */

		childCount():  number  {
			var iCount:  number  = 0;
			var pChild: IEntity = this.child;

			while(!isNull(pChild)) {
				iCount ++;
				pChild = pChild.sibling;
			}

// var pNextChild: IEntity = this.child;

// if (pNextChild) {
//     ++ iCount;
//     while (pNextChild) {
//         pNextChild = pNextChild.sibling;
//         ++ iCount;
//     }
// }
		    return iCount;
		}

		/**@inline*/  isUpdated(): bool {
			return  (((this._iStateFlags) & (EEntityStates.k_Updated)) == (EEntityStates.k_Updated)) ;
		}

		/**@inline*/  hasUpdatedSubNodes(): bool {
			return  (((this._iStateFlags) & (EEntityStates.k_DescendantsUpdtated)) == (EEntityStates.k_DescendantsUpdtated)) ;
		}

		recursiveUpdate(): bool {
// var bUpdated: bool = false;
// update myself
		    if (this.update()) {
		    	((this._iStateFlags) |= (EEntityStates.k_Updated)) ;
// bUpdated = true;
		    }
// update my sibling
		    if (this._pSibling && this._pSibling.recursiveUpdate()) {
		        ((this._iStateFlags) |= (EEntityStates.k_SiblingsUpdated)) ;
// bUpdated = true;
		    }
// update my child
		    if (this._pChild && this._pChild.recursiveUpdate()) {
		        ((this._iStateFlags) |= (EEntityStates.k_DescendantsUpdtated)) ;
// bUpdated = true;
		    }

/*bUpdated */
		    return (this._iStateFlags != 0);
		}

		recursivePreUpdate(): void {
// clear the flags from the previous update
		    this.prepareForUpdate();

// update my sibling
		    if (this._pSibling) {
		        this._pSibling.recursivePreUpdate();
		    }
// update my child
		    if (this._pChild) {
		        this._pChild.recursivePreUpdate();
		    }
		}


		prepareForUpdate(): void {
			this._iStateFlags = 0;
		};

/** Parent is not undef */

		/**@inline*/  hasParent(): bool {
		    return isDefAndNotNull(this._pParent);
		}

/** Child is not undef*/

		/**@inline*/  hasChild(): bool {
		    return isDefAndNotNull(this._pChild);
		}

/** Sibling is not undef */

		/**@inline*/  hasSibling(): bool {
			return isDefAndNotNull(this._pSibling);
		}

/**
		 * Checks to see if the provided item is a sibling of this object
		 */

		isASibling(pSibling: IEntity): bool {
			if (!pSibling) {
		        return false;
		    }
// if the sibling we are looking for is me, or my FirstSibling, return true
		    if (this == pSibling || this._pSibling == pSibling) {
		        return true;
		    }
// if we have a sibling, continue searching
		    if (this._pSibling) {
		        return this._pSibling.isASibling(pSibling);
		    }
// it's not us, and we have no sibling to check. This is not a sibling of ours.
		    return false;
		}

/** Checks to see if the provided item is a child of this object. (one branch depth only) */

		isAChild(pChild: IEntity): bool {
			if (!pChild) {
		        return (false);
		    }
// if the sibling we are looking for is my FirstChild return true
		    if (this._pChild == pChild) {
		        return (true);
		    }
// if we have a child, continue searching
		    if (this._pChild) {
		        return (this._pChild.isASibling(pChild));
		    }
// it's not us, and we have no child to check. This is not a sibling of ours.
		    return (false);
		}

/**
		 * Checks to see if the provided item is a child or sibling of this object. If SearchEntireTree
		 * is TRUE, the check is done recursivly through all siblings and children. SearchEntireTree
		 * is FALSE by default.
		 */

		isInFamily(pEntity: IEntity, bSearchEntireTree?: bool): bool {
			if (!pEntity) {
		        return (false);
		    }
// if the model we are looking for is me or my immediate family, return true
		    if (this == pEntity || this._pChild == pEntity || this._pSibling == pEntity) {
		        return (true);
		    }
// if not set to seach entire tree, just check my siblings and kids
		    if (!bSearchEntireTree) {
		        if (this.isASibling(pEntity)) {
		            return (true);
		        }
		        if (this._pChild && this._pChild.isASibling(pEntity)) {
		            return (true);
		        }
		    }
// seach entire Tree!!!
		    else {
		        if (this._pSibling && this._pSibling.isInFamily(pEntity, bSearchEntireTree)) {
		            return (true);
		        }

		        if (this._pChild && this._pChild.isInFamily(pEntity, bSearchEntireTree)) {
		            return (true);
		        }
		    }

		    return (false);
		}

/**
		 * Adds the provided ModelSpace object to the descendant list of this object. The provided
		 * ModelSpace object is removed from any parent it may already belong to.
		 */

		addSibling(pSibling: IEntity): IEntity {
			if (pSibling) {
// replace objects current sibling pointer with this new one
		        pSibling.sibling = this._pSibling;
		        this.sibling = pSibling;
		    }

		    return pSibling;
		}

/**
		 * Adds the provided ModelSpace object to the descendant list of this object. The provided
		 * ModelSpace object is removed from any parent it may already belong to.
		 */

		addChild(pChild: IEntity): IEntity {
			if (pChild) {
// Replace the new child's sibling pointer with our old first child.
		        pChild.sibling = this._pChild;
// the new child becomes our first child pointer.
		        this._pChild = pChild;
		        this.childAdded(pChild);
    		}

    		return pChild;
		}

/**
		 * Removes a specified child object from this parent object. If the child is not the
		 * FirstChild of this object, all of the Children are searched to find the object to remove.
		 */

		removeChild(pChild: IEntity): IEntity {
			if (this._pChild && pChild) {
		        if (this._pChild == pChild) {
		            this._pChild = pChild.sibling;
		            pChild.sibling  = null;
		        }
		        else {
		            var pTempNode: IEntity = this._pChild;
// keep searching until we find the node who's sibling is our target
// or we reach the end of the sibling chain
		            while (pTempNode && (pTempNode.sibling != pChild)) {
		                pTempNode = pTempNode.sibling;
		            }
// if we found the proper item, set it's FirstSibling to be the FirstSibling of the child
// we are removing
		            if (pTempNode) {
		                pTempNode.sibling = pChild.sibling;
		                pChild.sibling = null;
		            }
		        }

		        this.childRemoved(pChild);
	    	}

	    	return pChild;
		}

/** Removes all Children from this parent object */

		removeAllChildren(): void {
// keep removing children until end of chain is reached
		    while (!isNull(this._pChild)) {
		        var pNextSibling = this._pChild.sibling;
		        this._pChild.detachFromParent();
		        this._pChild = pNextSibling;
		    }
		}

/** Attaches this object ot a new parent. Same as calling the parent's addChild() routine. */

		attachToParent(pParent: IEntity): bool {

			var pParentPrev: IEntity = this.parent;

			if (pParent != this._pParent) {

		        this.detachFromParent();

		        if (pParent) {
		            if (pParent.addChild(this)) {
			            this._pParent = pParent;
			            this._pParent.addRef();
			            this.attached();
		            	return true;
		            }

		            return this.attachToParent(pParentPrev);
		        }
	    	}

	    	return false;
		}

		detachFromParent(): bool {
// tell our current parent to release us
		    if (this._pParent) {
		        this._pParent.removeChild(this);
//TODO: разобраться что за херня!!!!
		        if (this._pParent) {
		            this._pParent.release();
		        }

		        this._pParent = null;
// my world matrix is now my local matrix
		        this.detached();
		        return true;
		    }

		    return false;
		}

/**
		 * Attaches this object's children to it's parent, promoting them up the tree
		 */

		promoteChildren(): void {
// Do I have any children to promote?
		    while (!isNull(this._pChild)) {
		        var pNextSibling: IEntity = this._pChild.sibling;
		        this._pChild.attachToParent(this._pParent);
		        this._pChild = pNextSibling;
		    }
		}

		relocateChildren(pParent: IEntity): void {
			if (pParent != this) {
// Do I have any children to relocate?
		        while (!isNull(this._pChild)) {
		            var pNextSibling: IEntity = this._pChild.sibling;
		            this._pChild.attachToParent(pParent);
		            this._pChild = pNextSibling;
		        }
		    }
		}

		update(): bool { return false; }

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {

		    if (!isRecursive) {
		        return '<entity' + (this._sName? ' ' + this._sName: "") + '>';
		    }

// var pSibling: IEntity = this.sibling;
		    var pChild: IEntity = this.child;
		    var s: string = "";

		    for (var i = 0; i < iDepth; ++ i) {
		        s += ':  ';
		    }

		    s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';

		    if (pChild) {
		        s += pChild.toString(true, iDepth + 1);
		    }

// if (pSibling) {
//     s += pSibling.toString(true, iDepth);
// }

		    return s;


		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Entity._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;

		attached (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).attached; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
		detached (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).detached; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
		childAdded (child): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).childAdded; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier, child) : _unicast.listener (_recivier, child) ; } } ; ;
		childRemoved (child): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).childRemoved; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier, child) : _unicast.listener (_recivier, child) ; } } ; ;
	}
}






module akra.scene {

	export enum ENodeUpdateFlags {
		k_SetForDestruction = 0,
//if changed scale, otation or position
		k_NewOrientation,
// k_NewTranslation,
// k_NewScale,
		k_NewWorldMatrix,
		k_NewLocalMatrix,
		k_RebuildInverseWorldMatrix,
		k_RebuildNormalMatrix,
     };

	export class Node extends util.Entity implements INode {
		protected _m4fLocalMatrix: IMat4 = null;
		protected _m4fWorldMatrix: IMat4 = null;
		protected _m4fInverseWorldMatrix: IMat4 = null;
		protected _m3fNormalMatrix: IMat3 = null;

		protected _v3fWorldPosition: IVec3 = null;

		protected _qRotation: IQuat4 = null;
		protected _v3fTranslation: IVec3 = null;
		protected _v3fScale: IVec3 = null;

		protected _iUpdateFlags:  number  = 0;
		protected _eInheritance: ENodeInheritance = ENodeInheritance.POSITION;

		create(): bool {
			return true;
		}


		/**@inline*/  get localOrientation(): IQuat4 {
			return this._qRotation;
		}

		/**@inline*/  set localOrientation(qOrient: IQuat4) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._qRotation.set(qOrient);
		}

		/**@inline*/  get localPosition(): IVec3 {
			return this._v3fTranslation;
		}

		/**@inline*/  set localPosition(v3fPosition: IVec3) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._v3fTranslation.set(v3fPosition);
		}

		/**@inline*/  get localScale(): IVec3 {
			return this._v3fScale;
		}

		/**@inline*/  set localScale(v3fScale: IVec3) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._v3fScale.set(v3fScale);
		}

		/**@inline*/  get localMatrix(): IMat4 {
			return this._m4fLocalMatrix;
		}

		/**@inline*/  set localMatrix(m4fLocalMatrix: IMat4) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewLocalMatrix))) ) ;
			this._m4fLocalMatrix.set(m4fLocalMatrix);
		}


		/**@inline*/  get worldMatrix(): IMat4 {
			return this._m4fWorldMatrix;
		}

		/**@inline*/  get worldPosition(): IVec3 {
			return this._v3fWorldPosition;
		}

		/**@inline*/  get worldOrientation(): IQuat4 {
//TODO: calc right world orient.
			return null;
		}

		/**@inline*/  get worldScale(): IVec3 {
//TODO: calc right world scale.
			return this.localScale;
		}

		/**@inline*/  get parent(): INode { return <INode>this._pParent; }
		/**@inline*/  set parent(pParent: INode) { this.attachToParent(pParent); }

		/**@inline*/  get sibling(): INode { return <INode>this._pSibling; }
		/**@inline*/  set sibling(pSibling: INode) { this._pSibling = pSibling; }

		/**@inline*/  get child(): INode { return <INode>this._pChild; }
		/**@inline*/  set child(pChild: INode) { this._pChild = pChild; }

// inline get worldRotation(): IQuat4 {
// 	ASSERT((<Node>this._pParent).worldMatrix.toMat3(Node._m3fTemp1).decompose(Node._q4fTemp1, Node._v3fTemp1), 
//             		"could not decompose.");
// 	//FIXME: use correct way to get world rotation
// 	return Node._q4fTemp1;
// }

		get inverseWorldMatrix(): IMat4 {
			if ( ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_RebuildInverseWorldMatrix)) ) != 0) ) {
		        this._m4fWorldMatrix.inverse(this._m4fInverseWorldMatrix);
		        ((this._iUpdateFlags) &= ~ (1 << ((ENodeUpdateFlags.k_RebuildInverseWorldMatrix))) ) ;
		    }

			return this._m4fInverseWorldMatrix;
		}

		get normalMatrix(): IMat3 {
			if ( ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_RebuildNormalMatrix)) ) != 0) ) {

		        this._m4fWorldMatrix.toMat3(this._m3fNormalMatrix).inverse().transpose();

		        ((this._iUpdateFlags) &= ~ (1 << ((ENodeUpdateFlags.k_RebuildNormalMatrix))) ) ;
		    }

			return this._m3fNormalMatrix;
		}


		update(): bool {
// derived classes update the local matrix
// then call this base function to complete
// the update
		    return this.recalcWorldMatrix();
		}


		prepareForUpdate(): void {
			super.prepareForUpdate();
// clear the temporary flags
			((this._iUpdateFlags) &= ~( (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) | (1 << (ENodeUpdateFlags.k_NewOrientation)) | (1 << (ENodeUpdateFlags.k_NewWorldMatrix)) ))
                                                                                            ;
		}


		/**@inline*/  setInheritance(eInheritance: ENodeInheritance) {
			this._eInheritance = eInheritance;
		}

		/**@inline*/  getInheritance(): ENodeInheritance {
			return this._eInheritance;
		}

		/**@inline*/  isWorldMatrixNew(): bool {
			return  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewWorldMatrix)) ) != 0) ;
		}

		/**@inline*/  isLocalMatrixNew(): bool {
			return  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) ) != 0) ;
		}

		private recalcWorldMatrix(): bool {
			var isParentMoved: bool = this._pParent && (<Node>this._pParent).isWorldMatrixNew();
		    var isOrientModified: bool =  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewOrientation)) ) != 0) ;
		    var isLocalModified: bool =  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) ) != 0) ;

		    if (isOrientModified || isParentMoved || isLocalModified) {
		        var m4fLocal: IMat4 = this._m4fLocalMatrix;
		        var m4fWorld: IMat4 = this._m4fWorldMatrix;

		        var m4fOrient: IMat4 = Node._m4fTemp1;
		        var v3fTemp: IVec3 = Node._v3fTemp1;

		        var pWorldData: Float32Array = m4fWorld.data;
		        var pOrientData: Float32Array = m4fOrient.data;

		        this._qRotation.toMat4(m4fOrient);

		        m4fOrient.setTranslation(this._v3fTranslation);
		        m4fOrient.scaleRight(this._v3fScale);
		        m4fOrient.multiply(m4fLocal);

//console.error(m4fOrient.toString());

		        if (this._pParent && this._eInheritance !== ENodeInheritance.NONE) {
		        	var m4fParent: IMat4 = (<Node>this._pParent).worldMatrix;
					var pParentData: Float32Array = m4fParent.data;

					if (this._eInheritance === ENodeInheritance.ALL) {
		                m4fParent.multiply(m4fOrient, m4fWorld);
		            }
		            else if (this._eInheritance === ENodeInheritance.POSITION) {
		                m4fWorld.set(m4fOrient);

		                pWorldData[ 12 ] = pParentData[ 12 ] + pOrientData[ 12 ];
		                pWorldData[ 13 ] = pParentData[ 13 ] + pOrientData[ 13 ];
		                pWorldData[ 14 ] = pParentData[ 14 ] + pOrientData[ 14 ];
		            }
		            else if (this._eInheritance === ENodeInheritance.ROTPOSITION) {
//FIXME: add faster way to compute this inheritance...
		            	{ logger.setSourceLocation( "scene/Node.ts" , 206 ); logger.assert(m4fParent.toMat3(Node._m3fTemp1).decompose(Node._q4fTemp1, Node._v3fTemp1), "could not decompose."); }
                                       ;

		            	var m4fParentNoScale: IMat4 = Node._q4fTemp1.toMat4(Node._m4fTemp2);

		            	m4fParentNoScale.data[ 12 ] = pParentData[ 12 ];
		            	m4fParentNoScale.data[ 13 ] = pParentData[ 13 ];
		            	m4fParentNoScale.data[ 14 ] = pParentData[ 14 ];

		            	m4fParentNoScale.multiply(m4fOrient, m4fWorld);
		            }
		            else if (this._eInheritance === ENodeInheritance.ROTSCALE) {
//3x3 parent world matrix
		                var p11 = pParentData[ 0 ], p12 = pParentData[ 4 ],
		                    p13 = pParentData[ 8 ];
		                var p21 = pParentData[ 1 ], p22 = pParentData[ 5 ],
		                    p23 = pParentData[ 9 ];
		                var p31 = pParentData[ 2 ], p32 = pParentData[ 6 ],
		                    p33 = pParentData[ 10 ];

//3x3 local matrix
		                var l11 = pOrientData[ 0 ], l12 = pOrientData[ 4 ],
		                    l13 = pOrientData[ 8 ];
		                var l21 = pOrientData[ 1 ], l22 = pOrientData[ 5 ],
		                    l23 = pOrientData[ 9 ];
		                var l31 = pOrientData[ 2 ], l32 = pOrientData[ 6 ],
		                    l33 = pOrientData[ 10 ];

//parent x local with local world pos.
		                pWorldData[ 0 ] = p11 * l11 + p12 * l21 + p13 * l31;
		                pWorldData[ 4 ] = p11 * l12 + p12 * l22 + p13 * l32;
		                pWorldData[ 8 ] = p11 * l13 + p12 * l23 + p13 * l33;
		                pWorldData[ 12 ] = pOrientData[ 12 ];
		                pWorldData[ 1 ] = p21 * l11 + p22 * l21 + p23 * l31;
		                pWorldData[ 5 ] = p21 * l12 + p22 * l22 + p23 * l32;
		                pWorldData[ 9 ] = p21 * l13 + p22 * l23 + p23 * l33;
		                pWorldData[ 13 ] = pOrientData[ 13 ];
		                pWorldData[ 2 ] = p31 * l11 + p32 * l21 + p33 * l31;
		                pWorldData[ 6 ] = p31 * l12 + p32 * l22 + p33 * l32;
		                pWorldData[ 10 ] = p31 * l13 + p32 * l23 + p33 * l33;
		                pWorldData[ 14 ] = pOrientData[ 14 ];

		                pWorldData[ 3 ] = pOrientData[ 3 ];
		                pWorldData[ 7 ] = pOrientData[ 7 ];
		                pWorldData[ 11 ] = pOrientData[ 11 ];
		                pWorldData[ 15 ] = pOrientData[ 15 ];
		            }
		        }
		        else {
		            m4fWorld.set(m4fOrient);
		        }

		        this._v3fWorldPosition.x = pWorldData[ 12 ];
		        this._v3fWorldPosition.y = pWorldData[ 13 ];
		        this._v3fWorldPosition.z = pWorldData[ 14 ];

// set the flag that our world matrix has changed
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewWorldMatrix))) ) ;
// and it's inverse & vectors are out of date
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_RebuildInverseWorldMatrix))) ) ;
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_RebuildNormalMatrix))) ) ;

		        return true;
		    }

		    return false;
		}


		setWorldPosition(v3fPosition: IVec3): void;
		setWorldPosition(fX:  number , fY:  number , fZ:  number ): void;
		setWorldPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]:  Vec3.stackCeil.set(fX, fY, fZ) ;

//target world matrix
			var Au: IMat4 =  Mat4.stackCeil.set(1.) ;
			Au.setTranslation(pPos);

//original translation matrices of this node
			var A0: IMat4 =  Mat4.stackCeil.set(1.) ;
			A0.setTranslation(this.worldPosition);

//inversed A0
			var A0inv: IMat4 = A0.inverse( Mat4.stackCeil.set() );
//transformation matrix A0 to Au
			var C: IMat4 = Au.multiply(A0inv,  Mat4.stackCeil.set() );

//parent world matrix
			var Mp: IMat4 = isNull(this.parent)?  Mat4.stackCeil.set(1.) :  Mat4.stackCeil.set(this.parent.worldMatrix) ;
//this orientation matrix (orientation + sclae + translation)
			var Mo: IMat4 =  Mat4.stackCeil.set() ;

//assemble local orientaion matrix
			this.localOrientation.toMat4(Mo);
	        Mo.setTranslation(this.localPosition);
	        Mo.scaleRight(this.localScale);

//this local matrix
			var Ml: IMat4 =  Mat4.stackCeil.set(this.localMatrix) ;

//inversed parent world matrix
			var Mpinv: IMat4 = Mp.inverse( Mat4.stackCeil.set() );
//inversed this orientation matrix
			var Moinv: IMat4 = Mo.inverse( Mat4.stackCeil.set() );

//transformation matrix Ml to Mlc
			var Cc: IMat4 = Moinv.multiply(Mpinv,  Mat4.stackCeil.set() ).multiply(C).multiply(Mp).multiply(Mo);
//modified local matrix, that translate node to pPos world position
			var Mlc: IMat4 = Cc.multiply(Ml,  Mat4.stackCeil.set() );

			this._m4fLocalMatrix.setTranslation(Mlc.getTranslation());

			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewLocalMatrix))) ) ;
		}


		setPosition(v3fPosition: IVec3): void;
		setPosition(fX:  number , fY:  number , fZ:  number ): void;
		setPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]:  Vec3.stackCeil.set(fX, fY, fZ) ;
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    v3fTranslation.set(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRelPosition(v3fPosition: IVec3): void;
		setRelPosition(fX:  number , fY:  number , fZ:  number ): void;
		setRelPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]:  Vec3.stackCeil.set(fX, fY, fZ) ;
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    this._qRotation.multiplyVec3(pPos);
    		v3fTranslation.set(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addPosition(v3fPosition: IVec3): void;
		addPosition(fX:  number , fY:  number , fZ:  number ): void;
		addPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]:  Vec3.stackCeil.set(fX, fY, fZ) ;
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    v3fTranslation.add(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addRelPosition(v3fPosition: IVec3): void;
		addRelPosition(fX:  number , fY:  number , fZ:  number ): void;
		addRelPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]:  Vec3.stackCeil.set(fX, fY, fZ) ;
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    this._qRotation.multiplyVec3(pPos);
    		v3fTranslation.add(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByMatrix(m3fRotation: IMat3): void;
		setRotationByMatrix(m4fRotation: IMat4): void;
		setRotationByMatrix(matrix: any): void {
			matrix.toQuat4(this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			Quat4.fromAxisAngle(v3fAxis, fAngle, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			Quat4.fromForwardUp(v3fForward, v3fUp, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			Quat4.fromYawPitchRoll(fY, fX, fZ, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotation(q4fRotation: IQuat4): void {
			this._qRotation.set(q4fRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addRelRotationByMatrix(m3fRotation: IMat3): void;
		addRelRotationByMatrix(m4fRotation: IMat4): void;
		addRelRotationByMatrix(matrix: any): void {
			this.addRelRotation(arguments[0].toQuat4(Node._q4fTemp1));
		}

		/**@inline*/  addRelRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			this.addRelRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp1));
		}

		/**@inline*/  addRelRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			this.addRelRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp1));
		}

		/**@inline*/  addRelRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			this.addRelRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp1));
		}

		/**@inline*/  addRelRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			this.addRelRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp1));
		}

		addRelRotation(q4fRotation: IQuat4): void {
			this._qRotation.multiply(q4fRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		/**@inline*/  addRotationByMatrix(m3fRotation: IMat3): void;
		/**@inline*/  addRotationByMatrix(m4fRotation: IMat4): void;
		/**@inline*/  addRotationByMatrix(matrix: any): void {
			this.addRotation(arguments[0].toQuat4(Node._q4fTemp1));
		}

		/**@inline*/  addRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			this.addRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp1));
		}

		/**@inline*/  addRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			this.addRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp1));
		}

		/**@inline*/  addRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			this.addRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp1));
		}

		/**@inline*/  addRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			this.addRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp1));
		}

		addRotation(q4fRotation: IQuat4): void {
			q4fRotation.multiplyVec3(this._v3fTranslation);
    		q4fRotation.multiply(this._qRotation, this._qRotation);
    		((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}


		scale(fScale:  number ): void;
		scale(v3fScale: IVec3): void;
		scale(fX:  number , fY:  number , fZ:  number ): void;
		scale(fX: any, fY?: any, fZ?: any): void {
			var pScale: IVec3 = arguments.length === 1? (isNumber(arguments[0])?  Vec3.stackCeil.set(fX) : arguments[0]):  Vec3.stackCeil.set(fX, fY, fZ) ;
		    var v3fScale: IVec3 = this._v3fScale;

		    v3fScale.scale(pScale);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		lookAt(v3fFrom: IVec3, v3fCenter: IVec3, v3fUp?: IVec3): void;
    	lookAt(v3fCenter: IVec3, v3fUp?: IVec3): void;
    	lookAt(v3f?): void {
    		var v3fFrom: IVec3, v3fCenter: IVec3, v3fUp: IVec3;

    		this.update();

		    if (arguments.length < 3) {
		        v3fFrom = this.worldPosition;
		        v3fCenter = <IVec3>arguments[0];
		        v3fUp = <IVec3>arguments[1];
		    }
		    else {
		        v3fFrom = <IVec3>arguments[0];
		        v3fCenter = <IVec3>arguments[1];
		        v3fUp = <IVec3>arguments[2];
		    }

		    v3fUp = v3fUp ||  Vec3.stackCeil.set(0., 1., 0.) ;

		    var v3fParentPos: IVec3 = (<Node>this.parent).worldPosition;
		    var m4fTemp: IMat4 = Mat4.lookAt(v3fFrom, v3fCenter, v3fUp,  Mat4.stackCeil.set() ).inverse();
		    var pData: Float32Array = m4fTemp.data;

		    switch (this._eInheritance) {
		        case ENodeInheritance.ALL :
		            (<Node>this._pParent).inverseWorldMatrix.multiply(m4fTemp, m4fTemp);
		            m4fTemp.toQuat4(this._qRotation);
		            this.setPosition(pData[ 12 ], pData[ 13 ], pData[ 14 ]);
		            break;
		        case ENodeInheritance.ROTSCALE :
		            var m3fTemp = m4fTemp.toMat3();
		            m3fTemp = (<Node>this._pParent).inverseWorldMatrix.toMat3().multiply(m3fTemp,  Mat3.stackCeil.set() );
		            m3fTemp.toQuat4(this._qRotation);
		            this.setPosition(pData[ 12 ], pData[ 13 ], pData[ 14 ]);
		            break;
		        default :
		            m4fTemp.toQuat4(this._qRotation);
		            this.setPosition(
		            	pData[ 12 ] - v3fParentPos.x,
		            	pData[ 13 ] - v3fParentPos.y,
		                pData[ 14 ] - v3fParentPos.z);
		    }

		    this.update();
    	}



		attachToParent(pParent: IEntity): bool {
			if (super.attachToParent(pParent)) {
// adjust my local matrix to be relative to this new parent
	            var m4fInvertedParentMatrix: IMat4 =  Mat4.stackCeil.set() ;
	            (<Node>this._pParent)._m4fWorldMatrix.inverse(m4fInvertedParentMatrix);
	            ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewWorldMatrix))) ) ;

	            return true;
			}

			return false;
		}

		detachFromParent(): bool {
			if (super.detachFromParent()) {
				this._m4fWorldMatrix.identity();
				return true;
			}

			return false;
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {


		    if (!isRecursive) {
		        return '<node' + (this.name? " " + this.name: "") + '>';
		    }

// var pSibling: IEntity = this.sibling;
		    var pChild: IEntity = this.child;
		    var s = "";

		    for (var i = 0; i < iDepth; ++ i) {
		        s += ':  ';
		    }

		    s += '+----[depth: ' + this.depth + ']' + this.toString() +  '\n';
/*"[updated: " + this.isUpdated() + ", childs updated: " + this.hasUpdatedSubNodes() + ", new wm: " + this.isWorldMatrixNew() + "]" +*/

		    while (pChild) {
		        s += pChild.toString(true, iDepth + 1);
		        pChild = pChild.sibling;
		    }

// if (pSibling) {
// s += pSibling.toString(true, iDepth);
// }
// 
		    return s;

		};

		private static _v3fTemp1: IVec3 = new Vec3();
		private static _v4fTemp1: IVec4 = new Vec4();
		private static _m3fTemp1: IMat3 = new Mat3();
		private static _m4fTemp1: IMat4 = new Mat4();
		private static _m4fTemp2: IMat4 = new Mat4();
		private static _q4fTemp1: IQuat4 = new Quat4();
	}
}










module akra {
	;
	;
	;

	export interface IAnimationController extends IEventProvider {
		name: string;

		 totalAnimations:  number ;
		 active: IAnimationBase;
		 target: ISceneNode;

		getEngine(): IEngine;

		setOptions(eOptions): void;
		addAnimation(pAnimation: IAnimationBase): bool;

		removeAnimation(pAnimation: string): bool;
		removeAnimation(pAnimation:  number ): bool;
		removeAnimation(pAnimation: IAnimationBase): bool;

		findAnimation(pAnimation: string): IAnimationBase;
		findAnimation(pAnimation:  number ): IAnimationBase;
		findAnimation(pAnimation: IAnimationBase): IAnimationBase;

		getAnimation(iAnim:  number ): IAnimationBase;

		setAnimation(iAnimation:  number , pAnimation: IAnimationBase): void;
		attach(pTarget: ISceneNode): void;

		 play(pAnimation: string): bool;
		 play(pAnimation:  number ): bool;
		 play(pAnimation: IAnimationBase): bool;

		 animationAdded(pAnimation: IAnimationBase): void;

		stop(): void;

		update(): void;

		toString(bFullInfo?: bool);
	}
}



module akra.scene {
	export class SceneNode extends Node implements ISceneNode {
		protected _pScene: IScene3d = null;
		protected _pAnimationControllers: IAnimationController[] = null;
		protected _iSceneNodeFlags:  number  = 0;

		/**@inline*/  get scene(): IScene3d { return this._pScene; }
		/**@inline*/  set scene(pScene: IScene3d) { this._pScene = pScene; }

		/**@inline*/  get totalControllers():  number  { return this._pAnimationControllers? this._pAnimationControllers.length: 0; }

		constructor (pScene: IScene3d, eType: EEntityTypes = EEntityTypes.SCENE_NODE) {
			super(eType);

			this.scene = pScene;
		}

		/**@inline*/  getController(i:  number  = 0): IAnimationController {
			return isNull(this._pAnimationControllers) || this._pAnimationControllers.length <= i?
				null: this._pAnimationControllers[i];
		}

		/**@inline*/  addController(pController: IAnimationController): void {
			if (isNull(this._pAnimationControllers)) {
				this._pAnimationControllers = [];
			}

			if (this._pAnimationControllers.indexOf(pController) != -1) {
				return;
			}

			pController.attach(this);
			this._pAnimationControllers.push(pController);
		}


    	/**@inline*/  isFrozen(): bool {
    		return  (((this._iSceneNodeFlags) & (( (1 << (ESceneNodeFlags.FROZEN_SELF)) | (1 << (ESceneNodeFlags.FROZEN_PARENT)) ))) != 0)
                                                                                 ;
    	}

    	/**@inline*/  isSelfFrozen(): bool {
    		return  ((this._iSceneNodeFlags & (1 << (ESceneNodeFlags.FROZEN_SELF)) ) != 0) ;
    	}

    	/**@inline*/  isParentFrozen(): bool {
    		return  ((this._iSceneNodeFlags & (1 << (ESceneNodeFlags.FROZEN_PARENT)) ) != 0) ;
    	}

    	freeze(bValue: bool = true): void {
    		(bValue ? ((this._iSceneNodeFlags) |= (1 << ((ESceneNodeFlags.FROZEN_SELF))) ) : ((this._iSceneNodeFlags) &= ~ (1 << ((ESceneNodeFlags.FROZEN_SELF))) ) ) ;
    		this.frozen(bValue);
    	}

    	/**@inline*/  isHidden(): bool {
    		return  (((this._iSceneNodeFlags) & (( (1 << (ESceneNodeFlags.HIDDEN_SELF)) | (1 << (ESceneNodeFlags.HIDDEN_PARENT)) ))) != 0)
                                                                                 ;
    	}

    	hide(bValue: bool = true): void {
    		(bValue ? ((this._iSceneNodeFlags) |= (1 << ((ESceneNodeFlags.HIDDEN_SELF))) ) : ((this._iSceneNodeFlags) &= ~ (1 << ((ESceneNodeFlags.HIDDEN_SELF))) ) ) ;
    		this.hidden(bValue);
    	}

    	_parentFrozen(pParent: ISceneNode, bValue: bool): void {
    		(bValue ? ((this._iSceneNodeFlags) |= (1 << ((ESceneNodeFlags.FROZEN_PARENT))) ) : ((this._iSceneNodeFlags) &= ~ (1 << ((ESceneNodeFlags.FROZEN_PARENT))) ) ) ;
    	}

    	_parentHidden(pParent: ISceneNode, bValue: bool): void {
    		(bValue ? ((this._iSceneNodeFlags) |= (1 << ((ESceneNodeFlags.HIDDEN_PARENT))) ) : ((this._iSceneNodeFlags) &= ~ (1 << ((ESceneNodeFlags.HIDDEN_PARENT))) ) ) ;
    	}

		create(): bool {
			super.create();

			this._m4fLocalMatrix        = new Mat4(1);
		    this._m4fWorldMatrix        = new Mat4(1);
		    this._m4fInverseWorldMatrix = new Mat4(1);
		    this._m3fNormalMatrix       = new Mat3(1);

		    this._v3fWorldPosition  = new Vec3();

		    this._v3fTranslation    = new Vec3(0);
		    this._v3fScale          = new Vec3(1);
		    this._qRotation         = new Quat4(0, 1);

		    return true;
		}


		update(): bool {
			var isOk = super.update();

			if (!isNull(this._pAnimationControllers)) {
				for (var i:  number  = 0; i < this._pAnimationControllers.length; ++ i) {
					this._pAnimationControllers[i].update();
				}
			}

			return isOk;
		}

		destroy(): void {
			super.destroy();
		}

		attachToParent(pParent: IEntity): bool {
			if ((<ISceneNode>pParent).scene !== this._pScene) {
				{ logger.setSourceLocation( "SceneNode.ts" , 119 ); logger.warning("transfer of the scene node between trees scene - forbidden"); } ;
				return false;
			}

			if (super.attachToParent(pParent)) {
				if (!isNull(this.parent)) {
					this.connect(this.parent,  "frozen" ,  "_parentFrozen" );
					this.connect(this.parent,  "hidden" ,  "_parentHidden" );
				}
				return true;
			}

			return false;
		}

		detachFromParent(): bool {
			if (super.detachFromParent()) {
				if (!isNull(this.parent)) {
					this.disconnect(this.parent,  "frozen" ,  "_parentFrozen" );
					this.disconnect(this.parent,  "hidden" ,  "_parentHidden" );
				}
				return true;
			}

			return false;
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {
			if (!isRecursive) {
/* + " height: " + this.worldPosition.y*/
		        return "<scene_node" + (this.name? " " + this.name: "") + ">"                                         ;
		    }

		    return super.toString(isRecursive, iDepth);
		}

		frozen (value): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).frozen; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, value) : _broadcast[i].listener (_recivier, value) ; } } } ; ;
		hidden (value): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).hidden; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, value) : _broadcast[i].listener (_recivier, value) ; } } } ; ;

	}
}



module akra.scene {
	export class Joint extends SceneNode implements IJoint {
		private _sBone: string = null;
// private _iUpdated: int = 0;
// private _pEngine: IEngine = null;

		constructor (pScene: IScene3d) {
			super(pScene, EEntityTypes.JOINT);
		}

		/**@inline*/  get boneName(): string{
			return this._sBone;
		}

		/**@inline*/  set boneName(sBone: string) {
			this._sBone = sBone;
		}

// getEngine(): IEngine {
// 	return this._pEngine;
// }

		create(): bool {
			this._m4fLocalMatrix = new Mat4(1);
			this._m4fWorldMatrix = new Mat4(1);

			this._v3fWorldPosition  = new Vec3();
			this._v3fTranslation    = new Vec3(0, 0, 0);
			this._v3fScale          = new Vec3(1);
			this._qRotation         = new Quat4(0, 1);


//maybe custom
			this.setInheritance(ENodeInheritance.ALL);
			return true;
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {
			isRecursive = isRecursive || false;

			if (!isRecursive) {
/* + " height: " + this.worldPosition.y*/
			    return "<joint" + (this._sName ? (' ' + this._sName) : "") + ">"                                         ;
			}

			return Node.prototype.toString.call(this, isRecursive, iDepth);
		}
	}

	export  /**@inline*/  function isJoint(pEntity: IEntity): bool {
		return pEntity.type == EEntityTypes.JOINT;
	}
}



module akra.model {

	class Skeleton implements ISkeleton{
		private _sName: string;
		private _pRootJoints: IJoint[] = [];
		private _pJointMap: IJointMap = null;
		private _pNodeList: ISceneNode[]  = null;
		private _pMeshNode: ISceneModel = null;
// private _iFlags: bool = false;


		/**@inline*/  get totalBones():  number {
			return Object.keys(this._pJointMap).length;
		}

		/**@inline*/  get totalNodes():  number {
			return this._pNodeList.length;
		}

		/**@inline*/  get name(): string{
			return this._sName;
		}

		/**@inline*/  get root(): IJoint {
			return this._pRootJoints[0] || null;
		}

		constructor (sName: string = null) {
			this._sName = sName;
		}

		/**@inline*/  getRootJoint(): IJoint {
			return this.getRootJoints()[0];
		}

		/**@inline*/  getRootJoints(): IJoint[] {
			return this._pRootJoints;
		}

		/**@inline*/  getJointMap(): IJointMap {
			return this._pJointMap;
		}

		/**@inline*/  getNodeList(): ISceneNode[] {
			return this._pNodeList;
		}

		addRootJoint(pJoint: IJoint): bool {
			{ logger.setSourceLocation( "model/Skeleton.ts" , 56 ); logger.assert(pJoint instanceof scene.Joint, 'node must be joint'); } ;

		    var pRootJoints = this._pRootJoints;

			for (var i = 0; i < pRootJoints.length; i++) {
				if (pJoint.childOf(pRootJoints[i])) {
					return false;
				}
				else if (pRootJoints[i].childOf(pJoint)) {
					pRootJoints.splice(i, 1);
				}
			};

			this._pRootJoints.push(pJoint);

			return this.update();
		}

		update(): bool {
			var pRootJoints: IJoint[] 	= this.getRootJoints();
		    var pJointMap: IJointMap 	= this._pJointMap = <IJointMap>{};
		    var pNodeList: ISceneNode[] = this._pNodeList = [];
//var pNotificationJoints = this._pNotificationJoints = [];

		    function findNodes (pNode: ISceneNode): void {
		    	var sJoint: string = null;

		    	if (!isNull(pNode)) {
		    		if (scene.isJoint(pNode)) {
			    		sJoint = (<IJoint>pNode).boneName;
			    	}

			    	if (!isNull(sJoint)) {
			    		{ logger.setSourceLocation( "model/Skeleton.ts" , 90 ); logger.assert(!pJointMap[sJoint], 'joint with name<' + sJoint + '> already exists in skeleton <' + this._sName + '>'); }
                                                                                             ;

			    		pJointMap[sJoint] = <IJoint>pNode;
			    	}

			    	pNodeList.push(pNode);

			    	findNodes(<ISceneNode>pNode.sibling);
			    	findNodes(<ISceneNode>pNode.child);
		    	}
		    }

		    for (var i = 0; i < pRootJoints.length; i++) {
		    	findNodes(pRootJoints[i]);
		    };

// for (var sJoint in pJointMap) {
// 	var pJoint = pJointMap[sJoint];

//    	if (pJoint.sibling() == null && pJoint.child() == null) {
//    		pNotificationJoints.push(pJoint);
//    	}
//    };    

			return true;
		}

		findJoint(sName: string): IJoint {
			return this._pJointMap[sName];
		}

		findJointByName(sName: string): IJoint {
			for (var s in this._pJointMap) {
				if (this._pJointMap[s].name === sName) {
					return this._pJointMap[s];
				}
			}

			return null;
		}

		attachMesh(pMesh: IMesh): bool {
			if (isNull(this.root)) {
				return false;
			}

		    if (this._pMeshNode == null) {
		    	this._pMeshNode = this.root.scene.createModel();
		    	this._pMeshNode.setInheritance(ENodeInheritance.ALL);
		    	this._pMeshNode.attachToParent(this.root);
		    }

		    this._pMeshNode.name = this.name + "[mesh-container]";
		    this._pMeshNode.mesh = (pMesh);

		    return true;
		}

		detachMesh(): void {
//TODO: write detach method.
		}
	}

	export function createSkeleton(sName: string = null): ISkeleton {
		return new Skeleton(sName);
	}
}



















module akra.animation {
	export class Frame implements IFrame {
		type: EAnimationInterpolations;

		time:  number ;
		weight:  number ;

		constructor (eType: EAnimationInterpolations, fTime:  number   = 0.0, fWeight:  number  = 1.0) {
			this.type = eType;
			this.time = fTime;
			this.weight = fWeight;
		}

		reset(): IFrame {
			this.weight = 0.0;
			this.time = 0.0;

			return this;
		}

		add(pFrame: IFrame, isFirst: bool): IFrame {
			{ logger.setSourceLocation( "Frame.ts" , 30 ); logger.error("You cannot use Frame class directly."); } ;
			return this;
		}

		set(pFrame: IFrame): IFrame {
			this.weight = pFrame.weight;
			this.time = pFrame.time;

			return this;
		}

		mult(fScalar:  number ): IFrame {
			this.weight *= fScalar;

			return this;
		}

		normilize(): IFrame {
			{ logger.setSourceLocation( "Frame.ts" , 48 ); logger.error("You cannot use Frame class directly."); } ;
			return this;
		}

		interpolate(pStartFrame: IFrame, pEndFrame: IFrame, fBlend:  number ): IFrame {
			{ logger.setSourceLocation( "Frame.ts" , 53 ); logger.error("You cannot use Frame class directly."); } ;
			return this;
		}
	}

//complex world position frame
	export class PositionFrame extends Frame implements IPositionFrame {
		private matrix: IMat4 = null;

		rotation: IQuat4 = new Quat4;
		scale: IVec3 = new Vec3;
		translation: IVec3 = new Vec3;

		constructor();
		constructor(fTime:  number , pMatrix: IMat4);
		constructor(fTime:  number , pMatrix: IMat4, fWeight:  number );
		constructor(fTime?:  number , pMatrix?: IMat4, fWeight?:  number ) {
			super(EAnimationInterpolations.SPHERICAL);

			switch (arguments.length) {
				case 0:
					this.matrix = new Mat4;
					return;
				case 3:
					this.weight = fWeight;
				case 2:
					this.matrix = pMatrix;
				case 1:
					this.time = fTime;
			};

			{ logger.setSourceLocation( "Frame.ts" , 84 ); logger.assert(this.matrix.decompose(this.rotation, this.scale, this.translation), "could not decompose matrix"); } ;
		}

		toMatrix(): IMat4 {
			return this.rotation.toMat4(this.matrix).setTranslation(this.translation).scaleRight(this.scale);
		}

		reset(): IPositionFrame {
			super.reset();

			this.rotation.x = this.rotation.y = this.rotation.z = 0;
			this.rotation.w = 1.0;

			this.translation.x = this.translation.y = this.translation.z = 0;

			this.scale.x = this.scale.y = this.scale.z = 0;

			return this;
		}

		set(pFrame: IPositionFrame): IPositionFrame {
			super.set(pFrame);

			this.rotation.set(pFrame.rotation);
			this.scale.set(pFrame.scale);
			this.translation.set(pFrame.translation);

			return this;
		}

/**
		 * Adding frame data with own weight.
		 * @note Frame must be normilized after this modification!
		 */

		add(pFrame: IPositionFrame, isFirst: bool): IPositionFrame {
			var fWeight:  number  = pFrame.weight;

//only lerp supported
			this.scale.x += pFrame.scale.x * fWeight;
			this.scale.y += pFrame.scale.y * fWeight;
			this.scale.z += pFrame.scale.z * fWeight;

//only lerp supported
			this.translation.x += pFrame.translation.x * fWeight;
			this.translation.y += pFrame.translation.y * fWeight;
			this.translation.z += pFrame.translation.z * fWeight;

			this.weight += fWeight;

			if (isFirst) {
				this.rotation.set(pFrame.rotation);
				return this;
			}

			switch (this.type) {
				case EAnimationInterpolations.LINEAR:
					this.rotation.mix(pFrame.rotation, fWeight / this.weight);
					break;
				case EAnimationInterpolations.SPHERICAL:
					this.rotation.smix(pFrame.rotation, fWeight / this.weight);
					break;
			}

			return this;
		}

		normilize(): IPositionFrame {
			var fScalar:  number  = 1.0 / this.weight;

		    this.scale.x *= fScalar;
		    this.scale.y *= fScalar;
		    this.scale.z *= fScalar;

		    this.translation.x *= fScalar;
		    this.translation.y *= fScalar;
		    this.translation.z *= fScalar;

			return this;
		}


		interpolate(pStartFrame: IPositionFrame, pEndFrame: IPositionFrame, fBlend:  number ): IPositionFrame {
			pStartFrame.translation.mix(pEndFrame.translation, fBlend, this.translation);
			pStartFrame.scale.mix(pEndFrame.scale, fBlend, this.scale);

			switch (pStartFrame.type) {
				case EAnimationInterpolations.LINEAR:
					pStartFrame.rotation.mix(pEndFrame.rotation, fBlend, this.rotation);
					break;
				case EAnimationInterpolations.SPHERICAL:
					pStartFrame.rotation.smix(pEndFrame.rotation, fBlend, this.rotation);
					break;
			}

			return this;
		}

		static get stackCeil(): PositionFrame { PositionFrame.stackPosition = PositionFrame.stackPosition === PositionFrame.stackSize - 1? 0: PositionFrame.stackPosition; return PositionFrame.stack[PositionFrame.stackPosition ++]; } static stackSize: number = 4 * 4096 ; static stackPosition: number = 0; static stack: PositionFrame[] = (function(): PositionFrame[]{ var pStack: PositionFrame[] = new Array(PositionFrame.stackSize); for(var i: number = 0; i<PositionFrame.stackSize; i++){ pStack[i] = new PositionFrame(); } return pStack})(); ;
	}

	export class MatrixFrame extends Frame {
		matrix: IMat4 = null;

		constructor();
		constructor(fTime:  number , pMatrix: IMat4);
		constructor(fTime:  number , pMatrix: IMat4, fWeight:  number );
		constructor(fTime?:  number , pMatrix?: IMat4, fWeight?:  number ) {
			super(EAnimationInterpolations.LINEAR);

			switch (arguments.length) {
				case 0:
					this.matrix = new Mat4;
					return;
				case 3:
					this.weight = fWeight;
				case 2:
					this.matrix = pMatrix;
				case 1:
					this.time = fTime;
			};
		}

		reset(): MatrixFrame {
			super.reset();

			var pData = this.matrix.data;

			pData[ 0 ] = pData[ 4 ] = pData[ 8 ] = pData[ 12 ] =
			pData[ 1 ] = pData[ 5 ] = pData[ 9 ] = pData[ 13 ] =
			pData[ 2 ] = pData[ 6 ] = pData[ 10 ] = pData[ 14 ] =
			pData[ 3 ] = pData[ 7 ] = pData[ 11 ] = pData[ 15 ] = 0;

			return this;
		}

		set(pFrame: MatrixFrame): MatrixFrame {
			super.set(pFrame);
//FIXME: расписать побыстрее
			this.matrix.set(pFrame.matrix);

			return this;
		}

		/**@inline*/  toMatrix(): IMat4 {
			return this.matrix;
		}

		add(pFrame: MatrixFrame, isFirst: bool): MatrixFrame {
			var pMatData: Float32Array = pFrame.matrix.data;
			var fWeight:  number  = pFrame.weight;
			var pResData: Float32Array = this.matrix.data;

			for (var i = 0; i < 16; ++ i) {
				pResData[i] += pMatData[i] * fWeight;
			}

			this.weight += fWeight;
			return this;
		}

		normilize(): MatrixFrame {
			var fScalar:  number  = 1.0 / this.weight;
		    var pData = this.matrix.data;

		    pData[ 0 ] *= fScalar;
		    pData[ 4 ] *= fScalar;
		    pData[ 8 ] *= fScalar;
		    pData[ 12 ] *= fScalar;

			pData[ 1 ] *= fScalar;
		    pData[ 5 ] *= fScalar;
		    pData[ 9 ] *= fScalar;
		    pData[ 13 ] *= fScalar;

			pData[ 2 ] *= fScalar;
		    pData[ 6 ] *= fScalar;
		    pData[ 10 ] *= fScalar;
		    pData[ 14 ] *= fScalar;

			pData[ 3 ] *= fScalar;
		    pData[ 7 ] *= fScalar;
		    pData[ 11 ] *= fScalar;
		    pData[ 15 ] *= fScalar;

			return this;
		}

		interpolate(pStartFrame: MatrixFrame, pEndFrame: MatrixFrame, fBlend:  number ): MatrixFrame {
			{ logger.setSourceLocation( "Frame.ts" , 273 ); logger.assert(this.type === EAnimationInterpolations.LINEAR, "only LERP interpolation supported for matrix frames"); }
                                                          ;

			var pResultData = this.matrix.data;
			var pStartData = pStartFrame.matrix.data;
			var pEndData = pEndFrame.matrix.data;
			var fBlendInv:  number  = 1. - fBlend;

			for (var i:  number  = 0; i < 16; i++) {
				pResultData[i] = pEndData[i] * fBlend + pStartData[i] * fBlendInv;
			}

			return this;
		}

		static get stackCeil(): MatrixFrame { MatrixFrame.stackPosition = MatrixFrame.stackPosition === MatrixFrame.stackSize - 1? 0: MatrixFrame.stackPosition; return MatrixFrame.stack[MatrixFrame.stackPosition ++]; } static stackSize: number = 4 * 4096 ; static stackPosition: number = 0; static stack: MatrixFrame[] = (function(): MatrixFrame[]{ var pStack: MatrixFrame[] = new Array(MatrixFrame.stackSize); for(var i: number = 0; i<MatrixFrame.stackSize; i++){ pStack[i] = new MatrixFrame(); } return pStack})(); ;

	}

	export  /**@inline*/  function animationFrame(): PositionFrame {
		return PositionFrame.stackCeil;
	}
}



module akra.animation {
	export class Parameter implements IAnimationParameter {
		private _pKeyFrames: IFrame[] = [];

		/**@inline*/  get totalFrames():  number  {
			return this._pKeyFrames.length;
		}

		/**@inline*/  get duration():  number  {
			return (<IFrame>(this._pKeyFrames.last)).time;
		}

		/**@inline*/  get first():  number  {
			return (<IFrame>(this._pKeyFrames.first)).time;
		}

		keyFrame(pFrame: IFrame): bool {
		    var iFrame:  number ;

		    var pKeyFrames: IFrame[] = this._pKeyFrames;
		  	var nTotalFrames:  number  = pKeyFrames.length;

		    if (nTotalFrames && (iFrame = this.findKeyFrame(pFrame.time)) >= 0) {
				pKeyFrames.splice(iFrame, 0, pFrame);
			}
			else {
				pKeyFrames.push(pFrame);
			}

			return true;
		}

		getKeyFrame(iFrame:  number ): IFrame {
			{ logger.setSourceLocation( "Parameter.ts" , 41 ); logger.assert(iFrame < this.totalFrames, "iFrame must be less then number of total jey frames."); }
                                                           ;

			return this._pKeyFrames[iFrame];
		}

		findKeyFrame(fTime:  number ):  number  {
			var pKeyFrames: IFrame[] = this._pKeyFrames;
		    var nTotalFrames:  number              = pKeyFrames.length;

			if (pKeyFrames[nTotalFrames - 1].time == fTime) {
				return nTotalFrames - 1;
			}
			else {
				for (var i:  number  = nTotalFrames - 1; i >= 0; i--) {
					if (pKeyFrames[i].time > fTime && pKeyFrames[i - 1].time <= fTime) {
						return i - 1;
					}
				}
			}

			return -1;
		}

		frame(fTime:  number ): IFrame {
			var iKey1:  number  = 0, iKey2:  number  = 0;
			var fScalar:  number ;
			var fTimeDiff:  number ;

			var pKeys:  IFrame[] = this._pKeyFrames;
			var nKeys:   number  = pKeys.length;
			var pFrame: IFrame = animationFrame();

			{ logger.setSourceLocation( "Parameter.ts" , 73 ); logger.assert(nKeys > 0, 'no frames :('); } ;

			if (nKeys === 1) {
				pFrame.set(pKeys[0]);
			}
			else {
//TODO: реализовать эвристики для бинарного поиска

				if(fTime >= this._pKeyFrames[nKeys - 1].time){
					iKey1 = nKeys - 1;
				}
				else {
					var p:  number  = 0;
					var q:  number  = nKeys - 1;

					while(p < q){
						var s: number  = (p + q) >> 1;
						var fKeyTime:  number  = this._pKeyFrames[s].time;

						if(fTime >= fKeyTime){
							if(fTime === fKeyTime || fTime < this._pKeyFrames[s+1].time){
								iKey1 = s;
								break;
							}

							p = s + 1;
						}
						else {
							q = s;
						}
					}
				}

			    iKey2 = (iKey1 >= (nKeys - 1))? iKey1 : iKey1 + 1;

			    fTimeDiff = pKeys[iKey2].time - pKeys[iKey1].time;

			    if (!fTimeDiff) {
			        fTimeDiff = 1.;
			    }

				fScalar = (fTime - pKeys[iKey1].time) / fTimeDiff;

				pFrame.interpolate(
					this._pKeyFrames[iKey1],
					this._pKeyFrames[iKey2],
					fScalar);
			}

			pFrame.time = fTime;
			pFrame.weight = 1.0;

			return pFrame;
		}
	}

	export function createParameter(): IAnimationParameter {
		return new Parameter();
	}
}




module akra.animation {

	class Track extends Parameter implements IAnimationTrack {
		private _sTarget: string = null;
		private _pTarget: ISceneNode = null;


		/**@inline*/  get target(): ISceneNode{
			return this._pTarget;
		}

		/**@inline*/  get targetName(): string{
			return this._sTarget;
		}

		/**@inline*/  set targetName(sValue: string) {
			this._sTarget = sValue;
		}

		constructor (sTarget: string = null) {
			super();
			this._sTarget = sTarget;
		}

		keyFrame(pFrame: PositionFrame): bool;
		keyFrame(fTime:  number , pMatrix: IMat4): bool;
		keyFrame(fTime, pMatrix?): bool {
			var pFrame: PositionFrame;

			if (arguments.length > 1) {
		  		pFrame = new PositionFrame(< number >fTime, <IMat4>pMatrix);
		  	}
		    else {
		    	pFrame = <PositionFrame>arguments[0];
		    }

		    return super.keyFrame(pFrame);
		}

		bind(sJoint: string, pSkeleton: ISkeleton): bool;
		bind(pSkeleton: ISkeleton): bool;
		bind(pNode: ISceneNode): bool;
		bind(pJoint: any, pSkeleton?: any): bool {
			var pNode: ISceneNode = null,
				pRootNode: ISceneNode;

			var sJoint: string;

			switch (arguments.length) {
				case 2:
//bind by pair <String joint, Skeleton skeleton>
					sJoint = <string>pJoint;

					this._sTarget = sJoint;
					pNode = (<ISkeleton>pSkeleton).findJoint(sJoint);
					break;
				default:
//bind by <Skeleton skeleton>
					if (!isDef(arguments[0].type)) {

						if (this._sTarget == null) {
							return false;
						}

						pSkeleton = <ISkeleton>arguments[0];
						pNode = (<ISkeleton>pSkeleton).findJoint(this._sTarget);
					}
//bind by <Node node>
					else {
						pRootNode = <ISceneNode>arguments[0];
						pNode = <ISceneNode>pRootNode.findEntity(this.targetName);
					}
			}

			this._pTarget = pNode;

			return isDefAndNotNull(pNode);
		}



		toString(): string {
			var s = "target: " + this.targetName + ", from: " + this.first + "sec. , duration: " + this.duration +
				" sec. , frames: " + this.totalFrames;
			return s;
		}

	}

	export function createTrack(sTarget: string = null): IAnimationTrack {
		return new Track(sTarget);
	}
}














module akra {
	;
	;
	;
	;

	export interface IAnimationTarget {
		target: ISceneNode;
		index:  number ;
		name: string;
		track?: IAnimationTrack;
	}

	export enum EAnimationTypes {
		ANIMATION,
		LIST,
		CLIP,
		CONTAINER,
		BLEND
	}

	export interface IAnimationBase extends IEventProvider {
		duration:  number ;
		name: string;
		type: EAnimationTypes;

		 first:  number ;

		extra: any;

		play(fRealTime:  number ): void;
		stop(fRealTime:  number ): void;

		isAttached(): bool;
		attach(pTarget: ISceneNode): void;

		frame(sName: string, fRealTime:  number ): IPositionFrame;
		apply(fRealTime:  number ): bool;

		addTarget(sName: string, pTarget: ISceneNode): IAnimationTarget;
		setTarget(sName: string, pTarget: ISceneNode): IAnimationTarget;

		getTarget(sTargetName: string): IAnimationTarget;
		getTargetByName(sName: string): IAnimationTarget;

		getTargetList(): IAnimationTarget[];

		targetNames(): string[];
		targetList(): ISceneNode[];
		jointList(): IJoint[];

		grab(pAnimationBase: IAnimationBase, bRewrite?: bool): void;

		createAnimationMask(): FloatMap;

		 played(fTime:  number ): void;
		 stoped(fTime:  number ): void;
		 renamed(sName: string): void;
	}

	export interface IAnimationMap {
		[name: string]: IAnimationBase;
	}
}



module akra {
	;
	;
	;

	export interface IAnimation extends IAnimationBase {
		 totalTracks:  number ;

		push(pTrack: IAnimationTrack): void;
		attach(pTarget: ISceneNode): void;

		getTracks(): IAnimationTrack[];
		getTrack(i:  number ): IAnimationTrack;

		frame(sName: string, fTime:  number ): IPositionFrame;
		extend(pAnimation: IAnimation): void;
	}
}



























module akra.animation {
	export interface IAnimationTargetMap {
		[index: string]: IAnimationTarget;
	}

	export class Base implements IAnimationBase {

		protected _pTargetMap: IAnimationTargetMap = {};
    	protected _pTargetList: IAnimationTarget[] = [];

    	protected _fDuration:  number  = 0.0;
//first ever frame time of all targets
    	protected _fFirst:  number  = MAX_UINT32;
		protected _sName: string;

		protected _eType: EAnimationTypes;

		public extra: any = null;

		constructor (eType: EAnimationTypes, sName: string = null) {
			this._sName = sName || ("animation-" + "-" + this.getGuid());
			this._eType = eType;
		}

		/**@inline*/  get type(): EAnimationTypes {
			return this._eType;
		}

		/**@inline*/  get duration():  number {
			return this._fDuration;
		}

		/**@inline*/  set duration(fValue:  number ) {
// LOG("new duration(", this.name, ") > " + fValue);
			this._fDuration = fValue;
		}

		/**@inline*/  get first():  number  {
			return this._fFirst;
		}

		/**@inline*/  get name(): string{
			return this._sName;
		};

		/**@inline*/  set name(sName: string){
			if (sName == this._sName) {
				return;
			}

			this._sName = sName;
			this.renamed(sName);
		};


		/**@inline*/  play(fRealTime:  number ): void {
			this.played(fRealTime);
		}

		/**@inline*/  stop(fRealTime:  number ): void {
			this.stoped(fRealTime);
		}

		/**@inline*/  isAttached(): bool {
			if (this._pTargetList.length) {
				return isDefAndNotNull(this._pTargetList[0].target);
			}

			return false;
		}

		attach(pTarget: ISceneNode): void {
			{ logger.setSourceLocation( "Base.ts" , 83 ); logger.error("method AnimationBase::attach() must be overwritten."); } ;
		}

		frame(sName: string, fRealTime:  number ): IPositionFrame {
			return null;
		}

		apply(fRealTime:  number ): bool {
			var pTargetList: IAnimationTarget[] = this._pTargetList;
		    var pTarget: ISceneNode = null;
		    var pFrame: IPositionFrame = null;
		    var pTransform: IMat4 = null;
		    var bAffected: bool = false;

			for (var i = 0; i < pTargetList.length; ++ i) {
				pFrame = this.frame(pTargetList[i].name, fRealTime);
				pTarget = pTargetList[i].target;

				if (!pFrame || !pTarget) {
					continue;
				}

				pTransform = pFrame.toMatrix();
				pTarget.localMatrix = pTransform;
				bAffected = true;
			}
// console.log(bAffected);
			return bAffected;
		}

		addTarget(sName: string, pTarget: ISceneNode = null): IAnimationTarget {
//pTarget = pTarget || null;

		    var pPointer: IAnimationTarget = this._pTargetMap[sName];

		    if (pPointer) {
		    	pPointer.target = pTarget || pPointer.target || null;
		    	return pPointer;
		    }

		    pPointer = {
				target: pTarget,
				index: this._pTargetList.length,
				name: sName
			};

		    this._pTargetList.push(pPointer);
			this._pTargetMap[sName] = pPointer;

			return pPointer;
		}

		setTarget(sName: string, pTarget: ISceneNode): IAnimationTarget {

		    var pPointer: IAnimationTarget = this._pTargetMap[sName];
			pPointer.target = pTarget;
			return pPointer;
		}

		getTarget(sTargetName: string): IAnimationTarget {
			return this._pTargetMap[sTargetName];
		}

		/**@inline*/  getTargetList(): IAnimationTarget[] {
			return this._pTargetList;
		}

		/**@inline*/  getTargetByName(sName: string): IAnimationTarget {
			return this._pTargetMap[sName];
		}

		targetNames(): string[] {
			var pTargets: IAnimationTarget[] = this._pTargetList;
			var pTargetNames: string[] = [];

			for (var i = 0; i < pTargets.length; ++ i) {
				pTargetNames.push(pTargets[i].name);
			}

			return pTargetNames;
		}

		targetList(): ISceneNode[] {
			var pTargets: IAnimationTarget[] = this._pTargetList;
			var pTargetList: ISceneNode[] = [];

			for (var i = 0; i < pTargets.length; ++ i) {
				pTargetList.push(pTargets[i].target);
			}

			return pTargetList;
		}

		jointList(): IJoint[] {
			var pTargets: IAnimationTarget[] = this._pTargetList;
			var pJointList: IJoint[] = [];

			for (var i = 0; i < pTargets.length; ++ i) {
				if (scene.isJoint(pTargets[i].target)) {
					pJointList.push(<IJoint>pTargets[i].target);
				}
			}

			return pJointList;
		}

		grab(pAnimationBase: IAnimationBase, bRewrite: bool = true): void{

		    var pAdoptTargets: IAnimationTarget[] = pAnimationBase.getTargetList();

			for (var i = 0; i < pAdoptTargets.length; ++ i) {

				if (!pAdoptTargets[i].target) {
//warning('cannot grab target <' + pAdoptTargets[i].name + '>, becaus "target" is null');
					continue;
				}

				if (bRewrite || !this.getTarget(pAdoptTargets[i].name)) {
					this.addTarget(pAdoptTargets[i].name, pAdoptTargets[i].target);
				}
			}

			this._fFirst = math.min(this.first, pAnimationBase.first);
		}

		createAnimationMask(): FloatMap {
			var pTargets: string[] = this.targetNames();
		    var pMask: FloatMap = <FloatMap>{};

		    for (var i = 0; i < pTargets.length; ++ i) {
		    	pMask[pTargets[i]] = 1.0;
		    }

		    return pMask;
		}


		toString(): string {
			var s = "\n";
			s += "name         : " + this.name + "\n";
			s += "duration     : " + this.duration + " sec\n";
			s += "total targets: " + this.targetList().length.toString() + "\n";
			return s;
		}


		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Base._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		played (fRealTime): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).played; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, fRealTime) : _broadcast[i].listener (_recivier, fRealTime) ; } } } ; ;
		stoped (fRealTime): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).stoped; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, fRealTime) : _broadcast[i].listener (_recivier, fRealTime) ; } } } ; ;
		renamed (sName): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).renamed; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, sName) : _broadcast[i].listener (_recivier, sName) ; } } } ; ;
	}


}



module akra.animation {
	class Animation extends Base implements IAnimation {
		private _pTracks: IAnimationTrack[] = [];

    	constructor (sName?: string) {
    		super(EAnimationTypes.ANIMATION, sName);
    	}

		/**@inline*/  get totalTracks():  number  {
			return this._pTracks.length;
		}

		push(pTrack: IAnimationTrack): void {
			this._pTracks.push(pTrack);
			this._fDuration = math.max(this._fDuration, pTrack.duration);
			this._fFirst = math.min(this.first, pTrack.first);
			this.addTarget(pTrack.targetName);
		}

		attach(pTarget: ISceneNode): void {
			var pPointer: IAnimationTarget;
		    var pTracks: IAnimationTrack[] = this._pTracks;

			for (var i = 0; i < pTracks.length; ++ i) {
				if (!pTracks[i].bind(pTarget)) {
					{ logger.setSourceLocation( "animation/Animation.ts" , 36 ); logger.log("cannot bind animation track [", i, "] to joint <", pTracks[i].target, ">"); } ;
				}
				else {
					pPointer = this.setTarget(pTracks[i].targetName, pTracks[i].target);
					pPointer.track = pTracks[i];
				}
			}
		}

		/**@inline*/  getTracks(): IAnimationTrack[] {
			return this._pTracks;
		}

		/**@inline*/  getTrack(i:  number ): IAnimationTrack {
			return this._pTracks[i];
		}

		frame(sName: string, fTime:  number ): IPositionFrame {
			var pPointer: IAnimationTarget = this.getTargetByName(sName);

		    if (!pPointer || !pPointer.track) {
		    	return null;
		    }

			return <IPositionFrame>pPointer.track.frame(math.clamp(fTime, 0, this._fDuration));
		}

		extend(pAnimation: IAnimation): void {
			var pTracks: IAnimationTrack[] = pAnimation.getTracks();

			for (var i = 0; i < pTracks.length; ++ i) {
				if (!this.getTarget(pTracks[i].targetName)) {
					this.push(pTracks[i]);
				}
			}
		}


		toString(): string {
			var s = super.toString();
			s += "total tracks : " + this.totalTracks + "\n";

			for (var i:  number  = 0; i < this.totalTracks; ++ i) {
				s += "\t" + i + ". " + this.getTrack(i) + "\n";
			}

			return s;
		}

	}

	export  /**@inline*/  function isAnimation(pAnimation: IAnimationBase): bool {
		return pAnimation.type === EAnimationTypes.ANIMATION;
	}

	export function createAnimation(sName?: string): IAnimation {
		return new Animation(sName);
	}
}


























module akra {
	;

	export interface IAnimationContainer extends IAnimationBase {
		 animationName: string;
		 speed:  number ;
		 animationTime:  number ;
		 time:  number ;

		setAnimation(pAnimation: IAnimationBase): void;
		getAnimation(): IAnimationBase;

		enable(): void;
		disable(): void;
		isEnabled(): bool;

		leftInfinity(bValue: bool): void;
		rightInfinity(bValue: bool): void;

		setStartTime(fRealTime:  number ): void;
		getStartTime():  number ;

		inLeftInfinity(): bool;
		inRightInfinity(): bool;

		setSpeed(fSpeed:  number ): void;
		getSpeed():  number ;

		useLoop(bValue: bool): void;
		inLoop(): bool;

		reverse(bValue: bool): void;
		isReversed(): bool;

		rewind(fRealTime:  number ): void;

		pause(bValue?: bool): void;
		isPaused(): bool;

		 durationUpdated(fDuration:  number ): void;
		 enterFrame(fRealTime:  number , fTime:  number ): void;
	}
}











module akra.animation {
	export class Container extends Base implements IAnimationContainer {

		private _bEnable: bool = true;
		private _fStartTime:  number  = 0;
		private _fSpeed:  number  = 1.0;
		private _bLoop: bool = false;
		private _pAnimation: IAnimationBase = null;
		private _bReverse: bool = false;

//Время учитывающее циклы и прочее.
		private _fTrueTime:  number  = 0;
//реальное время на сцене
		private _fRealTime:  number  = 0;
//время с учетом ускорений
		private _fTime:  number  = 0;

		private _bPause: bool = false;

//определена ли анимация до первого и после последнего кадров
		private _bLeftInfinity: bool = true;
		private _bRightInfinity: bool = true;

		constructor(pAnimation?: IAnimationBase, sName?: string){
			super(EAnimationTypes.CONTAINER, sName);

			if (pAnimation) {
				this.setAnimation(pAnimation);
			}
		}

		/**@inline*/  get animationName(): string{
			return this._pAnimation.name;
		}

		/**@inline*/  get speed():  number {
			return this._fSpeed;
		}

		/**@inline*/  get animationTime():  number {
			return this._fTrueTime;
		}

		/**@inline*/  get time():  number  {
			return this._fTime;
		}

		play(fRealTime:  number ): void {
			this._fRealTime = fRealTime;
		    this._fTime = 0;

		    this.played(this._fTime);
		}

		/**@inline*/  stop(): void {
			this.stoped(this._fTime);
		}

		attach(pTarget: ISceneNode): void {
			if (!isNull(this._pAnimation)) {
				this._pAnimation.attach(pTarget);
				this.grab(this._pAnimation, true);
			}
		}

		setAnimation(pAnimation: IAnimationBase): void {
			{ logger.setSourceLocation( "Container.ts" , 76 ); logger.assert(!this._pAnimation, "anim. already exists"); } ;

			this._pAnimation = pAnimation;
			this.setSpeed(this.speed);

			this.connect(pAnimation, "durationUpdated" , "_onDurationUpdate" ) ;

			this.grab(pAnimation);
		}

		_onDurationUpdate(pAnimation: IAnimationBase, fDuration:  number ): void {
			this.setSpeed(this.speed);
		}

		getAnimation(): IAnimationBase {
			return this._pAnimation;
		}

		/**@inline*/  enable(): void {
			this._bEnable = true;
		}

		/**@inline*/  disable(): void {
			this._bEnable = false;
		}

		/**@inline*/  isEnabled(): bool {
			return this._bEnable;
		}

		/**@inline*/  leftInfinity(bValue: bool): void {
			this._bLeftInfinity = bValue;
		}

		/**@inline*/  inLeftInfinity(): bool {
			return this._bLeftInfinity;
		}

		/**@inline*/  inRightInfinity(): bool {
			return this._bRightInfinity;
		}

		/**@inline*/  rightInfinity(bValue: bool): void {
			this._bRightInfinity = bValue;
		}

		/**@inline*/  setStartTime(fRealTime:  number ): void {
			this._fStartTime = fRealTime;
		}

		/**@inline*/  getStartTime():  number  {
			return this._fStartTime;
		}

		setSpeed(fSpeed:  number ): void {
			this._fSpeed = fSpeed;
			this.duration = this._pAnimation.duration / fSpeed;

			this.durationUpdated(this.duration);
		}

		/**@inline*/  getSpeed():  number  {
			return this._fSpeed;
		}

		/**@inline*/  useLoop(bValue: bool): void {
			this._bLoop = bValue;
		}

		/**@inline*/  inLoop(): bool {
			return this._bLoop;
		}

		/**@inline*/  reverse(bValue: bool): void {
			this._bReverse = bValue;
		}

		/**@inline*/  isReversed(): bool {
			return this._bReverse;
		}

		pause(bValue: bool = true): void {
			this._fRealTime = -1;
			this._bPause = bValue;
		}

		/**@inline*/  rewind(fRealTime:  number ): void {
// console.log("rewind > ", fRealTime);
			this._fTrueTime = 0;
			this._fTime = fRealTime;
		}

		/**@inline*/  isPaused(): bool {
			return this._bPause;
		}

		protected calcTime(fRealTime:  number ): void{
			if (this._bPause) {
		    	return;
		    }

//if loop switched and prev. fRealTime less than new fRealTime
//for ex.: prev real time calced in loop, next - real time from now()
		    if (this._fRealTime < 0 || this._fRealTime > fRealTime) {
		    	this._fRealTime = fRealTime;
		    }

		    this._fTime = this._fTime + (fRealTime - this._fRealTime) * this._fSpeed;
		    this._fRealTime = fRealTime;

		    var fTime = this._fTime;

		    if (this._bLoop) {
		    	fTime = math.mod(fTime, (this._pAnimation.duration));
		    	if (this._bReverse) {
		    		fTime = this._pAnimation.duration - fTime;
		    	}
		    }

		    this._fTrueTime = fTime;
		}

		frame(sName: string, fRealTime:  number ): IPositionFrame {
			if (!this._bEnable) {
		    	return null;
		    }


		    if (this._fRealTime !== fRealTime) {
//only for first bone in list

		    	this.calcTime(fRealTime);
		    	this.enterFrame(fRealTime, this._fTrueTime);
		    }

		    if (!this._bLeftInfinity  && this._fTrueTime < this.first) {
		    	return null;
		    }


			if (!this._bRightInfinity && this._fTrueTime > this.duration) {
		    	return null;
		    }

			return this._pAnimation.frame(sName, this._fTrueTime);
		}


		durationUpdated (fDuration): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).durationUpdated; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, fDuration) : _broadcast[i].listener (_recivier, fDuration) ; } } } ; ;
		enterFrame (fRealTime, fTime): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).enterFrame; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, fRealTime, fTime) : _broadcast[i].listener (_recivier, fRealTime, fTime) ; } } } ; ;
	}

	export  /**@inline*/  function isContainer(pAnimation: IAnimationBase): bool {
		return pAnimation.type === EAnimationTypes.CONTAINER;
	}

	export function createContainer(pAnimation?: IAnimationBase, sName?: string): IAnimationContainer {
		return new Container(pAnimation, sName);
	}
}










module akra {
	;

	export interface IAnimationElement {
		animation: IAnimationBase;
		weight:  number ;
		mask: FloatMap;
		acceleration?:  number ;
		time:  number ;
		realTime:  number ;
	}

	export interface IAnimationBlend extends IAnimationBase {
		 totalAnimations:  number ;

		addAnimation(pAnimation: IAnimationBase, fWeight?:  number , pMask?: FloatMap):  number ;
		setAnimation(iAnimation:  number , pAnimation: IAnimationBase, fWeight?:  number , pMask?: FloatMap): bool;

		getAnimationIndex(sName: string):  number ;
		getAnimation(sName: string): IAnimationBase;
		getAnimation(iAnimation:  number ): IAnimationBase;
		getAnimationWeight(sName: string):  number ;
		getAnimationWeight(iAnimation:  number ):  number ;

		swapAnimations(i:  number , j:  number ): bool;
		removeAnimation(iAnimation:  number ): bool;

		setWeights(...pWeight:  number []): bool;
		setWeightSwitching(fWeight:  number , iAnimationFrom:  number , iAnimationTo:  number ): bool;
		setAnimationWeight(iAnimation:  number , fWeight:  number ): bool;
		setAnimationWeight(fWeight:  number ): bool;

		setAnimationMask(sName: string, pMask: FloatMap): bool;
		setAnimationMask(iAnimation:  number , pMask: FloatMap): bool;

		getAnimationMask(sName: string): FloatMap;
		getAnimationMask(iAnimation:  number ): FloatMap;

		getAnimationAcceleration(sName: string):  number ;
		getAnimationAcceleration(iAnimation:  number ):  number ;

		createAnimationMask(iAnimation?:  number ): FloatMap;

		 durationUpdated(fDuration:  number );
		 weightUpdated(iAnim:  number , fWeight:  number );
	}
}








module akra.animation {
	class Blend extends Base implements IAnimationBlend {
		public duration:  number  = 0;

		private _pAnimationList: IAnimationElement[] = [];

		constructor (sName?: string) {
			super(EAnimationTypes.BLEND, sName);
		}

		/**@inline*/  get totalAnimations():  number  {
			return this._pAnimationList.length;
		}

		play(fRealTime:  number ): void {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;
			var n:  number  = pAnimationList.length;

			for (var i:  number  = 0; i < n; ++ i) {

				pAnimationList[i].realTime = fRealTime;
				pAnimationList[i].time = fRealTime * pAnimationList[i].acceleration;
			}

			this.played(fRealTime);
		}

		stop(): void {
			this.stoped(0.);
		}

		attach(pTarget: ISceneNode): void {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;

			for (var i:  number  = 0; i < pAnimationList.length; ++ i) {
				var pAnim: IAnimationBase = pAnimationList[i].animation;
				pAnim.attach(pTarget);
				this.grab(pAnim, true);
			}
		}

		addAnimation(pAnimation: IAnimationBase, fWeight?:  number , pMask?: FloatMap):  number  {
			{ logger.setSourceLocation( "Blend.ts" , 51 ); logger.assert(isDef(pAnimation), 'animation must be setted.'); } ;

			this._pAnimationList.push(null);
			var iAnimation:  number  = this._pAnimationList.length - 1;

			if (this.setAnimation(iAnimation, pAnimation, fWeight, pMask)) {
				return iAnimation;
			}

			return -1;
		}

		setAnimation(iAnimation:  number , pAnimation: IAnimationBase, fWeight:  number  = 1.0, pMask: FloatMap = null): bool {
			{ logger.setSourceLocation( "Blend.ts" , 64 ); logger.assert(iAnimation <= this._pAnimationList.length, 'invalid animation slot: ' + iAnimation + '/' + this._pAnimationList.length); } ;

		    var pPointer: IAnimationElement = this._pAnimationList[iAnimation];
		    var pAnimationList: IAnimationElement[] = this._pAnimationList;

		    if (!pAnimation) {
		    	if (isDefAndNotNull(pAnimationList[iAnimation])) {
			    	pAnimationList[iAnimation] = null;
			    	this.updateDuration();
			    	return true;
		    	}

		    	return false;
		    }

		    if (!pPointer) {
		    	pPointer = {
					animation: pAnimation,
					weight: fWeight,
					mask: pMask,
					acceleration: 1.0,
					time: 0.0,
					realTime: 0.0
				};

				this.connect(pAnimation, "durationUpdated" , "_onDurationUpdate" )

				if (iAnimation == this._pAnimationList.length) {
					pAnimationList.push(pPointer);
				}
				else {
					pAnimationList[iAnimation] = pPointer;
				}
			}
			else {
				return false;
			}

			this.grab(pAnimation);
			this.updateDuration();

			return true;
		}

		swapAnimations(i:  number , j:  number ): bool {
		    var pAnimationList: IAnimationElement[] = this._pAnimationList;
			var pPointerA: IAnimationElement = pAnimationList[i];
			var pPointerB: IAnimationElement = pAnimationList[j];

		    if (!isDefAndNotNull(pPointerA) || !isDefAndNotNull(pPointerB)) {
		    	return false;
		    }

		    pAnimationList[i] = pPointerB;
		    pAnimationList[j] = pPointerA;

		    return true;
		}

		removeAnimation(i:  number ): bool {
			if (this.setAnimation(i, null)) {
				this._pAnimationList.splice(i, 1);
				return true;
			}

			return false;
		}

		_onDurationUpdate(pAnimation: IAnimationBase, fDuration:  number ): void {
			this.updateDuration();
		}

		protected updateDuration(): void {
			var fWeight:  number  = 0;
			var fSumm:  number  = 0;
			var pAnimationList: IAnimationElement[] = this._pAnimationList;
			var n:  number  = pAnimationList.length;

			for (var i:  number  = 0; i < n; ++ i) {
				if (pAnimationList[i] === null) {
					continue;
				}

				fSumm += pAnimationList[i].weight * pAnimationList[i].animation.duration;
				fWeight += pAnimationList[i].weight;
			}

			if (fWeight === 0) {
				this.duration = 0;
			}
			else {

				this.duration = fSumm / fWeight;

				for (var i:  number  = 0; i < n; ++ i) {
					if (pAnimationList[i] === null) {
						continue;
					}

					pAnimationList[i].acceleration = pAnimationList[i].animation.duration / this.duration;
//trace(pAnimationList[i].animation.name, '> acceleration > ', pAnimationList[i].acceleration);
				}
			}

			this.durationUpdated(this.duration);
		}

		getAnimationIndex(sName: string):  number  {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;

			for (var i:  number  = 0; i < pAnimationList.length; i++) {
				if (pAnimationList[i].animation.name === sName) {
					return i;
				}
			};

			return -1;
		}


		getAnimation(sName: string): IAnimationBase;
		getAnimation(iAnimation:  number ): IAnimationBase;
		getAnimation(animation): IAnimationBase {
			var iAnimation:  number  = isString(animation)? this.getAnimationIndex(animation): < number >animation;
			return this._pAnimationList[iAnimation].animation;
		}

		getAnimationWeight(iAnimation:  number ):  number ;
		getAnimationWeight(sName: string):  number ;
		getAnimationWeight(animation):  number  {
			var iAnimation:  number  = < number >animation;
			if (isString(animation)) {
				iAnimation = this.getAnimationIndex(animation);
			}

			return this._pAnimationList[iAnimation].weight;
		}

		setWeights(...pWeight:  number []): bool {
			var fWeight:  number ;
    		var isModified: bool = false;
		    var pAnimationList: IAnimationElement[] = this._pAnimationList;

			for (var i:  number  = 0; i < arguments.length; ++ i) {
				fWeight = arguments[i];

				if (fWeight < 0 || fWeight === null || !pAnimationList[i]) {
					continue;
				}

				if (pAnimationList[i].weight !== fWeight) {
					pAnimationList[i].weight = fWeight;
					isModified = true;
				}
			}

			if (isModified) {
				this.updateDuration();
			}

			return true;
		}

		setWeightSwitching(fWeight:  number , iAnimationFrom:  number , iAnimationTo:  number ): bool {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;
		    var isModified: bool = false;
		    var fWeightInv:  number  = 1. - fWeight;

		    if (!pAnimationList[iAnimationFrom] || !pAnimationList[iAnimationTo]) {
		    	return false;
		    }

		    if (pAnimationList[iAnimationFrom].weight !== fWeightInv) {
				pAnimationList[iAnimationFrom].weight = fWeightInv;
				isModified = true;
			}

			if (pAnimationList[iAnimationTo].weight !== fWeight) {
				pAnimationList[iAnimationTo].weight = fWeight;
				isModified = true;
			}

			if (isModified) {
				this.updateDuration();
			}

			return true;
		}

		setAnimationWeight(fWeight:  number ): bool;
		setAnimationWeight(iAnimation:  number , fWeight:  number ): bool;
		setAnimationWeight(sName: string, fWeight:  number ): bool;
		setAnimationWeight(animation, fWeight?:  number ): bool {
			var pAnimationList = this._pAnimationList;

		    if (arguments.length === 1) {
		    	fWeight = arguments[0];

		    	for (var i = 0; i < pAnimationList.length; i++) {
		    		pAnimationList[i].weight = fWeight;
		    		this.weightUpdated(i, fWeight);
		    	}

		    	this.updateDuration();
		    }
		    else {
			    var iAnimation:  number  = isString(animation)? this.getAnimationIndex(animation): < number >animation;

//trace('set weight for animation: ', iAnimation, 'to ', fWeight);
			    if (pAnimationList[iAnimation].weight !== fWeight) {
					pAnimationList[iAnimation].weight = fWeight;
					this.updateDuration();
					this.weightUpdated(iAnimation, fWeight);
				}
			}

			return true;
		}

		setAnimationMask(iAnimation:  number , pMask: FloatMap): bool;
		setAnimationMask(sName: string, pMask: FloatMap): bool;
		setAnimationMask(animation, pMask: FloatMap): bool {
			var iAnimation:  number  = isString(animation)? this.getAnimationIndex(animation): < number >animation;

			this._pAnimationList[iAnimation].mask = pMask;

			return true;
		}

		getAnimationMask(iAnimation:  number ): FloatMap;
		getAnimationMask(sName: string): FloatMap;
		getAnimationMask(animation): FloatMap {
			var iAnimation:  number  = isString(animation)? this.getAnimationIndex(animation): < number >animation;

			return this._pAnimationList[iAnimation].mask;
		}

		getAnimationAcceleration(iAnimation:  number ):  number ;
		getAnimationAcceleration(sName: string):  number ;
		getAnimationAcceleration(animation):  number  {
			var iAnimation:  number  = isString(animation)? this.getAnimationIndex(animation): < number >animation;

			return this._pAnimationList[iAnimation].acceleration;
		}

		createAnimationMask(iAnimation?:  number ): FloatMap {
			if (arguments.length === 0) {
				return super.createAnimationMask();
			}

			if (typeof arguments[0] === 'string') {
		    	iAnimation = this.getAnimationIndex(arguments[0]);
		    }

		    var pAnimation: IAnimationBase = this._pAnimationList[iAnimation].animation;
			return pAnimation.createAnimationMask();
		}

		frame(sName: string, fRealTime:  number ): IPositionFrame {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;
			var pResultFrame: IPositionFrame = animationFrame().reset();
			var pFrame: IPositionFrame;
			var pMask: FloatMap;
			var pPointer: IAnimationElement;
			var fAcceleration:  number ;

			var fBoneWeight:  number ;
			var fWeight:  number ;
			var iAnim:  number  = 0;


			for (var i:  number  = 0; i < pAnimationList.length; i++) {
				pPointer = pAnimationList[i];

				if (!pPointer) {
					continue;
				}

				fAcceleration = pPointer.acceleration;
				pMask = pPointer.mask;
				fBoneWeight = 1.0;

//для того чтобы циклы используемые выше работали корректно
				if (fRealTime < pPointer.realTime) {
					pPointer.time = 0;
					pPointer.realTime = 0;
				}

				pPointer.time = pPointer.time + (fRealTime - pPointer.realTime) * fAcceleration;
		    	pPointer.realTime = fRealTime;

		    	if (pMask) {
					fBoneWeight = isDef(pMask[sName]) ? pMask[sName] : 1.0;
				}

				fWeight = fBoneWeight * pPointer.weight;

				if (fWeight > 0.0) {
					pFrame = pPointer.animation.frame(sName, pPointer.time);

					if (pFrame) {
						iAnim ++;
//first, if 1
						pResultFrame.add(pFrame.mult(fWeight), iAnim === 1);
					}
				}
			}

			if (pResultFrame.weight === 0.0) {
				return <IPositionFrame>null;
			}

			return <IPositionFrame>pResultFrame.normilize();
		}

		weightUpdated (iAnim, fWeight): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).weightUpdated; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, iAnim, fWeight) : _broadcast[i].listener (_recivier, iAnim, fWeight) ; } } } ; ;
		durationUpdated (fDuration): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).durationUpdated; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, fDuration) : _broadcast[i].listener (_recivier, fDuration) ; } } } ; ;
	}

	export  /**@inline*/  function isBlend(pAnimation: IAnimationBase): bool {
		return pAnimation.type === EAnimationTypes.BLEND;
	}

	export function createBlend(sName?: string): IAnimationBlend {
		return new Blend(sName);
	}
}



module akra.animation {
	export class Controller implements IAnimationController {
		public name: string = null;

		private _pAnimations: IAnimationBase[] = [];
		private _iOptions:  number  = 0;
	    private _pActiveAnimation: IAnimationBase = null;
	    private _pEngine: IEngine;
	    private _pTarget: ISceneNode = null;


	    /**@inline*/  get totalAnimations():  number {
			return this._pAnimations.length;
		}

		/**@inline*/  get active(): IAnimationBase{
			return this._pActiveAnimation;
		}

		/**@inline*/  get target(): ISceneNode {
			return this._pTarget;
		}

		constructor(pEngine: IEngine, sName: string = null, iOptions:  number  = 0) {
			this._pEngine = pEngine;
			this.setOptions(iOptions);
			this.name = sName;
		}

		/**@inline*/  getEngine(): IEngine {
			return this._pEngine;
		}

		setOptions(iOptions:  number ): void {

		}


		addAnimation(pAnimation: IAnimationBase): bool {
			if (this.findAnimation(pAnimation.name)) {
				{ logger.setSourceLocation( "animation/Controller.ts" , 52 ); logger.warning("Animation with name <" + pAnimation.name + "> already exists in this controller"); } ;
				return false;
			}

//LOG('animation controller :: add animation >> ', pAnimation.name);

			this._pAnimations.push(pAnimation);
			this._pActiveAnimation = pAnimation;
/*!pAnimation.isAttached() && */
			if (                                !isNull(this.target)) {
				pAnimation.attach(this.target);
			}
			else {
//TODO: detach animation
			}

			this.animationAdded(pAnimation);
		}

		removeAnimation(pAnimation: string): bool;
		removeAnimation(pAnimation:  number ): bool;
		removeAnimation(pAnimation: IAnimationBase): bool;
		removeAnimation(pAnimation: any): bool {
			var pAnimation = this.findAnimation(arguments[0]);
		    var pAnimations = this._pAnimations;

			for (var i = 0; i < pAnimations.length; ++ i) {
				if (pAnimations[i] === pAnimation) {
					pAnimations.splice(i, 1);
					{ logger.setSourceLocation( "animation/Controller.ts" , 80 ); logger.log("animation controller :: remove animation >> ", pAnimation.name); } ;
					return true;
				}
			}

			return false;
		}

		findAnimation(pAnimation: string): IAnimationBase;
		findAnimation(pAnimation:  number ): IAnimationBase;
		findAnimation(pAnimation: IAnimationBase): IAnimationBase;
		findAnimation(pAnimation: any): IAnimationBase {
			var pAnimations: IAnimationBase[] = this._pAnimations;
		    var iAnimation:  number ;
		    var sAnimation: string;

			if (isString(arguments[0])) {
				sAnimation = arguments[0];

				for (var i = 0; i < pAnimations.length; ++ i) {
					if (pAnimations[i].name === sAnimation) {
						return pAnimations[i];
					}
				}

				return null;
			}

			if (typeof arguments[0] === 'number') {
				iAnimation = arguments[0];
				return pAnimations[iAnimation] || null;
			}

			return arguments[0];
		}

		/**@inline*/  getAnimation(iAnim:  number ): IAnimationBase {
			return this._pAnimations[iAnim];
		}

		setAnimation(iAnimation:  number , pAnimation: IAnimationBase): void {
			{ logger.setSourceLocation( "animation/Controller.ts" , 121 ); logger.assert(iAnimation < this._pAnimations.length, 'invalid animation slot'); } ;

			this._pAnimations[iAnimation] = pAnimation;
		}

		attach(pTarget: ISceneNode): void {
			var pAnimations: IAnimationBase[] = this._pAnimations;

		    for (var i:  number  = 0; i < pAnimations.length; ++ i) {
		        if (!pAnimations[i].isAttached() || this.target !== pTarget) {
		        	pAnimations[i].attach(pTarget);
		        }
		    }

		    if (this.target) {
		    	this.disconnect(this.target.scene,  "postUpdate" ,  "update" );
		    }

		    this._pTarget = pTarget;
		    this.connect(this.target.scene,  "postUpdate" ,  "update" );

		}

		play(pAnimation: string): bool;
		play(pAnimation:  number ): bool;
		play(pAnimation: IAnimationBase): bool;
		play(pAnimation: any): bool {
			var pAnimationNext: IAnimationBase = this.findAnimation(arguments[0]);
			var pAnimationPrev: IAnimationBase = this._pActiveAnimation;
			var fRealTime:  number  = this._pEngine.time;

			if (pAnimationNext && pAnimationNext !== pAnimationPrev) {

				if (pAnimationPrev) {
					pAnimationPrev.stop(fRealTime);
				}

				pAnimationNext.play(fRealTime);
				this._pActiveAnimation = pAnimationNext;

				this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).play; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pAnimationNext, fRealTime) : _broadcast[i].listener (_recivier, pAnimationNext, fRealTime) ; } } ;
				return true;
			}

			return false;
		}

		stop(): void {
			if (this._pActiveAnimation) {
				this._pActiveAnimation.stop(this._pEngine.time);
			}

			this._pActiveAnimation = null;
		}

		update(): void {
			var pAnim: IAnimationBase = this._pActiveAnimation;
			if (!isNull(pAnim)) {
				if (!pAnim.apply(this._pEngine.time)) {

// this._pActiveAnimation = null;
// pAnim.stop(this._pEngine.time);
				}
			}
		}

		toString(bFullInfo: bool = false): string {

			var s: string = "\n";
			s += "ANIMATION CONTROLLER (total: " + this.totalAnimations + " animations)\n";
			s += "-----------------------------------------------------\n";

			for (var i:  number  = 0; i < this.totalAnimations; ++ i) {
				s += this.getAnimation(i).toString();
			}

			return s;

		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Controller._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		animationAdded (pAnimation): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).animationAdded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pAnimation) : _broadcast[i].listener (_recivier, pAnimation) ; } } } ; ;
//BROADCAST(play, CALL(pAnimation));
	}


	export function createController(pEngine: IEngine, sName?: string, iOptions?:  number ): IAnimationController {
		return new Controller(pEngine, sName, iOptions);
	}
}



























module akra.core.pool.resources {

/* COMMON FUNCTIONS
     ------------------------------------------------------
     */


    function getSupportedFormat(sSemantic: string): IColladaUnknownFormat[];
    function calcFormatStride(pFormat: IColladaUnknownFormat[]):  number ;


// additional

    function printArray(pArr: any[], nRow:  number , nCol:  number ): string;
    function sortArrayByProperty(pData: any[], sProperty: string): any[];

//xml

    function stringData(pXML: Element): string;
    function attr(pXML: Element, sName: string): string;
    function firstChild(pXML: Element, sTag?: string): Element;




// globals

    var pSupportedVertexFormat: IColladaUnknownFormat[];
    var pSupportedTextureFormat: IColladaUnknownFormat[];
    var pSupportedColorFormat: IColladaUnknownFormat[];
    var pSupportedWeightFormat: IColladaUnknownFormat[];
    var pSupportedJointFormat: IColladaUnknownFormat[];
    var pSupportedInvBindMatrixFormat: IColladaUnknownFormat[];
    var pSupportedInterpolationFormat: IColladaUnknownFormat[];
    var pSupportedInputFormat: IColladaUnknownFormat[];
    var pSupportedOutputFormat: IColladaUnknownFormat[];
    var pSupportedTangentFormat: IColladaUnknownFormat[];

    var pFormatStrideTable: IColladaFormatStrideTable;

    export class Collada extends ResourcePoolItem implements ICollada {
        constructor ();

        parse(sXMLData: string, pOptions?: IColladaLoadOptions): bool;

// load(sFilename: string, fnCallback?: IColladaLoadCallback, pOptions?: IColladaLoadOptions): void;

// polygon index convertion

        private polygonToTriangles(pXML: Element, iStride:  number ):  number [];
        private polylistToTriangles(pXML: Element, iStride:  number ):  number [];
        private trifanToTriangles(pXML: Element, iStride:  number ):  number [];
        private tristripToTriangles(pXML: Element, iStride:  number ):  number [];

// xml    

        private eachNode(pXMLList: NodeList, fnCallback: IXMLExplorer, nMax?:  number ): void;
        private eachChild(pXML: Element, fnCallback: IXMLExplorer): void;
        private eachByTag(pXML: Element, sTag: string, fnCallback: IXMLExplorer, nMax?:  number ): void;

// Akra convertions functions

        private findNode(pNodes: IColladaNode[], sNode?: string, fnNodeCallback?: (pNode: IColladaNode) => void): IColladaNode;


// helper functions

        private COLLADATranslateMatrix(pXML: Element): IMat4;
        private COLLADARotateMatrix(pXML: Element): IMat4;
        private COLLADAScaleMatrix(pXML: Element): IMat4;
        private COLLADAData(pXML: Element): any;
        private COLLADAGetSourceData(pSource: IColladaSource, pFormat: IColladaUnknownFormat[]): IColladaArray;

// common
// -----------------------------------------------------------

        private COLLADATransform(pXML: Element, id?: string): IColladaTransform;
        private COLLADANewParam(pXML: Element): IColladaNewParam;
        private COLLADAAsset(pXML?: Element): IColladaAsset;
        private COLLADALibrary(pXML: Element, pTemplate: IColladaLibraryTemplate): IColladaLibrary;

// geometry

        private COLLADAAccessor(pXML: Element): IColladaAccessor;
        private COLLADAInput(pXML: Element, iOffset?:  number ): IColladaInput;
        private COLLADATechniqueCommon(pXML: Element): IColladaTechniqueCommon;
        private COLLADASource(pXML: Element): IColladaSource;
        private COLLADAVertices(pXML: Element): IColladaVertices;
        private COLLADAJoints(pXML: Element): IColladaJoints;
        private COLLADAPolygons(pXML: Element, sType: string): IColladaPolygons;
        private COLLADAVertexWeights(pXML: Element): IColladaVertexWeights;
        private COLLADAMesh(pXML: Element): IColladaMesh;
        private COLLADAGeometrie(pXML: Element): IColladaGeometrie;
        private COLLADASkin(pXML: Element): IColladaSkin;
        private COLLADAController(pXML: Element): IColladaController;

// images
// 
        private COLLADAImage(pXML: Element): IColladaImage;

// effects

        private COLLADASurface(pXML: Element): IColladaSurface;
        private COLLADATexture(pXML: Element): IColladaTexture;
        private COLLADASampler2D(pXML: Element): IColladaSampler2D;
        private COLLADAPhong(pXML: Element): IColladaPhong;
        private COLLADAEffectTechnique(pXML: Element): IColladaEffectTechnique;
        private COLLADAProfileCommon(pXML: Element): IColladaProfileCommon;
        private COLLADAEffect(pXML: Element): IColladaEffect;

//materials

        private COLLADAMaterial(pXML: Element): IColladaMaterial;

// scene

        private COLLADANode(pXML: Element, iDepth?:  number ): IColladaNode;
        private COLLADAVisualScene(pXML: Element): IColladaVisualScene;
        private COLLADABindMaterial(pXML: Element): IColladaBindMaterial;
        private COLLADAInstanceEffect(pXML: Element): IColladaInstanceEffect;
        private COLLADAInstanceController(pXML: Element): IColladaInstanceController;
        private COLLADAInstanceGeometry(pXML: Element): IColladaInstanceGeometry;
        private COLLADAInstanceCamera(pXML: Element): IColladaInstanceCamera;
        private COLLADAInstanceLight(pXML: Element): IColladaInstanceLight;

// directly load <visual_scene> from <instance_visual_scene> from <scene>.
        private COLLADAScene(pXML?: Element): IColladaVisualScene;

//lighting
        private COLLADALight(pXML: Element): IColladaLight;

//camera
        private COLLADAPerspective(pXML: Element): IColladaPerspective;
        private COLLADAOptics(pXML: Element): IColladaOptics;
        private COLLADACamera(pXML: Element): IColladaCamera;

// animation

        private COLLADAAnimationSampler(pXML: Element): IColladaAnimationSampler;
        private COLLADAAnimationChannel(pXML: Element): IColladaAnimationChannel;
        private COLLADAAnimation(pXML: Element): IColladaAnimation;


// collada mapping

        private source(sUrl: string): IColladaEntry;
        private link(sId: string, pTarget: IColladaEntry): void;
        private link(pEntry: IColladaEntry): void;
        private target(sPath: string): IColladaTarget;

//animation 

        private buildAnimationTrack(pChannel: IColladaAnimationChannel): IAnimationTrack;
        private buildAnimationTrackList(pAnimationData: IColladaAnimation): IAnimationTrack[];
        private buildAnimation(pAnimationData: IColladaAnimation): IAnimation;
        private buildAnimations(pAnimationsList?: IAnimation[]): IAnimation[];

// common

        private buildAssetTransform(pNode: ISceneNode, pAsset?: IColladaAsset): ISceneNode;
        private buildDeclarationFromAccessor(sSemantic: string, pAccessor: IColladaAccessor): IVertexElementInterface[];

// materials & meshes

        private buildDefaultMaterials(pMesh: IMesh): IMesh;
        private buildMaterials(pMesh: IMesh, pGeometryInstance: IColladaInstanceGeometry): IMesh;
        private buildSkeleton(pSkeletonsList: string[]): ISkeleton;
        private buildMesh(pGeometryInstance: IColladaInstanceGeometry): IMesh;
        private buildSkinMesh(pControllerInstance: IColladaInstanceController): IMesh;

        private buildMeshInstance(pGeometries: IColladaInstanceGeometry[], pSceneNode?: ISceneNode): IMesh[];
        private buildSkinMeshInstance(pControllers: IColladaInstanceController[], pSceneNode?: ISceneNode): IMesh[];
        private buildMeshes(): IMesh[];

// scene

        private buildSceneNode(pNode: IColladaNode, pParentNode: ISceneNode): ISceneNode;
        private buildJointNode(pNode: IColladaNode, pParentNode: ISceneNode): IJoint;
        private buildCamera(pColladaInstanceCamera: IColladaInstanceCamera, pParent: ISceneNode): ICamera;
        private buildNodes(pNodes: IColladaNode[], pParentNode?: ISceneNode): ISceneNode;
        private buildScene(pRootNode: ISceneNode): ISceneNode[];

        private buildInititalPose(pNodes: IColladaNode[], pSkeleton: ISkeleton): IAnimation;
        private buildInitialPoses(pPoseSkeletons?: ISkeleton[]): IAnimation[];

// additional

        private buildComplete(): void;

//---------------------------

        private setOptions(pUserOptions: IColladaLoadOptions): void;
        private setXMLRoot(pXML: Element): void;
        private getXMLRoot(): Element;

        private findMesh(sName: string): IMesh;
        private addMesh(pMesh: IMesh): void;

        private sharedBuffer(pBuffer?: IRenderDataCollection): IRenderDataCollection;
        private prepareInput(pInput: IColladaInput): IColladaInput;

        private isJointsVisualizationNeeded(): bool;
        public  isVisualSceneLoaded(): bool;
        public  isShadowsEnabled(): bool;
        public  isAnimationLoaded(): bool;
        private isSceneNeeded(): bool;
        private isAnimationNeeded(): bool;
        private isPoseExtractionNeeded(): bool;
        private isWireframeEnabled(): bool;
        private getSkeletonsOutput(): ISkeleton[];
        private getVisualScene(): IColladaVisualScene;
        private getImageOptions(): IColladaImageLoadOptions;
        public  getAnimations(): IColladaAnimation[];
        public  getAnimation(i:  number ): IColladaAnimation;
        public  getAsset(): IColladaAsset;


        private isLibraryLoaded(sLib: string): bool;
        private isLibraryExists(sLib: string): bool;
        private getLibrary(sLib: string): IColladaLibrary;
        public  getBasename(): string;
        public  getFilename(): string;
        private setFilename(sName: string): void;

        private checkLibraries(pXML: Element, pTemplates: IColladaLibraryTemplate[]): void;
        private readLibraries(pXML: Element, pTemplates: IColladaLibraryTemplate[]): void;


        static DEFAULT_OPTIONS: IColladaLoadOptions = {
            drawJoints      : false,
            wireframe       : false,
            shadows         : true,
            sharedBuffer    : false,
            animation       : { pose: true },
            scene           : true,
            extractPoses    : true,
            skeletons       : [],
            images          : { flipY: false },

            debug          : false

        };

        private static SCENE_TEMPLATE: IColladaLibraryTemplate[] = [
            {lib : 'library_images',        element : 'image',          loader : "COLLADAImage"         },
            {lib : 'library_effects',       element : 'effect',         loader : "COLLADAEffect"        },
            {lib : 'library_materials',     element : 'material',       loader : "COLLADAMaterial"      },
            {lib : 'library_geometries',    element : 'geometry',       loader : "COLLADAGeometrie"     },
            {lib : 'library_controllers',   element : 'controller',     loader : "COLLADAController"    },
            {lib : 'library_cameras',       element : 'camera',         loader : "COLLADACamera"        },
            {lib : 'library_lights',        element : 'light',          loader : "COLLADALight"         },
            {lib : 'library_visual_scenes', element : 'visual_scene',   loader : "COLLADAVisualScene"   }
        ];

        private static ANIMATION_TEMPLATE: IColladaLibraryTemplate[] = [
            {lib : 'library_animations',    element : 'animation',      loader : "COLLADAAnimation"     }
        ];

        private static COLLADA_MATERIAL_NAMES: string[] = [
            "emission",
            "ambient",
            "diffuse",
            "shininess",
            "reflective",
            "reflectivity",
            "transparent",
            "transparency",
            "specular"
        ];

        /**@inline*/  get modelFormat(): EModelFormats {
            return EModelFormats.COLLADA;
        }

//=======================================================================================

        private _pModel: IModel = null;
        private _pOptions: IColladaLoadOptions = null;

        private _pLinks: IColladaLinkMap = {};
        private _pLib: IColladaLibraryMap = {};
        private _pCache: IColladaCache = { meshMap: {}, sharedBuffer: null };

        private _pAsset: IColladaAsset = null;
        private _pVisualScene: IColladaVisualScene = null;
        private _pAnimations: IColladaAnimation[] = [];

        private _sFilename: string = null;

        private _pXMLRoot: Element = null;

        private _iByteLength:  number  = 0;



        constructor () {
            super();

        }

// polygon index convertion

        get options(): IColladaLoadOptions {
            return this._pOptions;
        }


        isShadowsEnabled(): bool {
            return this._pOptions.shadows;
        }

        private trifanToTriangles(pXML: Element, iStride:  number ):  number [] {
            var pFans2Tri:  number [] = [0, 0, 0];
            var pData:  number [] = [];
            var tmp:  number [] = new Array(iStride), n:  number ;
            var pIndexes:  number [] = [];

            this.eachByTag(pXML, "p", function (pXMLData) {
                n = string2IntArray(stringData(pXMLData), pData);

                for (var i:  number  = 0; i < 3; i++) {
                    retrieve(pData, tmp, iStride, i, 1);
                    for (var j:  number  = 0; j < iStride; ++j) {
                        pIndexes.push(tmp[j]);
                    }
                }


                for (var i:  number  = 3, m = n / iStride; i < m; i++) {
                    pFans2Tri[1] = i - 1;
                    pFans2Tri[2] = i;
                    for (var j:  number  = 0; j < pFans2Tri.length; ++j) {
                        for (var k:  number  = 0; k < iStride; ++k) {
                            pIndexes.push(pData[pFans2Tri[j] * iStride + k]);
                        }
                    }
                }

            });

            return pIndexes;
        }

        private  /**@inline*/  polygonToTriangles(pXML: Element, iStride:  number ):  number [] {
//TODO для невыпуклых многоугольников с самоперечечениями работать будет не верно
            return this.trifanToTriangles(pXML, iStride);
        }

        private tristripToTriangles(pXML: Element, iStride:  number ):  number [] {
            var pStrip2Tri:  number [] = [0, 0, 0];
            var pData:  number [] = [];
            var tmp:  number [] = new Array(iStride), n;
            var pIndexes:  number [] = [];

            this.eachByTag(pXML, "p", function (pXMLData) {
                n = string2IntArray(stringData(pXMLData), pData);

                for (var i:  number  = 0; i < 3; i++) {
                    retrieve(pData, tmp, iStride, i, 1);
                    for (var j:  number  = 0; j < iStride; ++j) {
                        pIndexes.push(tmp[j]);
                    }
                }

                for (var i:  number  = 3, m = n / iStride; i < m; i++) {
                    pStrip2Tri[0] = i - 1;
                    pStrip2Tri[1] = i - 2;
                    pStrip2Tri[2] = i;
                    for (var j:  number  = 0; j < pStrip2Tri.length; ++j) {
                        for (var k:  number  = 0; k < iStride; ++k) {
                            pIndexes.push(pData[pStrip2Tri[j] * iStride + k]);
                        }
                    }
                }
            });

            return pIndexes;
        }

        private polylistToTriangles(pXML: Element, iStride:  number ):  number [] {
            var pXMLvcount: Element = firstChild(pXML, "vcount");
            var pXMLp: Element = firstChild(pXML, "p");
            var pVcount:  number [] = new Array(parseInt(attr(pXML, "count")));
            var pData:  number [],
                pIndexes:  number [];
            var n:  number , h:  number  = 0;
            var tmp = new Array(128);
            var buf = new Array(256);
            var pPoly2Tri = [0, 0, 0];

            string2IntArray(stringData(pXMLvcount), pVcount);

            var nElements:  number  = 0,
                nTotalElement:  number  = 0;

            for (var i:  number  = 0; i < pVcount.length; i++) {
                nElements += pVcount[i];
                nTotalElement += (pVcount[i] - 2) * 3;
            }

            pIndexes = new Array(iStride * nTotalElement);
            pData = new Array(iStride * nElements);

            string2IntArray(stringData(pXMLp), pData);

            for (var i:  number  = 0, m = 0; i < pVcount.length; i++) {
                n = retrieve(pData, tmp, iStride, m, pVcount[i]);

                for (var j:  number  = 0; j < 3; j++) {
                    retrieve(tmp, buf, iStride, j, 1);
                    for (var k:  number  = 0; k < iStride; ++k) {
                        pIndexes[h++] = buf[k];
                    }
                }

                for (var x:  number  = 3, t = n / iStride; x < t; x++) {
                    pPoly2Tri[1] = x - 1;
                    pPoly2Tri[2] = x;
                    for (var j:  number  = 0; j < pPoly2Tri.length; ++j) {
                        for (var k:  number  = 0; k < iStride; ++k) {
                            pIndexes[h++] = pData[(m + pPoly2Tri[j]) * iStride + k];
                        }
                    }
                }

                m += pVcount[i];
            }

            return pIndexes;
        }

//xml

        private eachNode(pXMLList: NodeList, fnCallback: IXMLExplorer, nMax?:  number ): void {
            var n:  number  = pXMLList.length, i:  number ;
            nMax = (isNumber(nMax) ? (nMax < n ? nMax : n) : n);

            n = 0;
            i = 0;

            while (n < pXMLList.length) {
//skip text nodes
                if (pXMLList[n ++].nodeType === Node.TEXT_NODE) {
                    continue;
                }

                var pXMLData: Element = <Element>pXMLList[n - 1];
                fnCallback.call(this, pXMLData, pXMLData.nodeName);

                i ++;

                if (nMax === i) {
                    break;
                }
            }

//        for (var i = 0; i < nMax; i++) {
//            var pXMLData = pXMLList.item(i);
//            var sName = pXMLData.getNodeName();
//            fnCallback(pXMLData, sName);
//        }
        }

        private eachChild(pXML: Element, fnCallback: IXMLExplorer): void {
            this.eachNode(pXML.childNodes, fnCallback);
        }

        private  /**@inline*/  eachByTag(pXML: Element, sTag: string, fnCallback: IXMLExplorer, nMax?:  number ): void {
            this.eachNode(pXML.getElementsByTagName(sTag), fnCallback, nMax);
        }


// akra additional functions

        private findNode(pNodes: IColladaNode[], sNode: string = null, fnNodeCallback: (pNode: IColladaNode) => void = null): IColladaNode {
            var pNode: IColladaNode = null;
            var pRootJoint: IColladaNode = null;

            for (var i = pNodes.length - 1; i >= 0; i--) {
                pNode = pNodes[i];

                if (pNode === null) {
                    continue;
                }

                if (sNode && "#" + pNode.id === sNode) {
                    return pNode;
                }

                if (!isNull(fnNodeCallback)) {
                    fnNodeCallback.call(this, pNode);
                }

                if (pNode.childNodes) {
                    pRootJoint = this.findNode(pNode.childNodes, sNode, fnNodeCallback);

                    if (!isNull(pRootJoint)) {
                        return pRootJoint;
                    }
                }
            }

            return null;
        }


// helper functions

        private COLLADATranslateMatrix(pXML: Element): IMat4 {
            var pData:  number [] = new Array(3);

            string2FloatArray(stringData(pXML), pData);

            return ( Vec3.stackCeil.set(pData) ).toTranslationMatrix();
        }

        private COLLADARotateMatrix(pXML: Element): IMat4 {
            var pData:  number [] = new Array(4);

            string2FloatArray(stringData(pXML), pData);

            return (new Mat4(1)).rotateLeft(pData[3] * math.RADIAN_RATIO,  Vec3.stackCeil.set(pData[0], pData[1], pData[2]) );
        }

        private COLLADAScaleMatrix(pXML: Element): IMat4 {
            var pData:  number [] = new Array(3);

            string2FloatArray(stringData(pXML), pData);

            return new Mat4(pData[0], pData[1], pData[2], 1.0);
        }

        private COLLADAData(pXML: Element): any {
            var sName: string = pXML.nodeName;
            var sData: string = stringData(pXML);

            switch (sName) {
                case "bool":
                    return string2Any(sData, 1, "bool");

                case "int":
                    return string2Any(sData, 1, "int");

                case "float":
                    return string2Any(sData, 1, "float");

                case "float2":
                    return string2Any(sData, 2, "float");

                case "float3":
                    return string2Any(sData, 3, "float");

                case "float4":
                case "color":
                    return string2Any(sData, 4, "float");

                case "rotate":
                    return this.COLLADARotateMatrix(pXML);

                case "translate":
                    return this.COLLADATranslateMatrix(pXML);

                case "scale":
                    return this.COLLADAScaleMatrix(pXML);

                case "bind_shape_matrix":
                case "matrix":
                    return (new Mat4(string2Any(sData, 16, "float"), true)).transpose();

                case "float_array":
                    return string2Any(sData, parseInt(attr(pXML, "count")), "float", true);

                case "int_array":
                    return string2Any(sData, parseInt(attr(pXML, "count")), "int", true);

                case "bool_array":
                    return string2Any(sData, parseInt(attr(pXML, "count")), "bool", true);

                case "Name_array":
                case "name_array":
                case "IDREF_array":
                    return string2Any(sData, parseInt(attr(pXML, "count")), "string", true);

                case "sampler2D":
                    return this.COLLADASampler2D(pXML);

                case "surface":
                    return this.COLLADASurface(pXML);

                default:
                    { logger.setSourceLocation( "resources/Collada.ts" , 626 ); logger.error("unsupported COLLADA data type <" + sName + " />"); } ;
            }

//return null;
        }

        private COLLADAGetSourceData(pSource: IColladaSource, pFormat: IColladaUnknownFormat[]): IColladaArray {

            { logger.setSourceLocation( "resources/Collada.ts" , 634 ); logger.assert(isDefAndNotNull(pSource), "<source /> with expected format ", pFormat, " not founded"); } ;

            var nStride:  number  = calcFormatStride(pFormat);
            var pTech: IColladaTechniqueCommon = pSource.techniqueCommon;

            { logger.setSourceLocation( "resources/Collada.ts" , 639 ); logger.assert(isDefAndNotNull(pTech), "<source /> with id <" + pSource.id + "> has no <technique_common />"); } ;

            var pAccess: IColladaAccessor = pTech.accessor;
            var isFormatSupported: bool;


            if (!(pAccess.stride <= nStride)) {
                { logger.setSourceLocation( "resources/Collada.ts" , 646 ); logger.log(pAccess.stride, "/", nStride); } ;
            }


            { logger.setSourceLocation( "resources/Collada.ts" , 651 ); logger.assert(pAccess.stride <= nStride, "<source /> width id" + pSource.id + " has unsupported stride: " + pAccess.stride); }
                                                                                                           ;

            var fnUnsupportedFormatError = function (): void {
                { logger.setSourceLocation( "resources/Collada.ts" , 654 ); logger.log("expected format: " , pFormat); } ;
                { logger.setSourceLocation( "resources/Collada.ts" , 655 ); logger.log("given format: " , pAccess.params); } ;
                { logger.setSourceLocation( "resources/Collada.ts" , 656 ); logger.error("accessor of <" + pSource.id + "> has unsupported format"); } ;
            }

            for (var i:  number  = 0; i < pAccess.params.length; ++ i) {

                isFormatSupported = false;

//finding name in format names..
                for (var f:  number  = 0; f < pFormat[i].name.length; ++ f) {
                    if ((pAccess.params[i].name || "").toLowerCase() == (pFormat[i].name[f] || "").toLowerCase()) {
                        isFormatSupported = true;
                    }
                }

                if (!isFormatSupported) {
                    fnUnsupportedFormatError();
                }


                isFormatSupported = false;

                for (var f:  number  = 0; f < pFormat[i].type.length; ++f) {
                    if (pAccess.params[i].type.toLowerCase() == pFormat[i].type[f].toLowerCase()) {
                        isFormatSupported = true;
                    }
                }

                if (!isFormatSupported) {
                    fnUnsupportedFormatError();
                }

            }

            return pAccess.data;
        }


// common
// -----------------------------------------------------------

        private COLLADATransform(pXML: Element, id?: string): IColladaTransform {
            var pTransform: IColladaTransform = {
                sid         : attr(pXML, "sid"),
                transform   : String(pXML.nodeName),
                value       : null
            };

            if (isString(id) && isDefAndNotNull(pTransform.sid)) {
                this.link(id + "/" + pTransform.sid, pTransform);
            }
            else {
                this.link(id + "/" + pTransform.transform, pTransform);
            }

            var v4f: IVec4,
                m4f: IMat4;
            var pData:  number [];

            switch (pTransform.transform) {
                case "rotate":

                    pData = new Array(4);
                    string2FloatArray(stringData(pXML), pData);
                    v4f = new Vec4(pData);
/* to radians. */
                    v4f.w *= math.RADIAN_RATIO;
                    pTransform.value = v4f;

                    break;

                case "translate":
                case "scale":

                    pData = new Array(3);
                    string2FloatArray(stringData(pXML), pData);
                    pTransform.value = new Vec3(pData);
                    break;

                case "matrix":

                    m4f = new Mat4;
                    string2FloatArray(stringData(pXML), < number []><any>m4f.data);
                    m4f.transpose();
                    pTransform.value = m4f;

                    break;

                default:
                    { logger.setSourceLocation( "resources/Collada.ts" , 743 ); logger.error("unsupported transform detected: " + pTransform.transform); } ;
            }


            return pTransform;
        }

        private COLLADANewParam(pXML: Element): IColladaNewParam {
            var pParam: IColladaNewParam = {
                sid         : attr(pXML, "sid"),
                annotate    : null,
                semantics   : null,
                modifier    : null,
                value       : null,
                type        : null
            };

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "semantic":
                        pParam.semantics = stringData(pXMLData);
                        break;

                    case "modifier":
                        pParam.modifier = stringData(pXMLData);

                    case "annotate":

                        pParam.annotate = {
                            name  : attr(pXMLData, "name"),
                            value : stringData(pXMLData)
                        };

                    case "float":
                    case "float2":
                    case "float3":
                    case "float4":
                    case "surface":
                    case "sampler2D":
                        pParam.type = sName;
                        pParam.value = this.COLLADAData(pXMLData);
                        break;

                    default:
                        pParam.value = this.COLLADAData(pXMLData);
                }
            });

            this.link(pParam.sid, pParam);

            return pParam;
        }

        private COLLADAAsset(pXML: Element = firstChild(this.getXMLRoot(), "asset")): IColladaAsset {
            var pAsset: IColladaAsset = {
                unit : {
                    meter : 1.0,
                    name  : "meter"
                },

                upAxis   : "Y_UP",
                title    : null,
                created  : null,
                modified : null,

                contributor : {
                    author          : null,
                    authoringTool   : null,
                    comments        : null,
                    copyright       : null,
                    sourceData      : null
                }
            };

            this.eachChild(pXML, (pXMLNode: Element, sName?: string) => {
                var sValue: string = stringData(pXMLNode);

                switch (sName) {
                    case "up_axis":
                        pAsset.upAxis = sValue;
                        break;

                    case "created":
                        pAsset.created = sValue;
                        break;

                    case "modified":
                        pAsset.modified = sValue;
                        break;

                    case "title":
                        pAsset.title = sValue;
                        break;

                    case "contributor":
//TODO contributor
                        break;

                    case "unit":
                        pAsset.unit.meter = parseFloat(attr(pXMLNode, "meter"));
                        pAsset.unit.name = attr(pXMLNode, "name");
                        break;
                }
            });

            return this._pAsset = pAsset;
        }

        private COLLADALibrary(pXML: Element, pTemplate: IColladaLibraryTemplate): IColladaLibrary {
            if (!isDefAndNotNull(pXML)) {
                return null;
            }

            var pLib: IColladaLibrary = <IColladaLibrary>{};
            var pData: IColladaEntry;
            var sTag: string = pTemplate.element;
            var iAutoId:  number  = 0;

            pLib[sTag] = {};

            { logger.setSourceLocation( "resources/Collada.ts" , 863 ); logger.log("[COLLADA [" + this.findResourceName() + "]]", "read library <" + sTag + "/>"); } ;

            this.eachChild(pXML, (pXMLData: Element, sName?: string): void => {
                if (sTag !== sName) {
                    return;
                }

                pData = (<IColladaEntryLoader>((<any>this)[pTemplate.loader]))(pXMLData);

                if (isNull(pData)) {
                    return;
                }

                pLib[sTag][attr(pXMLData, 'id') || (sTag + "_" + (iAutoId ++))] = pData;
            });

            return pLib;
        }


// geometry

        private COLLADAAccessor(pXML: Element): IColladaAccessor {
            var pAccessor: IColladaAccessor = {
                data   : <IColladaArray>this.source(attr(pXML, "source")),
                count  : parseInt(attr(pXML, "count")),
                stride : parseInt(attr(pXML, "stride") || 1),
                params : []
            };


            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                pAccessor.params.push({
                                          name : attr(pXMLData, "name"),
                                          type : attr(pXMLData, "type")
                                      });
            });

            return pAccessor;
        }

//dangerous: the default offset is 0, but collada required this attribute
        private COLLADAInput(pXML: Element, iOffset:  number  = 0): IColladaInput {
            var pInput: IColladaInput = {
                semantics : attr(pXML, "semantic"),
                source    : <IColladaSource>this.source(attr(pXML, "source")),
                offset    : -1,
                set       : attr(pXML, "set")
            };
//pInput.set = (pInput.set ? parseInt(pInput.set) : 0);

            if (!isNull(attr(pXML, "offset"))) {
                pInput.offset = parseInt(attr(pXML, "offset"));
            }

            if (isInt(iOffset) && pInput.offset === -1) {
                pInput.offset = iOffset;
            }

            { logger.setSourceLocation( "resources/Collada.ts" , 922 ); logger.assert(isInt(pInput.offset) && pInput.offset >= 0, "invalid offset detected"); } ;

            return pInput;
        }

        private COLLADATechniqueCommon(pXML: Element): IColladaTechniqueCommon {
            var pTechniqueCommon: IColladaTechniqueCommon = {
                accessor : null,
                perspective: null
            };

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "accessor":
                        pTechniqueCommon.accessor = this.COLLADAAccessor(pXMLData);
                        break;
                    case "perspective":
                        pTechniqueCommon.perspective = this.COLLADAPerspective(pXMLData);
                        break;
                }
            });

            return pTechniqueCommon;
        }

        private COLLADASource(pXML: Element): IColladaSource {
            var pSource: IColladaSource = {
                id               : attr(pXML, "id"),
                name             : attr(pXML, "name"),
                array           : {},
                techniqueCommon : null
            };

            this.link(pSource);

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                var pColladaArray: IColladaArray;
                var id: string;

                switch (sName.toLowerCase()) {
                    case "int_array":
                    case "bool_array":
                    case "float_array":
                    case "idref_array":
                    case "name_array":
                        pColladaArray = <IColladaArray>this.COLLADAData(pXMLData);

                        id = attr(pXMLData, "id");
                        pSource.array[id] = pColladaArray;

                        this.link(id, pColladaArray);

                        break;
                    case "technique_common":
                        pSource.techniqueCommon = this.COLLADATechniqueCommon(pXMLData);
                        break;
                }
            });

            return pSource;
        }

        private COLLADAVertices(pXML: Element): IColladaVertices {
            var pVertices: IColladaVertices = {
                id      : attr(pXML, "id"),
                inputs  : {}
            };


            this.eachByTag(pXML, "input", function (pXMLData) {
                var sSemantic: string = attr(pXMLData, "semantic");
                pVertices.inputs[sSemantic] = this.COLLADAInput(pXMLData);
            });


            { logger.setSourceLocation( "resources/Collada.ts" , 998 ); logger.assert(isDefAndNotNull(pVertices.inputs["POSITION"]), "semantics POSITION must be in the <vertices /> tag"); }
                                                                              ;

            this.link(pVertices);

            return pVertices;
        }

        private COLLADAJoints(pXML: Element): IColladaJoints {
            var pJoints: IColladaJoints = {
                inputs : {}
            };

            var pMatrixArray: IMat4[];
            var iCount:  number ;
            var pInvMatrixArray: Float32Array;

            this.eachByTag(pXML, "input", (pXMLData: Element): void => {
                switch (attr(pXMLData, "semantic")) {
                    case "JOINT":
                        pJoints.inputs["JOINT"] = this.COLLADAInput(pXMLData);
                        break;

                    case "INV_BIND_MATRIX":
                        pJoints.inputs["INV_BIND_MATRIX"] = this.COLLADAInput(pXMLData);
                        if (this.options.debug) {
                            console.log(pJoints.inputs["INV_BIND_MATRIX"]);
                        }
                        break;

                    default:
                        { logger.setSourceLocation( "resources/Collada.ts" , 1028 ); logger.error("semantics are different from JOINT/INV_BIND_MATRIX is not supported in the <joints /> tag"); } ;
                }
            });


            for (var sInput in pJoints.inputs) {
                this.prepareInput(pJoints.inputs[sInput]);

                if (sInput === "INV_BIND_MATRIX") {

                    pInvMatrixArray = new Float32Array(pJoints.inputs[sInput].array);
                    iCount = pInvMatrixArray.length / 16;
                    pMatrixArray = new Array(iCount);

                    for (var j:  number  = 0, n:  number  = 0; j < pInvMatrixArray.length; j += 16) {
                        pMatrixArray[n++] =
                            (new Mat4(
                                new Float32Array(pInvMatrixArray.buffer, j * Float32Array.BYTES_PER_ELEMENT, 16), true)
                            ).transpose();
                    }

                    pJoints.inputs[sInput].array = pMatrixArray;
                }
            }

            return pJoints;
        }

        private COLLADAPolygons(pXML: Element, sType: string): IColladaPolygons {
            var pPolygons: IColladaPolygons = {
/*потоки данных*/
                inputs    : [],
/*индексы*/
                p         : null,
/*идентификатор материала*/
                material  : attr(pXML, "material"),
/*имя (встречается редко, не используется)*/
                name      : null,
/*полное число индексов*/
                count     : parseInt(attr(pXML, "count"))
            };

            var iOffset:  number  = 0, n:  number  = 0;
            var iCount:  number  = parseInt(attr(pXML, "count"));
            var iStride:  number  = 0;

            this.eachByTag(pXML, "input", (pXMLData: Element): void => {
                pPolygons.inputs.push(this.COLLADAInput(pXMLData, iOffset));
                iOffset ++;
            });

            sortArrayByProperty(pPolygons.inputs, "iOffset");

            for(var i:  number  = 0; i < pPolygons.inputs.length; ++ i) {
                iStride = math.max((<IColladaInput>pPolygons.inputs[i]).offset + 1, iStride);
            }

            { logger.setSourceLocation( "resources/Collada.ts" , 1080 ); logger.assert(iStride > 0, "Invalid offset detected."); } ;

            switch (sType) {
                case "polylist":
                    pPolygons.p = this.polylistToTriangles(pXML, iStride);
                    break;

                case "polygons":
                    pPolygons.p = this.polygonToTriangles(pXML, iStride);

                    this.eachByTag(pXML, "ph", (pXMLData: Element): void => {
                        { logger.setSourceLocation( "resources/Collada.ts" , 1091 ); logger.error("unsupported polygon[polygon] subtype founded: <ph>"); } ;
                    });

                    break;

                case "triangles":
                    pPolygons.p = new Array(3 * iCount * iStride);

                    this.eachByTag(pXML, "p", (pXMLData: Element): void => {
                        n += string2IntArray(stringData(pXMLData), pPolygons.p, n);
                    });

                    break;
                case "trifans":
                    pPolygons.p = this.trifanToTriangles(pXML, iStride);
                    break;

                case "tristrips":
                    pPolygons.p = this.tristripToTriangles(pXML, iStride);
                    break;

                default:
                    { logger.setSourceLocation( "resources/Collada.ts" , 1113 ); logger.error("unsupported polygon[" + sType + "] type founded"); } ;
            }

            if (!isDef(pPolygons.type)) {
                pPolygons.type = EPrimitiveTypes.TRIANGLELIST;
            }

            return pPolygons;
        }

        private COLLADAVertexWeights(pXML: Element): IColladaVertexWeights {
            var pVertexWeights: IColladaVertexWeights = {
                count       : parseInt(attr(pXML, "count")),
                inputs      : [],
                weightInput : null,
                vcount      : null,
                v           : null
            };

            var iOffset:  number  = 0;
            var pInput: IColladaInput;

            this.eachByTag(pXML, "input", (pXMLData: Element): void => {
                pInput = this.COLLADAInput(pXMLData, iOffset);

                if (pInput.semantics === "WEIGHT") {
                    pVertexWeights.weightInput = pInput;
                }

                pVertexWeights.inputs.push(pInput);
                iOffset ++;
            });

            var pVcountData:  number [],
                pVData:  number [];

            pVcountData = new Array(pVertexWeights.count);
            string2IntArray(stringData(firstChild(pXML, "vcount")), pVcountData);
            pVertexWeights.vcount = pVcountData;


            var n:  number  = 0;

            for (var i:  number  = 0; i < pVcountData.length; ++i) {
                n += pVcountData[i];
            }

            n *= pVertexWeights.inputs.length;

            { logger.setSourceLocation( "resources/Collada.ts" , 1163 ); logger.assert(pVertexWeights.inputs.length === 2, "more than 2 inputs in <vertex_weights/> not supported currently"); }
                                                                                           ;

            pVData = new Array(n);
            string2IntArray(stringData(firstChild(pXML, "v")), pVData);
            pVertexWeights.v = pVData;

            return pVertexWeights;
        }

        private COLLADAMesh(pXML: Element): IColladaMesh {
            var pMesh: IColladaMesh = {
                sources   : [],
                polygons  : []
            };

            var id: string;
            var pPolygons: IColladaPolygons,
                pVertices: IColladaVertices,
                pPos: IColladaInput;

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "source":
                        pMesh.sources.push(this.COLLADASource(pXMLData));
                        break;

                    case "vertices":
                        pVertices = this.COLLADAVertices(pXMLData);
                        break;

                    case "lines":
                    case "linestrips":
                    case "tristrips":
                    case "trifans":
                    case "triangles":
                    case "polygons":
                    case "polylist":
                        pPolygons = this.COLLADAPolygons(pXMLData, sName);

                        for (var i:  number  = 0; i < pPolygons.inputs.length; ++i) {
                            pPos = null;

                            if (pPolygons.inputs[i].semantics == "VERTEX") {
                                if (pPolygons.inputs[i].source.id == pVertices.id) {
                                    pPos = pVertices.inputs["POSITION"];

                                    pPolygons.inputs[i].source = pPos.source;
                                    pPolygons.inputs[i].semantics = pPos.semantics;
                                }
                                else {
                                    { logger.setSourceLocation( "resources/Collada.ts" , 1213 ); logger.error("<input /> with semantic VERTEX must refer to <vertices /> tag in same mesh."); } ;
                                }
                            }

                            this.prepareInput(pPolygons.inputs[i]);
                        }

                        pMesh.polygons.push(pPolygons);
                        break;
                }
            });

            return pMesh;
        }

        private COLLADAGeometrie(pXML: Element): IColladaGeometrie {
            var pGeometrie: IColladaGeometrie = {
                id         : attr(pXML, "id"),
                name       : attr(pXML, "name"),
                mesh       : null,
                convexMesh : null,
                spline     : null,
            };

            var pXMLData: Element = firstChild(pXML);
            var sName: string = pXMLData.nodeName;

            if (sName == "mesh") {
                pGeometrie.mesh = this.COLLADAMesh(pXMLData);
            }

            this.link(pGeometrie);

            return pGeometrie;
        }

        private COLLADASkin(pXML: Element): IColladaSkin {
            var pSkin: IColladaSkin = {
                shapeMatrix   : <IMat4>this.COLLADAData(firstChild(pXML, "bind_shape_matrix")),
                sources       : [],
                geometry      : <IColladaGeometrie>this.source(attr(pXML, "source")),
                joints        : null,
                vertexWeights : null

//TODO:  add other parameters to skin section
            }

            var pVertexWeights: IColladaVertexWeights,
                pInput: IColladaInput;

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "source":
                        pSkin.sources.push(this.COLLADASource(pXMLData));
                        break;

                    case "joints":
                        pSkin.joints = this.COLLADAJoints(pXMLData);
                        break;

                    case "vertex_weights":
                        pVertexWeights = this.COLLADAVertexWeights(pXMLData);

                        for (var i = 0; i < pVertexWeights.inputs.length; ++ i) {
                            pInput = this.prepareInput(pVertexWeights.inputs[i]);
                        }

                        pSkin.vertexWeights = pVertexWeights;
                        break;
                }
            });

            return pSkin;
        }

        private COLLADAController(pXML: Element): IColladaController {
            var pController: IColladaController = {
                name  : attr(pXML, "name"),
                id    : attr(pXML, "id"),
                skin  : null,
                morph : null
            };

            var pXMLData: Element = firstChild(pXML, "skin");

            if (!isNull(pXMLData)) {
                pController.skin = this.COLLADASkin(pXMLData);
            }
            else {
                { logger.setSourceLocation( "resources/Collada.ts" , 1302 ); logger.warning("Founded controller without skin element!"); } ;
                return null;
            }

            this.link(pController);

            return pController;
        }

// images

        private COLLADAImage(pXML: Element): IColladaImage {
            var pImage: IColladaImage = {
                id        : attr(pXML, "id"),
                name      : attr(pXML, "name"),

                format    : attr(pXML, "format"),
/*-1 == auto detection*/
                height    : parseInt(attr(pXML, "height") || -1),
                width     : parseInt(attr(pXML, "width") || -1),

/*only 2D images supported*/
                depth     : 1,
                data      : null,
                path      : null
            };

            var sFilename: string = this.getFilename();
            var sPath: string = null;
            var pXMLInitData: Element = firstChild(pXML, "init_from"),
                pXMLData: Element;

            if (isDefAndNotNull(pXMLInitData)) {
                sPath = stringData(pXMLInitData);

//modify path to the textures relative to a given file
// if (!isNull(sFilename)) {
//     if (!path.info(sPath).isAbsolute()) {
//         sPath = path.info(sFilename).dirname + "/" + sPath;
//     }
// }
// console.log("collada deps image: ", path.normalize(sPath));
// pImage.path = path.normalize(sPath);
                pImage.path = path.resolve(sPath, sFilename);
// console.log("collada deps image >>> ", pImage.path);
            }
            else if (isDefAndNotNull(pXMLData = firstChild(pXML, "data"))) {
                { logger.setSourceLocation( "resources/Collada.ts" , 1347 ); logger.error("image loading from <data /> tag unsupported yet."); } ;
            }
            else {
                { logger.setSourceLocation( "resources/Collada.ts" , 1350 ); logger.error("image with id: " + pImage.id + " has no data."); } ;
            }

            this.link(pImage);

            return pImage;
        }

// effects

        private COLLADASurface(pXML: Element): IColladaSurface {
            var pSurface: IColladaSurface = {
                initFrom : stringData(firstChild(pXML, "init_from"))
//, format: stringData(firstChild(pXML, "format"))
            }

            return pSurface;
        }

        private COLLADATexture(pXML: Element): IColladaTexture {
            if (!isDefAndNotNull(pXML)) {
                return null;
            }

            var pTexture: IColladaTexture = {
                texcoord : attr(pXML, "texcoord"),
                sampler  : <IColladaNewParam>this.source(attr(pXML, "texture")),
                surface  : null,
                image    : null
            };

            if (!isNull(pTexture.sampler) && isDefAndNotNull(pTexture.sampler.value)) {
                pTexture.surface = <IColladaNewParam>this.source((<IColladaSampler2D>pTexture.sampler.value).source);
            }

            if (!isNull(pTexture.surface)) {
                var pImage: IColladaImage = <IColladaImage>this.source((<IColladaSurface>pTexture.surface.value).initFrom);
                pTexture.image = pImage;

                { logger.setSourceLocation( "resources/Collada.ts" , 1389 ); logger.log("[COLLADA [" + this.findResourceName() + "]]", "load texture \"" + pImage.path + "\"..."); } ;

                var pTex: ITexture = <ITexture>this.getManager().texturePool.loadResource(pImage.path);
// var pModel = this;
// pTex.bind("loaded", () => {
//     LOG(pTex.findResourceName(), "loaded", pModel.isResourceLoaded());
//     })
                this.sync(pTex, EResourceItemEvents.LOADED);

//FIX THIS
                pTex.setFilter(ETextureParameters.MAG_FILTER, ETextureFilters.LINEAR);
                pTex.setFilter(ETextureParameters.MIN_FILTER, ETextureFilters.LINEAR_MIPMAP_LINEAR);

                pTex.setWrapMode(ETextureParameters.WRAP_S, ETextureWrapModes.REPEAT);
                pTex.setWrapMode(ETextureParameters.WRAP_T, ETextureWrapModes.REPEAT);
            }

            return pTexture;
        }

        private COLLADASampler2D(pXML: Element): IColladaSampler2D {
            var pSampler: IColladaSampler2D = {
                source    : stringData(firstChild(pXML, "source")),
                wrapS     : stringData(firstChild(pXML, "wrap_s")),
                wrapT     : stringData(firstChild(pXML, "wrap_t")),
                minFilter : stringData(firstChild(pXML, "minfilter")),
                mipFilter : stringData(firstChild(pXML, "mipfilter")),
                magFilter : stringData(firstChild(pXML, "magfilter"))
            };

            return pSampler;
        }

        private COLLADAPhong(pXML: Element): IColladaPhong {
            var pMat: IColladaPhong = {
                diffuse             : new Color(0.),
                specular            : new Color(0.),
                ambient             : new Color(0.),
                emissive            : new Color(0.),
                shininess           : 0.0,

                reflective          : new Color(0.),
                reflectivity        : 0.0,
                transparent         : new Color(0.),
                transparency        : 0.0,

                indexOfRefraction   : 0.0,

                textures: {
                    diffuse     : null,
                    specular    : null,
                    ambient     : null,
                    emissive    : null,
                    normal      : null
                }
            };

            var pXMLData: Element;
            var pList: string[] = Collada.COLLADA_MATERIAL_NAMES;

            for (var i:  number  = 0; i < pList.length; i++) {
                var csComponent: string = pList[i];

                pXMLData = firstChild(pXML, csComponent);

//emission --> emissive
//emission does not exists in akra engine materials

                if (csComponent === "emission") {
                    csComponent = "emissive";
                }

                if (pXMLData) {
                    this.eachChild(pXMLData, (pXMLData: Element, sName?: string) => {

                        switch (sName) {
                            case "float":
                                pMat[csComponent] = < number >this.COLLADAData(pXMLData);
                                break;

                            case "color":
                                pMat[csComponent].set(<IColorValue>this.COLLADAData(pXMLData));
                                break;

                            case "texture":
                                pMat.textures[csComponent] = this.COLLADATexture(pXMLData);
                        }
                    });

                }
            }

// correct shininess
            pMat.shininess *= 10.0;

            return pMat;
        }

        private COLLADAEffectTechnique(pXML: Element): IColladaEffectTechnique {
            var pTech: IColladaEffectTechnique = {
                sid   : attr(pXML, "sid"),
                type  : null,
                value : null
            };

            var pValue: Element = firstChild(pXML);

            pTech.type = pValue.nodeName;

            switch (pTech.type) {
//FIXME: at now, all materials draws similar..
                case "blinn":
                case "lambert":
                    { logger.setSourceLocation( "resources/Collada.ts" , 1502 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "<blinn /> or <lambert /> material interprated as phong"); } ;
                case "phong":
                    pTech.value = this.COLLADAPhong(pValue);
                    break;

                default:
                    { logger.setSourceLocation( "resources/Collada.ts" , 1508 ); logger.error("unsupported technique <" + pTech.type + " /> founded"); } ;
            }

//finding normal maps like this
/*
                <technique profile=​"OpenCOLLADA3dsMax">​
                    <bump bumptype=​"HEIGHTFIELD">​
                      <texture texture=​"Default_Material_normals2_png-sampler" texcoord=​"CHANNEL1">​</texture>​
                    </bump>​
                </technique>​
            */


            var pXMLExtra: Element = firstChild(pXML, "extra");

            if (isDefAndNotNull(pXMLExtra)) {
                var pXMLTech: Element = firstChild(pXMLExtra, "technique");
                if (isDefAndNotNull(pXMLTech)) {
                    var pXMLBump: Element = firstChild(pXMLTech, "bump");
                    if (isDefAndNotNull(pXMLBump) && attr(pXMLBump, "bumptype") === "HEIGHTFIELD") {
                        (<IColladaPhong>pTech.value).textures.normal = this.COLLADATexture(firstChild(pXMLBump, "texture"));
// LOG(pTech.value);
                    }
                }
            }

            this.link(pTech.sid, pTech);

            return pTech;
        }

        private COLLADAProfileCommon(pXML: Element): IColladaProfileCommon {
            var pProfile: IColladaProfileCommon = {
                technique : null,
                newParam  : {}
            };

            this.eachByTag(pXML, "newparam", (pXMLData: Element): void => {
                pProfile.newParam[attr(pXMLData, "sid")] = this.COLLADANewParam(pXMLData);
            })

            pProfile.technique = this.COLLADAEffectTechnique(firstChild(pXML, "technique"));

            return pProfile;
        }

        private COLLADAEffect(pXML: Element): IColladaEffect {
            var pEffect: IColladaEffect = {
                id             : attr(pXML, "id"),
                profileCommon  : null
            };

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName.toLowerCase()) {
                    case "profile_common":
                        pEffect.profileCommon = this.COLLADAProfileCommon(pXMLData);
                        pEffect.profileCommon.technique.value.name = pEffect.id;
                        break;
                    default:
                        { logger.setSourceLocation( "resources/Collada.ts" , 1566 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "<" + sName + " /> unsupported in effect section"); } ;
                }
            });

            this.link(pEffect);

            return pEffect;
        }


//materials

        private COLLADAMaterial(pXML: Element): IColladaMaterial {
            var pMaterial: IColladaMaterial = {
                id             : attr(pXML, "id"),
                name           : attr(pXML, "name"),
                instanceEffect : this.COLLADAInstanceEffect(firstChild(pXML, "instance_effect"))
            };

            this.link(pMaterial);

            return pMaterial;
        }

// scene

        private COLLADANode(pXML: Element, iDepth:  number  = 0): IColladaNode {
            var pNode: IColladaNode = {
                id              : attr(pXML, "id"),
                sid             : attr(pXML, "sid"),
                name            : attr(pXML, "name") || "unknown",
                type            : attr(pXML, "type"),
                layer           : attr(pXML, "layer"),
                transform       : new Mat4(1),
                geometry        : [],
                controller      : [],
                childNodes      : [],
                camera          : [],
                depth           : iDepth,
                transforms      : [],
/*<! узел, в котором будет хранится ссылка на реальный игровой нод, построенный по нему*/
                constructedNode : null
            };

            var m4fMatrix: IMat4;
            var sType: string;
            var id: string, sid: string;

            this.link(pNode);

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "rotate":
                    case "matrix":
                    case "translate":
                    case "scale":
                        pNode.transforms.push(this.COLLADATransform(pXMLData, pNode.id));
                        pNode.transform.multiply(<IMat4>this.COLLADAData(pXMLData));
                        break;

                    case "instance_geometry":
                        pNode.geometry.push(this.COLLADAInstanceGeometry(pXMLData));
                        break;

                    case "instance_controller":
                        pNode.controller.push(this.COLLADAInstanceController(pXMLData));
                        break;

                    case "instance_camera":
                        pNode.camera.push(this.COLLADAInstanceCamera(pXMLData));
                        break;

                    case "node":
                        pNode.childNodes.push(this.COLLADANode(pXMLData, iDepth + 1));
                        break;
                }
            });

//TODO: do not load empty nodes..
// if (!pNode.pGeometry.length && 
//     !pNode.pController.length && 
//     !pNode.pChildNodes.length) {
//     return null;
// }

            return pNode;
        }

        private COLLADAVisualScene(pXML: Element): IColladaVisualScene {
            var pNode: IColladaNode;
            var pScene: IColladaVisualScene = {
                id     : attr(pXML, "id"),
                name   : attr(pXML, "name"),
                nodes : []
            };

            this.link(pScene);

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "node":
                        pNode = this.COLLADANode(pXMLData);

                        if (isDefAndNotNull(pNode)) {
                            pScene.nodes.push(pNode);
                        }

                        break;
                }
            });

            { logger.setSourceLocation( "resources/Collada.ts" , 1676 ); logger.log("[COLLADA [" + this.findResourceName() + "]]", "visual scene loaded."); } ;

            return pScene;
        }

        private COLLADABindMaterial(pXML: Element): IColladaBindMaterial {
            if (!isDefAndNotNull(pXML)) {
                return null;
            }

            var pMaterials: IColladaBindMaterial = {};
            var pMat: IColladaInstanceMaterial = null;
            var pSourceMat: IColladaMaterial = null;
            var pTech: Element = firstChild(pXML, "technique_common");

            this.eachByTag(pTech, "instance_material", (pInstMat: Element): void => {

                pSourceMat = <IColladaMaterial>this.source(attr(pInstMat, "target"));

                pMat = {
// url         : pSourceMat.instanceEffect.url,
                    target      : attr(pInstMat, "target"),
                    symbol      : attr(pInstMat, "symbol"),
                    material    : pSourceMat,
                    vertexInput : <IColladaBindVertexInputMap>{}
                };

                this.eachByTag(pInstMat, "bind_vertex_input", (pXMLVertexInput: Element): void => {
                    var sInputSemantic: string = attr(pXMLVertexInput, "input_semantic");

                    if (sInputSemantic !== "TEXCOORD") {
                        { logger.setSourceLocation( "resources/Collada.ts" , 1707 ); logger.error("unsupported vertex input semantics founded: " + sInputSemantic); } ;
                    }


                    var sSemantic: string = attr(pXMLVertexInput, "semantic");
                    var iInputSet:  number  = parseInt(attr(pXMLVertexInput, "input_set"));

                    pMat.vertexInput[sSemantic] = {
                        semantics       : sSemantic,
                        inputSet        : iInputSet,
                        inputSemantic   : sInputSemantic
                    };
                });

                pMaterials[pMat.symbol] = pMat;
            });

            return pMaterials;
        }

        private COLLADAInstanceEffect(pXML: Element): IColladaInstanceEffect {
            var pInstance: IColladaInstanceEffect = {
                parameters    : {},
                techniqueHint : <StringMap>{},
                effect        : null
            };

/*
                Exmaple for <instance_effect /> :
            
                <instance_effect url="CarPaint">
                    <technique_hint profile="CG" platform="PS3" ref="precalc_texture"/>
                    <setparam ref="diffuse_color">
                        <float3> 0.3 0.25 0.85 </float3>
                    </setparam>
                </instance_effect>
            */


            pInstance.effect = <IColladaEffect>this.source(attr(pXML, "url"));

            this.eachByTag(pXML, "technique_hint", (pXMLData: Element): void => {
                pInstance.techniqueHint[attr(pXMLData, "platform")] = attr(pXMLData, "ref");
                { logger.setSourceLocation( "resources/Collada.ts" , 1749 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "<technique_hint /> used, but will be ignored!"); } ;
            });

            this.eachByTag(pXML, "setparam", (pXMLData: Element): void => {
//can be any type
                pInstance.parameters[attr(pXMLData, "ref")] = <any>this.COLLADAData(pXMLData);
                { logger.setSourceLocation( "resources/Collada.ts" , 1755 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "<setparam /> used, but will be ignored!"); } ;
            });

            return pInstance;
        }

        private COLLADAInstanceController(pXML: Element): IColladaInstanceController {
            var pInst: IColladaInstanceController = {
                controller : <IColladaController>this.source(attr(pXML, "url")),
                material   : <IColladaBindMaterial>this.COLLADABindMaterial(firstChild(pXML, "bind_material")),
                skeletons  : []
            };

            this.eachByTag(pXML, "skeleton", (pXMLData: Element): void => {
//cut # symbol from skeleton name
                pInst.skeletons.push(stringData(pXMLData).substr(1));
            });

            return pInst;
        }

        private COLLADAInstanceGeometry(pXML: Element): IColladaInstanceGeometry {
            var pInst: IColladaInstanceGeometry = {
                geometry : <IColladaGeometrie>this.source(attr(pXML, "url")),
                material : <IColladaBindMaterial>this.COLLADABindMaterial(firstChild(pXML, "bind_material"))
            };

            return pInst;
        }

        private COLLADAInstanceCamera(pXML: Element): IColladaInstanceCamera {
            var pInst: IColladaInstanceCamera = {
                camera: <IColladaCamera>this.source(attr(pXML, "url"))
            };

            return pInst;
        }

        private COLLADAInstanceLight(pXML: Element): IColladaInstanceLight {
            var pInst: IColladaInstanceLight = {
                light: <IColladaLight>this.source(attr(pXML, "url"))
            };

            return pInst;
        }

// directly load <visual_scene> from <instance_visual_scene> from <scene>.
        private COLLADAScene(pXML: Element = firstChild(this.getXMLRoot(), "scene")): IColladaVisualScene {
            var pXMLData: Element = firstChild(pXML, "instance_visual_scene");
            var pScene: IColladaVisualScene = <IColladaVisualScene>this.source(attr(pXMLData, "url"));

            if (isNull(pXMLData) || isNull(pScene)) {
                { logger.setSourceLocation( "resources/Collada.ts" , 1807 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "model has no visual scenes."); } ;
            }

            return this._pVisualScene = pScene;
        }

//camera

        private COLLADAPerspective(pXML: Element): IColladaPerspective {
            var pPerspective: IColladaPerspective = {
                xfov: parseFloat(stringData(firstChild(pXML, "xfov")) || 60.) * math.RADIAN_RATIO,
                yfov: parseFloat(stringData(firstChild(pXML, "yfov")) || 60.) * math.RADIAN_RATIO,
                aspect: parseFloat(stringData(firstChild(pXML, "aspect")) || 4./3.),
                znear: parseFloat(stringData(firstChild(pXML, "znear")) || .1),
                zfar: parseFloat(stringData(firstChild(pXML, "zfar")) || 500.),
            }

            return pPerspective;
        }

        private COLLADAOptics(pXML: Element): IColladaOptics {
            var pOptics: IColladaOptics = {
                techniqueCommon: this.COLLADATechniqueCommon(firstChild(pXML, "technique_common"))
            }

            return pOptics;
        }

        private COLLADACamera(pXML: Element): IColladaCamera {
            var pCamera: IColladaCamera = {
                optics: null,
                id    : attr(pXML, "id")
            };

            pCamera.optics = this.COLLADAOptics(firstChild(pXML, "optics"));

            this.link(pCamera);

            return pCamera;
        }

//light

        private COLLADALight(pXML: Element): IColladaLight {
            return null;
        }

// animation

        private COLLADAAnimationSampler(pXML: Element): IColladaAnimationSampler {
            var pSampler: IColladaAnimationSampler = {
                inputs : {},
                id    : attr(pXML, "id")
            };


            var pInput: IColladaInput;
            var sSemantic: string;

            this.link(pSampler);

            this.eachByTag(pXML, "input", (pXMLData: Element): void => {
                sSemantic = attr(pXMLData, "semantic");

                switch (sSemantic) {
                    case "INPUT":
                    case "OUTPUT":
                    case "INTERPOLATION":
                    case "IN_TANGENT":
                    case "OUT_TANGENT":
                        pInput = this.prepareInput(this.COLLADAInput(pXMLData));
                        pSampler.inputs[sSemantic] = pInput;
                        break;

                    default:
                        { logger.setSourceLocation( "resources/Collada.ts" , 1882 ); logger.error("semantics are different from OUTPUT/INTERPOLATION/IN_TANGENT/OUT_TANGENT is not supported in the <sampler /> tag"); } ;
                }
            });

            return pSampler;
        }

        private COLLADAAnimationChannel(pXML: Element): IColladaAnimationChannel {
            var pChannel: IColladaAnimationChannel = {
                sampler : <IColladaAnimationSampler>this.source(attr(pXML, "source")),
                target  : this.target(attr(pXML, "target"))
            };


            if (isNull(pChannel.target) || isNull(pChannel.target.object)) {
                { logger.setSourceLocation( "resources/Collada.ts" , 1897 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "cound not setup animation channel for <" + attr(pXML, "target") + ">"); } ;
                return null;
            }

            return pChannel;
        }


        private COLLADAAnimation(pXML: Element): IColladaAnimation {
            var pAnimation: IColladaAnimation = {
                id          : attr(pXML, "id"),
                name        : attr(pXML, "name"),
                sources     : [],
                samplers    : [],
                channels    : [],
                animations  : []
            };

            var pChannel: IColladaAnimationChannel;
            var pSubAnimation: IColladaAnimation;

            this.link(pAnimation);

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "source":
                        pAnimation.sources.push(this.COLLADASource(pXMLData));
                        break;

                    case "sampler":
                        pAnimation.samplers.push(this.COLLADAAnimationSampler(pXMLData));
                        break;

                    case "channel":
                        pChannel = this.COLLADAAnimationChannel(pXMLData);

                        if (isDefAndNotNull(pChannel)) {
//this guard for skipping channels with unknown targets
                            pAnimation.channels.push(pChannel);
                        }

                        break;
                    case "animation":
                        pSubAnimation = this.COLLADAAnimation(pXMLData);

                        if (isDefAndNotNull(pSubAnimation)) {
                            pAnimation.animations.push(pSubAnimation);
                        }
                }
            });

            if (pAnimation.channels.length == 0 && pAnimation.animations.length == 0) {
                { logger.setSourceLocation( "resources/Collada.ts" , 1949 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "animation with id \"" + pAnimation.id + "\" skipped, because channels/sub animation are empty"); } ;
                return null;
            }

            { logger.setSourceLocation( "resources/Collada.ts" , 1954 ); logger.assert(pXML.parentNode === firstChild(this.getXMLRoot(), "library_animations"), "sub animations not supported"); }
                                               ;

            this._pAnimations.push(pAnimation);

            return pAnimation;
        }

// collada mapping

        private source(sUrl: string): IColladaEntry {
             if (sUrl.charAt(0) !== "#") {
                sUrl = "#" + sUrl;
            }

            var pElement: IColladaEntry = this._pLinks[sUrl];

            if (!isDefAndNotNull(pElement)) {
                { logger.setSourceLocation( "resources/Collada.ts" , 1971 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "cannot find element with id: " + sUrl + ("\n" + (<any>new Error).stack.split("\n").slice(1).join("\n")) ); } ;
            }

            return pElement || null;
        }


        private link(el: any, pTarget?: IColladaEntry): void {
            var sId: string;

            if (!isString(arguments[0])) {
                pTarget = <IColladaEntry>arguments[0];
                sId = pTarget.id;
            }
            else {
                sId = <string>arguments[0];
            }

            this._pLinks["#" + sId] = pTarget;
        }

//astroBoy_newSkeleton_root/rotateY.ANGLE
//pObject.source: IColladaEntry = astroBoy_newSkeleton_root
//pSource: IColladaTransform = source(astroBoy_newSkeleton_root/rotateY)
//pSource: IColladaTransform = {
//    sid: string;  //rotateY
//    value: IVec4; //<0 1 0 -4.56752>
//    name: string; //rotate
//  }
//
//sValue: string = "ANGLE"
//pObject.object: IColladaTransform = pSource;
//
        private target(sPath: string): IColladaTarget {
            var pObject: IColladaTarget = {value : null};
            var pSource: IColladaTransform;

            var pMatches: string[];
            var sValue: string;

            var iPos:  number ;
            var jPos:  number  = 0;

            iPos = sPath.lastIndexOf("/");

            if (iPos >= 0) {
                pObject.source = this.source(sPath.substr(0, iPos));
            }

            iPos = sPath.lastIndexOf(".");

            if (iPos < 0) {
                iPos = sPath.indexOf("(");
                jPos = -1;
            }

            if (iPos < 0) {
                pObject.object = this.source(sPath);
                return pObject;
            }

            pSource = <IColladaTransform>this.source(sPath.substr(0, iPos));
            sValue = sPath.substr(iPos + jPos + 1);
            pObject.object = pSource;

            if (!pSource) {
                return null;
            }

            switch (sValue) {
                case "X":
                    pObject.value = (<IVec4>pSource.value).x;
                    break;
                case "Y":
                    pObject.value = (<IVec4>pSource.value).y;
                    break;
                case "Z":
                    pObject.value = (<IVec4>pSource.value).z;
                    break;
                case "W":
                    pObject.value = (<IVec4>pSource.value).w;
                    break;
                case "ANGLE":
                    pObject.value = (<IVec4>pSource.value).w;
//<rotate sid="rotateY">0 1 0 -4.56752</rotate>
                    break;
            }

            if (isDefAndNotNull(pObject.value)) {
                return pObject;
            }

            pMatches = sValue.match(/^\((\d+)\)$/);

            if (pMatches) {
                pObject.value = Number(pMatches[1]);
            }

            pMatches = sValue.match(/^\((\d+)\)\((\d+)\)$/)

            if (pMatches) {
//trace(pMatches, '--->',  Number(pMatches[2]) * 4 + Number(pMatches[1]));
//pObject.value = Number(pMatches[2]) * 4 + Number(pMatches[1]);
                pObject.value = Number(pMatches[1]) * 4 + Number(pMatches[2]);
            }

            { logger.setSourceLocation( "resources/Collada.ts" , 2077 ); logger.assert(isDefAndNotNull(pObject.value), "unsupported target value founded: " + sValue); } ;

            return pObject;
        }

// //animation 

        private buildAnimationTrack(pChannel: IColladaAnimationChannel): IAnimationTrack {
            var sNodeId: string = pChannel.target.source.id;
            var sJoint: string = this.source(sNodeId).sid || null;
            var pTrack: IAnimationTrack = null;
            var pSampler: IColladaAnimationSampler = pChannel.sampler;

            { logger.setSourceLocation( "resources/Collada.ts" , 2090 ); logger.assert(isDefAndNotNull(pSampler), "could not find sampler for animation channel"); } ;

            var pInput: IColladaInput = pSampler.inputs["INPUT"];
            var pOutput: IColladaInput = pSampler.inputs["OUTPUT"];
            var pInterpolation: IColladaInput = pSampler.inputs["INTERPOLATION"];

            var pTimeMarks:  number [] = pInput.array;
            var pOutputValues:  number [] = pOutput.array;
            var pFloatArray: Float32Array;

            var pTransform: IColladaTransform = <IColladaTransform>pChannel.target.object
            var sTransform: string = pTransform.transform;
            var v4f: IVec4;
            var pValue: any;
            var nMatrices:  number ;

// if (sJoint == null) {
//     warning('node\'s <' + pChannel.pTarget.pSource.id + '> "sid" attribute is null');
// }

            switch (sTransform) {
                case "translate":
// pTrack = new a.AnimationTranslation(sJoint);

// for (var i = 0, v3f = new Array(3), n; i < pTimeMarks.length; ++ i) {
//     n = i * 3;
//     v3f.X = pOutputValues[i * 3];
//     v3f.Y = pOutputValues[i * 3 + 1];
//     v3f.Z = pOutputValues[i * 3 + 2];
//     pTrack.keyFrame(pTimeMarks[i], [v3f.X, v3f.Y, v3f.Z]);
// };
                    { logger.setSourceLocation( "resources/Collada.ts" , 2121 ); logger.criticalError("TODO: implement animation translation"); } ;
//TODO: implement animation translation
                    break;
                case "rotate":
// v4f = pTransform.pValue;
// pTrack = new a.AnimationRotation(sJoint, [v4f[1], v4f[2], v4f[3]]);

// debug_assert(pOutput.pAccessor.iStride === 1, 
//     "matrix modification supported only for one parameter modification");

// for (var i = 0; i < pTimeMarks.length; ++ i) {
//     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i] / 180.0 * math.PI);
// };
                    { logger.setSourceLocation( "resources/Collada.ts" , 2134 ); logger.criticalError("TODO: implement animation rotation"); } ;
//TODO: implement animation rotation
                    break;
                case "matrix":
                    pValue = pChannel.target.value;
                    if (isNull(pValue)) {
                        pTrack = animation.createTrack(sJoint);
                        nMatrices = pOutputValues.length / 16;
                        pFloatArray = new Float32Array(pOutputValues);

                        { logger.setSourceLocation( "resources/Collada.ts" , 2145 ); logger.assert(nMatrices % 1 === 0.0, "incorrect output length of transformation data (" + pFloatArray.length + ")"); }
                                                                                                                   ;

                        for (var i:  number  = 0; i < nMatrices; i++) {
                            var pFrame: IPositionFrame = new animation.PositionFrame(
                                pTimeMarks[i],
                                (new Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true)).transpose());
                            pTrack.keyFrame(pFrame);
                        }


// i=0;
// var m = (new Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true));
// trace(sFilename,sNodeId,m.toString());
                    }
                    else {
// pTrack = new a.AnimationMatrixModification(sJoint, pValue);

// for (var i = 0; i < pTimeMarks.length; ++i) {
//     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i]);
// }
                        { logger.setSourceLocation( "resources/Collada.ts" , 2165 ); logger.criticalError("TODO: implement animation matrix modification"); } ;
                    }
                    break;
                default:
                    { logger.setSourceLocation( "resources/Collada.ts" , 2169 ); logger.error("unsupported animation typed founeed: " + sTransform); } ;
            }

            if (!isNull(pTrack)) {
                pTrack.targetName = sNodeId;
            }

            return pTrack;
        }

        private buildAnimationTrackList(pAnimationData: IColladaAnimation): IAnimationTrack[] {
            var pSubAnimations: IColladaAnimation[] = pAnimationData.animations;
            var pSubTracks: IAnimationTrack[];
            var pTrackList: IAnimationTrack[] = [];
            var pTrack: IAnimationTrack;
            var pChannels: IColladaAnimationChannel[] = pAnimationData.channels;

            for (var i:  number  = 0; i < pChannels.length; ++i) {
                pTrack = this.buildAnimationTrack(pChannels[i]);
                pTrackList.push(pTrack);
            }


            if (isDefAndNotNull(pSubAnimations)) {
                for (var i:  number  = 0; i < pSubAnimations.length; ++i) {
                    pSubTracks = this.buildAnimationTrackList(pSubAnimations[i]);
                    pTrackList = pTrackList.concat(pSubTracks);
                }
            }

            return pTrackList;
        }

        private buildAnimation(pAnimationData: IColladaAnimation): IAnimation {

            var pTracks: IAnimationTrack[] = this.buildAnimationTrackList(pAnimationData);
            var sAnimation: string = pAnimationData.name || pAnimationData.id || null;
            var pAnimation: IAnimation = animation.createAnimation(sAnimation || this.getBasename());

            for (var i:  number  = 0; i < pTracks.length; i++) {
                pAnimation.push(pTracks[i]);
            }

            return pAnimation;
        }

        private buildAnimations(pAnimationsList: IAnimation[] = []): IAnimation[] {
            var pAnimations: IColladaAnimation[] = this.getAnimations();

            if (isNull(pAnimations)) {
                return null;
            }

            for (var i:  number  = 0; i < pAnimations.length; ++ i) {
                var pAnimation: IAnimation = this.buildAnimation(pAnimations[i]);

                pAnimationsList.push(pAnimation);
            }

            return pAnimationsList;
        }

// common

        private buildAssetTransform(pNode: ISceneNode, pAsset: IColladaAsset = null): ISceneNode {
            pAsset = pAsset || this.getAsset();

            if (isDefAndNotNull(pAsset)) {
                var fUnit:  number  = pAsset.unit.meter;
                var sUPaxis: string = pAsset.upAxis;

                pNode.localScale =  Vec3.stackCeil.set(fUnit) ;

                if (sUPaxis.toUpperCase() == "Z_UP") {
//pNode.addRelRotation([1, 0, 0], -.5 * math.PI);
                    pNode.addRelRotationByEulerAngles(0, -.5 * math.PI, 0);
                }
            }

            return pNode;
        }

        private buildDeclarationFromAccessor(sSemantic: string, pAccessor: IColladaAccessor): IVertexElementInterface[] {
            var pDecl: IVertexElementInterface[] = [];

            for (var i:  number  = 0; i < pAccessor.params.length; ++ i) {
                var sUsage: string = pAccessor.params[i].name;
                var sType: string = pAccessor.params[i].type;

                { logger.setSourceLocation( "resources/Collada.ts" , 2258 ); logger.assert(sType === "float", "Only float type supported for construction declaration from accessor"); } ;

                pDecl.push(VE_FLOAT(sUsage));
            }

            pDecl.push(VE_CUSTOM(sSemantic, EDataTypes.FLOAT, pAccessor.params.length, 0));

            { logger.setSourceLocation( "resources/Collada.ts" , 2265 ); logger.log("[COLLADA [" + this.findResourceName() + "]]", "Automatically constructed declaration: ", createVertexDeclaration(pDecl).toString()); } ;

            return pDecl;
        }


// materials & meshes

        private buildDefaultMaterials(pMesh: IMesh): IMesh {
            var pDefaultMaterial: IMaterial = material.create("default");

            for (var j:  number  = 0; j < pMesh.length; ++j) {
                var pSubMesh: IMeshSubset = pMesh.getSubset(j);
                pSubMesh.material.set(pDefaultMaterial);
                pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
// pSubMesh.renderMethod.effect.addComponent("akra.system.wireframe");
            }

            return pMesh;
        }

        private buildMaterials(pMesh: IMesh, pGeometryInstance: IColladaInstanceGeometry): IMesh {
            var pMaterials: IColladaBindMaterial = pGeometryInstance.material;
            var pEffects: IColladaEffectLibrary = <IColladaEffectLibrary>this.getLibrary("library_effects");

            if (isNull(pEffects) || isNull(pMaterials)) {
                return this.buildDefaultMaterials(pMesh);
            }

            for (var sMaterial in pMaterials) {
                var pMaterialInst: IColladaInstanceMaterial = pMaterials[sMaterial];
                var pInputMap: IColladaBindVertexInputMap = pMaterialInst.vertexInput;
// URL --> ID (#somebody ==> somebody)
                var sEffectId: string = pMaterialInst.material.instanceEffect.effect.id;
                var pEffect: IColladaEffect = pEffects.effect[sEffectId];
                var pPhongMaterial: IColladaPhong = <IColladaPhong>pEffect.profileCommon.technique.value;
                var pMaterial: IMaterial = material.create(sEffectId)

                pMaterial.set(<IMaterialBase>pPhongMaterial);

                for (var j:  number  = 0; j < pMesh.length; ++j) {
                    var pSubMesh: IMeshSubset = pMesh.getSubset(j);

//if (pSubMesh.surfaceMaterial.findResourceName() === sMaterial) {
                    if (pSubMesh.material.name === sMaterial) {
//setup materials
                        pSubMesh.material.set(pMaterial);
//FIXME: remove flex material setup(needs only demo with flexmats..)
// pSubMesh.applyFlexMaterial(sMaterial, pMaterial);


                        pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");

//setup textures
                        for (var sTextureType in pPhongMaterial.textures) {
                            var pColladaTexture: IColladaTexture = pPhongMaterial.textures[sTextureType];

                            if (isNull(pColladaTexture)) {
                                continue;
                            }

                            var pInput: IColladaBindVertexInput = pInputMap[pColladaTexture.texcoord];

                            if (!isDefAndNotNull(pInput)) {
                                continue;
                            }

                            var sInputSemantics: string = pInputMap[pColladaTexture.texcoord].inputSemantic;
                            var pColladaImage: IColladaImage = pColladaTexture.image;


                            var pSurfaceMaterial: ISurfaceMaterial = pSubMesh.surfaceMaterial;
                            var pTexture: ITexture = <ITexture>this.getManager().texturePool.findResource(pColladaImage.path);

                            if (this.getImageOptions().flipY === true) {
                                { logger.setSourceLocation( "resources/Collada.ts" , 2340 ); logger.error("TODO: flipY for image unsupported!"); } ;
                            }

                            var pMatches: string[] = sInputSemantics.match(/^(.*?\w)(\d+)$/i);
                            var iTexCoord:  number  = (pMatches ? parseInt(pMatches[2]) : 0);


                            var iTexture = ESurfaceMaterialTextures[sTextureType.toUpperCase()];

                            if (!isDef(iTexture)) {
                                continue;
                            }
// LOG(iTexture, sTextureType)
                            pSurfaceMaterial.setTexture(iTexture, pTexture, iTexCoord);
// LOG(pSurfaceMaterial);
                        }

                        if (this.isWireframeEnabled()) {
                            pSubMesh.wireframe(true);
                        }
                    }
                }
//trace('try to apply mat:', pMaterial);
            }


            return pMesh;
        }


        private buildSkeleton(pSkeletonsList: string[]): ISkeleton {
            var pSkeleton: ISkeleton = null;

            pSkeleton = model.createSkeleton(pSkeletonsList[0]);

            for (var i:  number  = 0; i < pSkeletonsList.length; ++i) {
                var pJoint: IJoint = <IJoint>(<IColladaNode>this.source(pSkeletonsList[i])).constructedNode;

                { logger.setSourceLocation( "resources/Collada.ts" , 2378 ); logger.assert(scene.isJoint(pJoint), "skeleton node must be joint"); } ;

                pSkeleton.addRootJoint(pJoint);
            }

            this.addSkeleton(pSkeleton);

            return pSkeleton;
        }

        private buildMesh(pGeometryInstance: IColladaInstanceGeometry): IMesh {
            var pMesh: IMesh = null;
            var pGeometry: IColladaGeometrie = pGeometryInstance.geometry;
            var pNodeData: IColladaMesh = pGeometry.mesh;
            var sMeshName: string = pGeometry.id;

            if (isNull(pNodeData)) {
                return null;
            }

            if ((pMesh = this.findMesh(sMeshName))) {
//mesh with same geometry data
                return this.buildMaterials(
                    pMesh.clone(EMeshCloneOptions.GEOMETRY_ONLY | EMeshCloneOptions.SHARED_GEOMETRY),
                    pGeometryInstance);
            }

            var iBegin:  number  = now();

            pMesh = this.getEngine().createMesh(
                sMeshName,
/*|EMeshOptions.RD_ADVANCED_INDEX,  0,*/
                < number >(EMeshOptions.HB_READABLE),
/*shared buffer, if supported*/
                this.sharedBuffer());

            var pPolyGroup: IColladaPolygons[] = pNodeData.polygons;
            var pMeshData: IRenderDataCollection = pMesh.data;

//creating subsets
            for (var i:  number  = 0; i < pPolyGroup.length; ++i) {
                pMesh.createSubset("submesh-" + i, pPolyGroup[i].type);
            }

//filling data
            for (var i:  number  = 0, pUsedSemantics: BoolMap = <BoolMap>{}; i < pPolyGroup.length; ++i) {
                var pPolygons: IColladaPolygons = pPolyGroup[i];

                for (var j:  number  = 0; j < pPolygons.inputs.length; ++j) {
                    var pInput: IColladaInput = pPolygons.inputs[j];
                    var sSemantic: string = pInput.semantics;
                    var pData: ArrayBufferView = <ArrayBufferView><any>pInput.array;
                    var pDecl: IVertexElementInterface[];
                    var pDataExt: Float32Array;

//if (pMesh.buffer.getDataLocation(sSemantic) < 0) {
                    if (!pUsedSemantics[sSemantic]) {
                        pUsedSemantics[sSemantic] = true;

                        switch (sSemantic) {
                            case DeclUsages.POSITION:
                            case DeclUsages.NORMAL:
/*
                                 Extend POSITION and NORMAL from {x,y,z} --> {x,y,z,w};
                                 */


                                pDataExt = new Float32Array((<Float32Array>pData).length / 3 * 4);

                                for (var y = 0, n = 0,  m = 0, l = (<Float32Array>pData).length / 3; y < l; y++, n++) {
                                    pDataExt[n++] = pData[m++];
                                    pDataExt[n++] = pData[m++];
                                    pDataExt[n++] = pData[m++];
                                }

                                pData = pDataExt;
                                pDecl = [VE_FLOAT3(sSemantic), VE_END(16)];
// #if COLLADA_DEBUG == true
//                                 if (this.options.debug) {
//                                     CLD_PRINT(this, "[add vertex data]");
//                                     console.log(pDecl);
//                                     console.log(pData);
//                                 }
// #endif
                                break;
                            case DeclUsages.TEXCOORD:
                            case DeclUsages.TEXCOORD1:
                            case DeclUsages.TEXCOORD2:
                            case DeclUsages.TEXCOORD3:
                            case DeclUsages.TEXCOORD4:
                            case DeclUsages.TEXCOORD5:
//avoiding semantics collisions
                                if(sSemantic === "TEXCOORD"){
                                    sSemantic = "TEXCOORD0";
                                }

                                pDecl = [VE_CUSTOM(sSemantic, EDataTypes.FLOAT, pInput.accessor.stride)];
                                break;
                            default:
                                pDecl = this.buildDeclarationFromAccessor(sSemantic, pInput.accessor);
                                { logger.setSourceLocation( "resources/Collada.ts" , 2475 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "unsupported semantics used: " + sSemantic); } ;
                        }

                        pMeshData.allocateData(pDecl, pData);
                    }
                }
            }

//add indices to data
            for (var i:  number  = 0; i < pPolyGroup.length; ++i) {
                var pPolygons: IColladaPolygons = pPolyGroup[i];
                var pSubMesh: IMeshSubset = pMesh.getSubset(i);
                var pSubMeshData: IRenderData = pSubMesh.data;
                var pIndexDecl: IVertexDeclaration = createVertexDeclaration();
                var pSurfaceMaterial: ISurfaceMaterial = null;
                var pSurfacePool: IResourcePool = null;

                for (var j:  number  = 0; j < pPolygons.inputs.length; ++j) {
                    var iOffset:  number  = pPolygons.inputs[j].offset;
                    var sIndexSemantic: string = DeclUsages.INDEX + iOffset;
//total number of offsets can be less then number of inputs
                    if (!pIndexDecl.hasSemantics(sIndexSemantic)) {
                        pIndexDecl.append(VE_FLOAT(sIndexSemantic));
                    }
                }

                pSubMeshData.allocateIndex(pIndexDecl, new Float32Array(pPolygons.p));

                for (var j:  number  = 0; j < pPolygons.inputs.length; ++j) {
                    var sSemantic: string = pPolygons.inputs[j].semantics;
                    var sIndexSemantics: string = DeclUsages.INDEX + pPolygons.inputs[j].offset;

                    pSubMeshData.index(sSemantic, sIndexSemantics);
                }

// if (!pSubMesh.material) {
//     pSurfacePool = pEngine.getResourceManager().surfaceMaterialPool;
//     pSurfaceMaterial = pSurfacePool.findResource(pPolygons.material);

//     if (!pSurfaceMaterial) {
//         pSurfaceMaterial = pSurfacePool.createResource(pPolygons.material);
//     }

//     pSubMesh.surfaceMaterial = pSurfaceMaterial;
// }

                pSubMesh.material.name = pPolygons.material;
            }

// ASSERT(pMesh.addFlexMaterial("default"), "Could not add flex material to mesh <" + pMesh.name + ">");
// ASSERT(pMesh.setFlexMaterial("default"), "Could not set flex material to mesh <" + pMesh.name + ">");

            pMesh.shadow = this.isShadowsEnabled();

//adding all data to cahce data
            this.addMesh(pMesh);


            return this.buildMaterials(pMesh, pGeometryInstance);
        }

        private buildSkinMesh(pControllerInstance: IColladaInstanceController): IMesh {
            var pController: IColladaController = pControllerInstance.controller;
            var pMaterials: IColladaBindMaterial = pControllerInstance.material;

            var pSkinData: IColladaSkin = pController.skin;

//skin data
            var pBoneList: string[] = <string[]>pSkinData.joints.inputs["JOINT"].array;
            var pBoneOffsetMatrices: IMat4[] = <IMat4[]>pSkinData.joints.inputs["INV_BIND_MATRIX"].array;

            var m4fBindMatrix: IMat4 = pSkinData.shapeMatrix;
            var pVertexWeights: IColladaVertexWeights = pSkinData.vertexWeights;

            var pGeometry: IColladaGeometrie = pSkinData.geometry;

            var pMesh: IMesh;
            var pSkeleton: ISkeleton;
            var pSkin: ISkin;

            pSkeleton = this.buildSkeleton(pControllerInstance.skeletons);
            pMesh = this.buildMesh({geometry : pGeometry, material : pMaterials});

            pSkin = pMesh.createSkin();

            pSkin.setBindMatrix(m4fBindMatrix);
            pSkin.setBoneNames(pBoneList);
            pSkin.setBoneOffsetMatrices(pBoneOffsetMatrices);

            { logger.setSourceLocation( "resources/Collada.ts" , 2564 ); logger.assert(pSkin.setSkeleton(pSkeleton), "Could not set skeleton to skin."); } ;

            if (!pSkin.setVertexWeights(
                < number []>pVertexWeights.vcount,
                new Float32Array(pVertexWeights.v),
                new Float32Array(pVertexWeights.weightInput.array))) {
                { logger.setSourceLocation( "resources/Collada.ts" , 2570 ); logger.error("cannot set vertex weight info to skin"); } ;
            }

            pMesh.setSkin(pSkin);
            pMesh.setSkeleton(pSkeleton);
            pSkeleton.attachMesh(pMesh);

            return pMesh;
        }


        private buildSkinMeshInstance(pControllers: IColladaInstanceController[], pSceneNode: ISceneModel = null): IMesh[] {
            var pMesh: IMesh = null;
            var pMeshList: IMesh[] = [];

            for (var m:  number  = 0; m < pControllers.length; ++m) {
                pMesh = this.buildSkinMesh(pControllers[m]);
                pMeshList.push(pMesh);

                { logger.setSourceLocation( "resources/Collada.ts" , 2589 ); logger.assert(isDefAndNotNull(pMesh), "cannot find instance <" + pControllers[m].url + ">\"s data"); } ;

                if (!isNull(pSceneNode)) {
                    pSceneNode.mesh = pMesh;
                }
            }

            return pMeshList;
        }

        private buildMeshInstance(pGeometries: IColladaInstanceGeometry[], pSceneNode: ISceneModel = null): IMesh[] {
            var pMesh: IMesh = null;
            var pMeshList: IMesh[] = [];

            for (var m:  number  = 0; m < pGeometries.length; ++m) {
                pMesh = this.buildMesh(pGeometries[m]);
                pMeshList.push(pMesh);

                { logger.setSourceLocation( "resources/Collada.ts" , 2607 ); logger.assert(isDefAndNotNull(pMesh), "cannot find instance <" + pGeometries[m].url + ">\"s data"); } ;

                if (!isNull(pSceneNode)) {
                    pSceneNode.mesh = pMesh;
                }
            }

            return pMeshList;
        }

        private buildMeshes(): IMesh[] {
            var pScene: IColladaVisualScene = this.getVisualScene();
            var pMeshes: IMesh[] = [];

            this.findNode(pScene.nodes, null, function (pNode: IColladaNode) {
                var pModelNode: ISceneNode = pNode.constructedNode;

                if (isNull(pModelNode)) {
                    { logger.setSourceLocation( "resources/Collada.ts" , 2625 ); logger.error("you must call buildScene() before call buildMeshes() or file corrupt"); } ;
                    return;
                }

                if (pNode.controller.length == 0 && pNode.geometry.length == 0) {
                    return;
                }

                if (!scene.isModel(pModelNode) && pNode.geometry.length > 0) {
                    pModelNode = pModelNode.scene.createModel(".joint-to-model-link-" + sid());
                    pModelNode.attachToParent(pNode.constructedNode);
                }

                pMeshes.insert(<IMesh[]>this.buildSkinMeshInstance(pNode.controller));
                pMeshes.insert(<IMesh[]>this.buildMeshInstance(pNode.geometry, pModelNode));
            });

            return pMeshes;
        }

// scene

        private buildSceneNode(pNode: IColladaNode, pParentNode: ISceneNode): ISceneNode {
            var pSceneNode: ISceneNode = pNode.constructedNode;
            var pScene: IScene3d = pParentNode.scene;

            if (isDefAndNotNull(pSceneNode)) {
                return pSceneNode;
            }

//FIXME: предпологаем, что мы никогда не аттачим контроллеры к узлам,
// где они найдены, а аттачим  их к руту скелета, на который они ссылаются
/*pNode.pController.length ||*/
            if (pNode.geometry.length > 0) {
                pSceneNode = pScene.createModel();
            }
            else {
                pSceneNode = pScene.createNode();
            }

            { logger.setSourceLocation( "resources/Collada.ts" , 2664 ); logger.assert(pSceneNode.create(), "Can not initialize scene node!"); } ;

            pSceneNode.attachToParent(pParentNode);

            return pSceneNode;
        }

        private buildJointNode(pNode: IColladaNode, pParentNode: ISceneNode): IJoint {
            var pJointNode: IJoint = <IJoint>pNode.constructedNode;
            var sJointSid: string = pNode.sid;
            var sJointName: string = pNode.id;
            var pSkeleton: ISkeleton;

            { logger.setSourceLocation( "resources/Collada.ts" , 2677 ); logger.assert(isDefAndNotNull(pParentNode), "parent node is null"); } ;

            if (isDefAndNotNull(pJointNode)) {
                return pJointNode;
            }

            if (isNull(pParentNode)) {
                return null;
            }

            pJointNode = pParentNode.scene.createJoint();

            { logger.setSourceLocation( "resources/Collada.ts" , 2689 ); logger.assert(pJointNode.create(), "Can not initialize joint node!"); } ;

            pJointNode.boneName = sJointSid;
            pJointNode.attachToParent(pParentNode);


            if (this.isJointsVisualizationNeeded()) {
//draw joints
// var pSceneNode: ISceneModel = pEngine.appendMesh(
//     pEngine.pCubeMesh.clone(a.Mesh.GEOMETRY_ONLY | a.Mesh.SHARED_GEOMETRY),
//     pJointNode);
// pSceneNode.name = sJointName + '[joint]';
// pSceneNode.setScale(0.02);
                { logger.setSourceLocation( "resources/Collada.ts" , 2702 ); logger.criticalError("TODO: visualize joints..."); } ;
            }


            return pJointNode;
        }

        private buildCamera(pColladaInstanceCamera: IColladaInstanceCamera, pParent: ISceneNode): ICamera {
            var pColladaCamera: IColladaCamera = pColladaInstanceCamera.camera;
            var pCamera: ICamera = pParent.scene.createCamera(pColladaCamera.name || pColladaCamera.id || null);

            pCamera.setInheritance(ENodeInheritance.ALL);
            pCamera.attachToParent(pParent);

            var pPerspective: IColladaPerspective = pColladaCamera.optics.techniqueCommon.perspective;



            if (!isNull(pPerspective)) {
                pCamera.setProjParams(pPerspective.xfov, pPerspective.aspect, pPerspective.znear,
//FIX far plane distance
                    pPerspective.zfar * (1 / this.getAsset().unit.meter));
            }

            return pCamera;
        }

        private buildNodes(pNodes: IColladaNode[], pParentNode: ISceneNode = null): ISceneNode {
            if (isNull(pNodes)) {
                return null;
            }

            var pNode: IColladaNode = null;
            var pHierarchyNode: ISceneNode = null;
            var m4fLocalMatrix: IMat4 = null;

            for (var i:  number  = pNodes.length - 1; i >= 0; i--) {
                pNode = pNodes[i];

                if (!isDefAndNotNull(pNode)) {
                    continue;
                }

                if (pNode.type === "JOINT") {
                    pHierarchyNode = this.buildJointNode(pNode, pParentNode);
                }
                else {
                    pHierarchyNode = this.buildSceneNode(pNode, pParentNode);
                }

                pHierarchyNode.name = (pNode.id || pNode.name);
                pHierarchyNode.setInheritance(ENodeInheritance.ALL);

//cache already constructed nodes
                pNode.constructedNode = pHierarchyNode;
                pHierarchyNode.localMatrix = pNode.transform;

                this.buildNodes(pNode.childNodes, pHierarchyNode);

                if (pNode.camera.length > 0) {
                    for (var c = 0; c < pNode.camera.length; ++ c) {
                        var pColladaCamera: IColladaInstanceCamera = pNode.camera[c];
                        var pCamera: ICamera = this.buildCamera(pColladaCamera, pHierarchyNode);
                    }
                }
            }

            return pHierarchyNode;
        }

        private buildScene(pRootNode: ISceneNode): ISceneNode[] {
            var pScene: IColladaVisualScene = this.getVisualScene();
            var pAsset: IColladaAsset = this.getAsset();

            var pNodes: ISceneNode[] = [];
            var pNode: IColladaNode = null;

            for (var i:  number  = 0; i < pScene.nodes.length; i++) {
                pNode = pScene.nodes[i];
                pNodes.push(this.buildNodes([pNode], pRootNode));
            }

            for (var i:  number  = 0; i < pNodes.length; i++) {
                pNodes[i] = this.buildAssetTransform(pNodes[i]);
            }

            return pNodes;
        }

        private buildInititalPose(pNodes: IColladaNode[], pSkeleton: ISkeleton): IAnimation {
            var sPose: string = "Pose-" + this.getBasename() + "-" + pSkeleton.name;
            var pPose: IAnimation = animation.createAnimation(sPose);
            var pNodeList: ISceneNode[] = pSkeleton.getNodeList();
            var pNodeMap: ISceneNodeMap = {};
            var pTrack: IAnimationTrack;

            for (var i:  number  = 0; i < pNodeList.length; ++i) {
                pNodeMap[pNodeList[i].name] = pNodeList[i];
            }

            this.findNode(pNodes, null, function (pNode: IColladaNode) {
                var sJoint: string = pNode.sid;
                var sNodeId: string = pNode.id;

                if (!isDefAndNotNull(pNodeMap[sNodeId])) {
                    return;
                }

                pTrack = animation.createTrack(sJoint);
                pTrack.targetName = sNodeId;
                pTrack.keyFrame(0.0, pNode.transform);

                pPose.push(pTrack);
            });

            return pPose;
        }

        private buildInitialPoses(pPoseSkeletons: ISkeleton[] = null): IAnimation[] {
            if (!this.isVisualSceneLoaded()) {
                this.COLLADAScene();
            }

            pPoseSkeletons = pPoseSkeletons || this.getSkeletonsOutput();

            if (isNull(pPoseSkeletons)) {
                return null;
            }

            var pScene: IColladaVisualScene = this.getVisualScene();
            var pSkeleton: ISkeleton;
            var pPoses: IAnimation[] = [];

            for (var i:  number  = 0; i < pPoseSkeletons.length; ++i) {
                pSkeleton = pPoseSkeletons[i];
// if (pSkeleton.name === "node-Bip001_Pelvis" || pSkeleton.name === "node-Bip001") {
//     trace('skipping <node-Bip001_Pelvis> skeleto, ...', '[' + sBasename + ']');

//     trace(pSkeleton.getNodeList()[0].localMatrix().toQuat4().toYawPitchRoll(Vec3()).toString());

//     continue;
// }
                pPoses.push(this.buildInititalPose(pScene.nodes, pSkeleton));
            }
// LOG(pPoses);
            return pPoses;
        }

// additional


        private buildComplete(): void {
            var pScene: IColladaVisualScene = this.getVisualScene();

            if (isNull(pScene)) {
                { logger.setSourceLocation( "resources/Collada.ts" , 2857 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "build complete, but visual scene not parsed correctly!"); } ;
                return;
            }

//release all links to constructed nodes
            this.findNode(pScene.nodes, null, function (pNode: IColladaNode) {
                pNode.constructedNode = null;
            });
        }

        private setOptions(pOptions: IColladaLoadOptions): void {
            if (isNull(pOptions)) {
                pOptions = {};
            }

            for (var i in Collada.DEFAULT_OPTIONS) {
                if (isDef(pOptions[i])) {
                    continue;
                }

                pOptions[i] = Collada.DEFAULT_OPTIONS[i];
            }

            this._pOptions = pOptions;
        }

        private setXMLRoot(pXML: Element): void {
            this._pXMLRoot = pXML;
        }

        private getXMLRoot(): Element {
            return this._pXMLRoot;
        }

        private findMesh(sName: string): IMesh {
            return this._pCache.meshMap[sName] || null;
        }

        private addMesh(pMesh: IMesh): void {
            this._pCache.meshMap[pMesh.name] = pMesh;
            this.sharedBuffer(pMesh.data);
        }

        private sharedBuffer(pBuffer?: IRenderDataCollection): IRenderDataCollection {
            if (isDefAndNotNull(pBuffer)) {
                this._pCache.sharedBuffer = pBuffer;
            }

            return null;
// return this._pOptions.sharedBuffer ? pCache.sharedBuffer : null;
        }

        private prepareInput(pInput: IColladaInput): IColladaInput {
            var pSupportedFormat: IColladaUnknownFormat[] = getSupportedFormat(pInput.semantics);
            { logger.setSourceLocation( "resources/Collada.ts" , 2911 ); logger.assert(isDefAndNotNull(pSupportedFormat), "unsupported semantic used <" + pInput.semantics + ">"); } ;

            pInput.array    = <any[]><any>this.COLLADAGetSourceData(pInput.source, pSupportedFormat);
            pInput.accessor = pInput.source.techniqueCommon.accessor;

            return pInput;
        }

        private  /**@inline*/  isJointsVisualizationNeeded(): bool {
            return this._pOptions.drawJoints === true;
        }

        public  /**@inline*/  isVisualSceneLoaded(): bool {
            return isDefAndNotNull(this._pVisualScene);
        }

        public  /**@inline*/  isAnimationLoaded(): bool {
            return this._pAnimations.length > 0;
        }

        private  /**@inline*/  isSceneNeeded(): bool {
            return this._pOptions.scene === true;
        }

         private  /**@inline*/  isAnimationNeeded(): bool {
            return isDefAndNotNull(this._pOptions.animation) && this._pOptions.animation !== false;
        }

        private  /**@inline*/  isPoseExtractionNeeded(): bool {
            return this._pOptions.extractPoses === true;
        }

        private  /**@inline*/  isWireframeEnabled(): bool {
            return this._pOptions.wireframe === true;
        }

        private  /**@inline*/  getSkeletonsOutput(): ISkeleton[] {
            return this._pOptions.skeletons || null;
        }

        private  /**@inline*/  addSkeleton(pSkeleton: ISkeleton): void {
            this._pOptions.skeletons.push(pSkeleton);
        }

        private  /**@inline*/  getImageOptions(): IColladaImageLoadOptions {
            return this._pOptions.images;
        }

        private  /**@inline*/  getVisualScene(): IColladaVisualScene {
            return this._pVisualScene;
        }

        public  /**@inline*/  getAnimations(): IColladaAnimation[] {
            return this._pAnimations;
        }

        public  /**@inline*/  getAnimation(i:  number ): IColladaAnimation {
            return this._pAnimations[i] || null;
        }

        public  /**@inline*/  getAsset(): IColladaAsset {
            return this._pAsset;
        }

        private  /**@inline*/  isLibraryLoaded(sLib: string): bool {
            return isDefAndNotNull(this._pLib[sLib]);
        }

        private  /**@inline*/  isLibraryExists(sLib: string): bool {
            return !isNull(firstChild(this.getXMLRoot(), "library_animations"));
        }

        private  /**@inline*/  getLibrary(sLib: string): IColladaLibrary {
            return this._pLib[sLib] || null;
        }

        public  /**@inline*/  getBasename(): string {
            return path.info(this._pOptions.name || this._sFilename || "unknown").basename;
        }

        public  /**@inline*/  getFilename(): string {
            return this._sFilename;
        }

        private  /**@inline*/  setFilename(sName: string): void {
            this._sFilename = sName;
        }

        private readLibraries(pXML: Element, pTemplates: IColladaLibraryTemplate[]): void {
            var pLibraries: IColladaLibraryMap = this._pLib;

            for (var i:  number  = 0; i < pTemplates.length; i++) {
                var sLib: string = pTemplates[i].lib;
                pLibraries[sLib] = this.COLLADALibrary(firstChild(pXML, sLib), pTemplates[i]);
            }
        }

        private checkLibraries(pXML: Element, pTemplates: IColladaLibraryTemplate[]): void {
            var pLibraries: IColladaLibraryMap = this._pLib;

            for (var i:  number  = 0; i < pTemplates.length; i++) {
                var sLib: string = pTemplates[i].lib;

                if (isDefAndNotNull(firstChild(pXML, sLib))) {
                    pLibraries[sLib] = null;
                }
            }
        }

        /**@inline*/  get byteLength():  number  {
            return this._iByteLength;
        }

        parse(sXMLData: string, pOptions: IColladaLoadOptions = null): bool {
            if (isNull(sXMLData)) {
                { logger.setSourceLocation( "resources/Collada.ts" , 3026 ); logger.error("must be specified collada content."); } ;
                return false;
            }

            { logger.setSourceLocation( "resources/Collada.ts" , 3030 ); logger.log("[COLLADA [" + this.findResourceName() + "]]", "parsing started..."); } ;

            var pParser: DOMParser = new DOMParser();
            var pXMLDocument: Document = pParser.parseFromString(sXMLData, "application/xml");
            var pXMLRoot: Element = <Element>pXMLDocument.getElementsByTagName("COLLADA")[0];

            this.setOptions(pOptions);
            this.setXMLRoot(pXMLRoot);

            this.checkLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);
            this.checkLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);

            this.readLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);

            this.COLLADAAsset();
            this.COLLADAScene();

            if (this.isAnimationNeeded()) {
                this.readLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);
            }

            { logger.setSourceLocation( "resources/Collada.ts" , 3051 ); logger.log("[COLLADA [" + this.findResourceName() + "]]", "parsed."); } ;

            return true;
        }

        loadResource(sFilename: string = null, pOptions: IColladaLoadOptions = null): bool {
            if (isNull(sFilename)) {
                sFilename = this.findResourceName();
            }

            if (this.isResourceLoaded()) {
                { logger.setSourceLocation( "resources/Collada.ts" , 3062 ); logger.warning("[COLLADA [" + this.findResourceName() + "]]", "collada model already loaded"); } ;
                return false;
            }

            var pModel: Collada = this;

            this.setFilename(sFilename);

            this.notifyDisabled();
            this.notifyUnloaded();

            var pFile: IFile = io.fopen(sFilename);

            pFile.open(function (err, meta): void {
//FIXME: setuop byteLength correctly..
                (<any>pModel)["_iByteLength"] = meta.size || 0;
            });

            pFile.read(function (pErr: Error, sXML: string) {
                if (!isNull(pErr)) {
                    { logger.setSourceLocation( "resources/Collada.ts" , 3082 ); logger.error(pErr); } ;
                }

                pModel.notifyRestored();

                if (pModel.parse(sXML, pOptions)) {
//if resource not synced to any other resources
//loaded satet must be setted manuality
//but if resource has dependend sub-resources,
//loaded event happen automaticly, when all depenedences will be loaded.

                    if (pModel.isSyncedTo(EResourceItemEvents.LOADED)) {
                        pModel.setChangesNotifyRoutine((eFlag?: EResourceItemEvents, iResourceFlags?:  number , isSet?: bool) => {
                            if (eFlag === EResourceItemEvents.LOADED && isSet) {
//automaticly LOADED
                                { logger.setSourceLocation( "resources/Collada.ts" , 3097 ); logger.log("[COLLADA [" + pModel.findResourceName() + "]]", "resource loaded"); } ;
                                pModel.loaded();
                            }
                        });
                    }
                    else {
                        { logger.setSourceLocation( "resources/Collada.ts" , 3103 ); logger.log("[COLLADA [" + pModel.findResourceName() + "]]", "resource loaded"); } ;
                        pModel.notifyLoaded();
                    }
                }
            });

            return true;
        }


        attachToScene(pScene: IScene3d): IModelEntry;
        attachToScene(pNode: ISceneNode): IModelEntry;
        attachToScene(parent): IModelEntry {
            var pScene: IScene3d;
            var pNode: ISceneNode;
            var pRoot: IModelEntry;

            var pSceneOutput: ISceneNode[] = null;
// var pAnimationOutput: IAnimation[] = null;
            var pMeshOutput: IMesh[] = null;
// var pInitialPosesOutput: IAnimation[] = null;


            if (isNull(parent)) {
                return null;
            }

            if (parent instanceof scene.Node) {
//attach collada scene to give node
                pNode = <ISceneNode>parent;
                pScene = pNode.scene;

            }
            else {
//attaching collada scene to new node, that is child of scene root
                pScene = <IScene3d>parent;
                pNode = pScene.getRootNode();
            }

            pRoot = pScene._createModelEntry(this);
            pRoot.create();
            pRoot.name = this.getBasename();
            pRoot.setInheritance(ENodeInheritance.ALL);

            if (!pRoot.attachToParent(pNode)) {
                return null;
            }

            if (this.isVisualSceneLoaded() && this.isSceneNeeded()) {
                pSceneOutput = this.buildScene(pRoot);
                pMeshOutput = this.buildMeshes();
            }

// if (this.isPoseExtractionNeeded()) {
//     pInitialPosesOutput = this.buildInitialPoses();
// }

//pAnimationOutput = this.extractAnimations();

// if (isNull(pController)) {
//     pController = this.getEngine().createAnimationController();
// }

// if (!isNull(pController) && !isNull(pAnimationOutput)) {
//     for (var i: int = 0; i < pAnimationOutput.length; ++ i) {
//         pController.addAnimation(pAnimationOutput[i]);
//     }

//     pController.attach(pRoot);
// }

//clear all links from collada nodes to scene nodes
            this.buildComplete();

            return pRoot;
        }

        extractAnimation(i:  number ): IAnimation {
            var pPoses: IAnimation[];
            var pSkeletons: ISkeleton[],
                pSkeleton: ISkeleton;
            var pAnimation: IAnimation = null;
            var pData: IColladaAnimation = this.getAnimation(i);

            if (!isNull(pData) && this.isAnimationNeeded() && this.isLibraryExists("library_animations")) {

                pAnimation = this.buildAnimation(pData);
//дополним анимации начальными позициями костей
                if (this.isPoseExtractionNeeded()) {
                    pSkeletons = this.getSkeletonsOutput() || [];

                    pPoses = this.buildInitialPoses(pSkeletons);

                    for (var j:  number  = 0; j < pPoses.length; ++ j) {
                        pAnimation.extend(pPoses[j]);
                    }
                }
            }

            return pAnimation;
        }

        extractAnimations(): IAnimation[] {
            var pPoses: IAnimation[];
            var pSkeletons: ISkeleton[],
                pSkeleton: ISkeleton;
            var pAnimationOutput: IAnimation[] = null;

            if (this.isAnimationNeeded() && this.isLibraryExists("library_animations")) {

                pAnimationOutput = this.buildAnimations();
//дополним анимации начальными позициями костей
                if (this.isPoseExtractionNeeded()) {
                    pSkeletons = this.getSkeletonsOutput() || [];

/*
     
                    // добавим к начальным позам, те, в которых находятся меши
                    // в момент выгрузки
                    if (!isNull(pMeshOutput)) {
                        for (var i = 0; i < pMeshOutput.length; ++ i) {
                            pSkeletons.push(pMeshOutput[i].skeleton);
                        }
                    }
                    else {
                        //необхоимо для посчета ссылочной информации
                        if (isNull(pSceneOutput)) {
                            this.buildScene();
                        }

                        this.eachByTag(pXMLRoot, "skeleton", function (pXML: Node) {
                            pSkeletons.push(this.buildSkeleton([stringData(pXML)]));
                        });
                    }

                    */


                    pPoses = this.buildInitialPoses(pSkeletons);

                    for (var i:  number  = 0; i < pAnimationOutput.length; ++ i) {
                        for (var j:  number  = 0; j < pPoses.length; ++ j) {
                            pAnimationOutput[i].extend(pPoses[j]);
                        }
                    }
                }
            }

            return pAnimationOutput;
        }

    }

    pSupportedVertexFormat = [
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["Z"], type : ["float"]}
    ];

    pSupportedTextureFormat = [
        {name : ["S"], type : ["float"]},
        {name : ["T"], type : ["float"]},
        {name : ["P"], type : ["float"]}
    ];

    pSupportedColorFormat = [
        {name : ["R"], type : ["float"]},
        {name : ["G"], type : ["float"]},
        {name : ["B"], type : ["float"]}
    ];

    pSupportedWeightFormat = [
        {name : ["WEIGHT"], type : ["float"]}
    ];

    pSupportedJointFormat = [
        {name : ["JOINT"], type : ["Name", "IDREF"]}
    ];

    pSupportedInvBindMatrixFormat = [
        {name : ["TRANSFORM"], type : ["float4x4"]}
    ];

    pSupportedInterpolationFormat = [
        {name : ["INTERPOLATION"], type : ["Name"]}
    ];

    pSupportedInputFormat = [
        {name : ["TIME"], type : ["float"]}
    ];

    pSupportedOutputFormat = [
        {name : ["TRANSFORM", "X", "ANGLE", null], type : ["float4x4", "float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["Z"], type : ["float"]}
    ];

    pSupportedTangentFormat = [
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]}
    ];

    pFormatStrideTable = <IColladaFormatStrideTable> {
        "float"    : 1,
        "float2"   : 2,
        "float3"   : 3,
        "float4"   : 4,
        "float3x3" : 9,
        "float4x4" : 16,
        "int"      : 1,
        "name"     : 1,
        "Name"     : 1,
        "IDREF"    : 1
    };

/* COMMON FUNCTIONS
     ------------------------------------------------------
     */


    function getSupportedFormat(sSemantics: string): IColladaUnknownFormat[] {
        switch (sSemantics) {
            case "TEXTANGENT":
            case "TEXBINORMAL":
            case "VERTEX":
            case "NORMAL":
            case "TANGENT":
            case "BINORMAL":
            case "POSITION":
                return pSupportedVertexFormat;

            case "TEXCOORD":
                return pSupportedTextureFormat;

            case "WEIGHT":
                return pSupportedWeightFormat;

            case "JOINT":
                return pSupportedJointFormat;

            case "INV_BIND_MATRIX":
                return pSupportedInvBindMatrixFormat;

            case "INTERPOLATION":
                return pSupportedInterpolationFormat;

            case "IN_TANGENT":
                return pSupportedTangentFormat;

            case "INPUT":
                return pSupportedInputFormat;

            case "OUT_TANGENT":
                return pSupportedTangentFormat;

            case "OUTPUT":
                return pSupportedOutputFormat;
            case "COLOR":
                return pSupportedColorFormat;
            case "UV":
            case "MORPH_WEIGHT":
            case "MORPH_TARGET":
            case "LINEAR_STEPS":
            case "IMAGE":
            case "CONTINUITY":
                return null;
        }

        { logger.setSourceLocation( "resources/Collada.ts" , 3377 ); logger.error("unknown semantics founded: " + sSemantics); } ;

        return null;
    }

    function calcFormatStride(pFormat: IColladaUnknownFormat[]):  number  {
        var iStride:  number  = 0;
        var s: string = null;

        for (var i:  number  = 0; i < pFormat.length; ++i) {
            s = pFormat[i].type[0];
            iStride += pFormatStrideTable[s];
        }

        return iStride;
    }

// additional

    function printArray(pArr: any[], nRow:  number , nCol:  number ): string {
        var s: string = "\n";

        for (var i = 0; i < pArr.length; ++i) {
            if (i % nCol == 0) {
                s += "  ";
            }

            s += pArr[i] + ", ";

            if ((i + 1) % nRow == 0) {
                s += '\n';
            }
        }

        return s;
    }

    function sortArrayByProperty(pData: any[], sProperty: string): any[] {
        var tmp: any;

        for (var i:  number  = pData.length - 1; i > 0; i--) {
            for (var j:  number  = 0; j < i; j++) {
                if (pData[j][sProperty] > pData[j + 1][sProperty]) {
                    tmp = pData[j];
                    pData[j] = pData[j + 1];
                    pData[j + 1] = tmp;
                }
            }
        }

        return pData;
    }


    /**@inline*/  function stringData(pXML: Element): string {
        return (isDefAndNotNull(pXML) ? pXML.textContent : null);
    }

    /**@inline*/  function attr(pXML: Element, sName: string): string {
         return pXML.getAttribute(sName);

    }

    function firstChild(pXML: Element, sTag?: string): Element {
        if (isString(sTag)) {
            return <Element>pXML.getElementsByTagName(sTag)[0];
        }

        for (var i = 0; i < pXML.childNodes.length; i++) {
            if (pXML.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                return <Element>pXML.childNodes[i];
            }
        }

        return null;
    }


    export  /**@inline*/  function isModelResource(pItem: IResourcePoolItem): bool {
        return isVideoResource(pItem) && pItem.resourceCode.type === EVideoResources.MODEL_RESOURCE;
    }

    export  /**@inline*/  function isColladaResource(pItem: IResourcePoolItem): bool {
        return isModelResource(pItem) && (<IModel>pItem).modelFormat === EModelFormats.COLLADA;
    }
}













// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;

// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;

// getAnimationController(): IAnimationController;

// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;

// addNode(pNode: ISceneNode): void;

// addSkeleton(pSkeleton: ISkeleton): void;

// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;

// getRootNodes(): ISceneNode[];

// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;

// //instead old method: applyShadow();
// _setup(): bool;

// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;

module akra {
	;

	export interface IObjLoadOptions extends IModelLoadOptions {
		shadows?: bool;
		name?: string;

        axis?: {
            x: {index:  number ; inverse: bool;};
            y: {index:  number ; inverse: bool;};
            z: {index:  number ; inverse: bool;};
        };
	}

    export interface IObj extends IModel {
        getFilename(): string;
        getBasename(): string;

        parse(sXMLData: string, pOptions?: IObjLoadOptions): bool;
        loadResource(sFilename?: string, pOptions?: IObjLoadOptions): bool;
        uploadVertexes(pPositions: Float32Array, pIndexes?: Float32Array): void;
    }
}











module akra.core.pool.resources {
	export enum EObjFVF {
		XYZ = 0x01,
		NORMAL = 0x02,
		UV = 0x04
	}


	function regExpResultToFloatArray(pSrc: string[], ppDest:  number [], iFrom:  number  = -1):  number  {
//i = 1 ==> regexp result starts from original value, like: ("1 2 3").match(/([1-9])/i) = ["1 2 3", "1", "2", "3"];
	    var j:  number  = 0;

//writing into end of dest array
	    if (iFrom < 0) {
	    	iFrom = ppDest.length;
	    }

	    for (var i = 1; i < pSrc.length; ++i) {
	        if (pSrc[i]) {
	            ppDest[iFrom + j] = parseFloat(pSrc[i].replace(/,/g, "."));
	            j ++;
	        }
	    }

	    return j;
	};

	var temp:  number [] = [0, 0, 0, 0, 0, 0, 0, 0, 0];

	export class Obj extends ResourcePoolItem implements IObj {
		private _sFilename: string = null;
        private _iByteLength:  number  = 0;
        private _pOptions: IObjLoadOptions = null;

        private _pVertices:  number [] = [];
        private _pNormals:  number [] = [];
        private _pTextureCoords:  number [] = [];

        private _pVertexIndexes:  number [] = [];
        private _pTexcoordIndexes:  number [] = [];
        private _pNormalIndexes:  number [] = [];


//flexible vertex format
        private _iFVF:  number  = 0;


        public  /**@inline*/  get modelFormat(): EModelFormats {
            return EModelFormats.OBJ;
        }

        public  /**@inline*/  getFilename(): string {
            return this._sFilename;
        }

        private  /**@inline*/  setFilename(sName: string): void {
            this._sFilename = sName;
        }

        public  /**@inline*/  getBasename(): string {
            return path.info(this._pOptions.name || this._sFilename || "unknown").basename;
        }

        public  /**@inline*/  get byteLength():  number  {
            return this._iByteLength;
        }

        public  /**@inline*/  get options(): IObjLoadOptions {
            return this._pOptions;
        }

		private setOptions(pOptions: IObjLoadOptions): void {
            if (isNull(pOptions)) {
                pOptions = Obj.DEFAULT_OPTIONS;
            }

            for (var i in Obj.DEFAULT_OPTIONS) {
                if (isDef(pOptions[i])) {
                    continue;
                }

                pOptions[i] = Obj.DEFAULT_OPTIONS[i];
            }

            this._pOptions = pOptions;
        }

        attachToScene(pScene: IScene3d): IModelEntry;
        attachToScene(pNode: ISceneNode): IModelEntry;
        attachToScene(parent): IModelEntry {
        	var pScene: IScene3d;
            var pNode: ISceneNode;
            var pRoot: IModelEntry;

            if (isNull(parent)) {
                return null;
            }

            if (parent instanceof scene.Node) {
//attach collada scene to give node
                pNode = <ISceneNode>parent;
                pScene = pNode.scene;

            }
            else {
//attaching collada scene to new node, that is child of scene root
                pScene = <IScene3d>parent;
                pNode = pScene.getRootNode();
            }

            pRoot = pScene._createModelEntry(this);
            pRoot.create();
            pRoot.name = this.getBasename();
            pRoot.setInheritance(ENodeInheritance.ALL);

            if (!pRoot.attachToParent(pNode)) {
                return null;
            }

            this.buildMesh(pRoot);

            return pRoot;
        }

        private buildMesh(pRoot: ISceneNode): void {
        	var pMesh: IMesh = null,
			pSubMesh: IMeshSubset = null;

		    var pVerticesData: Float32Array = new Float32Array(this._pVertices);
		    var pNormalsData: Float32Array = new Float32Array(this._pNormals);
		    var pTexcoordsData: Float32Array = new Float32Array(this._pTextureCoords);

// console.log(pVerticesData, pNormalsData)

		    var pVertexIndicesData: Float32Array = new Float32Array(this._pVertexIndexes);
		    var pNormalIndicesData:Float32Array = new Float32Array(this._pNormalIndexes);
		    var pTexcoordIndicesData:Float32Array = new Float32Array(this._pTexcoordIndexes);

		   	var iPos:  number  = 0,
		    	iNorm:  number  = 0,
		    	iTexcoord:  number  = 0;

		    var pEngine: IEngine = this.getEngine();

		    pMesh = model.createMesh(pEngine, this.getBasename(), EMeshOptions.HB_READABLE);
	    	pSubMesh = pMesh.createSubset(this.getBasename(), EPrimitiveTypes.TRIANGLELIST);

	    	iPos = pSubMesh.data.allocateData([VE_VEC3('POSITION')], pVerticesData);
		    pSubMesh.data.allocateIndex([VE_FLOAT('INDEX0')], pVertexIndicesData);
		    pSubMesh.data.index(iPos, 'INDEX0');
// console.log(pVerticesData, pVertexIndicesData);

		    if (this.hasNormals()) {
			    iNorm = pSubMesh.data.allocateData([VE_VEC3('NORMAL')], pNormalsData);

			    if (this._pNormalIndexes.length > 0) {
			    	pSubMesh.data.allocateIndex([VE_FLOAT('INDEX1')], pNormalIndicesData);
				    pSubMesh.data.index(iNorm, 'INDEX1');
// console.log(pNormalsData, pNormalIndicesData);
			    }
			    else {
			    	{ logger.setSourceLocation( "resources/Obj.ts" , 178 ); logger.log("[OBJ [" + this.findResourceName() + "]]", "normal index was replaced with vertex index"); } ;
			    	pSubMesh.data.allocateIndex([VE_FLOAT('INDEX1')], pVertexIndicesData);
			    	pSubMesh.data.index(iNorm, 'INDEX1');
			    }
		    }

		    if (this.hasTexcoords()) {
		    	{ logger.setSourceLocation( "resources/Obj.ts" , 185 ); logger.log("[OBJ [" + this.findResourceName() + "]]", "model have texture coordinates"); } ;
		    	iTexcoord = pSubMesh.data.allocateData([VE_VEC2('TEXCOORD0')], pTexcoordsData);
			    pSubMesh.data.allocateIndex([VE_FLOAT('INDEX2')], pTexcoordIndicesData);
			    pSubMesh.data.index('TEXCOORD0', 'INDEX2');
// console.log(pTexcoordsData, pTexcoordIndicesData);
		    }
		    else {
		    	{ logger.setSourceLocation( "resources/Obj.ts" , 192 ); logger.log("[OBJ [" + this.findResourceName() + "]]", "model does not have any texture coordinates"); } ;
		    }

		    pSubMesh.shadow = this.options.shadows;
		    pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");

		    var pMatrial: IMaterial = pSubMesh.renderMethod.surfaceMaterial.material;
		    pMatrial.diffuse = new Color(0.7, 0., 0., 1.);
		    pMatrial.ambient = new Color(0., 0., 0., 1.);
			pMatrial.specular = new Color(0.7, 0., 0. ,1);
			pMatrial.emissive = new Color(0., 0., 0., 1.);
		    pMatrial.shininess = 30.;

		    var pSceneModel: ISceneModel = pRoot.scene.createModel(this.getBasename());
		    pSceneModel.setInheritance(ENodeInheritance.ALL);
	    	pSceneModel.mesh = pMesh;

		    pSubMesh.wireframe(true);

	    	pSceneModel.attachToParent(pRoot);
        }

        uploadVertexes(pPositions: Float32Array, pIndexes: Float32Array = null): void {

        	for (var i:  number  = 0; i < pPositions.length; ++ i) {
        		this._pVertices[i] = pPositions[i];
        	}

        	if (!isNull(pIndexes)) {
        		for (var i:  number  = 0; i < pIndexes.length; ++ i) {
        			this._pVertexIndexes[i] = pIndexes[i];
        		}
        	}

        	this.calcDeps();

        	this.notifyRestored();
        	this.notifyLoaded();
        }

		parse(sData: string, pOptions: IObjLoadOptions = null): bool {
			if (isNull(sData)) {
                { logger.setSourceLocation( "resources/Obj.ts" , 234 ); logger.error("must be specified obj content."); } ;
                return false;
            }

            { logger.setSourceLocation( "resources/Obj.ts" , 238 ); logger.log("[OBJ [" + this.findResourceName() + "]]", "parsing started..."); } ;
            this.setOptions(pOptions);

            var pLines: string[] = sData.split("\n");

            for (var i:  number  = 0; i < pLines.length; ++ i) {
//current line
            	var sLine: string = pLines[i];
//first character
            	var c: string = sLine.charAt(0);

            	switch (c) {
            		case 'v': this.readVertexInfo(sLine); break;
            		case 'f': this.readFaceInfo(sLine); break;
            	}
            }

//fixing indices, all indices starts from 1.....
            for (var i:  number  = 0; i < this._pVertexIndexes.length; ++ i) {
            	this._pVertexIndexes[i] --;
            }

            for (var i:  number  = 0; i < this._pNormalIndexes.length; ++ i) {
            	this._pNormalIndexes[i] --;
            }

            for (var i:  number  = 0; i < this._pTexcoordIndexes.length; ++ i) {
            	this._pTexcoordIndexes[i] --;
            }
//end of index fix


            this.calcDeps();


            return true;
		}

		private calcDeps(): void {
//FIXME: crete model with out indices, instead using pseudo indices like 0, 1, 2, 3....
//fill indices, if not presented
            if (this._pVertexIndexes.length === 0) {
            	this.calcVertexIndices();
            }

            if (!this._pNormals.length) {
            	{ logger.setSourceLocation( "resources/Obj.ts" , 284 ); logger.log("[OBJ [" + this.findResourceName() + "]]", "calculation normals...."); }
            	this.calcNormals();
            }
		}

		private calcVertexIndices(): void {
			for (var i = 0; i < this._pVertices.length; ++i) {
		        this._pVertexIndexes[i] = i;
		    }
		}

		private calcNormals(useSmoothing: bool = true): void {
			var v = new Array(3),
				p: IVec3 = new Vec3,
				q: IVec3 = new Vec3,
				i, j,
				n: IVec3 = new Vec3,
				k;

		    for (i = 0; i < this._pVertices.length; ++i) {
		        this._pNormals[i] = 0.;
		    }

		    for (i = 0; i < this._pVertexIndexes.length; i += 3) {
		        for (k = 0; k < 3; ++k) {

		            j = this._pVertexIndexes[i + k] * 3;
		            v[k] =  Vec3.stackCeil.set([this._pVertices[j], this._pVertices[j + 1], this._pVertices[j + 2]]) ;
		        }

		        v[1].subtract(v[2], p);
		        v[0].subtract(v[2], q);
		        p.cross(q, n);
		        n.normalize();
// n.negate();

		        for (k = 0; k < 3; ++k) {
		            j = this._pVertexIndexes[i + k] * 3;
		            this._pNormals[j] = n.x;
		            this._pNormals[j + 1] = n.y;
		            this._pNormals[j + 2] = n.z;
		        }
		    }

//    if (useSmoothing) {
//        for (i = 0; i < this._pVertexIndexes.length; i += 3) {
//            for (k = 0; k < 3; ++k) {
//                j = this._pVertexIndexes[i + k] * 3;
//                Vec3.set(this._pNormals[j], this._pNormals[j + 1], this._pNormals[j + 2], n);
//                Vec3.normalize(n);
//                this._pNormals[j] = n[0];
//                this._pNormals[j + 1] = n[1];
//                this._pNormals[j + 2] = n[2];
//                //a.log(this._pNormals[j] + " : " + this._pNormals[j + 1] + " : " + this._pNormals[j + 2]);
//            }
//        }
//    }

			((this._iFVF) |= (EObjFVF.NORMAL)) ;
		}

		static VERTEX_REGEXP: RegExp = /^v[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)([\s]+[-+]?[\d]*[\.|\,]?[\de-]*?)?[\s]*$/i;
//provide only {U, V} pairs, 3D textures unsupported :(
		static TEXCOORD_REGEXP: RegExp = /^vt[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]*.*$/i;
		static NORMAL_REGEXP: RegExp = /^vn[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]+([-+]?[\d]*[\.|\,]?[\de-]*?)[\s]*$/i;

		readVertexInfo(s: string): void {
//<s> - current line
//second character of line <s>
			var ch: string = s.charAt(1);
//results of regexp matching
			var pm: string[];
;
			var iX:  number  = this.options.axis.x.index;
			var iY:  number  = this.options.axis.y.index;
			var iZ:  number  = this.options.axis.z.index;

			var iXSign:  number  = this.options.axis.x.inverse? -1: 1;
			var iYSign:  number  = this.options.axis.y.inverse? -1: 1;
			var iZSign:  number  = this.options.axis.z.inverse? -1: 1;

			s = s.replace("\r", "");

//List of Vertices, with (x,y,z[,w]) coordinates, w is optional.
		    if (ch == ' ') {
		        pm = s.match(Obj.VERTEX_REGEXP);
		        { logger.setSourceLocation( "resources/Obj.ts" , 370 ); logger.assert(!isNull(pm), "invalid line detected: <" + s + ">"); } ;
		        regExpResultToFloatArray(pm, temp, 0);
		        this._pVertices.push(iXSign * temp[iX], iYSign * temp[iY], iZSign * temp[iZ]);
		        ((this._iFVF) |= (EObjFVF.XYZ)) ;
		    }

//Texture coordinates, in (u,v[,w]) coordinates, w is optional.
		    else if (ch == 't') {
		        pm = s.match(Obj.TEXCOORD_REGEXP);
		    	{ logger.setSourceLocation( "resources/Obj.ts" , 379 ); logger.assert(!isNull(pm), "invalid line detected: <" + s + "> (" + Obj.TEXCOORD_REGEXP.toString() + ")"); } ;
		       	regExpResultToFloatArray(pm, this._pTextureCoords);
		        ((this._iFVF) |= (EObjFVF.UV)) ;
		    }
//Normals in (x,y,z) form; normals might not be unit.	
		    else if (ch == 'n') {
		        pm = s.match(Obj.NORMAL_REGEXP);
		    	{ logger.setSourceLocation( "resources/Obj.ts" , 386 ); logger.assert(!isNull(pm), "invalid line detected: <" + s + ">"); } ;
		        regExpResultToFloatArray(pm, temp, 0);
		        this._pNormals.push(iXSign * temp[iX], iYSign * temp[iY], iZSign * temp[iZ]);
		        ((this._iFVF) |= (EObjFVF.NORMAL)) ;
		    }
		}

		/**@inline*/  hasTexcoords(): bool {
			return (this._iFVF & EObjFVF.UV) != 0;
		}

		/**@inline*/  hasNormals(): bool {
			return (this._iFVF & EObjFVF.NORMAL) != 0;
		}

		static VERTEX_UV_FACE_REGEXP = /^f[\s]+([\d]+)\/([\d]*)[\s]+([\d]+)\/([\d]*)[\s]+([\d]+)\/([\d]*)[\s]*$/i;
		static VERTEX_NORMAL_FACE_REGEXP = /^f[\s]+([\d]+)\/\/([\d]*)[\s]+([\d]+)\/\/([\d]*)[\s]+([\d]+)\/\/([\d]*)[\s]*$/i;
		static VERTEX_UV_NORMAL_FACE_REGEXP =
		            /^f[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]+([\d]+)\/([\d]*)\/([\d]*)[\s]*$/i;



		readFaceInfo(s: string): void {
//results of regexp matching
		    var pm: string[];

// vertex / texcoord
		    if (this.hasTexcoords() && !this.hasNormals()) {
		        pm = s.match(Obj.VERTEX_UV_FACE_REGEXP);

		        regExpResultToFloatArray(pm, temp, 0);

		        this._pVertexIndexes.push(temp[0], temp[2], temp[4]);
		        this._pTexcoordIndexes.push(temp[1], temp[3], temp[5]);
		    }
//vertex / normal
		    else if (!this.hasTexcoords() && this.hasNormals()) {
		        pm = s.match(Obj.VERTEX_NORMAL_FACE_REGEXP);
		        { logger.setSourceLocation( "resources/Obj.ts" , 424 ); logger.assert(!isNull(pm), "invalid line detected: <" + s + ">"); } ;
// if (!pm) {
//     this._isObjectHasNormals = false;
//     this._readFaceInfo(s);
//     return;
// }
		        regExpResultToFloatArray(pm, temp, 0);
		        this._pVertexIndexes.push(temp[0], temp[2], temp[4]);
		        this._pNormalIndexes.push(temp[1], temp[3], temp[5]);
		    }
//vertex / texcoord / normal
		    else if (this.hasTexcoords() && this.hasNormals()) {
		        pm = s.match(Obj.VERTEX_UV_NORMAL_FACE_REGEXP);
		        { logger.setSourceLocation( "resources/Obj.ts" , 437 ); logger.assert(!isNull(pm), "invalid line detected: <" + s + ">"); } ;
		        regExpResultToFloatArray(pm, temp, 0);
		        this._pVertexIndexes.push(temp[0], temp[3], temp[6]);
		        this._pTexcoordIndexes.push(temp[1], temp[4], temp[7]);
		        this._pNormalIndexes.push(temp[2], temp[5], temp[8]);
		    }
//vertex only
		    else {
		        pm = s.match(
		            /^f[\s]+([\d]+)[\s]+([\d]+)[\s]+([\d]+)[\s]*$/i);
		        { logger.setSourceLocation( "resources/Obj.ts" , 447 ); logger.assert(!isNull(pm), "invalid line detected: <" + s + ">"); } ;
		        regExpResultToFloatArray(pm, temp, 0);
		        this._pVertexIndexes.push(temp[0], temp[1], temp[2]);
		    }
		};


		loadResource(sFilename: string = null, pOptions: IObjLoadOptions = null): bool {
            if (isNull(sFilename)) {
                sFilename = this.findResourceName();
            }

            if (this.isResourceLoaded()) {
                { logger.setSourceLocation( "resources/Obj.ts" , 460 ); logger.warning("[OBJ [" + this.findResourceName() + "]]", "obj model already loaded"); } ;
                return false;
            }

            var pModel: Obj = this;

            this.setFilename(sFilename);

            this.notifyDisabled();
            this.notifyUnloaded();

            var pFile: IFile = io.fopen(sFilename);

            pFile.open(function (err, meta): void {
//FIXME: setuop byteLength correctly..
                (<any>pModel)["_iByteLength"] = meta.size || 0;
            });

            pFile.read(function (pErr: Error, sXML: string) {
                if (!isNull(pErr)) {
                    { logger.setSourceLocation( "resources/Obj.ts" , 480 ); logger.error(pErr); } ;
                }

                pModel.notifyRestored();

                if (pModel.parse(sXML, pOptions)) {
                    { logger.setSourceLocation( "resources/Obj.ts" , 486 ); logger.log("[OBJ [" + pModel.findResourceName() + "]]", "resource loaded"); } ;
                    pModel.notifyLoaded();
                }
            });

            return true;
        }

        static DEFAULT_OPTIONS: IObjLoadOptions = {
            shadows         : true,
            axis: {
            	x: {index: 0, inverse: false},
            	y: {index: 1, inverse: false},
            	z: {index: 2, inverse: false}
            }
        };
	}
}



































module akra.util {











    akra.logger.registerCode( 2001 , "Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\n" +
                                                           "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                                                           "Old operation: {oldOperation}\n" +
                                                           "New operation: {newOperation}\n" +
                                                           "For more info init parser in debug-mode and see syntax table and list of states.");

    akra.logger.registerCode( 2002 , "Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\n" +
                                                            "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                                                            "Old next state: {oldNextStateIndex}\n" +
                                                            "New next state: {newNextStateIndex}\n" +
                                                            "For more info init parser in debug-mode and see syntax table and list of states.");

    akra.logger.registerCode( 2003 , "Grammar error. Can`t generate rules from grammar\n" +
                                                               "Unexpected symbol: {unexpectedSymbol}\n" +
                                                               "Expected: {expectedSymbol}");

    akra.logger.registerCode( 2004 , "Grammar error. Empty additional function name.");
    akra.logger.registerCode( 2005 , "Grammar error. Bad keyword: {badKeyword}\n" +
                                                         "All keyword must be define in lexer rule block.");

    akra.logger.registerCode( 2051 , "Syntax error during parsing. Token: {tokenValue}\n" +
                                                  "Line: {line}. Column: {column}.");

    akra.logger.registerCode( 2101 , "Unknown token: {tokenValue}");
    akra.logger.registerCode( 2102 , "Bad token: {tokenValue}");



    function sourceLocationToString(pLocation: ISourceLocation): string {
        var sLocation:string = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
        return sLocation;
    }

    function syntaxErrorLogRoutine(pLogEntity: ILoggerEntity): void{
        var sPosition:string = sourceLocationToString(pLogEntity.location);
        var sError: string = "Code: " + pLogEntity.code.toString() + ". ";
        var pParseMessage: string[] = pLogEntity.message.split(/\{(\w+)\}/);
        var pInfo:any = pLogEntity.info;

        for(var i = 0; i < pParseMessage.length; i++){
            if(isDef(pInfo[pParseMessage[i]])){
                pParseMessage[i] = <string><any>pInfo[pParseMessage[i]];
            }
        }

        var sMessage = sPosition + sError + pParseMessage.join("");

        console["error"].call(console, sMessage);
    }

    akra.logger.setCodeFamilyRoutine("ParserSyntaxErrors", syntaxErrorLogRoutine, ELogLevel.ERROR);

//akra.logger

    export interface IOperation {
        type: EOperationType;
        rule?: IRule;
        index?:  number ;
    }

    export interface IItem {
        isEqual(pItem: IItem, eType?: EParserType): bool;
        isParentItem(pItem: IItem): bool;
        isChildItem(pItem: IItem): bool;

        mark(): string;
        end(): string;
        nextMarked(): string;

        toString(): string;

        isExpected(sSymbol: string): bool;
        addExpected(sSymbol: string): bool;

        rule: IRule;
        position:  number ;
        index:  number ;
        state: IState;
        expectedSymbols: BoolMap;
        isNewExpected: bool;
        length:  number ;
    }

    export interface IState {

        hasItem(pItem: IItem, eType: EParserType): IItem;
        hasParentItem(pItem: IItem): IItem;
        hasChildItem(pItem: IItem): IItem;

        hasRule(pRule:IRule, iPos: number ):bool;

        isEmpty(): bool;
        isEqual(pState: IState, eType: EParserType): bool;

        push(pItem: IItem): void;

        tryPush_LR0(pRule: IRule, iPos:  number ): bool;
        tryPush_LR(pRule: IRule, iPos:  number , sExpectedSymbol: string): bool;

        deleteNotBase(): void;

        getNextStateBySymbol(sSymbol: string): IState;
        addNextState(sSymbol: string, pState: IState): bool;

        toString(isBase: bool): string;

        items: IItem[];
        numBaseItems:  number ;
        index:  number ;
        nextStates: IStateMap;
    }

    export interface IStateMap {
        [index: string]: IState;
    }


    class Item implements IItem {
        private _pRule: IRule;
        private _iPos:  number ;
        private _iIndex:  number ;
        private _pState: IState;

        private _pExpected: BoolMap;
        private _isNewExpected: bool;
        private _iLength:  number ;


        /**@inline*/  get rule(): IRule {
            return this._pRule;
        }

        /**@inline*/  set rule(pRule: IRule) {
            this._pRule = pRule;
        }

        /**@inline*/  get position():  number  {
            return this._iPos;
        }

        /**@inline*/  set position(iPos:  number ) {
            this._iPos = iPos;
        }

        /**@inline*/  get state(): IState {
            return this._pState;
        }

        /**@inline*/  set state(pState: IState) {
            this._pState = pState;
        }

        /**@inline*/  get index():  number  {
            return this._iIndex;
        }

        /**@inline*/  set index(iIndex:  number ) {
            this._iIndex = iIndex;
        }

        /**@inline*/  get expectedSymbols(): BoolMap {
            return this._pExpected;
        }

        /**@inline*/  get length():  number  {
            return this._iLength;
        }

        /**@inline*/  get isNewExpected(): bool {
            return this._isNewExpected;
        }

        /**@inline*/  set isNewExpected(_isNewExpected: bool) {
            this._isNewExpected = _isNewExpected;
        }

        constructor (pRule: IRule, iPos:  number , pExpected?: BoolMap) {
            this._pRule = pRule;
            this._iPos = iPos;
            this._iIndex = 0;
            this._pState = null;

            this._isNewExpected = true;
            this._iLength = 0;
            this._pExpected = <BoolMap>{};

            if (arguments.length === 3) {
                var i: string = null;
                for (i in <BoolMap>arguments[2]) {
                    this.addExpected(i);
                }
            }
        }

        isEqual(pItem: IItem, eType?: EParserType = EParserType.k_LR0): bool {
            if (eType === EParserType.k_LR0) {
                return (this._pRule === pItem.rule && this._iPos === pItem.position);
            }
            else if (eType === EParserType.k_LR1) {
                if (!(this._pRule === pItem.rule && this._iPos === pItem.position && this._iLength === (<IItem>pItem).length)) {
                    return false;
                }
                var i: string = null;
                for (i in this._pExpected) {
                    if (!(<IItem>pItem).isExpected(i)) {
                        return false;
                    }
                }
                return true;
            }
        }

        isParentItem(pItem: IItem): bool {
            return (this._pRule === pItem.rule && this._iPos === pItem.position + 1);
        }

        isChildItem(pItem: IItem): bool {
            return (this._pRule === pItem.rule && this._iPos === pItem.position - 1);
        }

        mark(): string {
            var pRight: string[] = this._pRule.right;
            if (this._iPos === pRight.length) {
                return  "END" ;
            }
            return pRight[this._iPos];
        }

        /**@inline*/  end(): string {
            return this._pRule.right[this._pRule.right.length - 1] ||  "EMPTY" ;
        }

        /**@inline*/  nextMarked(): string {
            return this._pRule.right[this._iPos + 1] ||  "END" ;
        }

        /**@inline*/  isExpected(sSymbol: string): bool {
            return !!(this._pExpected[sSymbol]);
        }

        addExpected(sSymbol: string): bool {
            if (this._pExpected[sSymbol]) {
                return false;
            }
            this._pExpected[sSymbol] = true;
            this._isNewExpected = true;
            this._iLength++;
            return true;
        }

        toString(): string {
            var sMsg: string = this._pRule.left + " -> ";
            var sExpected: string = "";
            var pRight: string[] = this._pRule.right;

            for (var k = 0; k < pRight.length; k++) {
                if (k === this._iPos) {
                    sMsg += ". ";
                }
                sMsg += pRight[k] + " ";
            }

            if (this._iPos === pRight.length) {
                sMsg += ". ";
            }

            if (isDef(this._pExpected)) {
                sExpected = ", ";
                for (var l in this._pExpected) {
                    sExpected += l + "/";
                }
                if (sExpected !== ", ") {
                    sMsg += sExpected;
                }
            }

            sMsg = sMsg.slice(0, sMsg.length - 1);
            return sMsg;
        }
    }

    class State implements IState {
        private _pItemList: IItem[];
        private _pNextStates: IStateMap;
        private _iIndex:  number ;
        private _nBaseItems:  number ;

        /**@inline*/  get items(): IItem[] {
            return this._pItemList;
        }

        /**@inline*/  get numBaseItems():  number  {
            return this._nBaseItems;
        }

        /**@inline*/  get index():  number  {
            return this._iIndex;
        }

        /**@inline*/  set index(iIndex:  number ) {
            this._iIndex = iIndex;
        }

        /**@inline*/  get nextStates(): IStateMap {
            return this._pNextStates;
        }

        constructor () {
            this._pItemList = <IItem[]>[];
            this._pNextStates = <IStateMap>{};
            this._iIndex = 0;
            this._nBaseItems = 0;
        }

        hasItem(pItem: IItem, eType: EParserType): IItem {
            var i;
            var pItems: IItem[] = this._pItemList;
            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].isEqual(pItem, eType)) {
                    return pItems[i];
                }
            }
            return null;
        }

        hasParentItem(pItem: IItem): IItem {
            var i;
            var pItems = this._pItemList;
            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].isParentItem(pItem)) {
                    return pItems[i];
                }
            }
            return null;
        }

        hasChildItem(pItem: IItem): IItem {
            var i;
            var pItems = this._pItemList;
            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].isChildItem(pItem)) {
                    return pItems[i];
                }
            }
            return null;
        }

        hasRule(pRule:IRule, iPos:  number ): bool {
            var i: number  = 0;
            var pItemList:IItem[] = this._pItemList;
            var pItem:IItem;

            for(i = 0; i < this._nBaseItems; i++){
                pItem = pItemList[i];
                if(pItem.rule === pRule && pItem.position === iPos){
                    return true;
                }
            }

            return false;
        }

        /**@inline*/  isEmpty(): bool {
            return !(this._pItemList.length);
        }

        isEqual(pState: IState, eType: EParserType): bool {

            var pItemsA: IItem[] = this._pItemList;
            var pItemsB: IItem[] = pState.items;

            if (this._nBaseItems !== pState.numBaseItems) {
                return false;
            }
            var nItems = this._nBaseItems;
            var i, j;
            var isEqual;
            for (i = 0; i < nItems; i++) {
                isEqual = false;
                for (j = 0; j < nItems; j++) {
                    if (pItemsA[i].isEqual(pItemsB[j], eType)) {
                        isEqual = true;
                        break;
                    }
                }
                if (!isEqual) {
                    return false;
                }
            }
            return true;
        }

        push(pItem: IItem): void {
            if (this._pItemList.length === 0 || pItem.position > 0) {
                this._nBaseItems += 1;
            }
            pItem.state = this;
            this._pItemList.push(pItem);
        }

        tryPush_LR0(pRule: IRule, iPos:  number ): bool {
            var i:  number ;
            var pItems: IItem[] = this._pItemList;
            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].rule === pRule && pItems[i].position === iPos) {
                    return false;
                }
            }
            var pItem: IItem = new Item(pRule, iPos);
            this.push(pItem);
            return true;
        }

        tryPush_LR(pRule: IRule, iPos:  number , sExpectedSymbol: string): bool {
            var i:  number ;
            var pItems: IItem[] = <IItem[]>(this._pItemList);

            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].rule === pRule && pItems[i].position === iPos) {
                    return pItems[i].addExpected(sExpectedSymbol);
                }
            }

            var pExpected: BoolMap = <BoolMap>{};
            pExpected[sExpectedSymbol] = true;

            var pItem: IItem = new Item(pRule, iPos, pExpected);
            this.push(pItem);
            return true;
        }

        getNextStateBySymbol(sSymbol: string): IState {
            if (isDef(this._pNextStates[sSymbol])) {
                return this._pNextStates[sSymbol];
            }
            else {
                return null;
            }
        }

        addNextState(sSymbol: string, pState: IState): bool {
            if (isDef(this._pNextStates[sSymbol])) {
                return false;
            }
            else {
                this._pNextStates[sSymbol] = pState;
                return true;
            }
        }

        /**@inline*/  deleteNotBase(): void {
            this._pItemList.length = this._nBaseItems;
        }

        toString(isBase: bool): string {
            var len:  number  = 0;
            var sMsg: string;
            var pItemList: IItem[] = this._pItemList;

            sMsg = "State " + this._iIndex + ":\n";
            len = isBase ? this._nBaseItems : pItemList.length;

            for (var j = 0; j < len; j++) {
                sMsg += "\t\t";
                sMsg += pItemList[j].toString();
                sMsg += "\n";
            }

            return sMsg;
        }
    }

    export class ParseTree implements IParseTree {
        private _pRoot: IParseNode;
        private _pNodes: IParseNode[];
        private _pNodesCountStack:  number [];
        private _isOptimizeMode: bool;

        /**@inline*/  get root(): IParseNode {
            return this._pRoot;
        }

        /**@inline*/  set root(pRoot: IParseNode) {
            this._pRoot = pRoot;
        }

        constructor () {
            this._pRoot = null;
            this._pNodes = <IParseNode[]>[];
            this._pNodesCountStack = < number []>[];
            this._isOptimizeMode = false;
        }

        setRoot(): void {
            this._pRoot = this._pNodes.pop();
        }

        setOptimizeMode(isOptimize: bool): void {
            this._isOptimizeMode = isOptimize;
        }

        addNode(pNode: IParseNode): void {
            this._pNodes.push(pNode);
            this._pNodesCountStack.push(1);
        }

        reduceByRule(pRule: IRule, eCreate: ENodeCreateMode = ENodeCreateMode.k_Default): void {
            var iReduceCount:  number  = 0;
            var pNodesCountStack:  number [] = this._pNodesCountStack;
            var pNode: IParseNode;
            var iRuleLength:  number  = pRule.right.length;
            var pNodes: IParseNode[] = this._pNodes;
            var nOptimize:  number  = this._isOptimizeMode ? 1 : 0;

            while (iRuleLength) {
                iReduceCount += pNodesCountStack.pop();
                iRuleLength--;
            }

            if ((eCreate === ENodeCreateMode.k_Default && iReduceCount > nOptimize) || (eCreate === ENodeCreateMode.k_Necessary)) {
                pNode = <IParseNode>{
                            name: pRule.left,
                            children: null,
                            parent: null,
                            value: "" ,
                            isAnalyzed: false,
                            position: this._pNodes.length
                        };

                while (iReduceCount) {
                    this.addLink(pNode, pNodes.pop());
                    iReduceCount -= 1;
                }

                pNodes.push(pNode);
                pNodesCountStack.push(1);
            }
            else {
                pNodesCountStack.push(iReduceCount);
            }
        }

        toString(): string {
            if (this._pRoot) {
                return this.toStringNode(this._pRoot);
            }
            else {
                return "";
            }
        }

        clone(): IParseTree {
            var pTree = new ParseTree();
            pTree.root = this.cloneNode(this._pRoot);
            return pTree;
        }

        /**@inline*/  getNodes(): IParseNode[]{
            return this._pNodes;
        }

        /**@inline*/  getLastNode(): IParseNode{
            return this._pNodes[this._pNodes.length - 1];
        }

        private addLink(pParent: IParseNode, pNode: IParseNode): void {
            if (!pParent.children) {
                pParent.children = <IParseNode[]>[];
            }
            pParent.children.push(pNode);
            pNode.parent = pParent;
        }

        private cloneNode(pNode: IParseNode): IParseNode {
            var pNewNode: IParseNode;
            pNewNode = <IParseNode>{
                name: pNode.name,
                value: pNode.value,
                children: null,
                parent: null,
                isAnalyzed: pNode.isAnalyzed,
                position: pNode.position
            };

            var pChildren: IParseNode[] = pNode.children;
            for (var i = 0; pChildren && i < pChildren.length; i++) {
                this.addLink(pNewNode, this.cloneNode(pChildren[i]));
            }

            return pNewNode;
        }

        private toStringNode(pNode: IParseNode, sPadding: string = ""): string {
            var sRes: string = sPadding + "{\n";
            var sOldPadding: string = sPadding;
            var sDefaultPadding: string = "  ";

            sPadding += sDefaultPadding;

            if (pNode.value) {
                sRes += sPadding + "name : \"" + pNode.name + "\"" + ",\n";
                sRes += sPadding + "value : \"" + pNode.value + "\"" + "\n";
            }
            else {

                sRes += sPadding + "name : \"" + pNode.name + "\"" + "\n";
                sRes += sPadding + "children : [";

                var pChildren: IParseNode[] = pNode.children;

                if (pChildren) {
                    sRes += "\n";
                    sPadding += sDefaultPadding;

                    for (var i = pChildren.length - 1; i >= 0; i--) {
                        sRes += this.toStringNode(pChildren[i], sPadding);
                        sRes += ",\n";
                    }

                    sRes = sRes.slice(0, sRes.length - 2);
                    sRes += "\n";
                    sRes += sOldPadding + sDefaultPadding + "]\n";
                }
                else {
                    sRes += " ]\n";
                }
            }
            sRes += sOldPadding + "}";
            return sRes;
        }
    }

    class Lexer implements ILexer {
        private _iLineNumber:  number ;
        private _iColumnNumber:  number ;
        private _sSource: string;
        private _iIndex:  number ;
        private _pParser: IParser;
        private _pPunctuatorsMap: StringMap;
        private _pKeywordsMap: StringMap;
        private _pPunctuatorsFirstSymbols: BoolMap;

        constructor (pParser: IParser) {
            this._iLineNumber = 0;
            this._iColumnNumber = 0;
            this._sSource = "";
            this._iIndex = 0;
            this._pParser = pParser;
            this._pPunctuatorsMap = <StringMap>{};
            this._pKeywordsMap = <StringMap>{};
            this._pPunctuatorsFirstSymbols = <BoolMap>{};
        }

        addPunctuator(sValue: string, sName?: string): string {
            if (sName === undefined && sValue.length === 1) {
                sName = "T_PUNCTUATOR_" + sValue.charCodeAt(0);

            }
            this._pPunctuatorsMap[sValue] = sName;
            this._pPunctuatorsFirstSymbols[sValue[0]] = true;
            return sName;
        }

        addKeyword(sValue: string, sName: string): string {
            this._pKeywordsMap[sValue] = sName;
            return sName;
        }

        getTerminalValueByName(sName: string): string{
            var sValue: string = null;

            for(sValue in this._pPunctuatorsMap){
                if(this._pPunctuatorsMap[sValue] === sName){
                    return sValue;
                }
            }

            for(sValue in this._pKeywordsMap){
                if(this._pKeywordsMap[sValue] === sName){
                    return sValue;
                }
            }

            return sName;
        }

        init(sSource: string): void {
            this._sSource = sSource;
            this._iLineNumber = 0;
            this._iColumnNumber = 0;
            this._iIndex = 0;
        }

        getNextToken(): IToken {
            var ch: string = this.currentChar();
            if (!ch) {
                return <IToken>{
                    name:  "$" ,
                    value:  "$" ,
                    start: this._iColumnNumber,
                    end: this._iColumnNumber,
                    line: this._iLineNumber
                };
            }
            var eType: ETokenType = this.identityTokenType();
            var pToken: IToken;
            switch (eType) {
                case ETokenType.k_NumericLiteral:
                    pToken = this.scanNumber();
                    break;
                case ETokenType.k_CommentLiteral:
                    this.scanComment();
                    pToken = this.getNextToken();
                    break;
                case ETokenType.k_StringLiteral:
                    pToken = this.scanString();
                    break;
                case ETokenType.k_PunctuatorLiteral:
                    pToken = this.scanPunctuator();
                    break;
                case ETokenType.k_IdentifierLiteral:
                    pToken = this.scanIdentifier();
                    break;
                case ETokenType.k_WhitespaceLiteral:
                    this.scanWhiteSpace();
                    pToken = this.getNextToken();
                    break;
                default:
                    this._error( 2101 ,
                                <IToken>{
                                    name:  "UNNOWN" ,
                                    value: ch + this._sSource[this._iIndex + 1],
                                    start: this._iColumnNumber,
                                    end: this._iColumnNumber + 1,
                                    line: this._iLineNumber
                                });
            }
            return pToken;
        }

        /**@inline*/  _getIndex():  number  {
            return this._iIndex;
        }

        /**@inline*/  _setSource(sSource: string): void {
            this._sSource = sSource;
        }

        /**@inline*/  _setIndex(iIndex:  number ): void {
            this._iIndex = iIndex;
        }

        private _error(eCode:  number , pToken: IToken): void {
            var pLocation: ISourceLocation = <ISourceLocation>{
                                                file: this._pParser.getParseFileName(),
                                                line: this._iLineNumber
                                             };
            var pInfo:Object = {
                tokenValue: pToken.value,
                tokenType: pToken.type
            };

            var pLogEntity: ILoggerEntity = <ILoggerEntity>{code: eCode, info: pInfo, location: pLocation};

            akra.logger["error"](pLogEntity);

            throw new Error(eCode.toString());
        }

        private identityTokenType(): ETokenType {
            if (this.isIdentifierStart()) {
                return ETokenType.k_IdentifierLiteral;
            }
            if (this.isWhiteSpaceStart()) {
                return ETokenType.k_WhitespaceLiteral;
            }
            if (this.isStringStart()) {
                return ETokenType.k_StringLiteral;
            }
            if (this.isCommentStart()) {
                return ETokenType.k_CommentLiteral;
            }
            if (this.isNumberStart()) {
                return ETokenType.k_NumericLiteral;
            }
            if (this.isPunctuatorStart()) {
                return ETokenType.k_PunctuatorLiteral;
            }
            return ETokenType.k_Unknown;
        }

        private isNumberStart(): bool {
            var ch: string = this.currentChar();

            if ((ch >= '0') && (ch <= '9')) {
                return true;
            }

            var ch1: string = this.nextChar();
            if (ch === "." && (ch1 >= '0') && (ch1 <= '9')) {
                return true;
            }

            return false;
        }

        private isCommentStart(): bool {
            var ch: string = this.currentChar();
            var ch1: string = this.nextChar();

            if (ch === "/" && (ch1 === "/" || ch1 === "*")) {
                return true;
            }

            return false;
        }

        private isStringStart(): bool {
            var ch: string = this.currentChar();
            if (ch === "\"" || ch === "'") {
                return true;
            }
            return false;
        }

        private isPunctuatorStart(): bool {
            var ch: string = this.currentChar();
            if (this._pPunctuatorsFirstSymbols[ch]) {
                return true;
            }
            return false;
        }

        private isWhiteSpaceStart(): bool {
            var ch: string = this.currentChar();
            if (ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t') {
                return true;
            }
            return false;
        }

        private isIdentifierStart(): bool {
            var ch: string = this.currentChar();
            if ((ch === '_') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                return true;
            }
            return false;
        }

        private isLineTerminator(sSymbol: string): bool {
            return (sSymbol === '\n' || sSymbol === '\r' || sSymbol === '\u2028' || sSymbol === '\u2029');
        }

        private isWhiteSpace(sSymbol: string): bool {
            return (sSymbol === ' ') || (sSymbol === '\t');
        }

        private  /**@inline*/  isKeyword(sValue: string): bool {
            return !!(this._pKeywordsMap[sValue]);
        }

        private  /**@inline*/  isPunctuator(sValue: string): bool {
            return !!(this._pPunctuatorsMap[sValue]);
        }

        private  /**@inline*/  nextChar(): string {
            return this._sSource[this._iIndex + 1];
        }

        private  /**@inline*/  currentChar(): string {
            return this._sSource[<number>this._iIndex];
        }

        private  /**@inline*/  readNextChar(): string {
            this._iIndex++;
            this._iColumnNumber++;
            return this._sSource[<number>this._iIndex];
        }

        private scanString(): IToken {
            var chFirst: string = this.currentChar();
            var sValue: string = chFirst;
            var ch: string = null;
            var chPrevious: string = chFirst;
            var isGoodFinish: bool = false;
            var iStart:  number  = this._iColumnNumber;

            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    break;
                }
                sValue += ch;
                if (ch === chFirst && chPrevious !== '\\') {
                    isGoodFinish = true;
                    this.readNextChar();
                    break;
                }
                chPrevious = ch;
            }

            if (isGoodFinish) {
                return <IToken>{
                    name:  "T_STRING" ,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber - 1,
                    line: this._iLineNumber
                };
            }
            else {
                if (!ch) {
                    ch =  "EOF" ;
                }
                sValue += ch;

                this._error( 2102 , <IToken> {
                    type: ETokenType.k_StringLiteral,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber,
                    line: this._iLineNumber
                });
                return null;
            }
        }

        private scanPunctuator(): IToken {
            var sValue: string = this.currentChar();
            var ch: string;
            var iStart:  number  = this._iColumnNumber;

            while (true) {
                ch = this.readNextChar();
                if (ch) {
                    sValue += ch;
                    this._iColumnNumber++;
                    if (!this.isPunctuator(sValue)) {
                        sValue = sValue.slice(0, sValue.length - 1);
                        break;
                    }
                }
                else {
                    break;
                }
            }

            return <IToken>{
                name: this._pPunctuatorsMap[sValue],
                value: sValue,
                start: iStart,
                end: this._iColumnNumber - 1,
                line: this._iLineNumber
            };
        }

        private scanNumber(): IToken {
            var ch: string = this.currentChar();
            var sValue: string = "";
            var isFloat: bool = false;
            var chPrevious: string = ch;
            var isGoodFinish: bool = false;
            var iStart:  number  = this._iColumnNumber;
            var isE: bool = false;

            if (ch === '.') {
                sValue += 0;
                isFloat = true;
            }

            sValue += ch;

            while (true) {
                ch = this.readNextChar();
                if (ch === '.') {
                    if (isFloat) {
                        break;
                    }
                    else {
                        isFloat = true;
                    }
                }
                else if (ch === 'e') {
                    if (isE) {
                        break;
                    }
                    else {
                        isE = true;
                    }
                }
                else if (((ch === '+' || ch === '-') && chPrevious === 'e')) {
                    sValue += ch;
                    chPrevious = ch;
                    continue;
                }
                else if (ch === 'f' && isFloat) {
                    ch = this.readNextChar();
                    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                        break;
                    }
                    isGoodFinish = true;
                    break;
                }
                else if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                    break;
                }
                else if (!((ch >= '0') && (ch <= '9')) || !ch) {
                    if ((isE && chPrevious !== '+' && chPrevious !== '-' && chPrevious !== 'e') || !isE) {
                        isGoodFinish = true;
                    }
                    break;
                }
                sValue += ch;
                chPrevious = ch;
            }

            if (isGoodFinish) {
                var sName = isFloat ?  "T_FLOAT"  :  "T_UINT" ;
                return {
                    name: sName,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber - 1,
                    line: this._iLineNumber
                };
            }
            else {
                if (!ch) {
                    ch =  "EOF" ;
                }
                sValue += ch;
                this._error( 2102 , <IToken> {
                    type: ETokenType.k_NumericLiteral,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber,
                    line: this._iLineNumber
                });
                return null;
            }
        }

        private scanIdentifier(): IToken {
            var ch: string = this.currentChar();
            var sValue: string = ch;
            var iStart:  number  = this._iColumnNumber;
            var isGoodFinish: bool = false;

            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    isGoodFinish = true;
                    break;
                }
                if (!((ch === '_') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'))) {
                    isGoodFinish = true;
                    break;
                }
                sValue += ch;
            }

            if (isGoodFinish) {
                if (this.isKeyword(sValue)) {
                    return <IToken>{
                        name: this._pKeywordsMap[sValue],
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                }
                else {
                    var sName = this._pParser.isTypeId(sValue) ?  "T_TYPE_ID"  :  "T_NON_TYPE_ID" ;
                    return <IToken> {
                        name: sName,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                }
            }
            else {
                if (!ch) {
                    ch =  "EOF" ;
                }
                sValue += ch;
                this._error( 2102 , <IToken> {
                    type: ETokenType.k_IdentifierLiteral,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber,
                    line: this._iLineNumber
                });
                return null;
            }
        }

        private scanWhiteSpace(): bool {
            var ch: string = this.currentChar();

            while (true) {
                if (!ch) {
                    break;
                }
                if (this.isLineTerminator(ch)) {
                    if(ch === "\r" && this.nextChar() === "\n"){
                        this._iLineNumber--;
                    }
                    this._iLineNumber++;
                    ch = this.readNextChar();
                    this._iColumnNumber = 0;
                    continue;
                }
                else if (ch === '\t') {
                    this._iColumnNumber += 3;
                }
                else if (ch !== ' ') {
                    break;
                }
                ch = this.readNextChar();
            }

            return true;
        }

        private scanComment(): bool {
            var sValue: string = this.currentChar();
            var ch: string = this.readNextChar();
            sValue += ch;

            if (ch === '/') {
//Line Comment
                while (true) {
                    ch = this.readNextChar();
                    if (!ch) {
                        break;
                    }
                    if (this.isLineTerminator(ch)) {
                        if(ch === "\r" && this.nextChar() === "\n"){
                            this._iLineNumber--;
                        }
                        this._iLineNumber++;
                        this.readNextChar();
                        this._iColumnNumber = 0;
                        break;
                    }
                    sValue += ch;
                }

                return true;
            }
            else {
//Multiline Comment
                var chPrevious: string = ch;
                var isGoodFinish: bool = false;
                var iStart:  number  = this._iColumnNumber;

                while (true) {
                    ch = this.readNextChar();
                    if (!ch) {
                        break;
                    }
                    sValue += ch;
                    if (ch === '/' && chPrevious === '*') {
                        isGoodFinish = true;
                        this.readNextChar();
                        break;
                    }
                    if (this.isLineTerminator(ch)) {
                        if(ch === "\r" && this.nextChar() === "\n"){
                            this._iLineNumber--;
                        }
                        this._iLineNumber++;
                        this._iColumnNumber = -1;
                    }
                    chPrevious = ch;
                }

                if (isGoodFinish) {
                    return true;
                }
                else {
                    if (!ch) {
                        ch =  "EOF" ;
                    }
                    sValue += ch;
                    this._error( 2102 , <IToken> {
                        type: ETokenType.k_CommentLiteral,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });

                }

            }
        }
    }


    export interface IOperationMap {
        [grammarSymbol: string]: IOperation;
        [stateIndex:  number ]: IOperation;
    }

    export interface IOperationDMap {
        [stateIndex:  number ]: IOperationMap;
    }

    export interface IRuleMap {
        [ruleIndex:  number ]: IRule;
        [ruleName: string]: IRule;
    }

    export interface IRuleDMap {
        [ruleIndex:  number ]: IRuleMap;
        [ruleName: string]: IRuleMap;
    }

    export interface IRuleFunctionMap {
        [grammarSymbolOrFuncName: string]: IRuleFunction;
    }

    export interface IRuleFunctionDMap {
        [stateIndex:  number ]: IRuleFunctionMap;
    }

    export interface IAdditionalFuncInfo{
        name: string;
        position:  number ;
        rule: IRule;
    }

    export class Parser implements IParser {
// //Input

        private _sSource: string;
        private _iIndex:  number ;
        private _sFileName: string;

//Output

        private _pSyntaxTree: IParseTree;
        private _pTypeIdMap: BoolMap;

//Process params

        private _pLexer: ILexer;
        private _pStack:  number [];
        private _pToken: IToken;

//For async loading of files work fine

        private _fnFinishCallback: IFinishFunc;
        private _pCaller: any;

//Grammar Info

        private _pSymbolMap: BoolMap;
        private _pSyntaxTable: IOperationDMap;
        private _pReduceOperationsMap: IOperationMap;
        private _pShiftOperationsMap: IOperationMap;
        private _pSuccessOperation: IOperation;

        private _pFirstTerminalsDMap: BoolDMap;
        private _pFollowTerminalsDMap: BoolDMap;

        private _pRulesDMap: IRuleDMap;
        private _pStateList: IState[];
        private _nRules:  number ;

        private _pAdditionalFuncInfoList: IAdditionalFuncInfo[];
        private _pAdditionalFunctionsMap: IRuleFunctionMap;

        private _pAdidtionalFunctByStateDMap: IRuleFunctionDMap;

        private _eType: EParserType;

        private _pGrammarSymbols: StringMap;

//Additioanal info

        private _pRuleCreationModeMap: IntMap;
        private _eParseMode: EParseMode;

// private _isSync: bool;

//Temp

        private _pStatesTempMap: IStateMap;
        private _pBaseItemList: IItem[];
        private _pExpectedExtensionDMap: BoolDMap;


        constructor () {
            this._sSource = "";
            this._iIndex = 0;

            this._pSyntaxTree = null;
            this._pTypeIdMap = null;

            this._pLexer = null;
            this._pStack = < number []>[];
            this._pToken = null;

            this._fnFinishCallback = null;
            this._pCaller = null;

            this._pSymbolMap = <BoolMap><any>{ "$" : true};
            this._pSyntaxTable = null;
            this._pReduceOperationsMap = null;
            this._pShiftOperationsMap = null;
            this._pSuccessOperation = null;

            this._pFirstTerminalsDMap = null;
            this._pFollowTerminalsDMap = null;
            this._pRulesDMap = null;
            this._pStateList = null;
            this._nRules = 0;
            this._pAdditionalFuncInfoList = null;
            this._pAdditionalFunctionsMap = null;
            this._pAdidtionalFunctByStateDMap = null;

            this._eType = EParserType.k_LR0;

            this._pRuleCreationModeMap = null;
            this._eParseMode = EParseMode.k_AllNode;

// this._isSync = false;

            this._pStatesTempMap = null;
            this._pBaseItemList = null;

            this._pExpectedExtensionDMap = null;

            this._sFileName = "stdin";;
        }

        isTypeId(sValue: string): bool {
            return !!(this._pTypeIdMap[sValue]);
        }

        returnCode(pNode: IParseNode): string {
            if (pNode) {
                if (pNode.value) {
                    return pNode.value + " ";
                }
                else if (pNode.children) {
                    var sCode: string = "";
                    var i:  number  = 0;
                    for (i = pNode.children.length - 1; i >= 0; i--) {
                        sCode += this.returnCode(pNode.children[i]);
                    }
                    return sCode;
                }
            }
            return "";
        }

        init(sGrammar: string, eMode?: EParseMode = EParseMode.k_AllNode, eType?: EParserType = EParserType.k_LALR): bool {
            try {
                this._eType = eType;
                this._pLexer = new Lexer(this);
                this._eParseMode = eMode;
                this.generateRules(sGrammar);
                this.buildSyntaxTable();
                this.generateFunctionByStateMap();
                if(!bf.testAll(eMode, EParseMode.k_DebugMode)){
                    this.clearMem();
                }
                return true;
            }
            catch (e) {
                { logger.setSourceLocation( "util/Parser.ts" , 1397 ); logger.log(e.stack); } ;
// error("Could`not initialize parser. Error with code has occurred: " + e.message + ". See log for more info.");
                return false;
            }
        }

        parse(sSource: string, fnFinishCallback?: IFinishFunc = null, pCaller?: any = null): EParserCode {
             try {
                this.defaultInit();
                this._sSource = sSource;
                this._pLexer.init(sSource);

//this._isSync = isSync;

                this._fnFinishCallback = fnFinishCallback;
                this._pCaller = pCaller;

                var pTree:IParseTree = this._pSyntaxTree;
                var pStack: number [] = this._pStack;
                var pSyntaxTable:IOperationDMap = this._pSyntaxTable;

                var isStop:bool = false;
                var isError:bool = false;
                var isPause:bool = false;
                var pToken:IToken = this.readToken();

                var pOperation:IOperation;
                var iRuleLength: number ;

                var eAdditionalOperationCode: EOperationType;
                var iStateIndex:  number  = 0;

                while (!isStop) {
                    pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                    if (isDef(pOperation)) {
                        switch (pOperation.type) {
                            case EOperationType.k_Success:
                                isStop = true;
                                break;

                            case EOperationType.k_Shift:

                                iStateIndex = pOperation.index;
                                pStack.push(iStateIndex);
                                pTree.addNode(<IParseNode>pToken);

                                eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);

                                if(eAdditionalOperationCode === EOperationType.k_Error){
                                    isError = true;
                                    isStop = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Pause){
                                    this._pToken = null;
                                    isStop = true;
                                    isPause = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Ok){
                                    pToken = this.readToken();
                                }

                                break;

                            case EOperationType.k_Reduce:

                                iRuleLength = pOperation.rule.right.length;
                                pStack.length -= iRuleLength;
                                iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                pStack.push(iStateIndex);
                                pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);

                                eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);

                                if(eAdditionalOperationCode === EOperationType.k_Error){
                                    isError = true;
                                    isStop = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Pause){
                                    this._pToken = pToken;
                                    isStop = true;
                                    isPause = true;
                                }

                                break;
                        }
                    }
                    else {
                        isError = true;
                        isStop = true;
                    }
                }
            }
            catch (e) {
// debug_print(e.stack);
                this._sFileName = "stdin";
                return EParserCode.k_Error;
            }

            if (isPause) {
                return EParserCode.k_Pause;
            }

            if (!isError) {
                pTree.setRoot();
                if (!isNull(this._fnFinishCallback)) {
                    this._fnFinishCallback.call(this._pCaller, EParserCode.k_Ok, this.getParseFileName());
                }
                this._sFileName = "stdin";
                return EParserCode.k_Ok;
            }
            else {
                this._error( 2051 , pToken);
                if (!isNull(this._fnFinishCallback)) {
                    this._fnFinishCallback.call(this._pCaller, EParserCode.k_Error, this.getParseFileName());
                }
                this._sFileName = "stdin";
                return EParserCode.k_Error;
            }
        }

        setParseFileName(sFileName: string): void {
            this._sFileName = sFileName;
        }

        getParseFileName(): string{
            return this._sFileName;
        }

        pause(): EParserCode {
            return EParserCode.k_Pause;
        }

        resume(): EParserCode {
            return this.resumeParse();
        }

        printStates(isBaseOnly?: bool = true): void {
            if(!isDef(this._pStateList)){
                { logger.setSourceLocation( "util/Parser.ts" , 1535 ); logger.log("It`s impossible to print states. You must init parser in debug-mode"); } ;
                return;
            }
            var sMsg: string = "\n" + this.statesToString(isBaseOnly);
            { logger.setSourceLocation( "util/Parser.ts" , 1539 ); logger.log(sMsg); } ;
        }

        printState(iStateIndex:  number , isBaseOnly?: bool = true): void {
            if(!isDef(this._pStateList)){
                { logger.setSourceLocation( "util/Parser.ts" , 1544 ); logger.log("It`s impossible to print states. You must init parser in debug-mode"); } ;
                return;
            }

            var pState:IState = this._pStateList[iStateIndex];
            if(!isDef(pState)){
                { logger.setSourceLocation( "util/Parser.ts" , 1550 ); logger.log("Can not print stete with index: " + iStateIndex.toString()); } ;
                return;
            }

            var sMsg: string = "\n" + pState.toString(isBaseOnly);
            { logger.setSourceLocation( "util/Parser.ts" , 1555 ); logger.log(sMsg); } ;
        }

        getGrammarSymbols(): StringMap{
            return this._pGrammarSymbols;
        }

        /**@inline*/  getSyntaxTree(): IParseTree {
            return this._pSyntaxTree;
        }

        _saveState(): IParserState {
            return {
                source: this._sSource,
                index: this._pLexer._getIndex(),
                fileName: this._sFileName,
                tree: this._pSyntaxTree,
                types: this._pTypeIdMap,
                stack: this._pStack,
                token: this._pToken,
                fnCallback: this._fnFinishCallback,
                caller: this._pCaller
            };
        }

        _loadState(pState: IParserState): void {
            this._sSource = pState.source;
            this._iIndex = pState.index;
            this._sFileName = pState.fileName;
            this._pSyntaxTree = pState.tree;
            this._pTypeIdMap = pState.types;
            this._pStack = pState.stack;
            this._pToken = pState.token;
            this._fnFinishCallback = pState.fnCallback;
            this._pCaller = pState.caller;

            this._pLexer._setSource(pState.source);
            this._pLexer._setIndex(pState.index);
        }



        protected addAdditionalFunction(sFuncName: string, fnRuleFunction: IRuleFunction): void {
            if(isNull(this._pAdditionalFunctionsMap)){
                this._pAdditionalFunctionsMap = <IRuleFunctionMap>{};
            }
            this._pAdditionalFunctionsMap[sFuncName] = fnRuleFunction;
        }

        protected addTypeId(sIdentifier: string): void {
            if(isNull(this._pTypeIdMap)){
                this._pTypeIdMap = <BoolMap>{};
            }
            this._pTypeIdMap[sIdentifier] = true;
        }

        protected defaultInit(): void {
            this._iIndex = 0;
            this._pStack = [0];
            this._pSyntaxTree = new ParseTree();
            this._pTypeIdMap = <BoolMap>{};

            this._pSyntaxTree.setOptimizeMode(bf.testAll(this._eParseMode, EParseMode.k_Optimize));
        }

        private _error(eCode:  number , pErrorInfo: any): void {
            var pLocation: ISourceLocation = <ISourceLocation>{};

            var pInfo:any = {
                tokenValue: null,
                line: null,
                column: null,
                stateIndex: null,
                oldNextStateIndex: null,
                newNextStateIndex: null,
                grammarSymbol: null,
                newOperation: null,
                oldOperation: null,
                expectedSymbol: null,
                unexpectedSymbol: null,
                badKeyword: null
            };

            var pLogEntity: ILoggerEntity = <ILoggerEntity>{code: eCode, info: pInfo, location: pLocation};

            if(eCode ===  2051 ){
                var pToken: IToken = <IToken>pErrorInfo;
                var iLine:  number  = pToken.line;
                var iColumn:  number  = pToken.start;

                pInfo.tokenValue = pToken.value;
                pInfo.line = iLine;
                pInfo.column = iColumn;

                pLocation.file = this.getParseFileName();
                pLocation.line = iLine;
            }
            else if(eCode ===  2001 ){
                var iStateIndex:  number  = pErrorInfo.stateIndex;
                var sSymbol: string = pErrorInfo.grammarSymbol;
                var pOldOperation: IOperation = pErrorInfo.oldOperation;
                var pNewOperation: IOperation = pErrorInfo.newOperation;

                pInfo.stateIndex = iStateIndex;
                pInfo.grammarSymbol = sSymbol;
                pInfo.oldOperation = this.operationToString(pOldOperation);
                pInfo.newOperation = this.operationToString(pNewOperation);

                pLocation.file = "GRAMMAR";
                pLocation.line = 0;
            }
            else if(eCode ===  2002 ){
                var iStateIndex:  number  = pErrorInfo.stateIndex;
                var sSymbol: string = pErrorInfo.grammarSymbol;
                var iOldNextStateIndex:  number  = pErrorInfo.oldNextStateIndex;
                var iNewNextStateIndex:  number  = pErrorInfo.newNextStateIndex;

                pInfo.stateIndex = iStateIndex;
                pInfo.grammarSymbol = sSymbol;
                pInfo.oldNextStateIndex = iOldNextStateIndex;
                pInfo.newNextStateIndex = iNewNextStateIndex;

                pLocation.file = "GRAMMAR";
                pLocation.line = 0;
            }
            else if(eCode ===  2003 ){
                var iLine:  number  = pErrorInfo.grammarLine;
                var sExpectedSymbol: string = pErrorInfo.expectedSymbol;
                var sUnexpectedSymbol: string = pErrorInfo.unexpectedSymbol;

                pInfo.expectedSymbol = sExpectedSymbol;
                pInfo.unexpectedSymbol = sExpectedSymbol;

                pLocation.file = "GRAMMAR";
                pLocation.line = iLine || 0;
            }
            else if(eCode ===  2004 ){
                var iLine:  number  = pErrorInfo.grammarLine;

                pLocation.file = "GRAMMAR";
                pLocation.line = iLine || 0;
            }
            else if(eCode ===  2005 ){
                var iLine:  number  = pErrorInfo.grammarLine;
                var sBadKeyword: string = pErrorInfo.badKeyword;

                pInfo.badKeyword = sBadKeyword;

                pLocation.file = "GRAMMAR";
                pLocation.line = iLine || 0;
            }

            akra.logger["error"](pLogEntity);

            throw new Error(eCode.toString());
        }

        private clearMem(): void {
            delete this._pFirstTerminalsDMap;
            delete this._pFollowTerminalsDMap;
            delete this._pRulesDMap;
            delete this._pStateList;
            delete this._pReduceOperationsMap;
            delete this._pShiftOperationsMap;
            delete this._pSuccessOperation;
            delete this._pStatesTempMap;
            delete this._pBaseItemList;
            delete this._pExpectedExtensionDMap;
        }

        private hasState(pState: IState, eType: EParserType) {
            var pStateList: IState[] = this._pStateList;
            var i:  number  = 0;

            for (i = 0; i < pStateList.length; i++) {
                if (pStateList[i].isEqual(pState, eType)) {
                    return pStateList[i];
                }
            }

            return null;
        }

        private isTerminal(sSymbol: string): bool {
            return !(this._pRulesDMap[sSymbol]);
        }

        private pushState(pState: IState): void {
            pState.index = this._pStateList.length;
            this._pStateList.push(pState);
        }

        private pushBaseItem(pItem: IItem): void {
            pItem.index = this._pBaseItemList.length;
            this._pBaseItemList.push(pItem);
        }

        private tryAddState(pState: IState, eType: EParserType): IState {
            var pRes = this.hasState(pState, eType);

            if (isNull(pRes)) {
                if (eType === EParserType.k_LR0) {
                    var pItems = pState.items;
                    for (var i = 0; i < pItems.length; i++) {
                        this.pushBaseItem(pItems[i]);
                    }
                }

                this.pushState(pState);
                this.closure(pState, eType);

                return pState;
            }

            return pRes;
        }

        private hasEmptyRule(sSymbol: string): bool {
            if (this.isTerminal(sSymbol)) {
                return false;
            }

            var pRulesDMap: IRuleDMap = this._pRulesDMap;
            for (var i in pRulesDMap[sSymbol]) {
                if (pRulesDMap[sSymbol][i].right.length === 0) {
                    return true;
                }
            }

            return false;
        }

        private pushInSyntaxTable(iIndex:  number , sSymbol: string, pOperation: IOperation): void {
            var pSyntaxTable: IOperationDMap = this._pSyntaxTable;
            if (!pSyntaxTable[iIndex]) {
                pSyntaxTable[iIndex] = <IOperationMap>{};
            }
            if (isDef(pSyntaxTable[iIndex][sSymbol])) {
                this._error( 2001 , {stateIndex: iIndex,
                                                           grammarSymbol: this.convertGrammarSymbol(sSymbol),
                                                           oldOperation: this._pSyntaxTable[iIndex][sSymbol],
                                                           newOperation: pOperation});
            }
            pSyntaxTable[iIndex][sSymbol] = pOperation;
        }

        private addStateLink(pState: IState, pNextState: IState, sSymbol: string): void {
            var isAddState: bool = pState.addNextState(sSymbol, pNextState);
            if (!isAddState) {
                this._error( 2002 , {stateIndex: pState.index,
                                                            oldNextStateIndex: pState.getNextStateBySymbol(sSymbol),
                                                            newNextStateIndex: pNextState.index,
                                                            grammarSymbol: this.convertGrammarSymbol(sSymbol)});
            }
        }

        private firstTerminal(sSymbol: string): BoolMap {
            if (this.isTerminal(sSymbol)) {
                return null;
            }

            if (isDef(this._pFirstTerminalsDMap[sSymbol])) {
                return this._pFirstTerminalsDMap[sSymbol];
            }

            var i: string = null, j:  number  = 0, k: string = null;
            var pRulesMap: IRuleMap = this._pRulesDMap[sSymbol];

            var pTempRes: BoolMap = <BoolMap>{};
            var pRes: BoolMap;

            var pRight: string[];
            var isFinish: bool;

            pRes = this._pFirstTerminalsDMap[sSymbol] = <BoolMap>{};

            if (this.hasEmptyRule(sSymbol)) {
                pRes[ "EMPTY" ] = true;
            }
            for (i in pRulesMap) {

                isFinish = false;
                pRight = pRulesMap[i].right;

                for (j = 0; j < pRight.length; j++) {

                    if (pRight[j] === sSymbol) {
                        if (pRes[ "EMPTY" ]) {
                            continue;
                        }
                        isFinish = true;
                        break;
                    }

                    pTempRes = this.firstTerminal(pRight[j]);

                    if (isNull(pTempRes)) {
                        pRes[pRight[j]] = true;
                    }
                    else {
                        for (k in pTempRes) {
                            pRes[k] = true;
                        }
                    }

                    if (!this.hasEmptyRule(pRight[j])) {
                        isFinish = true;
                        break;
                    }

                }

                if (!isFinish) {
                    pRes[ "EMPTY" ] = true;
                }

            }

            return pRes;
        }

        private followTerminal(sSymbol: string): BoolMap {
            if (isDef(this._pFollowTerminalsDMap[sSymbol])) {
                return this._pFollowTerminalsDMap[sSymbol];
            }

            var i: string = null, j: string = null, k:  number  = 0, l:  number  = 0, m: string = null;
            var pRulesDMap: IRuleDMap = this._pRulesDMap;

            var pTempRes: BoolMap;
            var pRes: BoolMap;

            var pRight: string[];
            var isFinish: bool;

            pRes = this._pFollowTerminalsDMap[sSymbol] = <BoolMap>{};

            for (i in pRulesDMap) {
                for (j in pRulesDMap[i]) {

                    pRight = pRulesDMap[i][j].right;

                    for (k = 0; k < pRight.length; k++) {

                        if (pRight[k] === sSymbol) {

                            if (k === pRight.length - 1) {
                                pTempRes = this.followTerminal(pRulesDMap[i][j].left);
                                for (m in pTempRes) {
                                    pRes[m] = true;
                                }
                            }
                            else {
                                isFinish = false;

                                for (l = k + 1; l < pRight.length; l++) {
                                    pTempRes = this.firstTerminal(pRight[l]);

                                    if (isNull(pTempRes)) {
                                        pRes[pRight[l]] = true;
                                        isFinish = true;
                                        break;
                                    }
                                    else {
                                        for (m in pTempRes) {
                                            pRes[m] = true;
                                        }
                                    }

                                    if (!pTempRes[ "EMPTY" ]) {
                                        isFinish = true;
                                        break;
                                    }
                                }

                                if (!isFinish) {
                                    pTempRes = this.followTerminal(pRulesDMap[i][j].left);
                                    for (m in pTempRes) {
                                        pRes[m] = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return pRes;
        }

        private firstTerminalForSet(pSet: string[], pExpected: BoolMap): BoolMap {
            var i:  number  = 0, j: string = null;

            var pTempRes: BoolMap;
            var pRes: BoolMap = <BoolMap>{};

            var isEmpty: bool;

            for (i = 0; i < pSet.length; i++) {
                pTempRes = this.firstTerminal(pSet[i]);

                if (isNull(pTempRes)) {
                    pRes[pSet[i]] = true;
                }

                isEmpty = false;

                for (j in pTempRes) {
                    if (j ===  "EMPTY" ) {
                        isEmpty = true;
                        continue;
                    }
                    pRes[j] = true;
                }

                if (!isEmpty) {
                    return pRes;
                }
            }

            for (j in pExpected) {
                pRes[j] = true;
            }

            return pRes;
        }

        private generateRules(sGrammarSource: string): void {
            var pAllRuleList: string[] = sGrammarSource.split(/\r?\n/);
            var pTempRule: string[];
            var pRule: IRule;
            var isLexerBlock: bool = false;

            this._pRulesDMap = <IRuleDMap>{};
            this._pAdditionalFuncInfoList = <IAdditionalFuncInfo[]>[];
            this._pRuleCreationModeMap = <IntMap>{};
            this._pGrammarSymbols = <StringMap>{};

            var i:  number  = 0, j:  number  = 0;

            var isAllNodeMode: bool = bf.testAll(< number >this._eParseMode, < number >EParseMode.k_AllNode);
            var isNegateMode: bool = bf.testAll(< number >this._eParseMode, < number >EParseMode.k_Negate);
            var isAddMode: bool = bf.testAll(< number >this._eParseMode, < number >EParseMode.k_Add);

            var pSymbolsWithNodeMap: IntMap = this._pRuleCreationModeMap;


            for (i = 0; i < pAllRuleList.length; i++) {
                if (pAllRuleList[i] === "" || pAllRuleList[i] === "\r") {
                    continue;
                }

                pTempRule = pAllRuleList[i].split(/\s* \s*/);

                if (isLexerBlock) {
                    if ((pTempRule.length === 3 || (pTempRule.length === 4 && pTempRule[3] === "")) &&
                        ((pTempRule[2][0] === "\"" || pTempRule[2][0] === "'") && pTempRule[2].length > 3)) {

//TERMINALS
                        if (pTempRule[2][0] !== pTempRule[2][pTempRule[2].length - 1]) {
                            this._error( 2003 , {unexpectedSymbol: pTempRule[2][pTempRule[2].length - 1],
                                                                           expectedSymbol: pTempRule[2][0],
                                                                           grammarLine: i});
                        }

                        pTempRule[2] = pTempRule[2].slice(1, pTempRule[2].length - 1);

                        var ch: string = pTempRule[2][0];
                        var sName: string;

                        if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                            sName = this._pLexer.addKeyword(pTempRule[2], pTempRule[0]);
                        }
                        else {
                            sName = this._pLexer.addPunctuator(pTempRule[2], pTempRule[0]);
                        }

                        this._pGrammarSymbols[sName] = pTempRule[2];
                    }

                    continue;
                }

                if (pTempRule[0] ===  "--LEXER--" ) {
                    isLexerBlock = true;
                    continue;
                }

//NON TERMNINAL RULES
                if (isDef(this._pRulesDMap[pTempRule[0]]) === false) {
                    this._pRulesDMap[pTempRule[0]] = <IRuleMap>{};
                }

                pRule = <IRule>{
                    left: pTempRule[0],
                    right: <string[]>[],
                    index: 0
                };
                this._pSymbolMap[pTempRule[0]] = true;
                this._pGrammarSymbols[pTempRule[0]] = pTempRule[0];

                if (isAllNodeMode) {
                    pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Default;
                }
                else if (isNegateMode && !isDef(pSymbolsWithNodeMap[pTempRule[0]])) {
                    pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Default;
                }
                else if (isAddMode && !isDef(pSymbolsWithNodeMap[pTempRule[0]])) {
                    pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Not;
                }

                for (j = 2; j < pTempRule.length; j++) {
                    if (pTempRule[j] === "") {
                        continue;
                    }
                    if (pTempRule[j] ===  "--AN" ) {
                        if (isAddMode) {
                            pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Necessary;
                        }
                        continue;
                    }
                    if (pTempRule[j] ===  "--NN" ) {
                        if (isNegateMode && !isAllNodeMode) {
                            pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Not;
                        }
                        continue;
                    }
                    if (pTempRule[j] ===  "--F" ) {
                        if ((!pTempRule[j + 1] || pTempRule[j + 1].length === 0)) {
                            this._error( 2004 , {grammarLine: i});
                        }

                        var pFuncInfo: IAdditionalFuncInfo = <IAdditionalFuncInfo>{name: pTempRule[j + 1],
                                                                                   position: pRule.right.length,
                                                                                   rule: pRule};
                        this._pAdditionalFuncInfoList.push(pFuncInfo);
                        j++;
                        continue;
                    }
                    if (pTempRule[j][0] === "'" || pTempRule[j][0] === "\"") {
                        if (pTempRule[j].length !== 3) {
                            this._error( 2005 , {badKeyword: pTempRule[j],
                                                                     grammarLine: i});
                        }
                        if (pTempRule[j][0] !== pTempRule[j][2]) {
                            this._error( 2003 , {unexpectedSymbol: pTempRule[j][2],
                                                                           expectedSymbol: pTempRule[j][0],
                                                                           grammarLine: i});
//this._error("Can`t generate rules from grammar! Unexpected symbol! Must be");
                        }
                        var sName: string = this._pLexer.addPunctuator(pTempRule[j][1]);
                        pRule.right.push(sName);
                        this._pSymbolMap[sName] = true;
                    }
                    else {
                        pRule.right.push(pTempRule[j]);
                        this._pSymbolMap[pTempRule[j]] = true;
                    }
                }

                pRule.index = this._nRules;
                this._pRulesDMap[pTempRule[0]][pRule.index] = pRule;
                this._nRules += 1;

            }
        }

        private generateFunctionByStateMap():void {
            if(isNull(this._pAdditionalFunctionsMap)){
                return;
            }

            var pStateList: IState[] = this._pStateList;
            var pFuncInfoList: IAdditionalFuncInfo[] = this._pAdditionalFuncInfoList;
            var pFuncInfo: IAdditionalFuncInfo;
            var pRule: IRule;
            var iPos:  number  = 0;
            var pFunc: IRuleFunction;
            var sGrammarSymbol: string;

            var i: number  = 0, j:  number  = 0;

            var pFuncByStateDMap:IRuleFunctionDMap = <IRuleFunctionDMap>{};
            pFuncByStateDMap = this._pAdidtionalFunctByStateDMap = <IRuleFunctionDMap>{};

            for(i = 0; i < pFuncInfoList.length; i++){
                pFuncInfo = pFuncInfoList[i];

                pFunc = this._pAdditionalFunctionsMap[pFuncInfo.name];
                if(!isDef(pFunc)){
                    continue;
                }

                pRule = pFuncInfo.rule;
                iPos = pFuncInfo.position;
                sGrammarSymbol = pRule.right[iPos - 1];

                for(j = 0; j < pStateList.length; j++){
                    if(pStateList[j].hasRule(pRule, iPos)){
                        if(!isDef(pFuncByStateDMap[pStateList[j].index])){
                            pFuncByStateDMap[pStateList[j].index] = <IRuleFunctionMap>{};
                        }

                        pFuncByStateDMap[pStateList[j].index][sGrammarSymbol] = pFunc;
                    }
                }
            }
        }

        private generateFirstState(eType: EParserType): void {
            if (eType === EParserType.k_LR0) {
                this.generateFirstState_LR0();
            }
            else {
                this.generateFirstState_LR();
            }
        }

        private generateFirstState_LR0(): void {
            var pState: IState = new State();
            var pItem: IItem = new Item(this._pRulesDMap[ "S" ][0], 0);

            this.pushBaseItem(pItem);
            pState.push(pItem);

            this.closure_LR0(pState);
            this.pushState(pState);
        }

        private generateFirstState_LR(): void {
            var pState: IState = new State();
            var pExpected: BoolMap = <BoolMap>{};
            pExpected[ "$" ] = true;

            pState.push(new Item(this._pRulesDMap[ "S" ][0], 0, pExpected));

            this.closure_LR(pState);
            this.pushState(pState);
        }

        private closure(pState: IState, eType: EParserType): IState {
            if (eType === EParserType.k_LR0) {
                return this.closure_LR0(pState);
            }
            else {
                this.closure_LR(pState);
            }
        }

        private closure_LR0(pState: IState): IState {
            var pItemList: IItem[] = pState.items;
            var i:  number  = 0, j: string = null;
            var sSymbol: string;

            for (i = 0; i < pItemList.length; i++) {
                sSymbol = pItemList[i].mark();

                if (sSymbol !==  "END"  && (!this.isTerminal(sSymbol))) {
                    for (j in this._pRulesDMap[sSymbol]) {
                        pState.tryPush_LR0(this._pRulesDMap[sSymbol][j], 0);
                    }
                }

            }
            return pState;
        }

        private closure_LR(pState: IState): IState {
            var pItemList: IItem[] = <IItem[]>(pState.items);
            var i:  number  = 0, j: string = null, k: string = null;
            var sSymbol: string;
            var pSymbols: BoolMap;
            var pTempSet: string[];
            var isNewExpected: bool = false;

            while (true) {
                if (i === pItemList.length) {
                    if (!isNewExpected) {
                        break;
                    }
                    i = 0;
                    isNewExpected = false;
                }
                sSymbol = pItemList[i].mark();

                if (sSymbol !==  "END"  && (!this.isTerminal(sSymbol))) {
                    pTempSet = pItemList[i].rule.right.slice(pItemList[i].position + 1);
                    pSymbols = this.firstTerminalForSet(pTempSet, pItemList[i].expectedSymbols);

                    for (j in this._pRulesDMap[sSymbol]) {
                        for (k in pSymbols) {
                            if (pState.tryPush_LR(this._pRulesDMap[sSymbol][j], 0, k)) {
                                isNewExpected = true;
                            }
                        }
                    }
                }

                i++;
            }

            return pState;
        }

        private nexeState(pState: IState, sSymbol: string, eType: EParserType): IState {
            if (eType === EParserType.k_LR0) {
                return this.nextState_LR0(pState, sSymbol);
            }
            else {
                return this.nextState_LR(pState, sSymbol);
            }
        }

        private nextState_LR0(pState: IState, sSymbol: string): IState {
            var pItemList: IItem[] = pState.items;
            var i:  number  = 0;
            var pNewState: IState = new State();

            for (i = 0; i < pItemList.length; i++) {
                if (sSymbol === pItemList[i].mark()) {
                    pNewState.push(new Item(pItemList[i].rule, pItemList[i].position + 1));
                }
            }

            return pNewState;
        }

        private nextState_LR(pState: IState, sSymbol: string): IState {
            var pItemList: IItem[] = <IItem[]>pState.items;
            var i:  number  = 0;
            var pNewState: IState = new State();

            for (i = 0; i < pItemList.length; i++) {
                if (sSymbol === pItemList[i].mark()) {
                    pNewState.push(new Item(pItemList[i].rule, pItemList[i].position + 1, pItemList[i].expectedSymbols));
                }
            }

            return pNewState;
        }

        private deleteNotBaseItems(): void {
            var i:  number  = 0;
            for (i = 0; i < this._pStateList.length; i++) {
                this._pStateList[i].deleteNotBase();
            }
        }

        private closureForItem(pRule: IRule, iPos:  number ): IState {
            var sIndex: string = "";
            sIndex += pRule.index + "_" + iPos;

            var pState: IState = this._pStatesTempMap[sIndex];
            if (isDef(pState)) {
                return pState;
            }
            else {
                var pExpected: BoolMap = <BoolMap>{};
                pExpected[ "##" ] = true;

                pState = new State();
                pState.push(new Item(pRule, iPos, pExpected));

                this.closure_LR(pState);
                this._pStatesTempMap[sIndex] = pState;

                return pState;
            }
        }

        private addLinkExpected(pItem: IItem, pItemX: IItem): void {
            var pTable: BoolDMap = this._pExpectedExtensionDMap;
            var iIndex:  number  = pItem.index;

            if (!isDef(pTable[iIndex])) {
                pTable[iIndex] = <BoolMap>{};
            }

            pTable[iIndex][pItemX.index] = true;
        }

        private determineExpected(pTestState: IState, sSymbol: string): void {
            var pStateX = pTestState.getNextStateBySymbol(sSymbol);

            if (isNull(pStateX)) {
                return;
            }

            var pItemListX: IItem[] = <IItem[]>pStateX.items;
            var pItemList: IItem[] = <IItem[]>pTestState.items;
            var pState: IState;
            var pItem: IItem;
                var i:  number  = 0, j:  number  = 0, k: string = null;

            var nBaseItemTest = pTestState.numBaseItems;
            var nBaseItemX = pStateX.numBaseItems;

            for (i = 0; i < nBaseItemTest; i++) {
                pState = this.closureForItem(pItemList[i].rule, pItemList[i].position);

                for (j = 0; j < nBaseItemX; j++) {
                    pItem = <IItem>pState.hasChildItem(pItemListX[j]);

                    if (pItem) {
                        var pExpected: BoolMap = pItem.expectedSymbols;

                        for (k in pExpected) {
                            if (k ===  "##" ) {
                                this.addLinkExpected(pItemList[i], pItemListX[j]);
                            }
                            else {
                                pItemListX[j].addExpected(k);
                            }
                        }
                    }
                }
            }
        }

        private generateLinksExpected(): void {
            var i:  number  = 0, j: string = null;
            var pStates: IState[] = this._pStateList;

            for (i = 0; i < pStates.length; i++) {
                for (j in this._pSymbolMap) {
                    this.determineExpected(pStates[i], j);
                }
            }
        }

        private expandExpected(): void {
            var pItemList: IItem[] = <IItem[]>this._pBaseItemList;
            var pTable: BoolDMap = this._pExpectedExtensionDMap;
            var i:  number  = 0, j: string = null;
            var sSymbol: string = null;
            var isNewExpected: bool = false;

            pItemList[0].addExpected( "$" );
            pItemList[0].isNewExpected = true;

            while (true) {

                if (i === pItemList.length) {
                    if (!isNewExpected) {
                        break;
                    }
                    isNewExpected = false;
                    i = 0;
                }

                if (pItemList[i].isNewExpected) {
                    var pExpected: BoolMap = pItemList[i].expectedSymbols;

                    for (sSymbol in pExpected) {
                        for (j in pTable[i]) {
                            if (pItemList[<number><any>j].addExpected(sSymbol)) {
                                isNewExpected = true;
                            }
                        }
                    }
                }

                pItemList[i].isNewExpected = false;
                i++;
            }
        }

        private generateStates(eType: EParserType): void {
            if (eType === EParserType.k_LR0) {
                this.generateStates_LR0();
            }
            else if (eType === EParserType.k_LR1) {
                this.generateStates_LR();
            }
            else if (eType === EParserType.k_LALR) {
                this.generateStates_LALR();
            }
        }

        private generateStates_LR0(): void {
            this.generateFirstState_LR0();

            var i:  number  = 0;
            var pStateList: IState[] = this._pStateList;
            var sSymbol: string = null;
            var pState: IState;

            for (i = 0; i < pStateList.length; i++) {
                for (sSymbol in this._pSymbolMap) {
                    pState = this.nextState_LR0(pStateList[i], sSymbol);

                    if (!pState.isEmpty()) {
                        pState = this.tryAddState(pState, EParserType.k_LR0);
                        this.addStateLink(pStateList[i], pState, sSymbol);
                    }
                }
            }
        }

        private generateStates_LR(): void {
            this._pFirstTerminalsDMap = <BoolDMap>{};
            this.generateFirstState_LR();

            var i:  number  = 0;
            var pStateList: IState[] = this._pStateList;
            var sSymbol: string = null;
            var pState: IState;

            for (i = 0; i < pStateList.length; i++) {
                for (sSymbol in this._pSymbolMap) {
                    pState = this.nextState_LR(pStateList[i], sSymbol);

                    if (!pState.isEmpty()) {
                        pState = this.tryAddState(pState, EParserType.k_LR1);
                        this.addStateLink(pStateList[i], pState, sSymbol);
                    }
                }
            }
        }

        private generateStates_LALR(): void {

            this._pStatesTempMap = <IStateMap>{};
            this._pBaseItemList = <IItem[]>[];
            this._pExpectedExtensionDMap = <BoolDMap>{};
            this._pFirstTerminalsDMap = <BoolDMap>{};

            this.generateStates_LR0();
            this.deleteNotBaseItems();
            this.generateLinksExpected();
            this.expandExpected();

            var i:  number  = 0;
            var pStateList: IState[] = this._pStateList;

            for (i = 0; i < pStateList.length; i++) {
                this.closure_LR(pStateList[i]);
            }
        }

        private calcBaseItem():  number  {
            var num:  number  = 0;
            var i:  number  = 0;

            for (i = 0; i < this._pStateList.length; i++) {
                num += this._pStateList[i].numBaseItems;
            }

            return num;
        }

        private printExpectedTable(): string {
            var i: string = null, j: string = null;
            var sMsg: string = "";

            for (i in this._pExpectedExtensionDMap) {
                sMsg += "State " + this._pBaseItemList[<number><any>i].state.index + ":   ";
                sMsg += this._pBaseItemList[<number><any>i].toString() + "  |----->\n";

                for (j in this._pExpectedExtensionDMap[i]) {
                    sMsg += "\t\t\t\t\t" + "State " + this._pBaseItemList[<number><any>j].state.index + ":   ";
                    sMsg += this._pBaseItemList[<number><any>j].toString() + "\n";
                }

                sMsg += "\n";
            }

            return sMsg;
        }

        private addReducing(pState: IState): void {
            var i:  number  = 0, j: string = null;
            var pItemList: IItem[] = pState.items;

            for (i = 0; i < pItemList.length; i++) {
                if (pItemList[i].mark() ===  "END" ) {

                    if (pItemList[i].rule.left ===  "S" ) {
                        this.pushInSyntaxTable(pState.index,  "$" , this._pSuccessOperation);
                    }
                    else {
                        var pExpected = pItemList[i].expectedSymbols;

                        for (j in pExpected) {
                            this.pushInSyntaxTable(pState.index, j, this._pReduceOperationsMap[pItemList[i].rule.index]);
                        }
                    }
                }
            }
        }

        private addShift(pState: IState) {
            var i: string = null;
            var pStateMap: IStateMap = pState.nextStates;

            for (i in pStateMap) {
                this.pushInSyntaxTable(pState.index, i, this._pShiftOperationsMap[pStateMap[i].index]);
            }
        }

        private buildSyntaxTable(): void {
            this._pStateList = <IState[]>[];

            var pStateList: IState[] = this._pStateList;
            var pState: IState;

//Generate states
            this.generateStates(this._eType);

//Init necessary properties
            this._pSyntaxTable = <IOperationDMap>{};
            this._pReduceOperationsMap = <IOperationMap>{};
            this._pShiftOperationsMap = <IOperationMap>{};

            this._pSuccessOperation = <IOperation>{ type: EOperationType.k_Success };

            var i:  number  = 0, j: string = null, k: string = null;

            for (i = 0; i < pStateList.length; i++) {
                this._pShiftOperationsMap[pStateList[i].index] = <IOperation>{
                    type: EOperationType.k_Shift,
                    index: pStateList[i].index
                };
            }

            for (j in this._pRulesDMap) {
                for (k in this._pRulesDMap[j]) {
                    this._pReduceOperationsMap[k] = <IOperation>{
                        type: EOperationType.k_Reduce,
                        rule: this._pRulesDMap[j][k]
                    };
                }
            }

//Build syntax table
            for (var i = 0; i < pStateList.length; i++) {
                pState = pStateList[i];
                this.addReducing(pState);
                this.addShift(pState);
            }
        }

        private readToken(): IToken {
            return this._pLexer.getNextToken();
        }

        private operationAdditionalAction(iStateIndex: number , sGrammarSymbol: string): EOperationType {
            var pFuncDMap:IRuleFunctionDMap = this._pAdidtionalFunctByStateDMap;

            if(!isNull(this._pAdidtionalFunctByStateDMap) &&
               isDef(pFuncDMap[iStateIndex]) &&
               isDef(pFuncDMap[iStateIndex][sGrammarSymbol])){

                return pFuncDMap[iStateIndex][sGrammarSymbol].call(this);
            }

            return EOperationType.k_Ok;
        }

        private resumeParse(): EParserCode {
            try {
                var pTree:IParseTree = this._pSyntaxTree;
                var pStack: number [] = this._pStack;
                var pSyntaxTable:IOperationDMap = this._pSyntaxTable;

                var isStop:bool = false;
                var isError:bool = false;
                var isPause:bool = false;
                var pToken:IToken = isNull(this._pToken) ? this.readToken() : this._pToken;

                var pOperation:IOperation;
                var iRuleLength: number ;

                var eAdditionalOperationCode: EOperationType;
                var iStateIndex:  number  = 0;

                while (!isStop) {
                    pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                    if (isDef(pOperation)) {
                        switch (pOperation.type) {
                            case EOperationType.k_Success:
                                isStop = true;
                                break;

                            case EOperationType.k_Shift:

                                iStateIndex = pOperation.index;
                                pStack.push(iStateIndex);
                                pTree.addNode(<IParseNode>pToken);

                                eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);

                                if(eAdditionalOperationCode === EOperationType.k_Error){
                                    isError = true;
                                    isStop = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Pause){
                                    this._pToken = null;
                                    isStop = true;
                                    isPause = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Ok){
                                    pToken = this.readToken();
                                }

                                break;

                            case EOperationType.k_Reduce:

                                iRuleLength = pOperation.rule.right.length;
                                pStack.length -= iRuleLength;
                                iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                pStack.push(iStateIndex);
                                pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);

                                eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);

                                if(eAdditionalOperationCode === EOperationType.k_Error){
                                    isError = true;
                                    isStop = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Pause){
                                    this._pToken = pToken;
                                    isStop = true;
                                    isPause = true;
                                }

                                break;
                        }
                    }
                    else {
                        isError = true;
                        isStop = true;
                    }
                }
            }
            catch (e) {
                this._sFileName = "stdin";
                return EParserCode.k_Error;
            }
            if (isPause) {
                return EParserCode.k_Pause;
            }

            if (!isError) {
                pTree.setRoot();
                if (isDef(this._fnFinishCallback)) {
                    this._fnFinishCallback.call(this._pCaller, EParserCode.k_Ok, this.getParseFileName());
                }
                this._sFileName = "stdin";
                return EParserCode.k_Ok;
            }
            else {
                this._error( 2051 , pToken);
                if (isDef(this._fnFinishCallback)) {
                    this._fnFinishCallback.call(this._pCaller, EParserCode.k_Error, this.getParseFileName());
                }
                this._sFileName = "stdin";
                return EParserCode.k_Error;
            }
        }

        private statesToString(isBaseOnly?: bool = true): string {
            if(!isDef(this._pStateList)){
                return null;
            }

            var sMsg: string = "";
            var i:  number  = 0;

            for (i = 0; i < this._pStateList.length; i++) {
                sMsg += this._pStateList[i].toString(isBaseOnly);
                sMsg += " ";
            }

            return sMsg;
        }

        private operationToString(pOperation: IOperation): string{
            var sOperation: string = null;

            switch(pOperation.type){
                case EOperationType.k_Shift:
                    sOperation = "SHIFT to state " + pOperation.index.toString();
                    break;
                case EOperationType.k_Reduce:
                    sOperation = "REDUCE by rule { " + this.ruleToString(pOperation.rule) + " }";
                    break;
                case EOperationType.k_Success:
                    sOperation = "SUCCESS";
                    break;
            }

            return sOperation;
        }

        private ruleToString(pRule: IRule): string {
            var sRule: string;

            sRule = pRule.left + " : " + pRule.right.join(" ");

            return sRule;
        }

        private convertGrammarSymbol(sSymbol: string): string{
            if(!this.isTerminal(sSymbol)){
                return sSymbol;
            }
            else{
                return this._pLexer.getTerminalValueByName(sSymbol);
            }
        }

    }

}













module akra.util {

	export class EffectParser extends Parser {
		private _pIncludedFilesMap: BoolMap = null;

		constructor(){
			super();

			this.addAdditionalFunction("addType", this._addType);
			this.addAdditionalFunction("includeCode", this._includeCode);
		}

		protected defaultInit(): void {
			super.defaultInit();

			this.addTypeId("float2");
			this.addTypeId("float3");
			this.addTypeId("float4");

			this.addTypeId("float2x2");
			this.addTypeId("float3x3");
			this.addTypeId("float4x4");

			this.addTypeId("int2");
			this.addTypeId("int3");
			this.addTypeId("int4");

			this.addTypeId("bool2");
			this.addTypeId("bool3");
			this.addTypeId("bool4");

			this._pIncludedFilesMap = <BoolMap>{};
			this._pIncludedFilesMap[this.getParseFileName()] = true;
		}

		_addIncludedFile(sFileName: string): void {
			this._pIncludedFilesMap[sFileName] = true;
		}

		private _addType(): EOperationType {
			var pTree: IParseTree = this.getSyntaxTree();
			var pNode: IParseNode = pTree.getLastNode();
			var sTypeId: string;

			sTypeId = pNode.children[pNode.children.length - 2].value;

			this.addTypeId(sTypeId);

			return EOperationType.k_Ok;
		}

		private normalizeIncludePath(sFile: string): string {
// console.log(sFile, this.getParseFileName(), path.resolve(sFile, this.getParseFileName()));
			return path.resolve(sFile, this.getParseFileName());
		}

		private _includeCode(): EOperationType {
			var pTree: IParseTree = this.getSyntaxTree();
		    var pNode: IParseNode = pTree.getLastNode();
		    var sFile: string = pNode.value;

//cuttin qoutes
		    sFile = this.normalizeIncludePath(sFile.substr(1, sFile.length - 2));

		    if (this._pIncludedFilesMap[sFile]) {
		    	return EOperationType.k_Ok;
		    }
		    else {
		    	var pParserState: IParserState = this._saveState();
		    	var me: EffectParser = this;
		    	var pFile: IFile = io.fopen(sFile, "r+t");

		    	pFile.read((err, sData: string) => {
		    		if (err) {
		    			{ logger.setSourceLocation( "util/EffectParser.ts" , 85 ); logger.error("Can not read file"); } ;
		    		}
		    		else {
		    			pParserState.source = pParserState.source.substr(0, pParserState.index) +
		    								  sData + pParserState.source.substr(pParserState.index);

		    			me._loadState(pParserState);
		    			me._addIncludedFile(sFile);
		    			me.resume();
		    		}
		    	});

				return EOperationType.k_Pause;
		    }
		}

		_saveState(): IParserState {
			var pState: IParserState = super._saveState();
			pState["includeFiles"] = this._pIncludedFilesMap;
			return pState;
		}

		_loadState(pState: IParserState): void {
			super._loadState(pState);
			this._pIncludedFilesMap = <BoolMap>pState["includeFiles"];
		}

	}

	export var parser: EffectParser = new EffectParser();

	export function initAFXParser(sGrammar: string): void {
		parser.init(sGrammar, akra.EParseMode.k_Add |
				    akra.EParseMode.k_Negate |
					akra.EParseMode.k_Optimize |
					akra.EParseMode.k_DebugMode);
	}

}





module akra.core.pool.resources {
	export class EffectData extends ResourcePoolItem {
		private _pFile: IFile = null;


		private _pSyntaxTree: IParseTree = null;

		/**@inline*/  get byteLength():  number  {
			return this._pFile? this._pFile.byteLength: 0;
		}

		loadResource(sFileName?: string): bool {
			var reExt: RegExp  = /^(.+)(\.afx|\.abf|\.fx)$/;
    		var pRes:RegExpExecArray = reExt.exec(sFileName);

    		if(isNull(pRes)){
    			{ logger.setSourceLocation( "resources/EffectData.ts" , 28 ); logger.error("Bad effect file extension. Only .afx, .fx, .abf are available"); } ;
    			return;
    		}

    		var isBinary: bool = pRes[pRes.length - 1] === ".abf";
    		var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();
    		var me: EffectData = this;


			if(isBinary) {
    			var pFile: IFile = this._pFile = io.fopen(sFileName, "r+b");

	    		pFile.read(function(err, pData: Uint8Array) {
					if (err){  { logger.setSourceLocation( "resources/EffectData.ts" , 47 ); logger.error("Can not read file"); } ; }
					else me._initFromBinaryData(pData, sFileName);
				});

				return true;
			}


//text only
			var pFile: IFile = this._pFile = io.fopen(sFileName, "r+t");

			pFile.read(function(pErr: Error, sData: string){
				if(!isNull(pErr)){
					{ logger.setSourceLocation( "resources/EffectData.ts" , 60 ); logger.error("Can not load .afx file: '" + sFileName + "'"); } ;
				}
				else {

					util.parser.setParseFileName(sFileName);
					util.parser.parse(sData, me._initFromParsedEffect, me);
				}
			});

			return true;
		}


		_initFromParsedEffect(eCode: EParserCode, sFileName: string): void {
			if(eCode === EParserCode.k_Error) {
				return;
			}

			this._pSyntaxTree = util.parser.getSyntaxTree();

			var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();
			if(pComposer._loadEffectFromSyntaxTree(this._pSyntaxTree, sFileName)){
				this.notifyLoaded();
			}

		}


		_initFromBinaryData(pData: Uint8Array, sFileName: string): void {
// var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();
// pComposer._loadEffectFromBinary(this._pSyntaxTree, sFileName);
		}
	}


}
















module akra.core.pool.resources {
	export class HardwareBuffer extends ResourcePoolItem implements IHardwareBuffer {
		protected _iFlags:  number  = 0;

		protected _isLocked: bool = false;
/** Lock byte offset. */

		protected _iLockStart:  number ;
/** Lock byte size. */

		protected _iLockSize:  number ;

		protected _pBackupCopy: HardwareBuffer = null;
		protected _pBackupUpdated: bool = false;
		protected _bIgnoreHardwareUpdate: bool = false;

		get byteLength():  number  { return 0; }
		get length():  number  { return 0; }

// byteLength: uint = 0;
// length: uint = 0;

		constructor() {
			super();
		}

		/**@inline*/  isValid(): bool {
			return false;
		}

		/**@inline*/  isDynamic(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ;
		}

		/**@inline*/  isStatic(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.STATIC)) != 0) ;
		}

		/**@inline*/  isStream(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.STREAM)) != 0) ;
		}

		/**@inline*/  isReadable(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ;
		}

		/**@inline*/  isBackupPresent(): bool {
			return this._pBackupCopy != null;
		}

		/**@inline*/  isSoftware(): bool {
    		return  (((this._iFlags) & (EHardwareBufferFlags.SOFTWARE)) != 0) ;
		}

		/**@inline*/  isAligned(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.ALIGNMENT)) != 0) ;
		}

		/**@inline*/  isLocked(): bool {
			return this._isLocked;
		}

		clone(pSrc: IHardwareBuffer): bool {
			return false;
		}

		/**@inline*/  getFlags():  number  { return this._iFlags; }

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			return false;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;

		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {
			return false;
		}

		copyData(pSrcBuffer: IHardwareBuffer, iSrcOffset:  number , iDstOffset:  number , iSize:  number , bDiscardWholeBuffer: bool = false): bool {
			var pData: any = pSrcBuffer.lock(iSrcOffset, iSize);
			this.writeData(pData, iDstOffset, iSize, bDiscardWholeBuffer);
			pSrcBuffer.unlock();
			return true;
		}

		create(iSize:  number , iFlags:  number  = 0): bool {
			iFlags |= EHardwareBufferFlags.STATIC;

			if ( (((iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ) {
				((iFlags) &= ~(EHardwareBufferFlags.STATIC)) ;

				if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
					((iFlags) &= ~(EHardwareBufferFlags.READABLE)) ;
				}
			}

			this._iFlags = iFlags;

			this.notifyCreated();
			this.notifyRestored();

			return true;
		}

		destroy(): void {
			this._iFlags = 0;
			this.notifyDestroyed();
			this.notifyUnloaded();
		}

		resize(iSize:  number ): bool {
			return false;
		}

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags:  number  = EHardwareBufferFlags.READABLE): any;
		lock(): any {
			{ logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 123 ); logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!"); } ;

			var iOffset:  number  = 0,
				iSize:  number  = 0,
				iLockFlags:  number  = 0;

			if (arguments.length == 1) {
				iLockFlags = < number >arguments[0];
				iOffset = 0;
				iSize = this.byteLength;
			}
			else {
				iOffset = arguments[0];
				iSize = arguments[1];
				iLockFlags = (arguments.length === 3) ? arguments[2] : EHardwareBufferFlags.READABLE;
			}

			var pResult: any = null;

			if ((iOffset + iSize) > this.byteLength) {
				{ logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 143 ); logger.error("Lock request out of bounds.", "HardwareBuffer::lock"); } ;
			}
			else if (this.isBackupPresent()) {
				if (! (((iLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// we have to assume a read / write lock so we use the shadow buffer
// and tag for sync on unlock()
                    this._pBackupUpdated = true;
                }

                pResult = this._pBackupCopy.lock(iOffset, iSize, iLockFlags);
            }
            else {
// Lock the real buffer if there is no shadow buffer 
                pResult = this.lockImpl(iOffset, iSize, iLockFlags);
                this._isLocked = true;
            }

			this._iLockStart = iOffset;
			this._iLockSize = iSize;

            return pResult;
		}

		unlock(): void {
			{ logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 167 ); logger.assert(this.isLocked(), "Cannot unlock this buffer, it is not locked!"); } ;

// If we used the shadow buffer this time...
            if (this._pBackupCopy && this._pBackupCopy.isLocked()) {
                this._pBackupCopy.unlock();
// Potentially update the 'real' buffer from the shadow buffer
                this.restoreFromBackup();
            }
            else
            {
// Otherwise, unlock the real one
                this.unlockImpl();
                this._isLocked = false;
            }
		}

		restoreFromBackup(): bool {
			if (this._pBackupCopy && this._pBackupUpdated && !this._bIgnoreHardwareUpdate) {
// Do this manually to avoid locking problems
	            var pBackupData: any = this._pBackupCopy.lockImpl(this._iLockStart,
	            	this._iLockSize, ELockFlags.READ);
// Lock with discard if the whole buffer was locked, otherwise normal
				var iLockFlags:  number ;

				if (this._iLockStart == 0 && this._iLockSize == this.byteLength) {
					iLockFlags = ELockFlags.DISCARD;
				}
				else {
					iLockFlags = ELockFlags.NORMAL;
				}

	            var pRealData: any = this.lockImpl(this._iLockStart, this._iLockSize, iLockFlags);
// Copy backup to real
	            this.copyBackupToRealImpl(pRealData, pBackupData, iLockFlags);

	            this.unlockImpl();
	            this._pBackupCopy.unlockImpl();
	            this._pBackupUpdated = false;

	            return true;
	        }

	        return false;
		}

		createResource(): bool {
// innitialize the resource (called once)
		    { logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 215 ); logger.assert(!this.isResourceCreated(), "The resource has already been created."); }
                                                            ;

// signal that the resource is now created,
// but has not been enabled
//this.notifyCreated();
		    this.notifyDisabled();

		    return true;
		}

		destroyResource(): bool {
// destroy the resource
//
// we permit redundant calls to destroy, so there are no asserts here
//
		    if (this.isResourceCreated()) {
// disable the resource
		        this.disableResource();
		        this.destroy();
		        return true;
		    }

		    return false;
		}

		restoreResource(): bool {
		    { logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 241 ); logger.assert(this.isResourceCreated(), "The resource has not been created."); } ;

		    this.notifyRestored();
		    return true;
		}

		disableResource (): bool {
		    { logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 248 ); logger.assert(this.isResourceCreated(), "The resource has not been created."); } ;

		    this.notifyDisabled();
		    return true;
		}

		protected lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
			return null;
		}

		protected unlockImpl(): void {

		}

		protected copyBackupToRealImpl(pRealData: any, pBackupData: any, iLockFlags:  number ): void {

		}
	}
}









module akra.webgl {
	export class WebGLPixelBuffer extends core.pool.resources.HardwareBuffer implements IPixelBuffer {

		protected _iWidth:  number  = 0;
		protected _iHeight:  number  = 0;
		protected _iDepth:  number  = 0;

// Pitches (offsets between rows and slices)
		protected _iRowPitch:  number  = 0;
		protected _iSlicePitch:  number  = 0;

		protected _eFormat: EPixelFormats = EPixelFormats.UNKNOWN;

//webgl specific

		protected _pCurrentLock: IPixelBox = null;
		protected _pLockedBox: IBox = null;
		protected _iCurrentLockFlags:  number  = 0;

		protected _pBuffer: IPixelBox = null;
		protected _iWebGLInternalFormat:  number  = 0;

		protected _iByteSize:  number ;

		/**@inline*/  get byteLength():  number  { return this._iByteSize; }

		/**@inline*/  get width():  number  { return this._iWidth; }
		/**@inline*/  get height():  number  { return this._iHeight; }
		/**@inline*/  get depth():  number  { return this._iDepth; }

		/**@inline*/  get format():  number  { return this._eFormat; }



		constructor () {
			super();
		}


//upload(download) data to(from) videocard.
		protected upload(pData: IPixelBox, pDestBox: IBox): void {
			{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 51 ); logger.criticalError("Upload not possible for this pixelbuffer type"); } ;
		}

		protected download(pData: IPixelBox): void {
			{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 55 ); logger.criticalError("Download not possible for this pixelbuffer type"); } ;
		}

		_bindToFramebuffer(pAttachment:  number , iZOffset:  number ): void {
			{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 59 ); logger.criticalError("Framebuffer bind not possible for this pixelbuffer type"); } ;
		}

		_getWebGLFormat():  number  {
			return this._iWebGLInternalFormat;
		}

		_clearRTT(iZOffset:  number ): void {
		}

		reset(): void;
        reset(iSize:  number ): void;
        reset(iWidth:  number , iHeight:  number ): void;
        reset(iWidth?:  number  = this._iWidth, iHeight?:  number  = iWidth): void {
			this._iWidth = iWidth;
			this._iHeight = iHeight;
		}

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(): bool {
			if(arguments.length === 1) {
				{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 81 ); logger.criticalError("Invalid number of arguments. For PixelBuffer it must be six"); } ;
			}
			var iWidth:  number  = arguments[0];
			var iHeight:  number  = arguments[1];
			var iDepth:  number  = arguments[2];
			var eFormat:  number  = arguments[3];
			var iFlags:  number  = arguments[4];

 			super.create(iFlags);

			this._iWidth = iWidth;
			this._iHeight = iHeight;
			this._iDepth = iDepth;
			this._eFormat = eFormat;

			this._iRowPitch = iWidth;
			this._iSlicePitch = iHeight * iWidth;
			this._iByteSize = iHeight * iWidth * akra.pixelUtil.getNumElemBytes(eFormat);

			this._pBuffer = new pixelUtil.PixelBox(iWidth, iHeight, iDepth, eFormat);
			this._iWebGLInternalFormat =  0 ;

			return true;
		}

		destroy(): void {
			this._pBuffer = null;

			super.destroy();
		}

		destroyResource(): bool {
			this.destroy();
			this.notifyDestroyed();
			return true;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(): bool {
			{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 121 ); logger.criticalError("Reading a byte range is not implemented. Use blitToMemory."); } ;
			return false;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
		writeData(pData: ArrayBuffer, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
		writeData(): bool {
			{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 128 ); logger.criticalError("Writing a byte range is not implemented. Use blitFromMemory."); } ;
			return false;
		}

		readPixels(pDestBox: IPixelBox): bool {
			this.download(pDestBox);
			return true;
		}

//=====

		blit(pSource: IPixelBuffer): bool;
		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer, pSrcBox?: IBox, pDestBox?: IBox): bool {
			if (arguments.length == 1) {
				return this.blit(pSource,
		            new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth),
		            new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth)
		        );
			}
			else {
				if(pSource === <IPixelBuffer>this) {
					{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 150 ); logger.criticalError("Source must not be the same object"); }  ;
				}

				/**@const*/var  pSrclock: IPixelBox = pSource.lock(pSrcBox, ELockFlags.READ);

				var eLockMethod: ELockFlags = ELockFlags.NORMAL;
				if (pDestBox.left === 0 && pDestBox.top === 0 && pDestBox.front === 0 &&
				    pDestBox.right === this._iWidth && pDestBox.bottom === this._iHeight &&
				    pDestBox.back === this._iDepth) {
// Entire buffer -- we can discard the previous contents
					eLockMethod = ELockFlags.DISCARD;
				}

				/**@const*/var  pDstlock: IPixelBox = this.lock(pDestBox, eLockMethod);

				if (pDstlock.width != pSrclock.width ||
		            pDstlock.height != pSrclock.height ||
		            pDstlock.depth != pSrclock.depth) {
// Scaling desired
					pSrclock.scale(pDstlock);
				}
				else {
// No scaling needed
					akra.pixelUtil.bulkPixelConversion(pSrclock, pDstlock);
				}

				this.unlock();
				pSource.unlock();

				return true;
			}
		}

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox: IBox): bool;
		blitFromMemory(): bool {
			var pSource: IPixelBox;
			var pDestBox: IBox;

			pSource = arguments[0];

			if(arguments.length === 1) {
				pDestBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
				return this.blitFromMemory(pSource, pDestBox);
			}
			else{
				pDestBox = arguments[1];
			}

			if (!this._pBuffer.contains(pDestBox)) {
				{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 200 ); logger.criticalError("Destination box out of range"); } ;
	        }

	        var pScaledBox: IPixelBox;

	        if (pSource.width != pDestBox.width ||
	            pSource.height != pDestBox.height ||
	            pSource.depth != pDestBox.depth) {
// Scale to destination size.
// This also does pixel format conversion if needed
	            this.allocateBuffer();
	            pScaledBox = this._pBuffer.getSubBox(pDestBox);
	            pScaledBox.setConsecutive();

	            pSource.scale(pScaledBox, EFilters.BILINEAR);
	        }
	        else if ((pSource.format !== this._eFormat) ||
	                 (getWebGLFormat(pSource.format) === 0)) {
// Extents match, but format is not accepted as valid source format for GL
// do conversion in temporary buffer
	            this.allocateBuffer();
	            pScaledBox = this._pBuffer.getSubBox(pDestBox);
	         	pScaledBox.setConsecutive();

	            pixelUtil.bulkPixelConversion(pSource, pScaledBox);

// if(this._eFormat === EPixelFormats.A4R4G4B4)
// {
//     // ARGB->BGRA
//     convertToWebGLformat(pScaledBox, pScaledBox);
// }
	        }
	        else {
	            this.allocateBuffer();
	            pScaledBox = pSource;
	        }

	        this.upload(pScaledBox, pDestBox);
	        this.freeBuffer();

			return true;
		}

		blitToMemory(pDest: IPixelBox): bool;
		blitToMemory(pSrcBox: IBox, pDest: IPixelBox): bool;
		blitToMemory(): bool {
			var pSrcBox: IBox;
			var pDest: IPixelBox;

			if(arguments.length === 1){
				pDest = arguments[0];
				pSrcBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
				return this.blitToMemory(pSrcBox, pDest);
			}
			else{
				pSrcBox = arguments[0];
				pDest = arguments[1];
			}

			if (!this._pBuffer.contains(pSrcBox)) {
				{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 260 ); logger.criticalError("source box out of range"); } ;
	        }

	        if (pSrcBox.left == 0 && pSrcBox.right == this._iWidth &&
            	pSrcBox.top == 0 && pSrcBox.bottom == this._iHeight &&
            	pSrcBox.front == 0 && pSrcBox.back == this._iDepth &&
            	pDest.width == this._iWidth &&
            	pDest.height == this._iHeight &&
            	pDest.depth == this._iDepth &&
            	getWebGLFormat(pDest.format) != 0) {
// The direct case: the user wants the entire texture in a format supported by GL
// so we don't need an intermediate buffer
	            this.download(pDest);
	        }
	        else {
// Use buffer for intermediate copy
	            this.allocateBuffer();
// Download entire buffer
	            this.download(this._pBuffer);

	            if(pSrcBox.width != pDest.width ||
	               pSrcBox.height != pDest.height ||
	               pSrcBox.depth != pDest.depth) {
// We need scaling
	                this._pBuffer.getSubBox(pSrcBox).scale(pDest, EFilters.BILINEAR);
	            }
	            else {
// Just copy the bit that we need
	                pixelUtil.bulkPixelConversion(this._pBuffer.getSubBox(pSrcBox), pDest);
	            }
	            this.freeBuffer();
	        }

			return true;
		}

		getRenderTarget(): IRenderTarget {
			return null;
		}

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags:  number  = EHardwareBufferFlags.READABLE): any;
		lock(pLockBox: IBox, iLockFlags:  number  = EHardwareBufferFlags.READABLE): IPixelBox;
		lock(): any {
			var pLockBox: IBox = null;
			var iLockFlags:  number  = 0;

			if(isInt(arguments[0])){
				var iOffset:  number ;
				var iSize:  number ;

				if(arguments.length === 1){
					iLockFlags = arguments[0];
					iOffset = 0;
					iSize = this.byteLength;
				}
				else {
					iOffset = arguments[0];
					iSize = arguments[1];
					iLockFlags = (arguments.length === 3) ? arguments[2] : EHardwareBufferFlags.READABLE;
				}

				{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 323 ); logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!"); }
                                                         ;
				{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 325 ); logger.assert(iOffset === 0 && iSize === this.byteLength, "Cannot lock memory region, most lock box or entire buffer"); }
                                                                   ;

				pLockBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
			}
			else {
				pLockBox = <IBox>arguments[0];
			}

			if(this.isBackupPresent()){
				if (! (((iLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// we have to assume a read / write lock so we use the shadow buffer
// and tag for sync on unlock()
                    this._pBackupUpdated = true;
                }

                this._pCurrentLock = (<WebGLPixelBuffer>(this._pBackupCopy)).lock(pLockBox, iLockFlags);
			}
			else {
				this._pCurrentLock = this.lockImpl(pLockBox, iLockFlags);
				this._isLocked = true;
			}

			return this._pCurrentLock;
		}

		protected allocateBuffer(): void {
			if(!isNull(this._pBuffer.data)){
				return;
			}

			this._pBuffer.data = new Uint8Array(this.byteLength);
		}

		protected freeBuffer(): void {
			if( (((this._iFlags) & (EHardwareBufferFlags.STATIC)) != 0) ){
				this._pBuffer.data = null;
			}
		}

		protected lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any;
		protected lockImpl(pLockBox: IBox, iLockFlags:  number ): IPixelBox;
		protected lockImpl(): any {
			if(arguments.length === 3){
				{ logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 368 ); logger.criticalError("lockImpl(offset,length) is not valid for PixelBuffers and should never be called"); } ;
			}

			var pLockBox:IBox = arguments[0];
			var iLockFlags:  number  = arguments[1];

			this.allocateBuffer();

			if(! (((iLockFlags) & (ELockFlags.DISCARD)) != 0)  &&
			   (((this._iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ){

			   	this.download(this._pBuffer);
			}

			this._iCurrentLockFlags = iLockFlags;
			this._pLockedBox = pLockBox;

			return this._pBuffer.getSubBox(pLockBox);
		}

		protected unlockImpl(): void {
			if ( (((this._iCurrentLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// From buffer to card, only upload if was locked for writing
	            this.upload(this._pCurrentLock, this._pLockedBox);
	        }

	        this.freeBuffer();
		}





	}
}






















module akra.core.pool.resources {

    export enum ETextureForcedFormatFlags {
        FORCEMIPLEVELS = 0,
        FORCEFORMAT,
        FORCESIZE
    }

	export class Texture extends ResourcePoolItem implements ITexture {
        protected _iFlags:  number  = ETextureFlags.DEFAULT;

        protected _iWidth:  number  = 512;
        protected _iHeight:  number  = 512;
        protected _iDepth:  number  = 1;

        protected _eFormat: EPixelFormats = EPixelFormats.UNKNOWN;

        protected _nMipLevels:  number  = 0;
        protected _nRequestedMipLevels:  number  = 0;

        protected _eTextureType: ETextureTypes = ETextureTypes.TEXTURE_2D;

        protected _pParams: IntMap = <IntMap>{};

        protected _isInternalResourceCreated: bool = false;
        protected _isMipmapsHardwareGenerated: bool = false;

        constructor () {
            super();

            this._pParams[ETextureParameters.MIN_FILTER] = ETextureFilters.NEAREST;
            this._pParams[ETextureParameters.MAG_FILTER] = ETextureFilters.NEAREST;
            this._pParams[ETextureParameters.WRAP_S] = ETextureWrapModes.CLAMP_TO_EDGE;
            this._pParams[ETextureParameters.WRAP_T] = ETextureWrapModes.CLAMP_TO_EDGE;
        }

		/**@inline*/  get width():  number  {
			return this._iWidth;
		}

//inline set width(iWidth: uint) {
//    this._iWidth = this._iSrcWidth = iWidth;
//}

        /**@inline*/  get height():  number  {
        	return this._iHeight;
        }

//inline set height(iHeight: uint) {
//    this._iHeight = this._iSrcHeight = iHeight;
//}

        /**@inline*/  get depth():  number  {
            return this._iDepth;
        }

//inline set depth(iDepth: uint) {
//    this._iDepth = this._iSrcDepth = iDepth;
//}

        /**@inline*/  get format(): EPixelFormats {
        	return this._eFormat;
        }

//inline set format(eFormat: EPixelFormats) {
//    this._eFormat = eFormat;
//    this._eDesiredFormat = eFormat;
//    this._eSrcFormat = eFormat;
//}

        /**@inline*/  get textureType(): ETextureTypes {
            return this._eTextureType;
        }

//inline set textureType(eTextureType: ETextureTypes) {
//    this._eTextureType = eTextureType;
//}

        /**@inline*/  get mipLevels():  number  {
            return this._nMipLevels;
        }

//inline set mipLevels(nMipLevels: uint) {
//    this._nMipLevels = nMipLevels;
//}

/*inline get desiredIntegerBitDepth(): uint {
            return this._iDesiredIntegerBitDepth;
        }

        inline set desiredIntegerBitDepth(iDesiredIntegerBitDepth: uint) {
            this._iDesiredIntegerBitDepth = iDesiredIntegerBitDepth;
        }

        inline get desiredFloatBitDepth(): uint {
            return this._iDesiredFloatBitDepth;
        }

        inline set desiredFloatBitDepth(iDesiredFloatBitDepth: uint) {
            this._iDesiredFloatBitDepth = iDesiredFloatBitDepth;
        }*/


        /**@inline*/  get byteLength():  number  {
            return this.getSize();
        }

        /**@inline*/  getFlags():  number  {
            return this._iFlags;
        }

        /**@inline*/  setFlags(iFlags: ETextureFlags): void {
            this._iFlags = iFlags;
        }

        /**@inline*/  isTexture2D(): bool {
        	return this._eTextureType === ETextureTypes.TEXTURE_2D;
        }

        /**@inline*/  isTextureCube(): bool {
        	return this._eTextureType === ETextureTypes.TEXTURE_CUBE_MAP;
        }

        /**@inline*/  isCompressed(): bool {
        	return (this._eFormat >= EPixelFormats.DXT1 && this._eFormat <= EPixelFormats.DXT5) ||
                (this._eFormat >= EPixelFormats.PVRTC_RGB2 && this._eFormat <= EPixelFormats.PVRTC_RGBA4);
        }

        /**@inline*/  isValid(): bool {
            return this._isInternalResourceCreated;
        }

// inline calculateSize(): uint {
//     return this.getNumFaces() * pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
// }

        /**@inline*/  getNumFaces():  number  {
            return this._eTextureType === ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1;
        }

        /**@inline*/  getSize():  number  {
//FIXME: necessary consider the number of texture MIP levels
            return this.getNumFaces() * pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
        }

        reset(): void;
        reset(iSize:  number ): void;
        reset(iWidth:  number , iHeight:  number ): void;
        reset(iWidth?:  number  = this._iWidth, iHeight?:  number  = iWidth): void {
            this._iWidth = iWidth;
            this._iHeight = iHeight;
        }

        getBuffer(iFace?:  number , iMipmap?:  number ): IPixelBuffer {
            return null;
        }

        create(iWidth:  number , iHeight:  number , iDepth:  number , cFillColor?: IColor,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: Array,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: ArrayBufferView,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth?:  number  = 1, pPixels?: any = null,
               eFlags?: ETextureFlags = ETextureFlags.DEFAULT, nMipLevels?:  number  = 0, nFaces?:  number  = 0,
               eTextureType?: ETextureTypes = ETextureTypes.TEXTURE_2D,
               eFormat?: EPixelFormats = EPixelFormats.B8G8R8): bool {


            if(eTextureType!=ETextureTypes.TEXTURE_2D && eTextureType!=ETextureTypes.TEXTURE_CUBE_MAP)
            {
                { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 183 ); logger.criticalError("Заданный тип текстуры не поддреживается"); } ;
                return false;
            }

            this._eTextureType = eTextureType;

            this._iWidth = iWidth;
            this._iHeight = iHeight;
            this._iDepth = iDepth;

            this._iFlags = eFlags;
            this._nMipLevels = nMipLevels;

            this._eFormat = eFormat;



            if(isArray(pPixels))
            {
                pPixels = new Uint8Array(pPixels);
                return this.loadRawData(pPixels, iWidth, iHeight,iDepth,eFormat,nFaces,nMipLevels);
            }
            else if(isTypedArray(pPixels))
            {
                return this.loadRawData(pPixels, iWidth, iHeight,iDepth,eFormat,nFaces,nMipLevels);
            }
            else
            {
                return this.createInternalTexture(pPixels);
            }
        }

        loadResource(sFilename?: string): bool {
            if (arguments.length == 0) {
                return;
            }

            var pImage: IImg = this.getManager().loadImage(sFilename);
// console.log("Texture::loadResource(" + sFilename + ")", pImage.isResourceLoaded());

            if (pImage.isResourceLoaded()) {
                return this.loadImage(pImage);
            }
// LOG("Texture::loadResource(" + sFilename + ")", pImage);
            this.connect(pImage,  "loaded" ,  "_onImageLoad" );
            return true;
        }

        _onImageLoad(pImage: IImg): void {
            this.disconnect(pImage,  "loaded" ,  "_onImageLoad" );
// console.log("image loaded > ", pImage.findResourceName());
            this.loadImage(pImage);
// debug_print("texture/image loaded: ", pImage.findResourceName());
        }

        destroyResource(): bool {
            this.freeInternalTexture();
            this.notifyDestroyed();
            return true;
        }

        setFilter(eParam: ETextureParameters, eValue: ETextureFilters): bool {
            if(this._pParams[eParam] === eValue){
                return true;
            }

            this._pParams[eParam] = eValue;
            return this._setFilterInternalTexture(eParam,eValue);
        }

        setWrapMode(eParam: ETextureParameters, eValue: ETextureWrapModes): bool {
            if(this._pParams[eParam] === eValue){
                return true;
            }

            this._pParams[eParam] = eValue;
            return this._setWrapModeInternalTexture(eParam, eValue);
        }

        /**@inline*/  getFilter(eParam: ETextureParameters): ETextureFilters {
// if(!isDefAndNotNull(this._pParams[eParam])) {
//     this._pParams[eParam] = this._getFilterInternalTexture(eParam);
// }

            return this._pParams[eParam];
        }

        /**@inline*/  getWrapMode(eParam: ETextureParameters): ETextureWrapModes {
// if(!isDefAndNotNull(this._pParams[eParam])) {
//     this._pParams[eParam] = this._getWrapModeInternalTexture(eParam);
// }

            return this._pParams[eParam];
        }

        protected _setFilterInternalTexture(eParam: ETextureParameters, eValue: ETextureFilters): bool{
            { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 279 ); logger.criticalError("virual"); } ;
            return false;
        }
        protected _setWrapModeInternalTexture(eParam: ETextureParameters, eValue: ETextureWrapModes): bool{
            { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 283 ); logger.criticalError("virual"); } ;
            return false;
        }

        protected _getFilterInternalTexture(eParam: ETextureParameters): ETextureFilters{
            { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 288 ); logger.criticalError("virual"); } ;
            return 0;
        }
        protected _getWrapModeInternalTexture(eParam: ETextureParameters): ETextureWrapModes{
            { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 292 ); logger.criticalError("virual"); } ;
            return 0;
        }


        loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number  = 1, eFormat: EPixelFormats = EPixelFormats.BYTE_RGB,
                    nFaces?:  number  = 1, nMipMaps?:  number  = 0)
        {
            var pTempImg: IImg = <IImg>this.getManager().imagePool.findResource(".texture.temp_image");

            if(isNull(pTempImg)){
                pTempImg = <IImg>this.getManager().imagePool.createResource(".texture.temp_image");
            }

            pTempImg.loadRawData(pData, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
            var isLoaded: bool = this.loadImage(pTempImg);
            this.getManager().imagePool.destroyResource(pTempImg);

            return isLoaded;
        }

        loadImage(pImage: IImg): bool
        {
            var isLoaded:bool = this._loadImages(pImage);

            if(isLoaded)
            {
                this.notifyLoaded();
                return true;
            }
            else {
                return false;
            }
        }

        loadImages(pImages: IImg[]): bool
        {
            var isLoaded:bool = this._loadImages(pImages);

            if(isLoaded) {
                this.notifyLoaded();
                return true;
            }
            else{
                return false;
            }
        }

        _loadImages(pImageList: IImg[]): bool;
        _loadImages(pImage: IImg): bool;

        _loadImages(pImage:any): bool
        {




            if(this.isResourceLoaded()){
                { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 350 ); logger.warning("Yoy try to load texture when it already have been loaded. All texture data was destoyed."); } ;
                this.freeInternalTexture();
            }

            var pMainImage: IImg = null;
            var pImageList: IImg[] = null;

            if(!isArray(pImage))
            {
                pMainImage = pImage;
                pImageList = new Array(0);
                pImageList[0]=pMainImage;
            }
            else
            {
                pImageList = arguments[0];
                if(pImageList.length === 0) {
                    { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 367 ); logger.criticalError("Cannot load empty list of images"); } ;
                    return false;
                }
                pMainImage = pImageList[0];
            }



            this._iWidth = pMainImage.width;
            this._iHeight = pMainImage.height;
            this._iDepth = pMainImage.depth;

// Get source image format and adjust if required

            if(webgl.isWebGLFormatSupport(pMainImage.format))
            {
                this._eFormat = pMainImage.format;
            }
            else
            {
                { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 387 ); logger.warning("Format not support(" +pixelUtil.getFormatName(pMainImage.format) + ")"); } ;
                if(pMainImage.convert(EPixelFormats.B8G8R8A8))
                {
                    this._eFormat = pMainImage.format;
                }
                else
                {
                    { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 394 ); logger.criticalError("Format not convert"); } ;
                }
            }

            for(i=1;i<pImageList.length;i++)
            {
                if(!pImageList[i].convert(pMainImage.format))
                {
                    { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 402 ); logger.criticalError("Format not support and not convert"); } ;
                }
            }


// The custom mipmaps in the image have priority over everything
            var iImageMips:  number  = pMainImage.numMipMaps;

            if(iImageMips==Img.getMaxMipmaps(this._iWidth,this._iHeight,this._iDepth,this._eFormat)) {
                this._nMipLevels=iImageMips;

// Disable flag for auto mip generation
                ((this._iFlags) &= ~(ETextureFlags.AUTOMIPMAP)) ;
            }
            else
            {
                this._nMipLevels=0;
            }


// Check if we're loading one image with multiple faces
// or a vector of images representing the faces
            var iFaces:  number  = 0;
            var isMultiImage:bool =false;

            if(pImageList.length == 6)
            {
                iFaces = 6;
                isMultiImage = true;
                this._eTextureType = ETextureTypes.TEXTURE_CUBE_MAP;
            }
            else if(pMainImage.numFaces==6)
            {
                iFaces = 6;
                isMultiImage = false;
                this._eTextureType = ETextureTypes.TEXTURE_CUBE_MAP;
            }
            else
            {
                iFaces = 1;
                isMultiImage = false;
                this._eTextureType = ETextureTypes.TEXTURE_2D;
            }

// Check wether number of faces in images exceeds number of faces
// in this texture. If so, clamp it.
            if(iFaces > this.getNumFaces())
            {
                iFaces = this.getNumFaces();
            }

// Create the texture
            this.createInternalTexture(null);

// Main loading loop
// imageMips == 0 if the image has no custom mipmaps, otherwise contains the number of custom mips

            var mip:  number  = 0;
            var i:  number  = 0;
            for(mip = 0; mip <= this._nMipLevels; ++mip) {
                for(i = 0; i < iFaces; ++i) {
                    var pSrc: IPixelBox;

                    if(isMultiImage){
// Load from multiple images
                        pSrc = pImageList[i].getPixels(0, mip);
//console.log(mip,i);
                    }
                    else {
// Load from faces of images[0] or main Image
//console.log(mip,i);
                        pSrc = pMainImage.getPixels(i, mip);
                    }

// Destination: entire texture. blitFromMemory does the scaling to
// a power of two for us when needed
//console.log(pSrc);
//console.log(this.getBuffer(i, mip));

                    this.getBuffer(i, mip).blitFromMemory(pSrc);
                }
            }

            return true;
        }

        convertToImage(pDestImage: IImg, bIncludeMipMaps: bool): void
        {
// CRITICAL("!!!нехуй")
            var iNumMips:  number  = bIncludeMipMaps ? this._nMipLevels + 1 : 1;
            var iDataSize:  number  = pixelUtil.calculateSizeForImage(iNumMips, this.getNumFaces(),
                                                                  this._iWidth, this._iHeight, this._iDepth,
                                                                  this._eFormat);

            var pPixData: Uint8Array = new Uint8Array(iDataSize);
// if there are multiple faces and mipmaps we must pack them into the data
// faces, then mips
            var pCurrentPixData: Uint8Array = pPixData;

            var iFace:  number  = 0;
            var mip:  number  = 0;

            for (iFace = 0; iFace < this.getNumFaces(); ++iFace) {
                for (mip = 0; mip < iNumMips; ++mip) {

                    var iMipDataSize = pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

                    var pPixBox: IPixelBox = new pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat, pCurrentPixData);
                    this.getBuffer(iFace, mip).blitToMemory(pPixBox);

                    pCurrentPixData = pCurrentPixData.subarray(iMipDataSize);

                }
            }

// load, and tell Image to delete the memory when it's done.
            pDestImage.loadDynamicImage(pPixData, this._iWidth, this._iHeight, this._iDepth, this._eFormat,
                this.getNumFaces(), iNumMips - 1);
        }

        copyToTexture(pTarget: ITexture): void {
            if(pTarget.getNumFaces() !== this.getNumFaces()){
                { logger.setSourceLocation( "core/pool/resources/Texture.ts" , 524 ); logger.criticalError("Texture types must match"); } ;
            }

            var nMipLevels:  number  = Math.min(this._nMipLevels, pTarget.mipLevels);
            if( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0)  ||  (((this.getFlags()) & (ETextureFlags.AUTOMIPMAP)) != 0) ){
                nMipLevels = 0;
            }

            var iFace:  number  = 0, mip:  number  = 0;

            for(iFace = 0; iFace < this.getNumFaces(); iFace++){
                for(mip = 0; mip <= nMipLevels; mip++){
                    pTarget.getBuffer(iFace, mip).blit(this.getBuffer(iFace, mip));
                }
            }
        }

        createInternalTexture(cFillColor?: IColor = null): bool
        {

            if(!this._isInternalResourceCreated)
            {
                this._createInternalTextureImpl(cFillColor);
                this._isInternalResourceCreated = true;
                this.notifyCreated();
                return true;
            }

        	return false;
        }

        freeInternalTexture(): bool {
            if(this._isInternalResourceCreated){
                this.freeInternalTextureImpl();
                this._isInternalResourceCreated = false;
                this.notifyDestroyed();
                return true;
            }

            return false;
        }

        protected _createInternalTextureImpl(cFillColor?: IColor = null): bool {
            return false;
        }

        protected freeInternalTextureImpl(): bool {
            return false;
        }

        setPixelRGBA(i1:  number , i2:  number , iTextureWidth:  number , iTextureHeight:  number , pBuffer: Uint8Array): void {
            return;
        }
	}

}

































module akra {

	export interface IDepthBuffer extends IRenderResource {
		bitDepth:  number ;
		width:  number ;
		height:  number ;

		create(iBitDepth:  number , iWidth:  number , iHeight:  number , bManual: bool): void;

		isManual(): bool;
		isCompatible(pTarget: IRenderTarget): bool;

		_notifyRenderTargetAttached(pTarget: IRenderTarget): void;
		_notifyRenderTargetDetached(pTarget: IRenderTarget): void;
	}
}






module akra {
	export interface IFPSStat {
		last:  number ;
		avg:  number ;
		best:  number ;
		worst:  number ;
	};

	export interface ITimeStat {
		best:  number ;
		worst:  number ;
	};

	export interface IFrameStats {
		fps: IFPSStat;
		time: ITimeStat;
		polygonsCount:  number ;
	}
}













module akra {
    ;
	;
    ;

    export interface ISceneObject extends ISceneNode {
    	worldBounds: IRect3d;
    	totalRenderable:  number ;
        shadow: bool;
        billboard: bool;

         onclick: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;
         onmousemove: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;
         onmousedown: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;
         onmouseup: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;
         onmouseover: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;
         onmouseout: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;
         ondragstart: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;
         ondragstop: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;
         ondragging: (pObject: ISceneObject, pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number ) => void;

    	 localBounds: IRect3d;

        isBillboard(): bool;

        getRenderable(i?:  number ): IRenderableObject;
    	getObjectFlags():  number ;

    	accessLocalBounds(): IRect3d;
    	isWorldBoundsNew(): bool;

        prepareForRender(pViewport: IViewport): void;

         worldBoundsUpdated(): void;

         click(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );
         mousemove(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );
         mousedown(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );
         mouseup(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );
         mouseover(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );
         mouseout(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );

         dragstart(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );
         dragstop(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );
         dragging(pViewport: IViewport, pRenderable: IRenderableObject, x:  number , y:  number );
    }
}



module akra {
	;
	;
	;
	;
	;
    ;
    ;
    ;

	export enum ECameraParameters {
        CONST_ASPECT = 1
	}

    export enum ECameraTypes {
        PERSPECTIVE,
        ORTHO,
        OFFSET_ORTHO
    }



    export interface ICamera extends ISceneNode {
    	 viewMatrix: IMat4;
    	 projectionMatrix: IMat4;
    	 projViewMatrix: IMat4;
// readonly internalProjectionMatrix: IMat4;
// readonly internalViewProjMatrix: IMat4;
    	 targetPos: IVec3;

        fov:  number ;
    	aspect:  number ;
    	nearPlane:  number ;
    	farPlane:  number ;

    	 viewDistance:  number ;
    	 searchRect: IRect3d;
    	 frustum: IFrustum;

    	setParameter(eParam: ECameraParameters, pValue: any): void;
    	isConstantAspect(): bool;

    	setProjParams(fFOV:  number , fAspect:  number , fNearPlane:  number , fFarPlane:  number ): void;
    	setOrthoParams(fWidth:  number , fHeight:  number , fNearPlane:  number , fFarPlane:  number ): void;
    	setOffsetOrthoParams(fMinX:  number , fMaxX:  number , fMinY:  number , fMaxY:  number , fNearPlane:  number , fFarPlane:  number ): void;

        projectPoint(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3;

//moved to private.
// recalcMatrices(): void;

// applyRenderStageBias(iStage: int): void;

//изменились ли параметры процекции
        isProjParamsNew(): bool;
        recalcProjMatrix(): void;

        isActive(): bool;

//display via display list with name <csList>
        display(iList?:  number ): IObjectArray;

    	_renderScene(pViewport: IViewport): void;
    	_keepLastViewport(pViewport: IViewport): void;
    	_getLastViewport(): IViewport;
    	_getNumRenderedFaces():  number ;
        _notifyRenderedFaces(nFaces:  number ): void;
        _getLastResults(iList?:  number ): IObjectArray;

        getDepthRange(): IDepthRange;
    }
}





module akra {
	;
	;

	export enum EFramebuffer {
		FRONT,
		BACK,
		AUTO
	};

	export enum EStatFlags {
		NONE           = 0,
        FPS            = 1,
        AVG_FPS        = 2,
        BEST_FPS       = 4,
        WORST_FPS      = 8,
        TRIANGLE_COUNT = 16,
        ALL            = 0xFFFF
	};

	export enum E3DEventTypes {
        CLICK = 0x01,
        MOUSEMOVE = 0x02,
        MOUSEDOWN = 0x04,
        MOUSEUP = 0x08,
        MOUSEOVER = 0x10,
        MOUSEOUT = 0x20,
        DRAGSTART = 0x40,
        DRAGSTOP = 0x80,
        DRAGGING = 0x100,
        MOUSEWHEEL = 0x200
    }

	export interface IRenderTarget extends IEventProvider {
		name: string;
		width:  number ;
		height:  number ;


		colorDepth:  number ;

		totalViewports:  number ;

		priority:  number ;

		getRenderer(): IRenderer;

		getDepthBuffer(): IDepthBuffer;

		attachDepthBuffer(pBuffer: IDepthBuffer): bool;
		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool;
		attachDepthTexture(pTexture: ITexture): bool;

		detachDepthBuffer(): void;
		detachDepthTexture(): void;
		detachDepthPixelBuffer(): void;

		enableSupportFor3DEvent(iType:  number ):  number ;
        is3DEventSupported(eType: E3DEventTypes): bool;

		destroy(): void;

		update(): void;
		updateStats(): void;

		getCustomAttribute(sName: string): any;

		addViewport(pViewport: IViewport): IViewport;

		getViewport(iIndex:  number ): IViewport;
		getViewportByZIndex(iZIndex:  number ): IViewport;
		hasViewportByZIndex(iZIndex:  number ): bool;
		removeViewport(iZIndex:  number ): bool;
		removeAllViewports():  number ;

		getPolygonCount():  number ;

		getStatistics(): IFrameStats;
		getLastFPS():  number ;
		getAverageFPS():  number ;
		getBestFPS():  number ;
		getWorstFPS():  number ;

		getBestFrameTime():  number ;
		getWorstFrameTime():  number ;
		resetStatistics(): void;

		isActive(): bool;
		setActive(isActive?: bool): void;
		setAutoUpdated(isAutoUpdate?: bool): void;
		isAutoUpdated(): bool;
		isPrimary(): bool;

		readPixels(ppDest?: IPixelBox, eFramebuffer?: EFramebuffer): IPixelBox;

		_beginUpdate(): void;
		_updateViewport(iZIndex:  number , bUpdateStatistics?: bool): void;
		_updateViewport(pViewport: IViewport, bUpdateStatistics?: bool): void;
		_updateAutoUpdatedViewports(bUpdateStatistics?: bool): void;
		_endUpdate(): void;

		 preUpdate(): void;
		 postUpdate(): void;

		 viewportPreUpdate(pViewport: IViewport): void;
		 viewportPostUpdate(pViewport: IViewport): void;
		 viewportAdded(pViewport: IViewport): void;
		 viewportRemoved(pViewport: IViewport): void;

		 resized(width:  number , height:  number ): void;

		 cameraRemoved(pCamera: ICamera): void;
	}
}








module akra {

	export interface IRenderTexture extends IRenderTarget {
		copyContentsToMemory(pDest: IPixelBox, pBuffer: EFramebuffer): void;
		suggestPixelFormat(): EPixelFormats;
		getPixelBuffer(): IPixelBuffer;
	}
}


























module akra {

    export interface IAFXObject{
        getName(): string;
        getId(): IAFXIdInstruction;
    }

    export interface IAFXVariable extends IAFXObject {
        setName(sName: string): void;
        setType(pType: IAFXVariableTypeInstruction): void;
        getType(): IAFXVariableTypeInstruction;

        initializeFromInstruction(pInstruction: IAFXVariableDeclInstruction): void;

    }

    export interface IAFXType extends IAFXObject {
        isBase(): bool;
        initializeFromInstruction(pInstruction: IAFXTypeDeclInstruction): bool;
    }

    export interface IAFXFunction extends IAFXObject {
        getHash(): string;
    }

    export interface IAFXPass extends IAFXObject {

    }

    export interface IAFXTechnique extends IAFXObject {

    }

    export interface IAFXEffectStats{
        time:  number ;
    }

    export interface IAFXEffect {
        analyze(pTree: IParseTree): bool;
        setAnalyzedFileName(sFileName: string): void;
        getStats(): IAFXEffectStats;

        clear(): void;

        getTechniqueList(): IAFXTechniqueInstruction[];
    }
}



// #ifndef IAFXEFFECT_TS
// #define IAFXEFFECT_TS

// #include "IResourcePoolItem.ts"

// module akra {
// 	export interface IAFXEffect extends IResourcePoolItem {

// 	}
// }

// #endif





module akra {
	export interface IAFXPreRenderState {

	}
}




















module akra {

    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;

    export interface IShaderProgram extends IRenderResource {
    	create(csVertex?: string, csPixel?: string): bool;
    	compile(csVertex?: string, csPixel?: string): bool;
    	isLinked(): bool;
    	isValid(): bool;
    	isActive(): bool;

    	setFloat(sName: string, fValue:  number ): void;
    	setInt(sName: string, iValue:  number ): void;

    	setVec2(sName: string, v2fValue: IVec2): void;
// setVec2(sName: string, x: float, y: float): void;

    	setVec2i(sName: string, v2iValue: IVec2): void;
// setVec2i(sName: string, x: int, y: int): void;

    	setVec3(sName: string, v3fValue: IVec3): void;
// setVec3(sName: string, x: float, y: float, z: float): void;

    	setVec3i(sName: string, v3iValue: IVec3): void;
// setVec3i(sName: string, x: int, y: int, z: int): void;

    	setVec4(sName: string, v4fValue: IVec4): void;
// setVec4(sName: string, x: float, y: float, z: float, w: float): void;

    	setVec4i(sName: string, v4iValue: IVec4): void;
// setVec4i(sName: string, x: int, y: int, z: int, w: int): void;

    	setMat3(sName: string, m3fValue: IMat3): void;
    	setMat4(sName: string, m4fValue: IMat4): void;

    	setFloat32Array(sName: string, pValue: Float32Array): void;
    	setInt32Array(sName: string, pValue: Int32Array): void;

    	setVec2Array(sName: string, pValue: IVec2[]): void;
    	setVec2iArray(sName: string, pValue: IVec2[]): void;

    	setVec3Array(sName: string, pValue: IVec3[]): void;
    	setVec3iArray(sName: string, pValue: IVec3[]): void;

    	setVec4Array(sName: string, pValue: IVec4[]): void;
    	setVec4iArray(sName: string, pValue: IVec4[]): void;

    	setMat3Array(sName: string, pValue: IMat3[]): void;
    	setMat4Array(sName: string, pValue: IMat4[]): void;

    	setStruct(sName: string, pData: Object): void;
    	setSampler(sName: string, pSampler: IAFXSamplerState): void;
        setSamplerArray(sName: string, pSamplerList: IAFXSamplerState[]): void;

    	setTexture(sName: string, pData: ITexture): void;

//applyVertexBuffer(sName: string, pBuffer: IVertexBuffer);
    	applyVertexData(sName: string, pData: IVertexData): void;

        applyBufferMap(pMap: IBufferMap): void;

        setVertexBuffer(sName: string, pBuffer: IVertexBuffer): void;

        _getActiveUniformNames(): string[];
        _getActiveAttributeNames(): string[];
    }
}


















module akra.fx {
	export interface IVariableBlendInfo {
		varList: IAFXVariableDeclInstruction[];
		blendType: IAFXVariableTypeInstruction;
		name: string;
		nameIndex:  number ;
	}

	export interface IVariableBlendInfoMap {
		[index:  number ]: IVariableBlendInfo;
	}

	export class VariableBlendContainer {
		protected _pVarBlendInfoList: IVariableBlendInfo[] = null;
		protected _pNameToIndexMap: IntMap = null;
		protected _pNameIndexToIndexMap: IntMap = null;

		/**@inline*/  get varsInfo(): IVariableBlendInfo[] {
			return this._pVarBlendInfoList;
		}

		/**@inline*/  getVarBlenInfo(iIndex:  number ): IVariableBlendInfo {
			return this._pVarBlendInfoList[iIndex];
		}

		/**@inline*/  getVarList(iIndex:  number ): IAFXVariableDeclInstruction[] {
			return this._pVarBlendInfoList[iIndex].varList;
		}

		/**@inline*/  getBlendType(iIndex:  number ): IAFXVariableTypeInstruction {
			return this._pVarBlendInfoList[iIndex].blendType;
		}

		/**@inline*/  getKeyIndexByName(sName: string):  number  {
			return isDef(this._pNameToIndexMap[sName]) ? this._pNameToIndexMap[sName] : (this._pNameToIndexMap[sName] = -1);
		}

		/**@inline*/  getKeyIndexByNameIndex(iNameIndex:  number ):  number  {
			return isDef(this._pNameIndexToIndexMap[iNameIndex]) ? this._pNameIndexToIndexMap[iNameIndex] : (this._pNameIndexToIndexMap[iNameIndex] = -1);
		}

		/**@inline*/  hasVariableWithName(sName: string): bool {
			return this.getKeyIndexByName(sName) === -1 ? false : true;
		}

		/**@inline*/  hasVariableWithNameIndex(iNameIndex:  number ): bool {
			return this.getKeyIndexByNameIndex(iNameIndex) === -1 ? false : true;
		}

		/**@inline*/  hasVariable(pVar: IAFXVariableDeclInstruction): bool {
			return this.hasVariableWithNameIndex(pVar._getNameIndex());
		}

		/**@inline*/  getVariable(iIndex:  number ): IAFXVariableDeclInstruction {
			return this._pVarBlendInfoList[iIndex].varList[0];
		}

		/**@inline*/  getVariableByName(sName: string): IAFXVariableDeclInstruction {
			var iIndex:  number  = this.getKeyIndexByName(sName);
			return iIndex === -1 ? null : this.getVariable(iIndex);
		}

		/**@inline*/  getVariableByNameIndex(iNameIndex:  number ): IAFXVariableDeclInstruction {
			var iIndex:  number  = this.getKeyIndexByNameIndex(iNameIndex);
			return iIndex === -1 ? null : this.getVariable(iIndex);
		}

		constructor() {
			this._pVarBlendInfoList = [];
			this._pNameToIndexMap = <IntMap>{};
			this._pNameIndexToIndexMap = <IntMap>{};
		}

		addVariable(pVariable: IAFXVariableDeclInstruction, eBlendMode: EAFXBlendMode): bool {
			var sName: string = pVariable.getRealName();
			var iNameIndex:  number  = pVariable._getNameIndex();
			var iIndex:  number  = this.getKeyIndexByNameIndex(iNameIndex);

			if(iIndex === -1){
				this._pVarBlendInfoList.push(<IVariableBlendInfo>{
					varList: [pVariable],
					blendType:  pVariable.getType(),
					name: sName,
					nameIndex: iNameIndex
				});

				iIndex = this._pVarBlendInfoList.length - 1;

				this._pNameToIndexMap[sName] = iIndex;
				this._pNameIndexToIndexMap[iNameIndex] = iIndex;

				return true;
			}

			var pBlendType: IAFXVariableTypeInstruction = this._pVarBlendInfoList[iIndex].blendType.blend(pVariable.getType(), eBlendMode);

			if(pBlendType === this._pVarBlendInfoList[iIndex].blendType){
				return true;
			}

			if(isNull(pBlendType)){
				{ logger.setSourceLocation( "fx/BlendContainers.ts" , 111 ); logger.error("Could not blend type for variable '" + sName + "'"); } ;
				return false;
			}

			 this._pVarBlendInfoList[iIndex].varList.push(pVariable);
			 this._pVarBlendInfoList[iIndex].blendType = pBlendType;

			return true;
		}

		/**@inline*/  getDeclCodeForVar(iIndex:  number , bWithInitializer: bool): string {
			var pInfo: IVariableBlendInfo = this._pVarBlendInfoList[iIndex];
			var pType: IAFXVariableTypeInstruction = pInfo.blendType;
			var pVar: IAFXVariableDeclInstruction = this.getVariable(iIndex);

			var sCode: string = pType.toFinalCode() + " ";
			sCode += pVar.getRealName();

			if(pVar.getType().isNotBaseArray()){
				var iLength:  number  = pVar.getType().getLength();
				if(webgl.isANGLE && iLength === 1 && pVar.getType().isComplex()){
					sCode += "[" + 2 + "]";
				}
				else {
					sCode += "[" + iLength + "]";
				}
			}

			if(bWithInitializer && pVar.hasInitializer()){
				sCode += "=" + pVar.getInitializeExpr().toFinalCode();
			}

			return sCode;
		}

		forEach(iIndex:  number , fnModifier: {(pVar: IAFXVariableDeclInstruction): void;}): void {
			if(iIndex === -1){
				return;
			}

			var pVarList: IAFXVariableDeclInstruction[] = this.getVarList(iIndex);

			for(var i:  number  = 0; i < pVarList.length; i++) {
				fnModifier.call(null, pVarList[i]);
			}
		}

		setNameForEach(iIndex:  number , sNewRealName: string): void {
			if(iIndex === -1){
				return;
			}

			var pVarList: IAFXVariableDeclInstruction[] = this.getVarList(iIndex);

			for(var i:  number  = 0; i < pVarList.length; i++) {
				pVarList[i].setRealName(sNewRealName);
			}
		}
	}

/*
	export class VariableBlendContainer {
		protected _pVarListMap: IAFXVariableDeclListMap = null;
		protected _pVarKeys: string[] = null;
		protected _pKeyToIndexMap: IntMap = null;

		protected _pVarBlendTypeMap: IAFXVariableTypeMap = null;

		inline get keys(): string[] {
			return this._pVarKeys;
		}

		inline getVarList(sKey: string): IAFXVariableDeclInstruction[] {
			return this._pVarListMap[sKey];
		}

		inline getBlendType(sKey: string): IAFXVariableTypeInstruction {
			return this._pVarBlendTypeMap[sKey];
		}

		inline getKeyIndex(sKey: string): uint {
			return this._pKeyToIndexMap[sKey];
		}

		constructor() {
			this._pVarListMap = <IAFXVariableDeclListMap>{};
			this._pVarKeys = [];
			this._pKeyToIndexMap = <IntMap>{};

			this._pVarBlendTypeMap = <IAFXVariableTypeMap>{};
		}

		addVariable(pVariable: IAFXVariableDeclInstruction, eBlendMode: EAFXBlendMode): bool {
			var sName: string = pVariable.getRealName();

			if(!isDef(this._pVarListMap[sName])){
				this._pVarListMap[sName] = [pVariable];
				this._pVarKeys.push(sName);
				this._pKeyToIndexMap[sName] = this._pVarKeys.length - 1;

				this._pVarBlendTypeMap[sName] = pVariable.getType();
				
				return true;
			}

			var pBlendType: IAFXVariableTypeInstruction = this._pVarBlendTypeMap[sName].blend(pVariable.getType(), eBlendMode);

			if(pBlendType === this._pVarBlendTypeMap[sName]){
				return true;
			}

			if(isNull(pBlendType)){
				ERROR("Could not blend type for variable '" + sName + "'");
				return false;
			}

			this._pVarListMap[sName].push(pVariable);
			this._pVarBlendTypeMap[sName] = pBlendType;

			return true;
		}

		hasVariableWithName(sName: string): bool {
			if(!isDefAndNotNull(this._pVarBlendTypeMap[sName])){
				this._pVarBlendTypeMap[sName] = null;
				return false;
			}

			return true;
		}

		inline hasVariable(pVar: IAFXVariableDeclInstruction): bool {
			return this.hasVariableWithName(pVar.getRealName());
		}

		inline getVariableByName(sName: string): IAFXVariableDeclInstruction {
			return this.hasVariableWithName(sName) ? this._pVarListMap[sName][0] : null;
		}

		inline getDeclCodeForVar(sName: string, bWithInitializer: bool): string {
			var pType: IAFXVariableTypeInstruction = this.getBlendType(sName);
			var sCode: string = pType.toFinalCode() + " ";
			var pVar: IAFXVariableDeclInstruction = this.getVariableByName(sName);
			
			sCode += pVar.getRealName();
			
			if(pVar.getType().isNotBaseArray()){
				var iLength: uint = pVar.getType().getLength();
				if(webgl.isANGLE && iLength === 1 && pVar.getType().isComplex()){
					sCode += "[" + 2 + "]";
				}
				else {
					sCode += "[" + iLength + "]";
				}
			}

			if(bWithInitializer && pVar.hasInitializer()){
				sCode += "=" + pVar.getInitializeExpr().toFinalCode();
			}

			return sCode;
		}

		forEach(sKey: string, fnModifier: {(pVar: IAFXVariableDeclInstruction): void;}): void {
			if(this.hasVariableWithName(sKey)) {
				var pVarList: IAFXVariableDeclInstruction[] = this.getVarList(sKey);

				for(var i: uint = 0; i < pVarList.length; i++) {
					fnModifier.call(null, pVarList[i]);
				}
			}
		}

		setNameForEach(sKey: string, sNewRealName: string): void {
			if(this.hasVariableWithName(sKey)) {
				var pVarList: IAFXVariableDeclInstruction[] = this.getVarList(sKey);

				for(var i: uint = 0; i < pVarList.length; i++) {
					pVarList[i].setRealName(sNewRealName);
				}
			}
		}
	}
	*/



	export class ComplexTypeBlendContainer {
		private _pTypeListMap: IAFXTypeMap = null;
		private _pTypeKeys: string[] = null;

		/**@inline*/  get keys(): string[]{
			return this._pTypeKeys;
		}

		/**@inline*/  get types(): IAFXTypeMap {
			return this._pTypeListMap;
		}

		constructor() {
			this._pTypeListMap = <IAFXTypeMap>{};
			this._pTypeKeys = [];
		}

		addComplexType(pComplexType: IAFXTypeInstruction): bool {
			var pFieldList: IAFXVariableDeclInstruction[] = (<ComplexTypeInstruction>pComplexType)._getFieldDeclList();
			for(var i:  number  = 0; i < pFieldList.length; i++){
				if(pFieldList[i].getType().isComplex()){
					if(!this.addComplexType(pFieldList[i].getType().getBaseType())){
						return false;
					}
				}
			}

			var sName: string = pComplexType.getRealName();

			if(!isDef(this._pTypeListMap[sName])){
				this._pTypeListMap[sName] = pComplexType;
				this._pTypeKeys.push(sName);

				return true;
			}

			var pBlendType: IAFXTypeInstruction = this._pTypeListMap[sName].blend(pComplexType, EAFXBlendMode.k_TypeDecl);
			if(isNull(pBlendType)){
				{ logger.setSourceLocation( "fx/BlendContainers.ts" , 335 ); logger.error("Could not blend type declaration '" + sName + "'"); } ;
				return false;
			}

			this._pTypeListMap[sName]= pBlendType;

			return true;
		}

		addFromVarConatiner(pContainer: VariableBlendContainer): bool {
			if(isNull(pContainer)){
				return true;
			}

			var pVarInfoList: IVariableBlendInfo[] = pContainer.varsInfo;

			for(var i:  number  = 0; i < pVarInfoList.length; i++){
				var pType: IAFXTypeInstruction = pContainer.getBlendType(i).getBaseType();

				if(pType.isComplex()){
					if(!this.addComplexType(pType)){
						return false;
					}
				}
			}

			return true;
		}
	}

	export class ExtSystemDataContainer {
		protected _pExtSystemMacrosList: IAFXSimpleInstruction[] = null;
		protected _pExtSystemTypeList: IAFXTypeDeclInstruction[] = null;
		protected _pExtSystemFunctionList: IAFXFunctionDeclInstruction[] = null;

		/**@inline*/  get macroses(): IAFXSimpleInstruction[] {
			return this._pExtSystemMacrosList;
		}

		/**@inline*/  get types(): IAFXTypeDeclInstruction[] {
			return this._pExtSystemTypeList;
		}

		/**@inline*/  get functions(): IAFXFunctionDeclInstruction[] {
			return this._pExtSystemFunctionList;
		}

		constructor(){
			this._pExtSystemMacrosList = [];
			this._pExtSystemTypeList = [];
			this._pExtSystemFunctionList = [];
		}

		addFromFunction(pFunction: IAFXFunctionDeclInstruction): void {
			var pTypes = pFunction._getExtSystemTypeList();
			var pMacroses = pFunction._getExtSystemMacrosList();
			var pFunctions = pFunction._getExtSystemFunctionList();

			if(!isNull(pTypes)){
				for(var j:  number  = 0; j < pTypes.length; j++){
					if(this._pExtSystemTypeList.indexOf(pTypes[j]) === -1){
						this._pExtSystemTypeList.push(pTypes[j]);
					}
				}
			}

			if(!isNull(pMacroses)){
				for(var j:  number  = 0; j < pMacroses.length; j++){
					if(this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1){
						this._pExtSystemMacrosList.push(pMacroses[j]);
					}
				}
			}

			if(!isNull(pFunctions)){
				for(var j:  number  = 0; j < pFunctions.length; j++){
					if(this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1){
						this._pExtSystemFunctionList.push(pFunctions[j]);
					}
				}
			}
		}
	}


	export interface IDataFlowMap {
		[index: string]: IDataFlow;
	}

	export interface IAFXVaribaleListMap{
		[index: string]: IAFXVariableDeclInstruction[];
	}

	export interface ITypeInfo {
		isComplex: bool;
		isPointer: bool;
		isStrictPointer: bool;
	}

	export class AttributeBlendContainer extends VariableBlendContainer {

		private _pSlotBySemanticIndex:  number [] = null;
		private _pTypeInfoBySemanticIndex: ITypeInfo[] = null;

		private _pFlowBySlots:  number [] = null;
		private _pSlotByFlows:  number [] = null;
		private _pIsPointerBySlot: bool[] = null;
		private _pVBByBufferSlots:  number [] = null;
		private _pBufferSlotBySlots:  number [] = null;

		private _pHashPartList:  number [] = null;

		private _pOffsetVarsBySemanticMap: IAFXVaribaleListMap = null;
		private _pOffsetDefaultMap: IntMap = null;

		private _nSemantics:  number  = 0;
		private _nSlots:  number  = 0;
		private _nBufferSlots:  number  = 0;

		protected _sHash: string = "";

		/**@inline*/  get attrsInfo(): IVariableBlendInfo[] {
			return this.varsInfo;
		}

		/**@inline*/  get totalSlots():  number  {
			return this._nSlots;
		}

		/**@inline*/  get totalBufferSlots():  number  {
			return this._nBufferSlots;
		}

		constructor() {
			super();

			this._pSlotBySemanticIndex = null;
//this._pFlowBySemanticIndex = null;

			var iMaxSlots:  number  = 16;
			var iMaxVertexSamplers:  number  = 4;

			iMaxSlots = webgl.maxVertexAttributes;
			iMaxVertexSamplers = webgl.maxVertexTextureImageUnits;

			this._pFlowBySlots = new Array(iMaxSlots);
			this._pSlotByFlows = new Array(iMaxSlots);
			this._pIsPointerBySlot = new Array(iMaxSlots);
			this._pVBByBufferSlots = new Array(iMaxVertexSamplers);
			this._pBufferSlotBySlots = new Array(iMaxSlots);
			this._pHashPartList = null;
		}

		/**@inline*/  getOffsetVarsBySemantic(sName: string): IAFXVariableDeclInstruction[] {
			return this._pOffsetVarsBySemanticMap[sName];
		}

		/**@inline*/  getOffsetDefault(sName: string):  number  {
			return this._pOffsetDefaultMap[sName];
		}

		/**@inline*/  getSlotBySemanticIndex(iIndex:  number ):  number  {
			return this._pSlotBySemanticIndex[iIndex];
		}

		/**@inline*/  getBufferSlotBySemanticIndex(iIndex:  number ):  number  {
			return this._pBufferSlotBySlots[this.getSlotBySemanticIndex(iIndex)];
		}

		/**@inline*/  getAttributeListBySemanticIndex(iIndex:  number ): IAFXVariableDeclInstruction[] {
			return this.getVarList(iIndex);
		}

		/**@inline*/  getTypeForShaderAttributeBySemanticIndex(iIndex:  number ): IAFXTypeInstruction {
			return this._pIsPointerBySlot[this.getSlotBySemanticIndex(iIndex)] ?
						Effect.getSystemType("ptr") :
						this.getTypeBySemanticIndex(iIndex).getBaseType();
		}


		/**@inline*/  getTypeBySemanticIndex(iIndex:  number ): IAFXVariableTypeInstruction {
			return this.getBlendType(iIndex);
		}

		/**@inline*/  addAttribute(pVariable: IAFXVariableDeclInstruction): bool {
			return this.addVariable(pVariable, EAFXBlendMode.k_Attribute);
		}

		/**@inline*/  hasAttrWithSemantic(sSemantic: string): bool {
			return this.hasVariableWithName(sSemantic);
		}

		/**@inline*/  getAttributeBySemanticIndex(iIndex:  number ): IAFXVariableDeclInstruction {
			return this.getVariable(iIndex);
		}

		/**@inline*/  getAttributeBySemantic(sSemantic: string): IAFXVariableDeclInstruction {
			return this.getVariableByName(sSemantic);
		}

		/**@inline*/  hasTexcoord(iSlot:  number ): bool {
			return this.hasAttrWithSemantic(DeclUsages.TEXCOORD + iSlot.toString());
		}

		/**@inline*/  getTexcoordVar(iSlot:  number ): IAFXVariableDeclInstruction {
			return this.getVariableByName(DeclUsages.TEXCOORD + iSlot.toString());
		}

		finalize(): void {
			this._nSemantics = this.attrsInfo.length;

			this._pSlotBySemanticIndex = new Array(this._nSemantics);
			this._pTypeInfoBySemanticIndex = new Array(this._nSemantics);

			for(var i:  number  = 0; i < this._nSemantics; i++){
				this._pSlotBySemanticIndex[i] = -1;
				this._pTypeInfoBySemanticIndex[i] = this.createTypeInfo(i);
			}

			for(var i:  number  = 0; i < this._pFlowBySlots.length; i++){
				this._pFlowBySlots[i] = -1;
				this._pSlotByFlows[i] = -1;
				this._pIsPointerBySlot[i] = false;
				this._pBufferSlotBySlots[i] = -1;
			}

			for(var i:  number  = 0; i < this._pVBByBufferSlots.length; i++){
				this._pVBByBufferSlots[i] = 0;
			}
		}

		clear(): void {
			this._nSlots = 0;
			this._nBufferSlots = 0;

			this._sHash = "";
		}

		generateOffsetMap(): void {
			this._pOffsetVarsBySemanticMap = <IAFXVaribaleListMap>{};
			this._pOffsetDefaultMap = <IntMap>{};

			var pAttrs: IVariableBlendInfo[] = this.attrsInfo;

			for(var i:  number  = 0; i < pAttrs.length; i++){
				var pAttrInfo: IVariableBlendInfo = pAttrs[i];
				var sSemantic: string = pAttrInfo.name;
				var pAttr: IAFXVariableDeclInstruction = this.getAttributeBySemanticIndex(i);

				if(pAttr.isPointer()){
					this._pOffsetVarsBySemanticMap[sSemantic] = [];
					if(pAttr.getType().isComplex()){
						var pAttrSubDecls: IAFXVariableDeclInstruction[] = pAttr.getSubVarDecls();

						for(var j:  number  = 0; j < pAttrSubDecls.length; j++){
							var pSubDecl: IAFXVariableDeclInstruction = pAttrSubDecls[j];

							if(pSubDecl.getName() === "offset") {
								var sOffsetName: string = pSubDecl.getRealName();

								this._pOffsetVarsBySemanticMap[sSemantic].push(pSubDecl)
								this._pOffsetDefaultMap[sOffsetName] = (<IAFXVariableDeclInstruction>pSubDecl.getParent()).getType().getPadding();
							}
						}
					}
					else {
						var pOffsetVar: IAFXVariableDeclInstruction = pAttr.getType()._getAttrOffset();
						var sOffsetName: string = pOffsetVar.getRealName();

						this._pOffsetVarsBySemanticMap[sSemantic].push(pOffsetVar);
						this._pOffsetDefaultMap[sOffsetName] = 0;
					}
				}
				else{
					this._pOffsetVarsBySemanticMap[sSemantic] = null;
				}

			}
		}

		initFromBufferMap(pMap: util.BufferMap): void {
			this.clear();

			if(isNull(pMap)){
				{ logger.setSourceLocation( "fx/BlendContainers.ts" , 622 ); logger.criticalError("Yoy don`t set any buffermap for render"); } ;
				return;
			}

			var pAttrs: IVariableBlendInfo[] = this.attrsInfo;
			var iHash:  number  = 0;

			for(var i:  number  = 0; i < pAttrs.length; i++) {
				var pAttrInfo: IVariableBlendInfo = pAttrs[i];
				var sSemantic: string = pAttrInfo.name;
				var pTypeInfo: ITypeInfo = this._pTypeInfoBySemanticIndex[i];

				var pFindFlow: IDataFlow = null;

				if(pTypeInfo.isComplex){
// pFindFlow = pMap.findFlow(sSemantic) || pMap.getFlow(sSemantic, true);
					pFindFlow = pMap.findFlow(sSemantic) || pMap.getFlowBySemantic(sSemantic);
				}
				else {
// pFindFlow = pMap.getFlow(sSemantic, true);
					pFindFlow = pMap.getFlowBySemantic(sSemantic);
				}

				if(!isNull(pFindFlow)) {
					var iBufferSlot:  number  = -1;
					var iFlow:  number  = pFindFlow.flow;
					var iSlot:  number  = this._pSlotByFlows[iFlow];

					if(iSlot >= 0 && iSlot < this._nSlots && this._pFlowBySlots[iSlot] === iFlow){
						this._pSlotBySemanticIndex[i] = iSlot;
						iHash += ((iSlot + 1) << 5 + (this._pBufferSlotBySlots[iSlot] + 1)) << iSlot;
// continue;
					}
					else {
						iSlot = this._nSlots;

						if (pFindFlow.type === EDataFlowTypes.MAPPABLE) {
							if(!pTypeInfo.isPointer) {
								{ logger.setSourceLocation( "fx/BlendContainers.ts" , 660 ); logger.criticalError("You try to put pointer data into non-pointer attribute with semantic '" + sSemantic + "'"); } ;
							}
// iSlot = this._pSlotByFlows[iFlow];

// if(iSlot >= 0 && this._pFlowBySlots[iSlot] === iFlow){
// 	this._pSlotBySemanticIndex[i] = iSlot;
// 	iHash += ((iSlot + 1) << 5 + (this._pBufferSlotBySlots[iSlot] + 1)) << iSlot;
// 	continue;
// }

// iSlot = this._nSlots;

							var iBuffer:  number  = (<any>pFindFlow.data.buffer).getGuid();

							for(var j:  number  = 0; j < this._nBufferSlots; j++){
								if(this._pVBByBufferSlots[j] === iBuffer){
									iBufferSlot = j;
									break;
								}
							}

							if(iBufferSlot === -1){
								iBufferSlot = this._nBufferSlots;
								this._pVBByBufferSlots[iBufferSlot] = iBuffer;
								this._nBufferSlots++;
							}

							this._pIsPointerBySlot[iSlot] = true;
						}
						else {
							if(pTypeInfo.isStrictPointer) {
								{ logger.setSourceLocation( "fx/BlendContainers.ts" , 691 ); logger.criticalError("You try to put non-pointer data into pointer attribute with semantic '" + sSemantic + "'"); } ;
							}

							this._pIsPointerBySlot[iSlot] = false;
						}
//new slot
						this._pSlotBySemanticIndex[i] = iSlot;
						this._pFlowBySlots[iSlot] = iFlow;
						this._pSlotByFlows[iFlow] = iSlot;
						this._pBufferSlotBySlots[iSlot] = iBufferSlot;

						iHash += ((iSlot + 1) << 5 + (iBufferSlot + 1)) << iSlot;
						this._nSlots++;
					}
				}
				else {
					this._pSlotBySemanticIndex[i] = -1;
				}
			}

			this._sHash = iHash.toString();
		}

		/**@inline*/  getHash(): string {
			return this._sHash;
		}


		private createTypeInfo(iIndex:  number ): ITypeInfo {
			return <ITypeInfo>{
				isComplex: this.getTypeBySemanticIndex(iIndex).isComplex(),
				isPointer: this.getTypeBySemanticIndex(iIndex).isPointer(),
				isStrictPointer: this.getTypeBySemanticIndex(iIndex).isStrictPointer()
			};
		}
	}
}









module akra.fx {



//TODO: CHECK SAMPLER TYPE

	export class SamplerBlender {
		protected _pSlotList: util.ObjectArray[] = null;
		protected _nActiveSlots:  number  = 0;

		protected _pIdToSlotMap: IntMap = null;
		protected _pIdList:  number [] = null;

		/**@inline*/  get slots(): util.ObjectArray[] {
			return this._pSlotList;
		}

		/**@inline*/  get totalActiveSlots():  number  {
			return this._nActiveSlots;
		}

		constructor() {
			this._pSlotList = new Array( 32 );

			for(var i:  number  = 0; i < this._pSlotList.length; i++){
				this._pSlotList[i] = new util.ObjectArray();
			}

			this._nActiveSlots = 1;

			this._pIdToSlotMap = <IntMap><any>{0 : 0};
			this._pIdList = new Array( 32 );
		}

		/**@inline*/  getSamplersBySlot(iSlot:  number ): util.ObjectArray {
			return this.slots[iSlot];
		}

		clear(): void {
			for(var i:  number  = 0; i < this._nActiveSlots; i++){
				this._pSlotList[i].clear(false);
			}

			for(var i:  number  = 0; i < this._nActiveSlots - 1; i++){
				this._pIdToSlotMap[this._pIdList[i]] = -1;
			}

			this._nActiveSlots = 1;
		}

		clearSamplerNames(): void {
			for(var i:  number  = 0; i < this._nActiveSlots; i++){
				for(var j:  number  = 0; j < this._pSlotList[i].length; j++){
					var pSampler: IAFXVariableDeclInstruction = this._pSlotList[i].value(j);
					pSampler.setRealName(pSampler.getSemantic() || pSampler.getName());
					pSampler.defineByZero(false);
				}
			}
		}

		addTextureSlot(id:  number ): void {
			if(this._pIdToSlotMap[id] > 0){
				return;
			}

// if(this._pSlotList.length === this._nActiveSlots){
// 	this._pSlotList.push(new util.ObjectArray());
// }

			this._pIdToSlotMap[id] = this._nActiveSlots;
			this._pIdList[this._nActiveSlots - 1] = id;
			this._nActiveSlots++;
		}

		/**@inline*/  addObjectToSlotById(pObject: any, id:  number ): void {
			this._pSlotList[this._pIdToSlotMap[id]].push(pObject);
		}

		addObjectToSlotIdAuto(pObject: any, id:  number ): void {
			this.addTextureSlot(id);
			this.addObjectToSlotById(pObject, id);
		}

		getHash(): string {
			var sHash: string = "";

			for(var i:  number  = 0; i < this._nActiveSlots; i++){
				var pBlend: util.ObjectArray = this._pSlotList[i];

				if(pBlend.length > 0) {
					if(i === 0) {
						sHash += "Z";
					}

					for(var j:  number  = 0; j < pBlend.length; j++){
						sHash += pBlend.value(j).getGuid() + ".";
					}

					sHash += ".";
				}
			}

			return sHash;
		}
	}


}




module akra {
	;
	;
	;
	;

	export interface IAFXMakerMap {
		[index: string]: IAFXMaker;
		[index:  number ]: IAFXMaker;
	}

	export interface IAFXBaseAttrInfo {
		name: string;
		semantic: string;
	}

	export interface IAFXMaker extends IUnique {
		 shaderProgram: IShaderProgram;
		 uniformNames: string[];
		 attributeInfo: IAFXBaseAttrInfo[];

		_create(sVertex: string, sPixel: string): bool;

		isUniformExists(sName: string): bool;
		isAttrExists(sName: string): bool;

		isArray(sName: string): bool;
		getType(sName: string): EAFXShaderVariableType;
		getLength(sName: string):  number ;
		setUniform(iLocation:  number , pValue: any): void;

		_make(pPassInput: IAFXPassInputBlend, pBufferMap: IBufferMap): IShaderInput;
		_initInput(pPassInput: IAFXPassInputBlend, pBlend: fx.SamplerBlender,
				pAttrs: fx.AttributeBlendContainer): bool;
		_createDataPool(): IShaderInput;
		_getShaderInput(): IShaderInput;
		_releaseShaderInput(pPool: IShaderInput): void;

	}
}










module akra {


	export interface IAFXPassBlendMap {
		[index:  number ]: IAFXPassBlend;
		[index: string]: IAFXPassBlend;
	}

	export interface IAFXPassBlend extends IUnique {
		initFromPassList(pPassList: IAFXPassInstruction[]): bool;
		generateFXMaker(pPassInput: IAFXPassInputBlend,
						pSurfaceMaterial: ISurfaceMaterial,
						pBuffer: IBufferMap): IAFXMaker;

		_hasUniformWithName(sName: string): bool;
		_hasUniformWithNameIndex(iNameIndex:  number ): bool;
		_getRenderStates(): IRenderStateMap;
	}
}





























module akra {
	export interface IRenderPass extends IUnique {
		setForeign(sName: string, fValue:  number ): void;
		setTexture(sName: string, pTexture: ITexture): void;
		setUniform(sName: string, pValue: any): void;
		setStruct(sName: string, pValue: any): void;
		setRenderState(eState: ERenderStates, eValue: ERenderStateValues): void;

		setSamplerTexture(sName: string, sTexture: string): void;
		setSamplerTexture(sName: string, pTexture: ITexture): void;

		getRenderTarget(): IRenderTarget;
		setRenderTarget(pTarget: IRenderTarget): void;

		getPassInput(): IAFXPassInputBlend;
		setPassInput(pInput: IAFXPassInputBlend, isNeedRelocate: bool): void;

		blend(sComponentName: string, iPass:  number ): bool;

		activate(): void;
		deactivate(): void;
		isActive(): bool;
	}
}



module akra {
	;
	;
	;

	export interface IRenderTechnique extends IEventProvider {
		 totalPasses:  number ;
		 modified:  number ;
	 data: IAFXComponentBlend;

		destroy(): void;

		getPass(n:  number ): IRenderPass;
		getMethod(): IRenderMethod;

		setMethod(pMethod: IRenderMethod);
		isReady(): bool;

		setState(sName: string, pValue: any): void;
		setForeign(sName: string, pValue: any): void;
		setStruct(sName: string, pValue: any): void;

		setTextureBySemantics(sName: string, pValue: any): void;
		setShadowSamplerArray(sName: string, pValue: any): void;
		setVec2BySemantic(sName: string, pValue: any): void;

		addComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		addComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;
		addComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;

		delComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		delComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;

		hasComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		hasOwnComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;

		hasPostEffect(): bool;

		isPostEffectPass(iPass:  number ): bool;
		isLastPass(iPass:  number ): bool;
		isFirstPass(iPass:  number ): bool;

		isFreeze(): bool;

		updatePasses(bSaveOldUniformValue: bool): void;

		_blockPass(iPass:  number ): void;

        _setPostEffectsFrom(iPass:  number ): void;

		_setComposer(pComposer: IAFXComposer): void;
		_getComposer(): IAFXComposer;
		_renderTechnique(pViewport: IViewport, pRenderable: IRenderableObject, pSceneObject: ISceneObject): void;

		 render(iPass:  number , pRenderable: IRenderableObject, pSceneObject: ISceneObject, pViewport: IViewport): void;
	}
}















module akra {

    ;
    ;
    ;
    ;
    ;

    export interface IDepthRange{
        min:  number ;
        max:  number ;
    };

    export enum EViewportTypes {
        DEFAULT = -1,
        DSVIEWPORT = 1,
        SHADOWVIEWPORT = 2,
        COLORVIEWPORT,
        TEXTUREVIEWPORT
    }

    export interface IViewport extends IEventProvider, IClickable {
        left:  number ;
        top:  number ;
        width:  number ;
        height:  number ;

//in pixels
        actualLeft:  number ;
        actualTop:  number ;
        actualWidth:  number ;
        actualHeight:  number ;

        zIndex:  number ;

        backgroundColor: IColor;
        depthClear:  number ;

         type: EViewportTypes;

        update(): void;
        destroy(): void;

        hide(bValue?: bool): void;

        startFrame(): void;
        renderObject(pRenderable: IRenderableObject): void;
        endFrame(): void;

        clear(iBuffers?:  number , cColor?: IColor, fDepth?:  number , iStencil?:  number ): void;

        enableSupportFor3DEvent(iType:  number ):  number ;
        is3DEventSupported(eType: E3DEventTypes): bool;
        touch(): void;

        pick(x:  number , y:  number ): IRIDPair;

        getObject(x:  number , y:  number ): ISceneObject;
        getRenderable(x:  number , y:  number ): IRenderableObject;

        getTarget(): IRenderTarget;
        getCamera(): ICamera;
        setCamera(pCamera: ICamera): bool;
        getDepth(x:  number , y:  number ):  number ;
        getDepthRange(): IDepthRange;

        setDimensions(fLeft:  number , fTop:  number , fWidth:  number , fHeight:  number ): bool;
        setDimensions(pRect: IRect2d): bool;

        getActualDimensions(): IRect2d;

        projectPoint(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3;
        unprojectPoint(x:  number , y:  number , v3fDestination?: IVec3): IVec3;
        unprojectPoint(pPos: IPoint, v3fDestination?: IVec3): IVec3;

//iBuffers=FBT_COLOUR|FBT_DEPTH
        setClearEveryFrame(isClear: bool, iBuffers?:  number ): void;
        getClearEveryFrame(): bool;
        getClearBuffers():  number ;

        setDepthParams(bDepthTest: bool, bDepthWrite: bool, eDepthFunction: ECompareFunction): void;
        setCullingMode(eCullingMode: ECullingMode): void;

        setAutoUpdated(bValue?: bool): void;
        isAutoUpdated(): bool;

        isUpdated(): bool;
/**
         * Is mouse under the viewport?
         */

        isMouseCaptured(): bool;

        _clearUpdatedFlag(): void;
        _updateImpl(): void;

        _getNumRenderedPolygons():  number ;
        _updateDimensions(pDimensions: IRect2d): void;

        _getViewportState(): IViewportState;
        _setTarget(pTarget: IRenderTarget): void;


         viewportDimensionsChanged(): void;
         viewportCameraChanged(): void;
         render(pTechnique: IRenderTechnique, iPass:  number , pRenderable: IRenderableObject, pSceneObject: ISceneObject);
    }
}



module akra {

	export enum ERenderDataTypes {
		UNKNOWN,

        MESH_SUBSET,
        SCREEN,
        SPRITE
    }

	export interface IRenderableObject extends IEventProvider {
		renderMethod: IRenderMethod;
		shadow: bool;

		 type: ERenderDataTypes;
		 effect: IEffect;
		 surfaceMaterial: ISurfaceMaterial;
		 data: IRenderData;
		 material: IMaterial;

		 onclick:   (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;
         onmousemove: (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;
         onmousedown: (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;
         onmouseup:   (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;
         onmouseover:   (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;
         onmouseout:   (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;

         ondragstart:   (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;
         ondragstop:   (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;
         ondragging:   (pRenderable: IRenderableObject, pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number ) => void;

		getRenderer(): IRenderer;
		getTechnique(sName?: string): IRenderTechnique;
		getTechniqueDefault(): IRenderTechnique;

		destroy(): void;
		setVisible(bVisible?: bool): void;
		isVisible(): bool;

		addRenderMethod(pMethod: IRenderMethod, csName?: string): bool;
		addRenderMethod(csMethod: string, csName?: string): bool;

// findRenderMethod(csName: string): uint;
		switchRenderMethod(csName: string): bool;
		switchRenderMethod(pMethod: IRenderMethod): bool;

		removeRenderMethod(csName: string): bool;
		getRenderMethod(csName?: string): IRenderMethod;

		getRenderMethodDefault(): IRenderMethod;

		isReadyForRender(): bool;
		isAllMethodsLoaded(): bool;
		isFrozen(): bool;

		wireframe(enable?: bool, bOverlay?: bool): bool;

		render(pViewport: IViewport, csMethod?: string, pSceneObject?: ISceneObject): void;

		_setRenderData(pData: IRenderData): void;
		_setup(pRenderer: IRenderer, csDefaultMethod?: string): void;
		_draw(): void;

/** Notify, when shadow added or removed. */

		 shadowed(bValue: bool): void;
/** Notify, before object start rendendering */

		 beforeRender(pViewport: IViewport, pMethod: IRenderMethod): void;

		 click(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );

         mousemove(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );
         mousedown(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );
         mouseup(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );
         mouseover(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );
         mouseout(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );

         dragstart(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );
         dragstop(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );
         dragging(pViewport: IViewport, pObject: ISceneObject, x:  number , y:  number );
	}
}





















module akra {
	export interface IBufferData {
		byteOffset:  number ;
		byteLength:  number ;
		buffer: IBuffer;
	}
}





module akra {
	;
	;
	;
	;

	export interface IVertexData extends IBufferData, IBuffer, IEventProvider {
		 stride:  number ;
		 startIndex:  number ;
		 id:  number ;

		getVertexDeclaration(): data.VertexDeclaration;
		setVertexDeclaration(pDecl: IVertexDeclaration): bool;

		getVertexElementCount():  number ;
		hasSemantics(sSemantics: string): bool;

		destroy(): void;

		extend(pDecl: IVertexDeclaration, pData?: ArrayBufferView): bool;
		resize(nCount:  number , pDecl?: IVertexDeclaration): bool;
		resize(nCount:  number , iStride?:  number ): bool;
		applyModifier(sUsage: string, fnModifier: IBufferDataModifier): bool;

		setData(pData: ArrayBufferView, iOffset:  number , iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView, sUsage?: string, iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;

		getData(): ArrayBuffer;
		getData(iOffset:  number , iSize:  number , iFrom?:  number , iCount?:  number ): ArrayBuffer;
		getData(sUsage: string): ArrayBuffer;
		getData(sUsage: string, iFrom:  number , iCount:  number ): ArrayBuffer;

		getTypedData(sUsage: string, iFrom?:  number , iCount?:  number ): ArrayBufferView;
		getBufferHandle():  number ;

		toString(): string;

//when data moved in memory(in parent Hardware Buffer)
		 relocated(from:  number , to:  number ): void;
//when data size changed
		 resized(byteLength:  number ): void;
//when declaration changed
		declarationChanged(decl: IVertexDeclaration): void;
//when data has been modified
		 updated(): void;
	}
}











module akra {

	;
	;
	;

	export enum EVertexBufferTypes {
		UNKNOWN,
		VBO,
		TBO
	};

	export interface IVertexBuffer extends IHardwareBuffer, IRenderResource {

		 type: EVertexBufferTypes;

		getVertexData(i:  number ): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pElements: IVertexElement[]): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pDecl: IVertexDeclaration): IVertexData;

		getEmptyVertexData(iCount:  number , pElements: IVertexElement[], ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDecl: IVertexDeclaration, ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pSize:  number , ppVertexDataIn?: IVertexData): IVertexData;

		freeVertexData(pVertexData: IVertexData): bool;
		freeVertexData(): bool;

		create(iByteSize:  number , iFlags?:  number , pData?: Uint8Array): bool;

		allocateData(pElements: IVertexElement[], pData: ArrayBufferView): IVertexData;
		allocateData(pDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
	}
}















module akra {

	;

	export interface IIndexBuffer extends IHardwareBuffer, IRenderResource {

		create(iByteSize:  number , iFlags?:  number , pData?: ArrayBufferView): bool;

		getIndexData(iOffset:  number , iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData;
		getEmptyIndexData(iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData;

		freeIndexData(pIndexData: IIndexData): bool;


		allocateData(ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes, pData: ArrayBufferView): IIndexData;
	}
}








module akra {
	;

    export interface IRenderEntry {
    	viewport: IViewport;
    	renderTarget: IRenderTarget;
		maker: IAFXMaker;
		input: IShaderInput;
		bufferMap: IBufferMap;

		clear(): void;
    }
}












module akra {
	export enum ECanvasTypes {
		TYPE_UNKNOWN = -1,
		TYPE_2D = 1,
		TYPE_3D
	};

	export interface ICanvas {
		type: ECanvasTypes;


		isFullscreen(): bool;
		setFullscreen(isFullscreen?: bool): void;
	}
}



module akra {
	;

	export interface ICanvas3d extends ICanvas, IRenderTarget {
		left:  number ;
		top:  number ;


		create(sName: string, iWidth?:  number , iHeight?:  number , isFullscreen?: bool): bool;
		destroy(): void;

		setFullscreen(isFullscreen?: bool): void;
		setVisible(bVisible?: bool): void;
		setDeactivateOnFocusChange(bDeactivate?: bool): void;

		isFullscreen(): bool;
		isVisible(): bool;
		isDeactivatedOnFocusChange(): bool;


		resize(iWidth:  number , iHeight:  number ): void;
	}
}






















module akra{

	;
	;

	export interface IRect2d{
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;

		left:  number ;
		top:  number ;

		width:  number ;
		height:  number ;

		set(): IRect2d;
		set(pRect: IRect2d): IRect2d;
		set(v2fVec: IVec2): IRect2d;
		set(fSizeX:  number , fSizeY:  number ): IRect2d;
		set(v2fMinPoint: IVec2, v2fMaxPoint: IVec2): IRect2d;
		set(fX0:  number , fX1:  number , fY0:  number , fY1:  number ): IRect2d;

		setFloor(pRect: IRect2d): IRect2d;
		setCeil(pRect: IRect2d): IRect2d;

		clear(): IRect2d;

		addSelf(fValue:  number ): IRect2d;
		addSelf(v2fVec: IVec2): IRect2d;

		subSelf(fValue:  number ): IRect2d;
		subSelf(v2fVec: IVec2): IRect2d;

		multSelf(fValue:  number ): IRect2d;
		multSelf(v2fVec: IVec2): IRect2d;

		divSelf(fValue:  number ): IRect2d;
		divSelf(v2fVec: IVec2): IRect2d;

		offset(v2fOffset: IVec2): IRect2d;
		offset(fOffsetX:  number , fOffsetY:  number ): IRect2d;

		expand(fValue:  number ): IRect2d;
		expand(v2fValue: IVec2): IRect2d;
		expand(fValueX:  number , fValueY:  number ): IRect2d;

		expandX(fValue:  number ): IRect2d;
		expandY(fValue:  number ): IRect2d;

		resize(v2fSize: IVec2): IRect2d;
		resize(fSizeX:  number , fSizeY:  number ): IRect2d;

		resizeX(fSize:  number ): IRect2d;
		resizeY(fSize:  number ): IRect2d;

		resizeMax(v2fSpan: IVec2): IRect2d;
		resizeMax(fSpanX:  number , fSpanY:  number ): IRect2d;

		resizeMaxX(fSpan:  number ): IRect2d;
		resizeMaxY(fSpan:  number ): IRect2d;

		resizeMin(v2fSpan: IVec2): IRect2d;
		resizeMin(fSpanX:  number , fSpanY:  number ): IRect2d;

		resizeMinX(fSpan:  number ): IRect2d;
		resizeMinY(fSpan:  number ): IRect2d;

		unionPoint(v2fPoint: IVec2): IRect2d;
		unionPoint(fX:  number , fY:  number ): IRect2d;
		unionRect(pRect: IRect2d): IRect2d;

		negate(pDestination?: IRect2d): IRect2d;
		normalize(): IRect2d;

		isEqual(pRect: IRect2d): bool;
		isClear(): bool;
		isValid(): bool;
		isPointInRect(v2fPoint: IVec2): bool;

		midPoint(v2fDestination?: IVec2): IVec2;
		midX():  number ;
		midY():  number ;

		size(v2fDestination?: IVec2): IVec2;
		sizeX():  number ;
		sizeY():  number ;

		minPoint(v2fDestination?: IVec2): IVec2;
		maxPoint(v2fDestination?: IVec2): IVec2;

		area():  number ;

		corner(iIndex:  number , v2fDestination?: IVec2): IVec2;

		createBoundingCircle(pCircle?: ICircle): ICircle;

		distanceToPoint(v2fPoint: IVec2):  number ;

		toString(): string;
	};
};












module akra {

	;

	export interface ICircle {

		radius:  number ;
		center: IVec2;

		set(): ICircle;
		set(pCircle: ICircle): ICircle;
		set(v2fCenter: IVec2, fRadius:  number ): ICircle;
		set(fCenterX:  number , fCenterY:  number , fRadius:  number ): ICircle;

		clear(): ICircle;

		isEqual(pCircle: ICircle): bool;
		isClear(): bool;
		isValid(): bool;

		offset(v2fOffset: IVec2): ICircle;
		expand(fInc:  number ): ICircle;
		normalize(): ICircle;
	};
};



module akra.geometry{
	export class Circle implements ICircle{
		center: IVec2;
		radius:  number ;

		constructor();
		constructor(pCircle: ICircle);
		constructor(v2fCenter: IVec2, fRadius:  number );
		constructor(fCenterX:  number , fCenterY:  number , fRadius:  number );
		constructor(fCenterX?, fCenterY?, fRadius?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pCircle: ICircle = arguments[0];
					this.center = new Vec2(pCircle.center);
					this.radius = pCircle.radius;
					break;
				case 2:
					var v2fCenter: IVec2 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center = new Vec2(v2fCenter);
					this.radius = fRadius;
					break;
				case 3:
					this.center = new Vec2(arguments[0], arguments[1]);
					this.radius = arguments[2];
					break;
				default:
					this.center = new Vec2();
					this.radius = 0.;
					break;
			}
		};

		set(): ICircle;
		set(pCircle: ICircle): ICircle;
		set(v2fCenter: IVec2, fRadius:  number ): ICircle;
		set(fCenterX:  number , fCenterY:  number , fRadius:  number ): ICircle;
		set(fCenterX?, fCenterY?, fRadius?): ICircle{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pCircle: ICircle = arguments[0];
					this.center.set(pCircle.center);
					this.radius = pCircle.radius;
					break;
				case 2:
					var v2fCenter: IVec2 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center.set(v2fCenter);
					this.radius = fRadius;
					break;
				case 3:
					this.center.set(arguments[0], arguments[1]);
					this.radius = arguments[2];
					break;
				default:
					this.center.set(0.);
					this.radius = 0.;
			}

			return this;
		};

		/**@inline*/  clear(): ICircle{
			this.center.clear();
			this.radius = 0.;

			return this;
		};

		/**@inline*/  isEqual(pCircle: ICircle): bool{
			return this.center.isEqual(pCircle.center) && (this.radius == pCircle.radius);
		};

		/**@inline*/  isClear(): bool{
			return this.center.isClear() && (this.radius === 0.);
		};

		/**@inline*/  isValid(): bool{
			return (this.radius >= 0.);
		};

		/**@inline*/  offset(v2fOffset: IVec2): ICircle{
			this.center.add(v2fOffset);
			return this;
		};

		/**@inline*/  expand(fInc:  number ): ICircle{
			this.radius += fInc;
			return this;
		};

		/**@inline*/  normalize(): ICircle{
			this.radius = math.abs(this.radius);
			return this;
		};
	};
};



module akra.geometry{
	export class Rect2d implements IRect2d{
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;

		/**@inline*/  get left():  number  { return this.x0; }
		/**@inline*/  get top():  number  { return this.y0; }
		/**@inline*/  get width():  number  { return this.x1 - this.x0; }
		/**@inline*/  get height():  number  { return this.y1 - this.y0; }

		constructor();
		constructor(pRect: IRect2d);
		constructor(v2fVec: IVec2);
		constructor(fSizeX:  number , fSizeY:  number );
		constructor(fX0:  number , fX1:  number , fY0:  number , fY1:  number );
		constructor(fX0?, fX1?, fY0?, fY1?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 4:
					this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = 0.;
					break;
			}
		};

		set(): IRect2d;
		set(pRect: IRect2d): IRect2d;
		set(v2fVec: IVec2): IRect2d;
		set(fSizeX:  number , fSizeY:  number ): IRect2d;
		set(v2fMinPoint: IVec2, v2fMaxPoint: IVec2): IRect2d;
		set(fX0:  number , fX1:  number , fY0:  number , fY1:  number ): IRect2d;
		set(fX0?, fX1?, fY0?, fY1?): IRect2d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					if(arguments[0] instanceof Rect2d){
						var pRect: IRect2d = arguments[0];

						this.x0 = pRect.x0;
						this.x1 = pRect.x1;
						this.y0 = pRect.y0;
						this.y1 = pRect.y1;
					}
					else{
						var v2fSizes: IVec2 = arguments[0];

						this.x1 = v2fSizes.x*0.5;
						this.x0 = -this.x1;

						this.y1 = v2fSizes.y*0.5;
						this.y0 = -this.y1;
					}
					break;
				case 2:
					if(isNumber(arguments[0])){
						var fSizeX:  number  = arguments[0];
						var fSizeY:  number  = arguments[1];

						this.x1 = fSizeX*0.5;
						this.x0 = -this.x1;

						this.y1 = fSizeY*0.5;
						this.y0 = -this.y1;
					}
					else{
						this.x0 = arguments[0].x;
						this.y0 = arguments[0].y;

						this.x1 = arguments[1].x;
						this.y1 = arguments[1].y;
					}
					break;
				case 4:
					this.x0 = arguments[0];
					this.x1 = arguments[1];
					this.y0 = arguments[2];
					this.y1 = arguments[3];
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = 0.;
					break;
			}

			return this;
		};

		setFloor(pRect: IRect2d): IRect2d{
			this.x0 = math.floor(pRect.x0);
			this.x1 = math.floor(pRect.x1);
			this.y0 = math.floor(pRect.y0);
			this.y1 = math.floor(pRect.y1);

			return this;
		};

		setCeil(pRect: IRect2d): IRect2d{
			this.x0 = math.ceil(pRect.x0);
			this.x1 = math.ceil(pRect.x1);
			this.y0 = math.ceil(pRect.y0);
			this.y1 = math.ceil(pRect.y1);

			return this;
		};

		/**@inline*/  clear(): IRect2d{
			this.x0 = this.x1 = this.y0 = this.y1 = 0.;
			return this;
		};

		addSelf(fValue:  number ): IRect2d;
		addSelf(v2fVec: IVec2): IRect2d;
		addSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 += fValue;
				this.x1 += fValue;
				this.y0 += fValue;
				this.y1 += fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 += v2fVec.x;
				this.x1 += v2fVec.x;

				this.y0 += v2fVec.y;
				this.y1 += v2fVec.y;
			}

			return this;
		};

		subSelf(fValue:  number ): IRect2d;
		subSelf(v2fVec: IVec2): IRect2d;
		subSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 -= fValue;
				this.x1 -= fValue;
				this.y0 -= fValue;
				this.y1 -= fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 -= v2fVec.x;
				this.x1 -= v2fVec.x;

				this.y0 -= v2fVec.y;
				this.y1 -= v2fVec.y;
			}

			return this;
		};

		multSelf(fValue:  number ): IRect2d;
		multSelf(v2fVec: IVec2): IRect2d;
		multSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 *= fValue;
				this.x1 *= fValue;
				this.y0 *= fValue;
				this.y1 *= fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 *= v2fVec.x;
				this.x1 *= v2fVec.x;

				this.y0 *= v2fVec.y;
				this.y1 *= v2fVec.y;
			}

			return this;
		};

		divSelf(fValue:  number ): IRect2d;
		divSelf(v2fVec: IVec2): IRect2d;
		divSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];
				{ logger.setSourceLocation( "geometry/Rect2d.ts" , 206 ); logger.assert(fValue != 0.,"divide by zero error"); } ;

				var fInvValue:  number  = 1./fValue;

				this.x0 *= fInvValue;
				this.x1 *= fInvValue;
				this.y0 *= fInvValue;
				this.y1 *= fInvValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				{ logger.setSourceLocation( "geometry/Rect2d.ts" , 218 ); logger.assert(v2fVec.x != 0.,"divide by zero error"); } ;
				{ logger.setSourceLocation( "geometry/Rect2d.ts" , 219 ); logger.assert(v2fVec.y != 0.,"divide by zero error"); } ;

				var fInvX:  number  = 1./v2fVec.x;
				var fInvY:  number  = 1./v2fVec.y;

				this.x0 *= fInvX;
				this.x1 *= fInvX;

				this.y0 *= fInvY;
				this.y1 *= fInvY;
			}

			return this;
		};

		offset(v2fOffset: IVec2): IRect2d;
		offset(fOffsetX:  number , fOffsetY:  number ): IRect2d;
		offset(fOffsetX?, fOffsetY?): IRect2d{
			if(arguments.length === 1){
				var v2fOffset: IVec2 = arguments[0];

				this.x0 += v2fOffset.x;
				this.x1 += v2fOffset.x;

				this.y0 += v2fOffset.y;
				this.y1 += v2fOffset.y;
			}
			else{
				this.x0 += arguments[0];
				this.x1 += arguments[0];

				this.y0 += arguments[1];
				this.y1 += arguments[1];
			}

			return this;
		};

		expand(fValue:  number ): IRect2d;
		expand(v2fValue: IVec2): IRect2d;
		expand(fValueX:  number , fValueY:  number ): IRect2d;
		expand(fValueX?, fValueY?): IRect2d{
			if(arguments.length == 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					this.x0 -= fValue;
					this.x1 += fValue;

					this.y0 -= fValue;
					this.y1 += fValue;
				}
				else{
					var v2fValue: IVec2 = <IVec2>arguments[0];

					this.x0 -= v2fValue.x;
					this.x1 += v2fValue.x;

					this.y0 -= v2fValue.y;
					this.y1 += v2fValue.y;
				}
			}
			else{
//arguments.length == 2

				this.x0 -= arguments[0];
				this.x1 += arguments[0];

				this.y0 -= arguments[1];
				this.y1 += arguments[1];
			}

			return this;
		};

		expandX(fValue:  number ): IRect2d{
			this.x0 -= fValue;
			this.x1 += fValue;

			return this;
		};

		expandY(fValue:  number ): IRect2d{
			this.y0 -= fValue;
			this.y1 += fValue;

			return this;
		};

		resize(v2fSize: IVec2): IRect2d;
		resize(fSizeX:  number , fSizeY:  number ): IRect2d;
		resize(fSizeX?, fSizeY?): IRect2d{
			var fSizeX:  number , fSizeY:  number ;

			if(arguments.length == 1){
				var v2fSize: IVec2 = arguments[0];

				fSizeX = v2fSize.x;
				fSizeY = v2fSize.y;
			}
			else{
				fSizeX = arguments[0];
				fSizeY = arguments[1];
			}

			this.x1 = (this.x0 + this.x1 + fSizeX)*0.5;
			this.x0 = this.x1 - fSizeX;

			this.y1 = (this.y0 + this.y1 + fSizeY)*0.5;
			this.y0 = this.y1 - fSizeY;

			return this;
		};

		/**@inline*/  resizeX(fSize:  number ): IRect2d{
			this.x1 = (this.x0 + this.x1 + fSize)*0.5;
			this.x0 = this.x1 - fSize;

			return this;
		};

		/**@inline*/  resizeY(fSize:  number ): IRect2d{
			this.y1 = (this.y0 + this.y1 + fSize)*0.5;
			this.y0 = this.y1 - fSize;

			return this;
		};

		resizeMax(v2fSpan: IVec2): IRect2d;
		resizeMax(fSpanX:  number , fSpanY:  number ): IRect2d;
		resizeMax(fSpanX?, fSpanY?): IRect2d{
			if(arguments.length == 1){
				var v2fSpan: IVec2 = arguments[0];

				this.x1 = this.x0 + v2fSpan.x;
				this.y1 = this.y0 + v2fSpan.y;
			}
			else{
				this.x1 = this.x0 + arguments[0];
				this.y1 = this.y0 + arguments[1];
			}

			return this;
		};

		/**@inline*/  resizeMaxX(fSpan:  number ): IRect2d{
			this.x1 = this.x0 + fSpan;
			return this;
		};

		/**@inline*/  resizeMaxY(fSpan:  number ): IRect2d{
			this.y1 = this.y0 + fSpan;
			return this;
		};

		resizeMin(v2fSpan: IVec2): IRect2d;
		resizeMin(fSpanX:  number , fSpanY:  number ): IRect2d;
		resizeMin(fSpanX?, fSpanY?): IRect2d{
			if(arguments.length == 1){
				var v2fSpan: IVec2 = arguments[0];

				this.x0 = this.x1 - v2fSpan.x;
				this.y0 = this.y1 - v2fSpan.y;
			}
			else{
				this.x0 = this.x1 - arguments[0];
				this.y0 = this.y1 - arguments[1];
			}

			return this;
		};

		/**@inline*/  resizeMinX(fSpan:  number ): IRect2d{
			this.x0 = this.x1 - fSpan;
			return this;
		};

		/**@inline*/  resizeMinY(fSpan:  number ): IRect2d{
			this.y0 = this.y1 - fSpan;
			return this;
		};

		unionPoint(v2fPoint: IVec2): IRect2d;
		unionPoint(fX:  number , fY:  number ): IRect2d;
		unionPoint(): IRect2d{
			if(arguments.length === 1){
				var v2fPoint: IVec2 = arguments[0];

				this.x0 = math.min(this.x0, v2fPoint.x);
				this.x1 = math.max(this.x1, v2fPoint.x);

				this.y0 = math.min(this.y0, v2fPoint.y);
				this.y1 = math.max(this.y1, v2fPoint.y);
			}
			else{
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];

				this.x0 = math.min(this.x0, fX);
				this.x1 = math.max(this.x1, fX);

				this.y0 = math.min(this.y0, fY);
				this.y1 = math.max(this.y1, fY);
			}

			return this;
		};

		unionRect(pRect: IRect2d): IRect2d{
			this.normalize();
			pRect.normalize();

			this.x0 = math.min(this.x0, pRect.x0);
			this.x1 = math.max(this.x1, pRect.x1);

			this.y0 = math.min(this.y0, pRect.y0);
			this.y1 = math.max(this.y1, pRect.y1);

			return this;
		};

		negate(pDestination?: IRect2d): IRect2d{
			if(!isDef(pDestination)){
				pDestination = this;
			}

			return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0);
		};

		normalize(): IRect2d{
			var fTmp:  number ;
			if(this.x0 > this.x1){
				fTmp = this.x0;
				this.x0 = this.x1;
				this.x1 = fTmp;
			}
			if(this.y0 > this.y1){
				fTmp = this.y0;
				this.y0 = this.y1;
				this.y1 = fTmp;
			}
			return this;
		};

		/**@inline*/  isEqual(pRect: IRect2d): bool{
			return 	this.x0 == pRect.x0 && this.x1 == pRect.x1
					&& this.y0 == pRect.y0 && this.y1 == pRect.y1;
		};

		/**@inline*/  isClear(): bool{
			return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0.;
		};

		/**@inline*/  isValid(): bool{
			return this.x0 <= this.x1 && this.y0 <= this.y1;
		};

		/**@inline*/  isPointInRect(v2fPoint: IVec2): bool{
			var x:  number  = v2fPoint.x;
			var y:  number  = v2fPoint.y;

			return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1);
		};

		midPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = (this.x0 + this.x1)*0.5;
			v2fDestination.y = (this.y0 + this.y1)*0.5;

			return v2fDestination;
		};

		/**@inline*/  midX():  number {
			return (this.x0 + this.x1)*0.5;
		};

		/**@inline*/  midY():  number {
			return (this.y0 + this.y1)*0.5;
		};

		size(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x1 - this.x0;
			v2fDestination.y = this.y1 - this.y0;

			return v2fDestination;
		};

		/**@inline*/  sizeX():  number {
			return this.x1 - this.x0;
		};

		/**@inline*/  sizeY():  number {
			return this.y1 - this.y0;
		};

		minPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x0;
			v2fDestination.y = this.y0;

			return v2fDestination;
		};

		maxPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x1;
			v2fDestination.y = this.y1;

			return v2fDestination;
		};

		/**@inline*/  area():  number {
			return (this.x1 - this.x0)*(this.y1 - this.y0);
		};

/**
		 * counter-clockwise
		 * x0,y0 -> x1,y0 -> x1,y1 -> x0,y1;
		 */


		corner(iIndex:  number , v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			{ logger.setSourceLocation( "geometry/Rect2d.ts" , 557 ); logger.assert(0 <= iIndex && iIndex < 4, "invalid index"); } ;

			switch(iIndex){
				case 0:
					v2fDestination.set(this.x0, this.y0);
					break;
				case 1:
					v2fDestination.set(this.x1, this.y0);
					break;
				case 2:
					v2fDestination.set(this.x1, this.y1);
					break;
				case 3:
					v2fDestination.set(this.x0, this.y1);
					break;
			};
			return v2fDestination;
		};

		createBoundingCircle(pCircle?: ICircle): ICircle{
			if(!isDef(pCircle)){
				pCircle = new Circle();
			}

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;

			var fHalfSizeX:  number  = (fX1 - fX0)*0.5;
			var fHalfSizeY:  number  = (fY1 - fY0)*0.5;

			pCircle.set((fX0 + fX1)*0.5, (fY0 + fY1)*0.5,
				math.sqrt(fHalfSizeX*fHalfSizeX + fHalfSizeY*fHalfSizeY));

			return pCircle;
		};

		distanceToPoint(v2fPoint: IVec2):  number {
			var fX:  number  = v2fPoint.x, fY:  number  = v2fPoint.y;

			var fX0:  number  = this.x0, fY0:  number  = this.y0;
			var fX1:  number  = this.x1, fY1:  number  = this.y1;

			var fXN:  number , fYN:  number ;

			fXN = (math.abs(fX0 - fX) < math.abs(fX1 - fX)) ? fX0 : fX1;
			fYN = (math.abs(fY0 - fY) < math.abs(fY1 - fY)) ? fY0 : fY1;

			return math.sqrt((fXN - fX)*(fXN - fX) + (fYN - fY)*(fYN - fY));
		};

		toString(): string{
			return "(" + this.x0 + ", " + this.y0 + ") --> (" +
					this.x1 + ", " + this.y1 + ")";
		};
	};
}












module akra {
/** ObjectArray interface */

	export interface IObjectArray {
/** number of element in array */

		length:  number ;

/** lock array for writing */

		lock(): void;
/**
		 * unlock array.
		 */

		unlock(): void;
/**
		 * Is arrat can be modified?
		 */

		isLocked(): bool;

/**
		 * Remove all elements from array;
		 * @param {Bool=false} bRemoveLinks Remove old pointers to data. 
		 */

		clear(bRemoveLinks?: bool): IObjectArray;

/** Get value of <n> element. */

		value(n:  number ): any;
/** Set value for <n> element. */

		set(n:  number , data: any): IObjectArray;
/** Fill ObjectArray from any <Array> */

		fromArray(elements: any[], iOffset?:  number , iSize?:  number ): IObjectArray;
/** Push element to end of array */

		push(element: any): IObjectArray;
/** Get & remove last element in array */

		pop(): any;
/** Complitly remove all data from array */

		release(): IObjectArray;
/** Swap elements in array */

		swap(i:  number , j:  number ): IObjectArray;

		takeAt(iPos): any;
	}
}





module akra.util {
	export class ObjectArray implements IObjectArray {
		protected _pData: any[] = [];
		protected _bLock: bool = false;
		protected _iLength:  number  = 0;

		/**@inline*/  get length():  number  {
			return this._iLength;
		}

// set length(n: uint) {

// 	if (this._bLock) {
// 		return;
// 	}

// 	this.extend(n);
// 	this._iLength = n;
// }

		constructor (pElements?: any[]) {
			if (arguments.length) {
				this.fromArray(pElements);
			}
		}

		/**@inline*/  lock(): void {
			this._bLock = true;
		}

		/**@inline*/  unlock(): void {
			this._bLock = false;
		}

		/**@inline*/  isLocked(): bool {
			return this._bLock;
		}

		clear(bRemoveLinks: bool = false): IObjectArray {

			{ logger.setSourceLocation( "util/ObjectArray.ts" , 47 ); logger.assert(!this._bLock, "cannot clear. array is locked."); } ;

			this._iLength = 0;

			if (bRemoveLinks) {
				for (var i:  number  = 0; i < this._pData.length; ++ i) {
					this._pData[i] = null;
				}
			}

			return this;
		}

		release(): IObjectArray {
			this.clear(true);
			this._pData.clear();
			return this;
		}

		/**@inline*/  value(n:  number ): any {
			return this._pData[n];
		}

		private extend(n:  number ): void {
			if (this._pData.length < n) {
//LOG("extending object array to > " + n);
				for (var i:  number  = this._pData.length; i < n; ++ i) {
					this._pData[i] = null;
				}
			}
		}

		set(n:  number , pData: any): IObjectArray {
			{ logger.setSourceLocation( "util/ObjectArray.ts" , 80 ); logger.assert(!this._bLock, "cannot clear. array is locked."); } ;

			var N:  number  = n + 1;

			this.extend(N);

			if (this._iLength < N) {
				this._iLength = N;
			}

			this._pData[n] = pData;

			return this;
		}

		fromArray(pElements: any[], iOffset:  number  = 0, iSize:  number  = 0): IObjectArray {
			{ logger.setSourceLocation( "util/ObjectArray.ts" , 96 ); logger.assert(!this._bLock, "cannot clear. array is locked."); } ;

			iSize = iSize > 0? iSize < pElements.length? iSize: pElements.length: pElements.length;

			this.extend(iSize);

			for (var i:  number  = iOffset, j:  number  = 0; i < iSize; ++ i, ++ j) {
				this._pData[i] = pElements[j];
			}

			this._iLength = i;

			return this;
		}

		/**@inline*/  push(pElement: any): IObjectArray {

			{ logger.setSourceLocation( "util/ObjectArray.ts" , 113 ); logger.assert(!this._bLock, "cannot clear. array is locked."); } ;

			return this.set(this._iLength, pElement);
		}

		/**@inline*/  pop(): any {
			{ logger.setSourceLocation( "util/ObjectArray.ts" , 119 ); logger.assert(!this._bLock, "cannot clear. array is locked."); } ;
			return this._iLength > 0? this._pData[-- this._iLength]: null;
		}

		/**@inline*/  swap(i:  number , j:  number ): IObjectArray {
			{ logger.setSourceLocation( "util/ObjectArray.ts" , 124 ); logger.assert(!this._bLock, "cannot clear. array is locked."); } ;
			{ logger.setSourceLocation( "util/ObjectArray.ts" , 125 ); logger.assert(i < this._iLength && j < this._iLength, "invalid swap index."); } ;

			this._pData.swap(i, j);

			return this;
		}

		takeAt(iPos): any {
			var pValue: any = this.value(iPos);

			for (var i = iPos + 1, j = iPos; i < this.length; ++ i, ++ j) {
				this._pData[j] = this._pData[i];
			}

			this._iLength --;

			return pValue;
		}

		indexOf(pObject: any):  number  {
			for(var i:  number  = 0; i < this._iLength; i++){
				if(pObject === this._pData[i]){
					return i;
				}
			}

			return -1;
		}

	}
}

module akra {
	export var ObjectArray = util.ObjectArray;
}



//#define DL_DEFAULT DEFAULT_NAME;

module akra.render {
	export class Viewport implements IViewport {
		protected _pCamera: ICamera = null;
		protected _pTarget: IRenderTarget = null;

		protected _fRelLeft:  number ;
		protected _fRelTop:  number ;
		protected _fRelWidth:  number ;
		protected _fRelHeight:  number ;

		protected _iActLeft:  number  = 0;
		protected _iActTop:  number  = 0;
		protected _iActWidth:  number  = 1;
		protected _iActHeight:  number  = 1;

		protected _iZIndex:  number ;

		protected _pDepthRange: IDepthRange = {min: -1., max: 1.};

		protected _pViewportState: IViewportState = {
			cullingMode: ECullingMode.NONE,

			depthTest: true,
			depthWrite: true,
			depthFunction: ECompareFunction.LESS,

			clearColor: new Color(0., 0., 0., 0.),
			clearDepth: 1.,
			clearBuffers: EFrameBufferTypes.COLOR | EFrameBufferTypes.DEPTH
		};

// protected _cBackColor: IColor = new Color(Color.BLACK);

// protected _fDepthClearValue: float = 1.;

		protected _bClearEveryFrame: bool = true;

// protected _iClearBuffers: int = EFrameBufferTypes.COLOR | EFrameBufferTypes.DEPTH;

		protected _bUpdated: bool = false;

// protected _bShowOverlays: bool = true;

// protected _bShowSkies: bool = true;
// protected _bShowShadows: bool = true;

		protected _iVisibilityMask:  number  = 0xFFFFFFFF;

// protected _sRQSequenceName: string;
// protected mRQSequence: RenderQueueInvocationSequence;

		protected sMaterialSchemeName: string = DEFAULT_MATERIAL_NAME;

// static _eDefaultOrientationMode: EOrientationModes;

		protected _isAutoUpdated: bool = true;

		protected _csDefaultRenderMethod: string = null;

		protected _isDepthRangeUpdated: bool = false;

//show/hide
		protected _bHidden: bool = false;

//get last mouse postion backend
		protected _pMousePositionLast: IPoint = {x: 0, y: 0};
//is mouse under the viewport?
		protected _bMouseIsCaptured: bool = false;

//3d event handing
	    private _i3DEvents:  number  = 0;
	    private _p3DEventPickLast: IRIDPair = {object: null, renderable: null};
	    private _p3DEventDragTarget: IRIDPair = {object: null, renderable: null};

		/**@inline*/  get zIndex():  number  {
			return this._iZIndex;
		}

		/**@inline*/  get left():  number  { return this._fRelLeft; }
        /**@inline*/  get top():  number  { return this._fRelTop; }
        /**@inline*/  get width():  number  { return this._fRelWidth; }
        /**@inline*/  get height():  number  { return this._fRelHeight; }

        /**@inline*/  get actualLeft():  number  { return this._iActLeft; }
        /**@inline*/  get actualTop():  number  { return this._iActTop; }
        /**@inline*/  get actualWidth():  number  { return this._iActWidth; }
        /**@inline*/  get actualHeight():  number  { return this._iActHeight; }

        /**@inline*/  get backgroundColor(): IColor { return this._pViewportState.clearColor; }
        /**@inline*/  set backgroundColor(cColor: IColor) { this._pViewportState.clearColor.set(cColor); }

        /**@inline*/  get depthClear():  number  { return this._pViewportState.clearDepth; }
        /**@inline*/  set depthClear(fDepthClearValue:  number ) { this._pViewportState.clearDepth = fDepthClearValue; }


        /**@inline*/  get type(): EViewportTypes { return EViewportTypes.DEFAULT; }

        /**@inline*/  set onclick(fn: (pViewport: IViewport, x:  number , y:  number ) => void) {
        	this.bind( "click" , fn);
        }

        /**@inline*/  set onmousemove(fn: (pViewport: IViewport, x:  number , y:  number ) => void) {
        	this.bind( "mousemove" , fn);
        }

        /**@inline*/  set onmousedown(fn: (pViewport: IViewport, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "mousedown" , fn);
        }

        /**@inline*/  set onmouseup(fn: (pViewport: IViewport, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "mouseup" , fn);
        }

        /**@inline*/  set onmouseover(fn: (pViewport: IViewport, x:  number , y:  number ) => void) {
        	this.bind( "mouseover" , fn);
        }

        /**@inline*/  set onmouseout(fn: (pViewport: IViewport, x:  number , y:  number ) => void) {
        	this.bind( "mouseout" , fn);
        }

        /**@inline*/  set onmousewheel(fn: (pViewport: IViewport, x:  number , y:  number , fDelta:  number ) => void) {
        	this.bind( "mousewheel" , fn);
        }

        /**@inline*/  set ondragstart(fn: (pViewport: IViewport, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "dragstart" , fn);
        }

        /**@inline*/  set ondragstop(fn: (pViewport: IViewport, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "dragstop" , fn);
        }

        /**@inline*/  set ondragging(fn: (pViewport: IViewport, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "dragging" , fn);
        }

		constructor (pCamera: ICamera, csRenderMethod: string = null, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0) {
			this._fRelLeft = fLeft;
			this._fRelTop = fTop;
			this._fRelWidth = fWidth;
			this._fRelHeight = fHeight;

			this._iZIndex = iZIndex;

			this._csDefaultRenderMethod = csRenderMethod;

			this._setCamera(pCamera);
		}

		destroy(): void {
			var pRenderer: IRenderer = this._pTarget.getRenderer();
			if (pRenderer && pRenderer._getViewport() === this) {
				pRenderer._setViewport(null);
			}
		}


		clear(iBuffers:  number  = EFrameBufferTypes.COLOR | EFrameBufferTypes.DEPTH,
			  cColor: IColor = Color.BLACK, fDepth:  number  = 1., iStencil:  number  = 0): void {

			var pRenderer: IRenderer = this._pTarget.getRenderer();

			if (pRenderer) {
				var pCurrentViewport: IViewport = pRenderer._getViewport();

				if (pCurrentViewport === this) {
					pRenderer.clearFrameBuffer(iBuffers, cColor, fDepth, iStencil);
				}
				else {
					pRenderer._setViewport(this);
					pRenderer.clearFrameBuffer(iBuffers, cColor, fDepth, iStencil);
					pRenderer._setViewport(pCurrentViewport);
				}
			}
		}

		enableSupportFor3DEvent(iType:  number ):  number  {
			if (isNull(this.getTarget())) {
				return 0;
			}

			if ( (((iType) & (E3DEventTypes.DRAGSTART | E3DEventTypes.DRAGSTOP | E3DEventTypes.DRAGGING)) != 0) ) {
				((iType) |= (E3DEventTypes.DRAGSTART | E3DEventTypes.DRAGSTOP | E3DEventTypes.DRAGGING | E3DEventTypes.MOUSEDOWN | E3DEventTypes.MOUSEUP | E3DEventTypes.MOUSEMOVE))
                                                                               ;
			}

//mouse over and mouse out events require mouse move
			if ( (((iType) & (E3DEventTypes.MOUSEOVER | E3DEventTypes.MOUSEOUT)) != 0) ) {
				((iType) |= (E3DEventTypes.MOUSEMOVE)) ;
			}

//get events that have not yet been activated
			var iNotActivate:  number  = (this._i3DEvents ^ MAX_INT32) & iType;

			((this._i3DEvents) |= (iNotActivate)) ;

			this.getTarget().enableSupportFor3DEvent(iType);

			return iNotActivate;
		}

		/**@inline*/  is3DEventSupported(eType: E3DEventTypes): bool {
			return  (((this._i3DEvents) & (< number >eType)) != 0) ;
		}

        /**@inline*/  getTarget(): IRenderTarget {
        	return this._pTarget;
        }

        /**@inline*/  getCamera(): ICamera {
        	return this._pCamera;
        }

        getDepth(x:  number , y:  number ):  number  {
        	return 1.0;
        }

        getDepthRange(): IDepthRange{

        	if(!this._isDepthRangeUpdated){
	        	this._isDepthRangeUpdated = true;
	        	var pDepthRange: IDepthRange = this._getDepthRangeImpl();

	        	this._pDepthRange.min = pDepthRange.min;
	        	this._pDepthRange.max = pDepthRange.max;
        	}

        	return this._pDepthRange;
        }

        protected _getDepthRangeImpl(): IDepthRange{
        	return <IDepthRange>{min: -1, max: 1};
        }

        setCamera(pCamera: ICamera): bool {
        	if(isDefAndNotNull(pCamera)) {
				if(this._pCamera._getLastViewport() == this) {
					this._pCamera._keepLastViewport(null);
				}
			}

			this._setCamera(pCamera);
			this.viewportCameraChanged();

			return true;
        }

        protected _setCamera(pCamera: ICamera): void {
			this._pCamera = pCamera;

			if (isDefAndNotNull(pCamera)) {
// update aspect ratio of new camera if needed.
				if (!pCamera.isConstantAspect()) {
					pCamera.aspect = (< number > this._iActWidth / < number > this._iActHeight);
				}
				pCamera._keepLastViewport(this);
			}
        }

        setDimensions(fLeft:  number , fTop:  number , fWidth:  number , fHeight:  number ): bool;
        setDimensions(pRect: IRect2d): bool;
        setDimensions(fLeft?, fTop?, fWidth?, fHeight?): bool {
        	var pRect: IRect2d;
        	if (isNumber(arguments[0])) {
        		this._fRelLeft = < number >fLeft;
        		this._fRelTop = < number >fTop;
        		this._fRelWidth = < number >fWidth;
        		this._fRelHeight = < number >fHeight;
        	}
        	else {
        		pRect = <IRect2d>arguments[0];
        		this._fRelLeft = pRect.left;
        		this._fRelTop = pRect.top;
        		this._fRelWidth = pRect.width;
        		this._fRelHeight = pRect.height;
        	}

         	this._updateDimensions();

         	return true;
        }

        getActualDimensions(): IRect2d {
        	return new geometry.Rect2d(< number >this._iActLeft, < number >this._iActTop, < number >this._iActWidth, < number >this._iActHeight);
        }

        setClearEveryFrame(isClear: bool, iBuffers?:  number  = EFrameBufferTypes.COLOR | EFrameBufferTypes.DEPTH): void {
        	this._bClearEveryFrame = isClear;
			this._pViewportState.clearBuffers = iBuffers;
        }

        /**@inline*/  getClearEveryFrame(): bool {
        	return this._bClearEveryFrame;
        }

        /**@inline*/  getClearBuffers():  number  {
        	return this._pViewportState.clearBuffers;
        }

        setDepthParams(bDepthTest: bool, bDepthWrite: bool, eDepthFunction: ECompareFunction): void {
        	this._pViewportState.depthTest = bDepthTest;
        	this._pViewportState.depthWrite = bDepthWrite;
        	this._pViewportState.depthFunction = eDepthFunction;
        }

        setCullingMode(eCullingMode: ECullingMode): void {
        	this._pViewportState.cullingMode = eCullingMode;
        }

        /**@inline*/  setAutoUpdated(bValue: bool = true): void { this._isAutoUpdated = bValue; }
        /**@inline*/  isAutoUpdated(): bool { return this._isAutoUpdated; }

		_updateDimensions(bEmitEvent: bool = true): void {
			var fHeight:  number   = < number >this._pTarget.height;
			var fWidth:  number   = < number >this._pTarget.width;

			this._iActLeft = < number >math.round(this._fRelLeft * fWidth);
			this._iActTop = < number >math.round(this._fRelTop * fHeight);
			this._iActWidth = < number >math.round(this._fRelWidth * fWidth);
			this._iActHeight = < number >math.round(this._fRelHeight * fHeight);

// This will check if the cameras getAutoAspectRatio() property is set.
// If it's true its aspect ratio is fit to the current viewport
// If it's false the camera remains unchanged.
// This allows cameras to be used to render to many viewports,
// which can have their own dimensions and aspect ratios.

	        if (this._pCamera)  {
	            if (!this._pCamera.isConstantAspect())
	                this._pCamera.aspect = (< number > this._iActWidth / < number > this._iActHeight);

			}

	 		this._bUpdated = true;

	 		if (bEmitEvent) {
				this.viewportDimensionsChanged();
	 		}
		}

		hide(bValue: bool = true): void {
			if (bValue !== this._bHidden) {
				this.clear();
				this._bHidden = bValue;
			}
		}

		update(): void {
			if (this._bHidden) {
				return;
			}

			if (isDefAndNotNull(this._pCamera)) {
				this._pCamera._keepLastViewport(this);
			}

			this.startFrame();

			this._isDepthRangeUpdated = false;

			this._updateImpl();

			this.endFrame();
		}

		_updateImpl(): void {
			if (this._pCamera) {
				this.renderAsNormal(this._csDefaultRenderMethod, this._pCamera);
			}
		}

		startFrame(): void {
			if(this._bClearEveryFrame){
				this.clear(this._pViewportState.clearBuffers,
        				   this._pViewportState.clearColor,
        				   this._pViewportState.clearDepth);
			}
		}

        /**@inline*/  renderObject(pRenderable: IRenderableObject, csMethod?: string = this._csDefaultRenderMethod): void {
        	pRenderable.render(this, csMethod, null);
        }

        endFrame(): void {
        	this.getTarget().getRenderer().executeQueue(true);
        }

		protected renderAsNormal(csMethod: string, pCamera: ICamera): void {
			var pVisibleObjects: IObjectArray = pCamera.display();
			var pRenderable: IRenderableObject;

			for(var i:  number  = 0; i < pVisibleObjects.length; ++ i){
				pVisibleObjects.value(i).prepareForRender(this);
			}

			for (var i:  number  = 0; i < pVisibleObjects.length; ++ i) {
				var pSceneObject: ISceneObject = pVisibleObjects.value(i);

				for (var j:  number  = 0; j < pSceneObject.totalRenderable; j++) {
					pRenderable = pSceneObject.getRenderable(j);

					if (!isNull(pRenderable)) {
						pRenderable.render(this, csMethod, pSceneObject);
					}
				}
			}
		}

		projectPoint(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3 {
			var pCamera: ICamera = this.getCamera();
			var v3fResult: IVec3 = pCamera.projectPoint(v3fPoint, v3fDestination);

			if(isNull(v3fResult)){
				return null;
			}

			var fX:  number  = v3fResult.x;
			var fY:  number  = v3fResult.y;
			var fZ:  number  = v3fResult.z;

			fX = fX * 0.5 + 0.5;
			fY = fY * 0.5 + 0.5;
			fZ = fZ * 0.5 + 0.5;

//from top left angle of element
			fX = this.actualLeft + this.actualWidth * fX;
			fY = this.actualTop + this.actualHeight * fY;

			return v3fResult.set(fX, fY, fZ);
		};

		unprojectPoint(x:  number , y:  number , v3fDestination?: IVec3): IVec3;
		unprojectPoint(pPos: IPoint, v3fDestination?: IVec3): IVec3;
		unprojectPoint(a0, a1?, a2?): IVec3 {
			var x:  number , y:  number ;
			var v3fDestination: IVec3;

			if (isInt(arguments[0])) {
				x = arguments[0];
				y = arguments[1];
				v3fDestination = arguments[2];
			}
			else {
				x = arguments[0].x;
				y = arguments[0].y;
				v3fDestination = arguments[1];
			}

			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3;
			}

			var pCamera: ICamera = this.getCamera();
			var m4fProjection: IMat4 = pCamera.projectionMatrix;
			var m4fWorld: IMat4 = pCamera.worldMatrix;

			var v4fIn: IVec4 =  Vec4.stackCeil.set() , v4fOut: IVec4 =  Vec4.stackCeil.set() ;

//Transformation of normalized coordinates between -1 and 1
			v4fIn.x = ((x - this.actualLeft) / this.actualWidth * 2.0 - 1.0);
//Y-axis look down for viewport, but look UP in GL
			v4fIn.y = ((y - this.actualTop) / this.actualHeight * 2.0 - 1.0);
			v4fIn.z = 2.0 * this.getDepth(x, y) - 1.0;
			v4fIn.w = 1.0;

            v3fDestination.set(m4fWorld.multiplyVec4(m4fProjection.unproj(v4fIn, v4fOut)).xyz);
			return v3fDestination;
		}

		_setTarget(pTarget: IRenderTarget): void {
			if (!isNull(this._pTarget)) {
				{ logger.setSourceLocation( "Viewport.ts" , 485 ); logger.criticalError("render target already exists in this viewport"); } ;
//this.disconnect(this._pTarget, SIGNAL(resized), SLOT(_updateDimensions));
			}

			this._pTarget = pTarget;

			if (!isNull(this._pTarget)) {
				this.connect(this._pTarget,  "resized" ,  "_updateDimensions" );
				this._updateDimensions();
				this._setCamera(this._pCamera);
			}
		}

        /**@inline*/  isUpdated(): bool {
        	return this._bUpdated;
        }

        /**@inline*/  isMouseCaptured(): bool {
        	return this._bMouseIsCaptured;
        }

        /**@inline*/  _clearUpdatedFlag(): void {
        	this._bUpdated = false;
        }

        _getNumRenderedPolygons():  number  {
        	return this._pCamera? this._pCamera._getNumRenderedFaces(): 0;
        }

        /**@inline*/  _getViewportState(): IViewportState {
        	return this._pViewportState;
        }

        pick(x:  number , y:  number ): IRIDPair {
        	return {object: null, renderable: null};
        }

		getObject(x:  number , y:  number ): ISceneObject {
			return null;
		}

		getRenderable(x:  number , y:  number ): IRenderableObject {
			return null;
		}

//manual recall over/out events for objects
		touch(): void {
			this.handleMouseInout({object: null, renderable: null}, 0, 0);
		}

		protected handleMouseInout(pCurr: IRIDPair, x:  number , y:  number ): IRIDPair {
// var pCurr: IRIDPair = this.pick(x, y);
			var pPrev: IRIDPair = this._p3DEventPickLast;

			if (pCurr.object !== pPrev.object) {
				if (!isNull(pPrev.object)) {
					pPrev.object.mouseout(this, pPrev.renderable, x, y);
				}

				if (!isNull(pCurr.object)) {
					pCurr.object.mouseover(this, pCurr.renderable, x, y);
				}
			}
// var ov = false;
// var ou = false;
// var n = math.floor(Math.random() * 100500);
			if (pCurr.renderable !== pPrev.renderable) {
				if (!isNull(pPrev.renderable)) {
// ou = true;
					pPrev.renderable.mouseout(this, pPrev.object, x, y);
				}

				if (!isNull(pCurr.renderable)) {
// ov = true;
					pCurr.renderable.mouseover(this, pCurr.object, x, y);
				}
			}

// if (!ov && ou) {
// console.log("opacity enabled");
// }

			this._p3DEventPickLast = pCurr;

			return pCurr;
		}

        _keepLastMousePosition(x:  number , y:  number ): void {
        	this._pMousePositionLast.x = x;
        	this._pMousePositionLast.y = y;
        }

        /**@inline*/  _getLastMousePosition(): IPoint {
        	return this._pMousePositionLast;
        }

        protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Viewport._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;

    	viewportDimensionsChanged (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportDimensionsChanged; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
    	viewportCameraChanged (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportCameraChanged; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;

    	 render(pTechnique: IRenderTechnique, iPass:  number , pRenderable: IRenderableObject, pSceneObject: ISceneObject): void {
//is mouse under the viewport
			if (this.isMouseCaptured() &&
// ... and pass is last
				iPass === 0 &&
// ... and mouseover or mouse out events are supported
				(this.is3DEventSupported(E3DEventTypes.MOUSEOVER) || this.is3DEventSupported(E3DEventTypes.MOUSEOUT))) {
//check, if the object are loss the mouse

				var x = this._pMousePositionLast.x;
				var y = this._pMousePositionLast.y;
				this.handleMouseInout(this.pick(x, y), x, y);
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).render; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pTechnique, iPass, pRenderable, pSceneObject) : _broadcast[i].listener (_recivier, pTechnique, iPass, pRenderable, pSceneObject) ; } } ;
    	}

// BROADCAST(render, CALL(pTechnique, iPass, pRenderable, pSceneObject));

    	 click(x:  number , y:  number ): void {
			this._keepLastMousePosition(x, y);
    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).click; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;

			if (!this.is3DEventSupported(E3DEventTypes.CLICK)) {
				return;
			}

			var p = this.pick(x, y);


			p.object && p.object.click(this, p.renderable, x, y);
			p.renderable && p.renderable.click(this, p.object, x, y);
		}

		 mousemove(x:  number , y:  number ): void {
			this._keepLastMousePosition(x, y);
    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousemove; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;

			if (!this.is3DEventSupported(E3DEventTypes.MOUSEMOVE)) {
				return;
			}

			var p = this.pick(x, y);

			p.object && p.object.mousemove(this, p.renderable, x, y);
			p.renderable && p.renderable.mousemove(this, p.object, x, y);
		}

		 mousedown(eBtn: EMouseButton, x:  number , y:  number ): void {
			this._keepLastMousePosition(x, y);
    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousedown; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;

			if (!this.is3DEventSupported(E3DEventTypes.MOUSEDOWN)) {
				return;
			}

			var p = this.pick(x, y);

			p.object && p.object.mousedown(this, p.renderable, x, y);
			p.renderable && p.renderable.mousedown(this, p.object, x, y);
		}

		 mouseup(eBtn: EMouseButton, x:  number , y:  number ): void {
			this._keepLastMousePosition(x, y);
    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseup; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;

			if (!this.is3DEventSupported(E3DEventTypes.MOUSEUP)) {
				return;
			}

			var p = this.pick(x, y);

			p.object && p.object.mouseup(this, p.renderable, x, y);
			p.renderable && p.renderable.mouseup(this, p.object, x, y);
		}

    	 mouseover(x:  number , y:  number ): void {
    		this._keepLastMousePosition(x, y);
    		this._bMouseIsCaptured = true;
    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseover; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;
    	}

    	 mouseout(x:  number , y:  number ): void {
    		this._keepLastMousePosition(x, y);
    		this._bMouseIsCaptured = false;
    		this.handleMouseInout({object: null, renderable: null}, x, y);
    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseout; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;
    	}

    	 mousewheel(x:  number , y:  number , fDelta:  number ): void {
    		this._keepLastMousePosition(x, y);
    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousewheel; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y, fDelta) : _broadcast[i].listener (_recivier, x, y, fDelta) ; } } ;
    	}

    	 dragstart(eBtn: EMouseButton, x:  number , y:  number ): void {
    		this._keepLastMousePosition(x, y);

    		if (!this.is3DEventSupported(E3DEventTypes.DRAGSTART)) {
				return;
			}

			var p = this.pick(x, y);

			this._p3DEventDragTarget.object = p.object;
			this._p3DEventDragTarget.renderable = p.renderable;

			p.object && p.object.dragstart(this, p.renderable, x, y);
			p.renderable && p.renderable.dragstart(this, p.object, x, y);

    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragstart; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, eBtn, x, y) : _broadcast[i].listener (_recivier, eBtn, x, y) ; } } ;
    	}

    	 dragstop(eBtn: EMouseButton, x:  number , y:  number ): void {
    		this._keepLastMousePosition(x, y);

    		if (!this.is3DEventSupported(E3DEventTypes.DRAGSTOP)) {
				return;
			}

			var p = this._p3DEventDragTarget;

			p.object && p.object.dragstop(this, p.renderable, x, y);
			p.renderable && p.renderable.dragstop(this, p.object, x, y);

    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragstop; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, eBtn, x, y) : _broadcast[i].listener (_recivier, eBtn, x, y) ; } } ;
    	}

    	 dragging(eBtn: EMouseButton, x:  number , y:  number ): void {
    		this._keepLastMousePosition(x, y);

    		if (!this.is3DEventSupported(E3DEventTypes.DRAGGING)) {
				return;
			}

			var p = this._p3DEventDragTarget;

			p.object && p.object.dragging(this, p.renderable, x, y);
			p.renderable && p.renderable.dragging(this, p.object, x, y);

    		this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragging; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, eBtn, x, y) : _broadcast[i].listener (_recivier, eBtn, x, y) ; } } ;
    	}
	}
}




























module akra {
	;

	export interface IDSViewport extends IViewport {
		 effect: IEffect;
		 depth: ITexture;
		 view: IRenderableObject;

		getSkybox(): ITexture;
		setSkybox(pSkyTexture: ITexture): void;

		setFXAA(bValue?: bool): void;
		isFXAA(): bool;

		highlight(iRid:  number ): void;
		highlight(pObject: ISceneObject, pRenderable?: IRenderableObject): void;
		highlight(pPair: IRIDPair): void;

		_getRenderId(x:  number , y:  number ):  number ;
		_getDeferredTexValue(iTex:  number , x:  number , y:  number ): IColor;

		 addedSkybox(pSkyTexture: ITexture): void;
	}
}















module akra {


	export interface IShaderInput {
		uniforms: {[index:  number ]: any;};
		attrs: {[index:  number ]: any;};
		renderStates: IRenderStateMap;
	}
}





















module akra.render {
	export function createRenderStateMap(): IRenderStateMap {
		var pMap: IRenderStateMap = <IRenderStateMap>{};

		pMap[ ERenderStates .BLENDENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .CULLFACEENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ZENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ZWRITEENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .DITHERENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .SCISSORTESTENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .STENCILTESTENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .POLYGONOFFSETFILLENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .CULLFACE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .FRONTFACE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .SRCBLEND] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .DESTBLEND] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ZFUNC] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ALPHABLENDENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ALPHATESTENABLE] =  ERenderStateValues .UNDEF;

		return pMap;
	}

	export function copyRenderStateMap(pFrom: IRenderStateMap, pTo: IRenderStateMap): void {
		if(isNull(pFrom)){
			return;
		}
		pTo[ ERenderStates .BLENDENABLE] = pFrom[ ERenderStates .BLENDENABLE] || pTo[ ERenderStates .BLENDENABLE];
		pTo[ ERenderStates .CULLFACEENABLE] = pFrom[ ERenderStates .CULLFACEENABLE] || pTo[ ERenderStates .CULLFACEENABLE];
		pTo[ ERenderStates .ZENABLE] = pFrom[ ERenderStates .ZENABLE] || pTo[ ERenderStates .ZENABLE];
		pTo[ ERenderStates .ZWRITEENABLE] = pFrom[ ERenderStates .ZWRITEENABLE] || pTo[ ERenderStates .ZWRITEENABLE];
		pTo[ ERenderStates .DITHERENABLE] = pFrom[ ERenderStates .DITHERENABLE] || pTo[ ERenderStates .DITHERENABLE];
		pTo[ ERenderStates .SCISSORTESTENABLE] = pFrom[ ERenderStates .SCISSORTESTENABLE] || pTo[ ERenderStates .SCISSORTESTENABLE];
		pTo[ ERenderStates .STENCILTESTENABLE] = pFrom[ ERenderStates .STENCILTESTENABLE] || pTo[ ERenderStates .STENCILTESTENABLE];
		pTo[ ERenderStates .POLYGONOFFSETFILLENABLE] = pFrom[ ERenderStates .POLYGONOFFSETFILLENABLE] || pTo[ ERenderStates .POLYGONOFFSETFILLENABLE];
		pTo[ ERenderStates .CULLFACE] = pFrom[ ERenderStates .CULLFACE] || pTo[ ERenderStates .CULLFACE];
		pTo[ ERenderStates .FRONTFACE] = pFrom[ ERenderStates .FRONTFACE] || pTo[ ERenderStates .FRONTFACE];
		pTo[ ERenderStates .SRCBLEND] = pFrom[ ERenderStates .SRCBLEND] || pTo[ ERenderStates .SRCBLEND];
		pTo[ ERenderStates .DESTBLEND] = pFrom[ ERenderStates .DESTBLEND] || pTo[ ERenderStates .DESTBLEND];
		pTo[ ERenderStates .ZFUNC] = pFrom[ ERenderStates .ZFUNC] || pTo[ ERenderStates .ZFUNC];
		pTo[ ERenderStates .ALPHABLENDENABLE] = pFrom[ ERenderStates .ALPHABLENDENABLE] || pTo[ ERenderStates .ALPHABLENDENABLE];
		pTo[ ERenderStates .ALPHATESTENABLE] = pFrom[ ERenderStates .ALPHATESTENABLE] || pTo[ ERenderStates .ALPHATESTENABLE];
	}

	export function mergeRenderStateMap(pFromA: IRenderStateMap, pFromB: IRenderStateMap, pTo: IRenderStateMap): void {
		if(isNull(pFromA) || isNull(pFromB)){
			return;
		}
		pTo[ ERenderStates .BLENDENABLE] = pFromA[ ERenderStates .BLENDENABLE] || pFromB[ ERenderStates .BLENDENABLE];
		pTo[ ERenderStates .CULLFACEENABLE] = pFromA[ ERenderStates .CULLFACEENABLE] || pFromB[ ERenderStates .CULLFACEENABLE];
		pTo[ ERenderStates .ZENABLE] = pFromA[ ERenderStates .ZENABLE] || pFromB[ ERenderStates .ZENABLE];
		pTo[ ERenderStates .ZWRITEENABLE] = pFromA[ ERenderStates .ZWRITEENABLE] || pFromB[ ERenderStates .ZWRITEENABLE];
		pTo[ ERenderStates .DITHERENABLE] = pFromA[ ERenderStates .DITHERENABLE] || pFromB[ ERenderStates .DITHERENABLE];
		pTo[ ERenderStates .SCISSORTESTENABLE] = pFromA[ ERenderStates .SCISSORTESTENABLE] || pFromB[ ERenderStates .SCISSORTESTENABLE];
		pTo[ ERenderStates .STENCILTESTENABLE] = pFromA[ ERenderStates .STENCILTESTENABLE] || pFromB[ ERenderStates .STENCILTESTENABLE];
		pTo[ ERenderStates .POLYGONOFFSETFILLENABLE] = pFromA[ ERenderStates .POLYGONOFFSETFILLENABLE] || pFromB[ ERenderStates .POLYGONOFFSETFILLENABLE];
		pTo[ ERenderStates .CULLFACE] = pFromA[ ERenderStates .CULLFACE] || pFromB[ ERenderStates .CULLFACE];
		pTo[ ERenderStates .FRONTFACE] = pFromA[ ERenderStates .FRONTFACE] || pFromB[ ERenderStates .FRONTFACE];
		pTo[ ERenderStates .SRCBLEND] = pFromA[ ERenderStates .SRCBLEND] || pFromB[ ERenderStates .SRCBLEND];
		pTo[ ERenderStates .DESTBLEND] = pFromA[ ERenderStates .DESTBLEND] || pFromB[ ERenderStates .DESTBLEND];
		pTo[ ERenderStates .ZFUNC] = pFromA[ ERenderStates .ZFUNC] || pFromB[ ERenderStates .ZFUNC];
		pTo[ ERenderStates .ALPHABLENDENABLE] = pFromA[ ERenderStates .ALPHABLENDENABLE] || pFromB[ ERenderStates .ALPHABLENDENABLE];
		pTo[ ERenderStates .ALPHATESTENABLE] = pFromA[ ERenderStates .ALPHATESTENABLE] || pFromB[ ERenderStates .ALPHATESTENABLE];
	}

	export function clearRenderStateMap(pMap: IRenderStateMap): void {
		pMap[ ERenderStates .BLENDENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .CULLFACEENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ZENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ZWRITEENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .DITHERENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .SCISSORTESTENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .STENCILTESTENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .POLYGONOFFSETFILLENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .CULLFACE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .FRONTFACE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .SRCBLEND] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .DESTBLEND] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ZFUNC] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ALPHABLENDENABLE] =  ERenderStateValues .UNDEF;
		pMap[ ERenderStates .ALPHATESTENABLE] =  ERenderStateValues .UNDEF;
	}

}




//#define FAST_SET_SAMPLER_TEXTURE(sName, pTexture) if(this.hasUniform(sName)) this.samplers[sName].texture = pTexture;

module akra.fx {

	export  /**@inline*/  function createSamplerState(): IAFXSamplerState {
		return <IAFXSamplerState>{
			textureName: "",
			texture: null,
			wrap_s: ETextureWrapModes.UNDEF,
			wrap_t: ETextureWrapModes.UNDEF,
			mag_filter: ETextureFilters.UNDEF,
			min_filter: ETextureFilters.UNDEF
/*wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,
			wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,
			mag_filter: ETextureFilters.LINEAR,
			min_filter: ETextureFilters.LINEAR*/

		};
	}

    export interface IAFXShaderVarTypeMap {
//[index: string]: EAFXShaderVariableType;
		[index:  number ]: EAFXShaderVariableType;
	}

	export class PassInputBlend implements IAFXPassInputBlend {
		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; }
		protected _pCreator: IAFXComponentPassInputBlend = null;

// private _bNeedToCalcBlend: bool = true;
// private _bNeedToCalcShader: bool = true;

		private _iLastPassBlendId:  number  = 0;
		private _iLastShaderId:  number  = 0;

		private _pMaterialContainer: any = {
			"DIFFUSE" 	: new Vec4(),
			"AMBIENT" 	: new Vec4(),
			"SPECULAR" 	: new Vec4(),
			"EMISSIVE" 	: new Vec4(),
			"SHININESS" : 1.
		};

//need for accelerate setSurfaceMaterial
		private _nLastSufraceMaterialTextureUpdates:  number  = 0;
		private _nLastSamplerUpdates:  number  = 0;
		private _pLastSurfaceMaterial: ISurfaceMaterial = null;

		private _isFirstSetSurfaceNaterial: bool = true;
		private _pMaterialNameIndices: any = {
			diffuse: 0,
			ambient: 0,
			specular: 0,
			emissive: 0,
			normal: 0,
			material: 0,
			textures: new Array(16)
		};

		private _pStatesInfo: IAFXPassInputStateInfo = null;

		samplers: IAFXSamplerStateMap = null;
		samplerArrays: IAFXSamplerStateListMap = null;
		samplerArrayLength: IntMap = null;

		uniforms: any = null;
		foreigns: any = null;
		textures: any = null;

		samplerKeys:  number [] = null;
		samplerArrayKeys:  number [] = null;

		uniformKeys:  number [] = null;
		foreignKeys:  number [] = null;
		textureKeys:  number [] = null;

		renderStates: IRenderStateMap = null;

		/**@inline*/  get statesInfo(): IAFXPassInputStateInfo {
			return  this._pStatesInfo;
		}

		constructor(pCreator: IAFXComponentPassInputBlend){
			this._pCreator = pCreator;

			this._pStatesInfo = <IAFXPassInputStateInfo>{
				uniformKey: 0,
				foreignKey: 0,
				samplerKey: 0,
				renderStatesKey: 0
			};

			this.init();
		}

		hasUniform(sName: string): bool {
			return this._pCreator.uniforms.hasVariableWithRealName(sName);
		}

		hasTexture(sName: string): bool {
			return this._pCreator.textures.hasVariableWithRealName(sName);
		}

		hasForeign(sName: string): bool {
			return this._pCreator.foreigns.hasVariableWithRealName(sName);
		}

		setUniform(sName: string, pValue: any): void {
			var iIndex:  number  = this._pCreator.uniforms.getIndexByRealName(sName);

			if(iIndex === 0){
				return;
			}

			var pInfo: IAFXVariableInfo = this._pCreator.uniforms.getVarInfoByIndex(iIndex);

			if (pInfo.type === EAFXShaderVariableType.k_Sampler2D ||
				pInfo.type === EAFXShaderVariableType.k_SamplerCUBE) {

				if (pInfo.isArray) {
					if(isNull(pValue)){
						this.samplerArrayLength[iIndex] = 0;
					}
					else {
						for (var i:  number  = 0; i < pValue.length; i++) {
							this.copySamplerState(pValue[i], this.samplerArrays[iIndex][i]);
						}

						this.samplerArrayLength[iIndex] = pValue.length;
					}
				}
				else {
					this.copySamplerState(pValue, this.samplers[iIndex]);
				}

				return;
			}

//Check type

			this._pStatesInfo.uniformKey++;
			this.uniforms[iIndex] = pValue;
		}

		setTexture(sName: string, pValue: any): void {
			var iIndex:  number  = this._pCreator.textures.getIndexByRealName(sName);

			if(iIndex === 0){
				return;
			}

//Check type

			if(this.textures[iIndex] !== pValue){
				this._pStatesInfo.samplerKey++;
			}

			this.textures[iIndex] = pValue;
		}

		setForeign(sName: string, pValue: any): void {
			var iIndex:  number  = this._pCreator.foreigns.getIndexByRealName(sName);

			if(iIndex === 0){
				return;
			}

//Check type

			var pOldValue: any = this.foreigns[iIndex];

			if(pOldValue !== pValue) {
// this._bNeedToCalcBlend = true;
// this._bNeedToCalcShader = true;
				this._pStatesInfo.foreignKey++;
			}

			this.foreigns[iIndex] = pValue;
		}

		setSampler(sName: string, pValue: IAFXSamplerState): void {
			var iIndex:  number  = this._pCreator.uniforms.getIndexByRealName(sName);

			if(iIndex === 0){
				return;
			}

			var eType: EAFXShaderVariableType = this._pCreator.uniforms.getTypeByIndex(iIndex);

			if (eType !== EAFXShaderVariableType.k_Sampler2D &&
				eType !== EAFXShaderVariableType.k_SamplerCUBE) {

				return;
			}

			this.copySamplerState(pValue, this.samplers[iIndex]);
		}

		setSamplerArray(sName: string, pValue: IAFXSamplerState[]): void {
			var iIndex:  number  = this._pCreator.uniforms.getIndexByRealName(sName);

			if(iIndex === 0){
				return;
			}

			var eType: EAFXShaderVariableType = this._pCreator.uniforms.getTypeByIndex(iIndex);

			if (eType !== EAFXShaderVariableType.k_Sampler2D &&
				eType !== EAFXShaderVariableType.k_SamplerCUBE) {

				return;
			}

			if(!isNull(pValue)){
				for (var i:  number  = 0; i < pValue.length; i++) {
					this.copySamplerState(pValue[i], this.samplerArrays[iIndex][i]);
				}

				this.samplerArrayLength[iIndex] = pValue.length;
			}
			else {
				this.samplerArrayLength[iIndex] = 0;
			}
		}

		setSamplerTexture(sName: string, sTexture: string): void;
		setSamplerTexture(sName: string, pTexture: ITexture): void;
		setSamplerTexture(sName: string, pTexture: any): void {
			var iIndex:  number  = this._pCreator.uniforms.getIndexByRealName(sName);

			if(iIndex === 0){
				return;
			}

			var eType: EAFXShaderVariableType = this._pCreator.uniforms.getTypeByIndex(iIndex);

			if (eType !== EAFXShaderVariableType.k_Sampler2D &&
				eType !== EAFXShaderVariableType.k_SamplerCUBE){

				return;
			}
			var pState: IAFXSamplerState = this.samplers[iIndex];

			if(isString(pTexture)){
				if (!isNull(pState.texture) || pState.textureName !== pTexture){
					this._pStatesInfo.samplerKey++;
				}

				pState.textureName = pTexture;
				pState.texture = null;
			}
			else {
				if(pState.texture !== pTexture){
					this._pStatesInfo.samplerKey++;
				}

				pState.texture = pTexture;
			}
		}

		_setSamplerTextureObject(sName: string, pTexture: ITexture):void {
			var iIndex:  number  = this._pCreator.uniforms.getIndexByRealName(sName);

			if(iIndex === 0){
				return;
			}

			var eType: EAFXShaderVariableType = this._pCreator.uniforms.getTypeByIndex(iIndex);

			if (eType !== EAFXShaderVariableType.k_Sampler2D &&
				eType !== EAFXShaderVariableType.k_SamplerCUBE){

				return;
			}

			var pState: IAFXSamplerState = this.samplers[iIndex];

			if(pState.texture !== pTexture){
				this._pStatesInfo.samplerKey++;
			}

			pState.texture = pTexture;
		}

		/**@inline*/  setStruct(sName: string, pValue: any): void {
			this.setUniform(sName, pValue);
		}

		setSurfaceMaterial(pSurfaceMaterial: ISurfaceMaterial): void {
			if(isNull(pSurfaceMaterial)){
				return;
			}

			if(this._isFirstSetSurfaceNaterial){
				for (var i:  number  = 0; i < 16; i++) {
				 	if(this.hasTexture("TEXTURE" + i.toString())){
				 		this._pMaterialNameIndices.textures[i] = this._pCreator.textures.getIndexByRealName("TEXTURE" + i.toString());
					}
					else {
						this._pMaterialNameIndices.textures[i] = 0;
					}
				}

				this._pMaterialNameIndices.material = this.hasUniform("MATERIAL") ?
														this._pCreator.uniforms.getIndexByRealName("MATERIAL") : 0;

				this._pMaterialNameIndices.diffuse = this.hasUniform("S_DIFFUSE") ?
														this._pCreator.uniforms.getIndexByRealName("S_DIFFUSE") : 0;
				this._pMaterialNameIndices.ambient = this.hasUniform("S_AMBIENT") ?
														this._pCreator.uniforms.getIndexByRealName("S_AMBIENT") : 0;
				this._pMaterialNameIndices.specular = this.hasUniform("S_SPECULAR") ?
														this._pCreator.uniforms.getIndexByRealName("S_SPECULAR") : 0;
				this._pMaterialNameIndices.emissive = this.hasUniform("S_EMISSIVE") ?
														this._pCreator.uniforms.getIndexByRealName("S_EMISSIVE") : 0;
				this._pMaterialNameIndices.normal = this.hasUniform("S_NORMAL") ?
														this._pCreator.uniforms.getIndexByRealName("S_NORMAL") : 0;

				this._isFirstSetSurfaceNaterial = false;
			}

			if (this._nLastSamplerUpdates !== this._pStatesInfo.samplerKey ||
				this._pLastSurfaceMaterial !== pSurfaceMaterial ||
				this._nLastSufraceMaterialTextureUpdates !== pSurfaceMaterial.totalUpdatesOfTextures){

				var iTotalTextures:  number  = pSurfaceMaterial.totalTextures;
				for (var i:  number  = 0; i < 16; i++) {
				 	if(this._pMaterialNameIndices.textures[i] > 0){
				 		this.textures[this._pMaterialNameIndices.textures[i]] =  pSurfaceMaterial.texture(i) || null;
				 	}
				}
			}

			if(this._pMaterialNameIndices.material > 0) {
				var pMaterial: IMaterial = pSurfaceMaterial.material;
				var pMatContainer: any = this._pMaterialContainer;

				pMatContainer.DIFFUSE.set(pMaterial.diffuse.r, pMaterial.diffuse.g, pMaterial.diffuse.b, pMaterial.diffuse.a);
				pMatContainer.AMBIENT.set(pMaterial.ambient.r, pMaterial.ambient.g, pMaterial.ambient.b, pMaterial.ambient.a);
				pMatContainer.SPECULAR.set(pMaterial.specular.r, pMaterial.specular.g, pMaterial.specular.b, pMaterial.specular.a);
				pMatContainer.EMISSIVE.set(pMaterial.emissive.r, pMaterial.emissive.g, pMaterial.emissive.b, pMaterial.emissive.a);
				pMatContainer.SHININESS = pMaterial.shininess;

				this.uniforms[this._pMaterialNameIndices.material] = pMatContainer;
			}

// if (this._nLastSamplerUpdates !== this._pStatesInfo.samplerKey){
				this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.diffuse, pSurfaceMaterial.texture(ESurfaceMaterialTextures.DIFFUSE) || null);
				this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.ambient, pSurfaceMaterial.texture(ESurfaceMaterialTextures.AMBIENT) || null);
				this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.specular, pSurfaceMaterial.texture(ESurfaceMaterialTextures.SPECULAR) || null);
				this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.emissive, pSurfaceMaterial.texture(ESurfaceMaterialTextures.EMISSIVE) || null);
				this._setSamplerTextureObjectByIndex(this._pMaterialNameIndices.normal, pSurfaceMaterial.texture(ESurfaceMaterialTextures.NORMAL) || null);
// }

			this._pLastSurfaceMaterial = pSurfaceMaterial;
			this._nLastSufraceMaterialTextureUpdates = pSurfaceMaterial.totalUpdatesOfTextures;
			this._nLastSamplerUpdates = this._pStatesInfo.samplerKey;
		}

		/**@inline*/  setRenderState(eState: ERenderStates, eValue: ERenderStateValues): void {
			if(this.renderStates[eState] !== eValue){
				this._pStatesInfo.renderStatesKey++;
			}

			this.renderStates[eState] = eValue;
		}

		/**@inline*/  _getForeignVarNameIndex(sName: string):  number  {
			return this._pCreator.foreigns.getIndexByRealName(sName);
		}

		/**@inline*/  _getForeignVarNameByIndex(iNameIndex:  number ): string {
			return this._pCreator.foreigns.getVarInfoByIndex(iNameIndex).realName;
		}

		/**@inline*/  _getUniformVarNameIndex(sName: string):  number  {
			return this._pCreator.uniforms.getIndexByRealName(sName);
		}

		/**@inline*/  _getUniformVar(iNameIndex:  number ): IAFXVariableDeclInstruction {
			return this._pCreator.uniforms.getVarByIndex(iNameIndex);
		}

		/**@inline*/  _getUniformVarNameByIndex(iNameIndex:  number ): string {
			return this._pCreator.uniforms.getVarInfoByIndex(iNameIndex).realName;
		}

		/**@inline*/  _getUniformLength(iNameIndex:  number ):  number  {
			return this._pCreator.uniforms.getVarByIndex(iNameIndex).getType().getLength();
		}

		/**@inline*/  _getUniformType(iNameIndex:  number ): EAFXShaderVariableType {
			return this._pCreator.uniforms.getTypeByIndex(iNameIndex);
		}

		/**@inline*/  _getSamplerState(iNameIndex:  number ): IAFXSamplerState {
			return this.samplers[iNameIndex];
		}

		/**@inline*/  _getSamplerTexture(iNameIndex:  number ): ITexture {
			return this._getTextureForSamplerState(this._getSamplerState(iNameIndex));
		}

		_getTextureForSamplerState(pSamplerState: IAFXSamplerState): ITexture {
			var pTexture: ITexture = null;

			if(!isNull(pSamplerState.texture)){
				pTexture = pSamplerState.texture;
			}
			else if(pSamplerState.textureName !== ""){
				if(this.hasTexture(pSamplerState.textureName)){
					pTexture = this.textures[this._pCreator.textures.getIndexByRealName(pSamplerState.textureName)];
				}
			}

			return pTexture;
		}

		_release(): void {
			for(var i:  number  = 0; i < this.uniformKeys.length; i++){
				var pInfo: IAFXVariableInfo = this._pCreator.uniforms.getVarInfoByIndex(this.uniformKeys[i]);
				var pDefaultValue: any = pInfo.variable.getDefaultValue();

				this.uniforms[this.uniformKeys[i]] = pDefaultValue;
			}

			for(var i:  number  = 0; i < this.foreignKeys.length; i++){
				this.foreigns[this.foreignKeys[i]] = null;
			}

			for(var i:  number  = 0; i < this.textureKeys.length; i++){
				this.textures[this.textureKeys[i]] = null;
			}

			for(var i:  number  = 0; i < this.samplerKeys.length; i++){
				var pInfo: IAFXVariableInfo = this._pCreator.uniforms.getVarInfoByIndex(this.samplerKeys[i]);
				var pDefaultState: IAFXSamplerState = pInfo.variable.getDefaultValue();
				var pSamplerState: IAFXSamplerState = this.samplers[this.samplerKeys[i]];

				this.clearSamplerState(pSamplerState);

				if(!isNull(pDefaultState)){
					pSamplerState.textureName = pDefaultState.textureName;
					pSamplerState.wrap_s = pDefaultState.wrap_s || pSamplerState.wrap_s;
					pSamplerState.wrap_t = pDefaultState.wrap_t || pSamplerState.wrap_t;
					pSamplerState.mag_filter = pDefaultState.mag_filter || pSamplerState.mag_filter;
					pSamplerState.min_filter = pDefaultState.min_filter || pSamplerState.min_filter;
				}
			}

			for(var i:  number  = 0; i < this.samplerArrayKeys.length; i++){
				var pInfo: IAFXVariableInfo = this._pCreator.uniforms.getVarInfoByIndex(this.samplerArrayKeys[i]);
				var pDefaultStateList: IAFXSamplerState[] = pInfo.variable.getDefaultValue();
				var pStateList: IAFXSamplerState[] = this.samplerArrays[this.samplerArrayKeys[i]];

				for(var j:  number  = 0; j < pStateList.length; j++){
					this.clearSamplerState(pStateList[j]);

					if(!isNull(pDefaultStateList) && i < pDefaultStateList.length){
						pStateList[j].textureName = pDefaultStateList[j].textureName;
						pStateList[j].wrap_s = pDefaultStateList[j].wrap_s || pStateList[j].wrap_s;
						pStateList[j].wrap_t = pDefaultStateList[j].wrap_t || pStateList[j].wrap_t;
						pStateList[j].mag_filter = pDefaultStateList[j].mag_filter || pStateList[j].mag_filter;
						pStateList[j].min_filter = pDefaultStateList[j].min_filter || pStateList[j].min_filter;
					}
				}

				this.samplerArrayLength[this.samplerArrayKeys[i]] = !isNull(pDefaultStateList) ? pDefaultStateList.length : 0;
			}

			render.clearRenderStateMap(this.renderStates);

			this._pCreator.releasePassInput(this);

// this._bNeedToCalcShader = true;
// this._bNeedToCalcBlend = true;
		}

		/**@inline*/  _isFromSameBlend(pInput: IAFXPassInputBlend): bool{
			return (pInput._getBlend() === this._getBlend());
		}

		/**@inline*/  _getBlend(): IAFXComponentPassInputBlend {
			return this._pCreator;
		}

		_copyFrom(pInput: IAFXPassInputBlend): void {
			this._copyUniformsFromInput(pInput);
			this._copyForeignsFromInput(pInput);
			this._copySamplersFromInput(pInput);
			this._copyRenderStatesFromInput(pInput);
		}

		_copyUniformsFromInput(pInput: IAFXPassInputBlend): void {
			for(var i:  number  = 0; i < pInput.uniformKeys.length; i++){
				var iIndex:  number  = pInput.uniformKeys[i];

				if(isDef(this.uniforms[iIndex])){
					this.uniforms[iIndex] = pInput.uniforms[iIndex];
				}
			}
		}

		_copySamplersFromInput(pInput: IAFXPassInputBlend): void {
			for(var i:  number  = 0; i < pInput.textureKeys.length; i++){
				var iIndex:  number  = pInput.textureKeys[i];

				if(isDef(this.textures[iIndex])){
					this.textures[iIndex] = pInput.textures[iIndex];
				}
			}

			for(var i:  number  = 0; i < pInput.samplerKeys.length; i++){
				var iIndex:  number  = pInput.samplerKeys[i];

				if(isDef(this.samplers[iIndex])){
					this.copySamplerState(pInput.samplers[iIndex], this.samplers[iIndex]);
				}
			}

			for(var i:  number  = 0; i < pInput.samplerArrayKeys.length; i++){
				var iIndex:  number  = pInput.samplerArrayKeys[i];

				if(isDef(this.samplerArrays[iIndex])){
					var pFrom: IAFXSamplerState[] = pInput.samplerArrays[iIndex];
					var pTo: IAFXSamplerState[] = this.samplerArrays[iIndex];
					var iLength:  number  = pInput.samplerArrayLength[iIndex];

					for(var j:  number  = 0; j < iLength; j++){
						this.copySamplerState(pFrom[j], pTo[j]);
					}

					this.samplerArrayLength[iIndex] = iLength;
				}
			}
		}

		_copyForeignsFromInput(pInput: IAFXPassInputBlend): void {
			for(var i:  number  = 0; i < pInput.foreignKeys.length; i++){
				var iIndex:  number  = pInput.foreignKeys[i];

				if(isDef(this.foreigns[iIndex])){
					this.foreigns[iIndex] = pInput.foreigns[iIndex];
				}
			}
		}

		_copyRenderStatesFromInput(pInput: IAFXPassInputBlend): void {
			render.copyRenderStateMap(pInput.renderStates, this.renderStates);
		}

		/**@inline*/  _getLastPassBlendId():  number  {
			return this._iLastPassBlendId;
		}

		/**@inline*/  _getLastShaderId():  number  {
			return this._iLastShaderId;
		}

		/**@inline*/  _setPassBlendId(id:  number ): void {
			this._iLastPassBlendId = id;
		}

		/**@inline*/  _setShaderId(id:  number ): void {
			this._iLastShaderId = id;
		}

		private init(): void {
			this.samplers = <IAFXSamplerStateMap>{};
			this.samplerArrays = <IAFXSamplerStateListMap>{};
			this.samplerArrayLength = <IntMap>{};

			this.uniforms = <any>{};
			this.foreigns = <any>{};
			this.textures = <any>{};

			this.renderStates = render.createRenderStateMap();

			var pUniformKeys:  number [] = this._pCreator.uniforms.indices;
			var pForeignKeys:  number [] = this._pCreator.foreigns.indices;
			var pTextureKeys:  number [] = this._pCreator.textures.indices;

			var eType: EAFXShaderVariableType = 0;
			var sName: string = "";
			var iIndex:  number  = 0;

			for(var i:  number  = 0; i < pUniformKeys.length; i++){
				var iIndex:  number  = pUniformKeys[i];
				var pInfo: IAFXVariableInfo = this._pCreator.uniforms.getVarInfoByIndex(iIndex);
				var pDefaultValue: any = pInfo.variable.getDefaultValue();

				if (pInfo.type === EAFXShaderVariableType.k_Sampler2D ||
					pInfo.type === EAFXShaderVariableType.k_SamplerCUBE){

					var hasDefaultValue: bool = !isNull(pDefaultValue);

					if(pInfo.isArray){
						if(hasDefaultValue){
							this.samplerArrays[iIndex] = new Array(pDefaultValue.length);
							this.samplerArrayLength[iIndex] = this.samplerArrays[iIndex].length;
						}
						else {
							this.samplerArrays[iIndex] = new Array(16);
							this.samplerArrayLength[iIndex] = 0;
						}


						for(var j:  number  = 0; j < this.samplerArrays[iIndex].length; j++) {
							var pNewState: IAFXSamplerState = createSamplerState();

							if(hasDefaultValue){
								var pDefaultState: IAFXSamplerState = pDefaultValue[j];
								pNewState.textureName = pDefaultState.textureName;
								pNewState.wrap_s = pDefaultState.wrap_s || pNewState.wrap_s;
								pNewState.wrap_t = pDefaultState.wrap_t || pNewState.wrap_t;
								pNewState.mag_filter = pDefaultState.mag_filter || pNewState.mag_filter;
								pNewState.min_filter = pDefaultState.min_filter || pNewState.min_filter;
							}

							this.samplerArrays[iIndex][j] = pNewState;
						}

					}
					else {
						var pNewState: IAFXSamplerState = createSamplerState();

						if(hasDefaultValue){
							var pDefaultState: IAFXSamplerState = pDefaultValue;
							pNewState.textureName = pDefaultState.textureName;
							pNewState.wrap_s = pDefaultState.wrap_s || pNewState.wrap_s;
							pNewState.wrap_t = pDefaultState.wrap_t || pNewState.wrap_t;
							pNewState.mag_filter = pDefaultState.mag_filter || pNewState.mag_filter;
							pNewState.min_filter = pDefaultState.min_filter || pNewState.min_filter;
						}

						this.samplers[iIndex] = pNewState;
					}
				}
				else {
					this.uniforms[iIndex] = pDefaultValue;
				}
			}

			for(var i:  number  = 0; i < pForeignKeys.length; i++){
				var iIndex:  number  = pForeignKeys[i];

				this.foreigns[iIndex] = null;
			}

			for(var i:  number  = 0; i < pTextureKeys.length; i++){
				var iIndex:  number  = pTextureKeys[i];
				this.textures[iIndex] = null;
			}

			this.samplerKeys = <any[]>Object.keys(this.samplers);
			for(var i:  number  = 0; i < this.samplerKeys.length; i++){
				this.samplerKeys[i] = +this.samplerKeys[i];
			}

			this.samplerArrayKeys = <any[]>Object.keys(this.samplerArrays);
			for(var i:  number  = 0; i < this.samplerArrayKeys.length; i++){
				this.samplerArrayKeys[i] = +this.samplerArrayKeys[i];
			}

			this.uniformKeys = <any[]>Object.keys(this.uniforms);
			for(var i:  number  = 0; i < this.uniformKeys.length; i++){
				this.uniformKeys[i] = +this.uniformKeys[i];
			}

			this.foreignKeys = <any[]>Object.keys(this.foreigns);
			for(var i:  number  = 0; i < this.foreignKeys.length; i++){
				this.foreignKeys[i] = +this.foreignKeys[i];
			}

			this.textureKeys = <any[]>Object.keys(this.textures);
			for(var i:  number  = 0; i < this.textureKeys.length; i++){
				this.textureKeys[i] = +this.textureKeys[i];
			}
		}

		private  /**@inline*/  isVarArray(pVar: IAFXVariableDeclInstruction): bool {
			return pVar.getType().isNotBaseArray();
		}

		private clearSamplerState(pState: IAFXSamplerState): void {
			pState.textureName = "";
			pState.texture = null;
			pState.wrap_s = ETextureWrapModes.UNDEF;
			pState.wrap_t = ETextureWrapModes.UNDEF;
			pState.mag_filter = ETextureFilters.UNDEF;
			pState.min_filter = ETextureFilters.UNDEF;
/*pState.wrap_s = ETextureWrapModes.CLAMP_TO_EDGE;
			pState.wrap_t = ETextureWrapModes.CLAMP_TO_EDGE;
			pState.mag_filter = ETextureFilters.LINEAR;
			pState.min_filter = ETextureFilters.LINEAR;*/

		}

		private _setSamplerTextureObjectByIndex(iNameIndex:  number , pTexture: ITexture): void {
			if(iNameIndex === 0){
				return;
			}

			var pState: IAFXSamplerState = this.samplers[iNameIndex];
			if(pState.texture !== pTexture){
				this._pStatesInfo.samplerKey++;
			}

			pState.texture = pTexture;
		}

		private copySamplerState(pFrom: IAFXSamplerState, pTo: IAFXSamplerState): void {
			if (pTo.textureName !== pFrom.textureName ||
				pTo.texture !== pFrom.texture){
				this._pStatesInfo.samplerKey++;
			}

			pTo.textureName = pFrom.textureName;
			pTo.texture = pFrom.texture;

			pTo.wrap_s = pFrom.wrap_s;
			pTo.wrap_t = pFrom.wrap_t;

			pTo.mag_filter = pFrom.mag_filter;
			pTo.min_filter = pFrom.min_filter;
		}
	}
}















module akra.render {
	export interface IUniform {

	}

	export  class  LightData {
		DIFFUSE: IVec4 = new Vec4();
		AMBIENT: IVec4 = new Vec4();
		SPECULAR: IVec4 = new Vec4();
		POSITION: IVec3 = new Vec3();
		ATTENUATION: IVec3 = new Vec3();

// set(pLightParam: IOmniParameters, v3fPosition: IVec3): LightData;
// set(pLightParam: IProjectParameters, v3fPosition: IVec3): LightData;
		set(pLightParam: ILightParameters, v3fPosition: IVec3): LightData;
		set(pLightParam: any, v3fPosition: IVec3): LightData {

		    this.DIFFUSE.set(pLightParam.diffuse);
		    this.AMBIENT.set(pLightParam.ambient);
		    this.SPECULAR.set(pLightParam.specular);
		    this.ATTENUATION.set(pLightParam.attenuation);
		    this.POSITION.set(v3fPosition);

		    return this;
		}
	};

	export  class  UniformOmni implements IUniform {
		LIGHT_DATA: LightData = new LightData();

		setLightData(pLightParam: IOmniParameters, v3fPosition: IVec3): UniformOmni {
			this.LIGHT_DATA.set(pLightParam, v3fPosition);

			return this;
		}

		static get stackCeil(): UniformOmni { UniformOmni.stackPosition = UniformOmni.stackPosition === UniformOmni.stackSize - 1? 0: UniformOmni.stackPosition; return UniformOmni.stack[UniformOmni.stackPosition ++]; } static stackSize: number = 200; static stackPosition: number = 0; static stack: UniformOmni[] = (function(): UniformOmni[]{ var pStack: UniformOmni[] = new Array(UniformOmni.stackSize); for(var i: number = 0; i<UniformOmni.stackSize; i++){ pStack[i] = new UniformOmni(); } return pStack})(); ;
	};

	export  class  UniformProject implements IUniform {
		LIGHT_DATA: LightData = new LightData();
    	SHADOW_MATRIX: IMat4 = new Mat4();

    	setLightData(pLightParam: IProjectParameters, v3fPosition: IVec3): UniformProject {
			this.LIGHT_DATA.set(pLightParam, v3fPosition);

			return this;
		}

		setMatrix(m4fMatrix: IMat4): UniformProject {
			this.SHADOW_MATRIX.set(m4fMatrix);
			return this;
		}

    	static get stackCeil(): UniformProject { UniformProject.stackPosition = UniformProject.stackPosition === UniformProject.stackSize - 1? 0: UniformProject.stackPosition; return UniformProject.stack[UniformProject.stackPosition ++]; } static stackSize: number = 200; static stackPosition: number = 0; static stack: UniformProject[] = (function(): UniformProject[]{ var pStack: UniformProject[] = new Array(UniformProject.stackSize); for(var i: number = 0; i<UniformProject.stackSize; i++){ pStack[i] = new UniformProject(); } return pStack})(); ;
	};


	export  class  UniformProjectShadow implements IUniform {
		LIGHT_DATA: LightData = new LightData();
	    TO_LIGHT_SPACE: IMat4 = new Mat4();
	    REAL_PROJECTION_MATRIX: IMat4 = new Mat4();
	    OPTIMIZED_PROJECTION_MATRIX: IMat4 = new Mat4();
	    SHADOW_SAMPLER: IAFXSamplerState = fx.createSamplerState();

	    setLightData(pLightParam: IProjectParameters, v3fPosition: IVec3): UniformProjectShadow {
	    	this.LIGHT_DATA.set(pLightParam, v3fPosition);
	    	return this;
	    }

	    setMatrix(m4fToLightSpace: IMat4, m4fRealProj: IMat4, m4fOptimizedProj: IMat4): UniformProjectShadow {
	    	this.TO_LIGHT_SPACE.set(m4fToLightSpace);
		    this.REAL_PROJECTION_MATRIX.set(m4fRealProj);
		    this.OPTIMIZED_PROJECTION_MATRIX.set(m4fOptimizedProj);

	    	return this;
	    }

	    setSampler(sTexture: string): UniformProjectShadow {
	    	this.SHADOW_SAMPLER.textureName = sTexture;
	    	return this;
	    }

	    static get stackCeil(): UniformProjectShadow { UniformProjectShadow.stackPosition = UniformProjectShadow.stackPosition === UniformProjectShadow.stackSize - 1? 0: UniformProjectShadow.stackPosition; return UniformProjectShadow.stack[UniformProjectShadow.stackPosition ++]; } static stackSize: number = 20; static stackPosition: number = 0; static stack: UniformProjectShadow[] = (function(): UniformProjectShadow[]{ var pStack: UniformProjectShadow[] = new Array(UniformProjectShadow.stackSize); for(var i: number = 0; i<UniformProjectShadow.stackSize; i++){ pStack[i] = new UniformProjectShadow(); } return pStack})(); ;
	}

	export  class  UniformOmniShadow implements IUniform {
		LIGHT_DATA: LightData = new LightData;
		TO_LIGHT_SPACE: IMat4[] =
		[
			new Mat4, new Mat4, new Mat4,
			new Mat4, new Mat4, new Mat4
		];

		OPTIMIZED_PROJECTION_MATRIX: IMat4[] =
		[
			new Mat4, new Mat4, new Mat4,
			new Mat4, new Mat4, new Mat4
		];

		SHADOW_SAMPLER: IAFXSamplerState[] =
		[
			fx.createSamplerState(), fx.createSamplerState(), fx.createSamplerState(),
	        fx.createSamplerState(), fx.createSamplerState(), fx.createSamplerState()
	    ];

	    setLightData(pLightParam: IOmniParameters, v3fPosition: IVec3): UniformOmniShadow {
		    this.LIGHT_DATA.set(pLightParam, v3fPosition);
		    return this;
		};

		setMatrix(m4fToLightSpace: IMat4, m4fOptimizedProj: IMat4, index:  number ): UniformOmniShadow {
		    this.TO_LIGHT_SPACE[index].set(m4fToLightSpace);
		    this.OPTIMIZED_PROJECTION_MATRIX[index].set(m4fOptimizedProj);
		    return this;
		};

		setSampler(sTexture: string, index:  number ): UniformOmniShadow {
		    this.SHADOW_SAMPLER[index].textureName = sTexture;
		    return this;
		};

	    static get stackCeil(): UniformOmniShadow { UniformOmniShadow.stackPosition = UniformOmniShadow.stackPosition === UniformOmniShadow.stackSize - 1? 0: UniformOmniShadow.stackPosition; return UniformOmniShadow.stack[UniformOmniShadow.stackPosition ++]; } static stackSize: number = 3; static stackPosition: number = 0; static stack: UniformOmniShadow[] = (function(): UniformOmniShadow[]{ var pStack: UniformOmniShadow[] = new Array(UniformOmniShadow.stackSize); for(var i: number = 0; i<UniformOmniShadow.stackSize; i++){ pStack[i] = new UniformOmniShadow(); } return pStack})(); ;
	}

	export  class  UniformSun implements IUniform {
		SUN_DIRECTION: IVec3 = new Vec3();
	    EYE_POSITION: IVec3 = new Vec3();
	    GROUNDC0: IVec3 = new Vec3();
	    GROUNDC1: IVec3 = new Vec3();
	    HG: IVec3 = new Vec3;
	    SKY_DOME_ID:  number  = 0;

	    setLightData(pSunParam: ISunParameters, iSunDomeId:  number ): UniformSun {
	    	this.SUN_DIRECTION.set(pSunParam.sunDir);
	    	this.EYE_POSITION.set(pSunParam.eyePosition);
	    	this.GROUNDC0.set(pSunParam.groundC0);
	    	this.GROUNDC1.set(pSunParam.groundC1);
	    	this.HG.set(pSunParam.hg);
	    	this.SKY_DOME_ID = iSunDomeId;

	    	return this;
	    }


	    static get stackCeil(): UniformSun { UniformSun.stackPosition = UniformSun.stackPosition === UniformSun.stackSize - 1? 0: UniformSun.stackPosition; return UniformSun.stack[UniformSun.stackPosition ++]; } static stackSize: number = 3; static stackPosition: number = 0; static stack: UniformSun[] = (function(): UniformSun[]{ var pStack: UniformSun[] = new Array(UniformSun.stackSize); for(var i: number = 0; i<UniformSun.stackSize; i++){ pStack[i] = new UniformSun(); } return pStack})(); ;
	}

	export  class  UniformSunShadow implements IUniform {
		SUN_DIRECTION: IVec3 = new Vec3();
	    EYE_POSITION: IVec3 = new Vec3();
	    GROUNDC0: IVec3 = new Vec3();
	    GROUNDC1: IVec3 = new Vec3();
	    HG: IVec3 = new Vec3;
	    SKY_DOME_ID:  number  = 0;
	    SHADOW_SAMPLER: IAFXSamplerState = fx.createSamplerState();
	    TO_LIGHT_SPACE: IMat4 = new Mat4();
	    OPTIMIZED_PROJECTION_MATRIX: IMat4 = new Mat4();

	    setLightData(pSunParam: ISunParameters, iSunDomeId:  number ): UniformSunShadow {
	    	this.SUN_DIRECTION.set(pSunParam.sunDir);
	    	this.EYE_POSITION.set(pSunParam.eyePosition);
	    	this.GROUNDC0.set(pSunParam.groundC0);
	    	this.GROUNDC1.set(pSunParam.groundC1);
	    	this.HG.set(pSunParam.hg);
	    	this.SKY_DOME_ID = iSunDomeId;

	    	return this;
	    }

	    setSampler(sTexture: string): UniformSunShadow {
	    	this.SHADOW_SAMPLER.textureName = sTexture;
	    	return this;
	    }

	    setMatrix(m4fToLightSpace: IMat4, m4fOptimizedProj: IMat4): UniformSunShadow {
	    	this.TO_LIGHT_SPACE.set(m4fToLightSpace);
		    this.OPTIMIZED_PROJECTION_MATRIX.set(m4fOptimizedProj);

	    	return this;
	    }

	    static get stackCeil(): UniformSunShadow { UniformSunShadow.stackPosition = UniformSunShadow.stackPosition === UniformSunShadow.stackSize - 1? 0: UniformSunShadow.stackPosition; return UniformSunShadow.stack[UniformSunShadow.stackPosition ++]; } static stackSize: number = 3; static stackPosition: number = 0; static stack: UniformSunShadow[] = (function(): UniformSunShadow[]{ var pStack: UniformSunShadow[] = new Array(UniformSunShadow.stackSize); for(var i: number = 0; i<UniformSunShadow.stackSize; i++){ pStack[i] = new UniformSunShadow(); } return pStack})(); ;
	}


	export interface UniformMap {
		omni: UniformOmni[];
        project: UniformProject[];
        sun: UniformSun[];
        omniShadows: UniformOmniShadow[];
        projectShadows: UniformProjectShadow[];
        sunShadows: UniformSunShadow[];
        textures: ITexture[];
        samplersOmni: IAFXSamplerState[];
        samplersProject: IAFXSamplerState[];
        samplersSun: IAFXSamplerState[];
	}
}













module akra {

	;
	;
	;
	;
	;

	export interface IOmniParameters extends ILightParameters {
//default parameters
	    ambient: IColor;
	    diffuse: IColor;
	    specular: IColor;
	    attenuation: IVec3;
	}

	export interface IOmniLight extends ILightPoint {
		params: IOmniParameters;

		getShadowCaster(): IShadowCaster[];
		getDepthTextureCube(): ITexture[];
		getRenderTarget(iFace:  number ): IRenderTarget;

//false if lighting not active 
//or it's effect don't seen
		_prepareForLighting(pCamera: ICamera): bool;
	}
}







module akra {

	;
	;

	export interface IProjectParameters extends ILightParameters {
//default parameters
	    ambient: IColor;
	    diffuse: IColor;
	    specular: IColor;
	    attenuation: IVec3;
	}

	export interface IProjectLight extends ILightPoint {
		params: IProjectParameters;

		getShadowCaster(): IShadowCaster;
		getDepthTexture(): ITexture;
		getRenderTarget(): IRenderTarget;

//false if lighting not active 
//or it's effect don't seen
		_prepareForLighting(pCamera: ICamera): bool;
	}
}







module akra {

	;
	;
	;
	;



	export interface IShadowCaster extends ICamera {
		 lightPoint: ILightPoint;
		 face:  number ;
		 affectedObjects: IObjectArray;
		 optimizedProjection: IMat4;
//casted shadows in the last frame
		isShadowCasted: bool;

		_optimizeProjectionMatrix(pEffectiveCameraFrustum: IFrustum): void;
	}
}

























module akra.render {
	export class RenderPass implements IRenderPass {
		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } ;

		private _pTechnique: IRenderTechnique = null;
		private _pRenderTarget: IRenderTarget = null;
		private _iPassNumber:  number  = 0;
		private _pInput: IAFXPassInputBlend = null;
		private _isActive: bool = true;

		constructor(pTechnique: IRenderTechnique, iPass:  number ){
			this._pTechnique = pTechnique;
			this._iPassNumber = iPass;
		}

		/**@inline*/  setForeign(sName: string, fValue:  number ): void {
			this._pInput.setForeign(sName, fValue);
		}

		/**@inline*/  setTexture(sName: string, pTexture: ITexture): void {
			this._pInput.setTexture(sName, pTexture);
		}

		/**@inline*/  setUniform(sName: string, pValue: any): void {
			this._pInput.setUniform(sName, pValue);
		}

		/**@inline*/  setStruct(sName: string, pValue: any): void {
			this._pInput.setStruct(sName, pValue);
		}

		/**@inline*/  setRenderState(eState: ERenderStates, eValue: ERenderStateValues): void {
			this._pInput.setRenderState(eState, eValue);
		}

		/**@inline*/  setSamplerTexture(sName: string, sTexture: string): void;
		/**@inline*/  setSamplerTexture(sName: string, pTexture: ITexture): void;
		/**@inline*/  setSamplerTexture(sName: string, pTexture: any): void {
			this._pInput.setSamplerTexture(sName, pTexture);
		}

// inline setSamplerState(sName: string, pState: IAFXSamplerState): void {
// 	this._pInput.setSamplerState(sName, pState);
// }

		getRenderTarget(): IRenderTarget {
			return this._pRenderTarget;
		}

		setRenderTarget(pTarget: IRenderTarget): void {
			this._pRenderTarget = pTarget;
		}

		getPassInput(): IAFXPassInputBlend {
			return this._pInput;
		}

		setPassInput(pInput: IAFXPassInputBlend, isNeedRelocate: bool): void {
			if(isNeedRelocate){
//pInput._copyFrom(pInput);
			}

			if(!isNull(this._pInput)) {
				this._pInput._release();
			}

			this._pInput = pInput;
		}

		blend(sComponentName: string, iPass:  number ): bool {
			return this._pTechnique.addComponent(sComponentName, this._iPassNumber, iPass);
		}

		/**@inline*/  activate(): void {
			this._isActive = true;
		}

		/**@inline*/  deactivate(): void {
			this._isActive = false;
		}

		/**@inline*/  isActive(): bool {
			return this._isActive;
		}

		private relocateOldInput(pNewInput: IAFXPassInputBlend): void {
//TODO: copy old uniforms to new
		}
	}
}





module akra.render {
	export class RenderTechnique implements IRenderTechnique {
		private _pMethod: IRenderMethod = null;

		private _isFreeze: bool = false;
		private _pComposer: IAFXComposer = null;

		private _pPassList: IRenderPass[] = null;
		private _pPassBlackList: bool[] = null;

		private _iCurrentPass:  number  = 0;
		private _pCurrentPass: IRenderPass = null;

		private _iGlobalPostEffectsStart:  number  = 0;
		private _iMinShiftOfOwnBlend:  number  = 0;

		private _pRenderMethodPassStateList: util.ObjectArray = null;

		static protected pRenderMethodPassStatesPool: util.ObjectArray = new util.ObjectArray();

		/**@inline*/  get modified():  number  {
			return this.getGuid();
		}

		get totalPasses():  number  {
			return this._pComposer.getTotalPassesForTechnique(this);
		}

		get data(): IAFXComponentBlend {
			return null;
		}

		constructor (pMethod: IRenderMethod = null) {
			this._pPassList = [];
			this._pPassBlackList = [];

			if(!isNull(pMethod)){
				this.setMethod(pMethod);
			}

			this._pRenderMethodPassStateList = new util.ObjectArray();
		}


		destroy(): void {

		}

		/**@inline*/  getPass(iPass:  number ): IRenderPass {
			this._pComposer.prepareTechniqueBlend(this);
			return this._pPassList[iPass];
		}

		getMethod(): IRenderMethod {
			return this._pMethod;
		}

		setMethod(pMethod: IRenderMethod): void {
			if(!isNull(this._pMethod)){
				this.disconnect(this._pMethod,  "altered" ,  "_updateMethod" , EEventTypes.BROADCAST);
			}

			this._pMethod = pMethod;

			if(!isNull(pMethod)){
				var pComposer: IAFXComposer = pMethod.manager.getEngine().getComposer();
				this._setComposer(pComposer);
				this.connect(pMethod,  "altered" ,  "_updateMethod" , EEventTypes.BROADCAST);
			}

			this._updateMethod(pMethod);
		}

		setState(sName: string, pValue: any): void {

		}

		setForeign(sName: string, pValue: any): void {

		}

		setStruct(sName: string, pValue: any): void {
//skip
		}

		setTextureBySemantics(sName: string, pValue: any): void {

		}

		setShadowSamplerArray(sName: string, pValue: any): void {

		}

		setVec2BySemantic(sName: string, pValue: any): void {

		}

		isReady(): bool {
			return this._pMethod.isResourceLoaded() && !this._pMethod.isResourceDisabled();
		}

		addComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		addComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;
		addComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		addComponent(pComponent: any, iShift?:  number  = 0, iPass?:  number  =  0xffffff ): bool {
			if(isNull(this._pComposer)){
				return false;
			}

			var pComponentPool: IResourcePool = this._pComposer.getEngine().getResourceManager().componentPool;

			if(isInt(pComponent)) {
				pComponent = pComponentPool.getResource(< number >pComponent);
			}
			else if(isString(pComponent)){
				pComponent = pComponentPool.findResource(<string>pComponent);
			}

			if(!isDef(pComponent) || isNull(pComponent)){
				{ logger.setSourceLocation( "RenderTechnique.ts" , 128 ); logger.error("Bad component for add."); } ;
				return false;
			}

			if(!this._pComposer.addOwnComponentToTechnique(this, <IAFXComponent>pComponent, iShift, iPass)){
				{ logger.setSourceLocation( "RenderTechnique.ts" , 133 ); logger.error("Can not add component '" + <IAFXComponent>pComponent.findResourceName() + "'"); } ;
				return false;
			}

			this._iMinShiftOfOwnBlend = this._pComposer.getMinShiftForOwnTechniqueBlend(this);

			return true;
		}

		delComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		delComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: any, iShift?:  number  = 0, iPass?:  number  =  0xffffff ): bool {
			if(isNull(this._pComposer)){
				return false;
			}

			var pComponentPool: IResourcePool = this._pComposer.getEngine().getResourceManager().componentPool;

			if(isInt(pComponent)) {
				pComponent = pComponentPool.getResource(< number >pComponent);
			}
			else if(isString(pComponent)){
				pComponent = pComponentPool.findResource(<string>pComponent);
			}

			if(!isDef(pComponent) || isNull(pComponent)){
				{ logger.setSourceLocation( "RenderTechnique.ts" , 160 ); logger.error("Bad component for delete."); } ;
				return false;
			}

			if(!this._pComposer.removeOwnComponentToTechnique(this, <IAFXComponent>pComponent, iShift, iPass)){
				{ logger.setSourceLocation( "RenderTechnique.ts" , 165 ); logger.error("Can not delete component '" + <IAFXComponent>pComponent.findResourceName() + "'"); } ;
				return false;
			}

			this._iMinShiftOfOwnBlend = this._pComposer.getMinShiftForOwnTechniqueBlend(this);

			return true;
		}

		hasComponent(sComponent: string, iShift?:  number  =  0xfffffb , iPass:  number  =  0xfffffa ): bool {
			return this._pMethod.effect.hasComponent(sComponent, iShift, iPass) || this.hasOwnComponent(sComponent, iShift, iPass);
		}

		hasOwnComponent(sComponent: string, iShift?:  number  =  0xfffffb , iPass:  number  =  0xfffffa ): bool {
			if(isNull(this._pComposer)){
				return false;
			}

			var pComponentPool: IResourcePool = this._pComposer.getEngine().getResourceManager().componentPool;
			var pComponent: IAFXComponent = null;

			pComponent = <IAFXComponent>pComponentPool.findResource(sComponent);

			if(isNull(pComponent)){
				return false;
			}

			return this._pComposer.hasOwnComponentInTechnique(this, pComponent, iShift, iPass);
		}

		hasPostEffect(): bool {
			return this._iGlobalPostEffectsStart > 0;
		}

		isPostEffectPass(iPass:  number ): bool {
			return this._iGlobalPostEffectsStart <= iPass;
		}

		isLastPass(iPass:  number ): bool {
			var iMaxPass:  number  = this.totalPasses - 1;

			if(iMaxPass === iPass){
				return true;
			}

			if(!this._pPassBlackList[iMaxPass]){
				return false;
			}

			for(var i:  number  = this._pPassBlackList.length - 2; i >=0; i--){
				if(!this._pPassBlackList[i]){
					if(i !== iPass){
						return false;
					}
					else {
						return true;
					}
				}
			}

			return false;
		}

		isFirstPass(iPass:  number ): bool {
			if(iPass === 0){
				return true;
			}

			if(!this._pPassBlackList[0]){
				return false;
			}

			for(var i:  number  = 1; i < this._pPassBlackList.length; i++){
				if(!this._pPassBlackList[i]){
					if(i !== iPass){
						return false;
					}
					else {
						return true;
					}
				}
			}

			return false;
		}

		isFreeze(): bool {
			return this._isFreeze;
		}

		updatePasses(bSaveOldUniformValue: bool): void {
			this._isFreeze = true;

			var iTotalPasses:  number  = this.totalPasses;

			for(var i:  number  = this._pPassList.length; i < iTotalPasses; i++) {
				if(!isDef(this._pPassBlackList[i]) || this._pPassBlackList[i] === false){
					this._pPassList[i] = new RenderPass(this, i);
					this._pPassBlackList[i] = false;
				}
			}

			for(var i:  number  = 0; i < iTotalPasses; i++){
				if(!this._pPassBlackList[i]){
					var pInput: IAFXPassInputBlend = this._pComposer.getPassInputBlendForTechnique(this, i);
					if(!isNull(pInput)){
						this._pPassList[i].setPassInput(pInput, bSaveOldUniformValue);
						this._pPassList[i].activate();
					}
					else {
						this._pPassList[i].deactivate();
					}

				}
			}

			this._isFreeze = false;
		}

		/**@inline*/  _setComposer(pComposer: IAFXComposer): void {
			this._pComposer = pComposer;
		}

		/**@inline*/  _getComposer(): IAFXComposer {
			return this._pComposer;
		}

		_renderTechnique(pViewport: IViewport, pRenderable: IRenderableObject, pSceneObject: ISceneObject): void {
			if(isNull(this._pComposer)){
				return;
			}

			var pComposer: IAFXComposer = this._pComposer;

			pComposer.prepareTechniqueBlend(this);
			pComposer._setCurrentViewport(pViewport);
			pComposer._setCurrentSceneObject(pSceneObject);
			pComposer._setCurrentRenderableObject(pRenderable);
			pComposer.applySurfaceMaterial(this._pMethod.surfaceMaterial);

			this._isFreeze = true;

			this.takePassInputsFromRenderMethod();

			var iTotalPasses:  number  = this.totalPasses;
			for(var i:  number  = 0; i < iTotalPasses; i++){
				if(this._pPassBlackList[i] === false && this._pPassList[i].isActive()){
					this.activatePass(i);
					this.render(i, pRenderable, pSceneObject, pViewport);
					pViewport.render(this, i, pRenderable, pSceneObject);
					pComposer.renderTechniquePass(this, i);
				}
			}

			this._isFreeze = false;
			pComposer._setDefaultCurrentState();
		}

		_updateMethod(pMethod: IRenderMethod): void {
			this.informComposer();
			this.prepareRenderMethodPassStateInfo(pMethod);
		}

		_blockPass(iPass:  number ): void {
			this._pPassBlackList[iPass] = true;
			this._pComposer.prepareTechniqueBlend(this);
// this._pPassList[iPass] = null; 

		}


        _setPostEffectsFrom(iPass:  number ): void {
        	this._iGlobalPostEffectsStart = iPass;
        }

		private informComposer(): void {
			if(!isNull(this._pComposer)){
				this._pComposer.markTechniqueAsNeedUpdate(this);
			}
		}

		private prepareRenderMethodPassStateInfo(pMethod: IRenderMethod): void {
			var iLength:  number  = this._pRenderMethodPassStateList.length;

			for(var i:  number  = 0; i < iLength; i++){
				this.freePassState(this._pRenderMethodPassStateList.value(i));
			}

			this._pRenderMethodPassStateList.clear();

			if(isNull(pMethod)){
				return;
			}

			var iMethodTotalPasses:  number  = pMethod.effect.totalPasses;

			for(var i:  number  = 0; i < iMethodTotalPasses; i++){
				var pState: IAFXPassInputStateInfo = this.getFreePassState();
				pState.uniformKey = 0;
				pState.foreignKey = 0;
				pState.samplerKey = 0;
				pState.renderStatesKey = 0;

				this._pRenderMethodPassStateList.push(pState);
			}
		}

		private takePassInputsFromRenderMethod(): void {
			if(isNull(this._pMethod)){
				return;
			}

			var iRenderMethodStartPass:  number  = (this._iMinShiftOfOwnBlend < 0) ?
												(-this._iMinShiftOfOwnBlend) : 0;
			var iTotalPasses:  number  = this._pMethod.effect.totalPasses;

			for(var i:  number  = 0; i < iTotalPasses; i++){
				if(this._pPassBlackList[i + iRenderMethodStartPass]){
					continue;
				}

				var pRenderMethodPassInput: IAFXPassInputBlend = this._pMethod._getPassInput(i);
				var pPassInput: IAFXPassInputBlend = this._pPassList[i].getPassInput();

				if(isNull(pRenderMethodPassInput) || isNull(pPassInput)){
					continue;
				}

				var pOldStates: IAFXPassInputStateInfo = this._pRenderMethodPassStateList.value(i);
				var pCurrentStates: IAFXPassInputStateInfo = pRenderMethodPassInput.statesInfo;

				if(pOldStates.uniformKey !== pCurrentStates.uniformKey){
					pPassInput._copyUniformsFromInput(pRenderMethodPassInput);
					pOldStates.uniformKey = pCurrentStates.uniformKey;
				}

				if(pOldStates.foreignKey !== pCurrentStates.foreignKey){
					pPassInput._copyForeignsFromInput(pRenderMethodPassInput);
					pOldStates.foreignKey = pCurrentStates.foreignKey;
				}

				if(pOldStates.samplerKey !== pCurrentStates.samplerKey){
					pPassInput._copySamplersFromInput(pRenderMethodPassInput);
					pOldStates.samplerKey = pCurrentStates.samplerKey;
				}

				if(pOldStates.renderStatesKey !== pCurrentStates.renderStatesKey){
					pPassInput._copyRenderStatesFromInput(pRenderMethodPassInput);
					pOldStates.renderStatesKey = pCurrentStates.renderStatesKey;
				}
			}
		}

		private activatePass(iPass:  number ): void {
			this._iCurrentPass = iPass;
			this._pCurrentPass = this._pPassList[iPass];
		}

		private getFreePassState(): IAFXPassInputStateInfo {
			if(RenderTechnique.pRenderMethodPassStatesPool.length > 0){
				return RenderTechnique.pRenderMethodPassStatesPool.pop();
			}
			else {
				return <IAFXPassInputStateInfo>{
					uniformKey: 0,
					foreignKey: 0,
					samplerKey: 0,
					renderStatesKey: 0
				};
			}
		}

		private freePassState(pState: IAFXPassInputStateInfo): void {
			RenderTechnique.pRenderMethodPassStatesPool.push(pState);
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return RenderTechnique._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		render (iPass, pRenderable, pSceneObject, pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).render; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, iPass, pRenderable, pSceneObject, pViewport) : _broadcast[i].listener (_recivier, iPass, pRenderable, pSceneObject, pViewport) ; } } } ; ;
	}
}






















































module akra {

	;
	;

	export interface ISphere {

		center: IVec3;
		radius:  number ;

		circle: ICircle;
		z:  number ;

		set(): ISphere;
		set(pSphere: ISphere): ISphere;
		set(v3fCenter: IVec3, fRadius:  number ): ISphere;
		set(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number ): ISphere;

		clear(): ISphere;

		isEqual(pSphere: ISphere): bool;
		isClear(): bool;
		isValid(): bool;

		offset(v3fOffset: IVec3): ISphere;
		expand(fInc:  number ): ISphere;
		normalize(): ISphere;

		transform(m4fMatrix: IMat4): ISphere;
	};
};





module akra.geometry{
	export class Sphere implements ISphere{
		center: IVec3;
		radius:  number ;

		constructor();
		constructor(pSphere: ISphere);
		constructor(v3fCenter: IVec3, fRadius:  number );
		constructor(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number );
		constructor(fCenterX?, fCenterY?, fCenterZ?, fRadius?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pSphere = arguments[0];

					this.center = new Vec3(pSphere.v3fCenter);
					this.radius = pSphere.fRadius;
					break;
				case 2:
					var v3fCenter: IVec3 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center = new Vec3(v3fCenter);
					this.radius = fRadius;
					break;
				case 4:
					this.center = new Vec3(arguments[0], arguments[1], arguments[2]);
					this.radius = arguments[3];
					break;
				default:
					this.center = new Vec3();
					this.radius = 0.;
					break;
			}
		};

		get circle(): ICircle{
			var v3fCenter: IVec3 = this.center;
			return new Circle(v3fCenter.x, v3fCenter.y, this.radius);
		};
		set circle(pCircle: ICircle){
			var v3fCenter: IVec3 = this.center;
			var v2fCircleCenter: IVec2 = pCircle.center;
			v3fCenter.x = v2fCircleCenter.x;
			v3fCenter.y = v2fCircleCenter.y;
			this.radius = pCircle.radius;
		};

		get z():  number {
			return this.center.z;
		};
		set z(fZ:  number ){
			this.center.z = fZ;
		};

		set(): ISphere;
		set(pSphere: ISphere): ISphere;
		set(v3fCenter: IVec3, fRadius:  number ): ISphere;
		set(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number ): ISphere;
		set(fCenterX?, fCenterY?, fCenterZ?, fRadius?): ISphere{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pSphere = arguments[0];

					this.center.set(pSphere.center);
					this.radius = pSphere.radius;
					break;
				case 2:
					var v3fCenter: IVec3 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center.set(v3fCenter);
					this.radius = fRadius;
					break;
				case 4:
					this.center.set(arguments[0], arguments[1], arguments[2]);
					this.radius = arguments[3];
					break;
				default:
					this.center.set(0.);
					this.radius = 0.;
					break;
			}

			return this;
		};

		/**@inline*/  clear(): ISphere{
			this.center.clear();
			this.radius = 0.;

			return this;
		};

		/**@inline*/  isEqual(pSphere: ISphere): bool{
			return this.center.isEqual(pSphere.center) && (this.radius == pSphere.radius);
		};

		/**@inline*/  isClear(): bool{
			return this.center.isClear() && (this.radius === 0.);
		};

		/**@inline*/  isValid(): bool{
			return (this.radius >= 0.);
		};

		/**@inline*/  offset(v3fOffset: IVec3): ISphere{
			this.center.add(v3fOffset);
			return this;
		};

		/**@inline*/  expand(fInc:  number ): ISphere{
			this.radius += fInc;
			return this;
		};

		/**@inline*/  normalize(): ISphere{
			this.radius = math.abs(this.radius);
			return this;
		};

		transform(m4fMatrix: IMat4): ISphere {
			var v4fTmp: IVec4 =  Vec4.stackCeil.set(this.center, 1.) ;
			v4fTmp = m4fMatrix.multiplyVec4(v4fTmp);

			this.center.set(v4fTmp.xyz);

			var m3fTmp: IMat3 = m4fMatrix.toMat3( Mat3.stackCeil.set() );
			var v3fScale: IVec3 =  Vec3.stackCeil.set() ;

			m3fTmp.decompose( Quat4.stackCeil.set() , v3fScale);

			var fScaleX:  number  = math.abs(v3fScale.x);
			var fScaleY:  number  = math.abs(v3fScale.y);
			var fScaleZ:  number  = math.abs(v3fScale.z);

		    var fMaxScale:  number ;

		    if(fScaleX >= fScaleY && fScaleX >= fScaleZ){
		    	fMaxScale = fScaleX;
		    }
		    else if(fScaleY >= fScaleX && fScaleY >= fScaleZ){
		    	fMaxScale = fScaleY;
		    }
		    else{
		    	fMaxScale = fScaleZ;
		    }

		    this.radius *= fMaxScale;

			return this;
		};
	};
}








module akra {

	;
	;

	export interface IRect3d {
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;
		z0:  number ;
		z1:  number ;

		rect2d: IRect2d;

		set(): IRect3d;
		set(pRect: IRect3d): IRect3d;
		set(v3fSize: IVec3): IRect3d;
		set(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		set(v3fMinPoint: IVec3, v3fMaxPoint: IVec3): IRect3d;
		set(fX0:  number , fX1:  number , fY0:  number ,
			fY1:  number , fZ0:  number , fZ1:  number ): IRect3d;

		setFloor(pRect: IRect3d): IRect3d;
		setCeil(pRect: IRect3d): IRect3d;

		clear(): IRect3d;

		addSelf(fValue:  number ): IRect3d;
		addSelf(v3fVec: IVec3): IRect3d;

		subSelf(fValue:  number ): IRect3d;
		subSelf(v3fVec: IVec3): IRect3d;

		multSelf(fValue:  number ): IRect3d;
		multSelf(v3fVec: IVec3): IRect3d;

		divSelf(fValue:  number ): IRect3d;
		divSelf(v3fVec: IVec3): IRect3d;

		offset(v3fOffset: IVec3): IRect3d;
		offset(fOffsetX:  number , fOffsetY:  number , fOffsetZ:  number ): IRect3d;

		expand(fValue:  number ): IRect3d;
		expand(v3fVec: IVec3): IRect3d;
		expand(fValueX:  number , fValueY:  number , fValueZ:  number ): IRect3d;

		expandX(fValue:  number ): IRect3d;
		expandY(fValue:  number ): IRect3d;
		expandZ(fValue:  number ): IRect3d;

		resize(v3fSize: IVec3): IRect3d;
		resize(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;

		resizeX(fSize:  number ): IRect3d;
		resizeY(fSize:  number ): IRect3d;
		resizeZ(fSize:  number ): IRect3d;

		resizeMax(v3fSpan: IVec3): IRect3d;
		resizeMax(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;

		resizeMaxX(fSpan:  number ): IRect3d;
		resizeMaxY(fSpan:  number ): IRect3d;
		resizeMaxZ(fSpan:  number ): IRect3d;

		resizeMin(v3fSpan: IVec3): IRect3d;
		resizeMin(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;

		resizeMinX(fSpan:  number ): IRect3d;
		resizeMinY(fSpan:  number ): IRect3d;
		resizeMinZ(fSpan:  number ): IRect3d;

		unionPoint(v3fPoint: IVec3): IRect3d;
		unionPoint(fX:  number , fY:  number , fZ:  number ): IRect3d;
		unionRect(pRect: IRect3d): IRect3d;

		negate(pDestination?: IRect3d): IRect3d;
		normalize(): IRect3d;

		transform(m4fMatrix: IMat4): IRect3d;

		isEqual(pRect: IRect3d): bool;
		isClear(): bool;
		isValid(): bool;
		isPointInRect(v3fPoint: IVec3): bool;

		midPoint(v3fDestination?: IVec3): IVec3;
		midX():  number ;
		midY():  number ;
		midZ():  number ;

		size(v3fDestination: IVec3): IVec3;
		sizeX():  number ;
		sizeY():  number ;
		sizeZ():  number ;

		minPoint(v3fDestination?: IVec3): IVec3;
		maxPoint(v3fDestination?: IVec3): IVec3;

		volume():  number ;

		corner(iIndex:  number , v3fDestination?: IVec3): IVec3;

		createBoundingSphere(pSphere?: ISphere): ISphere;

		distanceToPoint(v3fPoint: IVec3):  number ;

		toString(): string;
	}
}





module akra.geometry {
    export class Rect3d implements IRect3d{
    	x0:  number ;
    	x1:  number ;
		y0:  number ;
		y1:  number ;
		z0:  number ;
		z1:  number ;

		constructor();
		constructor(pRect: IRect3d);
		constructor(v3fSize: IVec3);
		constructor(fSizeX:  number , fSizeY:  number , fSizeZ:  number );
		constructor(v3fMinPoint: IVec3, v3fMaxPoint: IVec3);
		constructor(fX0:  number , fX1:  number , fY0:  number ,
					fY1:  number , fZ0:  number , fZ1:  number );
		constructor(fX0?, fX1?, fY0?, fY1?, fZ0?, fZ1?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				case 6:
					this.set(arguments[0], arguments[1], arguments[2],
							arguments[3], arguments[4], arguments[5]);
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
					break;
			}
		};

		get rect2d(): IRect2d{
			return new Rect2d(this.x0, this.x1, this.y0, this.y1);
		};

		set rect2d(pRect: IRect2d){
			this.x0 = pRect.x0;
			this.x1 = pRect.x1;
			this.y0 = pRect.y0;
			this.y1 = pRect.y1;
		};

		set(): IRect3d;
		set(pRect: IRect3d): IRect3d;
		set(v3fSize: IVec3): IRect3d;
		set(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		set(v3fMinPoint: IVec3, v3fMaxPoint: IVec3): IRect3d;
		set(fX0:  number , fX1:  number , fY0:  number ,
			fY1:  number , fZ0:  number , fZ1:  number ): IRect3d;
		set(fX0?, fX1?, fY0?, fY1?, fZ0?, fZ1?): IRect3d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					if(arguments[0] instanceof Rect3d){
						var pRect: IRect3d = arguments[0];

						this.x0 = pRect.x0;
						this.x1 = pRect.x1;
						this.y0 = pRect.y0;
						this.y1 = pRect.y1;
						this.z0 = pRect.z0;
						this.z1 = pRect.z1;
					}
					else{
						var v3fSize: IVec3 = arguments[0];

						this.x1 = v3fSize.x*0.5;
						this.x0 = -this.x1;

						this.y1 = v3fSize.y*0.5;
						this.y0 = -this.y1;

						this.z1 = v3fSize.z*0.5;
						this.z0 = -this.z1;
					}
					break;
				case 2:
					var v3fMinPoint: IVec3 = arguments[0];
					var v3fMaxPoint: IVec3 = arguments[1];

					this.x0 = v3fMinPoint.x;
					this.y0 = v3fMinPoint.y;
					this.z0 = v3fMinPoint.z;

					this.x1 = v3fMaxPoint.x;
					this.y1 = v3fMaxPoint.y;
					this.z1 = v3fMaxPoint.z;
					break;
				case 3:
					var fSizeX:  number  = arguments[0];
					var fSizeY:  number  = arguments[1];
					var fSizeZ:  number  = arguments[2];

					this.x1 = fSizeX*0.5;
					this.x0 = -this.x1;

					this.y1 = fSizeY*0.5;
					this.y0 = -this.y1;

					this.z1 = fSizeZ*0.5;
					this.z0 = -this.z1;
					break;
				case 6:
					this.x0 = arguments[0];
					this.x1 = arguments[1];

					this.y0 = arguments[2];
					this.y1 = arguments[3];

					this.z0 = arguments[4];
					this.z1 = arguments[5];
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
					break;
			}
			return this;
		};

		setFloor(pRect: IRect3d): IRect3d{
			this.x0 = math.floor(pRect.x0);
			this.x1 = math.floor(pRect.x1);
			this.y0 = math.floor(pRect.y0);
			this.y1 = math.floor(pRect.y1);
			this.z0 = math.floor(pRect.z0);
			this.z1 = math.floor(pRect.z1);

			return this;
		};

		setCeil(pRect: IRect3d): IRect3d{
			this.x0 = math.ceil(pRect.x0);
			this.x1 = math.ceil(pRect.x1);
			this.y0 = math.ceil(pRect.y0);
			this.y1 = math.ceil(pRect.y1);
			this.z0 = math.ceil(pRect.z0);
			this.z1 = math.ceil(pRect.z1);

			return this;
		};

		/**@inline*/  clear(): IRect3d{
			this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
			return this;
		};

		addSelf(fValue:  number ): IRect3d;
		addSelf(v3fVec: IVec3): IRect3d;
		addSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 += fValue;
				this.x1 += fValue;
				this.y0 += fValue;
				this.y1 += fValue;
				this.z0 += fValue;
				this.z1 += fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 += v3fVec.x;
				this.x1 += v3fVec.x;

				this.y0 += v3fVec.y;
				this.y1 += v3fVec.y;

				this.z0 += v3fVec.z;
				this.z1 += v3fVec.z;
			}

			return this;
		};


		subSelf(fValue:  number ): IRect3d;
		subSelf(v3fVec: IVec3): IRect3d;
		subSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 -= fValue;
				this.x1 -= fValue;
				this.y0 -= fValue;
				this.y1 -= fValue;
				this.z0 -= fValue;
				this.z1 -= fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 -= v3fVec.x;
				this.x1 -= v3fVec.x;

				this.y0 -= v3fVec.y;
				this.y1 -= v3fVec.y;

				this.z0 -= v3fVec.z;
				this.z1 -= v3fVec.z;
			}

			return this;
		};

		multSelf(fValue:  number ): IRect3d;
		multSelf(v3fVec: IVec3): IRect3d;
		multSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 *= fValue;
				this.x1 *= fValue;
				this.y0 *= fValue;
				this.y1 *= fValue;
				this.z0 *= fValue;
				this.z1 *= fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 *= v3fVec.x;
				this.x1 *= v3fVec.x;

				this.y0 *= v3fVec.y;
				this.y1 *= v3fVec.y;

				this.z0 *= v3fVec.z;
				this.z1 *= v3fVec.z;
			}

			return this;
		};

		divSelf(fValue:  number ): IRect3d;
		divSelf(v3fVec: IVec3): IRect3d;
		divSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				{ logger.setSourceLocation( "geometry/Rect3d.ts" , 261 ); logger.assert(fValue != 0.0, "divide by zero error"); } ;

				var fInvValue:  number  = 1./fValue;

				this.x0 *= fInvValue;
				this.x1 *= fInvValue;
				this.y0 *= fInvValue;
				this.y1 *= fInvValue;
				this.z0 *= fInvValue;
				this.z1 *= fInvValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				{ logger.setSourceLocation( "geometry/Rect3d.ts" , 275 ); logger.assert(v3fVec.x != 0.0, "divide by zero error"); } ;
				{ logger.setSourceLocation( "geometry/Rect3d.ts" , 276 ); logger.assert(v3fVec.y != 0.0, "divide by zero error"); } ;
				{ logger.setSourceLocation( "geometry/Rect3d.ts" , 277 ); logger.assert(v3fVec.z != 0.0, "divide by zero error"); } ;

				var fInvX:  number  = 1./v3fVec.x;
				var fInvY:  number  = 1./v3fVec.y;
				var fInvZ:  number  = 1./v3fVec.z;

				this.x0 *= fInvX;
				this.x1 *= fInvX;

				this.y0 *= fInvY;
				this.y1 *= fInvY;

				this.z0 *= fInvZ;
				this.z1 *= fInvZ;
			}

			return this;
		};

		offset(v3fOffset: IVec3): IRect3d;
		offset(fOffsetX:  number , fOffsetY:  number , fOffsetZ:  number ): IRect3d;
		offset(fOffsetX?, fOffsetY?, fOffsetZ?): IRect3d{
			if(arguments.length === 1){
				var v3fOffset: IVec3 = arguments[0];

				this.x0 += v3fOffset.x;
				this.x1 += v3fOffset.x;

				this.y0 += v3fOffset.y;
				this.y1 += v3fOffset.y;

				this.z0 += v3fOffset.z;
				this.z1 += v3fOffset.z;
			}
			else{
				this.x0 += arguments[0];
				this.x1 += arguments[0];

				this.y0 += arguments[1];
				this.y1 += arguments[1];

				this.z0 += arguments[2];
				this.z1 += arguments[2];
			}

			return this;
		};

		expand(fValue:  number ): IRect3d;
		expand(v3fVec: IVec3): IRect3d;
		expand(fValueX:  number , fValueY:  number , fValueZ:  number ): IRect3d;
		expand(fValueX?, fValueY?, fValueZ?): IRect3d{
			if(arguments.length === 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					this.x0 -= fValue;
					this.x1 += fValue;

					this.y0 -= fValue;
					this.y1 += fValue;

					this.z0 -= fValue;
					this.z1 += fValue;
				}
				else{
					var v3fVec: IVec3 = arguments[0];

					this.x0 -= v3fVec.x;
					this.x1 += v3fVec.x;

					this.y0 -= v3fVec.y;
					this.y1 += v3fVec.y;

					this.z0 -= v3fVec.z;
					this.z1 += v3fVec.z;
				}
			}
			else{
//arguments.length === 3

				this.x0 -= arguments[0];
				this.x1 += arguments[0];

				this.y0 -= arguments[1];
				this.y1 += arguments[1];

				this.z0 -= arguments[2];
				this.z1 += arguments[2];
			}

			return this;
		};

		/**@inline*/  expandX(fValue:  number ): IRect3d{
			this.x0 -= fValue;
			this.x1 += fValue;

			return this;
		};

		/**@inline*/  expandY(fValue:  number ): IRect3d{
			this.y0 -= fValue;
			this.y1 += fValue;

			return this;
		};

		/**@inline*/  expandZ(fValue:  number ): IRect3d{
			this.z0 -= fValue;
			this.z1 += fValue;

			return this;
		};

		resize(v3fSize: IVec3): IRect3d;
		resize(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		resize(fSizeX?, fSizeY?, fSizeZ?): IRect3d{
			var fSizeX:  number , fSizeY:  number , fSizeZ:  number ;

			if(arguments.length === 1){
				var v3fSize: IVec3 = arguments[0];

				fSizeX = v3fSize.x;
				fSizeY = v3fSize.y;
				fSizeZ = v3fSize.z;
			}
			else{
				fSizeX = arguments[0];
				fSizeY = arguments[1];
				fSizeZ = arguments[2];
			}

			this.x1 = (this.x0 + this.x1 + fSizeX)*0.5;
			this.x0 = this.x1 - fSizeX;

			this.y1 = (this.y0 + this.y1 + fSizeY)*0.5;
			this.y0 = this.y1 - fSizeY;

			this.z1 = (this.z0 + this.z1 + fSizeZ)*0.5;
			this.z0 = this.z1 - fSizeZ;

			return this;
		};

		/**@inline*/  resizeX(fSize:  number ): IRect3d{
			this.x1 = (this.x0 + this.x1 + fSize)*0.5;
			this.x0 = this.x1 - fSize;

			return this;
		};

		/**@inline*/  resizeY(fSize:  number ): IRect3d{
			this.y1 = (this.y0 + this.y1 + fSize)*0.5;
			this.y0 = this.y1 - fSize;

			return this;
		};

		/**@inline*/  resizeZ(fSize:  number ): IRect3d{
			this.z1 = (this.z0 + this.z1 + fSize)*0.5;
			this.z0 = this.z1 - fSize;

			return this;
		};

		resizeMax(v3fSpan: IVec3): IRect3d;
		resizeMax(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;
		resizeMax(fSpanX?, fSpanY?, fSpanZ?): IRect3d{
			if(arguments.length === 1){
				var v3fSpan: IVec3 = arguments[0];

				this.x1 = this.x0 + v3fSpan.x;
				this.y1 = this.y0 + v3fSpan.y;
				this.z1 = this.z0 + v3fSpan.z;
			}
			else{
//arguments.length === 3
				this.x1 = this.x0 + arguments[0];
				this.y1 = this.y0 + arguments[1];
				this.z1 = this.z0 + arguments[2];
			}

			return this;
		};

		/**@inline*/  resizeMaxX(fSpan:  number ): IRect3d{
			this.x1 = this.x0 + fSpan;
			return this;
		};

		/**@inline*/  resizeMaxY(fSpan:  number ): IRect3d{
			this.y1 = this.y0 + fSpan;
			return this;
		};

		/**@inline*/  resizeMaxZ(fSpan:  number ): IRect3d{
			this.z1 = this.z0 + fSpan;
			return this;
		};

		resizeMin(v3fSpan: IVec3): IRect3d;
		resizeMin(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;
		resizeMin(fSpanX?, fSpanY?, fSpanZ?): IRect3d{
			if(arguments.length === 1){
				var v3fSpan: IVec3 = arguments[0];

				this.x0 = this.x1 - v3fSpan.x;
				this.y0 = this.y1 - v3fSpan.y;
				this.z0 = this.z1 - v3fSpan.z;
			}
			else{
//arguments.length === 3
				this.x0 = this.x1 - arguments[0];
				this.y0 = this.y1 - arguments[1];
				this.z0 = this.z1 - arguments[2];
			}

			return this;
		};

		/**@inline*/  resizeMinX(fSpan:  number ): IRect3d{
			this.x0 = this.x1 - fSpan;
			return this;
		};

		/**@inline*/  resizeMinY(fSpan:  number ): IRect3d{
			this.y0 = this.y1 - fSpan;
			return this;
		};

		/**@inline*/  resizeMinZ(fSpan:  number ): IRect3d{
			this.z0 = this.z1 - fSpan;
			return this;
		};

		unionPoint(v3fPoint: IVec3): IRect3d;
		unionPoint(fX:  number , fY:  number , fZ:  number ): IRect3d;
		unionPoint(fX?, fY?, fZ?): IRect3d{
			if(arguments.length === 1){
				var v3fPoint: IVec3 = arguments[0];

				this.x0 = math.min(this.x0, v3fPoint.x);
				this.x1 = math.max(this.x1, v3fPoint.x);

				this.y0 = math.min(this.y0, v3fPoint.y);
				this.y1 = math.max(this.y1, v3fPoint.y);

				this.z0 = math.min(this.z0, v3fPoint.z);
				this.z1 = math.max(this.z1, v3fPoint.z);
			}
			else{
//arguments.length === 3

				this.x0 = math.min(this.x0, arguments[0]);
				this.x1 = math.max(this.x1, arguments[0]);

				this.y0 = math.min(this.y0, arguments[1]);
				this.y1 = math.max(this.y1, arguments[1]);

				this.z0 = math.min(this.z0, arguments[2]);
				this.z1 = math.max(this.z1, arguments[2]);
			}

			return this;
		};

		unionRect(pRect: IRect3d): IRect3d{
			this.normalize();
			pRect.normalize();

			this.x0 = math.min(this.x0, pRect.x0);
			this.x1 = math.max(this.x1, pRect.x1);

			this.y0 = math.min(this.y0, pRect.y0);
			this.y1 = math.max(this.y1, pRect.y1);

			this.z0 = math.min(this.z0, pRect.z0);
			this.z1 = math.max(this.z1, pRect.z1);

			return this;
		};

		negate(pDestination?: IRect3d): IRect3d{
			if(!isDef(pDestination)){
				pDestination = this;
			}

			return pDestination.set(-this.x1, -this.x0,
							 -this.y1, -this.y0,
							 -this.z1, -this.z0);
		};

		normalize(): IRect3d{
			var fTmp:  number ;
			if(this.x0 > this.x1){
				fTmp = this.x0;
				this.x0 = this.x1;
				this.x1 = fTmp;
			}
			if(this.y0 > this.y1){
				fTmp = this.y0;
				this.y0 = this.y1;
				this.y1 = fTmp;
			}
			if(this.z0 > this.z1){
				fTmp = this.z0;
				this.z0 = this.z1;
				this.z1 = fTmp;
			}

			return this;
		};

		transform(m4fMatrix: IMat4): IRect3d{
			var pData: Float32Array = m4fMatrix.data;

			var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ],
				a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
			var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ],
				a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
			var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ],
				a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;
			var fZ0:  number  = this.z0, fZ1:  number  = this.z1;

//base point

			var fBaseX:  number  = a11*fX0 + a12*fY0 + a13*fZ0 + a14;
			var fBaseY:  number  = a21*fX0 + a22*fY0 + a23*fZ0 + a24;
			var fBaseZ:  number  = a31*fX0 + a32*fY0 + a33*fZ0 + a34;

//new x vector

			var fXNewX:  number  = a11*(fX1 - fX0);
			var fXNewY:  number  = a21*(fX1 - fX0);
			var fXNewZ:  number  = a31*(fX1 - fX0);

//new y vector

			var fYNewX:  number  = a12*(fY1 - fY0);
			var fYNewY:  number  = a22*(fY1 - fY0);
			var fYNewZ:  number  = a32*(fY1 - fY0);

//new z vector

			var fZNewX:  number  = a13*(fZ1 - fZ0);
			var fZNewY:  number  = a23*(fZ1 - fZ0);
			var fZNewZ:  number  = a33*(fZ1 - fZ0);

			var fXMultX:  number  = (fXNewX > 0.) ? 1. : 0.;
			var fYMultX:  number  = (fYNewX > 0.) ? 1. : 0.;
			var fZMultX:  number  = (fZNewX > 0.) ? 1. : 0.;

			var fXMultY:  number  = (fXNewY > 0.) ? 1. : 0.;
			var fYMultY:  number  = (fYNewY > 0.) ? 1. : 0.;
			var fZMultY:  number  = (fZNewY > 0.) ? 1. : 0.;

			var fXMultZ:  number  = (fXNewZ > 0.) ? 1. : 0.;
			var fYMultZ:  number  = (fYNewZ > 0.) ? 1. : 0.;
			var fZMultZ:  number  = (fZNewZ > 0.) ? 1. : 0.;

			this.x1 = fBaseX + fXMultX*fXNewX + fYMultX*fYNewX + fZMultX*fZNewX;
			this.y1 = fBaseY + fXMultY*fXNewY + fYMultY*fYNewY + fZMultY*fZNewY;
			this.z1 = fBaseZ + fXMultZ*fXNewZ + fYMultZ*fYNewZ + fZMultZ*fZNewZ;

			this.x0 = fBaseX + (1. - fXMultX)*fXNewX + (1. - fYMultX)*fYNewX + (1. - fZMultX)*fZNewX;
			this.y0 = fBaseY + (1. - fXMultY)*fXNewY + (1. - fYMultY)*fYNewY + (1. - fZMultY)*fZNewY;
			this.z0 = fBaseZ + (1. - fXMultZ)*fXNewZ + (1. - fYMultZ)*fYNewZ + (1. - fZMultZ)*fZNewZ;

			return this;
		};

		/**@inline*/  isEqual(pRect: IRect3d): bool{
			return this.x0 == pRect.x0 && this.x1 == pRect.x1
					&& this.y0 == pRect.y0 && this.y1 == pRect.y1
					&& this.z0 == pRect.z0 && this.z1 == pRect.z1;
		};

		/**@inline*/  isClear(): bool{
			return this.x0 == 0. && this.x1 == 0.
					&& this.y0 == 0. && this.y1 == 0.
					&& this.z0 == 0. && this.z1 == 0.;
		};

		/**@inline*/  isValid(): bool{
			return this.x0 <= this.x1
					&& this.y0 <= this.y1
					&& this.z0 <= this.z1;
		};

		/**@inline*/  isPointInRect(v3fPoint: IVec3): bool{
			var x:  number  = v3fPoint.x;
			var y:  number  = v3fPoint.y;
			var z:  number  = v3fPoint.z;

			return (this.x0 <= x && x <= this.x1)
					&& (this.y0 <= y && y <= this.y1)
					&& (this.z0 <= z && z <= this.z1);
		};

		midPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set((this.x0 + this.x1)*0.5,
									  (this.y0 + this.y1)*0.5,
									  (this.z0 + this.z1)*0.5);
		};

		/**@inline*/  midX():  number {
			return (this.x0 + this.x1)*0.5;
		};

		/**@inline*/  midY():  number {
			return (this.y0 + this.y1)*0.5;
		};

		/**@inline*/  midZ():  number {
			return (this.z0 + this.z1)*0.5;
		}

		size(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x1 - this.x0, this.y1 - this.y0, this.z1 - this.z0);
		};

		/**@inline*/  sizeX():  number {
			return this.x1 - this.x0;
		};

		/**@inline*/  sizeY():  number {
			return this.y1 - this.y0;
		};

		/**@inline*/  sizeZ():  number {
			return this.z1 - this.z0;
		};

		minPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x0, this.y0, this.z0);
		};

		maxPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x1, this.y1, this.z1);
		};

		/**@inline*/  volume():  number {
			return (this.x1 - this.x0)*(this.y1 - this.y0)*(this.z1 - this.z0);
		};

/**
		 * counter-clockwise and from bottom
		 * x0,y0,z0 -> x1,y0,z0 -> x1,y1,z0 -> x0,y1,z0 ->
		 * x0,y0,z1 -> x1,y0,z1 -> x1,y1,z1 -> x0,y1,z1
		 */

		corner(iIndex:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			{ logger.setSourceLocation( "geometry/Rect3d.ts" , 752 ); logger.assert(0 <= iIndex && iIndex < 8, "invalid index"); } ;

			switch(iIndex){
				case 0:
					v3fDestination.set(this.x0, this.y0, this.z0);
					break;
				case 1:
					v3fDestination.set(this.x1, this.y0, this.z0);
					break;
				case 2:
					v3fDestination.set(this.x1, this.y1, this.z0);
					break;
				case 3:
					v3fDestination.set(this.x0, this.y1, this.z0);
					break;
				case 4:
					v3fDestination.set(this.x0, this.y0, this.z1);
					break;
				case 5:
					v3fDestination.set(this.x1, this.y0, this.z1);
					break;
				case 6:
					v3fDestination.set(this.x1, this.y1, this.z1);
					break;
				case 7:
					v3fDestination.set(this.x0, this.y1, this.z1);
					break;
			}
			return v3fDestination;
		};

		createBoundingSphere(pSphere?: ISphere): ISphere{
			if(!isDef(pSphere)){
				pSphere = new Sphere();
			}

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;
			var fZ0:  number  = this.z0, fZ1:  number  = this.z1;

			var fHalfSizeX:  number  = (fX1 - fX0)*0.5;
			var fHalfSizeY:  number  = (fY1 - fY0)*0.5;
			var fHalfSizeZ:  number  = (fZ1 - fZ0)*0.5;

			pSphere.set((fX0 + fX1)*0.5, (fY0 + fY1)*0.5, (fZ0 + fZ1)*0.5,
				math.sqrt(fHalfSizeX*fHalfSizeX + fHalfSizeY*fHalfSizeY + fHalfSizeZ*fHalfSizeZ));

			return pSphere;
		};

		distanceToPoint(v3fPoint: IVec3):  number {
			var fX:  number  = v3fPoint.x, fY:  number  = v3fPoint.y, fZ:  number  = v3fPoint.z;

			var fX0:  number  = this.x0, fY0:  number  = this.y0, fZ0:  number  = this.z0;
			var fX1:  number  = this.x1, fY1:  number  = this.y1, fZ1:  number  = this.z1;

			var fXN:  number , fYN:  number , fZN:  number ;

			fXN = (math.abs(fX0 - fX) < math.abs(fX1 - fX)) ? fX0 : fX1;
			fYN = (math.abs(fY0 - fY) < math.abs(fY1 - fY)) ? fY0 : fY1;
			fZN = (math.abs(fZ0 - fZ) < math.abs(fZ1 - fZ)) ? fZ0 : fZ1;

			return math.sqrt((fXN - fX)*(fXN - fX) + (fYN - fY)*(fYN - fY) + (fZN - fZ)*(fZN - fZ));
		};

		toString(): string{
			return "(" + this.x0 + ", " + this.y0 + ", " + this.z0 + ") --> (" +
					this.x1 + ", " + this.y1 + ", " + this.z1 +")";
		};

		static get stackCeil(): Rect3d { Rect3d.stackPosition = Rect3d.stackPosition === Rect3d.stackSize - 1? 0: Rect3d.stackPosition; return Rect3d.stack[Rect3d.stackPosition ++]; } static stackSize: number = 128; static stackPosition: number = 0; static stack: Rect3d[] = (function(): Rect3d[]{ var pStack: Rect3d[] = new Array(Rect3d.stackSize); for(var i: number = 0; i<Rect3d.stackSize; i++){ pStack[i] = new Rect3d(); } return pStack})(); ;
    }
}





module akra.scene {

	export enum ESceneObjectFlags {
		k_NewLocalBounds = 0,
		k_NewWorldBounds
	};

	export enum EObjectViewModes {
        k_Shadows = 0x01,
        k_Billboard = 0x02
    }

	export class SceneObject extends SceneNode implements ISceneObject {
		protected _iObjectFlags:  number  = 0;
		protected _pLocalBounds: IRect3d = new geometry.Rect3d();
		protected _pWorldBounds: IRect3d = new geometry.Rect3d();
		protected _iViewModes:  number  = 0;


		/**@inline*/  get totalRenderable():  number  { return 0; }

		/**@inline*/  get worldBounds(): IRect3d {
			return this._pWorldBounds;
		}

		/**@inline*/  set worldBounds(pBox: IRect3d) {
			this._pWorldBounds = pBox;
		}

		/**@inline*/  get localBounds(): IRect3d {
			return this._pLocalBounds;
		}

		/**@inline*/  set onclick(
			fn: (pObject: ISceneObject, pViewport: IViewport,
				pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "click" , fn);
        }

        /**@inline*/  set onmousemove(
        	fn: (pObject: ISceneObject, pViewport: IViewport,
        		pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "mousemove" , fn);
        }

        /**@inline*/  set onmousedown(
        	fn: (pObject: ISceneObject, pViewport: IViewport,
        		pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "mousedown" , fn);
        }

        /**@inline*/  set onmouseup(
        	fn: (pObject: ISceneObject, pViewport: IViewport,
        		pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "mouseup" , fn);
        }

        /**@inline*/  set onmouseover(
        	fn: (pObject: ISceneObject, pViewport: IViewport,
        		pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "mouseover" , fn);
        }

        /**@inline*/  set onmouseout(
        	fn: (pObject: ISceneObject, pViewport: IViewport,
        		pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "mouseout" , fn);
        }

        /**@inline*/  set ondragstart(
        	fn: (pObject: ISceneObject, pViewport: IViewport,
        		pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "dragstart" , fn);
        }

        /**@inline*/  set ondragstop(
        	fn: (pObject: ISceneObject, pViewport: IViewport,
        		pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "dragstop" , fn);
        }

        /**@inline*/  set ondragging(
        	fn: (pObject: ISceneObject, pViewport: IViewport,
        		pRenderable: IRenderableObject, x:  number , y:  number ) => void) {
        	this.bind( "dragging" , fn);
        }


		constructor (pScene: IScene3d, eType: EEntityTypes = EEntityTypes.SCENE_OBJECT) {
			super(pScene, eType);
		}

		getRenderable(i?:  number ): IRenderableObject {
			return null;
		}

		accessLocalBounds(): IRect3d {
			((this._iObjectFlags) |= (1 << ((ESceneObjectFlags.k_NewLocalBounds))) ) ;
			return this._pLocalBounds;
		}

		/**@inline*/  isWorldBoundsNew(): bool {
			return  ((this._iObjectFlags & (1 << (ESceneObjectFlags.k_NewLocalBounds)) ) != 0) ;
		}

		destroy(): void {
			super.destroy();
		}

		prepareForUpdate(): void {
			super.prepareForUpdate();

			((this._iObjectFlags) &= ~( (1 << (ESceneObjectFlags.k_NewLocalBounds)) | (1 << (ESceneObjectFlags.k_NewWorldBounds)) ))
                                                                                        ;
		}

		update(): bool {
//если, обновится мировая матрица узла, то и AABB обновится 
			super.update();
// do we need to update our local matrix?
// derived classes update the local matrix
// then call this base function to complete
// the update
		    return this.recalcWorldBounds();
		}

		private recalcWorldBounds(): bool {
// nodes only get their bounds updated
// as nessesary
		    if (( ((this._iObjectFlags & (1 << (ESceneObjectFlags.k_NewLocalBounds)) ) != 0)
		    		        || this.isWorldMatrixNew())) {
// transform our local rectangle 
// by the current world matrix
		        this._pWorldBounds.set(this._pLocalBounds);
// make sure we have some degree of thickness
		        if (true) {
		            this._pWorldBounds.x1 = Math.max(this._pWorldBounds.x1, this._pWorldBounds.x0 + 0.01);
		            this._pWorldBounds.y1 = Math.max(this._pWorldBounds.y1, this._pWorldBounds.y0 + 0.01);
		            this._pWorldBounds.z1 = Math.max(this._pWorldBounds.z1, this._pWorldBounds.z0 + 0.01);
		        }
		        this._pWorldBounds.transform(this.worldMatrix);

// set the flag that our bounding box has changed
		        ((this._iObjectFlags) |= (1 << ((ESceneObjectFlags.k_NewWorldBounds))) ) ;

		        this.worldBoundsUpdated();

		        return true;
		    }

		    return false;
		}

    	/**@inline*/  get shadow(): bool {
    		return (this._iViewModes & EObjectViewModes.k_Shadows) != 0;
    	};

    	/**@inline*/  set shadow(bValue: bool) {
    		bValue ?  ((this._iViewModes) |= (EObjectViewModes.k_Shadows))  :  ((this._iViewModes) &= ~(EObjectViewModes.k_Shadows)) ;

    		for(var i:  number  = 0; i < this.totalRenderable; i++){
    			(<IRenderableObject>this.getRenderable(i)).shadow = bValue;
    		}
    	};

    	/**@inline*/  set billboard(bValue: bool) {
    		bValue ?  ((this._iViewModes) |= (EObjectViewModes.k_Billboard))  :  ((this._iViewModes) &= ~(EObjectViewModes.k_Billboard)) ;
    	}

    	/**@inline*/  get billboard(): bool {
    		return (this._iViewModes & EObjectViewModes.k_Billboard) != 0;
    	}

    	/**@inline*/  isBillboard(): bool {
			return this.billboard;
		}

    	getObjectFlags():  number  {
    		return this._iObjectFlags;
    	}

    	/**@inline*/  prepareForRender(pViewport: IViewport): void {}

    	toString(isRecursive: bool = false, iDepth:  number  = 0): string {

			if (!isRecursive) {
/* + " height: " + this.worldPosition.y*/
		        return "<scene_object" + (this._sName ? " " + this._sName : "") + ">"                                         ;
		    }

		    return super.toString(isRecursive, iDepth);

    	}


		worldBoundsUpdated (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).worldBoundsUpdated; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;

		click (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).click; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;

		mousemove (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousemove; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;
		mousedown (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousedown; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;
		mouseup (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseup; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;
		mouseover (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseover; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;
		mouseout (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseout; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;

		dragstart (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragstart; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;
		dragstop (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragstop; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;
		dragging (pViewport, pRenderable, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragging; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pRenderable, x, y) : _broadcast[i].listener (_recivier, pViewport, pRenderable, x, y) ; } } } ; ;
	}

	export  /**@inline*/  function isSceneObject(pEntity: IEntity): bool {
		return !isNull(pEntity) && pEntity.type >= EEntityTypes.SCENE_OBJECT && pEntity.type < EEntityTypes.OBJECTS_LIMIT;
	}
}




















module akra{

	;

	export interface IPlane3d{
		normal: IVec3;
		distance:  number ;

		set(): IPlane3d;
		set(pPlane: IPlane3d): IPlane3d;
		set(v3fNormal: IVec3, fDistance:  number ): IPlane3d;
		set(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3): IPlane3d;

		clear(): IPlane3d;

		negate(): IPlane3d;

		normalize(): IPlane3d;

		isEqual(pPlane: IPlane3d): bool;

		projectPointToPlane(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3;

		intersectRay3d(pRay: IRay3d, vDest: IVec3): bool;

		solveForX(fY:  number , fZ:  number ):  number ;
		solveForY(fX:  number , fZ:  number ):  number ;
		solveForZ(fX:  number , fY:  number ):  number ;

		signedDistance(v3fPoint: IVec3):  number ;

		toString(): string;
	};
}



module akra.geometry{
	export class Plane3d implements IPlane3d{
		normal: IVec3;
		distance:  number ;

		constructor();
		constructor(pPlane: IPlane3d);
		constructor(v3fNormal: IVec3, fDistance:  number );
		constructor(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3);
		constructor(v3fPoint1?, v3fPoint2?, v3fPoint3?){

			this.normal = new Vec3();
			this.distance = 0.;

			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				default:
					break;
			}
		};

		set(): IPlane3d;
		set(pPlane: IPlane3d): IPlane3d;
		set(v3fNormal: IVec3, fDistance:  number ): IPlane3d;
		set(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3): IPlane3d;
		set(): IPlane3d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pPlane: IPlane3d = arguments[0];

					this.normal.set(pPlane.normal);
					this.distance = pPlane.distance;
					break;
				case 2:
					this.normal.set(arguments[0]);
					this.distance = arguments[1];
					break;
				case 3:
					var v3fPoint1: IVec3 = arguments[0];
					var v3fPoint2: IVec3 = arguments[1];
					var v3fPoint3: IVec3 = arguments[2];

					var x1:  number  = v3fPoint2.x - v3fPoint1.x;
					var y1:  number  = v3fPoint2.y - v3fPoint1.y;
					var z1:  number  = v3fPoint2.z - v3fPoint1.z;

					var x2:  number  = v3fPoint3.x - v3fPoint1.x;
					var y2:  number  = v3fPoint3.y - v3fPoint1.y;
					var z2:  number  = v3fPoint3.z - v3fPoint1.z;

					var x:  number  = y1*z2 - y2*z1;
					var y:  number  = z1*x2 - z2*x1;
					var z:  number  = x1*y2 - x2*y1;

					this.distance = -(x*v3fPoint1.x + y*v3fPoint1.y + z*v3fPoint1.z);
					this.normal.set(x,y,z);

					break;
				default:
					this.normal.clear();
					this.distance = 0.;
					break;
			}

			return this.normalize();
		};

		/**@inline*/  clear(): IPlane3d{
			this.normal.clear();
			this.distance = 0.;
			return this;
		};

		/**@inline*/  negate(): IPlane3d{
			this.normal.negate();
			this.distance = -this.distance;
			return this;
		};

		normalize(): IPlane3d{
			var v3fNormal: IVec3 = this.normal;
			var x:  number  = v3fNormal.x, y:  number  = v3fNormal.y, z:  number  = v3fNormal.z;

			var fLength:  number  = math.sqrt(x*x + y*y + z*z);

			if(fLength !== 0.){
				var fInvLength = 1./fLength;

				v3fNormal.x = x*fInvLength;
				v3fNormal.y = y*fInvLength;
				v3fNormal.z = z*fInvLength;

				this.distance *= fInvLength;
			}

			return this;
		};

		isEqual(pPlane: IPlane3d): bool{
			return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
		};

/*предполагается работа только с нормализованной плоскостью*/

		projectPointToPlane(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var v3fNormal: IVec3 = this.normal;
			var fDistance:  number  = this.distance + v3fNormal.dot(v3fPoint);

			v3fDestination.x = v3fPoint.x - fDistance*v3fNormal.x;
			v3fDestination.y = v3fPoint.y - fDistance*v3fNormal.y;
			v3fDestination.z = v3fPoint.z - fDistance*v3fNormal.z;

			return v3fDestination;
		};

		solveForX(fY:  number , fZ:  number ):  number {
/*Ax+By+Cz+D=0;
			x = -(D+By+Cz)/A;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.x !== 0.){
				return -(this.distance + v3fNormal.y*fY + v3fNormal.z*fZ)/v3fNormal.x;
			}
			return 0.;
		};

		solveForY(fX:  number , fZ:  number ):  number {
/*Ax+By+Cz+D=0;
			y = -(D+Ax+Cz)/B;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.y !== 0.){
				return -(this.distance + v3fNormal.x*fX + v3fNormal.z*fZ)/v3fNormal.y;
			}
			return 0.;
		};

		solveForZ(fX:  number , fY:  number ):  number {
/*Ax+By+Cz+D=0;
			z = -(D+Ax+By)/C;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.z !== 0.){
				return -(this.distance + v3fNormal.x*fX + v3fNormal.y*fY)/v3fNormal.z;
			}

			return 0.;
		};

		intersectRay3d(pRay: IRay3d, vDest: IVec3): bool {
			if (!intersectPlane3dRay3d(this, pRay)) {
				return false;
			}

			var r0: IVec3 = pRay.point;
			var n: IVec3 = this.normal;
			var l: IVec3 = pRay.normal;
			var d:  number  = this.distance;

			var t0:  number  = -(r0.dot(n) + d) / (l.dot(n));

			vDest.set(r0.x + l.x * t0, r0.y + l.y * t0, r0.z + l.z * t0);
			return true;
		}

		signedDistance(v3fPoint: IVec3):  number {
			return this.distance + this.normal.dot(v3fPoint);
		};

		toString(): string{
			return "normal: " + this.normal.toString() + "; distance: " + this.distance;
		};
	};
};




















module akra{

	;
	;

	export interface IPlane2d{
		normal: IVec2;
		distance:  number ;

		set(): IPlane2d;
		set(pPlane: IPlane2d): IPlane2d;
		set(v2fNormal: IVec2, fDistance:  number ): IPlane2d;
		set(v2fPoint1: IVec2, v2fPoint2: IVec2): IPlane2d;

		clear(): IPlane2d;

		negate(): IPlane2d;

		normalize(): IPlane2d;

		isEqual(pPlane: IPlane2d): bool;

		projectPointToPlane(v2fPoint: IVec2, v2fDestination?: IVec2): IVec2;

		solveForX(fY:  number ):  number ;
		solveForY(fX:  number ):  number ;

		signedDistance(v2fPoint):  number ;

		toString(): string;
	}
}



module akra.geometry{
	export class Plane2d implements IPlane2d{
		normal: IVec2;
		distance:  number ;

		constructor();
		constructor(pPlane: IPlane2d);
		constructor(v2fNormal: IVec2, fDistance:  number );
		constructor(v2fPoint1: IVec2, v2fPoint2: IVec2);
		constructor(v2fPoint1?, v2fPoint2?){

			this.normal = new Vec2();
			this.distance = 0.;

			var nArgumentsLength = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				default:
					break;
			}
		};

		set(): IPlane2d;
		set(pPlane: IPlane2d): IPlane2d;
		set(v2fNormal: IVec2, fDistance:  number ): IPlane2d;
		set(v2fPoint1: IVec2, v2fPoint2: IVec2): IPlane2d;
		set(v2fPoint1?, v2fPoint2?): IPlane2d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pPlane: IPlane2d = arguments[0];

					this.normal.set(pPlane.normal);
					this.distance = pPlane.distance;
					break;
				case 2:
					if(isFloat(arguments[1])){
						this.normal.set(arguments[0]);
						this.distance = arguments[1];
					}
					else{
						var v2fLine: IVec2 =  Vec2.stackCeil.set(<IVec2>arguments[1]) .subtract(arguments[0]);
						var v2fNormal: IVec2 = this.normal;

						v2fNormal.set(-v2fLine.y, v2fLine.x);
						this.distance = -v2fNormal.dot(arguments[0]);
					}
					break;
				default:
					this.normal.clear();
					this.distance = 0.;
					break;
			}

			return this.normalize();
		};

		/**@inline*/  clear(): IPlane2d{
			this.normal.clear();
			this.distance = 0.;
			return this;
		};

		/**@inline*/  negate(): IPlane2d{
			this.normal.negate();
			this.distance = -this.distance;
			return this;
		};

		normalize(): IPlane2d{
			var v2fNormal: IVec2 = this.normal;

			var x:  number  = v2fNormal.x;
			var y:  number  = v2fNormal.y

			var fLength:  number  = math.sqrt(x*x + y*y);

			if(fLength !== 0.){
				var fInvLength:  number  = 1./fLength;

				v2fNormal.x = x*fInvLength;
				v2fNormal.y = y*fInvLength;

				this.distance = this.distance*fInvLength;
			}

			return this;
		};

		/**@inline*/  isEqual(pPlane: IPlane2d): bool{
			return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
		};

/*предполагается работа только с нормализованной плоскостью*/

		projectPointToPlane(v2fPoint: IVec2, v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			var v2fNormal: IVec2 = this.normal;
			var fDistance:  number  = this.distance + v2fNormal.dot(v2fPoint);

			v2fDestination.x = v2fPoint.x - fDistance*v2fNormal.x;
			v2fDestination.y = v2fPoint.y - fDistance*v2fNormal.y;

			return v2fDestination;
		};

		solveForX(fY:  number ):  number {
/*Ax+By+d=0;
			x=-(d+By)/A;*/


			var v2fNormal: IVec2 = this.normal;

			if(v2fNormal.x !== 0.){
				return -(this.distance + v2fNormal.y*fY)/v2fNormal.x;
			}
			return 0.;
		};

		solveForY(fX:  number ):  number {
/*Ax+By+d=0;
			y=-(d+Ax)/B;*/


			var v2fNormal: IVec2 = this.normal;

			if(v2fNormal.y !== 0.){
				return -(this.distance + v2fNormal.x*fX)/v2fNormal.y;
			}
			return 0.;
		};

/*предполагается работа только с нормализованной плоскостью*/

		/**@inline*/  signedDistance(v2fPoint: IVec2):  number {
			return this.distance + this.normal.dot(v2fPoint);
		};

		toString(): string{
			return "normal: " + this.normal.toString() + "; distance: " + this.distance;
		};
	};
}







module akra{
	export enum EVolumeClassifications{
		NO_RELATION = 0,
		EQUAL,
		A_CONTAINS_B,
		B_CONTAINS_A,
		INTERSECTING
	};

	export enum EPlaneClassifications{
/**
		 * ax+by+cz+d=0
		 * PLANE_FRONT - объект находится перед плоскостью, то есть по направлению нормали
		 * PLANE_BACK - объект находится за плостостью, то есть против направления нормали
		 */

		PLANE_FRONT = 0,
		PLANE_BACK,
		PLANE_INTERSECT
	};
}

module akra.geometry{

	export function planeClassifyCircle(pPlane: IPlane2d, pCircle: ICircle): EPlaneClassifications{
		var fDistance:  number  = pPlane.signedDistance(pCircle.center);
		var fRadius:  number  = pCircle.radius;

		if(fDistance > fRadius){
			return EPlaneClassifications.PLANE_FRONT;
		}
		else if(fDistance < -fRadius){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_INTERSECT;
		}
	};

	export function planeClassifySphere(pPlane: IPlane3d, pSphere: ISphere): EPlaneClassifications{
		var fDistance:  number  = pPlane.signedDistance(pSphere.center);
		var fRadius:  number  = pSphere.radius;

		if(fDistance > fRadius){
			return EPlaneClassifications.PLANE_FRONT;
		}
		else if(fDistance < -fRadius){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_INTERSECT;
		}
	};

	export function planeClassifyRect2d(pPlane: IPlane2d, pRect: IRect2d): EPlaneClassifications{
		var v2fMinPoint: IVec2 =  Vec2.stackCeil.set() ;
		var v2fMaxPoint: IVec2 =  Vec2.stackCeil.set() ;

		var v2fNormal: IVec2 = pPlane.normal;

		if(v2fNormal.x > 0.){
			v2fMinPoint.x = pRect.x0;
			v2fMaxPoint.x = pRect.x1;
		}
		else{
			v2fMinPoint.x = pRect.x1;
			v2fMaxPoint.x = pRect.x0;
		}

		if(v2fNormal.y > 0.){
			v2fMinPoint.y = pRect.y0;
			v2fMaxPoint.y = pRect.y1;
		}
		else{
			v2fMinPoint.y = pRect.y1;
			v2fMaxPoint.y = pRect.y0;
		}

		var fMinDistance:  number  = pPlane.signedDistance(v2fMinPoint);
		var fMaxDistance:  number  = pPlane.signedDistance(v2fMaxPoint);

		if(fMinDistance*fMaxDistance <= 0.){
			return EPlaneClassifications.PLANE_INTERSECT;
		}
		else if (fMaxDistance < 0.){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_FRONT;
		}
	};

	export function planeClassifyRect3d(pPlane: IPlane3d, pRect: IRect3d): EPlaneClassifications{
		var v3fMinPoint: IVec3 =  Vec3.stackCeil.set() ;
		var v3fMaxPoint: IVec3 =  Vec3.stackCeil.set() ;

		var v3fNormal: IVec3 = pPlane.normal;

		if(v3fNormal.x > 0.){
			v3fMinPoint.x = pRect.x0;
			v3fMaxPoint.x = pRect.x1;
		}
		else{
			v3fMinPoint.x = pRect.x1;
			v3fMaxPoint.x = pRect.x0;
		}

		if(v3fNormal.y > 0.){
			v3fMinPoint.y = pRect.y0;
			v3fMaxPoint.y = pRect.y1;
		}
		else{
			v3fMinPoint.y = pRect.y1;
			v3fMaxPoint.y = pRect.y0;
		}

		if(v3fNormal.z > 0.){
			v3fMinPoint.z = pRect.z0;
			v3fMaxPoint.z = pRect.z1;
		}
		else{
			v3fMinPoint.z = pRect.z1;
			v3fMaxPoint.z = pRect.z0;
		}

		var fMinDistance:  number  = pPlane.signedDistance(v3fMinPoint);
		var fMaxDistance:  number  = pPlane.signedDistance(v3fMaxPoint);

		if(fMinDistance*fMaxDistance <= 0.){
			return EPlaneClassifications.PLANE_INTERSECT;
		}
		else if (fMaxDistance <= 0.){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_FRONT;
		}
	};

	export function planeClassify(pPlane: IPlane2d, pCircle: ICircle): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane3d, pSphere: ISphere): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane2d, pRect: IRect2d): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane3d, pRect: IRect3d): EPlaneClassifications;
	export function planeClassify(pPlane?, pRect?): EPlaneClassifications{
		var pArg0: any = arguments[0];
		var pArg1: any = arguments[1];

		if(pArg0 instanceof Plane2d){
			if(pArg1 instanceof Circle){
				return planeClassifyCircle(pArg0, pArg1);
			}
			else{
				return planeClassifyRect2d(pArg0, pArg1);
			}
		}
		else{
			if(pArg1 instanceof Sphere){
				return planeClassifySphere(pArg0, pArg1);
			}
			else{
				return planeClassifyRect3d(pArg0, pArg1);
			}
		}
	};

	export function classifyRect2d(pRectA: IRect2d, pRectB: IRect2d): EVolumeClassifications{
		var fRectAX0:  number  = pRectA.x0, fRectAX1:  number  = pRectA.x1;
		var fRectAY0:  number  = pRectA.y0, fRectAY1:  number  = pRectA.y1;

		var fRectBX0:  number  = pRectB.x0, fRectBX1:  number  = pRectB.x1;
		var fRectBY0:  number  = pRectB.y0, fRectBY1:  number  = pRectB.y1;

		if((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0)
			|| (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)){

			return EVolumeClassifications.NO_RELATION;
		}

		if((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1)
			&& (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)){

			return EVolumeClassifications.EQUAL;
		}

		if((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1)
			 && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)){

			return EVolumeClassifications.A_CONTAINS_B;
		}

		if((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1)
			&& (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)){

			return EVolumeClassifications.B_CONTAINS_A;
		}

		return EVolumeClassifications.INTERSECTING;
	};

	export function classifyRect3d(pRectA: IRect3d, pRectB: IRect3d): EVolumeClassifications{
		var fRectAX0:  number  = pRectA.x0, fRectAX1:  number  = pRectA.x1;
		var fRectAY0:  number  = pRectA.y0, fRectAY1:  number  = pRectA.y1;
		var fRectAZ0:  number  = pRectA.z0, fRectAZ1:  number  = pRectA.z1;

		var fRectBX0:  number  = pRectB.x0, fRectBX1:  number  = pRectB.x1;
		var fRectBY0:  number  = pRectB.y0, fRectBY1:  number  = pRectB.y1;
		var fRectBZ0:  number  = pRectB.z0, fRectBZ1:  number  = pRectB.z1;

		if((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0)
			|| (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)
			|| (fRectAZ1 < fRectBZ0 || fRectAZ1 < fRectBZ0)){

			return EVolumeClassifications.NO_RELATION;
		}

		if((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1)
			&& (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)
			&& (fRectAZ0 == fRectBZ0 && fRectAZ1 == fRectBZ1)){

			return EVolumeClassifications.EQUAL;
		}

		if((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1)
			 && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)
			 && (fRectAZ0 <= fRectBZ0 && fRectBZ1 <= fRectAZ1)){

			return EVolumeClassifications.A_CONTAINS_B;
		}

		if((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1)
			&& (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)
			&& (fRectBZ0 <= fRectAZ0 && fRectAZ1 <= fRectBZ1)){

			return EVolumeClassifications.B_CONTAINS_A;
		}

		return EVolumeClassifications.INTERSECTING;
	};

	export function classifyFrustumRect3d(pFrustum: IFrustum, pRect: IRect3d){
		var kClassification: EPlaneClassifications;
		var isIntersect: bool = false;

		kClassification = planeClassifyRect3d(pFrustum.leftPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.rightPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.topPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.bottomPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.nearPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.farPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		if(isIntersect){
			return EVolumeClassifications.INTERSECTING;
		}
		else{
			return EVolumeClassifications.A_CONTAINS_B;
		}
	};

}






module akra{

	;
	;
	;
	;
	;

	export interface IFrustum{
		leftPlane: IPlane3d;
		rightPlane: IPlane3d;
		topPlane: IPlane3d;
		bottomPlane: IPlane3d;
		nearPlane: IPlane3d;
		farPlane: IPlane3d;

		 frustumVertices: IVec3[];

		set(): IFrustum;
		set(pFrustum: IFrustum): IFrustum;
		set(pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
			pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
			pNearPlane: IPlane3d, pFarPlane: IPlane3d): IFrustum;

		calculateFrustumVertices(): IVec3[];
		extractFromMatrix(m4fProjection: IMat4, m4fWorld?: IMat4, pSearchRect?: IRect3d): IFrustum;

		isEqual(pFrustum: IFrustum): bool;

		getPlanePoints(sPlaneKey: string, pDestination?: IVec3[]): IVec3[];

		testPoint(v3fPoint: IVec3): bool;
		testRect(pRect: IRect3): bool;
		testSphere(pSphere: ISphere): bool;
		testFrustum(pFrustum: IFrustum): bool;

		getViewDirection(v3fDirection?: IVec3): IVec3;

		toString(): string;
	};
};



module akra.geometry{
	export class Frustum implements IFrustum {
		leftPlane: IPlane3d;
		rightPlane: IPlane3d;
		topPlane: IPlane3d;
		bottomPlane: IPlane3d;
		nearPlane: IPlane3d;
		farPlane: IPlane3d;

		_pFrustumVertices: IVec3[] = null;

		constructor ();
		constructor (pFrustum: IFrustum);
		constructor (pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
					pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
					pNearPlane: IPlane3d, pFarPlane: IPlane3d);
		constructor (pLeftPlane?,pRightPlane?,pTopPlane?,
					pBottomPlane?, pNearPlane?, pFarPlane?) {

			this.leftPlane = new Plane3d();
			this.rightPlane = new Plane3d();
			this.topPlane = new Plane3d();
			this.bottomPlane = new Plane3d();
			this.nearPlane = new Plane3d();
			this.farPlane = new Plane3d();

			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 6:
					this.set(arguments[0], arguments[1], arguments[2],
							 arguments[3], arguments[4], arguments[5]);
					break;
				default:
					break;
			}
		};

		/**@inline*/  get frustumVertices(): IVec3[]{
			return this._pFrustumVertices;
		};

		set(): IFrustum;
		set(pFrustum: IFrustum): IFrustum;
		set(pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
			pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
			pNearPlane: IPlane3d, pFarPlane: IPlane3d): IFrustum;
		set(pLeftPlane?, pRightPlane?, pTopPlane?,
			pBottomPlane?, pNearPlane?, pFarPlane?): IFrustum {

			var nArgumentsLength = arguments.length;

			switch(nArgumentsLength) {
				case 1:
					var pFrustum: IFrustum = arguments[0];

					this.leftPlane.set(pFrustum.leftPlane);
					this.rightPlane.set(pFrustum.rightPlane);
					this.topPlane.set(pFrustum.topPlane);
					this.bottomPlane.set(pFrustum.bottomPlane);
					this.nearPlane.set(pFrustum.nearPlane);
					this.farPlane.set(pFrustum.farPlane);
					break;
				case 6:
					this.leftPlane.set(arguments[0]);
					this.rightPlane.set(arguments[1]);
					this.topPlane.set(arguments[2]);
					this.bottomPlane.set(arguments[3]);
					this.nearPlane.set(arguments[4]);
					this.farPlane.set(arguments[5]);
					break;
				default:
					this.leftPlane.clear();
					this.rightPlane.clear();
					this.topPlane.clear();
					this.bottomPlane.clear();
					this.nearPlane.clear();
					this.farPlane.clear();
					break;
			}

			return this;
		};

		calculateFrustumVertices(): IVec3[]{
			if(this._pFrustumVertices == null){
				this._pFrustumVertices = new Array(8);

				for(var i: number  = 0; i < 8; i++){
					this._pFrustumVertices[i] = new Vec3();
				}
			}

			var v3fLeftNormal: IVec3 = this.leftPlane.normal;
			var v3fRightNormal: IVec3 = this.rightPlane.normal;
			var v3fTopNormal: IVec3 = this.topPlane.normal;
			var v3fBottomNormal: IVec3 = this.bottomPlane.normal;
			var v3fNearNormal: IVec3 = this.nearPlane.normal;
			var v3fFarNormal: IVec3 = this.farPlane.normal;

			var fLeft:  number  = -this.leftPlane.distance;
			var fRight:  number  = -this.rightPlane.distance;
			var fTop:  number  = -this.topPlane.distance;
			var fBottom:  number  = -this.bottomPlane.distance;
			var fNear:  number  = -this.nearPlane.distance;
			var fFar:  number  = -this.farPlane.distance;

			var m3fTemp: IMat3 =  Mat3.stackCeil.set() ;
			var pFrustumVertices: IVec3[] = this._pFrustumVertices;

//first left-bottom-near
			pFrustumVertices[0].set(fLeft, fBottom, fNear);
/*first colomn, not row*/
			m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fNearNormal.x,
						v3fLeftNormal.y, v3fBottomNormal.y, v3fNearNormal.y,
						v3fLeftNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[0]);

//second right-bottom-near
			pFrustumVertices[1].set(fRight, fBottom, fNear);
/*first colomn, not row*/
			m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fNearNormal.x,
						v3fRightNormal.y, v3fBottomNormal.y, v3fNearNormal.y,
						v3fRightNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[1]);

//third left-top-near
			pFrustumVertices[2].set(fLeft, fTop, fNear);
/*first colomn, not row*/
			m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fNearNormal.x,
						v3fLeftNormal.y, v3fTopNormal.y, v3fNearNormal.y,
						v3fLeftNormal.z, v3fTopNormal.z, v3fNearNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[2]);

//forth right-top-near
			pFrustumVertices[3].set(fRight, fTop, fNear);
/*first colomn, not row*/
			m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fNearNormal.x,
						v3fRightNormal.y, v3fTopNormal.y, v3fNearNormal.y,
						v3fRightNormal.z, v3fTopNormal.z, v3fNearNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[3]);

//fifth left-bottom-far
			pFrustumVertices[4].set(fLeft, fBottom, fFar);
/*first colomn, not row*/
			m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fFarNormal.x,
						v3fLeftNormal.y, v3fBottomNormal.y, v3fFarNormal.y,
						v3fLeftNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[4]);

//sixth right-bottom-far
			pFrustumVertices[5].set(fRight, fBottom, fFar);
/*first colomn, not row*/
			m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fFarNormal.x,
						v3fRightNormal.y, v3fBottomNormal.y, v3fFarNormal.y,
						v3fRightNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[5]);

//seventh left-top-far
			pFrustumVertices[6].set(fLeft, fTop, fFar);
/*first colomn, not row*/
			m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fFarNormal.x,
						v3fLeftNormal.y, v3fTopNormal.y, v3fFarNormal.y,
						v3fLeftNormal.z, v3fTopNormal.z, v3fFarNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[6]);

//eighth right-top-far
			pFrustumVertices[7].set(fRight, fTop, fFar);
/*first colomn, not row*/
			m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fFarNormal.x,
						v3fRightNormal.y, v3fTopNormal.y, v3fFarNormal.y,
						v3fRightNormal.z, v3fTopNormal.z, v3fFarNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[7]);

			return pFrustumVertices;
		};

		extractFromMatrix(m4fProjection: IMat4, m4fWorld?: IMat4, pSearchRect?: IRect3d): IFrustum{

			if(isNull(this._pFrustumVertices)){
				this._pFrustumVertices = new Array(8);

				for(var i: number  = 0; i < 8; i++){
					this._pFrustumVertices[i] = new Vec3();
				}
			}

			var pFrustumVertices: IVec3[] = this._pFrustumVertices;

			var v4fLeftBottomNear: IVec4 =  Vec4.stackCeil.set() ;
			var v4fRightBottomNear: IVec4 =  Vec4.stackCeil.set() ;
			var v4fLeftTopNear: IVec4 =  Vec4.stackCeil.set() ;
			var v4fRightTopNear: IVec4 =  Vec4.stackCeil.set() ;

			var v4fLeftBottomFar: IVec4 =  Vec4.stackCeil.set() ;
			var v4fRightBottomFar: IVec4 =  Vec4.stackCeil.set() ;
			var v4fLeftTopFar: IVec4 =  Vec4.stackCeil.set() ;
			var v4fRightTopFar: IVec4 =  Vec4.stackCeil.set() ;

			m4fProjection.unproj( Vec3.stackCeil.set(-1,-1,-1) , v4fLeftBottomNear);
		    m4fProjection.unproj( Vec3.stackCeil.set(1,-1,-1) , v4fRightBottomNear);
		    m4fProjection.unproj( Vec3.stackCeil.set(-1,1,-1) , v4fLeftTopNear);
		    m4fProjection.unproj( Vec3.stackCeil.set(1,1,-1) , v4fRightTopNear);

		    m4fProjection.unproj( Vec3.stackCeil.set(-1,-1,1) , v4fLeftBottomFar);
		    m4fProjection.unproj( Vec3.stackCeil.set(1,-1,1) , v4fRightBottomFar);
		    m4fProjection.unproj( Vec3.stackCeil.set(-1,1,1) , v4fLeftTopFar);
		    m4fProjection.unproj( Vec3.stackCeil.set(1,1,1) , v4fRightTopFar);

		    if(isDef(m4fWorld)){
		    	m4fWorld.multiplyVec4(v4fLeftBottomNear);
		    	m4fWorld.multiplyVec4(v4fRightBottomNear);
		    	m4fWorld.multiplyVec4(v4fLeftTopNear);
		    	m4fWorld.multiplyVec4(v4fRightTopNear);

		    	m4fWorld.multiplyVec4(v4fLeftBottomFar);
		    	m4fWorld.multiplyVec4(v4fRightBottomFar);
		    	m4fWorld.multiplyVec4(v4fLeftTopFar);
		    	m4fWorld.multiplyVec4(v4fRightTopFar);
		    }

		    var v3fLeftBottomNear: IVec3 = pFrustumVertices[0].set(v4fLeftBottomNear.xyz);
		    var v3fRightBottomNear: IVec3 = pFrustumVertices[1].set(v4fRightBottomNear.xyz);
		    var v3fLeftTopNear: IVec3 = pFrustumVertices[2].set(v4fLeftTopNear.xyz);
		    var v3fRightTopNear: IVec3 = pFrustumVertices[3].set(v4fRightTopNear.xyz);

		    var v3fLeftBottomFar: IVec3 = pFrustumVertices[4].set(v4fLeftBottomFar.xyz);
		    var v3fRightBottomFar: IVec3 = pFrustumVertices[5].set(v4fRightBottomFar.xyz);
		    var v3fLeftTopFar: IVec3 = pFrustumVertices[6].set(v4fLeftTopFar.xyz);
		    var v3fRightTopFar: IVec3 = pFrustumVertices[7].set(v4fRightTopFar.xyz);

//filling search rectangle

		    if(isDef(pSearchRect)){
		    	pSearchRect.set(v3fLeftBottomNear, v3fLeftBottomNear);

		    	pSearchRect.unionPoint(v3fRightBottomNear);
		    	pSearchRect.unionPoint(v3fLeftTopNear);
		    	pSearchRect.unionPoint(v3fRightTopNear);

		    	pSearchRect.unionPoint(v3fLeftBottomFar);
		    	pSearchRect.unionPoint(v3fRightBottomFar);
		    	pSearchRect.unionPoint(v3fLeftTopFar);
		    	pSearchRect.unionPoint(v3fRightTopFar);
		    }

//calculating planes

		    this.leftPlane.set(v3fLeftTopNear, v3fLeftTopFar, v3fLeftBottomNear);
			this.rightPlane.set(v3fRightBottomFar, v3fRightTopFar, v3fRightBottomNear);
			this.topPlane.set(v3fLeftTopNear, v3fRightTopNear, v3fLeftTopFar);
			this.bottomPlane.set(v3fRightBottomFar, v3fRightBottomNear, v3fLeftBottomFar);
			this.nearPlane.set(v3fLeftTopNear, v3fLeftBottomNear, v3fRightTopNear);
			this.farPlane.set(v3fRightBottomFar, v3fLeftBottomFar, v3fRightTopFar);

			return this;
		};

		/**@inline*/  isEqual(pFrustum: IFrustum): bool{
			return (this.leftPlane.isEqual(pFrustum.leftPlane)
				&& this.rightPlane.isEqual(pFrustum.rightPlane)
				&& this.topPlane.isEqual(pFrustum.topPlane)
				&& this.bottomPlane.isEqual(pFrustum.bottomPlane)
				&& this.nearPlane.isEqual(pFrustum.nearPlane)
				&& this.farPlane.isEqual(pFrustum.farPlane));
		};

//output - array of vertices in counterclockwise order (around plane normal as axis)
//if destination don't submitted returned array from temp vectors
		getPlanePoints(sPlaneKey: string, pDestination?: IVec3[]): IVec3[]{
			var pPoints: IVec3[] = (arguments.length === 2) ? pDestination : [ Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ];

			var pFrustumVertices: IVec3[] = this.frustumVertices;
			if(pFrustumVertices === null){
				pFrustumVertices = this.calculateFrustumVertices();
			}

			switch(sPlaneKey){
				case "leftPlane":
					pPoints[0].set(pFrustumVertices[6]);
					pPoints[1].set(pFrustumVertices[4]);
					pPoints[2].set(pFrustumVertices[0]);
					pPoints[3].set(pFrustumVertices[2]);
					break;
				case "rightPlane":
					pPoints[0].set(pFrustumVertices[7]);
					pPoints[1].set(pFrustumVertices[3]);
					pPoints[2].set(pFrustumVertices[1]);
					pPoints[3].set(pFrustumVertices[5]);
					break;
				case "topPlane":
					pPoints[0].set(pFrustumVertices[7]);
					pPoints[1].set(pFrustumVertices[6]);
					pPoints[2].set(pFrustumVertices[2]);
					pPoints[3].set(pFrustumVertices[3]);
					break;
				case "bottomPlane":
					pPoints[0].set(pFrustumVertices[5]);
					pPoints[1].set(pFrustumVertices[1]);
					pPoints[2].set(pFrustumVertices[0]);
					pPoints[3].set(pFrustumVertices[4]);
					break;
				case "nearPlane":
					pPoints[0].set(pFrustumVertices[3]);
					pPoints[1].set(pFrustumVertices[2]);
					pPoints[2].set(pFrustumVertices[0]);
					pPoints[3].set(pFrustumVertices[1]);
					break;
				case "farPlane":
					pPoints[0].set(pFrustumVertices[7]);
					pPoints[1].set(pFrustumVertices[5]);
					pPoints[2].set(pFrustumVertices[4]);
					pPoints[3].set(pFrustumVertices[6]);
					break;
				default:
					{ logger.setSourceLocation( "geometry/Frustum.ts" , 322 ); logger.assert(false, "invalid plane key"); } ;
					break;
			}
			return pPoints;
		};

		testPoint(v3fPoint: IVec3): bool{
			if(	   this.leftPlane.signedDistance(v3fPoint) > 0.
				|| this.rightPlane.signedDistance(v3fPoint) > 0.
				|| this.topPlane.signedDistance(v3fPoint) > 0.
				|| this.bottomPlane.signedDistance(v3fPoint) > 0.
				|| this.nearPlane.signedDistance(v3fPoint) > 0.
				|| this.farPlane.signedDistance(v3fPoint) > 0.){

				return false;
			}
			return true;
		};

		testRect(pRect: IRect3d): bool{

			if(planeClassifyRect3d(this.leftPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.rightPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.topPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.bottomPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.nearPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.farPlane, pRect) == EPlaneClassifications.PLANE_FRONT){

				return false;
			}
			return true;
		};

		testSphere(pSphere: ISphere): bool{
			if(	   planeClassifySphere(this.leftPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.rightPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.topPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.bottomPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.nearPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.farPlane, pSphere) == EPlaneClassifications.PLANE_FRONT){

				return false;
			}
			return true;
		};

		testFrustum(pFrustum: IFrustum): bool{

			var pFrustumVertices1: IVec3[] = this.frustumVertices;
			var pFrustumVertices2: IVec3[] = pFrustum.frustumVertices;

			if(pFrustumVertices1 == null){
				pFrustumVertices1 = this.calculateFrustumVertices();
			}
			if(pFrustumVertices2 == null){
				pFrustumVertices2 = pFrustum.calculateFrustumVertices();
			}

			var pFrustumPlanes: string[] = Frustum.frustumPlanesKeys;

			var nTest:  number ;

			for(var i:  number  = 0; i < 6; i++){
				var pPlane: IPlane3d = this[pFrustumPlanes[i]];

				nTest = 0;

				for(var j:  number  = 0; j < 8; j++){
					if(pPlane.signedDistance(pFrustumVertices2[j]) > 0){
						nTest++;
					}
				}

				if(nTest == 8){
//frustums don't intersecting
					return false;
				}
			}

//second batch of test for minimizing possible error
			for(var i:  number  = 0; i < 6; i++){
				var pPlane: IPlane3d = pFrustum[pFrustumPlanes[i]];

				nTest = 0;

				for(var j:  number  = 0; j < 8; j++){
					if(pPlane.signedDistance(pFrustumVertices1[j]) > 0){
						nTest++;
					}
				}

				if(nTest == 8){
//frustums don't intersecting
					return false;
				}
			}

			return true;
		};

		getViewDirection(v3fDirection?: IVec3): IVec3{
			if(!isDef(v3fDirection)){
				v3fDirection = new Vec3();
			}

			v3fDirection.set(0);

			if(isNull(this._pFrustumVertices)){
				this.calculateFrustumVertices();
			}

//far plane
			for(var i:  number  = 4; i<8; i++){
				v3fDirection.add(this._pFrustumVertices[i]);
			}

//near plane
			for(var i:  number  = 0; i<4; i++){
				v3fDirection.subtract(this._pFrustumVertices[i]);
			}

			return v3fDirection.normalize();
		};

		toString(): string{
			var sStr = "";

			for(var i:  number  = 0; i < 6; i++){
				var sKey: string = Frustum.frustumPlanesKeys[i];
				sStr += sKey + ":\n";
				sStr += this[sKey].toString() + "\n";
			}

			return sStr;
		};

		static frustumPlanesKeys: string[] = ["leftPlane", "rightPlane", "topPlane",
											  "bottomPlane", "nearPlane", "farPlane"];
	};
}





module akra.scene.objects {
	export enum ECameraFlags {
		k_NewProjectionMatrix = 0,
		k_NewProjectionParams
	}

	export class DLTechnique {
		list: IDisplayList;
		camera: ICamera;

		private _pPrevResult: IObjectArray = null;

		constructor (pList: IDisplayList, pCamera: ICamera) {
			this.list = pList;
			this.camera = pCamera;
		}

		/**@inline*/  findObjects(pResultArray: IObjectArray, bQuickSearch: bool = false): IObjectArray {
			var pResult: IObjectArray = this.list._findObjects(this.camera, pResultArray,
					bQuickSearch && isDefAndNotNull(this._pPrevResult));

			if (isNull(this._pPrevResult)) {
				this._pPrevResult = pResult;
			}

			return this._pPrevResult;
		}
	}

	export class Camera extends SceneNode implements ICamera {
/** camera type */

		protected _eCameraType: ECameraTypes = ECameraTypes.PERSPECTIVE;
/** camera options */

		protected _iCameraOptions:  number  = 0;
/** update projection bit flag */

		protected _iUpdateProjectionFlags:  number  = 0;

/** 
		 * View matrix 
		 */

		protected _m4fView: IMat4 = new Mat4;
/** internal, un-biased projection matrix */

		protected _m4fProj: IMat4 = new Mat4;
/** internal, un-biased projection+view matrix */

		protected _m4fProjView: IMat4 = new Mat4;

/** 
		 * Biased for use during current render stage 
		 * @deprecated
		 */

//protected _m4fRenderStageProj: IMat4 = new Mat4;

/**
		 * @deprecated
		 */

//protected _m4fRenderStageProjView: IMat4 = new Mat4;

/** Search rect for scene culling */

		protected _pSearchRect: IRect3d = new geometry.Rect3d();
/** Position */

		protected _v3fTargetPos: IVec3 = new Vec3;

/** Attributes for projection matrix */

		protected _fFOV:  number  = math.PI / 5.;
		protected _fAspect:  number  = 4. / 3.;
		protected _fNearPlane:  number  = 0.1;
		protected _fFarPlane:  number  = 500.;
		protected _fWidth:  number  = 0.;
		protected _fHeight:  number  = 0.;
		protected _fMinX:  number  = 0.;
		protected _fMaxX:  number  = 0.;
		protected _fMinY:  number  = 0.;
		protected _fMaxY:  number  = 0.;

		protected _pFrustum: IFrustum = new geometry.Frustum;

		protected _pLastViewport: IViewport = null;

		protected _pDLTechniques: DLTechnique[] = [];
		protected _pDLResultStorage: IObjectArray[] = [];

// protected _pPrevObjects: ISceneNode[] = null;
// protected _p

		/**@inline*/  get viewMatrix(): IMat4 { return this._m4fView; }

    	/**@inline*/  get projectionMatrix(): IMat4 { return this._m4fProj; }

    	/**@inline*/  get projViewMatrix(): IMat4 { return this._m4fProjView; }

    	/**@inline*/  get targetPos(): IVec3 { return this._v3fTargetPos; }

    	/**@inline*/  get fov():  number  { return this._fFOV; }
    	/**@inline*/  set fov(fFOV:  number ) {
    		this._fFOV = fFOV;
    		((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionParams))) ) ;
    	}

    	/**@inline*/  get aspect():  number  { return this._fAspect; }
    	/**@inline*/  set aspect(fAspect:  number ) {
    		this._fAspect = fAspect;
    		((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionParams))) ) ;
    	}

    	/**@inline*/  get nearPlane():  number  { return this._fNearPlane; }
    	/**@inline*/  set nearPlane(fNearPlane:  number ) {
    		this._fNearPlane = fNearPlane;
    		((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionParams))) ) ;
    	}

    	/**@inline*/  get farPlane():  number  { return this._fFarPlane; }
    	/**@inline*/  set farPlane(fFarPlane:  number ) {
    		this._fFarPlane = fFarPlane;
    		((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionParams))) ) ;
    	}

    	/**@inline*/  get viewDistance():  number  { return this._fFarPlane - this._fNearPlane; }
    	/**@inline*/  get searchRect(): IRect3d { return this._pSearchRect; }
    	/**@inline*/  get frustum(): IFrustum { return this._pFrustum; }

		constructor (pScene: IScene3d, eType: EEntityTypes = EEntityTypes.CAMERA) {
			super(pScene, eType);
		};

		create(): bool {
			var isOK: bool = super.create();

			if (isOK) {
				this._v3fTargetPos.set(
					this._m4fLocalMatrix.data[ 8 ],
					this._m4fLocalMatrix.data[ 9 ],
					this._m4fLocalMatrix.data[ 10 ]);
				this._v3fTargetPos.negate();

				this.recalcProjMatrix();
				this.recalcMatrices();

				var pScene: IScene3d = this._pScene;

				this.connect(pScene,  "displayListAdded" ,  "_addDisplayList" );
				this.connect(pScene,  "displayListRemoved" ,  "_removeDisplayList" );

				for (var i:  number  = 0; i < pScene.totalDL; ++ i) {
					var pList: IDisplayList = pScene.getDisplayList(i);

					if (!isNull(pList)) {
						this._addDisplayList(pScene, pList, i);
					}
				}
			}

			return isOK;
		}

		/**@inline*/  isProjParamsNew(): bool {
			return  ((this._iUpdateProjectionFlags & (1 << (ECameraFlags.k_NewProjectionParams)) ) != 0) ;
		}

		recalcProjMatrix(): void {
			switch(this._eCameraType){
				case ECameraTypes.PERSPECTIVE:
					Mat4.perspective(this._fFOV, this._fAspect, this._fNearPlane, this._fFarPlane,this._m4fProj);
					break;
				case ECameraTypes.ORTHO:
					Mat4.orthogonalProjection(this._fWidth, this._fHeight,
					 this._fNearPlane, this._fFarPlane, this._m4fProj);
					break;
				case ECameraTypes.OFFSET_ORTHO:
					Mat4.orthogonalProjectionAsymmetric(this._fMinX, this._fMaxX,
					 this._fMinY, this._fMaxY,this._fNearPlane, this._fFarPlane, this._m4fProj);
					break;
			}
			((this._iUpdateProjectionFlags) &= ~ (1 << ((ECameraFlags.k_NewProjectionParams))) ) ;
		}

		prepareForUpdate(): void {
			super.prepareForUpdate();

//reset culling cache for all display lists
// for (var i: int = 0; i < this._pDLTechniques.length; ++ i) {
// 	if (this._pDLTechniques[i] != null) {
// 		this._pDLTechniques.reset();
// 	}
// }
		}

/*DL_DEFAULT*/
		display(iList:  number  =               0): IObjectArray {
			var pObjects: IObjectArray = this._pDLTechniques[iList].
								findObjects(this._pDLResultStorage[iList], !this.isUpdated());

			return pObjects;
		}

		/**@inline*/  _getLastResults(iList:  number  = 0): IObjectArray {
			return this._pDLResultStorage[iList] || null;
		}

		setParameter(eParam: ECameraParameters, pValue: any): void {
			if (eParam === ECameraParameters.CONST_ASPECT && <bool>pValue) {
				((this._iCameraOptions) |= (< number >eParam)) ;
			}
		}

		isConstantAspect(): bool {
			return  (((this._iCameraOptions) & (ECameraParameters.CONST_ASPECT)) != 0) ;
		}

    	setProjParams(fFOV:  number , fAspect:  number , fNearPlane:  number , fFarPlane:  number ): void {
// Set attributes for the projection matrix
		    this._fFOV = fFOV;
		    this._fAspect = fAspect;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.PERSPECTIVE;

// create the regular projection matrix
		    Mat4.perspective(fFOV, fAspect, fNearPlane, fFarPlane, this._m4fProj);

// create a unit-space matrix 
// for sky box geometry.
// this ensures that the 
// near and far plane enclose 
// the unit space around the camera
// Mat4.perspective(fFOV, fAspect, 0.01, 2.0, this._m4fUnitProj);

		    ((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
    	}

    	setOrthoParams(fWidth:  number , fHeight:  number , fNearPlane:  number , fFarPlane:  number ): void {
		    this._fWidth = fWidth;
		    this._fHeight = fHeight;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.ORTHO;

// create the regular projection matrix
		    Mat4.orthogonalProjection(fWidth, fHeight, fNearPlane, fFarPlane, this._m4fProj);

// create a unit-space matrix 
// for sky box geometry.
// this ensures that the 
// near and far plane enclose 
// the unit space around the camera
// Mat4.matrixOrthoRH(fWidth, fHeight, 0.01, 2.0, this._m4fUnitProj);

		    ((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
    	}

    	setOffsetOrthoParams(fMinX:  number , fMaxX:  number , fMinY:  number , fMaxY:  number , fNearPlane:  number , fFarPlane:  number ): void {
    		this._fMinX = fMinX;
		    this._fMaxX = fMaxX;
		    this._fMinY = fMinY;
		    this._fMaxY = fMaxY;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.OFFSET_ORTHO;

// create the regular projection matrix
		    Mat4.orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY,
		                                fNearPlane, fFarPlane, this._m4fProj);

// create a unit-space matrix 
// for sky box geometry.
// this ensures that the 
// near and far plane enclose 
// the unit space around the camera
// Mat4.orthogonalProjectionorthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY,
//                             0.01, 2.0, this._m4fUnitProj);

		    ((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
    	}

    	private recalcMatrices(): void {
    		this._v3fTargetPos.set(
	        this._m4fLocalMatrix.data[ 8 ],
	        this._m4fLocalMatrix.data[ 9 ],
	        this._m4fLocalMatrix.data[ 10 ]);

		    this._v3fTargetPos.negate();

// the camera view matrix is the
// inverse of the world matrix
		    this._m4fView.set(this.inverseWorldMatrix);
// sky boxes use the inverse 
// world matrix of the camera (the
// camera view matrix) without 
// any translation information.

//this.m4fSkyBox.set(this.m4fView);
// this.m4fSkyBox.data[__14] = 0.0;
// this.m4fSkyBox.data[__24] = 0.0;
// this.m4fSkyBox.data[__34] = 0.0;

// this is combined with the unit
// space projection matrix to form
// the sky box viewing matrix
//this.m4fSkyBox.multiply(this.m4fUnitProj, this.m4fSkyBox);


// billboard objects use our world matrix
// without translation
// this.m4fBillboard.set(this.worldMatrix());
// this.m4fBillboard.data[__14] = 0.0;
// this.m4fBillboard.data[__24] = 0.0;
// this.m4fBillboard.data[__34] = 0.0;
    	}

    	update(): bool {
    		var isUpdated: bool = super.update();

    		if (this.isProjParamsNew()) {
    			this.recalcProjMatrix();
    		}

		    if (this.isWorldMatrixNew() ||  ((this._iUpdateProjectionFlags & (1 << (ECameraFlags.k_NewProjectionMatrix)) ) != 0) ) {
		    	this._pFrustum.extractFromMatrix(this._m4fProj, this._m4fWorldMatrix, this._pSearchRect);
// this._m4fRenderStageProj.set(this._m4fProj);

		    	if (this.isWorldMatrixNew()){
    				this.recalcMatrices();
    			}

// our projView matrix is the projection 
//matrix multiplied by the inverse of our world matrix  
		        this._m4fProj.multiply(this._m4fView, this._m4fProjView);
		        isUpdated = true;

		        ((this._iUpdateProjectionFlags) &= ~ (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
		    }

		    return isUpdated;
    	}

// applyRenderStageBias(iStage: int): void {
//    	var fZ_bias = iStage > 1 ? 0.001 : 0.0;

//     this._m4fRenderStageProj.set(this._m4fProj);
//     this._m4fRenderStageProjView.set(this._m4fProjView);

//     this._m4fRenderStageProj[__34] -= fZ_bias;
//     this._m4fRenderStageProjView[__34] -= fZ_bias;
//    }


    	_renderScene(pViewport: IViewport): void {
//update the pixel display ratio
// if (this._eCameraType == ECameraTypes.PERSPECTIVE) {
// 	mPixelDisplayRatio = (2. * math.tan(this._fFOV * 0.5)) / pViewport.actualHeight;
// }
// else {
// 	mPixelDisplayRatio = (mTop - mBottom) / vp->getActualHeight();
// }

//notify prerender scene
			this.preRenderScene();


			pViewport.update();

//notify postrender scene
			this.postRenderScene();
    	};


    	_keepLastViewport(pViewport: IViewport): void { this._pLastViewport = pViewport; }
    	_getLastViewport(): IViewport { return this._pLastViewport; }
    	_getNumRenderedFaces():  number  { return 0; }
    	_notifyRenderedFaces(nFaces:  number ): void {}

    	/**@inline*/  isActive(): bool {
    		return this._pLastViewport && this._pLastViewport.getCamera() === this;
    	}

    	toString(isRecursive: bool = false, iDepth:  number  = 0): string {
		    if (!isRecursive) {
		        return "<camera" + (this._sName? " " + this._sName: "") + ">" + " height: " + this.worldPosition.y;
		    }

		    return super.toString(isRecursive, iDepth);
    	};

    	projectPoint(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3 {
			if(!isDef(v3fDestination)){
				v3fDestination = v3fPoint;
			}

			var m4fView: IMat4 = this.viewMatrix;
			var m4fProj: IMat4 = this.projectionMatrix;

			var v4fTmp: IVec4 =  Vec4.stackCeil.set(v3fPoint, 1.) ;

			v4fTmp = m4fProj.multiplyVec4(m4fView.multiplyVec4(v4fTmp));

			if(v4fTmp.w <= 0.){
				return null;
			}

			v3fDestination.set((v4fTmp.scale(1./v4fTmp.w)).xyz);

			var fX:  number  = math.abs(v3fDestination.x);
			var fY:  number  = math.abs(v3fDestination.y);
			var fZ:  number  = math.abs(v3fDestination.z);

			if(fX > 1 || fY > 1 || fZ > 1){
				return null;
			}

			return v3fDestination;
		}


		getDepthRange(): IDepthRange{
			var pDepthRange: IDepthRange = this._pLastViewport.getDepthRange();

			var zNear:  number  = this._m4fProj.unprojZ(pDepthRange.min);
			var zFar:  number  = this._m4fProj.unprojZ(pDepthRange.max);

			return <IDepthRange>{min: zNear, max: zFar};
		};

    	_addDisplayList(pScene: IScene3d, pList: IDisplayList, index:  number ): void {
    		this._pDLTechniques[index] = new DLTechnique(pList, this);
    		this._pDLResultStorage[index] = new util.ObjectArray();
    	};

    	_removeDisplayList(pScene: IScene3d, pList: IDisplayList, index:  number ): void {
    		this._pDLTechniques[index] = null;
    		this._pDLResultStorage[index] = null;
    	};

		preRenderScene (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).preRenderScene; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		postRenderScene (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).postRenderScene; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
	}

	export  /**@inline*/  function isCamera(pNode: IEntity): bool {
		return pNode.type >= EEntityTypes.CAMERA && pNode.type <= EEntityTypes.SHADOW_CASTER;
	}
}









module akra.scene.light {
	export class ShadowCaster extends objects.Camera implements IShadowCaster {
		protected _pLightPoint: ILightPoint = null;
		protected _iFace:  number  = 0;
		protected _pAffectedObjects: IObjectArray = new util.ObjectArray();
		protected _m4fOptimizedProj: IMat4 = new Mat4();
		protected _isShadowCasted: bool = false;

		/**@inline*/  get lightPoint(): ILightPoint{
			return this._pLightPoint;
		};

		/**@inline*/  get face():  number {
			return this._iFace;
		};

		/**@inline*/  get affectedObjects(): IObjectArray{
			return this._pAffectedObjects;
		};

		/**@inline*/  get optimizedProjection(): IMat4{
			return this._m4fOptimizedProj;
		}

		/**@inline*/  get isShadowCasted(): bool{
			return this._isShadowCasted;
		}
		/**@inline*/  set isShadowCasted(isShadowCasted: bool){
			this._isShadowCasted = isShadowCasted;
		}

		constructor (pLightPoint: ILightPoint, iFace:  number  = ECubeFace.POSITIVE_X) {
			super(pLightPoint.scene, EEntityTypes.SHADOW_CASTER);

			this._pLightPoint = pLightPoint;
			this._iFace = iFace;
		};

		_optimizeProjectionMatrix(pEffectiveCameraFrustum: IFrustum):void {
			if (this._pAffectedObjects.length == 0) {
		        this._m4fOptimizedProj.set(this.projectionMatrix);
		        return;
		    }

		    var m4fView: IMat4 = this.viewMatrix;
		    var m4fProj: IMat4 = this.projectionMatrix;
		    var m4fProjData: Float32Array = m4fProj.data;

		    var pBox: IRect3d = geometry. Rect3d.stackCeil.set() ;

		    var pAffectedObjects: IObjectArray = this._pAffectedObjects;

		    var fX0:  number , fX1:  number , fY0:  number , fY1:  number , fZ0:  number , fZ1:  number ;
		    var fX:  number , fY:  number , fZ:  number , fW:  number ;

		    var fX_Left:  number , fY_Bottom:  number ;
		    var fX_Right:  number , fY_Top:  number ;
		    var fZ_Near:  number , fZ_Far:  number ;

//первый бокс должен быть, либо построен по первому элементу, что приводит к усложнению функции
//либо записан таким образом (то есть минимально (максимально) возможные значения), тогда можно просто все делать в цикле
		    var fXRes_Left:  number  = 1., fXRes_Right:  number  = -1,
		        fYRes_Bottom:  number  = 1, fYRes_Top:  number  = -1,
		        fZRes_Near:  number  = 1, fZRes_Far:  number  = -1;


		    var fTmp:  number ;

		    for(var i: number  = 0; i < pAffectedObjects.length; i++){
		    	var pObject: ISceneObject = pAffectedObjects.value(i);

		    	if(!pObject.shadow){
		    		continue;
		    	}

		        pBox.set(pObject.worldBounds);
		        pBox.transform(m4fView);

		        fX0 = pBox.x0; fX1 = pBox.x1;
		        fY0 = pBox.y0; fY1 = pBox.y1;
		        fZ0 = pBox.z0; fZ1 = pBox.z1;

//z - отрицательное => ближняя к камере грань fZ1, а fZ0 - дальняя

//left bottom near

		        fX = m4fProjData[ 0 ] * fX0 + m4fProjData[ 4 ] * fY0 + m4fProjData[ 8 ] * fZ1 + m4fProjData[ 12 ];
		        fY = m4fProjData[ 1 ] * fX0 + m4fProjData[ 5 ] * fY0 + m4fProjData[ 9 ] * fZ1 + m4fProjData[ 13 ];
		        fZ = m4fProjData[ 2 ] * fX0 + m4fProjData[ 6 ] * fY0 + m4fProjData[ 10 ] * fZ1 + m4fProjData[ 14 ];
		        fW = m4fProjData[ 3 ] * fX0 + m4fProjData[ 7 ] * fY0 + m4fProjData[ 11 ] * fZ1 + m4fProjData[ 15 ];

		        if (fW <= 0) {
//обходим особые случаи
		            fX = -1;
		            fY = -1;
		            fZ = -1;
		            fW = 1;
		        }

		        fX_Left = fX / fW;
		        fY_Bottom = fY / fW;

////////////////////////////////
//z near
		        fZ_Near = fZ / fW;
////////////////////////////////

//left bottom far

		        fX = m4fProjData[ 0 ] * fX0 + m4fProjData[ 4 ] * fY0 + m4fProjData[ 8 ] * fZ0 + m4fProjData[ 12 ];
		        fY = m4fProjData[ 1 ] * fX0 + m4fProjData[ 5 ] * fY0 + m4fProjData[ 9 ] * fZ0 + m4fProjData[ 13 ];
		        fZ = m4fProjData[ 2 ] * fX0 + m4fProjData[ 6 ] * fY0 + m4fProjData[ 10 ] * fZ0 + m4fProjData[ 14 ];
		        fW = m4fProjData[ 3 ] * fX0 + m4fProjData[ 7 ] * fY0 + m4fProjData[ 11 ] * fZ0 + m4fProjData[ 15 ];
//в этой части особенностей нет, так как w всегда больше нуля, иначе объект будет вне frustum-а

		        fTmp = fX / fW;
		        fX_Left = (fTmp < fX_Left) ? fTmp : fX_Left;

		        fTmp = fY / fW;
		        fY_Bottom = (fTmp < fY_Bottom) ? fTmp : fY_Bottom;


////////////////////////////////
//z far
		        fZ_Far = fZ / fW;
////////////////////////////////

//right top near

		        fX = m4fProjData[ 0 ] * fX1 + m4fProjData[ 4 ] * fY1 + m4fProjData[ 8 ] * fZ1 + m4fProjData[ 12 ];
		        fY = m4fProjData[ 1 ] * fX1 + m4fProjData[ 5 ] * fY1 + m4fProjData[ 9 ] * fZ1 + m4fProjData[ 13 ];
		        fW = m4fProjData[ 3 ] * fX1 + m4fProjData[ 7 ] * fY1 + m4fProjData[ 11 ] * fZ1 + m4fProjData[ 15 ];

		        if (fW <= 0) {
//обходим особые случаи
		            fX = 1;
		            fY = 1;
		            fW = 1;
		        }

		        fX_Right = fX / fW;
		        fY_Top = fY / fW;

//right top far

		        fX = m4fProjData[ 0 ] * fX1 + m4fProjData[ 4 ] * fY1 + m4fProjData[ 8 ] * fZ0 + m4fProjData[ 12 ];
		        fY = m4fProjData[ 1 ] * fX1 + m4fProjData[ 5 ] * fY1 + m4fProjData[ 9 ] * fZ0 + m4fProjData[ 13 ];
		        fW = m4fProjData[ 3 ] * fX1 + m4fProjData[ 7 ] * fY1 + m4fProjData[ 11 ] * fZ0 + m4fProjData[ 15 ];
//в этой части особенностей нет, так как w всегда больше нуля, иначе объект будет вне frustum-а

				fTmp = fX / fW;
		        fX_Right = (fTmp > fX_Right) ? fTmp : fX_Right;

		        fTmp = fY / fW;
		        fY_Top = (fTmp > fY_Top) ? fTmp : fY_Top;

////////////////////////////////

		        fXRes_Left = (fX_Left < fXRes_Left) ? fX_Left : fXRes_Left;
		        fXRes_Right = (fX_Right > fXRes_Right) ? fX_Right : fXRes_Right;

		        fYRes_Bottom = (fY_Bottom < fYRes_Bottom) ? fY_Bottom : fYRes_Bottom;
		        fYRes_Top = (fY_Top > fYRes_Top) ? fY_Top : fYRes_Top;

		        fZRes_Near = (fZ_Near < fZRes_Near) ? fZ_Near : fZRes_Near;
		        fZRes_Far = (fZ_Far > fZRes_Far) ? fZ_Far : fZRes_Far;
		    }

//test with camera frustum

		    var pCameraBox: IRect2d = this._getBoxForCameraFrustum(pEffectiveCameraFrustum, new geometry.Rect2d());

		    var fCameraMinX:  number  = math.max(pCameraBox.x0, -1);
		    var fCameraMaxX:  number  = math.min(pCameraBox.x1, 1);

		    var fCameraMinY:  number  = math.max(pCameraBox.y0, -1);
		    var fCameraMaxY:  number  = math.min(pCameraBox.y1, 1);

		    fXRes_Left = math.max((fXRes_Left < -1 || fXRes_Left == 1) ? -1 : fXRes_Left, fCameraMinX);
		    fXRes_Right = math.min((fXRes_Right > 1 || fXRes_Right == -1) ? 1 : fXRes_Right, fCameraMaxX);

		    fYRes_Bottom = math.max((fYRes_Bottom < -1 || fYRes_Bottom == 1) ? -1 : fYRes_Bottom, fCameraMinY);
		    fYRes_Top = math.min((fYRes_Top > 1 || fYRes_Top == -1) ? 1 : fYRes_Top, fCameraMaxY);

		    fZRes_Near = (fZRes_Near < -1 || fZRes_Near == 1) ? -1 : fZRes_Near;
		    fZRes_Far = (fZRes_Far > 1 || fZRes_Far == -1) ? 1 : fZRes_Far;

//optimized parameters

		    var v4fTmp1: IVec4 = m4fProj.unproj( Vec3.stackCeil.set(fXRes_Left, fYRes_Bottom, fZRes_Near) ,  Vec4.stackCeil.set() );
		    var v4fTmp2: IVec4 = m4fProj.unproj( Vec3.stackCeil.set(fXRes_Right, fYRes_Top, fZRes_Near) ,  Vec4.stackCeil.set() );

//////////////////////////


		    fX_Left = v4fTmp1.x;
		    fX_Right = v4fTmp2.x;
		    fY_Bottom = v4fTmp1.y;
		    fY_Top = v4fTmp2.y;
		    fZ_Near = v4fTmp1.z;
		    fZ_Far = m4fProj.unprojZ(fZRes_Far);

		    if(m4fProj.isOrthogonalProjection()){
//ortho-projection
		    	Mat4.orthogonalProjectionAsymmetric(fX_Left, fX_Right, fY_Bottom, fY_Top, -fZ_Near, -fZ_Far, this._m4fOptimizedProj);
		    }
		    else{
//frustum
		    	Mat4.frustum(fX_Left, fX_Right, fY_Bottom, fY_Top, -fZ_Near, -fZ_Far, this._m4fOptimizedProj);
			}
		};

		protected _getBoxForCameraFrustum(pEffectiveCameraFrustum: IFrustum, pDestination?: IRect2d): IRect2d{
			if(!isDef(pDestination)){
				pDestination = new geometry.Rect2d();
			}
			var m4fProjView: IMat4 = this.projViewMatrix;
			var pFrusutumVertices: IVec3[] = pEffectiveCameraFrustum.frustumVertices;

			var v4fTmp: IVec4 =  Vec4.stackCeil.set() ;
			var v2fTmp: IVec2 =  Vec2.stackCeil.set() ;

			for(var i:  number  = 0; i<8; i++){
				v4fTmp.set(pFrusutumVertices[i], 1.);

				m4fProjView.multiplyVec4(v4fTmp);

				v2fTmp.set(v4fTmp.x, v4fTmp.y).scale(math.abs(1./v4fTmp.w));

				if(i == 0){
					pDestination.set(v2fTmp,v2fTmp);
				}
				else{
					pDestination.unionPoint(v2fTmp);
				}
			}

		    return pDestination;
		};
	}

	export function isShadowCaster(pEntity: IEntity): bool {
		return !isNull(pEntity) && pEntity.type === EEntityTypes.SHADOW_CASTER;
	}
}





module akra.render {
	export class ShadowViewport extends Viewport implements IViewport {

		/**@inline*/  get type(): EViewportTypes { return EViewportTypes.SHADOWVIEWPORT; }

		constructor(pCamera: ICamera, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0){
			super(pCamera,  ".prepare-shadows" , fLeft, fTop, fWidth, fHeight, iZIndex);

			this.setClearEveryFrame(true, EFrameBufferTypes.DEPTH);
			this.setDepthParams(true, true, ECompareFunction.LESS);
			this.depthClear = 1.;
		}

		_updateImpl(): void {
// LOG("SAHDOW VIEWPORT #" + this.getGuid());
			var pShadowCaster: IShadowCaster = <IShadowCaster> this._pCamera;
			var pAffectedObjects: IObjectArray = pShadowCaster.affectedObjects;

			var pRenderable: IRenderableObject;
			var pSceneObject: ISceneObject;

			var nShadowsCasted:  number  = 0;

			for (var i:  number  = 0; i < pAffectedObjects.length; i++) {
				pSceneObject = pAffectedObjects.value(i);

					if(pSceneObject.shadow){
						for (var j:  number  = 0; j < pSceneObject.totalRenderable; j++) {
						pRenderable = pSceneObject.getRenderable(j);

						if (!isNull(pRenderable) && pRenderable.shadow) {
							this.prepareRenderableForShadows(pRenderable);
							pRenderable.render(this, this._csDefaultRenderMethod, pSceneObject);
							nShadowsCasted++;
						}
					}

				}
			}

			pShadowCaster.isShadowCasted = (nShadowsCasted > 0) ? true : false;
		};

		private prepareRenderableForShadows(pRenderable: IRenderableObject): void {
			var pRenderTechnique: IRenderTechnique = pRenderable.getTechnique(this._csDefaultRenderMethod);

			if(!isNull(pRenderTechnique)){
				return;
			}

			var pRmgr: IResourcePoolManager = this.getTarget().getRenderer().getEngine().getResourceManager();
			var pMethodPool: IResourcePool = pRmgr.renderMethodPool;

			var pMethod: IRenderMethod = <IRenderMethod>pMethodPool.findResource(".method-prepare-shadows");

			if(isNull(pMethod)){
				pMethod = pRmgr.createRenderMethod(".method-prepare-shadows");
				pMethod.effect = pRmgr.createEffect(".effect-prepare-shadows");
				pMethod.effect.addComponent("akra.system.prepareShadows");
			}

			pRenderable.addRenderMethod(pMethod, this._csDefaultRenderMethod);
		};

		protected _getDepthRangeImpl(): IDepthRange{
			var pDepthTexture: ITexture;
			var pShadowCaster: IShadowCaster = <IShadowCaster>this._pCamera;

			var pLightPoint: ILightPoint = pShadowCaster.lightPoint;

			switch(pLightPoint.type){
				case ELightTypes.PROJECT:
					pDepthTexture = (<IProjectLight>pLightPoint).getDepthTexture();
					break;
				case ELightTypes.OMNI:
					pDepthTexture = (<IOmniLight>pLightPoint).getDepthTextureCube()[pShadowCaster.face];
					break;
				default:
					pDepthTexture = null;
					break;
			}

			if(isDefAndNotNull(pDepthTexture)){
				var pRange: IDepthRange = util.getDepthRange(pDepthTexture);
				console.log("shadow viewport min & max depth range > ", pRange.min, pRange.max);
//[0,1] -> [-1, 1]
				pRange.min = pRange.min * 2. - 1.
				pRange.max = pRange.max * 2. - 1.

				return pRange;
			}
			return null;
		}

	};
}






module akra.render {

	export interface IRenderTechniqueMap {
		[key: string]: IRenderTechnique;
	}

	export class RenderableObject implements IRenderableObject {
		protected _pRenderData: IRenderData = null;
		protected _pRenderer: IRenderer;
		protected _pTechnique: IRenderTechnique = null;
		protected _pTechniqueMap: IRenderTechniqueMap = {};
		protected _eRenderableType: ERenderDataTypes;
		protected _bShadow: bool = true;
		protected _bVisible: bool = true;
		protected _bFrozen: bool = false;
		protected _bWireframeOverlay: bool = false;

		/**@inline*/  get type(): ERenderDataTypes { return this._eRenderableType; }
		/**@inline*/  get renderMethod(): IRenderMethod { return this._pTechnique.getMethod(); }
		/**@inline*/  set renderMethod(pMethod: IRenderMethod) {this.switchRenderMethod(pMethod); }
		/**@inline*/  get effect(): IEffect { return this._pTechnique.getMethod().effect; }
		/**@inline*/  get surfaceMaterial(): ISurfaceMaterial  { return this._pTechnique.getMethod().surfaceMaterial; }
		/**@inline*/  get material(): IMaterial  { return this.surfaceMaterial.material; }
		/**@inline*/  get data(): IRenderData { return this._pRenderData; }
		/**@inline*/  get shadow(): bool { return this._bShadow; }

		/**@inline*/  set shadow(bShadow: bool) {
			if(this._bShadow !== bShadow){
				this._bShadow = bShadow;
				this.shadowed(bShadow);
			}
		}

		/**@inline*/  set onclick(
			fn: (pRenderable: IRenderableObject, pViewport: IViewport,
				pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "click" , fn);
        }

        /**@inline*/  set onmousemove(
        	fn: (pRenderable: IRenderableObject, pViewport: IViewport,
        		pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "mousemove" , fn);
        }

        /**@inline*/  set onmousedown(
        	fn: (pRenderable: IRenderableObject, pViewport: IViewport,
        		pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "mousedown" , fn);
        }

        /**@inline*/  set onmouseup(
        	fn: (pRenderable: IRenderableObject, pViewport: IViewport,
        		pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "mouseup" , fn);
        }

        /**@inline*/  set onmouseover(
        	fn: (pRenderable: IRenderableObject, pViewport: IViewport,
        		pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "mouseover" , fn);
        }

        /**@inline*/  set onmouseout(
        	fn: (pRenderable: IRenderableObject, pViewport: IViewport,
        		pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "mouseout" , fn);
        }

        /**@inline*/  set ondragstart(
        	fn: (pRenderable: IRenderableObject, pViewport: IViewport,
        		pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "dragstart" , fn);
        }

		/**@inline*/  set ondragstop(
        	fn: (pRenderable: IRenderableObject, pViewport: IViewport,
        		pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "dragstop" , fn);
        }

        /**@inline*/  set ondragging(
        	fn: (pRenderable: IRenderableObject, pViewport: IViewport,
        		pObject: ISceneObject, x:  number , y:  number ) => void) {
        	this.bind( "dragging" , fn);
        }


		constructor (eType: ERenderDataTypes = ERenderDataTypes.UNKNOWN) {
			this._eRenderableType = eType;
		}

		/**@inline*/  _setRenderData(pData: IRenderData): void {
			this._pRenderData = pData;
		}

		_setup(pRenderer: IRenderer, csDefaultMethod: string = null): void {
			this._pRenderer = pRenderer;

			if (!this.addRenderMethod(csDefaultMethod) || this.switchRenderMethod(null) === false) {
				{ logger.setSourceLocation( "RenderableObject.ts" , 112 ); logger.criticalError("cannot add & switch render method to default"); } ;
			}
		}

		/**@inline*/  getRenderer(): IRenderer {
			return this._pRenderer;
		}

		destroy(): void {
			this._pRenderer = null;
			this._pTechnique = null;

			for (var i in this._pTechniqueMap) {
				this._pTechniqueMap[i].destroy();
			}

			this._pTechniqueMap = null;
		}

		addRenderMethod(pMethod: IRenderMethod, csName: string =  "default" ): bool;
		addRenderMethod(csMethod: string, csName: string =  "default" ): bool;
		addRenderMethod(csMethod: any, csName: string =  "default" ): bool {
			var pTechnique: IRenderTechnique = new RenderTechnique;
			var pRmgr: IResourcePoolManager = this.getRenderer().getEngine().getResourceManager();
			var pMethod: IRenderMethod = null;

			if (isNull(csMethod)) {
				csMethod =  "default" ;
			}

		    if (isString(csMethod) || arguments.length === 0) {
		        pMethod = pRmgr.createRenderMethod((csMethod) + this.getGuid());

		        if (!isDefAndNotNull(pMethod)) {
		        	{ logger.setSourceLocation( "RenderableObject.ts" , 146 ); logger.criticalError("resource manager failed to create method..."); } ;
		        	return false;
		        }

//adding empty, but NOT NULL effect & material
		        pMethod.surfaceMaterial = pRmgr.createSurfaceMaterial(csMethod + ".material." + this.getGuid());
		        pMethod.effect = pRmgr.createEffect(csMethod + ".effect." + this.getGuid());
		    }
		    else {
		    	pMethod = <IRenderMethod>arguments[0];
		    }


		    { logger.setSourceLocation( "RenderableObject.ts" , 160 ); logger.assert(pMethod.getManager().getEngine().getRenderer() === this._pRenderer, "Render method should belong to the same engine instance that the renderable object."); }
                                                                                                         ;

		    pTechnique.setMethod(pMethod);
//pTechnique.name = csName || DEFAULT_RT;

		    this._pTechniqueMap[csName ||  "default" ] = pTechnique;

		    return true;
		}

		switchRenderMethod(pMethod: IRenderMethod): bool;
		switchRenderMethod(csName: string): bool;
		switchRenderMethod(csName: any): bool {
			var pTechnique: IRenderTechnique;
			var sName: string = null;

			if(isNull(arguments[0])) {
				sName =  "default" ;
			}
			else if (isString(arguments[0])) {
				sName = <string>csName;
			}
			else if (isDefAndNotNull(arguments[0])) {
				sName = (<IRenderMethod>arguments[0]).findResourceName();

				if (!isDefAndNotNull(this._pTechniqueMap[sName])) {
					if (!this.addRenderMethod(<IRenderMethod>arguments[0], sName)) {
						return false;
					}
				}
			}

			pTechnique = this._pTechniqueMap[sName];

			if (isDefAndNotNull(pTechnique)) {
				this._pTechnique = pTechnique;
				return true;
			}

			return false;
		}

		removeRenderMethod(csName: string): bool {
			var pTechnique: IRenderTechnique = this._pTechniqueMap[csName];

			if (isDefAndNotNull(pTechnique)) {
				delete this._pTechniqueMap[csName ||  "default" ];
				return true
			}

		    return false;
		}



		/**@inline*/  getRenderMethod(csName: string = null): IRenderMethod {
			var pTechnique: IRenderTechnique = this._pTechniqueMap[csName ||  "default" ];
			return pTechnique? pTechnique.getMethod(): null;
		}

		/**@inline*/  getRenderMethodDefault(): IRenderMethod {
			return this.getRenderMethod( "default" );
		}

		/**@inline*/  isReadyForRender(): bool {
			return this._bVisible && this._pTechnique.isReady();
		}

		isAllMethodsLoaded(): bool {
			for (var i in this._pTechniqueMap) {
				var pMethod: IRenderMethod = this._pTechniqueMap[i].getMethod();

				if (!isDefAndNotNull(pMethod) || !pMethod.isResourceLoaded()) {
					return false;
				}
			}

			return true;
		}

		/**@inline*/  isFrozen(): bool {
			return this._bFrozen;
		}

		wireframe(bEnable: bool = true, bOverlay: bool = true): bool {
			var pDefaultRm: IRenderMethod = this.getRenderMethodDefault();

			if (!bEnable) {
				if (pDefaultRm.effect.hasComponent("akra.system.wireframe")) {
					pDefaultRm.effect.delComponent("akra.system.wireframe", 0, 0);
				}
				return;
			}

			if (this.data.getDataLocation("BARYCENTRIC") == -1) {
				var ePrimType: EPrimitiveTypes = this.data.getPrimitiveType();

/* && ePrimType !== EPrimitiveTypes.TRIANGLESTRIP*/
				if (ePrimType !== EPrimitiveTypes.TRIANGLELIST                                                   ) {
					{ logger.setSourceLocation( "RenderableObject.ts" , 258 ); logger.warning("wireframe supported only for TRIANGLELIST"); } ;
					return false;
				}

				var iPosition:  number  = this.data.getDataLocation('POSITION');
				var pIndices: Float32Array = <Float32Array>this.data.getIndexFor("POSITION");

// var pIndices: Float32Array = <any>this.data._getFlow("POSITION").mapper.data.getTypedData(this.data._getFlow("POSITION").mapper.semantics);
				var pBarycentric: Float32Array = new Float32Array(pIndices.length);

				if (ePrimType == EPrimitiveTypes.TRIANGLELIST) {
					for (var n = 0; n < pIndices.length; ++ n) {
						pIndices[n] = n;
						pBarycentric[n] = n % 3;
					}
				}


				this.data.allocateData([VE_FLOAT('BARYCENTRIC')], pBarycentric);
				this.data.allocateIndex([VE_FLOAT('BARYCENTRIC_INDEX')], pIndices);

				this.data.index('BARYCENTRIC', 'BARYCENTRIC_INDEX');
			}

			this._bWireframeOverlay = bOverlay;

			pDefaultRm.effect.addComponent("akra.system.wireframe", 0, 0);
		}


		render(pViewport: IViewport, csMethod?: string = null, pSceneObject?: ISceneObject = null): void {
			if (!this.isReadyForRender() || (!isNull(pSceneObject) && pSceneObject.isHidden())) {
				return;
			}

			if (!this.switchRenderMethod(csMethod)) {
//debug_error("could not switch render method <" + csMethod + ">");
				return;
			}

			this.beforeRender(pViewport, this._pTechnique.getMethod());

			this.data._draw(this._pTechnique, pViewport, this, pSceneObject);
		}

		/**@inline*/  getTechnique(sName: string =  "default" ): IRenderTechnique {
			return this._pTechniqueMap[sName] || null;
		}

		/**@inline*/  getTechniqueDefault(): IRenderTechnique{
			return this.getTechnique( "default" );
		}

		_draw(): void {
			{ logger.setSourceLocation( "RenderableObject.ts" , 312 ); logger.error("RenderableObject::_draw() pure virtual method() isn't callable!!"); } ;
		}

		/**@inline*/  isVisible(): bool {
			return this._bVisible;
		}
		/**@inline*/  setVisible(bVisible: bool = true): void {
			this._bVisible = bVisible;
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return RenderableObject._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;

		shadowed (bValue): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).shadowed; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier, bValue) : _unicast.listener (_recivier, bValue) ; } } ; ;
		beforeRender (pViewport, pMethod): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).beforeRender; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pMethod) : _broadcast[i].listener (_recivier, pViewport, pMethod) ; } } } ; ;

		click (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).click; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
		mousemove (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousemove; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
		mousedown (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousedown; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
		mouseup (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseup; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
		mouseover (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseover; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
		mouseout (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseout; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
		dragstart (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragstart; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
		dragstop (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragstop; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
		dragging (pViewport, pObject, x, y): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragging; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport, pObject, x, y) : _broadcast[i].listener (_recivier, pViewport, pObject, x, y) ; } } } ; ;
	}

	export  /**@inline*/  function isMeshSubset(pObject: IRenderableObject): bool {
		return pObject.type === ERenderDataTypes.MESH_SUBSET;
	}

	export  /**@inline*/  function isScreen(pObject: IRenderableObject): bool {
		return pObject.type === ERenderDataTypes.SCREEN;
	}

	export  /**@inline*/  function isSprite(pObject: IRenderableObject): bool {
		return pObject.type === ERenderDataTypes.SPRITE;
	}
}





















module akra.util{

// #ifdef WEBGL
// #define WEBGL_DEPTH_RANGE 1
// #endif


	export function getDepthRange(pDepthTexture: ITexture): IDepthRange{
		return <IDepthRange>{min: 0., max: 1.};
	};


}











module akra.render {
	export class Screen extends RenderableObject {
		protected _pBuffer: IRenderDataCollection;

		constructor(pRenderer: IRenderer, pCollection?: IRenderDataCollection) {
			super(ERenderDataTypes.SCREEN);

			if (!isDefAndNotNull(pCollection)) {
				pCollection = pRenderer.getEngine().createRenderDataCollection(0);
			}

			var pData: IRenderData = pCollection.getEmptyRenderData(EPrimitiveTypes.TRIANGLESTRIP);

			pData.allocateAttribute(createVertexDeclaration([VE_FLOAT2(DeclUsages.POSITION)]),
				new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1]));

			this._pRenderData = pData;
			this._setup(pRenderer);
		}
	}
}




module akra.render {

	var pDepthPixel: IPixelBox = new pixelUtil.PixelBox(new geometry.Box(0, 0, 1, 1), EPixelFormats.FLOAT32_DEPTH, new Uint8Array(4 * 1));
	var pFloatColorPixel: IPixelBox = new pixelUtil.PixelBox(new geometry.Box(0, 0, 1, 1), EPixelFormats.FLOAT32_RGBA, new Uint8Array(4 * 4));
	var pColor: IColor = new Color(0);

	export class DSViewport extends Viewport implements IDSViewport  {
		private _pDeferredEffect: IEffect = null;
		private _pDeferredColorTextures: ITexture[] = [];
		private _pDeferredDepthTexture: ITexture = null;
		private _pDeferredView: IRenderableObject = null;
		private _pDeferredSkyTexture: ITexture = null;

//index of lighting display list
		private _pLightDL:  number ;
	    private _pLightPoints: util.ObjectArray = null;
		private _pLightingUnifoms: UniformMap = {
	        omni           	: [],
	        project        	: [],
	        sun				: [],
	        omniShadows    	: [],
	        projectShadows 	: [],
	        sunShadows 		: [],
	        textures       	: [],
	        samplersOmni  	: [],
	        samplersProject : [],
	        samplersSun		: []
	    };

//highligting
	    private _pHighlightedObject: IRIDPair = {object: null, renderable: null};


	    /**@inline*/  get type(): EViewportTypes { return EViewportTypes.DSVIEWPORT; }


	    /**@inline*/  get effect(): IEffect {
			return this._pDeferredEffect;
		}

		/**@inline*/  get depth(): ITexture {
			return this._pDeferredDepthTexture;
		}

		/**@inline*/  get view(): IRenderableObject {
			return this._pDeferredView;
		}

		constructor(pCamera: ICamera, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0) {
			super(pCamera, null, fLeft, fTop, fWidth, fHeight, iZIndex);
		}

		_setTarget(pTarget: IRenderTarget): void {
			super._setTarget(pTarget);

//common api access
			var pEngine: IEngine 				= pTarget.getRenderer().getEngine();
			var pResMgr: IResourcePoolManager 	= pEngine.getResourceManager();

//textures for deferred shading
			var pDeferredData: IRenderTarget[] 	= <IRenderTarget[]>new Array(2);
			var pDeferredTextures: ITexture[] 	= <ITexture[]>new Array(2);
			var pDepthTexture: ITexture;

//renderable for displaying result from deferred textures
			var pDefferedView: IRenderableObject = new Screen(pEngine.getRenderer());

//unique idetifier for creation dependent resources
			var iGuid:  number  = this.getGuid();

//Float point texture must be power of two.
			var iWidth:  number  = math.ceilingPowerOfTwo(this.actualWidth);
    		var iHeight:  number  = math.ceilingPowerOfTwo(this.actualHeight);

//detect max texture resolution correctly

	        iWidth 	= math.min(iWidth, webgl.maxTextureSize);
	        iHeight = math.min(iHeight, webgl.maxTextureSize);


//creating depth
			pDepthTexture = this._pDeferredDepthTexture = pResMgr.createTexture("deferred-depth-texture-" + iGuid);
			pDepthTexture.create(iWidth, iHeight, 1, null, 0, 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.DEPTH32);
			pDepthTexture.setFilter(ETextureParameters.MAG_FILTER, ETextureFilters.LINEAR);
			pDepthTexture.setFilter(ETextureParameters.MIN_FILTER, ETextureFilters.LINEAR);

			var pViewport:  IViewport;

//creating float textures
			for (var i = 0; i < 2; ++ i) {
				pDeferredTextures[i] = this._pDeferredColorTextures[i] =
					pResMgr.createTexture("deferred-color-texture-" + i + "-" +  iGuid);

				pDeferredTextures[i].create(iWidth, iHeight, 1, null, ETextureFlags.RENDERTARGET, 0, 0,
					ETextureTypes.TEXTURE_2D, EPixelFormats.FLOAT32_RGBA);

				pDeferredData[i] = pDeferredTextures[i].getBuffer().getRenderTarget();
				pDeferredData[i].setAutoUpdated(false);
				pViewport = pDeferredData[i].addViewport(new Viewport(this.getCamera(), "deferred_shading_pass_" + i,
											0, 0, this.actualWidth / pDeferredTextures[i].width, this.actualHeight / pDeferredTextures[i].height));
				pDeferredData[i].attachDepthTexture(pDepthTexture);

				if (i === 1) {
					pViewport.setDepthParams(true, false, ECompareFunction.EQUAL);
					pViewport.setClearEveryFrame(true, EFrameBufferTypes.COLOR);
				}
			}

//creatin deferred effects
			var pDSMethod: IRenderMethod = null;
			var pDSEffect: IEffect = null;

			pDSMethod = pResMgr.createRenderMethod(".deferred_shading" + iGuid);
			pDSEffect = pResMgr.createEffect(".deferred_shading" + iGuid);

			pDSEffect.addComponent("akra.system.deferredShading");
			pDSEffect.addComponent("akra.system.omniLighting");
			pDSEffect.addComponent("akra.system.projectLighting");
			pDSEffect.addComponent("akra.system.omniShadowsLighting");
			pDSEffect.addComponent("akra.system.projectShadowsLighting");
			pDSEffect.addComponent("akra.system.sunLighting");
			pDSEffect.addComponent("akra.system.sunShadowsLighting");

			pDSMethod.effect = pDSEffect;

			this._pDeferredEffect = pDSEffect;
			this._pDeferredView = pDefferedView;

			pDefferedView.getTechnique().setMethod(pDSMethod);

			this.setClearEveryFrame(false);
			this.setDepthParams(false, false, 0);

//AA is default
			this.setFXAA(true);
		}

		setCamera(pCamera: ICamera): bool {
			var isOk = super.setCamera(pCamera);
			this._pDeferredColorTextures[0].getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
			this._pDeferredColorTextures[1].getBuffer().getRenderTarget().getViewport(0).setCamera(pCamera);
			return isOk;
		}

		_updateDimensions(bEmitEvent: bool = true): void {
			super._updateDimensions(false);

			var pDeferredTextures: ITexture[] = this._pDeferredColorTextures;

			if (isDefAndNotNull(this._pDeferredDepthTexture)) {
				this._pDeferredDepthTexture.reset(math.ceilingPowerOfTwo(this.actualWidth), math.ceilingPowerOfTwo(this.actualHeight));
				for (var i = 0; i < 2; ++ i) {
					pDeferredTextures[i].reset(math.ceilingPowerOfTwo(this.actualWidth), math.ceilingPowerOfTwo(this.actualHeight));
					pDeferredTextures[i].getBuffer().getRenderTarget().getViewport(0)
						.setDimensions(0., 0., this.actualWidth / pDeferredTextures[i].width, this.actualHeight / pDeferredTextures[i].height)
				}
			}

			if (bEmitEvent) {
				this.viewportDimensionsChanged();
			}
		}

		_updateImpl (): void {
			this.prepareForDeferredShading();

//prepare deferred textures
			this._pDeferredColorTextures[0].getBuffer().getRenderTarget().update();
			this._pDeferredColorTextures[1].getBuffer().getRenderTarget().update();

//camera last viewport changed, because camera used in deferred textures updating
			this._pCamera._keepLastViewport(this);

//calculate lighting
			var pLights: util.ObjectArray = <util.ObjectArray>this.getCamera().display( 1 );

		    for (var i:  number  = 0; i < pLights.length; i++) {
		        pLights.value(i)._calculateShadows();
		    }

		    this._pLightPoints = pLights;

//render deferred
			this._pDeferredView.render(this);
		}

		endFrame(): void {
        	this.getTarget().getRenderer().executeQueue(false);
        }

		prepareForDeferredShading(): void {
			var pNodeList: IObjectArray = this.getCamera().display();

			for (var i:  number  = 0; i < pNodeList.length; ++ i) {
				var pSceneObject: ISceneObject = pNodeList.value(i);

				for (var k:  number  = 0; k < pSceneObject.totalRenderable; k++) {
					var pRenderable: IRenderableObject = pSceneObject.getRenderable(k);
					var pTechCurr: IRenderTechnique = pRenderable.getTechniqueDefault();

					for (var j:  number  = 0; j < 2; j++) {
						var sMethod: string = "deferred_shading_pass_" + j;
						var pTechnique: IRenderTechnique = pRenderable.getTechnique(sMethod);

						if (isNull(pTechnique) || pTechCurr.modified > pTechnique.modified) {
							if (!pRenderable.addRenderMethod(pRenderable.getRenderMethod(), sMethod)) {
								{ logger.setSourceLocation( "DSViewport.ts" , 228 ); logger.criticalError("cannot clone active render method"); } ;
							}

							pTechnique = pRenderable.getTechnique(sMethod);
							pTechnique._syncTable(pTechCurr);


							if (j === 0) {
								pTechnique._blockPass(1);
							}
							else {
								pTechnique._blockPass(0);
							}

							if (pTechnique.totalPasses > j) {
								var pPass: IRenderPass = pTechnique.getPass(j);
								pPass.blend("akra.system.prepareForDeferredShading", j);
							}

						}
					}
				}
			};

		}

		/**@inline*/  getSkybox(): ITexture { return this._pDeferredSkyTexture; }

		protected _getDepthRangeImpl(): IDepthRange{
			var pRange: IDepthRange = util.getDepthRange(this._pDeferredDepthTexture);
//[0,1] -> [-1, 1]
			pRange.min = pRange.min * 2. - 1.;
			pRange.max = pRange.max * 2. - 1.;

			return pRange;
		}



		/**@inline*/  getObject(x:  number , y:  number ): ISceneObject {
			return this.getTarget().getRenderer().getEngine().getComposer()._getObjectByRid(this._getRenderId(x, y));
		}

		/**@inline*/  getRenderable(x:  number , y:  number ): IRenderableObject {
			return this.getTarget().getRenderer().getEngine().getComposer()._getRenderableByRid(this._getRenderId(x, y));
		}

		pick(x:  number , y:  number ): IRIDPair {
			var pComposer: IAFXComposer = this.getTarget().getRenderer().getEngine().getComposer();
			var iRid:  number  = this._getRenderId(x, y);
			var pObject: ISceneObject = pComposer._getObjectByRid(iRid);
			var pRenderable: IRenderableObject = null;

			if (isNull(pObject) || !pObject.isFrozen()) {
				pRenderable = pComposer._getRenderableByRid(iRid);
			}
			else {
				pObject = null;
			}

			return {renderable: pRenderable, object: pObject};
		}

		/**@inline*/  _getRenderId(x:  number , y:  number ):  number  {
			return this._getDeferredTexValue(0, x, y).a;
		}

		_getDeferredTexValue(iTex:  number , x:  number , y:  number ): IColor {
			{ logger.setSourceLocation( "DSViewport.ts" , 297 ); logger.assert(x < this.actualWidth && y < this.actualHeight, "invalid pixel: {" + x + "(" + this.actualWidth + ")" + ", " + y + "(" + this.actualHeight + ")" + "}"); }
                                                                                                           ;

			var pColorTexture: ITexture = this._pDeferredColorTextures[iTex];

//depth texture has POT sized, but viewport not;
//depth texture attached to left bottom angle of viewport
			y = pColorTexture.height - y - 1;
			pFloatColorPixel.left = x;
			pFloatColorPixel.top = y;
			pFloatColorPixel.right = x + 1;
			pFloatColorPixel.bottom = y + 1;

			pColorTexture.getBuffer(0, 0).readPixels(pFloatColorPixel);

			return pFloatColorPixel.getColorAt(pColor, 0, 0);
		}

		getDepth(x:  number , y:  number ):  number  {
			{ logger.setSourceLocation( "DSViewport.ts" , 315 ); logger.assert(x < this.actualWidth && y < this.actualHeight, "invalid pixel: {" + x + ", " + y + "}"); } ;

			var pDepthTexture: ITexture = this._pDeferredDepthTexture;

//depth texture has POT sized, but viewport not;
//depth texture attached to left bottom angle of viewport
// y = y + (pDepthTexture.height - this.actualHeight);
// pDepthPixel.left = x;
// pDepthPixel.top = y;
// pDepthPixel.right = x + 1;
// pDepthPixel.bottom = y + 1;

			y = pDepthTexture.height - y - 1;
			pDepthPixel.left = x;
			pDepthPixel.top = y;
			pDepthPixel.right = x + 1;
			pDepthPixel.bottom = y + 1;

			pDepthTexture.getBuffer(0, 0).readPixels(pDepthPixel);

			return pDepthPixel.getColorAt(pColor, 0, 0).r;
		}

		setSkybox(pSkyTexture: ITexture): bool {
			if (pSkyTexture.textureType !== ETextureTypes.TEXTURE_CUBE_MAP) {
				return null;
			}

			var pTechnique: IRenderTechnique = this._pDeferredView.getTechnique();
			var pEffect: IEffect = this._pDeferredEffect;

			if (pSkyTexture) {
				pEffect.addComponent("akra.system.skybox", 1, 0);
			}
			else {
				pEffect.delComponent("akra.system.skybox", 1, 0);
			}

			this._pDeferredSkyTexture = pSkyTexture;

			this.addedSkybox(pSkyTexture);

			return true;
		}

		setFXAA(bValue: bool = true): void {
			var pEffect: IEffect = this._pDeferredEffect;

			if (bValue) {
				pEffect.addComponent("akra.system.fxaa", 2, 0);
			}
			else {
				pEffect.delComponent("akra.system.fxaa", 2, 0);
			}
		}


		highlight(iRid:  number ): void;
		highlight(pObject: ISceneObject, pRenderable: IRenderableObject = null): void;
		highlight(pPair: IRIDPair): void;
		highlight(a): void {
			var pComposer: IAFXComposer = this.getTarget().getRenderer().getEngine().getComposer();
			var pEffect: IEffect = this._pDeferredEffect;
			var iRid:  number  = 0;
			var p: IRIDPair = this._pHighlightedObject;
			var pObjectPrev: ISceneObject = p.object;

			if (isNull(arguments[0])) {
				p.object = null;
				p.renderable = null;
			}
			else if (isInt(arguments[0])) {
				p.object = pComposer._getObjectByRid(iRid);
				p.renderable = pComposer._getRenderableByRid(iRid);
			}
			else if (arguments[0] instanceof akra.scene.SceneObject) {
				p.object = arguments[0];
				p.renderable = arguments[1];
			}
			else {
				p.object = arguments[0].object;
				p.renderable = arguments[0].renderable;
			}

			if (p.object && isNull(pObjectPrev)) {
				pEffect.addComponent("akra.system.outline", 1, 0);
			}
			else if (isNull(p.object) && pObjectPrev) {
				pEffect.delComponent("akra.system.outline", 1, 0);
			}
		}

		isFXAA(): bool {
			return this.effect.hasComponent("akra.system.fxaa");
		}


		destroy(): void {
			super.destroy();

			this._pDeferredDepthTexture.destroyResource();

			this._pDeferredColorTextures[0].destroyResource();
			this._pDeferredColorTextures[1].destroyResource();

			this._pDeferredView.destroy();
			this._pDeferredView = null;

			this._pDeferredSkyTexture = null;
		}



		render(
			pTechnique: IRenderTechnique,
			iPass:  number ,
			pRenderable: IRenderableObject,
			pSceneObject: ISceneObject): void {

			var pPass: IRenderPass = pTechnique.getPass(iPass);
			var pDepthTexture: ITexture = this._pDeferredDepthTexture;
			var pDeferredTextures: ITexture[] = this._pDeferredColorTextures;

			switch (iPass) {
				case 0:
					var pLightUniforms: UniformMap = this._pLightingUnifoms;
					var pLightPoints: util.ObjectArray = this._pLightPoints;
					var pCamera: ICamera = this.getCamera();

					this.createLightingUniforms(pCamera, pLightPoints, pLightUniforms);

					pPass.setForeign("nOmni", pLightUniforms.omni.length);
				    pPass.setForeign("nProject", pLightUniforms.project.length);
				    pPass.setForeign("nOmniShadows", pLightUniforms.omniShadows.length);
				    pPass.setForeign("nProjectShadows", pLightUniforms.projectShadows.length);
				    pPass.setForeign("nSun", pLightUniforms.sun.length);
				    pPass.setForeign("nSunShadows", pLightUniforms.sunShadows.length);

				    pPass.setStruct("points_omni", pLightUniforms.omni);
				    pPass.setStruct("points_project", pLightUniforms.project);
				    pPass.setStruct("points_omni_shadows", pLightUniforms.omniShadows);
				    pPass.setStruct("points_project_shadows", pLightUniforms.projectShadows);
				    pPass.setStruct("points_sun", pLightUniforms.sun);
				    pPass.setStruct("points_sun_shadows", pLightUniforms.sunShadows);

				    for (var i:  number  = 0; i < pLightUniforms.textures.length; i++) {
				        pPass.setTexture("TEXTURE" + i, pLightUniforms.textures[i]);
				    }

				    pPass.setUniform("PROJECT_SHADOW_SAMPLER", pLightUniforms.samplersProject);
	    			pPass.setUniform("OMNI_SHADOW_SAMPLER", pLightUniforms.samplersOmni);
	    			pPass.setUniform("SUN_SHADOW_SAMPLER", pLightUniforms.samplersSun);

    				pPass.setUniform("MIN_SHADOW_VALUE", 0.5);
    				pPass.setUniform("SHADOW_CONSTANT", 5.e+2);

    				pPass.setUniform("SCREEN_TEXTURE_RATIO",
                                     Vec2.stackCeil.set(this.actualWidth / pDepthTexture.width, this.actualHeight / pDepthTexture.height) );

				    pPass.setTexture("DEFERRED_TEXTURE0", pDeferredTextures[0]);
				    pPass.setTexture("DEFERRED_TEXTURE1", pDeferredTextures[1]);
				    pPass.setTexture("SCENE_DEPTH_TEXTURE", pDepthTexture);
					break;

				case 1:
//skybox
					pPass.setTexture("DEFERRED_TEXTURE0", pDeferredTextures[0]);
				    pPass.setTexture("SKYBOX_TEXTURE", this._pDeferredSkyTexture);

				    pPass.setUniform("SCREEN_TEXTURE_RATIO",
                                     Vec2.stackCeil.set(this.actualWidth / pDepthTexture.width, this.actualHeight / pDepthTexture.height) );
//outline
					var p: IRIDPair = this._pHighlightedObject;

					if (!isNull(p.object)) {
						var iRid:  number  = this.getTarget().getRenderer().getEngine().getComposer()._calcRenderID(p.object, p.renderable);

						pPass.setUniform("OUTLINE_TARGET", iRid);
						pPass.setUniform("OUTLINE_SOID", (iRid - 1) >>> 10);
						pPass.setUniform("OUTLINE_REID", (iRid - 1) & 1023);
					}

					pPass.setTexture("DEFERRED_TEXTURE0", pDeferredTextures[0]);
					pPass.setUniform("SCREEN_TEXTURE_RATIO",
                                     Vec2.stackCeil.set(this.actualWidth / pDepthTexture.width, this.actualHeight / pDepthTexture.height) );
					break;
// case 2:
// 	pPass.setTexture("DEFERRED_TEXTURE0", pDeferredTextures[0]);
// 	pPass.setUniform("SCREEN_TEXTURE_RATIO",
//                                  vec2(this.actualWidth / pDepthTexture.width, this.actualHeight / pDepthTexture.height));
// break;
			}

			super.render(pTechnique, iPass, pRenderable, pSceneObject);
		}

		private resetUniforms(): void {
			var pUniforms = this._pLightingUnifoms;
			pUniforms.omni.clear();
		    pUniforms.project.clear();
		    pUniforms.sun.clear();
		    pUniforms.omniShadows.clear();
		    pUniforms.projectShadows.clear();
		    pUniforms.sunShadows.clear();
		    pUniforms.textures.clear();
		    pUniforms.samplersProject.clear();
		    pUniforms.samplersOmni.clear();
		    pUniforms.samplersSun.clear();
		}

		private createLightingUniforms(pCamera: ICamera, pLightPoints: IObjectArray, pUniforms: UniformMap): void {
			var pLight: ILightPoint;
			var pOmniLight: IOmniLight;
			var pProjectLight: IProjectLight;
			var pSunLight: ISunLight;
		    var i:  number , j:  number ;
		    var pUniformData: IUniform;
		    var pCameraView: IMat4 = pCamera.viewMatrix;

		    var v4fLightPosition: IVec4 =  Vec4.stackCeil.set() ;
		    var v3fLightTransformPosition: IVec3 =  Vec3.stackCeil.set() ;
		    var v4fTemp: IVec4 =  Vec4.stackCeil.set() ;

		    var pShadowCaster: IShadowCaster;
		    var m4fShadow: IMat4, m4fToLightSpace: IMat4;

		    var iLastTextureIndex:  number  = 0;
		    var sTexture: string = "TEXTURE";
		    var pEngine: IEngine = this.getTarget().getRenderer().getEngine();

		    this.resetUniforms();

		    for (i = 0; i < pLightPoints.length; i++) {
		        pLight = pLightPoints.value(i);

//all cameras in list already enabled
// if (!pLight.enabled) {
//     continue;
// }

		        v4fLightPosition.set(pLight.worldPosition, 1.);
		        pCameraView.multiplyVec4(v4fLightPosition, v4fTemp);
		        v3fLightTransformPosition.set(v4fTemp.x, v4fTemp.y, v4fTemp.z);

		        if (pLight.lightType === ELightTypes.OMNI) {

		        	pOmniLight = <IOmniLight>pLight;

		            if (pLight.isShadowCaster) {
		                pUniformData =  UniformOmniShadow.stackCeil ;
		                (<UniformOmniShadow>pUniformData).setLightData(<IOmniParameters>pLight.params, v3fLightTransformPosition);

		                var pDepthCube: ITexture[]				= pOmniLight.getDepthTextureCube();
		                var pShadowCasterCube: IShadowCaster[] 	= pOmniLight.getShadowCaster();

		                for (j = 0; j < 6; ++ j) {
		                    pShadowCaster = pShadowCasterCube[j];
		                    m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix,  Mat4.stackCeil.set() );
		                    pUniforms.textures.push(pDepthCube[j]);
		                    sTexture = "TEXTURE" + (pUniforms.textures.length - 1);

		                    (<UniformOmniShadow>pUniformData).setSampler(sTexture, j);
		                    pUniforms.samplersOmni.push((<UniformOmniShadow>pUniformData).SHADOW_SAMPLER[j]);
		                    (<UniformOmniShadow>pUniformData).setMatrix(m4fToLightSpace, pShadowCaster.optimizedProjection, j);
		                }

		                pUniforms.omniShadows.push(<UniformOmniShadow>pUniformData);
		            }
		            else {
		                pUniformData =  UniformOmni.stackCeil ;
		                (<UniformOmni>pUniformData).setLightData(<IOmniParameters>pLight.params, v3fLightTransformPosition);
		                pUniforms.omni.push(<UniformOmni>pUniformData);
		            }
		        }
		        else if (pLight.lightType === ELightTypes.PROJECT) {
		        	pProjectLight = <IProjectLight>pLight;
		        	pShadowCaster = pProjectLight.getShadowCaster();

		            if (pLight.isShadowCaster && pShadowCaster.isShadowCasted) {
		                pUniformData =  UniformProjectShadow.stackCeil ;
		                (<UniformProjectShadow>pUniformData).setLightData(<IProjectParameters>pLight.params, v3fLightTransformPosition);

		                m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix,  Mat4.stackCeil.set() );
		                pUniforms.textures.push(pProjectLight.getDepthTexture());
		                sTexture = "TEXTURE" + (pUniforms.textures.length - 1);

		                (<UniformProjectShadow>pUniformData).setSampler(sTexture);
		                pUniforms.samplersProject.push((<UniformProjectShadow>pUniformData).SHADOW_SAMPLER);
		                (<UniformProjectShadow>pUniformData).setMatrix(m4fToLightSpace, pShadowCaster.projectionMatrix, pShadowCaster.optimizedProjection);
		                pUniforms.projectShadows.push(<UniformProjectShadow>pUniformData);
		            }
		            else {
		                pUniformData =  UniformProject.stackCeil ;
		                (<UniformProject>pUniformData).setLightData(<IProjectParameters>pLight.params, v3fLightTransformPosition);
		                m4fShadow = pShadowCaster.projViewMatrix.multiply(pCamera.worldMatrix,  Mat4.stackCeil.set() );
		                (<UniformProject>pUniformData).setMatrix(m4fShadow);
		                pUniforms.project.push(<UniformProject>pUniformData);
		            }

		        }
		        else if (pLight.lightType === ELightTypes.SUN) {
		        	pSunLight = <ISunLight>pLight;
		        	pShadowCaster = pSunLight.getShadowCaster();

		        	if (pLight.isShadowCaster) {
		        		pUniformData =  UniformSunShadow.stackCeil ;
			        	var pSkyDome: ISceneModel = pSunLight.skyDome;
			        	var iSkyDomeId:  number  = pEngine.getComposer()._calcRenderID(pSkyDome, pSkyDome.getRenderable(0), false);
			        	(<UniformSunShadow>pUniformData).setLightData(<ISunParameters>pLight.params, iSkyDomeId);
			        	pUniforms.sunShadows.push(<UniformSunShadow>pUniformData);

			        	pUniforms.textures.push(pSunLight.getDepthTexture());
		            	sTexture = "TEXTURE" + (pUniforms.textures.length - 1);

		            	(<UniformSunShadow>pUniformData).setSampler(sTexture);
		            	pUniforms.samplersSun.push((<UniformSunShadow>pUniformData).SHADOW_SAMPLER);

		            	m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix,  Mat4.stackCeil.set() );
		            	(<UniformSunShadow>pUniformData).setMatrix(m4fToLightSpace, pShadowCaster.optimizedProjection);

		        	}
		        	else {
			        	pUniformData =  UniformSun.stackCeil ;
			        	var pSkyDome: ISceneModel = pSunLight.skyDome;
			        	var iSkyDomeId:  number  = pEngine.getComposer()._calcRenderID(pSkyDome, pSkyDome.getRenderable(0), false);
			        	(<UniformSun>pUniformData).setLightData(<ISunParameters>pLight.params, iSkyDomeId);
			        	pUniforms.sun.push(<UniformSun>pUniformData);
		        	}
		        }
		        else {
		        	{ logger.setSourceLocation( "DSViewport.ts" , 645 ); logger.criticalError("Invalid light point type detected."); } ;
		        }
		    }
		}


		addedSkybox (pSkyTexture): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).addedSkybox; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pSkyTexture) : _broadcast[i].listener (_recivier, pSkyTexture) ; } } } ; ;
		addedBackground (pTexture): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).addedBackground; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pTexture) : _broadcast[i].listener (_recivier, pTexture) ; } } } ; ;
	}
}













module akra.render {
	var pPixel: IPixelBox = new pixelUtil.PixelBox(new geometry.Box(0, 0, 1, 1), EPixelFormats.BYTE_RGBA, new Uint8Array(4));

	export class ColorViewport extends Viewport implements IViewport {
		protected _pGuidToColorMap: IntMap = <any>{};
		protected _pColorToSceneObjectMap: ISceneObject[] = new Array(256);
		protected _pColorToRenderableMap: IRenderableObject[] = new Array(256);

		/**@inline*/  get type(): EViewportTypes { return EViewportTypes.COLORVIEWPORT; }

		constructor(pCamera: ICamera, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0){
			super(pCamera,  ".color-picker" , fLeft, fTop, fWidth, fHeight, iZIndex);
		}

		_updateImpl(): void {
			var pVisibleObjects: IObjectArray = this.getCamera().display();
			var pRenderable: IRenderableObject;

			for(var i:  number  = 0; i < pVisibleObjects.length; ++ i){
				pVisibleObjects.value(i).prepareForRender(this);
			}


			for (var i = 0; i < 256; ++ i) {
				this._pColorToSceneObjectMap[i] = null;
				this._pColorToRenderableMap[i] = null;
			}

			for (var g in this._pGuidToColorMap) {
				this._pGuidToColorMap[g] = 0;
			}

			var r = 1;
			var s = 1;

			for (var i:  number  = 0; i < pVisibleObjects.length; ++ i) {
				var pSceneObject: ISceneObject = pVisibleObjects.value(i);

				this._pGuidToColorMap[pSceneObject.getGuid()] = s;
				this._pColorToSceneObjectMap[s] = pSceneObject;
				s ++;

				for (var j:  number  = 0; j < pSceneObject.totalRenderable; j++) {
					pRenderable = pSceneObject.getRenderable(j);

					if (!isNull(pRenderable) && !pRenderable.isFrozen()) {

						this._pGuidToColorMap[pRenderable.getGuid()] = r;
						this._pColorToRenderableMap[r] = pRenderable;
						r ++;

						this.prepareRenderableForPicking(pRenderable);
						pRenderable.render(this, this._csDefaultRenderMethod, pSceneObject);
					}
				}
			}

// this._pCamera = pOldCamera;
		}

		pick(x:  number  = 0, y:  number  = 0): IRIDPair {
			var pTarget: IRenderTarget = this.getTarget();

			if (pTarget instanceof RenderTexture) {
				var pPixelBuffer: IPixelBuffer = (<IRenderTexture>pTarget).getPixelBuffer();
				x = math.round(x);
				y = math.round(y);

				pPixel.left = x;
				pPixel.right = x + 1;
				pPixel.top = y;
				pPixel.bottom = y + 1;

				if (pPixelBuffer.readPixels(pPixel)) {
					console.log(pPixel.data[0], pPixel.data[1], pPixel.data[2], pPixel.data[3]);
					return {
						object: this._pColorToSceneObjectMap[pPixel.data[0]] || null,
						renderable: this._pColorToRenderableMap[pPixel.data[1]] || null
					};
				}
			}

			return null;
		}

		render(
			pTechnique: IRenderTechnique,
			iPass:  number ,
			pRenderable: IRenderableObject,
			pSceneObject: ISceneObject): void {

			var pPass: IRenderPass = pTechnique.getPass(iPass);

			pPass.setUniform("RENDERABLE_ID", this._pGuidToColorMap[pRenderable.getGuid()]);
			pPass.setUniform("OPTIMIZED_PROJ_MATRIX", this.getCamera().projectionMatrix);
//pPass.setUniform("color", util.colorToVec4(util.randomColor(true)));

			if (!isNull(pSceneObject)) {
				pPass.setUniform("SCENE_OBJECT_ID", this._pGuidToColorMap[pSceneObject.getGuid()]);
			}

			super.render(pTechnique, iPass, pRenderable, pSceneObject);
		}

		private prepareRenderableForPicking(pRenderable: IRenderableObject): void {
			var pRenderTechnique: IRenderTechnique = pRenderable.getTechnique(this._csDefaultRenderMethod);

			if(!isNull(pRenderTechnique)) {
				return;
			}


			var pRmgr: IResourcePoolManager = this.getTarget().getRenderer().getEngine().getResourceManager();
			var pMethodPool: IResourcePool = pRmgr.renderMethodPool;
			var pMethod: IRenderMethod = <IRenderMethod>pMethodPool.findResource(".method-color-picker");

			if (isNull(pMethod)) {
				pMethod = pRmgr.createRenderMethod(".method-color-picker");
				pMethod.effect = pRmgr.createEffect(".effect-color-picker");
				pMethod.effect.addComponent("akra.system.colorPicker");
			}

			pRenderable.addRenderMethod(pMethod, this._csDefaultRenderMethod);
		}
	}
}













module akra.render {
	export class TextureViewport extends Viewport implements IViewport {
		private _pTargetTexture: ITexture;
		private _pDeferredView: IRenderableObject;
		private _pEffect: IEffect;
		private _v4fMapping: IVec4 = new Vec4(0., 0., 1., 1.);

		/**@inline*/  get type(): EViewportTypes { return EViewportTypes.TEXTUREVIEWPORT; }

		constructor(pTexture: ITexture, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0){
			super(null,  ".see_texture" , fLeft, fTop, fWidth, fHeight, iZIndex);

			this._pTargetTexture = pTexture;
		}

		/**@inline*/  get effect(): IEffect {
			return this._pEffect;
		}

		_setTarget(pTarget: IRenderTarget): void {
			super._setTarget(pTarget);

			var pEngine: IEngine = this.getTarget().getRenderer(). getEngine();
			var pResMgr: IResourcePoolManager = pEngine.getResourceManager();
			var pDefferedView: IRenderableObject = new Screen(pEngine.getRenderer());


			var pSeeTextureMethod: IRenderMethod  	= pResMgr.createRenderMethod( ".see_texture"  + this.getGuid());
			var pSeeTextureEffect: IEffect 			= pResMgr.createEffect( ".see_texture"  + this.getGuid());

			pSeeTextureEffect.addComponent("akra.system.texture_to_screen");
			pSeeTextureMethod.effect = pSeeTextureEffect;

			pDefferedView.addRenderMethod(pSeeTextureMethod,  ".see_texture" );

			this._pDeferredView = pDefferedView;
			this._pEffect = pSeeTextureEffect;
		}

		_updateImpl (): void {
			this._pDeferredView.render(this,  ".see_texture" );
		}

		/**@inline*/  setMapping(x:  number , y:  number , w:  number , h:  number ): void {
			this._v4fMapping.set(x, y, w, h);
// console.log("set mapping > ", x, y, w, h, this._v4fMapping.toString());
		}

		render(
			pTechnique: IRenderTechnique,
			iPass:  number ,
			pRenderable: IRenderableObject,
			pSceneObject: ISceneObject): void {

			var pPass: IRenderPass = pTechnique.getPass(iPass);

			pPass.setTexture("TEXTURE0", this._pTargetTexture);
			pPass.setUniform("VIEWPORT", this._v4fMapping);

			super.render(pTechnique, iPass, pRenderable, pSceneObject);
		}
	}
}












/* Define the number of priority groups for the render system's render targets. */







module akra.render {

	export class RenderTarget implements IRenderTarget {
		protected _sName: string;
		protected _pRenderer: IRenderer;

		protected _iPriority:  number  =  4 ;

		protected _iWidth:  number ;
		protected _iHeight:  number ;

		protected _iColorDepth:  number ;
		protected _pDepthBuffer: IDepthBuffer = null;
		protected _pDepthPixelBuffer: IPixelBuffer = null;

		protected _pFrameStats: IFrameStats;

		protected _pTimer: IUtilTimer;
		protected _fLastSecond:  number ;
		protected _fLastTime:  number ;
		protected _iFrameCount:  number ;

		protected _isActive: bool = true;
		protected _isAutoUpdate: bool = true;

		protected _bHwGamma: bool = false;

		protected _pViewportList: IViewport[] = [];

//3d event handing
	    private _i3DEvents:  number  = 0;

		/**@inline*/  get name(): string { return this._sName; }
		/**@inline*/  set name(sName: string) { this._sName = sName; }

		/**@inline*/  get width():  number  { return this._iWidth; }
		/**@inline*/  get height():  number  { return this._iHeight; }
		/**@inline*/  get colorDepth():  number  { return this._iColorDepth; }

		/**@inline*/  get totalViewports():  number  { return this._pViewportList.length; }
		/**@inline*/  get totalFrames():  number  { return this._iFrameCount; }

		/**@inline*/  get priority():  number  { return this._iPriority; }

		constructor (pRenderer: IRenderer) {
			this._pRenderer = pRenderer;
			this._pTimer = pRenderer.getEngine().getTimer();
			this._pFrameStats = {
				fps: {
					last: 0.,
					avg: 0.,
					best: 0.,
					worst: 0.
				},
				time: {
					best: 0.,
					worst: 0.
				},
				polygonsCount: 0
			}
			this.resetStatistics();
		}

		enableSupportFor3DEvent(iType:  number ):  number  {
			if ( (((iType) & (E3DEventTypes.DRAGSTART | E3DEventTypes.DRAGSTOP | E3DEventTypes.DRAGGING)) != 0) ) {
				((iType) |= (E3DEventTypes.DRAGSTART | E3DEventTypes.DRAGSTOP | E3DEventTypes.DRAGGING | E3DEventTypes.MOUSEDOWN | E3DEventTypes.MOUSEUP | E3DEventTypes.MOUSEMOVE))
                                                                               ;
			}

//mouse over and mouse out events require mouse move
			if ( (((iType) & (E3DEventTypes.MOUSEOVER | E3DEventTypes.MOUSEOUT)) != 0) ) {
				((iType) |= (E3DEventTypes.MOUSEMOVE)) ;
			}

//get events that have not yet been activated
			var iNotActivate:  number  = (this._i3DEvents ^ 0x7fffffff) & iType;

			((this._i3DEvents) |= (iNotActivate)) ;

			return iNotActivate;
		}

		/**@inline*/  is3DEventSupported(eType: E3DEventTypes): bool {
			return  (((this._i3DEvents) & (< number >eType)) != 0) ;
		}

		/**@inline*/  getRenderer(): IRenderer { return this._pRenderer; }

		destroy(): void {
			var pViewport: IViewport;

			for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];
				this.viewportRemoved(pViewport)
				pViewport.destroy();
			}

			this.detachDepthBuffer();

			{ logger.setSourceLocation( "render/RenderTarget.ts" , 127 ); logger.log("RenderTarget '%s'\n Average FPS: %s\n Best FPS: %s\n Worst FPS: %s", this._sName, this._pFrameStats.fps.avg, this._pFrameStats.fps.best, this._pFrameStats.fps.worst); }
                                ;
		}

		getDepthBuffer(): IDepthBuffer {
			return this._pDepthBuffer;
		}

		attachDepthBuffer(pBuffer: IDepthBuffer): bool {
			var isOk: bool = false;

			if ((isOk = pBuffer.isCompatible(this))) {
				this.detachDepthBuffer();
				this._pDepthBuffer = pBuffer;
				this._pDepthBuffer._notifyRenderTargetAttached(this);
			}

			return isOk;
		}

		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool {

			if(this._iWidth !== pBuffer.width ||
			   this._iHeight !== pBuffer.height) {
				return false;
			}

			var eFormat: EPixelFormats = pBuffer.format;
			if(eFormat !== EPixelFormats.FLOAT32_DEPTH ||
			   eFormat !== EPixelFormats.DEPTH8){
				return false;
			}

			this.detachDepthPixelBuffer();
			this._pDepthPixelBuffer = pBuffer;

			return true;
		}

		detachDepthPixelBuffer(): void {
			if(this._pDepthPixelBuffer){
				this._pDepthPixelBuffer = null;
			}
		}

		detachDepthBuffer(): void {
			if (this._pDepthBuffer) {
				this._pDepthBuffer._notifyRenderTargetDetached( this );
				this._pDepthBuffer = null;
			}
		}

		attachDepthTexture(pTexture: ITexture): bool {
			return false;
		}

		detachDepthTexture(): void {

		}

		_detachDepthBuffer(): void {
			this._pDepthBuffer = null;
		}


		_beginUpdate(): void {
			this.preUpdate();

			this._pFrameStats.polygonsCount = 0;
		}

		_updateAutoUpdatedViewports(bUpdateStatistics: bool = true): void {
	        var pViewport: IViewport;

	        for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];

				if(pViewport.isAutoUpdated()) {
					this._updateViewport(pViewport, bUpdateStatistics);
				}
			}
		}

		_endUpdate(): void {
			this.postUpdate();
			this.updateStats();
		}

		_updateViewport(iZIndex:  number , bUpdateStatistics: bool = true): void;
		_updateViewport(pViewportPtr: IViewport, bUpdateStatistics: bool = true): void;
		_updateViewport(pViewportPtr: any, bUpdateStatistics: bool = true): void {
			var pViewport: IViewport;
			var iZIndex:  number

			if (isNumber(arguments[0])) {
				iZIndex = < number >arguments[0];
				pViewport = this._pViewportList[iZIndex];

				{ logger.setSourceLocation( "render/RenderTarget.ts" , 225 ); logger.assert(isDefAndNotNull(pViewport), "No viewport with given z-index : %s", iZIndex, "RenderTarget::_updateViewport"); }
                                     ;
			}
			else {
				pViewport = <IViewport>arguments[0];
			}

			{ logger.setSourceLocation( "render/RenderTarget.ts" , 232 ); logger.assert(pViewport.getTarget() == this, "RenderTarget::_updateViewport the requested viewport is not bound to the rendertarget!"); }
                                                                                             ;

			this.viewportPreUpdate(pViewport);

			pViewport.update();

			if (bUpdateStatistics) {
				this._pFrameStats.polygonsCount += pViewport._getNumRenderedPolygons();
			}

			this.viewportPostUpdate(pViewport);
		}

		addViewport(pViewport: IViewport): IViewport {
			if (isNull(pViewport)) {
				return null;
			}

			var iZIndex:  number  = pViewport.zIndex;

			if (isDefAndNotNull(this._pViewportList[iZIndex])) {
				{ logger.setSourceLocation( "render/RenderTarget.ts" , 254 ); logger.criticalError("Can't create another viewport for %s with Z-index %s 					because a viewport exists with this Z-Order already.", this._sName, iZIndex, "RenderTarget::addViewport"); } ;
			}

			pViewport._setTarget(this);

			this._pViewportList[iZIndex] = pViewport;
			this.viewportAdded(pViewport);

			return pViewport;
		}


		removeViewport(iZIndex:  number ): bool {
			var pViewport: IViewport = this._pViewportList[iZIndex];

			if (isDefAndNotNull(pViewport)) {
				this.viewportRemoved(pViewport);

				this._pViewportList.splice(iZIndex, 1);
				pViewport = null;

				return true;
			}

			return false;
		}

		removeAllViewports():  number  {
			var pViewport: IViewport;
			var iTotal:  number ;

			for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];
	            this.viewportRemoved(pViewport);
	        }

	        iTotal = this._pViewportList.length;

        	(<any>this._pViewportList).clear();

        	return iTotal;
		}

		/**@inline*/  getStatistics(): IFrameStats {
			return this._pFrameStats;
		}

		/**@inline*/  getLastFPS():  number  {
			return this._pFrameStats.fps.last;
		}

		/**@inline*/  getAverageFPS():  number  {
			return this._pFrameStats.fps.avg;
		}

		/**@inline*/  getBestFPS():  number  {
			return this._pFrameStats.fps.best;
		}

		/**@inline*/  getWorstFPS():  number  {
			return this._pFrameStats.fps.worst;
		}

		/**@inline*/  getPolygonCount():  number  {
			return this._pFrameStats.polygonsCount;
		}

		/**@inline*/  getBestFrameTime():  number  {
			return this._pFrameStats.time.best;
		}

		/**@inline*/  getWorstFrameTime():  number  {
			return this._pFrameStats.time.worst;
		}

		resetStatistics(): void {
			var pStats: IFrameStats = this._pFrameStats;
			pStats.fps.avg = 0.;
			pStats.fps.best = 0.;
			pStats.fps.last = 0.;
			pStats.fps.worst = 999.;

			pStats.polygonsCount = 0;

			pStats.time.best = 9999999;
			pStats.time.worst = 0;

//FIXME: get right time!!!
			this._fLastTime = this._pTimer.appTime;
			this._fLastSecond = this._fLastTime;
			this._iFrameCount = 0;
		}

		updateStats(): void {
			this._iFrameCount ++;

			var fThisTime:  number  = this._pTimer.appTime;

			var fFrameTime:  number  = fThisTime - this._fLastTime;

			this._pFrameStats.time.best = math.min(this._pFrameStats.time.best, fFrameTime);
			this._pFrameStats.time.worst = math.min(this._pFrameStats.time.worst, fFrameTime);

			if (fThisTime - this._fLastTime > 1.) {
				this._pFrameStats.fps.last = < number >this._iFrameCount / < number >(fThisTime - this._fLastSecond);

				if (this._pFrameStats.fps.avg == 0.) {
					this._pFrameStats.fps.avg = this._pFrameStats.fps.last;
				}
				else {
					this._pFrameStats.fps.avg = (this._pFrameStats.fps.avg + this._pFrameStats.fps.last) / 2.;

					this._pFrameStats.fps.best = math.max(this._pFrameStats.fps.best, this._pFrameStats.fps.last);
					this._pFrameStats.fps.worst = math.max(this._pFrameStats.fps.worst, this._pFrameStats.fps.last);

					this._fLastSecond = fThisTime;
					this._iFrameCount = 0;
				}

				this._fLastTime = fThisTime;
			}
		}

		getCustomAttribute(sName: string): any {
			return null;
		}

		getViewport(iIndex:  number ): IViewport {
			{ logger.setSourceLocation( "render/RenderTarget.ts" , 382 ); logger.assert(iIndex < this._pViewportList.length, "Index out of bounds"); } ;

			for (var i in this._pViewportList) {
				if (iIndex --) {
					continue;
				}

				return this._pViewportList[i];
			}

			return null;
		}

		getViewportByZIndex(iZIndex:  number ): IViewport {
			var pViewport: IViewport = this._pViewportList[iZIndex];

			{ logger.setSourceLocation( "render/RenderTarget.ts" , 399 ); logger.assert(isDefAndNotNull(pViewport), "No viewport with given z-index : " + String(iZIndex), "RenderTarget::getViewportByZIndex"); }
                                                           ;

			return pViewport;
		}

		/**@inline*/  hasViewportByZIndex(iZIndex:  number ): bool {
			return isDefAndNotNull(this._pViewportList[iZIndex]);
		}

		/**@inline*/  isActive(): bool {
			return this._isActive;
		}

		setActive(bValue: bool = true): void {
			this._isActive = bValue;
		}

		/**@inline*/  setAutoUpdated(isAutoUpdate: bool = true): void {
			this._isAutoUpdate = isAutoUpdate;
		}

		_notifyCameraRemoved(pCamera: ICamera): void {
			var isRemoved: bool = false;
			for (var i in this._pViewportList) {
				var pViewport: IViewport = this._pViewportList[i];

				if (pViewport.getCamera() === pCamera) {
					pViewport.setCamera(null);
					isRemoved = true;
				}
			}

			if (isRemoved) {
				this.cameraRemoved(pCamera);
			}
		}

		/**@inline*/  isAutoUpdated(): bool {
			return this._isAutoUpdate;
		}

		/**@inline*/  isPrimary(): bool {
// RenderWindow will override and return true for the primary window
			return false;
		}

		update(): void {
			this.updateImpl();
		}

		readPixels(ppDest?: IPixelBox, eFramebuffer?: EFramebuffer): IPixelBox {
			return null;
		}


		protected updateImpl(): void {
			this._beginUpdate();
			this._updateAutoUpdatedViewports(true);
			this._endUpdate();
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return RenderTarget._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;

		preUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).preUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		viewportPreUpdate (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportPreUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
		viewportPostUpdate (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportPostUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
		viewportAdded (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportAdded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
		viewportRemoved (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
		postUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).postUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ;

		resized (iWidth, iHeight): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).resized; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, iWidth, iHeight) : _broadcast[i].listener (_recivier, iWidth, iHeight) ; } } } ; ;

		cameraRemoved (pCamera): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).cameraRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pCamera) : _broadcast[i].listener (_recivier, pCamera) ; } } } ; ;
	}
}



















module akra.render {
	export class RenderEntry implements IRenderEntry {
//target of rendering
		viewport: IViewport = null;
		renderTarget: IRenderTarget = null;
//wraper for shader program
		maker: IAFXMaker = null;
//complex info of native shader data
// + buffers
// + uniforms
// + samplers
		input: IShaderInput = null;
//needed for call direct render with index
		bufferMap: IBufferMap = null;


		clear(): void {
			this.maker._releaseShaderInput(this.input);
			this.viewport = null;
			this.renderTarget = null;
			this.bufferMap = null;
			this.input = null;
			this.maker = null;
		}
	}
}





module akra.render {
	export class RenderQueue implements IRenderQueue {
		protected _pRenderer: IRenderer;
		protected _pEntryList: util.ObjectArray;
		protected _fnSortFunction: Function = null;

		constructor (pRenderer: IRenderer) {
			this._pRenderer = pRenderer;
			this._pEntryList = new util.ObjectArray;
			this._fnSortFunction = function(a: IRenderEntry, b: IRenderEntry):  number {
				if(isNull(a) || isNull(a.maker)){
					return 1;
				}
				if(isNull(b) || isNull(b.maker)){
					return -1;
				}
				else {
					return a.maker.getGuid() - b.maker.getGuid();
				}
			}
		}

		bForceDisableSort: bool = false;
// nCount: uint = 0;
// fAVGMakerSeq: float = 0.;

		execute(bSort?: bool = false): void {
			this._pRenderer._beginRender();
			if(bSort && this._pEntryList.length > 0 && !this.bForceDisableSort){
				this.quickSortQueue(0, this._pEntryList.length - 1);
// this._pEntryList._pData.sort(<any>this._fnSortFunction);
			}

// var nCountOfMakerSeq: uint = 0;
// var pLastMaker: IAFXMaker = null;

			for (var i:  number  = 0; i < this._pEntryList.length; i++) {
				var pEntry: IRenderEntry = this._pEntryList.value(i);

// var pMaker: IAFXMaker = pEntry.maker;
// if(pMaker !== pLastMaker){
// 	nCountOfMakerSeq++;
// }
// pLastMaker = pMaker;

				this._pRenderer._renderEntry(pEntry);

				this.releaseEntry(pEntry);

			}

// if(this.nCount % 1000 === 0){
// 	LOG("AVG count of sequences of makers:", this.fAVGMakerSeq);
// 	this.nCount = 0;
// 	this.fAVGMakerSeq = 0.;
// }

// this.fAVGMakerSeq = (this.fAVGMakerSeq * this.nCount + nCountOfMakerSeq) / (this.nCount + 1);
// this.nCount++;

			this._pEntryList.clear(false);

			this._pRenderer._endRender();
		}

		quickSortQueue(iStart:  number , iEnd:  number ): void {
			var i:  number  = iStart;
			var j:  number  = iEnd;
			var iMiddle:  number  = this._pEntryList.value((iStart + iEnd)>>1).maker.getGuid();

			do {
				while(this._pEntryList.value(i).maker.getGuid() < iMiddle) ++i;
				while(this._pEntryList.value(j).maker.getGuid() > iMiddle) --j;

				if(i <= j){
					this._pEntryList.swap(i, j);
					i++; j--;
				}
			}
			while(i < j);

			if(iStart < j) this.quickSortQueue(iStart, j);
			if(i < iEnd) this.quickSortQueue(i, iEnd);
		}

		push(pEntry: IRenderEntry): void {
			this._pEntryList.push(pEntry);
		}

		/**@inline*/  createEntry(): IRenderEntry {
			return RenderQueue.createEntry();
		}

		/**@inline*/  releaseEntry(pEntry: IRenderEntry): void {
			return RenderQueue.releaseEntry(pEntry);
		}

		static createEntry(): IRenderEntry {
			return RenderQueue.pool.length > 0? RenderQueue.pool.pop(): new RenderEntry;
		}

		static releaseEntry(pEntry: IRenderEntry): void {
			RenderQueue.pool.push(pEntry);
			pEntry.clear();
		}

		static pool: util.ObjectArray = new util.ObjectArray;
	}
}



module  akra.render {
	export var SShaderPrefixes = {
		k_Sampler    : "A_s_",
		k_Header     : "A_h_",
		k_Attribute  : "A_a_",
		k_Offset     : "A_o_",
		k_Texture    : "TEXTURE",
		k_Texcoord   : "TEXCOORD",
		k_Texmatrix  : "TEXMATRIX",
		k_Temp       : "TEMP_",
		k_BlendType  : "AUTO_BLEND_TYPE_"
	};

	export var ZEROSAMPLER:  number  = 19;

	export var SSystemSemantics = {
		MODEL_MATRIX: 		"MODEL_MATRIX",
		VIEW_MATRIX: 		"VIEW_MATRIX",
		PROJ_MATRIX: 		"PROJ_MATRIX",
		NORMAL_MATRIX: 		"NORMAL_MATRIX",
		BIND_MATRIX: 		"BIND_SHAPE_MATRIX",
		RENDER_OBJECT_ID: 	"RENDER_OBJECT_ID"
	}

	export interface IRenderTargetPriorityMap {
		[priority:  number ]: IRenderTarget[];
	}

	export class Renderer implements IRenderer {
		protected _isActive: bool = false;
		protected _pEngine: IEngine;
		protected _pRenderTargets: IRenderTarget[] = [];
		protected _pPrioritisedRenderTargets: IRenderTargetPriorityMap = <IRenderTargetPriorityMap>{};
		protected _pPriorityList:  number [] = [];
		protected _pRenderQueue: RenderQueue = null;
		protected _pActiveViewport: IViewport = null;
		protected _pActiveRenderTarget: IRenderTarget = null;
/** TODO: FIX RENDER TARGET LOCK*/

		protected _bLockRenderTarget: bool = false;

		constructor (pEngine: IEngine) {
			this._pEngine = pEngine;

			this.connect(pEngine,  "active" ,  "active" );
			this.connect(pEngine,  "inactive" ,  "inactive" );

			this._pRenderQueue = new RenderQueue(this);
		}


		/**@inline*/  getEngine(): IEngine { return this._pEngine; }


	    hasCapability(eCapability: ERenderCapabilities): bool {
	      return false;
	    }


		debug(bValue?: bool, useApiTrace?: bool): bool {
			return false;
		}

		isDebug(): bool {
			return false;
		}

		isValid(): bool {
			return true;
		}

		/**@inline*/  getError(): string {
			return null;
		}

		_beginRender(): void { }

		_renderEntry(pEntry: IRenderEntry): void { }

		_endRender(): void { }

		clearFrameBuffer(iBuffer:  number , cColor: IColor, fDepth:  number , iStencil:  number ): void { }

 		attachRenderTarget(pTarget: IRenderTarget): bool {
 			if (this._pRenderTargets.indexOf(pTarget) != -1) {
 				return false;
 			}

 			var pList: IRenderTarget[] = this._pPrioritisedRenderTargets[pTarget.priority];

 			if (!isDef(pList)) {
 				pList = this._pPrioritisedRenderTargets[pTarget.priority] = [];
 				this._pPriorityList.push(pTarget.priority);
 				this._pPriorityList.sort(fnSortMinMax);
 			}

 			pList.push(pTarget);

 			this._pRenderTargets.push(pTarget);

 			return true;
 		}

        detachRenderTarget(pTarget: IRenderTarget): bool {
       		var i = this._pRenderTargets.indexOf(pTarget);

       		if (i == -1) {
       			return false;
       		}

       		this._pRenderTargets.splice(i, 1);

       		i = this._pPrioritisedRenderTargets[pTarget.priority].indexOf(pTarget);
       		this._pPrioritisedRenderTargets[pTarget.priority].splice(i, 1);

       		return true;
        }

        destroyRenderTarget(pTarget: IRenderTarget): void {
        	var hasTarget: bool = this.detachRenderTarget(pTarget);
        	if(hasTarget){
        		pTarget.destroy();
        		pTarget = null;
        	}
        }

        getActiveProgram(): IShaderProgram {
        	{ logger.setSourceLocation( "render/Renderer.ts" , 158 ); logger.criticalError("Renderer::getActiveProgram() is uncompleted method!"); } ;
        	return null;
        }

		/**@inline*/  _disableAllTextureUnits(): void {
			this._disableTextureUnitsFrom(0);
		}

		/**@inline*/  _disableTextureUnitsFrom(iUnit:  number ): void {

		}

		_initRenderTargets(): void {
// Init stats
	        for(var i:  number  = 0; i < this._pRenderTargets.length; ++ i) {
	            this._pRenderTargets[i].resetStatistics();
	        }
		}

		_updateAllRenderTargets(): void {
			var pTarget: IRenderTarget;
			for (var i:  number  = 0; i < this._pPriorityList.length; i++) {
				var iPriority:  number  = this._pPriorityList[i];
				var pTargetList: IRenderTarget[] = this._pPrioritisedRenderTargets[iPriority];

				for (var j = 0; j < pTargetList.length; ++ j) {
					pTarget = pTargetList[j];

					if (pTarget.isActive() && pTarget.isAutoUpdated()) {
						pTarget.update();
					}
				}
			}

		}

		_setViewport(pViewport: IViewport): void {}

		_setViewportForRender(pViewport: IViewport): void {
			var isViewportUpdate: bool = pViewport !== this._pActiveViewport || pViewport.isUpdated();
			var isRenderTargetUpdate: bool = pViewport.getTarget() !== this._pActiveRenderTarget;

			if(isViewportUpdate || isRenderTargetUpdate){
				this._setViewport(pViewport);

				if(isViewportUpdate){
// pViewport._clearForFrame();
					var pState: IViewportState = pViewport._getViewportState();

					this._setCullingMode(pState.cullingMode);
		        	this._setDepthBufferParams(pState.depthTest, pState.depthWrite,
	        							   pState.depthFunction, pState.clearDepth);
	        	}
			}
		}

		_getViewport(): IViewport {
			return this._pActiveViewport;
		}

		_setRenderTarget(pTarget: IRenderTarget): void {}

		_setCullingMode(eMode: ECullingMode): void {}

        _setDepthBufferParams(bDepthTest: bool, bDepthWrite: bool,
        					  eDepthFunction: ECompareFunction, fClearDepth?:  number ): void {}

		getDefaultCanvas(): ICanvas3d {
			return null;
		}

		/**@inline*/  createEntry(): IRenderEntry {
			return this._pRenderQueue.createEntry();
		}

        /**@inline*/  releaseEntry(pEntry: IRenderEntry): void {
        	this._pRenderQueue.releaseEntry(pEntry);
        }

        /**@inline*/  pushEntry(pEntry: IRenderEntry): void{
        	this._pRenderQueue.push(pEntry);
        }

        /**@inline*/  executeQueue(bSort?: bool = false): void {
        	this._pRenderQueue.execute(bSort);
        }

        /**@inline*/  _lockRenderTarget(): void {
        	this._bLockRenderTarget = true;
        }

        /**@inline*/  _unlockRenderTarget(): void {
        	this._bLockRenderTarget = false;
        }

        /**@inline*/  _isLockRenderTarget(): bool {
        	return this._bLockRenderTarget;
        }

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Renderer._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		 active(pEngine: IEngine): void {
			this._isActive = true;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).active; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pEngine) : _broadcast[i].listener (_recivier, pEngine) ; } } ;
		}

		 inactive(pEngine: IEngine): void {
			this._isActive = false;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).inactive; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pEngine) : _broadcast[i].listener (_recivier, pEngine) ; } } ;
		}

	}
};













module akra {
	export interface IClickable extends IEventProvider {
		 onclick: (target: any, x:  number , y:  number ) => void;
		 onmousemove: (target: any, x:  number , y:  number ) => void;
		 onmousedown: (target: any, eBtn: EMouseButton, x:  number , y:  number ) => void;
		 onmouseup: (target: any, eBtn: EMouseButton, x:  number , y:  number ) => void;
		 onmouseover: (target: any, x:  number , y:  number ) => void;
		 onmouseout: (target: any, x:  number , y:  number ) => void;
		 onmousewheel: (target: any, x:  number , y:  number , delta:  number ) => void;

		 ondragstart: (target: any, eBtn: EMouseButton, x:  number , y:  number ) => void;
		 ondragstop: (target: any, eBtn: EMouseButton, x:  number , y:  number ) => void;
		 ondragging: (target: any, eBtn: EMouseButton, x:  number , y:  number ) => void;

		 click(x:  number , y:  number ): void;
		 mousemove(x:  number , y:  number ): void;
		 mousedown(eBtn: EMouseButton, x:  number , y:  number ): void;
		 mouseup(eBtn: EMouseButton, x:  number , y:  number ): void;
		 mouseover(x:  number , y:  number ): void;
		 mouseout(x:  number , y:  number ): void;
		 mousewheel(x:  number , y:  number , delta:  number ): void;

		 dragstart(eBtn: EMouseButton, x:  number , y:  number ): void;
		 dragstop(eBtn: EMouseButton, x:  number , y:  number ): void;
		 dragging(eBtn: EMouseButton, x:  number , y:  number ): void;
	}
}























module akra.util {

	export class UtilTimer implements IUtilTimer {
		private isTimerInitialized: bool = false;
		private isTimerStopped: bool = false;
		private fTicksPerSec:  number  = 0.;
		private iStopTime:  number  = 0;
		private iLastElapsedTime:  number  = 0;
		private iBaseTime:  number  = 0;

		/**@inline*/  get absoluteTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME);
		}

		/**@inline*/  get appTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_APP_TIME);
		}

		/**@inline*/  get elapsedTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_ELAPSED_TIME);
		}

		/**@inline*/  start(): bool {
			return this.execCommand(EUtilTimerCommands.TIMER_START) === 0;
		}
        /**@inline*/  stop(): bool {
        	return this.execCommand(EUtilTimerCommands.TIMER_STOP) === 0;
        }

        /**@inline*/  reset(): bool {
        	return this.execCommand(EUtilTimerCommands.TIMER_RESET) === 0;
        }

        execCommand(eCommand: EUtilTimerCommands):  number  {
		    var fTime:  number  = 0.;
		    var fElapsedTime:  number  = 0.;
		    var iTime:  number ;

		    if (this.isTimerInitialized == false) {
		        this.isTimerInitialized = true;
		        this.fTicksPerSec = 1000;
		    }

// Get either the current time or the stop time, depending
// on whether we're stopped and what command was sent
		    if (this.iStopTime != 0 && eCommand != EUtilTimerCommands.TIMER_START &&
		    	eCommand != EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME) {
		        iTime = this.iStopTime;
		    }
		    else {
		        iTime = now();
		    }

// Return the elapsed time
		    if (eCommand == EUtilTimerCommands.TIMER_GET_ELAPSED_TIME) {
		        fElapsedTime = (iTime - this.iLastElapsedTime) / this.fTicksPerSec;
// LOG(iTime - this.iLastElapsedTime,  this.fTicksPerSec, fElapsedTime);
		        this.iLastElapsedTime = iTime;
		        return fElapsedTime;
		    }

// Return the current time
		    if (eCommand == EUtilTimerCommands.TIMER_GET_APP_TIME) {
		        var fAppTime = ( iTime - this.iBaseTime ) / this.fTicksPerSec;
		        return fAppTime;
		    }

// Reset the timer
		    if (eCommand == EUtilTimerCommands.TIMER_RESET) {
		        this.iBaseTime = iTime;
		        this.iLastElapsedTime = iTime;
		        this.iStopTime = 0;
		        this.isTimerStopped = false;
		        return 0;
		    }

// Start the timer
		    if (eCommand == EUtilTimerCommands.TIMER_START) {
		        if (this.isTimerStopped) {
		            this.iBaseTime += iTime - this.iStopTime;
		        }
		        this.iStopTime = 0;
		        this.iLastElapsedTime = iTime;
		        this.isTimerStopped = false;
		        return 0;
		    }

// Stop the timer
		    if (eCommand == EUtilTimerCommands.TIMER_STOP) {
		        if (!this.isTimerStopped) {
		            this.iStopTime = iTime;
		            this.iLastElapsedTime = iTime;
		            this.isTimerStopped = true;
		        }
		        return 0;
		    }

// Advance the timer by 1/10th second
		    if (eCommand == EUtilTimerCommands.TIMER_ADVANCE) {
		        this.iStopTime += this.fTicksPerSec / 10;
		        return 0;
		    }

		    if (eCommand == EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME) {
		        fTime = iTime / this.fTicksPerSec;
		        return  fTime;
		    }
// Invalid command specified
		    return -1;
        }

        static start(): UtilTimer {
        	var pTimer: UtilTimer = new UtilTimer;

        	if (pTimer.start()) {
        		return pTimer;
        	}

        	{ logger.setSourceLocation( "util/UtilTimer.ts" , 124 ); logger.error('cannot start util timer'); } ;

        	return null;
        }
	}
}






module akra.render {
	export class Canvas3d extends RenderTarget implements ICanvas3d {
// private _useHarwareAntialiasing: bool = false;

		protected _isFullscreen: bool = false;
		protected _isPrimary: bool = false;
		protected _bAutoDeactivatedOnFocusChange: bool = false;

		left:  number  = 0;
		top:  number  = 0;

		get type(): ECanvasTypes {
			return ECanvasTypes.TYPE_3D;
		}


		constructor (pRenderer: IRenderer) {
			super(pRenderer);
			this._pRenderer = pRenderer;
		}


		create(sName: string, iWidth?:  number , iHeight?:  number , isFullscreen: bool = false): bool {
			return false;
		}

		destroy(): void {}

		setFullscreen(isFullscreen?: bool): void {}

		setVisible(bVisible?: bool): void {}
		setDeactivateOnFocusChange(bDeactivate?: bool): void {
			this._bAutoDeactivatedOnFocusChange = bDeactivate;
		}

		/**@inline*/  isFullscreen(): bool {
			return this._isFullscreen;
		}

		isVisible(): bool {
			return true;
		}

		isClosed(): bool {
			return false;
		}

		isPrimary(): bool {
			return this._isPrimary;
		}

		isDeactivatedOnFocusChange(): bool {
			return this._bAutoDeactivatedOnFocusChange;
		}


		resize(iWidth:  number , iHeight:  number ): void {

		}
	}
}









module akra.webgl {

	function absorbEvent(e) {
		e.preventDefault && e.preventDefault();
		e.stopPropagation && e.stopPropagation();
		e.cancelBubble = true;
		e.returnValue = false;
    }

	export class WebGLCanvas extends render.Canvas3d implements IClickable {
		protected _pCanvas: HTMLCanvasElement;
		protected _pCanvasCreationInfo: ICanvasInfo;

//display size, if fullscreen not used
		protected _iRealWidth:  number ;
		protected _iRealHeight:  number ;

//last viewport, that can be finded by mouse event
//needed for simulating mouseover/mouseout events
		protected _p3DEventViewportLast: IViewport = null;
		protected _p3DEventDragTarget: IViewport = null;
		protected _p3DEventMouseDownPos: IPoint = {x: 0, y: 0};
//на сколько пикселей надо протащить курсор, чтобы сработал dragging
		protected _i3DEventDragDeadZone:  number  = 2;
		protected _b3DEventDragging: bool = false;
		protected _e3DEventDragBtn: EMouseButton = EMouseButton.UNKNOWN;
//переменная нужна, для того чтобы пропустить событие клика приходящее после окончания драггинга
//так как драггинг заканчивается вместе с событием отжатия мыши, которое в свою очередь всегда приходит раньше 
//клика
		protected _b3DEventSkipNextClick: bool = false;



		get left():  number  {
			var el: HTMLElement = this._pCanvas;
			for (var lx:  number  = 0; el != null; lx += el.offsetLeft, el = <HTMLElement>el.offsetParent);
			return lx;
		}

		get top():  number  {
			var el: HTMLElement = this._pCanvas;
			for (var ly:  number  = 0; el != null; ly += el.offsetTop, el = <HTMLElement>el.offsetParent);
			return ly;
		}

		set left(x:  number ) {
//TODO
		}

		set top(x:  number ) {
//TODO
		}

		/**@inline*/  get el(): HTMLCanvasElement { return this._pCanvas; }

		constructor (pRenderer: IRenderer) {
			super(pRenderer);
			this._pCanvas = (<any>pRenderer).getHTMLCanvas();
			this._pCanvasCreationInfo = info.canvas(this._pCanvas);
		}

		hideCursor(bHide: bool = true): void {
			if (bHide) {
				this.el.style.cursor = "none";
			}
			else {
				this.el.style.cursor = "auto";
			}
		}

		setCursor(sType: string): void {
			this.el.style.cursor = sType;
		}

		create(sName: string = null, iWidth:  number  = this._pCanvasCreationInfo.width,
				iHeight:  number  = this._pCanvasCreationInfo.height, isFullscreen: bool = false): bool {

			this.name = sName;

			this.resize(iWidth, iHeight);
			this.setFullscreen(isFullscreen);

			return true;
		}


		enableSupportFor3DEvent(iType:  number ):  number  {

			var iActivated:  number  = super.enableSupportFor3DEvent(iType);

			if (iActivated & E3DEventTypes.CLICK) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 102 ); logger.log("WebGLCanvas activate <CLICK> event handing"); } ;
				this.el.addEventListener("click", (e: MouseEvent): bool => {
					absorbEvent(e);
//0 --> 149, 149/150 --> 0
/*, e*/
					this.click(e.offsetX, this.height - e.offsetY - 1       );
					return false;
				}, true);
			}

			if (iActivated & E3DEventTypes.MOUSEMOVE) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 112 ); logger.log("WebGLCanvas activate <MOUSEMOVE> event handing"); } ;
				this.el.addEventListener("mousemove", (e: MouseEvent): bool => {
					absorbEvent(e);
/*, e*/
					this.mousemove(e.offsetX, this.height - e.offsetY - 1       );
					return false;
				}, true);
			}

			if (iActivated & E3DEventTypes.MOUSEDOWN) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 121 ); logger.log("WebGLCanvas activate <MOUSEDOWN> event handing"); } ;
				this.el.addEventListener("mousedown", (e: MouseEvent): bool => {
					absorbEvent(e);
/*, e*/
					this.mousedown(e.which, e.offsetX, this.height - e.offsetY - 1       );
					return false;
				}, true);
			}

			if (iActivated & E3DEventTypes.MOUSEUP) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 130 ); logger.log("WebGLCanvas activate <MOUSEUP> event handing"); } ;
				this.el.addEventListener("mouseup", (e: MouseEvent): bool => {
					absorbEvent(e);
/*, e*/
					this.mouseup(e.which, e.offsetX, this.height - e.offsetY - 1       );
					return false;
				}, true);
			}

			if (iActivated & E3DEventTypes.MOUSEOVER) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 139 ); logger.log("WebGLCanvas activate <MOUSEOVER> event handing"); } ;
				this.el.addEventListener("mouseover", (e: MouseEvent): bool => {
					absorbEvent(e);
/*, e*/
					this.mouseover(e.offsetX, this.height - e.offsetY - 1       );
					return false;
				}, true);
			}

			if (iActivated & E3DEventTypes.MOUSEOUT) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 148 ); logger.log("WebGLCanvas activate <MOUSEOUT> event handing"); } ;
				this.el.addEventListener("mouseout", (e: MouseEvent): bool => {
					absorbEvent(e);
/*, e*/
					this.mouseout(e.offsetX, this.height - e.offsetY - 1       );
					return false;
				}, true);
			}

			if (iActivated & E3DEventTypes.MOUSEWHEEL) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 157 ); logger.log("WebGLCanvas activate <MOUSEWHEEL> event handing"); } ;
				this.el.addEventListener("mousewheel", (e: MouseWheelEvent): bool => {
					absorbEvent(e);

//FIXME: skipping middle button click
					if (isDef(e["wheelDeltaX"]) && e["wheelDeltaX"] > 0) {
// console.log("skip mouse wheel event:", e);
						return;
					}

/*, e*/
					this.mousewheel(e.offsetX, this.height - e.offsetY - 1, e.wheelDelta       );
					return false;
				}, true);
			}

			return iActivated;
		}


		destroy(): void {
			super.destroy();

			this._pCanvas = null;
			this._pCanvasCreationInfo = null;
		}

		getCustomAttribute(sName: string): any {
			return null;
		}

		setFullscreen(isFullscreen: bool = true): void  {
			var pCanvasElement: HTMLCanvasElement = this._pCanvas;
			var pScreen: IScreenInfo;
			var pCanvasInfo: ICanvasInfo;
			var iRealWidth:  number  = this._iRealWidth;
			var iRealHeight:  number  = this._iRealHeight;
			var pCanvas: WebGLCanvas = this;

			if (this._isFullscreen === isFullscreen) {
				return;
			}

			if (WebGLCanvas.fullscreenLock) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 200 ); logger.warning("fullscreen is changing, do not try change before process will be ended"); } ;
				return;
			}

			this._isFullscreen = isFullscreen;

			if (isFullscreen) {
				iRealWidth = this._iRealWidth = this._iWidth;
				iRealHeight = this._iRealHeight = this._iHeight;
			}

			var el: any = pCanvasElement,
				doc: any = document,
				rfs =
	               el.requestFullScreen
	            || el.webkitRequestFullScreen
	            || el.mozRequestFullScreen

			try {
				WebGLCanvas.fullscreenLock = true;

				if (isFullscreen) {
					rfs.call(el);
				}

				el.onfullscreenchange =
				el.onmozfullscreenchange =
				el.onwebkitfullscreenchange = el.onfullscreenchange || (e) => {

					if (!!( doc.webkitFullscreenElement ||
							doc.mozFullScreenElement ||
							doc.fullscreenElement)) {
						pCanvas.resize(info.screen.width, info.screen.height);
					}
					else {
						this.setFullscreen(false);
						pCanvas.resize(iRealWidth, iRealHeight);
					}

					WebGLCanvas.fullscreenLock = false;
				}
			}
			catch (e) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 243 ); logger.error("Fullscreen API not supported", e); } ;
				throw e;
			}
		}


		/**@inline*/  isVisible(): bool { return this._pCanvas.style.display !== "none"; }

		setVisible(bVisible: bool = true): void {
			this._pCanvas.style.display = bVisible? "block": "none";
		}

		resize(iWidth:  number  = this._iWidth, iHeight:  number  = this._iHeight): void {
			if (this.width === iWidth && this.height === iHeight) {
				return;
			}

			var pCanvas: HTMLCanvasElement = this._pCanvas;

			this._iWidth = iWidth;
			this._iHeight = iHeight;

			pCanvas.width = iWidth;
			pCanvas.height = iHeight;

			this.resized(iWidth, iHeight);
		}

		readPixels(ppDest: IPixelBox = null, eFramebuffer: EFramebuffer = EFramebuffer.AUTO): IPixelBox {
			if (isNull(ppDest)) {
				var ePixelFormat: EPixelFormats = EPixelFormats.BYTE_RGB;

				ppDest = new pixelUtil.PixelBox(this._iWidth, this._iHeight, 1, ePixelFormat,
					new Uint8Array(pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, ePixelFormat)));
			}

			if ((ppDest.right > this._iWidth) || (ppDest.bottom > this._iHeight) || (ppDest.front != 0) || (ppDest.back != 1)) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 280 ); logger.criticalError("Invalid box.", "GLXWindow::copyContentsToMemory"); } ;
			}

			if (eFramebuffer == EFramebuffer.AUTO) {
				eFramebuffer = this._isFullscreen? EFramebuffer.FRONT: EFramebuffer.BACK;
			}

			var eFormat:  number  = getWebGLFormat(ppDest.format);
			var eType:  number  = getWebGLDataType(ppDest.format);

			if (eFormat ==  0  || eType == 0) {
				{ logger.setSourceLocation( "WebGLCanvas.ts" , 291 ); logger.criticalError("Unsupported format.", "WebGLCanvas::readPixels"); } ;
			}

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer._setViewport(this.getViewport(0));
			pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , null);

// Must change the packing to ensure no overruns!
			pWebGLRenderer.pixelStorei( 0x0D05 , 1);

//glReadBuffer((buffer == FB_FRONT)? GL_FRONT : GL_BACK);
// LOG("readPixels(", ppDest.left, ppDest.top, ppDest.width, ppDest.height, eFormat, eType, /*ppDest.data,*/ ")");
			pWebGLContext.readPixels(ppDest.left, ppDest.top, ppDest.width, ppDest.height, eFormat, eType, ppDest.data);

// restore default alignment
			pWebGLRenderer.pixelStorei( 0x0D05 , 4);

//vertical flip
// {
// 	size_t rowSpan = dst.getWidth() * PixelUtil::getNumElemBytes(dst.format);
// 	size_t height = dst.getHeight();
// 	uchar *tmpData = new uchar[rowSpan * height];
// 	uchar *srcRow = (uchar *)dst.data, *tmpRow = tmpData + (height - 1) * rowSpan;

// 	while (tmpRow >= tmpData)
// 	{
// 		memcpy(tmpRow, srcRow, rowSpan);
// 		srcRow += rowSpan;
// 		tmpRow -= rowSpan;
// 	}
// 	memcpy(dst.data, tmpData, rowSpan * height);

// 	delete [] tmpData;
// }


			return ppDest;
		}


		private findViewportByPosition(x:  number , y:  number ): IViewport {
//propagation of click event to all viewports, that can be handle it
			var pViewport: IViewport = null;

//finding top viewport, taht contains (x, y) point.
			for (var z in this._pViewportList) {
				var pVp: IViewport = this._pViewportList[z];
				if (pVp.actualLeft <= x && pVp.actualTop <= y &&
					pVp.actualLeft + pVp.actualWidth > x && pVp.actualTop + pVp.actualHeight > y) {
					if (isNull(pViewport) || pVp.zIndex > pViewport.zIndex) {
						pViewport = pVp;
					}
				}
			}

			return pViewport;
		}

		private getViewportByMouseEvent(x:  number , y:  number ): IViewport {
			var pViewportCurr: IViewport = this.findViewportByPosition(x, y);
			var pViewportPrev: IViewport = this._p3DEventViewportLast;

			if (pViewportPrev !== pViewportCurr) {
				if (!isNull(pViewportPrev)) {
					pViewportPrev.mouseout(x - pViewportPrev.actualLeft, y - pViewportPrev.actualTop);
				}

				if (!isNull(pViewportCurr)) {
					pViewportCurr.mouseover(x - pViewportCurr.actualLeft, y - pViewportCurr.actualTop);
				}
			}

			this._p3DEventViewportLast = pViewportCurr;

			return pViewportCurr;
		}

		/**@inline*/  set onclick(fn: (pCanvas: ICanvas3d, x:  number , y:  number ) => void) {
        	this.bind( "click" , fn);
        }

        /**@inline*/  set onmousemove(fn: (pCanvas: ICanvas3d, x:  number , y:  number ) => void) {
        	this.bind( "mousemove" , fn);
        }

        /**@inline*/  set onmousedown(fn: (pCanvas: ICanvas3d, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "mousedown" , fn);
        }

        /**@inline*/  set onmouseup(fn: (pCanvas: ICanvas3d, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "mouseup" , fn);
        }

        /**@inline*/  set onmouseover(fn: (pCanvas: ICanvas3d, x:  number , y:  number ) => void) {
        	this.bind( "mouseover" , fn);
        }

        /**@inline*/  set onmouseout(fn: (pCanvas: ICanvas3d, x:  number , y:  number ) => void) {
        	this.bind( "mouseout" , fn);
        }

        /**@inline*/  set onmousewheel(fn: (pCanvas: ICanvas3d, x:  number , y:  number , fDelta:  number ) => void) {
        	this.bind( "mousewheel" , fn);
        }

        /**@inline*/  set ondragstart(fn: (pCanvas: ICanvas3d, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "dragstart" , fn);
        }

        /**@inline*/  set ondragstop(fn: (pCanvas: ICanvas3d, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "dragstop" , fn);
        }

        /**@inline*/  set ondragging(fn: (pCanvas: ICanvas3d, eBtn: EMouseButton, x:  number , y:  number ) => void) {
        	this.bind( "dragging" , fn);
        }


		 click(x:  number , y:  number ): void {
			if (this._b3DEventSkipNextClick) {
				this._b3DEventSkipNextClick = false;
				return;
			}

			var pViewport: IViewport = this.getViewportByMouseEvent(x, y);

			if (!isNull(pViewport)) {
				pViewport.click(x - pViewport.actualLeft, y - pViewport.actualTop);
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).click; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;
		}

		 mousemove(x:  number , y:  number ): void {
			var pViewport: IViewport = this.getViewportByMouseEvent(x, y);

			if (!isNull(pViewport)) {
				pViewport.mousemove(x - pViewport.actualLeft, y - pViewport.actualTop);
			}

			if (this.is3DEventSupported(E3DEventTypes.DRAGSTART | E3DEventTypes.DRAGSTOP)) {
//dragging enabled
				if (!isNull(this._p3DEventDragTarget)) {
//drag start event not emitted
					if (!this._b3DEventDragging &&
//mouse shift from mousedown point greather than drag dead zone constant
						Vec2.stackCeil.set(x - this._p3DEventMouseDownPos.x, y - this._p3DEventMouseDownPos.y) .length() > this._i3DEventDragDeadZone) {
						this.dragstart(this._e3DEventDragBtn, x, y);
					}
					else if (this._b3DEventDragging) {
						this.dragging(this._e3DEventDragBtn, x, y);
					}
				}
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousemove; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;
		}

		 mousedown(eBtn: EMouseButton, x:  number , y:  number ): void {
			var pViewport: IViewport = this.getViewportByMouseEvent(x, y);

			this._p3DEventMouseDownPos.x = x;
			this._p3DEventMouseDownPos.y = y;

			if (!isNull(pViewport)) {
				pViewport.mousedown(eBtn, x - pViewport.actualLeft, y - pViewport.actualTop);
			}
			if (this.is3DEventSupported(E3DEventTypes.DRAGSTART)
				&& this._e3DEventDragBtn === EMouseButton.UNKNOWN) {
				this._p3DEventDragTarget = pViewport;
				this._e3DEventDragBtn = eBtn;

				if (this._i3DEventDragDeadZone === 0) {
					this.dragstart(eBtn, x, y);
				}
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousedown; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, eBtn, x, y) : _broadcast[i].listener (_recivier, eBtn, x, y) ; } } ;
		}

		 mouseup(eBtn: EMouseButton, x:  number , y:  number ): void {
			var pViewport: IViewport = this.getViewportByMouseEvent(x, y);

			if (!isNull(pViewport)) {
				pViewport.mouseup(eBtn, x - pViewport.actualLeft, y - pViewport.actualTop);
			}

			if (this.is3DEventSupported(E3DEventTypes.DRAGSTOP) &&
					this._e3DEventDragBtn === eBtn) {

				if (this._b3DEventDragging) {
					this.dragstop(eBtn, x, y);
				}

				this._p3DEventDragTarget = null;
				this._e3DEventDragBtn = EMouseButton.UNKNOWN;
			}



			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseup; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, eBtn, x, y) : _broadcast[i].listener (_recivier, eBtn, x, y) ; } } ;
		}

		 mouseover(x:  number , y:  number ): void {
			var pViewport: IViewport = this.getViewportByMouseEvent(x, y);

			if (!isNull(pViewport)) {
				pViewport.mouseover(x - pViewport.actualLeft, y - pViewport.actualTop);
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseover; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;
		}

		 mouseout(x:  number , y:  number ): void {
			var pViewport: IViewport = this.getViewportByMouseEvent(x, y);

			if (!isNull(pViewport)) {
				pViewport.mouseout(x - pViewport.actualLeft, y - pViewport.actualTop);
			}

//stop dragging if mouse goes out of target
			if (this.is3DEventSupported(E3DEventTypes.DRAGSTOP)) {
				this.dragstop(this._e3DEventDragBtn, x, y);

				this._p3DEventDragTarget = null;
				this._e3DEventDragBtn = EMouseButton.UNKNOWN;
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mouseout; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y) : _broadcast[i].listener (_recivier, x, y) ; } } ;
		}

		 mousewheel(x:  number , y:  number , fDelta:  number ): void {
			var pViewport: IViewport = this.getViewportByMouseEvent(x, y);

			if (!isNull(pViewport)) {
				pViewport.mousewheel(x - pViewport.actualLeft, y - pViewport.actualTop, fDelta);
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).mousewheel; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, x, y, fDelta) : _broadcast[i].listener (_recivier, x, y, fDelta) ; } } ;
		}

		 dragstart(eBtn: EMouseButton, x:  number , y:  number ): void {
			this._b3DEventDragging = true;

			if (!isNull(this._p3DEventDragTarget)) {
				this._p3DEventDragTarget.dragstart(
					eBtn,
					x - this._p3DEventDragTarget.actualLeft,
					y - this._p3DEventDragTarget.actualTop);
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragstart; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, eBtn, x, y) : _broadcast[i].listener (_recivier, eBtn, x, y) ; } } ;
		}

		 dragstop(eBtn: EMouseButton, x:  number , y:  number ): void {
			this._b3DEventSkipNextClick = true;
			this._b3DEventDragging = false;

			if (!isNull(this._p3DEventDragTarget)) {
				this._p3DEventDragTarget.dragstop(
					eBtn,
					x - this._p3DEventDragTarget.actualLeft,
					y - this._p3DEventDragTarget.actualTop);
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragstop; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, eBtn, x, y) : _broadcast[i].listener (_recivier, eBtn, x, y) ; } } ;
		}

		 dragging(eBtn: EMouseButton, x:  number , y:  number ): void {
			if (!isNull(this._p3DEventDragTarget)) {
				this._p3DEventDragTarget.dragging(
					eBtn,
					x - this._p3DEventDragTarget.actualLeft,
					y - this._p3DEventDragTarget.actualTop);
			}

			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).dragging; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, eBtn, x, y) : _broadcast[i].listener (_recivier, eBtn, x, y) ; } } ;
		}

		static fullscreenLock: bool = false;
	}
}





















module akra.webgl {

    export interface WebGLUniformLocationMap {
        [index: string]: WebGLUniformLocation;
    }

	export class WebGLShaderProgram extends core.pool.ResourcePoolItem implements IShaderProgram {
        protected _pWebGLRenderer: WebGLRenderer;
        protected _pWebGLContext: WebGLRenderingContext;
		protected _pWebGLProgram: WebGLProgram;
		protected _pWebGLUniformLocations: WebGLUniformLocationMap;
		protected _pWebGLAttributeLocations: IntMap;

		protected _pWebGLAttributesInfo: WebGLActiveInfo[];

        protected _iTotalAttributes:  number  = 0;

		create(csVertex?: string, csPixel?: string): bool {
			if (arguments.length > 0) {
				return this.compile(csVertex ||  "void main(void){gl_Position = vec4(0., 0., 0., 1.);}" , csPixel ||  "void main(void){}" );
			}

            return false;
		}

        destroy(): void {
            this._pWebGLRenderer.deleteWebGLProgram(this._pWebGLProgram);

            this._pWebGLUniformLocations = null;
            this._pWebGLAttributeLocations = null;
            this._pWebGLAttributesInfo = null;

            this.notifyDestroyed();
            this.notifyDisabled();
        }

    	compile(csVertex: string =  "void main(void){gl_Position = vec4(0., 0., 0., 1.);}" , csPixel: string =  "void main(void){}" ): bool {
    		var pWebGLRenderer: WebGLRenderer = this._pWebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = this._pWebGLContext =pWebGLRenderer.getWebGLContext();
			var pWebGLProgram: WebGLProgram = this._pWebGLProgram = pWebGLRenderer.createWebGLProgram();

			var pWebGLVs: WebGLShader = this.createWebGLShader( 0x8B31 , csVertex);
			var pWebGLFs: WebGLShader = this.createWebGLShader( 0x8B30 , csPixel);

// (<any>this)._debuginfo = {vs: csVertex, ps: csPixel};

/** because, if not all units correctly activated, can obtained wronf link status */

			pWebGLRenderer._disableAllTextureUnits();

			pWebGLContext.attachShader(pWebGLProgram, pWebGLVs);
			pWebGLContext.attachShader(pWebGLProgram, pWebGLFs);

			pWebGLContext.linkProgram(pWebGLProgram);

// LOG("================================", this.findResourceName());
// LOG(pWebGLContext.getShaderSource(pWebGLVs));
// LOG(pWebGLContext.getShaderSource(pWebGLFs));
// console.log(csPixel);
			if (!this.isLinked()) {
				{ logger.setSourceLocation( "WebGLShaderProgram.ts" , 71 ); logger.error("cannot link GLSL program(guid: %d)", this.getGuid()); } ;


                var sInfo: string = pWebGLContext.getProgramInfoLog(pWebGLProgram);

                { logger.setSourceLocation( "WebGLShaderProgram.ts" , 76 ); logger.log("shader program errors: \n" + sInfo); } ;
//+ "\n\nvertex code:\n"  + csVertex + "\n\n pixel code: " + csPixel);

				if (loadExtension(pWebGLContext,  "WEBGL_debug_shaders" )) {
					{ logger.setSourceLocation( "WebGLShaderProgram.ts" , 83 ); logger.log("translated(from GLSL) VS shader: \n" + pWebGLContext.getExtension( "WEBGL_debug_shaders" ).getTranslatedShaderSource(pWebGLVs) + "\ntranslated(from GLSL) PS shader: \n" + pWebGLContext.getExtension( "WEBGL_debug_shaders" ).getTranslatedShaderSource(pWebGLFs)); }
                                                                                          ;
				}


				return false;
			}

			pWebGLContext.validateProgram(pWebGLProgram);

			if (!this.isValid()) {
				{ logger.setSourceLocation( "WebGLShaderProgram.ts" , 93 ); logger.warning("GLSL program not valid(guid: %d)", this.getGuid()); } ;

				{ logger.setSourceLocation( "WebGLShaderProgram.ts" , 95 ); logger.log(pWebGLContext.getProgramInfoLog(pWebGLProgram)); } ;
			}

			this.obtainWebGLUniforms();
			this.obtainWebGLAttributes();

            this.notifyCreated();
            this.notifyRestored();

			return true;
    	}

        /**@inline*/  get totalAttributes():  number  {
            return this._iTotalAttributes;
        }

        /**@inline*/  _getActiveUniformNames(): string[] {
            return Object.keys(this._pWebGLUniformLocations);
        }

        /**@inline*/  _getActiveAttributeNames(): string[] {
            return Object.keys(this._pWebGLAttributeLocations);
        }

        /**@inline*/  _getActiveAttribLocations(): IntMap {
            return this._pWebGLAttributeLocations;
        }

    	isLinked(): bool {
    		return isDefAndNotNull(this._pWebGLProgram) &&
    			<bool>this._pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B82 );
    	}

    	isValid(): bool {
    		return isDefAndNotNull(this._pWebGLProgram) &&
    			<bool>this._pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B83 );
    	}

    	isActive(): bool {
    		return (isDefAndNotNull(this._pWebGLProgram) &&
    			<WebGLProgram>this._pWebGLContext.getParameter( 0x8B8D ) === this._pWebGLProgram);
    	}

    	/**@inline*/  setFloat(sName: string, fValue:  number ): void {
    		this._pWebGLContext.uniform1f(this._pWebGLUniformLocations[sName], fValue);
    	}

    	/**@inline*/  setInt(sName: string, iValue:  number ): void {
    		this._pWebGLContext.uniform1i(this._pWebGLUniformLocations[sName], iValue);
    	}

// inline setBool(sName: string, bValue: bool): void {
//     this.setInt(sName, bValue )
// }

        setVec2(sName: string, v2fValue: IVec2): void {
            this._pWebGLContext.uniform2f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y);
        }


        setVec2i(sName: string, v2iValue: IVec2): void {
            this._pWebGLContext.uniform2i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y);
        }

        setVec3(sName: string, v3fValue: IVec3): void {
            this._pWebGLContext.uniform3f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z);
        }

        setVec3i(sName: string, v3iValue: IVec3): void {
            this._pWebGLContext.uniform3i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z);
        }

        setVec4(sName: string, v4fValue: IVec4): void {
            this._pWebGLContext.uniform4f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
        }

        setVec4i(sName: string, v4iValue: IVec4): void {
            this._pWebGLContext.uniform4i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
        }


// setVec2(sName: string, v2fValue: IVec2): void;
// setVec2(sName: string, x: float, y: float): void;
// inline setVec2(sName: string, x?, y?): void {
// 	(arguments.length == 2)?
// 	  this._pWebGLContext.uniform2f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y):
// 	  this._pWebGLContext.uniform2f(this._pWebGLUniformLocations[sName], arguments[1], arguments[2]);
// }


// setVec2i(sName: string, v2iValue: IVec2): void;
// setVec2i(sName: string, x: int, y: int): void;
// inline setVec2i(sName: string, x?, y?): void {
// 	(arguments.length == 2)?
// 	  this._pWebGLContext.uniform2i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y):
// 	  this._pWebGLContext.uniform2i(this._pWebGLUniformLocations[sName], arguments[1], arguments[2]);
// }

// setVec3(sName: string, v3fValue: IVec3): void;
// setVec3(sName: string, x: float, y: float, z: float): void;
// inline setVec3(sName: string, x?, y?, z?): void {
// 	(arguments.length == 2)?
// 	  this._pWebGLContext.uniform3f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z):
// 	  this._pWebGLContext.uniform3f(this._pWebGLUniformLocations[sName], arguments[1], arguments[2], arguments[3]);
// }

// setVec3i(sName: string, v3iValue: IVec3): void;
// setVec3i(sName: string, x: int, y: int, z: int): void;
// inline setVec3i(sName: string, x?, y?, z?): void {
// 	(arguments.length == 2)?
// 		this._pWebGLContext.uniform3i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z):
// 		this._pWebGLContext.uniform3i(this._pWebGLUniformLocations[sName], arguments[1], arguments[2], arguments[3]);
// }

// setVec4(sName: string, v4fValue: IVec4): void;
// setVec4(sName: string, x: float, y: float, z: float, w: float): void;
// inline setVec4(sName: string, x?, y?, z?, w?): void {
// 	(arguments.length == 2) ?
// 	  this._pWebGLContext.uniform4f(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w):
// 	  this._pWebGLContext.uniform4f(this._pWebGLUniformLocations[sName], arguments[1], arguments[2], arguments[3], arguments[3]);
// }

// setVec4i(sName: string, v4iValue: IVec4): void;
// setVec4i(sName: string, x: int, y: int, z: int, w: int): void;
// inline setVec4i(sName: string, x?, y?, z?, w?): void {
// 	(arguments.length == 2)?
// 		this._pWebGLContext.uniform4i(this._pWebGLUniformLocations[sName], arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w):
// 		this._pWebGLContext.uniform4i(this._pWebGLUniformLocations[sName], arguments[1], arguments[2], arguments[3], arguments[3])
// }



    	/**@inline*/  setMat3(sName: string, m3fValue: IMat3): void {
    		this._pWebGLContext.uniformMatrix3fv(this._pWebGLUniformLocations[sName], false, m3fValue.data);
    	}

    	setMat4(sName: string, m4fValue: IMat4): void {
    		this._pWebGLContext.uniformMatrix4fv(this._pWebGLUniformLocations[sName], false, m4fValue.data);
    	}

    	/**@inline*/  setFloat32Array(sName: string, pValue: Float32Array): void {
    		this._pWebGLContext.uniform1fv(this._pWebGLUniformLocations[sName], pValue);
    	}

    	/**@inline*/  setInt32Array(sName: string, pValue: Int32Array): void {
    		this._pWebGLContext.uniform1iv(this._pWebGLUniformLocations[sName], pValue);
    	}

        static uniformBuffer: ArrayBuffer = new ArrayBuffer(4096 * 16);

    	/**@inline*/  setVec2Array(sName: string, pValue: IVec2[]): void {
    		var pBuffer: Float32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
            for (var i:  number  = 0, j:  number  = 0; j < pValue.length; i += 2, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
            }

            this._pWebGLContext.uniform2fv(this._pWebGLUniformLocations[sName], pBuffer);
    	}

    	/**@inline*/  setVec2iArray(sName: string, pValue: IVec2[]): void {
    		var pBuffer: Int32Array = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
            for (var i:  number  = 0, j:  number  = 0; j < pValue.length; i += 2, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
            }

            this._pWebGLContext.uniform2iv(this._pWebGLUniformLocations[sName], pBuffer);
    	}

    	/**@inline*/  setVec3Array(sName: string, pValue: IVec3[]): void {
    		var pBuffer: Float32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
            for (var i:  number  = 0, j:  number  = 0; j < pValue.length; i += 3, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
                pBuffer[i + 2] = pValue[j].z;
            }

            this._pWebGLContext.uniform3fv(this._pWebGLUniformLocations[sName], pBuffer);
    	}

    	/**@inline*/  setVec3iArray(sName: string, pValue: IVec3[]): void {
    		var pBuffer: Int32Array = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
            for (var i:  number  = 0, j:  number  = 0; j < pValue.length; i += 3, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
                pBuffer[i + 2] = pValue[j].z;
            }

            this._pWebGLContext.uniform3iv(this._pWebGLUniformLocations[sName], pBuffer);
    	}

    	/**@inline*/  setVec4Array(sName: string, pValue: IVec4[]): void {
    		var pBuffer: Float32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
            for (var i:  number  = 0, j:  number  = 0; j < pValue.length; i += 4, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
                pBuffer[i + 2] = pValue[j].z;
                pBuffer[i + 3] = pValue[j].w;
            }

            this._pWebGLContext.uniform4fv(this._pWebGLUniformLocations[sName], pBuffer);
    	}

    	/**@inline*/  setVec4iArray(sName: string, pValue: IVec4[]): void {
    		var pBuffer: Int32Array = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
            for (var i:  number  = 0, j:  number  = 0; j < pValue.length; i += 4, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
                pBuffer[i + 2] = pValue[j].z;
                pBuffer[i + 3] = pValue[j].w;
            }

            this._pWebGLContext.uniform4iv(this._pWebGLUniformLocations[sName], pBuffer);
    	}



    	/**@inline*/  setMat3Array(sName: string, pValue: IMat3[]): void {
            var pBuffer: Int32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 9);
            for (var i:  number  = 0; i < pValue.length; i ++) {
                pBuffer.set(pValue[i].data, 9*i);
            }
    		this._pWebGLContext.uniformMatrix3fv(this._pWebGLUniformLocations[sName], false, pBuffer);
    	}

    	/**@inline*/  setMat4Array(sName: string, pValue: IMat4[]): void {
    		var pBuffer: Int32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 16);
            for (var i:  number  = 0; i < pValue.length; i ++) {
                pBuffer.set(pValue[i].data, 16*i);
            }
            this._pWebGLContext.uniformMatrix4fv(this._pWebGLUniformLocations[sName], false, pBuffer);
    	}

    	/**@inline*/  setStruct(sName: string, pData: Object): void {

    	}

    	/**@inline*/  setSampler(sName: string, pSampler: IAFXSamplerState): void {
           var iSlot:  number  = this.applySamplerState(pSampler);
           this.setInt(sName, iSlot);
    	}

        /**@inline*/  setVertexBuffer(sName: string, pBuffer: IVertexBuffer): void {
// var iSlot: uint = this._pWebGLRenderer.getNextTextureSlot();
// this._pWebGLRenderer.activateWebGLTexture(iSlot + GL_TEXTURE0);
// WARNING(iSlot);
// var iSlot: uint = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(GL_TEXTURE_2D, null);
// this._pWebGLRenderer.bindWebGLTexture(GL_TEXTURE_2D, (<WebGLVertexTexture>pBuffer).getWebGLTexture());
            var iSlot:  number  = this._pWebGLRenderer.activateWebGLTextureInAutoSlot( 0x0DE1 , (<WebGLVertexTexture>pBuffer).getWebGLTexture());
            this.setInt(sName, iSlot);
        }

        /**@inline*/  setSamplerArray(sName: string, pList: IAFXSamplerState[]): void {
            var pBuffer: Int32Array = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pList.length);

            for (var i:  number  = 0; i < pList.length; ++ i) {
                pBuffer[i] = this.applySamplerState(pList[i]);
            }

            this.setInt32Array(sName, pBuffer);
        }


    	/**@inline*/  setTexture(sName: string, pData: ITexture): void {

    	}

        private applySamplerState(pSampler: IAFXSamplerState):  number  {
            var pTexture: WebGLInternalTexture = <WebGLInternalTexture>pSampler.texture;

            if(isNull(pTexture)){
                return  ;
            }

            var pTextureStateManager: WebGLInternalTextureStateManager = this._pWebGLRenderer._getTextureStateManager();
            var pStates: IntMap = pTextureStateManager.add(pTexture);
            var iSlot:  number  = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(pTexture._getWebGLTextureTarget(), pTexture.getWebGLTexture());

            if(pSampler.min_filter){
                pTexture.setFilter(ETextureParameters.MIN_FILTER, pSampler.min_filter);
            }
            else {
                pTexture.setFilter(ETextureParameters.MIN_FILTER, pStates[ETextureParameters.MIN_FILTER]);
            }

            if(pSampler.mag_filter){
                pTexture.setFilter(ETextureParameters.MAG_FILTER, pSampler.mag_filter);
            }
            else {
                pTexture.setFilter(ETextureParameters.MAG_FILTER, pStates[ETextureParameters.MAG_FILTER]);
            }

            if(pSampler.wrap_s){
                pTexture.setWrapMode(ETextureParameters.WRAP_S, pSampler.wrap_s);
            }
            else {
                pTexture.setWrapMode(ETextureParameters.WRAP_S, pStates[ETextureParameters.WRAP_S]);
            }

            if(pSampler.wrap_t){
                pTexture.setWrapMode(ETextureParameters.WRAP_T, pSampler.wrap_t);
            }
            else {
                pTexture.setWrapMode(ETextureParameters.WRAP_T, pStates[ETextureParameters.WRAP_T]);
            }
// LOG("sampler states: ",
// (<any>pSampler.min_filter).toString(16),
// (<any>pSampler.mag_filter).toString(16),
// (<any>pSampler.wrap_s).toString(16),
// (<any>pSampler.wrap_t).toString(16)
// );

// LOG("texture states: ",
// (<any>pTexture.getFilter(ETextureParameters.MIN_FILTER)).toString(16),
// (<any>pTexture.getFilter(ETextureParameters.MAG_FILTER)).toString(16),
// (<any>pTexture.getWrapMode(ETextureParameters.WRAP_S)).toString(16),
// (<any>pTexture.getWrapMode(ETextureParameters.WRAP_T)).toString(16)
// );
// pTexture._setFilterInternalTexture(ETextureParameters.MIN_FILTER, pSampler.min_filter || pTexture.getFilter(ETextureParameters.MIN_FILTER));
// pTexture._setFilterInternalTexture(ETextureParameters.MAG_FILTER, pSampler.mag_filter || pTexture.getFilter(ETextureParameters.MAG_FILTER));
// pTexture._setWrapModeInternalTexture(ETextureParameters.WRAP_S, pSampler.wrap_s || pTexture.getWrapMode(ETextureParameters.WRAP_S));
// pTexture._setWrapModeInternalTexture(ETextureParameters.WRAP_T, pSampler.wrap_t || pTexture.getWrapMode(ETextureParameters.WRAP_T));

// if(pSampler.min_filter){
//     pTexture._setFilterInternalTexture(ETextureParameters.MIN_FILTER, pSampler.min_filter);
// }

// if(pSampler.mag_filter){
//     pTexture._setFilterInternalTexture(ETextureParameters.MAG_FILTER, pSampler.mag_filter);
// }

// if(pSampler.wrap_s) {
//     pTexture._setWrapModeInternalTexture(ETextureParameters.WRAP_S, pSampler.wrap_s);
// }
// if(pSampler.wrap_t) {
//     pTexture._setWrapModeInternalTexture(ETextureParameters.WRAP_T, pSampler.wrap_t);
// }

            return iSlot;
        }

//applyVertexBuffer(sName: string, pBuffer: IVertexBuffer);
    	applyVertexData(sName: string, pData: IVertexData): bool {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var pVertexBuffer: IVertexBuffer = <IVertexBuffer>pData.buffer;
    		var iStride:  number  = pData.stride;

    		if (pVertexBuffer.type !== EVertexBufferTypes.VBO) {
    			return false
    		}

    		var pVertexDecl: IVertexDeclaration = pData.getVertexDeclaration();
    		var pVertexElement: IVertexElement;
    		var iLoc:  number ;

    		for (var i:  number  = 0; i < pVertexDecl.length; ++ i) {
    			pVertexElement = pVertexDecl[i];
    			iLoc = this.getWebGLAttributeLocation(pVertexElement.usage);

    			if (iLoc < 0) {
    				{ logger.setSourceLocation( "WebGLShaderProgram.ts" , 467 ); logger.warning("founded invalid GLSL attribute location(guid: %s): %s", this.getGuid(), pVertexElement.usage); }
                              ;
    				continue;
    			}

    			pWebGLRenderer.bindWebGLBuffer( 0x8892 , (<WebGLVertexBuffer>pVertexBuffer).getWebGLBuffer());
    			pWebGLContext.vertexAttribPointer(iLoc,
    											  pVertexElement.count,
    											  pVertexElement.type,
    											  false,
    											  iStride,
    											  pVertexElement.offset);
    		}

    		return true;
    	}


        /**@inline*/  _setFloat(pWebGLUniformLocation: WebGLUniformLocation, fValue:  number ): void {
            this._pWebGLContext.uniform1f(pWebGLUniformLocation, fValue);
        }

        /**@inline*/  _setInt(pWebGLUniformLocation: WebGLUniformLocation, iValue:  number ): void {
            this._pWebGLContext.uniform1i(pWebGLUniformLocation, iValue);
        }

        _setVec2(pWebGLUniformLocation: WebGLUniformLocation, v2fValue: IVec2): void {
            this._pWebGLContext.uniform2f(pWebGLUniformLocation, v2fValue.x, v2fValue.y);
        }


        _setVec2i(pWebGLUniformLocation: WebGLUniformLocation, v2iValue: IVec2): void {
            this._pWebGLContext.uniform2i(pWebGLUniformLocation, v2iValue.x, v2iValue.y);
        }

        _setVec3(pWebGLUniformLocation: WebGLUniformLocation, v3fValue: IVec3): void {
            this._pWebGLContext.uniform3f(pWebGLUniformLocation, v3fValue.x, v3fValue.y, v3fValue.z);
        }

        _setVec3i(pWebGLUniformLocation: WebGLUniformLocation, v3iValue: IVec3): void {
            this._pWebGLContext.uniform3i(pWebGLUniformLocation, v3iValue.x, v3iValue.y, v3iValue.z);
        }

        _setVec4(pWebGLUniformLocation: WebGLUniformLocation, v4fValue: IVec4): void {
            this._pWebGLContext.uniform4f(pWebGLUniformLocation, v4fValue.x, v4fValue.y, v4fValue.z, v4fValue.w);
        }

        _setVec4i(pWebGLUniformLocation: WebGLUniformLocation, v4iValue: IVec4): void {
            this._pWebGLContext.uniform4i(pWebGLUniformLocation, v4iValue.x, v4iValue.y, v4iValue.z, v4iValue.w);
        }



        /**@inline*/  _setMat3(pWebGLUniformLocation: WebGLUniformLocation, m3fValue: IMat3): void {
            this._pWebGLContext.uniformMatrix3fv(pWebGLUniformLocation, false, m3fValue.data);
        }

        _setMat4(pWebGLUniformLocation: WebGLUniformLocation, m4fValue: IMat4): void {
            this._pWebGLContext.uniformMatrix4fv(pWebGLUniformLocation, false, m4fValue.data);
        }

        /**@inline*/  _setFloat32Array(pWebGLUniformLocation: WebGLUniformLocation, pValue: Float32Array): void {
            this._pWebGLContext.uniform1fv(pWebGLUniformLocation, pValue);
        }

        /**@inline*/  _setInt32Array(pWebGLUniformLocation: WebGLUniformLocation, pValue: Int32Array): void {
            !isNull(pValue) && this._pWebGLContext.uniform1iv(pWebGLUniformLocation, pValue);
        }

        /**@inline*/  _setVec2Array(pWebGLUniformLocation: WebGLUniformLocation, pValue: IVec2[]): void {
            if (isNull(pValue)) {
                return;
            }

            var pBuffer: Float32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);

            for (var i:  number  = 0, j:  number  = 0; j < pValue.length; i += 2, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
            }

            this._pWebGLContext.uniform2fv(pWebGLUniformLocation, pBuffer);
        }

        /**@inline*/  _setVec2iArray(pWebGLUniformLocation: WebGLUniformLocation, pValue: IVec2[]): void {
            var pBuffer: Int32Array = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 2);
            for (var i:  number  = 0, j:  number  = 0; j < pValue.length; i += 2, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
            }

            this._pWebGLContext.uniform2iv(pWebGLUniformLocation, pBuffer);
        }

        /**@inline*/  _setVec3Array(pWebGLUniformLocation: WebGLUniformLocation, pValue: IVec3[]): void {
            var pBuffer: Float32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
            for (var i:  number  = 0, j:  number  = 0; i < pValue.length; i += 3, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
                pBuffer[i + 2] = pValue[j].z;
            }

            this._pWebGLContext.uniform3fv(pWebGLUniformLocation, pBuffer);
        }

        /**@inline*/  _setVec3iArray(pWebGLUniformLocation: WebGLUniformLocation, pValue: IVec3[]): void {
            var pBuffer: Int32Array = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 3);
            for (var i:  number  = 0, j:  number  = 0; i < pValue.length; i += 3, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
                pBuffer[i + 2] = pValue[j].z;
            }

            this._pWebGLContext.uniform3iv(pWebGLUniformLocation, pBuffer);
        }

        /**@inline*/  _setVec4Array(pWebGLUniformLocation: WebGLUniformLocation, pValue: IVec4[]): void {
            var pBuffer: Float32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
            for (var i:  number  = 0, j:  number  = 0; i < pValue.length; i += 4, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
                pBuffer[i + 2] = pValue[j].z;
                pBuffer[i + 3] = pValue[j].w;
            }

            this._pWebGLContext.uniform4fv(pWebGLUniformLocation, pBuffer);
        }

        /**@inline*/  _setVec4iArray(pWebGLUniformLocation: WebGLUniformLocation, pValue: IVec4[]): void {
            var pBuffer: Int32Array = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 4);
            for (var i:  number  = 0, j:  number  = 0; i < pValue.length; i += 4, ++ j) {
                pBuffer[i    ] = pValue[j].x;
                pBuffer[i + 1] = pValue[j].y;
                pBuffer[i + 2] = pValue[j].z;
                pBuffer[i + 3] = pValue[j].w;
            }

            this._pWebGLContext.uniform4iv(pWebGLUniformLocation, pBuffer);
        }



        /**@inline*/  _setMat3Array(pWebGLUniformLocation: WebGLUniformLocation, pValue: IMat3[]): void {
            var pBuffer: Int32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 9);
            for (var i:  number  = 0; i < pValue.length; i ++) {
                pBuffer.set(pValue[i].data, 9*i);
            }
            this._pWebGLContext.uniformMatrix3fv(pWebGLUniformLocation, false, pBuffer);
        }

        /**@inline*/  _setMat4Array(pWebGLUniformLocation: WebGLUniformLocation, pValue: IMat4[]): void {
            var pBuffer: Int32Array = new Float32Array(WebGLShaderProgram.uniformBuffer, 0, pValue.length * 16);
            for (var i:  number  = 0; i < pValue.length; i ++) {
                pBuffer.set(pValue[i].data, 16*i);
            }
            this._pWebGLContext.uniformMatrix4fv(pWebGLUniformLocation, false, pBuffer);
        }

        /**@inline*/  _setSampler(pWebGLUniformLocation: WebGLUniformLocation, pSampler: IAFXSamplerState): void {
// for(var i in this._pWebGLUniformLocations){
//     if(this._pWebGLUniformLocations[i] === pWebGLUniformLocation){
//         LOG(i);
//         break;
//     }
// }
            var iSlot:  number  = this.applySamplerState(pSampler);
            this._setInt(pWebGLUniformLocation, iSlot);
        }

        /**@inline*/  _setVertexBuffer(pWebGLUniformLocation: WebGLUniformLocation, pBuffer: IVertexBuffer): void {
// var iSlot: uint = this._pWebGLRenderer.getNextTextureSlot();
// this._pWebGLRenderer.activateWebGLTexture(iSlot + GL_TEXTURE0);
// WARNING(iSlot);
// var iSlot: uint = this._pWebGLRenderer.activateWebGLTextureInAutoSlot(GL_TEXTURE_2D, null);
// this._pWebGLRenderer.bindWebGLTexture(GL_TEXTURE_2D, (<WebGLVertexTexture>pBuffer).getWebGLTexture());
            var iSlot:  number  = this._pWebGLRenderer.activateWebGLTextureInAutoSlot( 0x0DE1 , (<WebGLVertexTexture>pBuffer).getWebGLTexture());
            this._setInt(pWebGLUniformLocation, iSlot);
        }

        /**@inline*/  _setSamplerArray(pWebGLUniformLocation: WebGLUniformLocation, pList: IAFXSamplerState[]): void {
            var pBuffer: Int32Array = new Int32Array(WebGLShaderProgram.uniformBuffer, 0, pList.length);

            for (var i:  number  = 0; i < pList.length; ++ i) {
                pBuffer[i] = this.applySamplerState(pList[i]);
            }

            this._setInt32Array(pWebGLUniformLocation, pBuffer);
        }


        /**@inline*/  applyBufferMap(pMap: IBufferMap): void {
            { logger.setSourceLocation( "WebGLShaderProgram.ts" , 665 ); logger.criticalError("WebGLShaderProgram::applyBufferMap() is uncompleted method!"); } ;
        }


    	/**@inline*/  getWebGLAttributeLocation(sName: string):  number  {
    		return isDef(this._pWebGLAttributeLocations[sName]) ? this._pWebGLAttributeLocations[sName] : -1;
    	}

        /**@inline*/  getWebGLUniformLocations(): WebGLUniformLocationMap {
            return this._pWebGLUniformLocations;
        }

    	/**@inline*/  getWebGLUniformLocation(sName: string): WebGLUniformLocation {

			var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName];

			if (!isDef(iLoc)) {
				{ logger.setSourceLocation( "WebGLShaderProgram.ts" , 682 ); logger.warning("could not find location for GLSL attribute(guid: %s): %s", this.getGuid(), sName); } ;
			}

			return iLoc;

    	}

    	/**@inline*/  getWebGLProgram(): WebGLProgram {
    		return this._pWebGLProgram;
    	}


        getTranslatedShaderCode(eWebGLType:  number ): string {
            var sReturn: string = "";
            var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

            if(!loadExtension(pWebGLContext,  "WEBGL_debug_shaders" )) {
                return null;
            }

            var pWebGLShaderList: WebGLShader[] = pWebGLContext.getAttachedShaders(this._pWebGLProgram);

            for(var i:  number  = 0; i < pWebGLShaderList.length; i++){
                var eShaderType:  number  = < number >pWebGLContext.getShaderParameter(pWebGLShaderList[i],  0x8B4F );

                if(eShaderType === eWebGLType) {
                    sReturn = pWebGLContext.getExtension( "WEBGL_debug_shaders" ).getTranslatedShaderSource(pWebGLShaderList[i]);
                    break;
                }
            }

            return sReturn;
        }

        printTranslatedShaderCode(eWebGLType?:  number  = -1): void {
            if(eWebGLType === -1){
                { logger.setSourceLocation( "WebGLShaderProgram.ts" , 721 ); logger.log("translated(from GLSL) VS shader: \n" + this.getTranslatedShaderCode( 0x8B31 )); } ;
                { logger.setSourceLocation( "WebGLShaderProgram.ts" , 722 ); logger.log("translated(from GLSL) PS shader: \n" + this.getTranslatedShaderCode( 0x8B30 )); } ;
            }
            else {
                { logger.setSourceLocation( "WebGLShaderProgram.ts" , 726 ); logger.log("translated(from GLSL) " + (eWebGLType === 0x8B31 ? "VS": "PS") + " shader: \n" + this.getTranslatedShaderCode(eWebGLType)); }
                                                             ;
            }
        }


    	protected createWebGLShader(eType:  number , csCode: string): WebGLShader {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
			var pWebGLShader: WebGLShader = pWebGLContext.createShader(eType);

			pWebGLContext.shaderSource(pWebGLShader, csCode);
			pWebGLContext.compileShader(pWebGLShader);

			if (!pWebGLContext.getShaderParameter(pWebGLShader,  0x8B81 )) {
				{ logger.setSourceLocation( "WebGLShaderProgram.ts" , 740 ); logger.error("cannot compile GLSL shader(guid: %d)", this.getGuid()); } ;

				var sInfo: string = pWebGLContext.getShaderInfoLog(pWebGLShader);
				var sCode: string = pWebGLContext.getShaderSource(pWebGLShader) || csCode;

                { logger.setSourceLocation( "WebGLShaderProgram.ts" , 745 ); logger.log("shader errors: \n %s \n----------\n %s", sInfo, sCode); } ;

                if (loadExtension(pWebGLContext,  "WEBGL_debug_shaders" )) {
                    { logger.setSourceLocation( "WebGLShaderProgram.ts" , 749 ); logger.log("translated(from GLSL) " + (eType == 0x8B31 ? "VS": "PS") + " shader: \n" + pWebGLContext.getExtension( "WEBGL_debug_shaders" ).getTranslatedShaderSource(pWebGLShader)); }
                                                                                                                ;
                }

				return null;
			}

			return pWebGLShader;
    	}

    	protected obtainWebGLUniforms(): void {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var nUniforms:  number  = pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B86 );
    		var pUniformLocations: WebGLUniformLocationMap = {};
    		var iLoc: WebGLUniformLocation;
    		var pUniformInfo: WebGLActiveInfo;

    		for (var i:  number  = 0; i < nUniforms; ++ i) {
    			pUniformInfo = pWebGLContext.getActiveUniform(this._pWebGLProgram, i);
				iLoc = pWebGLContext.getUniformLocation(this._pWebGLProgram, pUniformInfo.name);
				pUniformLocations[pUniformInfo.name] = iLoc;
    		}

    		this._pWebGLUniformLocations = pUniformLocations;
    	}

    	protected obtainWebGLAttributes(): void {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var nAttributes:  number  = pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B89 );
    		var pAttributeLocations: IntMap = <IntMap>{};
    		var pAttributesInfo: WebGLActiveInfo[] = [];
    		var iLoc:  number ;
    		var pAttributeInfo: WebGLActiveInfo;

    		for (var i:  number  = 0; i < nAttributes; ++ i) {
    			pAttributeInfo = pWebGLContext.getActiveAttrib(this._pWebGLProgram, i);
				iLoc = pWebGLContext.getAttribLocation(this._pWebGLProgram, pAttributeInfo.name);

				if (iLoc < 0 || !isDef(iLoc)) {
					{ logger.setSourceLocation( "WebGLShaderProgram.ts" , 789 ); logger.warning("could not get GLSL attribute location(guid: %s): %s", this.getGuid(), pAttributeInfo.name); } ;
				}


				pAttributeLocations[pAttributeInfo.name] = iLoc;
				pAttributesInfo[iLoc] = pAttributeInfo;
    		}

    		this._pWebGLAttributeLocations = pAttributeLocations;
    		this._pWebGLAttributesInfo = pAttributesInfo;
            this._iTotalAttributes = nAttributes;
    	}
	}
}















module akra.webgl {
	export interface WebGLInternalTextureState {
		isUsed: bool;
		texture: WebGLInternalTexture;
		states: IntMap;
	}

	export interface WebGLInternalTextureStateMap {
		[guid:  number ]: WebGLInternalTextureState;
	}

	export class WebGLInternalTextureStateManager {
		private _pActiveTextureStateMap: WebGLInternalTextureStateMap = null;
		private _pActiveTextureList: util.ObjectArray = null;

		private _pWebGLRenderer: WebGLRenderer = null;

		constructor(pRenderer: WebGLRenderer){
			this._pWebGLRenderer = pRenderer;

			this._pActiveTextureStateMap = <WebGLInternalTextureStateMap>{};
			this._pActiveTextureList = new util.ObjectArray;
		}

		add(pTexture: WebGLInternalTexture): IntMap {
			var iGuid:  number  = pTexture.getGuid();
			var pTextureState: WebGLInternalTextureState = this._pActiveTextureStateMap[iGuid];

			if(!isDef(pTextureState)){
				pTextureState = {
					isUsed: true,
					texture: pTexture,
					states: <IntMap>{}
				};

				pTextureState.states[ETextureParameters.MIN_FILTER] = pTexture.getFilter(ETextureParameters.MIN_FILTER);
				pTextureState.states[ETextureParameters.MAG_FILTER] = pTexture.getFilter(ETextureParameters.MAG_FILTER);
				pTextureState.states[ETextureParameters.WRAP_S] = pTexture.getWrapMode(ETextureParameters.WRAP_S);
				pTextureState.states[ETextureParameters.WRAP_T] = pTexture.getWrapMode(ETextureParameters.WRAP_T);

				this._pActiveTextureStateMap[iGuid] = pTextureState;
				this._pActiveTextureList.push(iGuid);

				return pTextureState.states;
			}

			if(!pTextureState.isUsed){
				pTextureState.states[ETextureParameters.MIN_FILTER] = pTexture.getFilter(ETextureParameters.MIN_FILTER);
				pTextureState.states[ETextureParameters.MAG_FILTER] = pTexture.getFilter(ETextureParameters.MAG_FILTER);
				pTextureState.states[ETextureParameters.WRAP_S] = pTexture.getWrapMode(ETextureParameters.WRAP_S);
				pTextureState.states[ETextureParameters.WRAP_T] = pTexture.getWrapMode(ETextureParameters.WRAP_T);

				this._pActiveTextureList.push(iGuid);
			}

			return pTextureState.states;
		}

		reset(): void {
			var iLength:  number  = this._pActiveTextureList.length;

			for(var i:  number  = 0; i < iLength; i++){
				var pTextureState: WebGLInternalTextureState = this._pActiveTextureStateMap[this._pActiveTextureList.value(i)];

				pTextureState.texture.setFilter(ETextureParameters.MIN_FILTER, pTextureState.states[ETextureParameters.MIN_FILTER]);
				pTextureState.texture.setFilter(ETextureParameters.MAG_FILTER, pTextureState.states[ETextureParameters.MAG_FILTER]);
				pTextureState.texture.setWrapMode(ETextureParameters.WRAP_S, pTextureState.states[ETextureParameters.WRAP_S]);
				pTextureState.texture.setWrapMode(ETextureParameters.WRAP_T, pTextureState.states[ETextureParameters.WRAP_T]);

				pTextureState.isUsed = false;
			}

			this._pActiveTextureList.clear();
			this._pWebGLRenderer.bindWebGLTexture( 0x0DE1 , null);
		}

		getTextureState(iGuid:  number ): IntMap {
			return this._pActiveTextureStateMap[iGuid].states;
		}

	}
}





module akra.webgl {
	export interface IWebGLContextStates {
		BLEND: bool;
		BLEND_COLOR: Float32Array;
		BLEND_DST_ALPHA:  number ;
		BLEND_DST_RGB:  number ;
		BLEND_EQUATION_ALPHA:  number ;
		BLEND_EQUATION_RGB:  number ;
		BLEND_SRC_ALPHA:  number ;
		BLEND_SRC_RGB:  number ;

		COLOR_CLEAR_VALUE: Float32Array;
		COLOR_WRITEMASK: bool[];

		CULL_FACE: bool;
		CULL_FACE_MODE:  number ;

		DEPTH_CLEAR_VALUE:  number ;
		DEPTH_FUNC:  number ;
		DEPTH_RANGE: Float32Array;
		DEPTH_TEST: bool;
		DEPTH_WRITEMASK: bool;

		DITHER: bool;

		FRONT_FACE:  number ;
		LINE_WIDTH:  number ;

		POLYGON_OFFSET_FACTOR:  number ;
		POLYGON_OFFSET_FILL: bool;
		POLYGON_OFFSET_UNITS:  number ;

		SAMPLE_BUFFERS:  number ;
		SAMPLE_COVERAGE_INVERT: bool;
		SAMPLE_COVERAGE_VALUE:  number ;
		SAMPLES:  number ;

		SCISSOR_TEST: bool;

		STENCIL_BACK_FAIL:  number ;
		STENCIL_BACK_FUNC:  number ;
		STENCIL_BACK_PASS_DEPTH_FAIL:  number ;
		STENCIL_BACK_PASS_DEPTH_PASS:  number ;
		STENCIL_BACK_REF:  number ;
		STENCIL_BACK_VALUE_MASK:  number ;
		STENCIL_BACK_WRITEMASK:  number ;
		STENCIL_CLEAR_VALUE:  number ;
		STENCIL_FAIL:  number ;
		STENCIL_FUNC:  number ;
		STENCIL_PASS_DEPTH_FAIL:  number ;
		STENCIL_PASS_DEPTH_PASS:  number ;
		STENCIL_REF:  number ;
		STENCIL_TEST: bool;
		STENCIL_VALUE_MASK:  number ;
		STENCIL_WRITEMASK:  number ;

		PACK_ALIGNMENT:  number ;
		UNPACK_ALIGNMENT:  number ;
	}

	export class WebGLRenderer extends render.Renderer {
		private _pCanvas: HTMLCanvasElement = null;

		private _pWebGLContext: WebGLRenderingContext;
		private _pWebGLFramebufferList: WebGLFramebuffer[];

		private _pDefaultCanvas: ICanvas3d;

//real context, if debug context used
		private _pWebGLInternalContext: WebGLRenderingContext = null;

		private _nActiveAttributes:  number  = 0;

		private _iSlot:  number  = 0;
		private _iCurrentTextureSlot:  number  = 0;
		private _iNextTextureSlot:  number  = 0;
		private _pTextureSlotList: WebGLTexture[] = null;
/**
		 * Need To reset texture states after render
		 */

		private _pTextureStateManager: WebGLInternalTextureStateManager = null;
/**
		 * Need to impove speed
		 */

		private _pCurrentContextStates: IWebGLContextStates = WebGLRenderer.createWebGLContextStates();
		private _pRenderStatesPool: IObjectArray = new util.ObjectArray();
		private _pFreeRenderStatesPool: IObjectArray = new util.ObjectArray();

		static DEFAULT_OPTIONS: IRendererOptions = {
			depth: false,
			stencil: false,
			antialias: false,
			preserveDrawingBuffer: false
		};

		constructor (pEngine: IEngine);
		constructor (pEngine: IEngine, sCanvas: string);
		constructor (pEngine: IEngine, pOptions: IRendererOptions);
		constructor (pEngine: IEngine, pCanvas: HTMLCanvasElement);
		constructor (pEngine: IEngine, options?: any) {
			super(pEngine);

			var pOptions: IRendererOptions = null;

			if (isDefAndNotNull(arguments[1])) {

//get HTMLCanvasElement by id
				if (isString(arguments[1])) {
					this._pCanvas = <HTMLCanvasElement>document.getElementById(arguments[1]);
				}
				else if (arguments[1] instanceof HTMLCanvasElement) {
					this._pCanvas = <HTMLCanvasElement>arguments[1];
				}
				else {
					pOptions = <IRendererOptions>arguments[1];

					if (pOptions.canvas instanceof HTMLCanvasElement) {
						this._pCanvas = pOptions.canvas;
					}
				}
			}

			if (isNull(this._pCanvas)) {
				this._pCanvas = <HTMLCanvasElement>document.createElement('canvas');
			}

			if (isNull(pOptions)) {
				pOptions = WebGLRenderer.DEFAULT_OPTIONS;
			}
			else {
				for (var i:  number  = 0, pOptList: string[] = Object.keys(WebGLRenderer.DEFAULT_OPTIONS); i < pOptList.length; ++ i) {
					var sOpt: string = pOptList[i];

					if (!isDef(pOptions[sOpt])) {
						pOptions[sOpt] = WebGLRenderer.DEFAULT_OPTIONS[sOpt];
					}
				}
			}

			{ logger.setSourceLocation( "WebGLRenderer.ts" , 153 ); logger.log("webgl context attributes:", pOptions); } ;

			this._pWebGLContext = createContext(this._pCanvas, pOptions);

			{ logger.setSourceLocation( "WebGLRenderer.ts" , 157 ); logger.assert(!isNull(this._pWebGLContext), "webgl context is NULL"); } ;

			this._pWebGLFramebufferList = new Array( 32 );


			for (var i:  number  = 0; i < this._pWebGLFramebufferList.length; ++ i) {
				this._pWebGLFramebufferList[i] = this._pWebGLContext.createFramebuffer();
			}

			this._pDefaultCanvas = new WebGLCanvas(this);
			{ logger.setSourceLocation( "WebGLRenderer.ts" , 167 ); logger.assert(this._pDefaultCanvas.create("primary-target"), "could not create WebGL canvas"); } ;

			this.attachRenderTarget(this._pDefaultCanvas);

			this._pTextureSlotList = new Array(maxTextureImageUnits);

			for(var i:  number  = 0; i < this._pTextureSlotList.length; i++){
				this._pTextureSlotList[i] = null;
			}

			for(var i:  number  = 0; i < 4; i++){
				this._pFreeRenderStatesPool.push(WebGLRenderer.createWebGLContextStates());
			}

			this.forceUpdateContextRenderStates();

			this._pTextureStateManager = new WebGLInternalTextureStateManager(this);
		}

		debug(bValue: bool = true, useApiTrace: bool = false): bool {
			var pWebGLInternalContext: WebGLRenderingContext = this._pWebGLContext;

			if (bValue) {
				if (isDef((<any>window).WebGLDebugUtils) && !isNull(pWebGLInternalContext)) {

		            this._pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLInternalContext,
		                (err:  number , funcName: string, args: IArguments): void => {
		                    throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
		                },
		                useApiTrace?
		                (funcName: string, args: IArguments): void => {
		                   { logger.setSourceLocation( "WebGLRenderer.ts" , 198 ); logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")"); } ;
		                }: null);

		            this._pWebGLInternalContext = pWebGLInternalContext;

		            return true;
		        }
	        }
	        else if (this.isDebug()) {
	        	this._pWebGLContext = this._pWebGLInternalContext;
	        	this._pWebGLInternalContext = null;

	        	return true;
	        }

			return false;
		}

		blendColor(fRed:  number , fGreen:  number , fBlue:  number , fAlpha:  number ): void {
			this._pWebGLContext.blendColor(fRed, fGreen, fBlue, fAlpha);
			this._pCurrentContextStates.BLEND_COLOR[0] = fRed;
			this._pCurrentContextStates.BLEND_COLOR[1] = fGreen;
			this._pCurrentContextStates.BLEND_COLOR[2] = fBlue;
			this._pCurrentContextStates.BLEND_COLOR[3] = fAlpha;
		}

		blendEquation(iWebGLMode:  number ): void {
			this._pWebGLContext.blendEquation(iWebGLMode);
			this._pCurrentContextStates.BLEND_EQUATION_RGB = iWebGLMode;
			this._pCurrentContextStates.BLEND_EQUATION_ALPHA = iWebGLMode;
		}

		blendEquationSeparate(iWebGLModeRGB:  number , iWebGLModeAlpha:  number ): void {
			this._pWebGLContext.blendEquationSeparate(iWebGLModeRGB, iWebGLModeAlpha);
			this._pCurrentContextStates.BLEND_EQUATION_RGB = iWebGLModeRGB;
			this._pCurrentContextStates.BLEND_EQUATION_ALPHA = iWebGLModeAlpha;
		}

		blendFunc(iWebGLSFactor:  number , iWebGLDFactor:  number ): void {
			this._pWebGLContext.blendFunc(iWebGLSFactor, iWebGLDFactor);
			this._pCurrentContextStates.BLEND_SRC_RGB = iWebGLSFactor;
			this._pCurrentContextStates.BLEND_SRC_ALPHA = iWebGLSFactor;
			this._pCurrentContextStates.BLEND_DST_RGB = iWebGLDFactor;
			this._pCurrentContextStates.BLEND_DST_ALPHA = iWebGLDFactor;
		}

		blendFuncSeparate(iWebGLSFactorRGB:  number , iWebGLDFactorRGB:  number , iWebGLSFactorAlpha:  number , iWebGLDFactorAlpha:  number ): void {
			this._pWebGLContext.blendFuncSeparate(iWebGLSFactorRGB, iWebGLDFactorRGB, iWebGLSFactorAlpha, iWebGLDFactorAlpha);
			this._pCurrentContextStates.BLEND_SRC_RGB = iWebGLSFactorRGB;
			this._pCurrentContextStates.BLEND_SRC_ALPHA = iWebGLSFactorAlpha;
			this._pCurrentContextStates.BLEND_DST_RGB = iWebGLDFactorRGB;
			this._pCurrentContextStates.BLEND_DST_ALPHA = iWebGLDFactorAlpha;
		}

		clearColor(fRed:  number , fGreen:  number , fBlue:  number , fAlpha:  number ): void {
			this._pWebGLContext.clearColor(fRed, fGreen, fBlue, fAlpha);
			this._pCurrentContextStates.COLOR_CLEAR_VALUE[0] = fRed;
			this._pCurrentContextStates.COLOR_CLEAR_VALUE[1] = fGreen;
			this._pCurrentContextStates.COLOR_CLEAR_VALUE[2] = fBlue;
			this._pCurrentContextStates.COLOR_CLEAR_VALUE[3] = fAlpha;
		}

		clearDepth(fDepth:  number ): void {
			this._pWebGLContext.clearDepth(fDepth);
			this._pCurrentContextStates.DEPTH_CLEAR_VALUE = fDepth;
		}

		clearStencil(iS:  number ): void {
			this._pWebGLContext.clearStencil(iS);
			this._pCurrentContextStates.STENCIL_CLEAR_VALUE = iS;
		}

		colorMask(bRed: bool, bGreen: bool, bBlue: bool, bAlpha: bool): void {
			this._pWebGLContext.colorMask(bRed, bGreen, bBlue, bAlpha);
			this._pCurrentContextStates.COLOR_WRITEMASK[0] = bRed;
			this._pCurrentContextStates.COLOR_WRITEMASK[1] = bGreen;
			this._pCurrentContextStates.COLOR_WRITEMASK[2] = bBlue;
			this._pCurrentContextStates.COLOR_WRITEMASK[3] = bAlpha;
		}

		cullFace(iWebGLMode:  number ): void {
			this._pWebGLContext.cullFace(iWebGLMode);
			this._pCurrentContextStates.CULL_FACE_MODE = iWebGLMode;
		}

		depthFunc(iWebGLMode:  number ): void {
			this._pWebGLContext.depthFunc(iWebGLMode);
			this._pCurrentContextStates.DEPTH_FUNC = iWebGLMode;
		}

		depthMask(bWrite: bool): void {
			this._pWebGLContext.depthMask(bWrite);
			this._pCurrentContextStates.DEPTH_WRITEMASK = bWrite;
		}

		depthRange(fZNear:  number , fZFar:  number ): void {
			this._pWebGLContext.depthRange(fZNear, fZFar);
			this._pCurrentContextStates.DEPTH_RANGE[0] = fZNear;
			this._pCurrentContextStates.DEPTH_RANGE[1] = fZFar;
		}

		disable(iWebGLCap:  number ): void {
			this._pWebGLContext.disable(iWebGLCap);

			switch(iWebGLCap){
				case  0x0B44 :
					this._pCurrentContextStates.CULL_FACE = false;
					return;
				case  0x0BE2 :
					this._pCurrentContextStates.BLEND = false;
					return;
				case  0x0BD0 :
					this._pCurrentContextStates.DITHER = false;
					return;
				case  0x0B90 :
					this._pCurrentContextStates.STENCIL_TEST = false;
					return;
				case  0x0B71 :
					this._pCurrentContextStates.DEPTH_TEST = false;
					return;
				case  0x0C11 :
					this._pCurrentContextStates.SCISSOR_TEST = false;
					return;
				case  0x8037 :
					this._pCurrentContextStates.POLYGON_OFFSET_FILL = false;
					return;
// case GL_SAMPLE_ALPHA_TO_COVERAGE:
// 	this._pCurrentContextStates.SAMPLE_ALPHA_TO_COVERAGE = false;
// 	return;
// case GL_SAMPLE_COVERAGE:
// 	this._pCurrentContextStates.SAMPLE_COVERAGE = false;
// 	return;
			}
		}

		enable(iWebGLCap:  number ): void {
			this._pWebGLContext.enable(iWebGLCap);

			switch(iWebGLCap){
				case  0x0B44 :
					this._pCurrentContextStates.CULL_FACE = true;
					return;
				case  0x0BE2 :
					this._pCurrentContextStates.BLEND = true;
					return;
				case  0x0BD0 :
					this._pCurrentContextStates.DITHER = true;
					return;
				case  0x0B90 :
					this._pCurrentContextStates.STENCIL_TEST = true;
					return;
				case  0x0B71 :
					this._pCurrentContextStates.DEPTH_TEST = true;
					return;
				case  0x0C11 :
					this._pCurrentContextStates.SCISSOR_TEST = true;
					return;
				case  0x8037 :
					this._pCurrentContextStates.POLYGON_OFFSET_FILL = true;
					return;
// case GL_SAMPLE_ALPHA_TO_COVERAGE:
// 	this._pCurrentContextStates.SAMPLE_ALPHA_TO_COVERAGE = false;
// 	return;
// case GL_SAMPLE_COVERAGE:
// 	this._pCurrentContextStates.SAMPLE_COVERAGE = false;
// 	return;
			}
		}

		frontFace(iWebGLMode:  number ): void {
			this._pWebGLContext.frontFace(iWebGLMode);
			this._pCurrentContextStates.FRONT_FACE = iWebGLMode;
		}

		getParameter(iWebGLName:  number ): any {
			switch(iWebGLName){
				case  0x0BE2 :
					return this._pCurrentContextStates.BLEND;
				case  0x8005 :
					return this._pCurrentContextStates.BLEND_COLOR;
				case  0x80CA :
					return this._pCurrentContextStates.BLEND_DST_ALPHA;
				case  0x80C8 :
					return this._pCurrentContextStates.BLEND_DST_RGB;
				case  0x883D :
					return this._pCurrentContextStates.BLEND_EQUATION_ALPHA;
				case  0x8009 :
					return this._pCurrentContextStates.BLEND_EQUATION_RGB;
				case  0x80CB :
					return this._pCurrentContextStates.BLEND_SRC_ALPHA;
				case  0x80C9 :
					return this._pCurrentContextStates.BLEND_SRC_RGB;
				case  0x0C22 :
					return this._pCurrentContextStates.COLOR_CLEAR_VALUE;
				case  0x0C23 :
					return this._pCurrentContextStates.COLOR_WRITEMASK;
				case  0x0B44 :
					return this._pCurrentContextStates.CULL_FACE;
				case  0x0B45 :
					return this._pCurrentContextStates.CULL_FACE_MODE;
				case  0x0B73 :
					return this._pCurrentContextStates.DEPTH_CLEAR_VALUE;
				case  0x0B74 :
					return this._pCurrentContextStates.DEPTH_FUNC;
				case  0x0B70 :
					return this._pCurrentContextStates.DEPTH_RANGE;
				case  0x0B71 :
					return this._pCurrentContextStates.DEPTH_TEST;
				case  0x0B72 :
					return this._pCurrentContextStates.DEPTH_WRITEMASK;
				case  0x0BD0 :
					return this._pCurrentContextStates.DITHER;
				case  0x0B46 :
					return this._pCurrentContextStates.FRONT_FACE;
				case  0x0B21 :
					return this._pCurrentContextStates.LINE_WIDTH;
				case  0x8038 :
					return this._pCurrentContextStates.POLYGON_OFFSET_FACTOR;
				case  0x8037 :
					return this._pCurrentContextStates.POLYGON_OFFSET_FILL;
				case  0x2A00 :
					return this._pCurrentContextStates.POLYGON_OFFSET_UNITS;
				case  0x80A8 :
					return this._pCurrentContextStates.SAMPLE_BUFFERS;
				case  0x80AB :
					return this._pCurrentContextStates.SAMPLE_COVERAGE_INVERT;
				case  0x80AA :
					return this._pCurrentContextStates.SAMPLE_COVERAGE_VALUE;
				case  0x80A9 :
					return this._pCurrentContextStates.SAMPLES;
				case  0x0C11 :
					return this._pCurrentContextStates.SCISSOR_TEST;
				case  0x8801 :
					return this._pCurrentContextStates.STENCIL_BACK_FAIL;
				case  0x8800 :
					return this._pCurrentContextStates.STENCIL_BACK_FUNC;
				case  0x8802 :
					return this._pCurrentContextStates.STENCIL_BACK_PASS_DEPTH_FAIL;
				case  0x8803 :
					return this._pCurrentContextStates.STENCIL_BACK_PASS_DEPTH_PASS;
				case  0x8CA3 :
					return this._pCurrentContextStates.STENCIL_BACK_REF;
				case  0x8CA4 :
					return this._pCurrentContextStates.STENCIL_BACK_VALUE_MASK;
				case  0x8CA5 :
					return this._pCurrentContextStates.STENCIL_BACK_WRITEMASK;
				case  0x0B91 :
					return this._pCurrentContextStates.STENCIL_CLEAR_VALUE;
				case  0x0B94 :
					return this._pCurrentContextStates.STENCIL_FAIL;
				case  0x0B92 :
					return this._pCurrentContextStates.STENCIL_FUNC;
				case  0x0B95 :
					return this._pCurrentContextStates.STENCIL_PASS_DEPTH_FAIL;
				case  0x0B96 :
					return this._pCurrentContextStates.STENCIL_PASS_DEPTH_PASS;
				case  0x0B97 :
					return this._pCurrentContextStates.STENCIL_REF;
				case  0x0B90 :
					return this._pCurrentContextStates.STENCIL_TEST;
				case  0x0B93 :
					return this._pCurrentContextStates.STENCIL_VALUE_MASK;
				case  0x0B98 :
					return this._pCurrentContextStates.STENCIL_WRITEMASK;
				case  0x0CF5 :
					return this._pCurrentContextStates.UNPACK_ALIGNMENT;
				case  0x0D05 :
					return this._pCurrentContextStates.PACK_ALIGNMENT;
				default:
					return this._pWebGLContext.getParameter(iWebGLName);
			}
		}

		lineWidth(fWidth:  number ): void {
			this._pWebGLContext.lineWidth(fWidth);
			this._pCurrentContextStates.LINE_WIDTH = fWidth;
		}

		pixelStorei(iWebGLName:  number , iParam:  number ): void {
			this._pWebGLContext.pixelStorei(iWebGLName, iParam);

			if(iWebGLName ===  0x0CF5 ){
				this._pCurrentContextStates.UNPACK_ALIGNMENT = iParam;
			}
			else {
				this._pCurrentContextStates.PACK_ALIGNMENT = iParam;
			}
		}

		polygonOffset(fFactor:  number , fUnints:  number ): void {
			this._pWebGLContext.polygonOffset(fFactor, fUnints);
			this._pCurrentContextStates.POLYGON_OFFSET_FACTOR = fFactor;
			this._pCurrentContextStates.POLYGON_OFFSET_UNITS = fUnints;
		}

		sampleCoverage(fValue:  number , bInvert: bool): void {
			this._pWebGLContext.sampleCoverage(fValue, bInvert);
			this._pCurrentContextStates.SAMPLE_COVERAGE_VALUE = fValue;
			this._pCurrentContextStates.SAMPLE_COVERAGE_INVERT = bInvert;
		}

		stencilFunc(iWebGLFunc:  number , iRef:  number , iMask:  number ): void {
			this._pWebGLContext.stencilFunc(iWebGLFunc, iRef, iMask);
			this._pCurrentContextStates.STENCIL_FUNC = iWebGLFunc;
			this._pCurrentContextStates.STENCIL_REF = iRef;
			this._pCurrentContextStates.STENCIL_VALUE_MASK = iMask;
			this._pCurrentContextStates.STENCIL_BACK_FUNC = iWebGLFunc;
			this._pCurrentContextStates.STENCIL_BACK_REF = iRef;
			this._pCurrentContextStates.STENCIL_BACK_VALUE_MASK = iMask;
		}

		stencilFuncSeparate(iWebGLFace:  number , iWebGLFunc:  number , iRef:  number , iMask:  number ): void {
			this._pWebGLContext.stencilFuncSeparate(iWebGLFace, iWebGLFunc, iRef, iMask);

			if(iWebGLFace ===  0x0408 ){
				this._pCurrentContextStates.STENCIL_FUNC = iWebGLFunc;
				this._pCurrentContextStates.STENCIL_REF = iRef;
				this._pCurrentContextStates.STENCIL_VALUE_MASK = iMask;
				this._pCurrentContextStates.STENCIL_BACK_FUNC = iWebGLFunc;
				this._pCurrentContextStates.STENCIL_BACK_REF = iRef;
				this._pCurrentContextStates.STENCIL_BACK_VALUE_MASK = iMask;
			}
			else if(iWebGLFace ===  0x0404 ){
				this._pCurrentContextStates.STENCIL_FUNC = iWebGLFunc;
				this._pCurrentContextStates.STENCIL_REF = iRef;
				this._pCurrentContextStates.STENCIL_VALUE_MASK = iMask;
			}
			else {
				this._pCurrentContextStates.STENCIL_BACK_FUNC = iWebGLFunc;
				this._pCurrentContextStates.STENCIL_BACK_REF = iRef;
				this._pCurrentContextStates.STENCIL_BACK_VALUE_MASK = iMask;
			}
		}

		stencilMask(iMask:  number ): void {
			this._pWebGLContext.stencilMask(iMask);
			this._pCurrentContextStates.STENCIL_WRITEMASK = iMask;
			this._pCurrentContextStates.STENCIL_BACK_WRITEMASK = iMask;
		}

		stencilMaskSeparate(iWebGLFace:  number , iMask:  number ): void {
			this._pWebGLContext.stencilMaskSeparate(iWebGLFace, iMask);

			if(iWebGLFace ===  0x0408 ){
				this._pCurrentContextStates.STENCIL_WRITEMASK = iMask;
				this._pCurrentContextStates.STENCIL_BACK_WRITEMASK = iMask;
			}
			else if(iWebGLFace ===  0x0404 ){
				this._pCurrentContextStates.STENCIL_WRITEMASK = iMask;
			}
			else {
				this._pCurrentContextStates.STENCIL_BACK_WRITEMASK = iMask;
			}
		}

		stencilOp(iFail:  number , iZFail:  number , iZPass:  number ): void {
			this._pWebGLContext.stencilOp(iFail, iZFail, iZPass);

			this._pCurrentContextStates.STENCIL_FAIL = iFail;
			this._pCurrentContextStates.STENCIL_PASS_DEPTH_FAIL = iZFail;
			this._pCurrentContextStates.STENCIL_PASS_DEPTH_PASS = iZPass;
			this._pCurrentContextStates.STENCIL_BACK_FAIL = iFail;
			this._pCurrentContextStates.STENCIL_BACK_PASS_DEPTH_FAIL = iZFail;
			this._pCurrentContextStates.STENCIL_BACK_PASS_DEPTH_PASS = iZPass;
		}

		stencilOpSeparate(iWebGLFace:  number , iFail:  number , iZFail:  number , iZPass:  number ): void {
			this._pWebGLContext.stencilOpSeparate(iWebGLFace, iFail, iZFail, iZPass);

			if(iWebGLFace ===  0x0408 ){
				this._pCurrentContextStates.STENCIL_FAIL = iFail;
				this._pCurrentContextStates.STENCIL_PASS_DEPTH_FAIL = iZFail;
				this._pCurrentContextStates.STENCIL_PASS_DEPTH_PASS = iZPass;
				this._pCurrentContextStates.STENCIL_BACK_FAIL = iFail;
				this._pCurrentContextStates.STENCIL_BACK_PASS_DEPTH_FAIL = iZFail;
				this._pCurrentContextStates.STENCIL_BACK_PASS_DEPTH_PASS = iZPass;
			}
			else if(iWebGLFace ===  0x0404 ){
				this._pCurrentContextStates.STENCIL_FAIL = iFail;
				this._pCurrentContextStates.STENCIL_PASS_DEPTH_FAIL = iZFail;
				this._pCurrentContextStates.STENCIL_PASS_DEPTH_PASS = iZPass;
			}
			else {
				this._pCurrentContextStates.STENCIL_BACK_FAIL = iFail;
				this._pCurrentContextStates.STENCIL_BACK_PASS_DEPTH_FAIL = iZFail;
				this._pCurrentContextStates.STENCIL_BACK_PASS_DEPTH_PASS = iZPass;
			}
		}

		/**@inline*/  _getTextureStateManager(): WebGLInternalTextureStateManager {
			return this._pTextureStateManager;
		}

		_beginRender(): void {
			this.enable( 0x0C11 );
			this.disable( 0x0BE2 );
		}

		private _time:  number [] = [0, 0, 0, 0, 0, 0, 0, 0];

		_printTime(): void {
			var _iTotalTime:  number  = 0;
			for(var i:  number  = 0; i < this._time.length; i++){
				_iTotalTime += this._time[i];
			}

			var _pPrinted: string[] = new Array(this._time.length);

			for(var i:  number  = 0; i < this._time.length; i++){
				_pPrinted[i] = (this._time[i]/ _iTotalTime).toFixed(2);
			}

			{ logger.setSourceLocation( "WebGLRenderer.ts" , 610 ); logger.log(_pPrinted.join("% ")); } ;
			{ logger.setSourceLocation( "WebGLRenderer.ts" , 611 ); logger.log(this._time.join("ms ")); }
		}

		_renderEntry(pEntry: IRenderEntry): void {
			var deltaTime:  number  = 0;

// deltaTime = Date.now();

			var pViewport: render.Viewport = <render.Viewport>pEntry.viewport;
			if(isNull(pViewport)){
				{ logger.setSourceLocation( "WebGLRenderer.ts" , 621 ); logger.log(pEntry); } ;
			}
			var pRenderTarget: IRenderTarget = (<render.Viewport>pViewport).getTarget();
			var pInput: IShaderInput = pEntry.input;
			var pMaker: fx.Maker = <fx.Maker>pEntry.maker;

// deltaTime = Date.now() - deltaTime;
// this._time[0] += deltaTime;


//--------------------------

// deltaTime = Date.now();
			if(!isNull(pEntry.renderTarget)){
				this._setRenderTarget(pEntry.renderTarget);
				this._lockRenderTarget();

				this._setViewportForRender(pViewport);

				this._unlockRenderTarget();
			}
			else {
				this._setViewportForRender(pViewport);
			}

// this.forceUpdateContextRenderStates();
			var isNeedPopRenderStates: bool = this.applyInputRenderStates(pInput.renderStates);

// if(isDef(pMaker["_pShaderUniformInfoMap"]["fKrESun"])){
// 	// LOG("1");
// 	this._pWebGLContext.depthMask(false);
// }
// deltaTime = Date.now() - deltaTime;
// this._time[1] += deltaTime;

//-----------------------

// deltaTime = Date.now();

			var pWebGLProgram: WebGLShaderProgram = <WebGLShaderProgram>(pMaker).shaderProgram;

			this.useWebGLProgram(pWebGLProgram.getWebGLProgram());

			this.enableWebGLVertexAttribs(pWebGLProgram.totalAttributes);

// deltaTime = Date.now() - deltaTime;
// this._time[2] += deltaTime;

//-----------------

// deltaTime = Date.now();

			var pAttribLocations: IntMap = pWebGLProgram._getActiveAttribLocations();
			var pAttributeInfo: IAFXBaseAttrInfo[] = pMaker.attributeInfo;

			var pBufferMap: IBufferMap = pEntry.bufferMap;

// deltaTime = Date.now() - deltaTime;
// this._time[3] += deltaTime;

//-----------------

// deltaTime = Date.now();

			if(!isNull(pBufferMap.index)){
				this.bindWebGLBuffer( 0x8893 , (<WebGLIndexBuffer>pBufferMap.index.buffer).getWebGLBuffer());
			}

// deltaTime = Date.now() - deltaTime;
// this._time[4] += deltaTime;

//---------


// deltaTime = Date.now();

			for(var i:  number  = 0; i < pAttributeInfo.length; i++){
				var sAttrName: string = pAttributeInfo[i].name;
				var sAttrSemantic: string = pAttributeInfo[i].semantic;

// if(isNull(sAttrSemantic)){
// 	continue;
// }

				var iLoc:  number  = pAttribLocations[sAttrName];
				var pFlow: IDataFlow = pInput.attrs[i];
				var pData: data.VertexData = null;
				var sSemantics: string = null;

				if (pFlow.type === EDataFlowTypes.MAPPABLE) {
					pData = <data.VertexData>pFlow.mapper.data;
					sSemantics = pFlow.mapper.semantics;
				}
				else {
					pData = <data.VertexData>pFlow.data;
					sSemantics = sAttrSemantic;
				}

				var pDecl: data.VertexDeclaration = <data.VertexDeclaration>pData.getVertexDeclaration();
				var pVertexElement: data.VertexElement = <data.VertexElement>pDecl.findElement(sSemantics);

				this.bindWebGLBuffer( 0x8892 , (<WebGLVertexBuffer>pData.buffer).getWebGLBuffer());
				this._pWebGLContext.vertexAttribPointer(iLoc,
                                    pVertexElement.count,
                                    pVertexElement.type,
                                    false,
                                    pData.stride,
                                    pVertexElement.offset);
			}

// deltaTime = Date.now() - deltaTime;
// this._time[5] += deltaTime;

//------------

// deltaTime = Date.now();

			var pUniformNames: string[] = pMaker.uniformNames;

			for (var i:  number  = 0; i < pUniformNames.length; i++) {
				pMaker.setUniform(i, pInput.uniforms[i]);
			}
// deltaTime = Date.now() - deltaTime;
// this._time[6] += deltaTime;

//---------

// deltaTime = Date.now();
			pEntry.bufferMap._draw();
// deltaTime = Date.now() - deltaTime;
// this._time[7] += deltaTime;
// LOG(pEntry.bufferMap.toString())

// if(isDef(pMaker["_pShaderUniformInfoMap"]["fKrESun"])){
// 	this._pWebGLContext.depthMask(true);
// }

			if(isNeedPopRenderStates){
				this._popRenderStates(false);
			}
		}

		_endRender(): void {
			this.disable( 0x0C11 );
			this._pTextureStateManager.reset();
		}

		_setViewport(pViewport: IViewport): void {
// if(true){
// 	return;
// }

			if(isNull(pViewport)){
				this._pActiveViewport = null;
				this._setRenderTarget(null);
				return;
			}

			var isViewportUpdate: bool = pViewport !== this._pActiveViewport || pViewport.isUpdated();
			var isRenderTargetUpdate: bool = pViewport.getTarget() !== this._pActiveRenderTarget;

			if(isViewportUpdate || isRenderTargetUpdate) {
				var pTarget: IRenderTarget = pViewport.getTarget();

				this._setRenderTarget(pTarget);

				if(isViewportUpdate){
					this._pActiveViewport = pViewport;

					var x:  number  = pViewport.actualLeft,
						y:  number  = pViewport.actualTop,
						w:  number  = pViewport.actualWidth,
						h:  number  = pViewport.actualHeight;

					this._pWebGLContext.viewport(x, y, w, h);
					this._pWebGLContext.scissor(x, y, w, h);
// if(w !== 2048){
// 	LOG(x, y, w, h, pViewport.getGuid());
// }

					pViewport._clearUpdatedFlag();
				}
			}
		}

        _setRenderTarget(pTarget: IRenderTarget): void {
// if(true){
// 	return;
// }
//May be unbind()

        	if(this._isLockRenderTarget()){
        		return;
        	}

        	this._pActiveRenderTarget = pTarget;

        	if(!isNull(pTarget)){
        		var pFrameBuffer: WebGLInternalFrameBuffer = pTarget.getCustomAttribute("FBO");
        		if(!isNull(pFrameBuffer)){
        			pFrameBuffer._bind();
        		}
        		else {
        			this.bindWebGLFramebuffer( 0x8D40 , null);
        		}
        	}
        }

        _setCullingMode(eMode: ECullingMode): void {
// if(true){
// 	return;
// }
        	var iWebGLCullMode:  number  = 0;

        	switch(eMode){
        		case ECullingMode.NONE:
        			this.disable( 0x0B44 );
        			return;

        		default:
        		case ECullingMode.CLOCKWISE:
        			iWebGLCullMode =  0x0404 ;
        			break;

        		case ECullingMode.ANTICLOCKWISE:
        			iWebGLCullMode =  0x0405 ;
        			break;
        	}

        	this.enable( 0x0B44 );
        	this.cullFace(iWebGLCullMode);
        }

        _setDepthBufferParams(bDepthTest: bool, bDepthWrite: bool,
        					  eDepthFunction: ECompareFunction, fClearDepth?:  number  = 1.): void {
// if(true){
// 	return;
// }
        	if(bDepthTest){
        		this.clearDepth(fClearDepth);
        		this.enable( 0x0B71 );
        	}
        	else {
        		this.disable( 0x0B71 );
        	}

        	var iWebGLDepthFunc:  number  = this.convertCompareFunction(eDepthFunction);

        	this.depthMask(bDepthWrite);
        	this.depthFunc(iWebGLDepthFunc);
        }

		isDebug(): bool {
			return !isNull(this._pWebGLInternalContext);
		}

		/**@inline*/  getHTMLCanvas(): HTMLCanvasElement {
			return this._pCanvas;
		}

		/**@inline*/  getWebGLContext(): WebGLRenderingContext {
			return this._pWebGLContext;
		}


/** Buffer Objects. */

		/**@inline*/  bindWebGLBuffer(eTarget:  number , pBuffer: WebGLBuffer): void {
			this._pWebGLContext.bindBuffer(eTarget, pBuffer);
		}

		/**@inline*/  createWebGLBuffer(): WebGLBuffer {
			return this._pWebGLContext.createBuffer();
		}

		/**@inline*/  deleteWebGLBuffer(pBuffer: WebGLBuffer): void {
			this._pWebGLContext.deleteBuffer(pBuffer);
		}

/** Texture Objects. */

		/**@inline*/  bindWebGLTexture(eTarget:  number , pTexture: WebGLTexture): void {
//if(this._pTextureSlotList[this._iCurrentTextureSlot] !== pTexture){
				this._pWebGLContext.bindTexture(eTarget, pTexture);
				this._pTextureSlotList[this._iCurrentTextureSlot] = pTexture;
//}
		}

		/**@inline*/  activateWebGLTexture(iWebGLSlot:  number ): void {
			this._pWebGLContext.activeTexture(iWebGLSlot);
// this._iCurrentTextureSlot = iWebGLSlot - GL_TEXTURE0;
		}

		activateWebGLTextureInAutoSlot(eTarget:  number , pTexture: WebGLTexture):  number  {

// var iSlot: uint = this._pTextureSlotList.indexOf(pTexture);

// if(iSlot === -1) {
				var iSlot = this._iNextTextureSlot;

				this._iNextTextureSlot++;

				if(this._iNextTextureSlot === maxTextureImageUnits){
					this._iNextTextureSlot = 0;
				}

				this.activateWebGLTexture( 0x84C0  + iSlot);
				this.bindWebGLTexture(eTarget, pTexture);
// }
// else {
// 	this.activateWebGLTexture(GL_TEXTURE0 + iSlot);
// }

			return iSlot;
		}

// inline getFreeWebGLTextureSlot(): int {
// 	return this._getNextTextureSlot() + GL_TEXTURE0;
// }

// inline getNextTextureSlot(): int {
// 	return this._iSlot === (maxTextureImageUnits - 1) ? (this._iSlot = 0) : (++this._iSlot);
// }

// inline getTextureSlot(): int {
// 	return this._iSlot - 1;
// }

		/**@inline*/  createWebGLTexture(): WebGLTexture {
			return this._pWebGLContext.createTexture();
		}

		/**@inline*/  deleteWebGLTexture(pTexture: WebGLTexture): void {
			this._pWebGLContext.deleteTexture(pTexture);
		}

/** Framebuffer Objects */

		/**@inline*/  createWebGLFramebuffer(): WebGLFramebuffer {

			if (this._pWebGLFramebufferList.length === 0) {
				{ logger.setSourceLocation( "WebGLRenderer.ts" , 962 ); logger.criticalError("WebGL framebuffer limit exidit"); } ;
			}

			return this._pWebGLFramebufferList.pop();
		}

		/**@inline*/  bindWebGLFramebuffer(eTarget:  number , pBuffer: WebGLFramebuffer): void {
			this._pWebGLContext.bindFramebuffer(eTarget, pBuffer);
//this._pCurrentContextStates.framebuffer = pBuffer;
		}

		/**@inline*/  bindWebGLFramebufferTexture2D(eTarget:  number , eAttachment: number ,eTexTarget: number , pTexture: WebGLTexture, iMipLevel?: number =0): void {
			this._pWebGLContext.framebufferTexture2D(eTarget, eAttachment, eTexTarget, pTexture, iMipLevel)
		}

		/**@inline*/  deleteWebGLFramebuffer(pBuffer: WebGLFramebuffer): void {
			this._pWebGLFramebufferList.push(pBuffer);
		}

/** Renderbuffer Objects */

		/**@inline*/  createWebGLRenderbuffer(): WebGLRenderbuffer {
			return this._pWebGLContext.createRenderbuffer();
		}

		/**@inline*/  bindWebGLRenderbuffer(eTarget:  number , pBuffer: WebGLRenderbuffer): void {
			this._pWebGLContext.bindRenderbuffer(eTarget, pBuffer);
		}

		/**@inline*/  deleteWebGLRenderbuffer(pBuffer: WebGLRenderbuffer): void {
			this._pWebGLContext.deleteRenderbuffer(pBuffer);
		}


		/**@inline*/  createWebGLProgram(): WebGLProgram {
			return this._pWebGLContext.createProgram();
		}

		/**@inline*/  deleteWebGLProgram(pProgram: WebGLProgram): void {
			this._pWebGLContext.deleteProgram(pProgram);
		}

		/**@inline*/  useWebGLProgram(pProgram: WebGLProgram): void {
			this._pWebGLContext.useProgram(pProgram);
		}

		enableWebGLVertexAttribs(iTotal:  number ): void {
			if (this._nActiveAttributes > iTotal) {
				for (var i:  number  = iTotal; i < this._nActiveAttributes; i++) {
					this._pWebGLContext.disableVertexAttribArray(i);
				}
			}
			else {
				for (var i:  number  = this._nActiveAttributes; i < iTotal; i++) {
					this._pWebGLContext.enableVertexAttribArray(i);
				}
			}

			this._nActiveAttributes = iTotal;
		}

		disableAllWebGLVertexAttribs(): void {
			var i: number  = 0;
			for(i = 0; i < this._nActiveAttributes; i++) {
				this._pWebGLContext.disableVertexAttribArray(i);
			}

			this._nActiveAttributes = 0;
		}

		getDefaultCanvas(): ICanvas3d {
			return this._pDefaultCanvas;
		}


		clearFrameBuffer(iBuffers:  number , cColor: IColor, fDepth:  number , iStencil:  number ): void {
			var bScissorTestEnable: bool = this.getParameter( 0x0C11 );

			this.enable( 0x0C11 );

			var iWebGLFlag:  number  = 0;
			var bOldDepthWrite: bool = this.getParameter( 0x0B72 );

			if(iBuffers & EFrameBufferTypes.COLOR){
				iWebGLFlag |=  0x00004000 ;
				this._pWebGLContext.clearColor(cColor.r, cColor.g, cColor.b, cColor.a);
			}

			if(iBuffers & EFrameBufferTypes.DEPTH){
				iWebGLFlag |=  0x00000100 ;

				if(!bOldDepthWrite){
					this._pWebGLContext.depthMask(true);
				}

				this._pWebGLContext.clearDepth(fDepth);
			}

			if(iBuffers & EFrameBufferTypes.STENCIL){
				iWebGLFlag |=  0x00000400 ;

				this._pWebGLContext.stencilMask(0xFFFFFFFF);
				this._pWebGLContext.clearStencil(iStencil);
			}

			this._pWebGLContext.clear(iWebGLFlag);

			if (!bOldDepthWrite && (iBuffers & EFrameBufferTypes.DEPTH)) {
	            this._pWebGLContext.depthMask(false);
        	}

        	if(!bScissorTestEnable){
        		this.disable( 0x0C11 );
        	}
		}

		/**@inline*/  _disableTextureUnitsFrom(iUnit:  number ): void {
			for(var i:  number  = iUnit; i < this._pTextureSlotList.length; i++) {
				this._pTextureSlotList[i] = null;
			}
		}

		_pushRenderStates(): void {
			this._pRenderStatesPool.push(this._pCurrentContextStates);

			this._pCurrentContextStates = WebGLRenderer.copyWebGLContextStates(this.getFreeRenderStates(), this._pCurrentContextStates);
		}

		_popRenderStates(isForce: bool): void {
			if(this._pRenderStatesPool.length === 0) {
				{ logger.setSourceLocation( "WebGLRenderer.ts" , 1091 ); logger.warning("Can not pop context render states. Pool of context is empty."); } ;
			}

			this._pFreeRenderStatesPool.push(this._pCurrentContextStates);

			if(isForce){
				this.forceUpdateContextRenderStates();
			}

			var pCurreentStates: IWebGLContextStates = this._pCurrentContextStates;
			this._pCurrentContextStates = this._pRenderStatesPool.pop();

			this.restoreWebGLContextRenderStates(pCurreentStates);
		}

		private restoreWebGLContextRenderStates(pStatesFrom: IWebGLContextStates): void {
			this.restoreBlendStates(pStatesFrom);
			this.restoreCullStates(pStatesFrom);
			this.restoreColorStates(pStatesFrom);
			this.restoreDepthStates(pStatesFrom);
			this.restoreDitherStates(pStatesFrom);
			this.restoreFrontFaceStates(pStatesFrom);
			this.restorePolygonStates(pStatesFrom);
			this.restoreSampleStates(pStatesFrom);
			this.restoreScissorStates(pStatesFrom);
			this.restoreStencilStates(pStatesFrom);
			this.restorePackStates(pStatesFrom);
		}

		private restoreBlendStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.BLEND !== pStatesFrom.BLEND){
				if(pRestoreStates.BLEND) {
					this._pWebGLContext.enable( 0x0BE2 );
				}
				else {
					this._pWebGLContext.disable( 0x0BE2 );
				}
			}

			if (pRestoreStates.BLEND_EQUATION_RGB !== pStatesFrom.BLEND_EQUATION_RGB ||
				pRestoreStates.BLEND_EQUATION_ALPHA !== pStatesFrom.BLEND_EQUATION_ALPHA) {

				if(pRestoreStates.BLEND_EQUATION_RGB === pRestoreStates.BLEND_EQUATION_ALPHA) {
					this._pWebGLContext.blendEquation(pRestoreStates.BLEND_EQUATION_RGB);
				}
				else {
					this._pWebGLContext.blendEquationSeparate(pRestoreStates.BLEND_EQUATION_RGB,
															  pRestoreStates.BLEND_EQUATION_ALPHA);
				}
			}

			if (pRestoreStates.BLEND_DST_RGB !== pStatesFrom.BLEND_DST_RGB ||
				pRestoreStates.BLEND_DST_ALPHA !== pStatesFrom.BLEND_DST_ALPHA ||
				pRestoreStates.BLEND_SRC_RGB !== pStatesFrom.BLEND_SRC_RGB ||
				pRestoreStates.BLEND_SRC_ALPHA !== pStatesFrom.BLEND_SRC_ALPHA) {

				if (pRestoreStates.BLEND_DST_RGB === pRestoreStates.BLEND_DST_ALPHA &&
					pRestoreStates.BLEND_SRC_RGB === pRestoreStates.BLEND_SRC_ALPHA) {

					this._pWebGLContext.blendFunc(pRestoreStates.BLEND_SRC_RGB, pRestoreStates.BLEND_DST_RGB);
				}
				else {
					this._pWebGLContext.blendFuncSeparate(pRestoreStates.BLEND_SRC_RGB, pRestoreStates.BLEND_DST_RGB,
														  pRestoreStates.BLEND_SRC_ALPHA, pRestoreStates.BLEND_DST_ALPHA);
				}
			}
		}

		private restoreCullStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.CULL_FACE !== pStatesFrom.CULL_FACE){
				if(pRestoreStates.CULL_FACE) {
					this._pWebGLContext.enable( 0x0B44 );
				}
				else {
					this._pWebGLContext.disable( 0x0B44 );
				}
			}

			if (pRestoreStates.CULL_FACE_MODE !== pStatesFrom.CULL_FACE_MODE){
				this._pWebGLContext.cullFace(pRestoreStates.CULL_FACE_MODE);
			}
		}

		private restoreColorStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.COLOR_CLEAR_VALUE[0] !== pStatesFrom.COLOR_CLEAR_VALUE[0] ||
				pRestoreStates.COLOR_CLEAR_VALUE[1] !== pStatesFrom.COLOR_CLEAR_VALUE[1] ||
				pRestoreStates.COLOR_CLEAR_VALUE[2] !== pStatesFrom.COLOR_CLEAR_VALUE[2] ||
				pRestoreStates.COLOR_CLEAR_VALUE[3] !== pStatesFrom.COLOR_CLEAR_VALUE[3]){

				this._pWebGLContext.clearColor(pRestoreStates.COLOR_CLEAR_VALUE[0],
											   pRestoreStates.COLOR_CLEAR_VALUE[1],
											   pRestoreStates.COLOR_CLEAR_VALUE[2],
											   pRestoreStates.COLOR_CLEAR_VALUE[3]);
			}

			if (pRestoreStates.COLOR_WRITEMASK[0] !== pStatesFrom.COLOR_WRITEMASK[0] ||
				pRestoreStates.COLOR_WRITEMASK[1] !== pStatesFrom.COLOR_WRITEMASK[1] ||
				pRestoreStates.COLOR_WRITEMASK[2] !== pStatesFrom.COLOR_WRITEMASK[2] ||
				pRestoreStates.COLOR_WRITEMASK[3] !== pStatesFrom.COLOR_WRITEMASK[3]){

				this._pWebGLContext.colorMask(pRestoreStates.COLOR_WRITEMASK[0],
											  pRestoreStates.COLOR_WRITEMASK[1],
											  pRestoreStates.COLOR_WRITEMASK[2],
											  pRestoreStates.COLOR_WRITEMASK[3]);
			}
		}

		private restoreDepthStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.DEPTH_TEST !== pStatesFrom.DEPTH_TEST){
				if(pRestoreStates.DEPTH_TEST) {
					this._pWebGLContext.enable( 0x0B71 );
				}
				else {
					this._pWebGLContext.disable( 0x0B71 );
				}
			}

			if (pRestoreStates.DEPTH_CLEAR_VALUE !== pStatesFrom.DEPTH_CLEAR_VALUE){
				this._pWebGLContext.clearDepth(pRestoreStates.DEPTH_CLEAR_VALUE);
			}

			if (pRestoreStates.DEPTH_FUNC !== pStatesFrom.DEPTH_FUNC){
				this._pWebGLContext.depthFunc(pRestoreStates.DEPTH_FUNC);
			}

			if (pRestoreStates.DEPTH_WRITEMASK !== pStatesFrom.DEPTH_WRITEMASK){
				this._pWebGLContext.depthMask(pRestoreStates.DEPTH_WRITEMASK);
			}

			if (pRestoreStates.DEPTH_RANGE[0] !== pStatesFrom.DEPTH_RANGE[0] ||
				pRestoreStates.DEPTH_RANGE[1] !== pStatesFrom.DEPTH_RANGE[1]){
				this._pWebGLContext.depthRange(pRestoreStates.DEPTH_RANGE[0], pRestoreStates.DEPTH_RANGE[1]);
			}
		}

		private restoreDitherStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.DITHER !== pStatesFrom.DITHER){
				if(pRestoreStates.DITHER) {
					this._pWebGLContext.enable( 0x0BD0 );
				}
				else {
					this._pWebGLContext.disable( 0x0BD0 );
				}
			}
		}

		private restoreFrontFaceStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.FRONT_FACE !== pStatesFrom.FRONT_FACE){
				this._pWebGLContext.frontFace(pRestoreStates.FRONT_FACE);
			}
		}

		private restorePolygonStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.POLYGON_OFFSET_FILL !== pStatesFrom.POLYGON_OFFSET_FILL){
				if(pRestoreStates.POLYGON_OFFSET_FILL) {
					this._pWebGLContext.enable( 0x8037 );
				}
				else {
					this._pWebGLContext.disable( 0x8037 );
				}
			}

			if (pRestoreStates.POLYGON_OFFSET_FACTOR !== pStatesFrom.POLYGON_OFFSET_FACTOR ||
				pRestoreStates.POLYGON_OFFSET_UNITS !== pStatesFrom.POLYGON_OFFSET_UNITS){

				this._pWebGLContext.polygonOffset(pRestoreStates.POLYGON_OFFSET_FACTOR, pRestoreStates.POLYGON_OFFSET_UNITS);
			}

		}

		private restoreSampleStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.SAMPLE_COVERAGE_VALUE !== pStatesFrom.SAMPLE_COVERAGE_VALUE ||
				pRestoreStates.SAMPLE_COVERAGE_INVERT !== pStatesFrom.SAMPLE_COVERAGE_INVERT){

				this._pWebGLContext.sampleCoverage(pRestoreStates.SAMPLE_COVERAGE_VALUE, pRestoreStates.SAMPLE_COVERAGE_INVERT);
			}
		}

		private restoreScissorStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.SCISSOR_TEST !== pStatesFrom.SCISSOR_TEST){
				if(pRestoreStates.SCISSOR_TEST) {
					this._pWebGLContext.enable( 0x0C11 );
				}
				else {
					this._pWebGLContext.disable( 0x0C11 );
				}
			}
		}

		private restoreStencilStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if (pRestoreStates.STENCIL_TEST !== pStatesFrom.STENCIL_TEST){
				if(pRestoreStates.STENCIL_TEST) {
					this._pWebGLContext.enable( 0x0B90 );
				}
				else {
					this._pWebGLContext.disable( 0x0B90 );
				}
			}

			if(pRestoreStates.STENCIL_CLEAR_VALUE !== pStatesFrom.STENCIL_CLEAR_VALUE){
				this._pWebGLContext.clearStencil(pRestoreStates.STENCIL_CLEAR_VALUE)
			}

			if (pRestoreStates.STENCIL_FUNC !== pStatesFrom.STENCIL_FUNC ||
				pRestoreStates.STENCIL_REF !== pStatesFrom.STENCIL_REF ||
				pRestoreStates.STENCIL_VALUE_MASK !== pStatesFrom.STENCIL_VALUE_MASK ||
				pRestoreStates.STENCIL_BACK_FUNC !== pStatesFrom.STENCIL_BACK_FUNC ||
				pRestoreStates.STENCIL_BACK_REF !== pStatesFrom.STENCIL_BACK_REF ||
				pRestoreStates.STENCIL_BACK_VALUE_MASK !== pStatesFrom.STENCIL_BACK_VALUE_MASK) {

				if (pRestoreStates.STENCIL_FUNC === pRestoreStates.STENCIL_BACK_FUNC ||
					pRestoreStates.STENCIL_REF === pRestoreStates.STENCIL_BACK_REF ||
					pRestoreStates.STENCIL_VALUE_MASK === pRestoreStates.STENCIL_BACK_VALUE_MASK) {

					this._pWebGLContext.stencilFunc(pRestoreStates.STENCIL_FUNC, pRestoreStates.STENCIL_REF, pRestoreStates.STENCIL_VALUE_MASK);
				}
				else {
					this._pWebGLContext.stencilFuncSeparate( 0x0404 ,
							pRestoreStates.STENCIL_FUNC, pRestoreStates.STENCIL_REF, pRestoreStates.STENCIL_VALUE_MASK);

					this._pWebGLContext.stencilFuncSeparate( 0x0405 ,
							pRestoreStates.STENCIL_BACK_FUNC, pRestoreStates.STENCIL_BACK_REF, pRestoreStates.STENCIL_BACK_VALUE_MASK);
				}
			}

			if (pRestoreStates.STENCIL_WRITEMASK !== pStatesFrom.STENCIL_WRITEMASK ||
				pRestoreStates.STENCIL_BACK_WRITEMASK !== pStatesFrom.STENCIL_BACK_WRITEMASK){

				if(pRestoreStates.STENCIL_WRITEMASK === pRestoreStates.STENCIL_BACK_WRITEMASK){
					this._pWebGLContext.stencilMask(pRestoreStates.STENCIL_WRITEMASK);
				}
				else {
					this._pWebGLContext.stencilMaskSeparate( 0x0404 , pRestoreStates.STENCIL_WRITEMASK);
					this._pWebGLContext.stencilMaskSeparate( 0x0405 , pRestoreStates.STENCIL_WRITEMASK);
				}
			}

			if (pRestoreStates.STENCIL_FAIL !== pStatesFrom.STENCIL_FAIL ||
				pRestoreStates.STENCIL_PASS_DEPTH_FAIL !== pStatesFrom.STENCIL_PASS_DEPTH_FAIL ||
				pRestoreStates.STENCIL_PASS_DEPTH_PASS !== pStatesFrom.STENCIL_PASS_DEPTH_PASS ||
				pRestoreStates.STENCIL_BACK_FAIL !== pStatesFrom.STENCIL_BACK_FAIL ||
				pRestoreStates.STENCIL_BACK_PASS_DEPTH_FAIL !== pStatesFrom.STENCIL_BACK_PASS_DEPTH_FAIL ||
				pRestoreStates.STENCIL_BACK_PASS_DEPTH_PASS !== pStatesFrom.STENCIL_BACK_PASS_DEPTH_PASS) {

				if (pRestoreStates.STENCIL_FAIL === pRestoreStates.STENCIL_BACK_FAIL ||
					pRestoreStates.STENCIL_PASS_DEPTH_FAIL === pRestoreStates.STENCIL_BACK_PASS_DEPTH_FAIL ||
					pRestoreStates.STENCIL_PASS_DEPTH_PASS === pRestoreStates.STENCIL_BACK_PASS_DEPTH_PASS) {

					this._pWebGLContext.stencilOp(pRestoreStates.STENCIL_FAIL, pRestoreStates.STENCIL_PASS_DEPTH_FAIL, pRestoreStates.STENCIL_PASS_DEPTH_PASS);
				}
				else {
					this._pWebGLContext.stencilOpSeparate( 0x0404 ,
							pRestoreStates.STENCIL_FAIL, pRestoreStates.STENCIL_PASS_DEPTH_FAIL, pRestoreStates.STENCIL_PASS_DEPTH_PASS);

					this._pWebGLContext.stencilOpSeparate( 0x0405 ,
							pRestoreStates.STENCIL_BACK_FAIL, pRestoreStates.STENCIL_BACK_PASS_DEPTH_FAIL, pRestoreStates.STENCIL_BACK_PASS_DEPTH_PASS);
				}
			}

		}

		private restorePackStates(pStatesFrom: IWebGLContextStates): void {
			var pRestoreStates: IWebGLContextStates = this._pCurrentContextStates;

			if(pRestoreStates.UNPACK_ALIGNMENT !== pStatesFrom.UNPACK_ALIGNMENT){
				this._pWebGLContext.pixelStorei( 0x0CF5 , pRestoreStates.UNPACK_ALIGNMENT);
			}

			if(pRestoreStates.PACK_ALIGNMENT !== pStatesFrom.PACK_ALIGNMENT){
				this._pWebGLContext.pixelStorei( 0x0D05 , pRestoreStates.PACK_ALIGNMENT);
			}
		}

		private  /**@inline*/  forceUpdateContextRenderStates(): void {
			WebGLRenderer.initStatesFromWebGLContext(this._pCurrentContextStates, this._pWebGLContext);
		}

		private getFreeRenderStates(): IWebGLContextStates {
			if(this._pFreeRenderStatesPool.length > 0){
				return this._pFreeRenderStatesPool.pop();
			}
			else {
				return WebGLRenderer.createWebGLContextStates();
			}
		}

		private applyInputRenderStates(pStates: IRenderStateMap): bool {
			var isStatesChanged: bool = false;
			var iWebGLValue:  number  = 0;

			if (pStates[ERenderStates.BLENDENABLE] !== ERenderStateValues.UNDEF){

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.BLENDENABLE]);
				if(this._pCurrentContextStates.BLEND !== !!iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.BLEND = !!iWebGLValue;

					if(this._pCurrentContextStates.BLEND){
						this._pWebGLContext.enable( 0x0BE2 );
					}
					else {
						this._pWebGLContext.disable( 0x0BE2 );
					}
				}

			}

			if (pStates[ERenderStates.CULLFACEENABLE] !== ERenderStateValues.UNDEF){

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.CULLFACEENABLE]);
				if(this._pCurrentContextStates.CULL_FACE !== !!iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.CULL_FACE = !!iWebGLValue;

					if(this._pCurrentContextStates.CULL_FACE){
						this._pWebGLContext.enable( 0x0B44 );
					}
					else {
						this._pWebGLContext.disable( 0x0B44 );
					}
				}
			}

			if (pStates[ERenderStates.ZENABLE] !== ERenderStateValues.UNDEF){

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.ZENABLE]);
				if(this._pCurrentContextStates.DEPTH_TEST !== !!iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.DEPTH_TEST = !!iWebGLValue;

					if(this._pCurrentContextStates.DEPTH_TEST){
						this._pWebGLContext.enable( 0x0B71 );
					}
					else {
						this._pWebGLContext.disable( 0x0B71 );
					}
				}
			}

			if (pStates[ERenderStates.DITHERENABLE] !== ERenderStateValues.UNDEF){

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.DITHERENABLE]);
				if(this._pCurrentContextStates.DITHER !== !!iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.DITHER = !!iWebGLValue;

					if(this._pCurrentContextStates.DITHER){
						this._pWebGLContext.enable( 0x0BD0 );
					}
					else {
						this._pWebGLContext.disable( 0x0BD0 );
					}
				}
			}

			if (pStates[ERenderStates.ZWRITEENABLE] !== ERenderStateValues.UNDEF){

				!isStatesChanged && this._pushRenderStates();
				isStatesChanged = true;
				this._pCurrentContextStates.DEPTH_WRITEMASK = this.convertRenderStateValue(pStates[ERenderStates.ZWRITEENABLE]);

				this._pWebGLContext.depthMask(this._pCurrentContextStates.DEPTH_WRITEMASK);
			}

			if (pStates[ERenderStates.SCISSORTESTENABLE] !== ERenderStateValues.UNDEF){

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.SCISSORTESTENABLE]);
				if(this._pCurrentContextStates.SCISSOR_TEST !== !!iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.SCISSOR_TEST = !!iWebGLValue;

					if(this._pCurrentContextStates.SCISSOR_TEST){
						this._pWebGLContext.enable( 0x0C11 );
					}
					else {
						this._pWebGLContext.disable( 0x0C11 );
					}
				}
			}

			if (pStates[ERenderStates.STENCILTESTENABLE] !== ERenderStateValues.UNDEF){

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.STENCILTESTENABLE]);
				if(this._pCurrentContextStates.STENCIL_TEST !== !!iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.STENCIL_TEST = !!iWebGLValue;

					if(this._pCurrentContextStates.STENCIL_TEST){
						this._pWebGLContext.enable( 0x0B90 );
					}
					else {
						this._pWebGLContext.disable( 0x0B90 );
					}
				}
			}

			if (pStates[ERenderStates.POLYGONOFFSETFILLENABLE] !== ERenderStateValues.UNDEF){

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.POLYGONOFFSETFILLENABLE]);
				if(this._pCurrentContextStates.POLYGON_OFFSET_FILL !== !!iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.POLYGON_OFFSET_FILL = !!iWebGLValue;

					if(this._pCurrentContextStates.POLYGON_OFFSET_FILL){
						this._pWebGLContext.enable( 0x8037 );
					}
					else {
						this._pWebGLContext.disable( 0x8037 );
					}
				}
			}

			if(pStates[ERenderStates.CULLFACE] !== ERenderStateValues.UNDEF) {

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.CULLFACE]);
				if(this._pCurrentContextStates.CULL_FACE_MODE !== iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.CULL_FACE_MODE = iWebGLValue;

					this._pWebGLContext.cullFace(this._pCurrentContextStates.CULL_FACE_MODE);
				}
			}

			if(pStates[ERenderStates.FRONTFACE] !== ERenderStateValues.UNDEF) {

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.FRONTFACE]);
				if(this._pCurrentContextStates.FRONT_FACE !== iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.FRONT_FACE = iWebGLValue;

					this._pWebGLContext.frontFace(this._pCurrentContextStates.FRONT_FACE);
				}
			}

			if(pStates[ERenderStates.ZFUNC] !== ERenderStateValues.UNDEF) {

				iWebGLValue = this.convertRenderStateValue(pStates[ERenderStates.ZFUNC]);
				if(this._pCurrentContextStates.DEPTH_FUNC !== iWebGLValue){

					!isStatesChanged && this._pushRenderStates();
					isStatesChanged = true;
					this._pCurrentContextStates.DEPTH_FUNC = iWebGLValue;

					this._pWebGLContext.depthFunc(this._pCurrentContextStates.DEPTH_FUNC);
				}
			}

			if (pStates[ERenderStates.SRCBLEND] !== ERenderStateValues.UNDEF ||
				pStates[ERenderStates.DESTBLEND] !== ERenderStateValues.UNDEF) {

				var iWebGLValue1:  number  = this.convertRenderStateValue(pStates[ERenderStates.SRCBLEND]);
				var iWebGLValue2:  number  = this.convertRenderStateValue(pStates[ERenderStates.DESTBLEND]);

				!isStatesChanged && this._pushRenderStates();
				isStatesChanged = true;

				this._pCurrentContextStates.BLEND_SRC_RGB = iWebGLValue1;
				this._pCurrentContextStates.BLEND_SRC_ALPHA = iWebGLValue1;
				this._pCurrentContextStates.BLEND_DST_RGB = iWebGLValue2;
				this._pCurrentContextStates.BLEND_DST_ALPHA = iWebGLValue2;

				this._pWebGLContext.blendFunc(iWebGLValue1, iWebGLValue2);
			}

			return isStatesChanged;
		}

		private convertRenderStateValue(eStateValue: ERenderStateValues): any {
			switch(eStateValue){
        		case ERenderStateValues.TRUE:
        			return 1;
        		case ERenderStateValues.FALSE:
        			return 0;
        		case ERenderStateValues.ZERO:
        			return  0 ;
        		case ERenderStateValues.ONE:
        			return  1 ;
        		case ERenderStateValues.SRCCOLOR:
        			return  0x0300 ;
        		case ERenderStateValues.INVSRCCOLOR:
        			return  0x0301 ;
        		case ERenderStateValues.SRCALPHA:
        			return  0x0302 ;
        		case ERenderStateValues.INVSRCALPHA:
        			return  0x0303 ;
        		case ERenderStateValues.DESTALPHA:
        			return  0x0304 ;
        		case ERenderStateValues.INVDESTALPHA:
        			return  0x0305 ;
        		case ERenderStateValues.DESTCOLOR:
        			return  0x0306 ;
        		case ERenderStateValues.INVDESTCOLOR:
        			return  0x0307 ;
        		case ERenderStateValues.SRCALPHASAT:
        			return  0x0308 ;
        		case ERenderStateValues.NONE:
        			return  0 ;
        		case ERenderStateValues.CW:
        			return  0x0900 ;
        		case ERenderStateValues.CCW:
        			return  0x0901 ;
        		case ERenderStateValues.FRONT:
        			return  0x0404 ;
        		case ERenderStateValues.BACK:
        			return  0x0405 ;
        		case ERenderStateValues.FRONT_AND_BACK:
        			return  0x0408 ;
        		case ERenderStateValues.NEVER:
        			return  0x0200 ;
        		case ERenderStateValues.LESS:
        			return  0x0201 ;
        		case ERenderStateValues.EQUAL:
        			return  0x0202 ;
        		case ERenderStateValues.LESSEQUAL:
        			return  0x0203 ;
        		case ERenderStateValues.GREATER:
        			return  0x0204 ;
        		case ERenderStateValues.NOTEQUAL:
        			return  0x0205 ;
        		case ERenderStateValues.GREATEREQUAL:
        			return  0x0206 ;
        		case ERenderStateValues.ALWAYS:
        			return  0x0207 ;
			}
		}

		private convertCompareFunction(eFunc: ECompareFunction):  number  {
	        switch(eFunc) {
	            case ECompareFunction.ALWAYS_FAIL:
	                return  0x0200 ;
	            case ECompareFunction.ALWAYS_PASS:
	                return  0x0207 ;
	            case ECompareFunction.LESS:
	                return  0x0201 ;
	            case ECompareFunction.LESS_EQUAL:
	                return  0x0203 ;
	            case ECompareFunction.EQUAL:
	                return  0x0202 ;
	            case ECompareFunction.NOT_EQUAL:
	                return  0x0205 ;
	            case ECompareFunction.GREATER_EQUAL:
	                return  0x0206 ;
	            case ECompareFunction.GREATER:
	                return  0x0204 ;
	        }

	        return  0x0207 ;
    	}


    	static createWebGLContextStates(pStates?: IWebGLContextStates = null): IWebGLContextStates {
			return {
				BLEND: isNull(pStates) ? false : pStates.BLEND,
				BLEND_COLOR: isNull(pStates) ? new Float32Array(4) : new Float32Array(pStates.BLEND_COLOR),
				BLEND_DST_ALPHA: isNull(pStates) ? 0 : pStates.BLEND_DST_ALPHA,
				BLEND_DST_RGB: isNull(pStates) ? 0 : pStates.BLEND_DST_RGB,
				BLEND_EQUATION_ALPHA: isNull(pStates) ? 0 : pStates.BLEND_EQUATION_ALPHA,
				BLEND_EQUATION_RGB: isNull(pStates) ? 0 : pStates.BLEND_EQUATION_RGB,
				BLEND_SRC_ALPHA: isNull(pStates) ? 0 : pStates.BLEND_SRC_ALPHA,
				BLEND_SRC_RGB: isNull(pStates) ? 0 : pStates.BLEND_SRC_RGB,

				COLOR_CLEAR_VALUE: isNull(pStates) ? new Float32Array(4) : new Float32Array(pStates.COLOR_CLEAR_VALUE),
				COLOR_WRITEMASK: isNull(pStates) ? [false, false, false, false] : pStates.COLOR_WRITEMASK.slice(0),

				CULL_FACE: isNull(pStates) ? false : pStates.CULL_FACE,
				CULL_FACE_MODE: isNull(pStates) ? 0 : pStates.CULL_FACE_MODE,

				DEPTH_CLEAR_VALUE: isNull(pStates) ? 0. : pStates.DEPTH_CLEAR_VALUE,
				DEPTH_FUNC: isNull(pStates) ? 0 : pStates.DEPTH_FUNC,
				DEPTH_RANGE: isNull(pStates) ? new Float32Array(2) : new Float32Array(pStates.DEPTH_RANGE),
				DEPTH_TEST: isNull(pStates) ? false : pStates.DEPTH_TEST,
				DEPTH_WRITEMASK: isNull(pStates) ? false : pStates.DEPTH_WRITEMASK,
				DITHER: isNull(pStates) ? false : pStates.DITHER,

				FRONT_FACE: isNull(pStates) ? 0 : pStates.FRONT_FACE,
				LINE_WIDTH: isNull(pStates) ? 0. : pStates.LINE_WIDTH,

				POLYGON_OFFSET_FACTOR: isNull(pStates) ? 0. : pStates.POLYGON_OFFSET_FACTOR,
				POLYGON_OFFSET_FILL: isNull(pStates) ? false : pStates.POLYGON_OFFSET_FILL,
				POLYGON_OFFSET_UNITS: isNull(pStates) ? 0. : pStates.POLYGON_OFFSET_UNITS,

				SAMPLE_BUFFERS: isNull(pStates) ? 0 : pStates.SAMPLE_BUFFERS,
				SAMPLE_COVERAGE_INVERT: isNull(pStates) ? false : pStates.SAMPLE_COVERAGE_INVERT,
				SAMPLE_COVERAGE_VALUE: isNull(pStates) ? 0. : pStates.SAMPLE_COVERAGE_VALUE,
				SAMPLES: isNull(pStates) ? 0 : pStates.SAMPLES,

				SCISSOR_TEST: isNull(pStates) ? false : pStates.SCISSOR_TEST,

				STENCIL_BACK_FAIL: isNull(pStates) ? 0 : pStates.STENCIL_BACK_FAIL,
				STENCIL_BACK_FUNC: isNull(pStates) ? 0 : pStates.STENCIL_BACK_FUNC,
				STENCIL_BACK_PASS_DEPTH_FAIL: isNull(pStates) ? 0 : pStates.STENCIL_BACK_PASS_DEPTH_FAIL,
				STENCIL_BACK_PASS_DEPTH_PASS: isNull(pStates) ? 0 : pStates.STENCIL_BACK_PASS_DEPTH_PASS,
				STENCIL_BACK_REF: isNull(pStates) ? 0 : pStates.STENCIL_BACK_REF,
				STENCIL_BACK_VALUE_MASK: isNull(pStates) ? 0 : pStates.STENCIL_BACK_VALUE_MASK,
				STENCIL_BACK_WRITEMASK: isNull(pStates) ? 0 : pStates.STENCIL_BACK_WRITEMASK,
				STENCIL_CLEAR_VALUE: isNull(pStates) ? 0 : pStates.STENCIL_CLEAR_VALUE,
				STENCIL_FAIL: isNull(pStates) ? 0 : pStates.STENCIL_FAIL,
				STENCIL_FUNC: isNull(pStates) ? 0 : pStates.STENCIL_FUNC,
				STENCIL_PASS_DEPTH_FAIL: isNull(pStates) ? 0 : pStates.STENCIL_PASS_DEPTH_FAIL,
				STENCIL_PASS_DEPTH_PASS: isNull(pStates) ? 0 : pStates.STENCIL_PASS_DEPTH_PASS,
				STENCIL_REF: isNull(pStates) ? 0 : pStates.STENCIL_REF,
				STENCIL_TEST: isNull(pStates) ? false : pStates.STENCIL_TEST,
				STENCIL_VALUE_MASK: isNull(pStates) ? 0 : pStates.STENCIL_VALUE_MASK,
				STENCIL_WRITEMASK: isNull(pStates) ? 0 : pStates.STENCIL_WRITEMASK,
				PACK_ALIGNMENT: isNull(pStates) ? 0 : pStates.PACK_ALIGNMENT,
				UNPACK_ALIGNMENT: isNull(pStates) ? 0 : pStates.UNPACK_ALIGNMENT
			};
		}

		static copyWebGLContextStates(pStatesTo: IWebGLContextStates, pStatesFrom: IWebGLContextStates): IWebGLContextStates {
			pStatesTo.BLEND = pStatesFrom.BLEND;
			pStatesTo.BLEND_COLOR.set(pStatesFrom.BLEND_COLOR);
			pStatesTo.BLEND_DST_ALPHA = pStatesFrom.BLEND_DST_ALPHA;
			pStatesTo.BLEND_DST_RGB = pStatesFrom.BLEND_DST_RGB;
			pStatesTo.BLEND_EQUATION_ALPHA = pStatesFrom.BLEND_EQUATION_ALPHA;
			pStatesTo.BLEND_EQUATION_RGB = pStatesFrom.BLEND_EQUATION_RGB;
			pStatesTo.BLEND_SRC_ALPHA = pStatesFrom.BLEND_SRC_ALPHA;
			pStatesTo.BLEND_SRC_RGB = pStatesFrom.BLEND_SRC_RGB;

			pStatesTo.COLOR_CLEAR_VALUE.set(pStatesFrom.COLOR_CLEAR_VALUE);
			pStatesTo.COLOR_WRITEMASK[0] = pStatesFrom.COLOR_WRITEMASK[0];
			pStatesTo.COLOR_WRITEMASK[1] = pStatesFrom.COLOR_WRITEMASK[1];
			pStatesTo.COLOR_WRITEMASK[2] = pStatesFrom.COLOR_WRITEMASK[2];
			pStatesTo.COLOR_WRITEMASK[3] = pStatesFrom.COLOR_WRITEMASK[3];

			pStatesTo.CULL_FACE = pStatesFrom.CULL_FACE;
			pStatesTo.CULL_FACE_MODE = pStatesFrom.CULL_FACE_MODE;

			pStatesTo.DEPTH_CLEAR_VALUE = pStatesFrom.DEPTH_CLEAR_VALUE;
			pStatesTo.DEPTH_FUNC = pStatesFrom.DEPTH_FUNC;
			pStatesTo.DEPTH_RANGE.set(pStatesFrom.DEPTH_RANGE);
			pStatesTo.DEPTH_TEST = pStatesFrom.DEPTH_TEST;
			pStatesTo.DEPTH_WRITEMASK = pStatesFrom.DEPTH_WRITEMASK;
			pStatesTo.DITHER = pStatesFrom.DITHER;

			pStatesTo.FRONT_FACE = pStatesFrom.FRONT_FACE;
			pStatesTo.LINE_WIDTH = pStatesFrom.LINE_WIDTH;

			pStatesTo.POLYGON_OFFSET_FACTOR = pStatesFrom.POLYGON_OFFSET_FACTOR;
			pStatesTo.POLYGON_OFFSET_FILL = pStatesFrom.POLYGON_OFFSET_FILL;
			pStatesTo.POLYGON_OFFSET_UNITS = pStatesFrom.POLYGON_OFFSET_UNITS;

			pStatesTo.SAMPLE_BUFFERS = pStatesFrom.SAMPLE_BUFFERS;
			pStatesTo.SAMPLE_COVERAGE_INVERT = pStatesFrom.SAMPLE_COVERAGE_INVERT;
			pStatesTo.SAMPLE_COVERAGE_VALUE = pStatesFrom.SAMPLE_COVERAGE_VALUE;
			pStatesTo.SAMPLES = pStatesFrom.SAMPLES;

			pStatesTo.SCISSOR_TEST = pStatesFrom.SCISSOR_TEST;

			pStatesTo.STENCIL_BACK_FAIL = pStatesFrom.STENCIL_BACK_FAIL;
			pStatesTo.STENCIL_BACK_FUNC = pStatesFrom.STENCIL_BACK_FUNC;
			pStatesTo.STENCIL_BACK_PASS_DEPTH_FAIL = pStatesFrom.STENCIL_BACK_PASS_DEPTH_FAIL;
			pStatesTo.STENCIL_BACK_PASS_DEPTH_PASS = pStatesFrom.STENCIL_BACK_PASS_DEPTH_PASS;
			pStatesTo.STENCIL_BACK_REF = pStatesFrom.STENCIL_BACK_REF;
			pStatesTo.STENCIL_BACK_VALUE_MASK = pStatesFrom.STENCIL_BACK_VALUE_MASK;
			pStatesTo.STENCIL_BACK_WRITEMASK = pStatesFrom.STENCIL_BACK_WRITEMASK;
			pStatesTo.STENCIL_CLEAR_VALUE = pStatesFrom.STENCIL_CLEAR_VALUE;
			pStatesTo.STENCIL_FAIL = pStatesFrom.STENCIL_FAIL;
			pStatesTo.STENCIL_FUNC = pStatesFrom.STENCIL_FUNC;
			pStatesTo.STENCIL_PASS_DEPTH_FAIL = pStatesFrom.STENCIL_PASS_DEPTH_FAIL;
			pStatesTo.STENCIL_PASS_DEPTH_PASS = pStatesFrom.STENCIL_PASS_DEPTH_PASS;
			pStatesTo.STENCIL_REF = pStatesFrom.STENCIL_REF;
			pStatesTo.STENCIL_TEST = pStatesFrom.STENCIL_TEST;
			pStatesTo.STENCIL_VALUE_MASK = pStatesFrom.STENCIL_VALUE_MASK;
			pStatesTo.STENCIL_WRITEMASK = pStatesFrom.STENCIL_WRITEMASK;


			pStatesTo.PACK_ALIGNMENT = pStatesFrom.PACK_ALIGNMENT;
			pStatesTo.UNPACK_ALIGNMENT = pStatesFrom.UNPACK_ALIGNMENT;

			return pStatesTo;
		}

		static initStatesFromWebGLContext(pStatesTo: IWebGLContextStates, pWebGLContext: WebGLRenderingContext): IWebGLContextStates {
			pStatesTo.BLEND = pWebGLContext.getParameter( 0x0BE2 );
			pStatesTo.BLEND_COLOR = pWebGLContext.getParameter( 0x8005 );
			pStatesTo.BLEND_DST_ALPHA = pWebGLContext.getParameter( 0x80CA );
			pStatesTo.BLEND_DST_RGB = pWebGLContext.getParameter( 0x80C8 );
			pStatesTo.BLEND_EQUATION_ALPHA = pWebGLContext.getParameter( 0x883D );
			pStatesTo.BLEND_EQUATION_RGB = pWebGLContext.getParameter( 0x8009 );
			pStatesTo.BLEND_SRC_ALPHA = pWebGLContext.getParameter( 0x80CB );
			pStatesTo.BLEND_SRC_RGB = pWebGLContext.getParameter( 0x80C9 );

			pStatesTo.COLOR_CLEAR_VALUE = pWebGLContext.getParameter( 0x0C22 );
			pStatesTo.COLOR_WRITEMASK = pWebGLContext.getParameter( 0x0C23 );

			pStatesTo.CULL_FACE = pWebGLContext.getParameter( 0x0B44 );
			pStatesTo.CULL_FACE_MODE = pWebGLContext.getParameter( 0x0B45 );

			pStatesTo.DEPTH_CLEAR_VALUE = pWebGLContext.getParameter( 0x0B73 );
			pStatesTo.DEPTH_FUNC = pWebGLContext.getParameter( 0x0B74 );
			pStatesTo.DEPTH_RANGE = pWebGLContext.getParameter( 0x0B70 );
			pStatesTo.DEPTH_TEST = pWebGLContext.getParameter( 0x0B71 );
			pStatesTo.DEPTH_WRITEMASK = pWebGLContext.getParameter( 0x0B72 );
			pStatesTo.DITHER = pWebGLContext.getParameter( 0x0BD0 );

			pStatesTo.FRONT_FACE = pWebGLContext.getParameter( 0x0B46 );
			pStatesTo.LINE_WIDTH = pWebGLContext.getParameter( 0x0B21 );

			pStatesTo.POLYGON_OFFSET_FACTOR = pWebGLContext.getParameter( 0x8038 );
			pStatesTo.POLYGON_OFFSET_FILL = pWebGLContext.getParameter( 0x8037 );
			pStatesTo.POLYGON_OFFSET_UNITS = pWebGLContext.getParameter( 0x2A00 );

			pStatesTo.SAMPLE_BUFFERS = pWebGLContext.getParameter( 0x80A8 );
			pStatesTo.SAMPLE_COVERAGE_INVERT = pWebGLContext.getParameter( 0x80AB );
			pStatesTo.SAMPLE_COVERAGE_VALUE = pWebGLContext.getParameter( 0x80AA );
			pStatesTo.SAMPLES = pWebGLContext.getParameter( 0x80A9 );

			pStatesTo.SCISSOR_TEST = pWebGLContext.getParameter( 0x0C11 );

			pStatesTo.STENCIL_BACK_FAIL = pWebGLContext.getParameter( 0x8801 );
			pStatesTo.STENCIL_BACK_FUNC = pWebGLContext.getParameter( 0x8800 );
			pStatesTo.STENCIL_BACK_PASS_DEPTH_FAIL = pWebGLContext.getParameter( 0x8802 );
			pStatesTo.STENCIL_BACK_PASS_DEPTH_PASS = pWebGLContext.getParameter( 0x8803 );
			pStatesTo.STENCIL_BACK_REF = pWebGLContext.getParameter( 0x8CA3 );
			pStatesTo.STENCIL_BACK_VALUE_MASK = pWebGLContext.getParameter( 0x8CA4 );
			pStatesTo.STENCIL_BACK_WRITEMASK = pWebGLContext.getParameter( 0x8CA5 );
			pStatesTo.STENCIL_CLEAR_VALUE = pWebGLContext.getParameter( 0x0B91 );
			pStatesTo.STENCIL_FAIL = pWebGLContext.getParameter( 0x0B94 );
			pStatesTo.STENCIL_FUNC = pWebGLContext.getParameter( 0x0B92 );
			pStatesTo.STENCIL_PASS_DEPTH_FAIL = pWebGLContext.getParameter( 0x0B95 );
			pStatesTo.STENCIL_PASS_DEPTH_PASS = pWebGLContext.getParameter( 0x0B96 );
			pStatesTo.STENCIL_REF = pWebGLContext.getParameter( 0x0B97 );
			pStatesTo.STENCIL_TEST = pWebGLContext.getParameter( 0x0B90 );
			pStatesTo.STENCIL_VALUE_MASK = pWebGLContext.getParameter( 0x0B93 );
			pStatesTo.STENCIL_WRITEMASK = pWebGLContext.getParameter( 0x0B98 );

			pStatesTo.PACK_ALIGNMENT = pWebGLContext.getParameter( 0x0D05 );
			pStatesTo.UNPACK_ALIGNMENT = pWebGLContext.getParameter( 0x0CF5 );

			return pStatesTo;
		}
	}
}











module akra.webgl {

	var SQUARE_VERTICES: Float32Array = new Float32Array([ -1.0, -1.0,
									                		1.0, -1.0,
									               		   -1.0,  1.0,
									                		1.0,  1.0 ]);
	var TEXCOORDS: Float32Array = new Float32Array(12);

	export function computeLog(iValue:  number ):  number  {
	    var i:  number  = 0;
/* Error! */

	    if (iValue === 0) return -1;

	    for (;;) {
	        if (iValue & 1) {
/* Error! */

	            if (iValue !== 1) return -1;
	                return i;
	        }
	        iValue = iValue >> 1;
	        i++;
	    }
	}

	export class WebGLTextureBuffer extends WebGLPixelBuffer implements IPixelBuffer {
		protected _eTarget:  number  = null;
		protected _eFaceTarget:  number  = null;
		protected _pWebGLTexture: WebGLTexture = null;
		protected _iFace:  number  = 0;
		protected _iLevel:  number  = 0;
		protected _bSoftwareMipmap: bool = false;
		protected _pRTTList: IRenderTexture[] = null;

		constructor () {
			super();
		}

		_clearRTT(iZOffset:  number ): void {
			this._pRTTList[iZOffset] = null;
		}

		reset(): void;
        reset(iSize:  number ): void;
        reset(iWidth:  number , iHeight:  number ): void;
        reset(iWidth?:  number  = this._iWidth, iHeight?:  number  = iWidth): void {
//TODO: check format
			iWidth = math.ceilingPowerOfTwo(iWidth);
			iHeight = math.ceilingPowerOfTwo(iHeight);

			this._iWidth = this._iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, this._iLevel);
			this._iHeight = this._iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, this._iLevel);

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();


//pWebGLRenderer.debug(true, true);

			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

			pWebGLContext.texImage2D(this._eFaceTarget,
                        			 this._iLevel,
                        			 getClosestWebGLInternalFormat(getSupportedAlternative(this._eFormat)),
                        			 this._iWidth, this._iHeight, 0,
                        			 getWebGLFormat(this._eFormat), getWebGLDataType(this._eFormat),
                        			 null);

			this._iByteSize = pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
			this._pBuffer.setPosition(0, 0, this._iWidth, this._iHeight, 0, this._iDepth);

			pWebGLRenderer.bindWebGLTexture(this._eTarget, null);

			this.notifyResized();

//pWebGLRenderer.debug(false, false);
		}

		private notifyResized(): void {
			if (!isNull(this._pRTTList)) {
				for (var i:  number  = 0; i < this._pRTTList.length; ++ i) {
					var pRTT: IRenderTexture = this._pRTTList[i];
					pRTT.resized(pRTT.width, pRTT.height);
				}
			}
		}

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(eTarget:  number , pTexture: WebGLTexture, iWidth:  number , iHeight:  number , iInternalFormat:  number , iFormat:  number ,
			   iFace:  number , iLevel:  number , iFlags:  number , bSoftwareMipmap: bool): bool;
		create(): bool {
			if(arguments.length < 6) {
				{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 105 ); logger.criticalError("Invalid number of params. For WebGLTextureBuffer"); } ;
			}

			var eTarget:  number  = arguments[0];
			var pTexture: WebGLTexture = arguments[1];
			var iWidth:  number  = arguments[2];
			var iHeight:  number  = arguments[3];
			var iInternalFormat:  number  = arguments[4];
			var iFormat:  number  = arguments[5];
			var iFace:  number  = arguments[6];
			var iLevel:  number  = arguments[7];
			var iFlags:  number  = arguments[8];
			var bSoftwareMipmap: bool = arguments[9];

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();

			pWebGLRenderer.bindWebGLTexture(eTarget, pTexture);

			this._eTarget = eTarget;
			this._pWebGLTexture = pTexture;
			this._iFace = iFace;
			this._iLevel = iLevel;
			this._iFlags = iFlags;
			this._bSoftwareMipmap = bSoftwareMipmap;

			this._eFaceTarget = eTarget;

			if(eTarget ===  0x8513 ){
				this._eFaceTarget =  0x8515  + iFace;
			}

			this._iWidth = iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, iLevel);
			this._iHeight = iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, iLevel);
			this._iDepth = 1;

			this._iWebGLInternalFormat = iInternalFormat;
			this._eFormat = getClosestAkraFormat(iInternalFormat, iFormat);

			this._iRowPitch = this._iWidth;
			this._iSlicePitch = this._iHeight * this._iWidth;
			this._iByteSize = pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

			this._pBuffer = new pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

			if(this._iWidth === 0 || this._iHeight === 0 || this._iDepth === 0){
// We are invalid, do not allocate a buffer
				return false;
			}

// Is this a render target?
	        if ( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ) {
// Create render target for each slice
	            this._pRTTList = new WebGLRenderTexture[];
	            for(var iZOffset:  number  = 0; iZOffset < this._iDepth; ++iZOffset) {
	                var pRenderTexture: WebGLRenderTexture = new WebGLRenderTexture(pWebGLRenderer, this);
	                this._pRTTList.push(pRenderTexture);
	                pWebGLRenderer.attachRenderTarget(pRenderTexture);
	            }
	        }

	        var pProgram: IShaderProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_blit_texture_buffer");
	        var sFloatToVec4Func: string = "	        	vec4 floatToVec4(float value){						\n					float data = value;								\n					vec4 result = vec4(0.);							\n																	\n					if(data == 0.){									\n						float signedZeroTest = 1./value;			\n						if(signedZeroTest < 0.){					\n							result.x = 128.;						\n						}											\n						return result/255.;							\n					}												\n																	\n					if(data < 0.){									\n						result.x=128.;								\n						data = -data;								\n					}												\n																	\n					float power = 0.;								\n					bool isFinish = false;							\n					for(int i=0;i<128;i++){							\n						if(isFinish){								\n							break;									\n						}											\n																	\n						if(data >= 2.) {							\n							if(!isFinish){							\n								data = data * 0.5;					\n								power += 1.;						\n								if (power == 127.) {				\n									isFinish = true;				\n								}									\n							}										\n						}											\n						else if(data < 1.) {						\n							if(!isFinish){							\n								data = data * 2.;					\n								power -= 1.;						\n								if (power == -126.) {				\n									isFinish = true;				\n								}									\n							}										\n						}											\n						else {										\n							isFinish = true;						\n						}											\n					}												\n																	\n					if(power == -126. && data < 1.){				\n						power = 0.;									\n					}												\n					else{											\n						power = power+127.;							\n						data = data - 1.;							\n					}												\n																	\n					result.x+=floor(power/2.);						\n					result.y = mod(power,2.)*128.;					\n																	\n					data *= 128.;									\n																	\n					result.y += floor(data);						\n																	\n					data -= floor(data);							\n					data *= 256.;									\n																	\n					result.z = floor(data);							\n																	\n					data -= floor(data);							\n					data *= 256.;									\n																	\n					result.w = floor(data);							\n																	\n					return result/255.;								\n				}													\n";

	        if(isNull(pProgram)){
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_blit_texture_buffer");
	        	pProgram.create(
	        	"																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				}																									\n				",
				"													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;        					\n																	\n				void main(void) {  									\n					vec4 color;										\n					color = texture2D(uSampler, texcoord.xy);      	\n				    gl_FragColor = color;           				\n				}                                   				\n				");
	        }

	        pProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_decode_depth32_texture");

	        if (isNull(pProgram)) {
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_decode_depth32_texture");
	        	pProgram.create("																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				}																									\n				",
				"													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;        					\n																	\n				" + sFloatToVec4Func + "																	\n				void main(void) {  									\n					vec4 color;										\n					color = texture2D(uSampler, vec2(texcoord.x, 1. - texcoord.y));      	\n					vec4 t = floatToVec4(color.r);					\n				    gl_FragColor = vec4(t.a, t.b, t.g, t.r);		\n				}                                   				\n				");
	        }

	        pProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_decode_float32_texture");

	        if (isNull(pProgram)) {
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_decode_float32_texture");
	        	pProgram.create("																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				varying vec2 dest_texcoord;																			\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				    dest_texcoord.xy = (POSITION.xy + 1.  ) /2.;													\n				}																									\n				",
				"													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n																	\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;							\n				uniform int dst_width;        						\n				uniform int dst_height;        						\n				uniform int src_components_num;						\n				varying vec2 dest_texcoord;							\n				" + sFloatToVec4Func + "																	\n				void main(void) {  									\n																	\n					float pixel = dest_texcoord.x * float(dst_width);	\n					float value;									\n					int comp = int(mod(pixel, float(src_components_num)));	\n					vec4 color = texture2D(uSampler, vec2(texcoord.x, 1. - texcoord.y));\n																	\n					if (comp == 0)									\n						value = color.r;							\n					if (comp == 1)									\n						value = color.g;							\n					if (comp == 2)									\n						value = color.b;							\n					if (comp == 3)									\n						value = color.a;	 						\n																	\n					vec4 t = floatToVec4(value);					\n																	\n				    gl_FragColor = vec4(t.a, t.b, t.g, t.r);		\n				}				");
	        }

	        pWebGLRenderer.bindWebGLTexture(eTarget, null);

			return true;
		}

// destroyResource(): bool {
// 	super.destroyResource();
// 	this._pWebGLTexture = null;
// 	this.destroy();
// 	return true;
// }

		destroy(): void {
			if ( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ) {
// Delete all render targets that are not yet deleted via _clearSliceRTT because the rendertarget
// was deleted by the user.
	            var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
	            for (var i:  number  = 0; i < this._pRTTList.length; i++) {
	                pWebGLRenderer.destroyRenderTarget(this._pRTTList[i]);
	            }
	        }
    	}

//upload(download) data to(from) videocard.
		protected upload(pData: IPixelBox, pDestBox: IBox): void {
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

			var pDataBox: IPixelBox = null;

			if(pixelUtil.isCompressed(pData.format)) {
				if(pData.format !== this._eFormat || !pData.isConsecutive()){
					{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 391 ); logger.criticalError("Compressed images must be consecutive, in the source format"); } ;
				}

				var iWebGLFormat:  number  = webgl.getClosestWebGLInternalFormat(this._eFormat);
// Data must be consecutive and at beginning of buffer as PixelStorei not allowed
// for compressed formats
            	if (pDestBox.left === 0 && pDestBox.top === 0) {
	                pWebGLContext.compressedTexImage2D(this._eFaceTarget, this._iLevel,
	                                       			   iWebGLFormat,
	                                       			   pDestBox.width,
	                                       			   pDestBox.height,
	                                       			   0,
	                                       			   pData.data);
	            }
	            else {
	                pWebGLContext.compressedTexSubImage2D(this._eFaceTarget, this._iLevel,
	                                          			  pDestBox.left, pDestBox.top,
	                                          			  pDestBox.width, pDestBox.height,
	                                          			  iWebGLFormat, pData.data);

	            }
			}
			else if(this._bSoftwareMipmap) {

				if (pData.width !== pData.rowPitch ||
					pData.height * pData.width !== pData.slicePitch)
				{
	                pDataBox = this._pBuffer.getSubBox(pDestBox, pixelUtil.pixelBox());
					pDataBox.setConsecutive();
					pixelUtil.bulkPixelConversion(pData, pDataBox);

	            }
	            else
	            {
	            	pDataBox = pData;
	            }

	            pWebGLRenderer.pixelStorei( 0x0CF5 , 1);
	            this.buildMipmaps(pDataBox);
			}
			else {
				if (pData.width !== pData.rowPitch ||
					pData.height * pData.width !== pData.slicePitch)
				{
	                pDataBox = this._pBuffer.getSubBox(pDestBox, pixelUtil.pixelBox());
					pDataBox.setConsecutive();
					pixelUtil.bulkPixelConversion(pData, pDataBox);
	            }
	            else {
	            	pDataBox = pData;
	            }

	            if ((pData.width * pixelUtil.getNumElemBytes(pData.format)) & 3) {
// Standard alignment of 4 is not right
	                pWebGLRenderer.pixelStorei( 0x0CF5 , 1);
	            }
	            if (pDestBox.left === 0 && pDestBox.top === 0 &&
	            	pDestBox.width >= this.width && pDestBox.height >= this.height)
	            {
	            	pWebGLContext.texImage2D(this._eFaceTarget,
                            			this._iLevel,
                            			webgl.getWebGLFormat(pData.format),
                            			pDestBox.width, pDestBox.height, 0,
                            			webgl.getWebGLFormat(pData.format),
                            			webgl.getWebGLDataType(pData.format),
                            			!pixelUtil.isFloatingPoint(pData.format)?
                            			pDataBox.data:
                            			new Float32Array(pDataBox.data.buffer, pDataBox.data.byteOffset, pDataBox.data.byteLength / Float32Array.BYTES_PER_ELEMENT));
	            }
	            else
	            {
            		pWebGLContext.texSubImage2D(this._eFaceTarget,
                            			this._iLevel,
                            			pDestBox.left, pDestBox.top,
                            			pDestBox.width, pDestBox.height,
                            			webgl.getWebGLFormat(pData.format),
                            			webgl.getWebGLDataType(pData.format),
                            			pDataBox.data);
	            }
	        }

	        if ( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0)  && !this._bSoftwareMipmap && (this._iLevel === 0)) {
	            pWebGLContext.generateMipmap(this._eFaceTarget);
	        }

	        pWebGLRenderer.pixelStorei( 0x0CF5 , 4);

	        pWebGLRenderer.bindWebGLTexture(this._eTarget, null);

	        this.notifyAltered();
		}



		protected download(pData: IPixelBox): void {


			{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 488 ); logger.assert(!((pData.right > this._iWidth) || (pData.bottom > this._iHeight) || (pData.front != 0) || (pData.back != 1)), "Invalid box " + pData.toString()); } ;

			var pSrcBox:IPixelBox = null;
			var pWebGLTexture: WebGLTexture = this._pWebGLTexture;
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if(!checkFBOAttachmentFormat(this.format)) {
				{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 496 ); logger.criticalError("Read from texture this format not support(" + this.format + ")"); } ;
			}

			if (!checkReadPixelFormat(this.format)) {
				{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 503 ); logger.assert(this.format === EPixelFormats.DEPTH32 || this.format === EPixelFormats.FLOAT32_RGB || this.format === EPixelFormats.FLOAT32_RGBA, "TODO: downloading for all formats"); }
                                                                                     ;

				var eFormat: EPixelFormats = this.format;
				var pDestBox: IBox = geometry.box(0, 0, 0, pData.width * pixelUtil.getComponentCount(this.format), pData.height, pData.depth);

				if (this.format === EPixelFormats.DEPTH32) {
					eFormat = EPixelFormats.FLOAT32_DEPTH;
				}

// мы не можем читать из данного формата напрямую, поэтому необходимо перерендерить эту текстура в RGB/RGBA 8.
				var pProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource(
					this.format === EPixelFormats.DEPTH32? "WEBGL_decode_depth32_texture": "WEBGL_decode_float32_texture");

				pWebGLTexture = WebGLTextureBuffer.copyTex2DImageByProgram(pProgram, pDestBox, EPixelFormats.R8G8B8A8, this, pData);

				if (pData.format === eFormat) {
					pSrcBox = pData;
				}
				else {
					pSrcBox = new pixelUtil.PixelBox(pData, eFormat,
						new Uint8Array(pixelUtil.getMemorySize(
							pData.width * pixelUtil.getComponentCount(this.format),
							pData.height,
							pData.depth,
							EPixelFormats.R8G8B8A8)));
				}

				var pOldFramebuffer: WebGLFramebuffer = pWebGLRenderer.getParameter( 0x8CA6 );
				var pFrameBuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

				pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pFrameBuffer);
				pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,  0x0DE1 , pWebGLTexture, 0);
				pWebGLContext.readPixels(0, 0, pDestBox.width, pDestBox.height,  0x1908 ,  0x1401 , pSrcBox.data);
				pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
				pWebGLRenderer.deleteWebGLFramebuffer(pFrameBuffer);
				pWebGLRenderer.deleteWebGLTexture(pWebGLTexture);

				if (pSrcBox != pData) {
					console.log("download. convertion....");
					pixelUtil.bulkPixelConversion(pSrcBox, pData);
				}

				return;
			}

			if(checkReadPixelFormat(pData.format))
			{
				pSrcBox = pData;
			}
			else
			{
				pSrcBox = new pixelUtil.PixelBox(pData, EPixelFormats.BYTE_RGBA,
												 new Uint8Array(pixelUtil.getMemorySize(pData.width, pData.height, pData.depth, EPixelFormats.BYTE_RGBA)));
			}



			var pOldFramebuffer: WebGLFramebuffer = pWebGLRenderer.getParameter( 0x8CA6 );
			var pFrameBuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

			pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pFrameBuffer);

			var eFormat:  number  = getWebGLFormat(pSrcBox.format);
			var eType:  number  = getWebGLDataType(pSrcBox.format);

			pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 , this._eFaceTarget, pWebGLTexture, this._iLevel);
			pWebGLContext.readPixels(pSrcBox.left, pSrcBox.top, pSrcBox.width, pSrcBox.height, eFormat, eType, pSrcBox.data);


			if(!checkReadPixelFormat(pData.format))
			{
				console.log("download. convertion....");
				pixelUtil.bulkPixelConversion(pSrcBox, pData);
			}

//дективировать его
			pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
			pWebGLRenderer.deleteWebGLFramebuffer(pFrameBuffer);

// if(data.getWidth() != getWidth() ||
//     data.getHeight() != getHeight() ||
//     data.getDepth() != getDepth())
//     OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "only download of entire buffer is supported by GL",
//         "GLTextureBuffer::download");
// glBindTexture( mTarget, mTextureID );
// if(PixelUtil::isCompressed(data.format))
// {
//     if(data.format != mFormat || !data.isConsecutive())
//         OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, 
//         "Compressed images must be consecutive, in the source format",
//         "GLTextureBuffer::download");
//     // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
//     // for compressed formate
//     glGetCompressedTexImageNV(mFaceTarget, mLevel, data.data);
// } 
// else
// {
//     if((data.getWidth()*PixelUtil::getNumElemBytes(data.format)) & 3) {
//         // Standard alignment of 4 is not right
//         glPixelStorei(GL_PACK_ALIGNMENT, 1);
//     }
//     // We can only get the entire texture
//     glGetTexImageNV(mFaceTarget, mLevel, 
//         GLES2PixelUtil::getGLOriginFormat(data.format), GLES2PixelUtil::getGLOriginDataType(data.format),
//         data.data);
//     // Restore defaults
//     glPixelStorei(GL_PACK_ALIGNMENT, 4);
// }
//CRITICAL("Downloading texture buffers is not supported by OpenGL ES");
		}

		protected buildMipmaps(pData: IPixelBox): void {
			var iWidth:  number  = 0;
	        var iHeight:  number  = 0;
	        var iLogW:  number  = 0;
	        var iLogH:  number  = 0;
	        var iLevel:  number  = 0;
	        var pScaled: IPixelBox = new pixelUtil.PixelBox();

	        pScaled.data = pData.data;
	        pScaled.left = pData.left;
	        pScaled.right = pData.right;
	        pScaled.top = pData.top;
	        pScaled.bottom = pData.bottom;
	        pScaled.front = pData.front;
	        pScaled.back = pData.back;

	        iWidth = pData.width;
	        iHeight = pData.height;

	        iLogW = computeLog(iWidth);
	        iLogH = computeLog(iHeight);
	        iLevel = (iLogW > iLogH ? iLogW : iLogH);

	        var mip:  number  = 0;
	        var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

	        for (mip = 0; mip <= iLevel; mip++) {
	           	var iWebGLFormat:  number  = webgl.getWebGLFormat(pScaled.format);
	            var iWebGLDataType:  number  = webgl.getWebGLDataType(pScaled.format);

	            pWebGLContext.texImage2D(this._eFaceTarget,
	            						 mip,
	            						 iWebGLFormat,
	            						 iWidth, iHeight,
                         				 0,
	                         			 iWebGLFormat,
	                        			 iWebGLDataType,
	                        			 pScaled.data);

	            if (mip !== 0) {
	                pScaled.data = null;
	            }

	            if (iWidth > 1) {
	                iWidth = iWidth / 2;
	            }

	            if (iHeight > 1) {
	                iHeight = iHeight / 2;
	            }

	            var iSizeInBytes:  number  = pixelUtil.getMemorySize(iWidth, iHeight, 1, pData.format);
	            pScaled = new pixelUtil.PixelBox(iWidth, iHeight, 1, pData.format);
	            pScaled.data = new Uint8Array(iSizeInBytes);
	            pData.scale(pScaled, EFilters.LINEAR);
        	}

// Delete the scaled data for the last level

	        if (iLevel > 0) {
	            pScaled.data = null;
	        }
		}

		_bindToFramebuffer(iAttachment:  number , iZOffset:  number ): void {
			{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 680 ); logger.assert(iZOffset < this._iDepth); } ;
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
			pWebGLContext.framebufferTexture2D( 0x8D40 , iAttachment, this._eFaceTarget, this._pWebGLTexture, this._iLevel);
		}

		_copyFromFramebuffer(iZOffset:  number ): void {
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
			pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, 0, 0, 0, 0, this._iWidth, this._iHeight);
			pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
		}

		/**@inline*/  _getTarget():  number  {
			return this._eTarget;
		}

		/**@inline*/  _getWebGLTexture(): WebGLTexture {
			return this._pWebGLTexture;
		}

		/**@inline*/  _getFaceTarget():  number  {
			return this._eFaceTarget;
		}

		blit(pSource: IPixelBuffer): bool;
		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer, pSrcBox?: IBox, pDestBox?: IBox): bool {
			if (arguments.length === 1) {
				return this.blit(pSource,
		            new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth),
		            new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth)
		        );
			}
			else {
				var pSourceTexture: WebGLTextureBuffer = <WebGLTextureBuffer>pSource;
// TODO: Check for FBO support first
// Destination texture must be 2D or Cube
// Source texture must be 2D
				if (! (((pSourceTexture.getFlags()) & (ETextureFlags.RENDERTARGET)) != 0)  &&
					pSourceTexture._getTarget() ===  0x0DE1 ) {

					return this.blitFromTexture(pSourceTexture, pSrcBox, pDestBox);
				}
				else {
					return super.blit(pSource, pSrcBox, pDestBox);
				}
			}
		}

		private static copyTex2DImageByProgram(pProgram: WebGLShaderProgram, pDestBox: IBox, eFormat:  number , pSource: WebGLTextureBuffer, pSrcBox: IBox = null): WebGLTexture {
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>pSource.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer._disableTextureUnitsFrom(0);
			pWebGLRenderer.activateWebGLTexture( 0x84C0 );

// Disable alpha, depth and scissor testing, disable blending, 
// and disable culling
        	pWebGLRenderer.disable( 0x0B71 );
	        pWebGLRenderer.disable( 0x0C11 );
	        pWebGLRenderer.disable( 0x0BE2 );
	        pWebGLRenderer.disable( 0x0B44 );

// Set up source texture
        	pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), pSource._getWebGLTexture());
        	var iOldMagFilter:  number  = pWebGLContext.getTexParameter(pSource._getFaceTarget(),  0x2800 ),
        		iOldMinFilter:  number  = pWebGLContext.getTexParameter(pSource._getFaceTarget(),  0x2801 ),
        		iOldWrapS:  number  	= pWebGLContext.getTexParameter(pSource._getFaceTarget(),  0x2802 ),
        		iOldWrapT:  number  	= pWebGLContext.getTexParameter(pSource._getFaceTarget(),  0x2803 );

        	if (isNull(pSrcBox)) {
        		pSrcBox = pDestBox;
        	}

// Set filtering modes depending on the dimensions and source
	        if(pSrcBox.width === pDestBox.width &&
	           pSrcBox.height === pDestBox.height &&
	           pSrcBox.depth === pDestBox.depth) {
// Dimensions match -- use nearest filtering (fastest and pixel correct)
	            pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2801 ,  0x2600 );
	            pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2800 ,  0x2600 );
	        }
	        else {
                pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2801 ,  0x2601 );
                pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2800 ,  0x2601 );
	        }
// Clamp to edge (fastest)
	        pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2802 ,  0x812F );
	        pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2803 ,  0x812F );

//Store old binding so it can be restored later
	        var pOldFramebuffer: WebGLFramebuffer = pWebGLRenderer.getParameter( 0x8CA6 );
	        var pFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

	        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pFramebuffer);

	        var pTempWebGLTexture: WebGLTexture = null;


// If target format not directly supported, create intermediate texture
        	var iGLTempFormat:  number  = webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(eFormat));

        	pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();
        	pWebGLRenderer.bindWebGLTexture( 0x0DE1 , pTempWebGLTexture);
// Allocate temporary texture of the size of the destination area
        	pWebGLContext.texImage2D( 0x0DE1 , 0, iGLTempFormat,
/*math.ceilingPowerOfTwo*/
                     				                           (pDestBox.width),
/*math.ceilingPowerOfTwo*/
                     				                           (pDestBox.height),
         				             0,  0x1908 ,  0x1401 , null);

        	pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
                                  			   0x0DE1 , pTempWebGLTexture, 0);
// Set viewport to size of destination slice
        	pWebGLContext.viewport(0, 0, pDestBox.width, pDestBox.height);


//Get WebGL program
	        var pWebGLShaderProgram: WebGLShaderProgram = <WebGLShaderProgram>pProgram;
	        pWebGLRenderer.disableAllWebGLVertexAttribs();
	        pWebGLRenderer.useWebGLProgram(pWebGLShaderProgram.getWebGLProgram());

	        var iPosAttrIndex:  number  = 0;
	        var iTexAttrIndex:  number  = 0;

	        iPosAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("POSITION");
	        iTexAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("TEXCOORD");

	        pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
	        pWebGLContext.enableVertexAttribArray(iTexAttrIndex);

	        var pSquareVertices: Float32Array = SQUARE_VERTICES;
	        var pTexCoords: Float32Array = TEXCOORDS;

	        var pPositionBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();
	        var pTexCoordsBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();

	        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pPositionBuffer);
	        pWebGLContext.bufferData( 0x8892 , pSquareVertices,  0x88E0 );
            pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2,  0x1406 , false, 0, 0);

            pWebGLShaderProgram.setInt("uSampler", 0);
            pWebGLShaderProgram.setInt("src_components_num", pixelUtil.getComponentCount(pSource.format));
            pWebGLShaderProgram.setInt("dst_width", pDestBox.width);
            pWebGLShaderProgram.setInt("dst_height", pDestBox.height);
// LOG("dest size: ", pDestBox.width, "x", pDestBox.height, "cn: ", pixelUtil.getComponentCount(pSource.format));
// Process each destination slice
	        var iSlice:  number  = 0;
	        for(iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
/// Calculate source texture coordinates
	            var u1:  number  = < number >pSrcBox.left / < number >pSource.width;
	            var v1:  number  = < number >pSrcBox.top / < number >pSource.height;
	            var u2:  number  = < number >pSrcBox.right / < number >pSource.width;
	            var v2:  number  = < number >pSrcBox.bottom / < number >pSource.height;
/// Calculate source slice for this destination slice
	            var w:  number  = < number >(iSlice - pDestBox.front) / < number >pDestBox.depth;
/// Get slice # in source
	            w = w * < number >pSrcBox.depth + pSrcBox.front;
/// Normalise to texture coordinate in 0.0 .. 1.0
	            w = (w + 0.5) / < number >pSource.depth;

	            pTexCoords[0] = u1;
	            pTexCoords[1] = v1;
	            pTexCoords[2] = w;

	            pTexCoords[3] = u2;
	            pTexCoords[4] = v1;
	            pTexCoords[5] = w;

	            pTexCoords[6] = u2;
	            pTexCoords[7] = v2;
	            pTexCoords[8] = w;

  	            pTexCoords[9]  = u1;
	            pTexCoords[10] = v2;
	            pTexCoords[11] = w;

/// Finally we're ready to rumble	
	            pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), pSource._getWebGLTexture());

	            pWebGLRenderer.bindWebGLBuffer( 0x8892 , pTexCoordsBuffer);
		        pWebGLContext.bufferData( 0x8892 , pTexCoords,  0x88E0 );
	            pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3,  0x1406 , false, 0, 0);

	            pWebGLContext.drawArrays( 0x0005 , 0, 4);
	        }

	        pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
	        pWebGLContext.disableVertexAttribArray(iTexAttrIndex);

	        pWebGLRenderer.deleteWebGLBuffer(pPositionBuffer);
	        pWebGLRenderer.deleteWebGLBuffer(pTexCoordsBuffer);

// Reset source texture to sane state
	        pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), pSource._getWebGLTexture());
	        pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2801 , iOldMinFilter);
	        pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2800 , iOldMagFilter);
	        pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2802 , iOldWrapS);
	        pWebGLContext.texParameteri(pSource._getFaceTarget(),  0x2803 , iOldWrapT);
	        pWebGLRenderer.bindWebGLTexture(pSource._getFaceTarget(), null);

// Detach texture from temporary framebuffer
	        pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8CE0 ,
	                                  			  0x8D41 , null);
// Restore old framebuffer
	        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
	        pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

	    	return pTempWebGLTexture;
		}

//-----------------------------------------------------------------------------  
// Very fast texture-to-texture blitter and hardware bi/trilinear scaling implementation using FBO
// Destination texture must be 1D, 2D, 3D, or Cube
// Source texture must be 1D, 2D or 3D
// Supports compressed formats as both source and destination format, it will use the hardware DXT compressor
// if available.
	    blitFromTexture(pSource: WebGLTextureBuffer, pSrcBox: IBox, pDestBox: IBox): bool {
	    	var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if (this.format === pSource.format &&
				checkCopyTexImage(this.format) &&
				this._pBuffer.contains(pDestBox) &&
				pSrcBox.width === pDestBox.width &&
	        	pSrcBox.height === pDestBox.height &&
	        	pSrcBox.depth === pDestBox.depth)
			{
				var pOldFramebuffer: WebGLFramebuffer = pWebGLRenderer.getParameter( 0x8CA6 );
	        	var pFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

	        	pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pFramebuffer);

	        	pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
                                      			   pSource._getTarget(), pSource._getWebGLTexture(), 0);

	        	pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

	        	if(pDestBox.width === this.width && pDestBox.height === this.height){
	        		pWebGLContext.copyTexImage2D(this._eFaceTarget, this._iLevel,
	        									 getWebGLFormat(this._eFormat),
	        									 pSrcBox.left, pSrcBox.top,
	        									 pSrcBox.width, pSrcBox.height, 0);
	        	}
	        	else {
	        		pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel,
	        									 	pDestBox.left, pDestBox.top,
	        										pSrcBox.left, pSrcBox.top,
	        										pSrcBox.width, pSrcBox.height);
	        	}

	        	pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
	        	pWebGLRenderer.bindWebGLTexture(this._eTarget, null);
				pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

				this.notifyAltered();

				return true;
			}
			pWebGLRenderer._disableTextureUnitsFrom(0);
			pWebGLRenderer.activateWebGLTexture( 0x84C0 );

// Disable alpha, depth and scissor testing, disable blending, 
// and disable culling
        	pWebGLRenderer.disable( 0x0B71 );
	        pWebGLRenderer.disable( 0x0C11 );
	        pWebGLRenderer.disable( 0x0BE2 );
	        pWebGLRenderer.disable( 0x0B44 );

// Set up source texture
        	pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());
        	var iOldMagFilter:  number  = pWebGLContext.getTexParameter(pSource._getFaceTarget(),  0x2800 ),
        		iOldMinFilter:  number  = pWebGLContext.getTexParameter(pSource._getFaceTarget(),  0x2801 ),
        		iOldWrapS:  number  	= pWebGLContext.getTexParameter(pSource._getFaceTarget(),  0x2802 ),
        		iOldWrapT:  number  	= pWebGLContext.getTexParameter(pSource._getFaceTarget(),  0x2803 );

// Set filtering modes depending on the dimensions and source
	        if(pSrcBox.width === pDestBox.width &&
	           pSrcBox.height === pDestBox.height &&
	           pSrcBox.depth === pDestBox.depth) {
// Dimensions match -- use nearest filtering (fastest and pixel correct)
	            pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2600 );
	            pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2600 );
	        }
	        else {
// Dimensions don't match -- use bi or trilinear filtering depending on the
// source texture.
	            if( (((pSource.getFlags()) & (ETextureFlags.AUTOMIPMAP)) != 0) ) {
// Automatic mipmaps, we can safely use trilinear filter which
// brings greatly improved quality for minimisation.
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2703 );
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2601 );
	            }
	            else {
// Manual mipmaps, stay safe with bilinear filtering so that no
// intermipmap leakage occurs.
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2601 );
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2601 );
	            }
	        }
// Clamp to edge (fastest)
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2802 ,  0x812F );
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2803 ,  0x812F );

//Store old binding so it can be restored later
	        var pOldFramebuffer: WebGLFramebuffer = pWebGLRenderer.getParameter( 0x8CA6 );

	        var pFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

	        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pFramebuffer);

	        var pTempWebGLTexture: WebGLTexture = null;

	        if(!webgl.checkFBOAttachmentFormat(this._eFormat) || pSource._getWebGLTexture() === this._getWebGLTexture()){
// If target format not directly supported, create intermediate texture
	        	var iGLTempFormat:  number  = webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(this._eFormat));

	        	pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();
	        	pWebGLRenderer.bindWebGLTexture( 0x0DE1 , pTempWebGLTexture);
// Allocate temporary texture of the size of the destination area
	        	pWebGLContext.texImage2D( 0x0DE1 , 0, iGLTempFormat,
                         				 math.ceilingPowerOfTwo(pDestBox.width),
                         				 math.ceilingPowerOfTwo(pDestBox.height),
             				             0,  0x1908 ,  0x1401 , null);

	        	pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
                                      			   0x0DE1 , pTempWebGLTexture, 0);
// Set viewport to size of destination slice
	        	pWebGLContext.viewport(0, 0, pDestBox.width, pDestBox.height);
	        }
	        else {
// We are going to bind directly, so set viewport to size and position of destination slice
	        	pWebGLContext.viewport(pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height);
	        }

//Get WebGL program
	        var pWebGLShaderProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_blit_texture_buffer");
	        pWebGLRenderer.disableAllWebGLVertexAttribs();
	        pWebGLRenderer.useWebGLProgram(pWebGLShaderProgram.getWebGLProgram());

	        var iPosAttrIndex:  number  = 0;
	        var iTexAttrIndex:  number  = 0;

	        iPosAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("POSITION");
	        iTexAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("TEXCOORD");

	        pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
	        pWebGLContext.enableVertexAttribArray(iTexAttrIndex);

	        var pSquareVertices: Float32Array = SQUARE_VERTICES;
	        var pTexCoords: Float32Array = TEXCOORDS;

	        var pPositionBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();
	        var pTexCoordsBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();

	        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pPositionBuffer);
	        pWebGLContext.bufferData( 0x8892 , pSquareVertices,  0x88E0 );
            pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2,  0x1406 , false, 0, 0);

            pWebGLShaderProgram.setInt("uSampler", 0);

// Process each destination slice
	        var iSlice:  number  = 0;
	        for(iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
	            if(isNull(pTempWebGLTexture)) {
// Bind directly
	                this._bindToFramebuffer( 0x8CE0 , iSlice);
	            }

/// Calculate source texture coordinates
	            var u1:  number  = < number >pSrcBox.left / < number >pSource.width;
	            var v1:  number  = < number >pSrcBox.top / < number >pSource.height;
	            var u2:  number  = < number >pSrcBox.right / < number >pSource.width;
	            var v2:  number  = < number >pSrcBox.bottom / < number >pSource.height;
/// Calculate source slice for this destination slice
	            var w:  number  = < number >(iSlice - pDestBox.front) / < number >pDestBox.depth;
/// Get slice # in source
	            w = w * < number >pSrcBox.depth + pSrcBox.front;
/// Normalise to texture coordinate in 0.0 .. 1.0
	            w = (w + 0.5) / < number >pSource.depth;

	            pTexCoords[0] = u1;
	            pTexCoords[1] = v1;
	            pTexCoords[2] = w;

	            pTexCoords[3] = u2;
	            pTexCoords[4] = v1;
	            pTexCoords[5] = w;

	            pTexCoords[6] = u2;
	            pTexCoords[7] = v2;
	            pTexCoords[8] = w;

  	            pTexCoords[9]  = u1;
	            pTexCoords[10] = v2;
	            pTexCoords[11] = w;

/// Finally we're ready to rumble	
	            pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());

// pWebGLContext.enable(pSource._getTarget());

	            pWebGLRenderer.bindWebGLBuffer( 0x8892 , pTexCoordsBuffer);
		        pWebGLContext.bufferData( 0x8892 , pTexCoords,  0x88E0 );
	            pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3,  0x1406 , false, 0, 0);

	            pWebGLContext.drawArrays( 0x0005 , 0, 4);
// pWebGLContext.disable(pSource._getTarget());


	            if(!isNull(pTempWebGLTexture)) {
	            	if(pSource === this) {
//set width, height and _pWebGLTexture
	            		pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

	            		this._pWebGLTexture = pTempWebGLTexture;
	            		this._iWidth = math.ceilingPowerOfTwo(pDestBox.width);
	            		this._iHeight = math.ceilingPowerOfTwo(pDestBox.height);
	            	}
	            	else {
// Copy temporary texture
		                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

		                switch(this._eTarget) {
		                    case  0x0DE1 :
		                    case  0x8513 :
		                        pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel,
		                                            			pDestBox.left, pDestBox.top,
		                                           				0, 0, pDestBox.width, pDestBox.height);
		                        break;
		                }
	            	}
	            }
	        }

	        pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
	        pWebGLContext.disableVertexAttribArray(iTexAttrIndex);

	        pWebGLRenderer.deleteWebGLBuffer(pPositionBuffer);
	        pWebGLRenderer.deleteWebGLBuffer(pTexCoordsBuffer);

// Finish up 
	        if(!isNull(pTempWebGLTexture)) {
// Generate mipmaps
	            if( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0) ) {
	                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
	                pWebGLContext.generateMipmap(this._eTarget);
	            }
	        }

// Reset source texture to sane state
	        pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 , iOldMinFilter);
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 , iOldMagFilter);
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2802 , iOldWrapS);
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2803 , iOldWrapT);
	        pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), null);

// Detach texture from temporary framebuffer
	        pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8CE0 ,
	                                  			  0x8D41 , null);
// Restore old framebuffer
	        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
	        if(pSource !== this) {
	        	pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
	    	}
	        pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

	        pTempWebGLTexture = null;
	        this.notifyAltered();

	    	return true;
	    }

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox?: IBox): bool;
		blitFromMemory(): bool {
			if(arguments.length === 1){
				return super.blitFromMemory(arguments[0]);
			}

// Fall back to normal GLHardwarePixelBuffer::blitFromMemory in case 
// - FBO is not supported
// - Either source or target is luminance due doesn't looks like supported by hardware
// - the source dimensions match the destination ones, in which case no scaling is needed
// TODO: Check that extension is NOT available

			var pSourceOrigin: IPixelBox = arguments[0];
			var pDestBox: IBox = arguments[1];

			if(pixelUtil.isLuminance(pSourceOrigin.format) ||
	           pixelUtil.isLuminance(this._eFormat) ||
	           (pSourceOrigin.width === pDestBox.width &&
	            pSourceOrigin.height === pDestBox.height &&
	            pSourceOrigin.depth === pDestBox.depth)) {

	            return super.blitFromMemory(pSourceOrigin, pDestBox);
	        }

	        if(!this._pBuffer.contains(pDestBox)) {
	            { logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 1182 ); logger.criticalError("Destination box out of range"); } ;
	        }

		    var pSource: IPixelBox;
// First, convert the srcbox to a OpenGL compatible pixel format
	        if(getWebGLFormat(pSourceOrigin.format) === 0){
// Convert to buffer internal format
	        	var iSizeInBytes:  number  = pixelUtil.getMemorySize(pSourceOrigin.width, pSourceOrigin.height,
	        													pSourceOrigin.depth, this._eFormat);
	        	pSource = new pixelUtil.PixelBox(pSourceOrigin.width, pSourceOrigin.height,
	        									 pSourceOrigin.depth, this._eFormat, new Uint8Array(iSizeInBytes));

	        	pixelUtil.bulkPixelConversion(pSourceOrigin, pSource);
	        }
	        else {
// No conversion needed
	        	pSource = pSourceOrigin;
	        }

	        var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

// Create temporary texture to store source data
	        var pTempWebGLTexture: WebGLTexture = null;
	        var eTarget:  number  =  0x0DE1 ;
	        var iWidth:  number  = math.ceilingPowerOfTwo(pSource.width);
	        var iHeight:  number  = math.ceilingPowerOfTwo(pSource.height);
	        var iWebGLFormat: number  = getClosestWebGLInternalFormat(pSource.format);
	        var iWebGLDataType:  number  = getWebGLDataType(pSource.format);

	        pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();

	        if(isNull(pTempWebGLTexture)){
	        	{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 1215 ); logger.error("Can not create WebGL texture"); } ;
	        	return false;
	        }

	        pWebGLRenderer.bindWebGLTexture(eTarget, pTempWebGLTexture);
	        pWebGLContext.texImage2D(eTarget, 0, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
			pWebGLRenderer.bindWebGLTexture(eTarget, null);

	        var pTextureBufferPool: IResourcePool = this.getManager().textureBufferPool;
	        var pTempTexBuffer: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(".temp");
// var pTempTexBuffer: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.findResource(".temp");

// if(isNull(pTextureBufferPool)){
// 	pTempTexBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(".temp");
// }

	        pTempTexBuffer.create(eTarget, pTempWebGLTexture, iWidth, iHeight,
								  iWebGLFormat, pSource.format, 0, 0,
								  ETextureFlags.AUTOMIPMAP | EHardwareBufferFlags.STATIC,
								  false);

// Upload data to 0,0,0 in temporary texture
	        var pTempBoxTarget: IBox = new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth);
	        pTempTexBuffer.upload(pSource, pTempBoxTarget);

//Blit
	        this.blitFromTexture(pTempTexBuffer, pTempBoxTarget, pDestBox);

//Delete temp data
	        pTempTexBuffer.release();
	        pTextureBufferPool.destroyResource(pTempTexBuffer);

	        pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
	        pTempWebGLTexture = null;
	        pTempBoxTarget = null;

			return true;
		}

		getRenderTarget(): IRenderTarget;
		getRenderTarget(iZOffest:  number ): IRenderTarget;
		getRenderTarget(iZOffest?:  number  = 0): IRenderTarget {
			{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 1257 ); logger.assert( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ); } ;
        	{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 1258 ); logger.assert(iZOffest < this._iDepth, "iZOffest: " + iZOffest + ", iDepth: " + this._iDepth); } ;
        	return this._pRTTList[iZOffest];
		}

		resize(iSize:  number ): bool;
		resize(iWidth:  number , iHeight?:  number  = iWidth): bool {
			if(arguments.length === 1){
				{ logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 1265 ); logger.criticalError("resize with one parametr not available for WebGLTextureBuffer"); } ;
				return false;
			}
			var pSrcBox: IBox = geometry.box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
			var pDestBox: IBox = geometry.box(0, 0, 0, iWidth, iHeight, this._iDepth);

			return this.blitFromTexture(this, pSrcBox, pDestBox);
		}

	}
}





module akra.webgl {
	export class WebGLInternalTexture extends core.pool.resources.Texture {
		private _pSurfaceList: WebGLTextureBuffer[] = null;
		private _pWebGLTexture: WebGLTexture = null;

        /**@inline*/  getWebGLTexture(): WebGLTexture {
            return this._pWebGLTexture;
        }

		constructor () {
            super();
        }

        _getWebGLTextureTarget():  number  {
        	switch(this._eTextureType) {
        		case ETextureTypes.TEXTURE_2D:
        			return  0x0DE1 ;
        		case ETextureTypes.TEXTURE_CUBE_MAP:
        			return  0x8513 ;
        		default:
        			return 0;
        	}
        }

        private _getWebGLTextureParameter(eParam: ETextureParameters): number
        {
        	switch(eParam) {
        		case ETextureParameters.MAG_FILTER:
        			return  0x2800 ;
        		case ETextureParameters.MIN_FILTER:
        			return  0x2801 ;
        		case ETextureParameters.WRAP_S:
        			return  0x2802 ;
        		case ETextureParameters.WRAP_T:
        			return  0x2803 ;
        		default:
        			return 0;
        	}
        }


        private _getWebGLTextureParameterValue(eValue: ETextureFilters): number ;
        private _getWebGLTextureParameterValue(eValue: ETextureWrapModes): number ;
        private _getWebGLTextureParameterValue(eValue: any): number
        {
        	switch(eValue) {
        		case ETextureFilters.NEAREST:
        			return  0x2600 ;
        		case ETextureFilters.LINEAR:
        			return  0x2601 ;
        		case ETextureFilters.NEAREST_MIPMAP_NEAREST:
        			return  0x2700 ;
        		case ETextureFilters.LINEAR_MIPMAP_NEAREST:
        			return  0x2701 ;
        		case ETextureFilters.NEAREST_MIPMAP_LINEAR:
        			return  0x2702 ;
        		case ETextureFilters.LINEAR_MIPMAP_LINEAR:
        			return  0x2703 ;


        		case ETextureWrapModes.REPEAT:
        			return  0x2901 ;
        		case ETextureWrapModes.CLAMP_TO_EDGE:
        			return  0x812F ;
        		case ETextureWrapModes.MIRRORED_REPEAT:
        			return  0x8370 ;
        		default:
        			return 0;
        	}
        }

        private _getAkraTextureParameterValue(iWebGLValue:  number ):  number  {
            switch(iWebGLValue){
                case  0x2600 :
                    return ETextureFilters.NEAREST;
                case  0x2601 :
                    return ETextureFilters.LINEAR;
                case  0x2700 :
                    return ETextureFilters.NEAREST_MIPMAP_NEAREST;
                case  0x2701 :
                    return ETextureFilters.LINEAR_MIPMAP_NEAREST;
                case  0x2702 :
                    return ETextureFilters.NEAREST_MIPMAP_LINEAR;
                case  0x2703 :
                    return ETextureFilters.LINEAR_MIPMAP_LINEAR;


                case  0x2901 :
                    return ETextureWrapModes.REPEAT;
                case  0x812F :
                    return ETextureWrapModes.CLAMP_TO_EDGE;
                case  0x8370 :
                    return ETextureWrapModes.MIRRORED_REPEAT;
                default:
                    return 0;
            }
        }

        reset(): void;
        reset(iSize:  number ): void;
        reset(iWidth:  number , iHeight:  number ): void;
        reset(iWidth?:  number  = this._iWidth, iHeight?:  number  = iWidth): void {
            super.reset(iWidth, iHeight);

            for(var i:  number  = 0; i < this._pSurfaceList.length; i++) {
                this._pSurfaceList[i].reset(iWidth, iHeight);
            }
        };


        protected _setFilterInternalTexture(eParam: ETextureParameters, eValue: ETextureFilters): bool{
             if (!this.isValid()) {
                return false;
            }

            var iWebGLTarget:  number  = this._getWebGLTextureTarget();
            var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
            pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(eParam), this._getWebGLTextureParameterValue(eValue));
// var e = pWebGLContext.getError();if (e){LOG(this.findResourceName(), "filter: ", eParam, "value: ", eValue, "error: ", e)};
            return true;
        }
        protected _setWrapModeInternalTexture(eParam: ETextureParameters, eValue: ETextureWrapModes): bool{
            if (!this.isValid()) {
                return false;
            }

            var iWebGLTarget:  number  = this._getWebGLTextureTarget();
            var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
            pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(eParam), this._getWebGLTextureParameterValue(eValue));
            return true;
        }

        protected _getFilterInternalTexture(eParam: ETextureParameters): ETextureFilters{
            if (!this.isValid()) {
                return 0;
            }
            var iWebGLTarget:  number  = this._getWebGLTextureTarget();
            var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
            return this._getAkraTextureParameterValue(pWebGLContext.getTexParameter(iWebGLTarget, this._getWebGLTextureParameter(eParam)));
        }

        protected _getWrapModeInternalTexture(eParam: ETextureParameters): ETextureWrapModes{
            if (!this.isValid()) {
                return 0;
            }
            var iWebGLTarget:  number  = this._getWebGLTextureTarget();
            var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
            return this._getAkraTextureParameterValue(pWebGLContext.getTexParameter(iWebGLTarget, this._getWebGLTextureParameter(eParam)));
        }


        protected _createInternalTextureImpl(cFillColor?: IColor = null): bool
        {
        	if(!isNull(cFillColor))
        	{
        		{ logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 177 ); logger.warning("Texture can create with filled only by default(black) color"); } ;
//TODO: must implement filling by color
        	}


        	var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();

			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();


            if(this._eTextureType==ETextureTypes.TEXTURE_2D)
            {
                if(this._iWidth>webgl.maxTextureSize)
                {
                	{ logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 191 ); logger.warning("Заданная ширина не поддерживается("+this._iWidth+")"); } ;
                	this._iWidth=webgl.maxTextureSize;
                }
                if(this._iHeight>webgl.maxTextureSize)
                {
                    { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 196 ); logger.warning("Заданная высота не поддерживается("+this._iHeight+")"); } ;
                    this._iHeight=webgl.maxTextureSize;

                }
            }
            else if( this._eTextureType==ETextureTypes.TEXTURE_CUBE_MAP)
            {
                if(this._iWidth>webgl.maxCubeMapTextureSize)
                {
                	{ logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 205 ); logger.warning("Заданная ширина не поддерживается("+this._iWidth+")"); } ;
                	this._iWidth=webgl.maxCubeMapTextureSize;
                }
                if(this._iHeight>webgl.maxCubeMapTextureSize)
                {
                    { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 210 ); logger.warning("Заданная высота не поддерживается("+this._iHeight+")"); } ;
                    this._iHeight=webgl.maxCubeMapTextureSize;

                }
            }

            if(this._iWidth==0)
            {
            	{ logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 218 ); logger.warning("Заданная ширина не поддерживается("+this._iWidth+")"); } ;
                this._iWidth=1;

            }
            if(this._iHeight==0)
            {
                { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 224 ); logger.warning("Заданная высота не поддерживается("+this._iHeight+")"); } ;
                this._iHeight=1;
            }
            if(this._iDepth!=1)
            {
            	this._iDepth=1;
                { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 230 ); logger.warning("Трехмерные текстуры не поддерживаются, сброс глубины в 1"); } ;
            }
            if(this._nMipLevels!=0 && !webgl.hasExtension( "EXT_texture_npot_2D_mipmap" ) &&(!math.isPowerOfTwo(this._iDepth)||!math.isPowerOfTwo(this._iHeight)||!math.isPowerOfTwo(this._iWidth)))
            {
                { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 234 ); logger.warning("Мип мапы у текстуры не стпени двойки не поддерживаются, сброс мипмапов в 0"); } ;
                this._nMipLevels=0;
                ((this._iFlags) &= ~(ETextureFlags.AUTOMIPMAP)) ;
            }

            if(!webgl.isWebGLFormatSupport(this._eFormat))
            {
                { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 241 ); logger.warning("Данный тип текстуры не поддерживается: ", this._eFormat); } ;
                this._eFormat=EPixelFormats.A8B8G8R8;
            }


            if (this._nMipLevels!=0 && this._nMipLevels!=akra.core.pool.resources.Img.getMaxMipmaps(this._iWidth, this._iHeight, this._iDepth, this._eFormat))
            {
                { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 248 ); logger.warning("Нехватает мипмапов, сброс в 0"); } ;
                this._nMipLevels=0;
            }


// Convert to nearest power-of-two size if required
//this._iWidth = math.ceilingPowerOfTwo(this._iWidth);
//this._iHeight = math.ceilingPowerOfTwo(this._iHeight);
//this._iDepth = math.ceilingPowerOfTwo(this._iDepth);


            var iWebGLTarget:  number  = this._getWebGLTextureTarget();

	        this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();

	        pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);

	        this._isMipmapsHardwareGenerated = pWebGLRenderer.hasCapability(ERenderCapabilities.AUTOMIPMAP);

// Set some misc default parameters, these can of course be changed later

            var eMinFiler:  number  = this.getFilter(ETextureParameters.MIN_FILTER);
            var eMagFiler:  number  = this.getFilter(ETextureParameters.MAG_FILTER);

            if ((eMinFiler >= ETextureFilters.NEAREST_MIPMAP_NEAREST && eMinFiler <= ETextureFilters.LINEAR_MIPMAP_LINEAR) &&
                this._nMipLevels < 2) {
                eMinFiler = ETextureFilters.LINEAR;
            }

            if ((eMagFiler >= ETextureFilters.NEAREST_MIPMAP_NEAREST && eMagFiler <= ETextureFilters.LINEAR_MIPMAP_LINEAR) &&
                this._nMipLevels < 2) {
                eMagFiler = ETextureFilters.LINEAR;
            }
// LOG("e: ", pWebGLContext.getError(), this.findResourceName(), "n mipmaps: ", this._nMipLevels, "size (x, y):", this._iWidth, this._iHeight, "min filer > ", "(0x", eMinFiler.toString(16), ")");


            this.setFilter(ETextureParameters.MIN_FILTER, eMinFiler);
            this.setFilter(ETextureParameters.MAG_FILTER, eMagFiler);
            this.setWrapMode(ETextureParameters.WRAP_S, this.getWrapMode(ETextureParameters.WRAP_S));
            this.setWrapMode(ETextureParameters.WRAP_T, this.getWrapMode(ETextureParameters.WRAP_T));

            pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(ETextureParameters.MIN_FILTER), eMinFiler);
            pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(ETextureParameters.MAG_FILTER), eMagFiler);
            pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(ETextureParameters.WRAP_S), this.getWrapMode(ETextureParameters.WRAP_S));
            pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(ETextureParameters.WRAP_T), this.getWrapMode(ETextureParameters.WRAP_T));

	        var iWebGLFormat:  number  = webgl.getWebGLFormat(this._eFormat);
	        var iWebGLDataType:  number  = webgl.getWebGLDataType(this._eFormat);
	        var iWidth:  number  = this._iWidth;
	        var iHeight:  number  = this._iHeight;
	        var iDepth:  number  = this._iDepth;

	        if (pixelUtil.isCompressed(this._eFormat))
	        {
// Compressed formats
	            var iSize:  number  = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);

// Provide temporary buffer filled with zeroes as glCompressedTexImageXD does not
// accept a 0 pointer like normal glTexImageXD
// Run through this process for every mipmap to pregenerate mipmap pyramid


	            var pTmpData: Uint8Array = new Uint8Array(iSize);
	            var pEmptyData: Uint8Array;
	            var mip:  number  = 0;

	            for (mip = 0; mip <= this._nMipLevels; mip++) {

	                iSize = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);
//console.log(iSize,iWidth, iHeight, iDepth, this._eFormat);
	                pEmptyData = pTmpData.subarray(0, iSize);
					switch(this._eTextureType)
                    {

						case ETextureTypes.TEXTURE_2D:
	                        pWebGLContext.compressedTexImage2D( 0x0DE1 , mip, iWebGLFormat,
	                        								   iWidth, iHeight, 0, pEmptyData);
	                        break;
						case ETextureTypes.TEXTURE_CUBE_MAP:
							var iFace:  number  = 0;
							for(iFace = 0; iFace < 6; iFace++) {
								pWebGLContext.compressedTexImage2D( 0x8515  + iFace, mip, iWebGLFormat,
																   iWidth, iHeight, 0, pEmptyData);
							}
							break;
	                    default:
	                        break;

	                };
	                if(iWidth > 1) iWidth = iWidth / 2;
	                if(iHeight > 1) iHeight = iHeight / 2;
	                if(iDepth > 1) iDepth = iDepth / 2;

	            }
	            pTmpData = null;
	            pEmptyData = null;
	        }
	        else {
	        	var mip:  number  = 0;
// Run through this process to pregenerate mipmap pyramid
	            for (mip = 0; mip <= this._nMipLevels; mip++) {
// Normal formats
					switch(this._eTextureType){
						case ETextureTypes.TEXTURE_2D:
//console.log(mip,iWidth, iHeight);
	                        pWebGLContext.texImage2D( 0x0DE1 , mip, iWebGLFormat,
	                                     			 iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
	                        break;
						case ETextureTypes.TEXTURE_CUBE_MAP:
							var iFace:  number  = 0;
							for(iFace = 0; iFace < 6; iFace++) {
								pWebGLContext.texImage2D( 0x8515  + iFace, mip, iWebGLFormat,
	                                     			 	 iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
							}
							break;
	                    default:
	                        break;
	                }

	                if(iWidth > 1) iWidth = iWidth >>> 1;
	                if(iHeight > 1) iHeight = iHeight >>> 1;
	                if(iDepth > 1) iDepth = iDepth >>> 1;
	            }
	        }

	        this._createSurfaceList();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, null);

            return true;
        }

        protected freeInternalTextureImpl(): bool {
        	var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
			this._pWebGLTexture = null;

			for(var i:  number  = 0; i < this._pSurfaceList.length; i++) {
				this._pSurfaceList[i].release();
			}

			this._pSurfaceList = null;

            return true;
        }

        private _createSurfaceList(): void {
        	this._pSurfaceList = new Array();

// For all faces and mipmaps, store surfaces as IPixelBuffer
        	var bWantGeneratedMips: bool =  (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0) ;

// Do mipmapping in software? (uses GLU) For some cards, this is still needed. Of course,
// only when mipmap generation is desired.
        	var bDoSoftware: bool = bWantGeneratedMips && !this._isMipmapsHardwareGenerated && this._nMipLevels !== 0;

        	var iFace:  number  = 0;
        	var mip:  number  = 0;
        	var pTextureBufferPool: IResourcePool = this.getManager().textureBufferPool;
        	var sResourceName: string = this.findResourceName();

        	for(iFace = 0; iFace < this.getNumFaces(); iFace++) {
        		var iWidth:  number  = this._iWidth;
        		var iHeight:  number  = this._iHeight;



        		for(mip = 0; mip <= this._nMipLevels; mip++) {
        			var pBuf: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(sResourceName + "_" + iFace + "_" + mip);


                    pBuf.create(this._getWebGLTextureTarget(),
        						this._pWebGLTexture,
        						iWidth, iHeight,
        						webgl.getClosestWebGLInternalFormat(this._eFormat),
        						webgl.getWebGLDataType(this._eFormat),
        						iFace,
        						mip,
        						this._iFlags,
        						bDoSoftware && mip === 0);

        			this._pSurfaceList.push(pBuf);

//check error
        			if(pBuf.width === 0 ||
        			   pBuf.height === 0 ||
        			   pBuf.depth === 0) {
        				{ logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 439 ); logger.criticalError("Zero sized texture surface on texture " + sResourceName + " face " + iFace + " mipmap " + mip + ". The GL driver probably refused to create the texture."); }
                                                                                        ;
        			}

        		}
        	}
        }

        getBuffer(iFace?:  number  = 0, iMipmap?:  number  = 0): IPixelBuffer {
            if (iFace >= this.getNumFaces()) {
	            { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 448 ); logger.criticalError("Face index out of range", iFace, this.getNumFaces()); } ;
	        }

	        if (iMipmap > this._nMipLevels) {
	            { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 452 ); logger.criticalError("Mipmap index out of range", iMipmap, this._nMipLevels); } ;
	        }

	        var idx:  number  = iFace * (this._nMipLevels + 1) + iMipmap;
	        { logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 456 ); logger.assert(idx < this._pSurfaceList.length,"smth "+this._pSurfaceList.length+" , "+ iFace+" , "+this._nMipLevels+" , "+iMipmap); } ;

	        return this._pSurfaceList[idx];
        }


        createRenderTexture(): bool {
// Create the GL texture
// This already does everything necessary
            return this.createInternalTexture();
        }

	}
}


































module akra {
	export interface IBufferDataModifier {
		(pData: ArrayBufferView): void;
	}
}







module akra.data {

	enum EVertexDataLimits {
		k_MaxElementsSize = 256
	};

	export class VertexData implements IVertexData {
		private _pVertexBuffer: IVertexBuffer;
		private _iOffset:  number ;
		private _iStride:  number ;
		private _iLength:  number ;
		private _pVertexDeclaration: VertexDeclaration;
		private _iId:  number ;

		/**@inline*/  get id():  number  { return this._iId; }
		/**@inline*/  get length():  number  { return this._iLength; };
		/**@inline*/  get byteOffset():  number  { return this._iOffset; };
		/**@inline*/  get byteLength():  number  { return this._iLength * this._iStride; };
		/**@inline*/  get buffer(): IVertexBuffer { return this._pVertexBuffer; };
		/**@inline*/  get stride():  number  { return this._iStride; };
		/**@inline*/  get startIndex():  number  {
			var iIndex:  number  = this.byteOffset / this.stride;
    		{ logger.setSourceLocation( "data/VertexData.ts" , 34 ); logger.assert(iIndex % 1 == 0, "cannot calc first element index"); } ;
   			return iIndex;
   		};


		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , nSize:  number );
		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , pDecl: IVertexDeclaration);
		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , pDecl: any) {

			this._pVertexBuffer = pVertexBuffer;
			this._iOffset = iOffset;
			this._iLength = iCount;
			this._iId = id;
			this._pVertexDeclaration = null;
			this._iStride = 0;

			if (isInt(pDecl)) {
				this._iStride = < number >pDecl;
			}
			else {
				this._iStride = pDecl.stride;
				this.setVertexDeclaration(pDecl);
			}

			{ logger.setSourceLocation( "data/VertexData.ts" , 59 ); logger.assert(pVertexBuffer.byteLength >= this.byteLength + this.byteOffset, "vertex data out of array linits"); }
                                      ;
		}


		getVertexDeclaration(): VertexDeclaration {
			return this._pVertexDeclaration;
		}

		setVertexDeclaration(pDecl: IVertexDeclaration): bool {
			if (this._pVertexDeclaration) {
				{ logger.setSourceLocation( "data/VertexData.ts" , 69 ); logger.error("vertex declaration already exists"); } ;

				return false;
			}

			var iStride:  number  = pDecl.stride;

		    this._pVertexDeclaration = <VertexDeclaration>pDecl.clone();


		    { logger.setSourceLocation( "data/VertexData.ts" , 80 ); logger.assert(iStride < <number>EVertexDataLimits.k_MaxElementsSize, "stride max is 255 bytes"); }
                                 ;
		    { logger.setSourceLocation( "data/VertexData.ts" , 82 ); logger.assert(iStride <= this.stride, "stride in VertexDeclaration grather than stride in construtor"); }
                                                                       ;

		    this.declarationChanged(this._pVertexDeclaration);

		    return true;
		}

		/**@inline*/  getVertexElementCount():  number  {
			return this._pVertexDeclaration.length;
		}

		hasSemantics(sUsage: string): bool {
			if (this._pVertexDeclaration != null) {
		        return this._pVertexDeclaration.hasSemantics(sUsage);
		    }

		    return false;
		}

		destroy(): void {
			this._pVertexDeclaration = null;
    		this._iLength = 0;
		}

		extend(pDecl: IVertexDeclaration, pData: ArrayBufferView = null): bool {
			pDecl = createVertexDeclaration(pDecl);

			if (isNull(pData)) {
				pData = new Uint8Array(this.length * pDecl.stride);
			}
			else {
				pData = new Uint8Array(pData.buffer);
			}

		    { logger.setSourceLocation( "data/VertexData.ts" , 116 ); logger.assert(this.length === pData.byteLength / pDecl.stride, 'invalid data size for extending'); } ;

		    var nCount:  number  = this._iLength;
//strides modifications
		    var nStrideNew:  number  = pDecl.stride;
		    var nStridePrev:  number  = this.stride;
		    var nStrideNext:  number  = nStridePrev + nStrideNew;
//total bytes after extending
		    var nTotalSize:  number  = nStrideNext * this.length;
		    var pDeclNew: IVertexDeclaration = this.getVertexDeclaration().clone();

//data migration
		    var pDataPrev: Uint8Array = new Uint8Array(<ArrayBuffer>this.getData());
		    var pDataNext: Uint8Array = new Uint8Array(nTotalSize);

		    for (var i:  number  = 0, iOffset:  number ; i < nCount; ++i) {
		        iOffset = i * nStrideNext;
		        pDataNext.set(pDataPrev.subarray(i * nStridePrev, (i + 1) * nStridePrev), iOffset);
		        pDataNext.set((<Uint8Array>pData).subarray(i * nStrideNew, (i + 1) * nStrideNew), iOffset + nStridePrev);
		    }

		    if (!pDeclNew.extend(pDecl)) {
		        return false;
		    }

		    if (!this.resize(nCount, pDeclNew)) {
		        return false;
		    }

		    return this.setData(pDataNext, 0, nStrideNext);
		}


		resize(nCount:  number , pDecl?: IVertexDeclaration): bool;
		resize(nCount:  number , iStride?:  number ): bool;
		resize(nCount:  number , pDecl?: any) {
			var iStride:  number  = 0;
		    var iOldOffset:  number  = this.byteOffset;
		    var pOldVertexBuffer: IVertexBuffer;
		    var pOldVertexDeclaration: IVertexDeclaration;
		    var iOldStride:  number

//debug_print("VertexData (offset: " + this.byteOffset + ") resized from " + this.byteLength + " to ", arguments);

		    if (arguments.length == 2) {
		        if (isInt(pDecl)) {
		            iStride = < number >pDecl;
		        }
		        else {
		            iStride = (<IVertexDeclaration>pDecl).stride;
		        }

		        if (nCount * iStride <= this.byteLength) {
		            this._iLength = nCount;
		            this._iStride = iStride;
		            this._pVertexDeclaration = null;

		            if (!isInt(pDecl)) {
		                this.setVertexDeclaration(pDecl);
		            }

		            this.resized(this.byteLength);
		            return true;
		        }
		        else {
		            pOldVertexBuffer = this.buffer;

		            pOldVertexBuffer.freeVertexData(this);

		            if (pOldVertexBuffer.getEmptyVertexData(nCount, pDecl, this) !== this) {
		                return false;
		            }

		            if (this.byteOffset != iOldOffset) {
		                { logger.setSourceLocation( "data/VertexData.ts" , 190 ); logger.warning("vertex data moved from " + iOldOffset + " ---> " + this.byteOffset); } ;
		                this.relocated(iOldOffset, this.byteOffset);
		            }

		            this.resized(this.byteLength);
		            return true;
		        }
		    }
		    else if (arguments.length == 1) {
		        if (nCount <= this.length) {
		            this._iLength = nCount;
		            this.resized(this.byteLength);
		            return true;
		        }
		        else {
		            pOldVertexBuffer = this.buffer;
		            pOldVertexDeclaration = this.getVertexDeclaration();
		            iOldStride = this.stride;

		            pOldVertexBuffer.freeVertexData(this);

		            if (pOldVertexBuffer.getEmptyVertexData(nCount, iOldStride, this) == null) {
		                return false;
		            }

		            this.setVertexDeclaration(pOldVertexDeclaration);

		            if (this.byteOffset != iOldOffset) {
		                { logger.setSourceLocation( "data/VertexData.ts" , 218 ); logger.warning("vertex data moved from " + iOldOffset + " ---> " + this.byteOffset); } ;
		                this.relocated(iOldOffset, this.byteOffset);
		            }

		            this.resized(this.byteLength);
		            return true;
		        }
		    }

		    return false;
		}

		applyModifier(sUsage: string, fnModifier: IBufferDataModifier): bool {
			var pData = this.getTypedData(sUsage);
		    fnModifier(pData);
		    return this.setData(pData, sUsage);
		}

//FIX ME:
//если известно sUsage, зачем нужет iSize?
		setData(pData: ArrayBufferView, iOffset:  number , iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView, sUsage?: string, iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView): bool {
			var iOffset:  number ;
			var iSize:  number ;
			var nCountStart:  number ;
			var nCount:  number ;

			var iStride:  number ;
			var pVertexBuffer: IVertexBuffer = this._pVertexBuffer;
			var pBackupBuf: Uint8Array;
			var pDataU8: Uint8Array;
			var k:  number ;
			var iOffsetBuffer:  number ;
			var pDeclaration: IVertexDeclaration = this._pVertexDeclaration;
			var pElement: IVertexElement;

			switch (arguments.length) {
		        case 5:
		        	if(isString(arguments[1])){
		        		iOffset = this._pVertexDeclaration.findElement(arguments[1]).offset;
		        	}
		        	else {
		        		iOffset = arguments[1];
		        	}

		        	iSize = arguments[2];
		        	nCountStart = arguments[3];
		        	nCount = arguments[4];

		            iStride = this.stride;
		            pDataU8 = new Uint8Array(pData.buffer);
		            if (iStride != iSize) {
//FIXME: очень тормознутое место, крайне медленно работает...
						if(pVertexBuffer.isBackupPresent() && nCount > 1) {
// console.log(pVertexBuffer.byteLength);
							pBackupBuf = new Uint8Array(pVertexBuffer.byteLength);
							pVertexBuffer.readData(pBackupBuf);

							iOffsetBuffer = this.byteOffset;

							for (var i = nCountStart; i < nCount + nCountStart; i++) {
								for(k = 0; k < iSize; k++) {
									pBackupBuf[iStride * i + iOffset + iOffsetBuffer + k] =
										pDataU8[iSize * (i - nCountStart) + k];
								}
							}

							pVertexBuffer.writeData(pBackupBuf, 0, pVertexBuffer.byteLength);
						}
						else {
							for (var i:  number  = 0; i < nCount; i++) {
								var iCurrent:  number  = i + nCountStart;

								pVertexBuffer.writeData(
/*pData.buffer.slice*/

										pDataU8.subarray( iSize * i, iSize * (i + 1)),
										iStride * iCurrent + iOffset + this.byteOffset,
										iSize);
							}
						}
		            }
		            else {

		                pVertexBuffer.writeData(
/*pData.buffer.slice*/

//stride == size => iOffset = 0;
		                	pDataU8.subarray(0 ,
		                		iStride * nCount),
/*iOffset + */
		                	              this.byteOffset + iStride * nCountStart,
		                    iStride * nCount);
		            }

		            this.updated();
		            return true;
		        case 4:
		            pElement = null;

		            if (isString(arguments[1])) {
		                pElement = pDeclaration.findElement(arguments[1]);

		                if (pElement) {
		                    return this.setData(
		                        pData,
		                        pElement.offset,
		                        pElement.size,
		                        arguments[2],
		                        arguments[3]);
		                }

		                return false;
		            }

		       		iOffset = arguments[1];
		       		iSize = arguments[2];
		            nCountStart = arguments[3] || 0;
		            nCount = pData.byteLength / iSize;

		            return this.setData(pData, iOffset, iSize, nCountStart, nCount);


		        case 2:
		        case 3:
		            var pDeclaration: VertexDeclaration = this._pVertexDeclaration,
		                pElement: VertexElement = null;

		            if (isString(arguments[1])) {
		                pElement = pDeclaration.findElement(arguments[1]);

		                if (pElement) {
//nCountStart = arguments[2] || 0
		                    nCountStart = 0;
			                nCount = pData.buffer.byteLength / pElement.size;

		                    return this.setData(
		                    	pData,
		                        pElement.offset,
		                        pElement.size,
		                       	nCountStart,
		                        nCount);
		                }

		                return false
		            }
		            else if (arguments.length === 3) {
		            	iOffset = arguments[1];
		            	iSize = arguments[2];
		                nCountStart = 0;
		                nCount = pData.byteLength / iSize;

		                return this.setData(pData, iOffset, iSize, nCountStart, nCount);
		            }

		            return false;

		        case 1:
		            return this.setData(pData, this._pVertexDeclaration.element(0).usage);
		        default:
		            return false;
		    }
		}


		getData(): ArrayBuffer;
		getData(iOffset:  number , iSize:  number , iFrom?:  number , iCount?:  number ): ArrayBuffer;
		getData(sUsage: string): ArrayBuffer;
		getData(sUsage: string, iFrom:  number , iCount:  number ): ArrayBuffer;
		getData(): ArrayBuffer {
			switch (arguments.length) {
		        case 4:
		        case 2:
		            if (isString(arguments[0])) {
						return null;
		            }

		            var iOffset:  number  = arguments[0];
		            var iSize:  number  = arguments[1];
		            var iFrom:  number  = 0;
		            var iCount:  number  = this._iLength;

		            if(arguments.length === 4){
		            	iFrom = arguments[2] || 0;
		            	iCount = arguments[3] || this._iLength;
		            }

		            iCount = math.min(iCount, this._iLength);

		            var iStride:  number  = this.stride;
		            var pBufferData: Uint8Array = new Uint8Array(iSize * iCount);

	            	for (var i:  number  = 0; i < iCount; i++) {
	            		var iCurrent:  number  = iFrom + i;
	            		var isOk: bool = this._pVertexBuffer.readData(iStride * iCurrent + iOffset + this.byteOffset,
	            			iSize, pBufferData.subarray(i * iSize, (i + 1) * iSize));
		            	{ logger.setSourceLocation( "data/VertexData.ts" , 412 ); logger.assert(isOk,"cannot read buffer"); } ;

//pBufferData.set(new Uint8Array(), i * iSize);
		            }

		            return pBufferData.buffer;

		        case 3:
		        case 1:
		            var pDeclaration: IVertexDeclaration = this._pVertexDeclaration,
		                pElement: IVertexElement = null;

		            if (isString("string")) {
		                pElement = pDeclaration.findElement(arguments[0]);

		                if (isDefAndNotNull(pElement)) {

		                    return this.getData(
		                        pElement.offset,
		                        pElement.size,
		                        arguments.length === 3 ? arguments[1] : 0,
		                        arguments.length === 3 ? arguments[2] : this._iLength
		                        );
		                }
		                return null;
		            }

		            return null;

		        case 0:
		            return this.getData(0, this._pVertexDeclaration.stride);
		        default:
		            return null;
		    }
		}

		getTypedData(sUsage: string, iFrom?:  number , iCount?:  number ): ArrayBufferView {
		    var pVertexElement: IVertexElement = this._pVertexDeclaration.findElement(sUsage);

		    if (pVertexElement) {
		        return util.abtota(this.getData(sUsage, iFrom, iCount), pVertexElement.type);
		    }

		    return null;
		}

		/**@inline*/  getBufferHandle():  number  {
			return this._pVertexBuffer.resourceHandle;
		}

		toString(): string {


			    var s: string = "";

			    s += "          VERTEX DATA  #" + this.id + "\n";
			    s += "---------------+-----------------------\n";
			    s += "        BUFFER : " + this.getBufferHandle() + "\n";
			    s += "          SIZE : " + this.byteLength + " b.\n";
			    s += "        OFFSET : " + this.byteOffset + " b.\n";
			    s += "---------------+-----------------------\n";
			    s += " MEMBERS COUNT : " + this.length + " \n";
			    s += "        STRIDE : " + this.stride + " \n";
			    s += "---------------+-----------------------\n";
			    s += this.getVertexDeclaration().toString();

			    return s;

		}



		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return VertexData._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;

		relocated (iFrom, iTo): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).relocated; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, iFrom, iTo) : _broadcast[i].listener (_recivier, iFrom, iTo) ; } } } ; ;
		resized (iByteLength): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).resized; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, iByteLength) : _broadcast[i].listener (_recivier, iByteLength) ; } } } ; ;
		declarationChanged (pDecl): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).declarationChanged; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pDecl) : _broadcast[i].listener (_recivier, pDecl) ; } } } ; ;
		updated (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).updated; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
	}

}











module akra.core.pool.resources {
	export class MemoryBuffer extends HardwareBuffer {

		protected _pData: Uint8Array;

		/**@inline*/  get byteLength():  number  {
			return this._pData.byteLength;
		}

		/**@inline*/  get length():  number  {
			return this.byteLength;
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.DYNAMIC): bool {

			((iFlags) &= ~(EHardwareBufferFlags.BACKUP_COPY | EHardwareBufferFlags.DISCARDABLE | EHardwareBufferFlags.ALIGNMENT))
                                   ;

			var isCreated: bool = super.create(0, iFlags | EHardwareBufferFlags.SOFTWARE);

			this._pData = new Uint8Array(iByteSize);

			return isCreated;
		}

		destroy(): void {
			super.destroy();
			this._pData = null;
		}

		resize(iSize:  number ): bool {
			var pData: Uint8Array = new Uint8Array(iSize);

			if(iSize >= this.byteLength){
				pData.set(this._pData);
			}
			else{
				pData.set(this._pData.subarray(0, iSize));
			}

			this._pData = pData;
			this.notifyAltered();

			return true;
		}

		lockImpl(iOffset:  number , iLength:  number , iLockFlags:  number ): Uint8Array {
			return this._pData.subarray(iOffset, iOffset + iLength);
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(): bool {
			var ppDest: ArrayBufferView;
			var iOffset:  number ;
			var iSize:  number ;

			if (arguments.length < 3) {
				ppDest = arguments[0];
				iOffset = 0;
				iSize = ppDest.byteLength;
			}
			else {
				iOffset = arguments[0];
				iSize = arguments[1];
				ppDest = arguments[2];
			}

			{ logger.setSourceLocation( "MemoryBuffer.ts" , 75 ); logger.assert((iOffset + iSize) <= this.byteLength); } ;
			memcpy((<ArrayBufferView>ppDest).buffer, (<ArrayBufferView>ppDest).byteOffset, this._pData.buffer, iOffset, iSize);

			return true;
		}

// writeData(pData: Uint8Array, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number  = 0, iSize?:  number  = pData.byteLength, bDiscardWholeBuffer: bool = false): bool{
// writeData(pData: any, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer: bool = false): bool { 

			{ logger.setSourceLocation( "MemoryBuffer.ts" , 85 ); logger.assert((iOffset + iSize) <= this.byteLength); } ;

			if(isDefAndNotNull(pData)){
				memcpy(this._pData.buffer, iOffset, (<ArrayBufferView>pData).buffer, (<ArrayBufferView>pData).byteOffset, iSize);
			}
			this.notifyAltered();

			return true;
		}
	}
}



module akra.core.pool.resources {
	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class VertexBuffer extends HardwareBuffer implements IVertexBuffer {
		protected _pVertexDataArray: IVertexData[] = [];
		protected _iDataCounter:  number  = 0;

		/**@inline*/  get type(): EVertexBufferTypes { return EVertexBufferTypes.UNKNOWN; }
		/**@inline*/  get length():  number  { return this._pVertexDataArray.length; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

// create(iByteSize: uint, iFlags?: uint, pData?: Uint8Array): bool;
		create(iByteSize:  number , iFlags?:  number , pData?: ArrayBufferView): bool{
// create(iByteSize: uint, iFlags?: uint, pData?: any): bool {
			super.create(0, iFlags || 0);

			if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
				this._pBackupCopy = new MemoryBuffer();
				this._pBackupCopy.create(iByteSize);
				this._pBackupCopy.writeData(pData, 0, iByteSize);
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			this._pBackupCopy.destroy();
			this.freeVertexData();

			this._iDataCounter = 0;
		}

		getVertexData(i:  number ): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pElements: IVertexElement[]): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pDecl: IVertexDeclaration): IVertexData;
		getVertexData(iOffset:  number , iCount?:  number , pData?: any): IVertexData {
			if (arguments.length < 2) {
				return this._pVertexDataArray[< number >arguments[0]];
			}

			var pDecl: IVertexDeclaration = createVertexDeclaration(pData);
			var pVertexData: IVertexData = new data.VertexData(this, this._iDataCounter ++, iOffset, iCount, pDecl);

			this._pVertexDataArray.push(pVertexData);
			this.notifyAltered();

			return pVertexData;
		}


		getEmptyVertexData(iCount:  number , pElements: IVertexElement[], ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDecl: IVertexDeclaration, ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pSize:  number , ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDeclData: any, ppVertexDataIn?: IVertexData): IVertexData {
			var pDecl: IVertexDeclaration = null;
			var pHole: IBufferHole[] = [];
			var i:  number ;
			var pVertexData: IVertexData;
			var iTemp:  number ;
			var iStride:  number  = 0;
			var iAligStart:  number ;
			var iNewSize:  number  = 0;

			while(true) {

				pHole[0] = {start:0, end: this.byteLength};

				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					pVertexData = this._pVertexDataArray[k];

					for(i = 0; i < pHole.length; i++) {
//Полностью попадает внутрь
						if(pVertexData.byteOffset > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							iTemp = pHole[i].end;
							pHole[i].end=pVertexData.byteOffset;
							pHole.splice(i + 1, 0, {start: pVertexData.byteOffset + pVertexData.byteLength, end: iTemp});
							i--;
						}
						else if(pVertexData.byteOffset == pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
						}
						else if(pVertexData.byteOffset > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {

						}
						else if(pVertexData.byteOffset == pHole[i].start &&
							pVertexData.byteLength == (pHole[i].end - pHole[i].start)) {
							pHole.splice(i, 1);
							i--;
						}
//Перекрывает снизу
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
						}
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {
							pHole.splice(i,1);
							i--;
						}
//Перекрывается сверху
						else if(pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end &&
							pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
							pHole[i].end=pVertexData.byteOffset;
						}
						else if(pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end &&
							pVertexData.byteOffset == pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
							pHole.splice(i,1);
							i--;
						}
//полнстью перекрывает
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end) {
							i--;
						}
					}
				}


				pHole.sort((a: IBufferHole, b: IBufferHole): number => ((a.end - a.start) - (b.end - b.start)));


				if(!isInt(pDeclData)) {
					pDecl = createVertexDeclaration(pDeclData);
					iStride = pDecl.stride;
				}
				else {
					iStride = pDeclData;
				}
// console.log(arguments[0], arguments[1].toString());
// console.log("Buffer size >", this.byteLength, iCount * iStride)

				for (i = 0; i < pHole.length; i++) {
					iAligStart = this.isAligned() ?
						math.alignUp(pHole[i].start, math.nok(iStride,4)):
						math.alignUp(pHole[i].start, iStride);

					if((pHole[i].end - iAligStart) >= iCount * iStride) {
						if(arguments.length == 2) {
							pVertexData = new data.VertexData(this, this._iDataCounter ++, iAligStart, iCount, pDeclData);
							this._pVertexDataArray.push(pVertexData);

							this.notifyAltered();
							return pVertexData;
						}
						else if(arguments.length == 3) {
							((<any>ppVertexDataIn).constructor).call(ppVertexDataIn, this, ppVertexDataIn.id, iAligStart, iCount, pDeclData);
							this._pVertexDataArray.push(ppVertexDataIn);

							this.notifyAltered();
							return ppVertexDataIn;
						}

						return null;
					}
				}

				iNewSize = math.max(this.byteLength * 2, this.byteLength + iCount * iStride);

				if (this.resize(iNewSize) == false) {
					{ logger.setSourceLocation( "core/pool/resources/VertexBuffer.ts" , 182 ); logger.warning("cannot resize buffer from " + this.byteLength + " bytes to " + iNewSize + " bytes "); }
                                                            ;
					break;
				}
			}

			return null;
		}


		freeVertexData(): bool;
		freeVertexData(pVertexData?: IVertexData): bool {
			if(arguments.length == 0) {
				for(var i:  number  = 0; i < this._pVertexDataArray.length; i ++) {
					this._pVertexDataArray[Number(i)].destroy();
				}

				this._pVertexDataArray = null;
			}
			else {
				for(var i:  number  = 0; i < this._pVertexDataArray.length; i ++) {
					if(this._pVertexDataArray[i] == pVertexData) {
						pVertexData.destroy();

						this._pVertexDataArray.splice(i, 1);
						this.notifyAltered();
						return true;
					}
				}

				return false;
			}

			this.notifyAltered();
			return true;
		}

		allocateData(pElements: IVertexElementInterface[], pData: ArrayBufferView): IVertexData;
		allocateData(pDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
		allocateData(pDeclData: any, pData: ArrayBufferView): IVertexData {
			var pDecl: IVertexDeclaration = createVertexDeclaration(pDeclData);

			var pVertexData: IVertexData;
		    var iCount:  number  = pData.byteLength / pDecl.stride;

		    { logger.setSourceLocation( "core/pool/resources/VertexBuffer.ts" , 226 ); logger.assert(iCount === math.floor(iCount), 'Data size should be a multiple of the vertex declaration.'); } ;

		    pVertexData = this.getEmptyVertexData(iCount, pDecl);

		    { logger.setSourceLocation( "core/pool/resources/VertexBuffer.ts" , 230 ); logger.assert(!isNull(pVertexData), "Could not allocate vertex data!"); } ;

		    pVertexData.setData(pData, 0, pDecl.stride);

		    return pVertexData;
		}

	}

	export  /**@inline*/  function isVBO(pBuffer: IVertexBuffer): bool {
		return pBuffer.type === EVertexBufferTypes.VBO;
	}

	export  /**@inline*/  function isTBO(pBuffer: IVertexBuffer): bool {
		return pBuffer.type === EVertexBufferTypes.TBO;
	}
}







module akra.webgl {

	export class WebGLVertexBuffer extends core.pool.resources.VertexBuffer implements IVertexBuffer {
		protected _iByteSize:  number ;

		protected _pWebGLBuffer: WebGLBuffer;

		private _pLockData: Uint8Array = null;
		protected _sCS: string = null;

		/**@inline*/  get type(): EVertexBufferTypes { return EVertexBufferTypes.VBO; }
		/**@inline*/  get byteLength():  number  { return this._iByteSize; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

// create(iByteSize: uint, iFlags: uint = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool{
// create(iByteSize: uint, iFlags: uint = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			iByteSize = math.max(iByteSize,  1024 );

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    { logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 45 ); logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated"); } ;

			this._iByteSize = iByteSize;
		    this._iFlags = iFlags;
		    pWebGLContext = pWebGLRenderer.getWebGLContext();

		    { logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 51 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); } ;

//Софтварного рендеринга буфера у нас нет
		    { logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 54 ); logger.assert(!this.isSoftware(), "no sftware rendering"); } ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 62 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера"); }
                                                                                                                         ;


		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        { logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 68 ); logger.criticalError("Не удалось создать буфер"); } ;

		        this.destroy();
		        return false;
		    }

		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);
		    pWebGLContext.bufferData( 0x8892 , this._iByteSize, getWebGLUsage(this._iFlags));

		    if (isDefAndNotNull(pData)) {
/*pWebGLContext.bufferSubData(
		        	GL_ARRAY_BUFFER, 0, isArrayBuffer(pData)? <ArrayBuffer>pData: (<Uint8Array>pData).buffer);*/


				pWebGLContext.bufferSubData( 0x8892 , 0, pData.buffer);

		    }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);

			this._pWebGLBuffer = null;
			this._iByteSize = 0;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 102 ); logger.assert(!isNull(this._pWebGLBuffer), "Буффер еще не создан"); } ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {

			{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 122 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); } ;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);

			{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 129 ); logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера"); } ;
			{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 130 ); logger.assert(this.byteLength >= iOffset + iSize, "Данные выйдут за предел буфера"); } ;

			var pU8Data: Uint8Array = null;

			if (isArrayBuffer(pData)) {
				pU8Data = new Uint8Array(pData);
			}
			else {
				pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
			}

			pU8Data = pU8Data.subarray(0, iSize);

			pWebGLContext.bufferSubData( 0x8892 , iOffset, pU8Data);

			if (this.isBackupPresent()) {
		        this._pBackupCopy.writeData(pU8Data, iOffset);
		    }

		    this.notifyAltered();

			return true;
		}

		resize(iSize:  number ): bool {
			var eUsage:  number ;
			var pData: Uint8Array;
			var iMax:  number  = 0;
			var pVertexData: IVertexData;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if(!this.isBackupPresent()) {
				{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 164 ); logger.log("Not resized, because backup not present!"); } ;
				return false;
			}

			{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 168 ); logger.log("WebGLVertexBuffer resized from " + this.byteLength + " to " + iSize + "(" + this.getGuid() + ")"); } ;
// debug_print(__CALLSTACK__);


			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					pVertexData = this._pVertexDataArray[k];

					if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
						iMax = pVertexData.byteOffset + pVertexData.byteLength;
					}
				}

				{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 182 ); logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер"); }
                                                                                                                                         ;
			}

			if(pWebGLContext.isBuffer(this._pWebGLBuffer)) {
				pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
			}

			eUsage = getWebGLUsage(this._iFlags);

		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        { logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 194 ); logger.criticalError("Не удалось создать буфер"); } ;

		        this.destroy();
		        return false;
		    }


		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);
			pWebGLContext.bufferData( 0x8892 , iSize, eUsage);

			pData = new Uint8Array(this._iByteSize);

			if (!this.readData(pData)) {
				{ logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 207 ); logger.warning("cannot read data from buffer"); } ;
				return false;
			}


			this.writeData(pData, 0, this._iByteSize);
			this._pBackupCopy.resize(iSize);
			this._iByteSize = iSize;

			this.notifyAltered();

			return true;
		}

		/**@inline*/  getWebGLBuffer(): WebGLBuffer {
			return this._pWebGLBuffer;
		}

		protected lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		protected unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		protected copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}
	}
}






























module akra.webgl {
	export class WebGLVertexTexture extends core.pool.resources.VertexBuffer implements IVertexBuffer {
		protected _iWidth:  number  = 0;
		protected _iHeight:  number  = 0;

		protected _pWebGLTexture: WebGLTexture = null;
		protected _eWebGLFormat:  number ;
		protected _eWebGLType:  number ;

		protected _ePixelFormat: EPixelFormats = EPixelFormats.FLOAT32_RGBA;
//переменная нужна, чтобы проигнорировать обновление копии, обычно, это не требуется
		protected _bForceUpdateBackupCopy: bool = true;

/*vertex data for header updating*/

		protected _pHeader: IVertexData = null;

		private _pLockData: Uint8Array = null;

		/**@inline*/  get type(): EVertexBufferTypes { return EVertexBufferTypes.TBO; }
		/**@inline*/  get byteLength():  number  { return pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, this._ePixelFormat); }

		/**@inline*/  getWebGLTexture(): WebGLTexture {
			return this._pWebGLTexture;
		}

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

		/**@inline*/  _getWidth():  number {
			return this._iWidth;
		}

		/**@inline*/  _getHeight():  number {
			return this._iHeight;
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			var iMinWidth:  number  =  32 ;
			var iWidth:  number , iHeight:  number ;
			var pTextureData: Uint8Array = null;
			var pDataU8: Uint8Array = pData;

/*header size*/
			var iAdditionalHeaderSize:  number  = (isDefAndNotNull(pData)) ? 32                 : 0;

			iByteSize = math.max(iByteSize + iAdditionalHeaderSize, pixelUtil.getMemorySize(iMinWidth, iMinWidth, 1, this._ePixelFormat));

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pPOTSize:  number [] = math.calcPOTtextureSize(math.ceil(iByteSize / pixelUtil.getNumElemBytes(this._ePixelFormat)));
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    iWidth = pPOTSize[0];
		    iHeight = pPOTSize[1];

		    { logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 85 ); logger.assert(this._pWebGLTexture == null, "webgl texture already allocated"); } ;

			this._iWidth = iWidth;
			this._iHeight = iHeight;
		    this._iFlags = iFlags;

		    { logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 91 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); } ;

//Софтварного рендеринга буфера у нас нет
		    { logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 94 ); logger.assert(!this.isSoftware(), "no software rendering"); } ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			{ logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 102 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера"); }
                                                                                                                         ;

			{ logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 105 ); logger.assert(loadExtension(pWebGLContext, "OES_texture_float"), "OES_texture_float extension is necessary for correct work."); }
                                                                 ;

		    this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();
		    this._eWebGLFormat = getWebGLFormat(this._ePixelFormat);
		    this._eWebGLType = getWebGLDataType(this._ePixelFormat);

		    if (!this._pWebGLTexture) {
		        { logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 112 ); logger.criticalError("Не удалось создать буфер"); } ;

		        this.destroy();
		        return false;
		    }

		    if (isDefAndNotNull(pData)) {

		    	if (pData.BYTES_PER_ELEMENT > 1) {
		    		pDataU8 = new Uint8Array(pData, pData.byteOffset, pData.byteLength);
		    	}

		    	pTextureData = new Uint8Array(this.byteLength);
		    	pTextureData.set(pDataU8);
		    }

		    pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);
		    pWebGLContext.texImage2D( 0x0DE1 , 0, this._eWebGLFormat,
		    	this._iWidth, this._iHeight, 0,  this._eWebGLFormat, this._eWebGLType, pTextureData);

		    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MAG_FILTER, pWebGLContext.NEAREST);
		    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MIN_FILTER, pWebGLContext.NEAREST);
		    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_S, pWebGLContext.CLAMP_TO_EDGE);
		    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_T, pWebGLContext.CLAMP_TO_EDGE);

		    pWebGLRenderer.bindWebGLTexture( 0x0DE1 , null);

//create header
		    this._pHeader = this.allocateData([VE_VEC2(DeclarationUsages.TEXTURE_HEADER)], this._header());


/**
		    * update program
		    **/


		    var pProgram: IShaderProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_vertex_texture_update");

	        if (isNull(pProgram)) {
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_vertex_texture_update");
	        	pProgram.create(
	        	"																									\n	        	uniform sampler2D sourceTexture;																	\n				attribute vec4  VALUE;																				\n				attribute float INDEX;																				\n				attribute float SHIFT;																				\n				                      																				\n				uniform vec2 size;																					\n				varying vec4 color;																					\n				                   																					\n				void main(void){																					\n				    vec4 value = VALUE;																				\n				    float  serial = INDEX;																			\n				                          																			\n				    int shift = int(SHIFT);																			\n				    if (shift != 0) {																				\n				        color = texture2D(sourceTexture,                                        					\n				            vec2((mod(serial, size.x) +.5 ) / size.x, (floor(serial / size.x) + .5) / size.y)		\n				            );																						\n																													\n																													\n				        if (shift == 1) {																			\n				            color = vec4(color.r, value.gba);														\n				        }																							\n				        else if (shift == 2) {																		\n				            color = vec4(color.rg, value.ba);														\n				        }																							\n				        else if (shift == 3) {																		\n				            color = vec4(color.rgb, value.a);														\n				        }																							\n				        else if (shift == -1) {																		\n				            color = vec4(value.r, color.gba);														\n				        }																							\n				        else if (shift == -2) {																		\n				            color = vec4(value.rg, color.ba);														\n				        }																							\n				        else {																						\n				            color = vec4(value.rgb, color.a);														\n				        }																							\n				    }																								\n				    else {																							\n				        color = value;																				\n				    }																								\n				    gl_PointSize = 1.;																				\n				    gl_Position = vec4(2. * (mod(serial, size.x) + .5) / size.x - 1.,								\n				                    2. * (floor(serial / size.x)  + .5) / size.y - 1., 0., 1.);						\n				}																									\n				",
				"									\n				#ifdef GL_ES                        \n				    precision highp float;          \n				#endif								\n				varying vec4 color;                 \n				                                    \n				void main(void) {                   \n				    gl_FragColor = color;           \n				}                                   \n				");
	        }

/**
		    * resize program
		    **/


	        pProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_vertex_texture_resize");

	        if (isNull(pProgram)) {
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_vertex_texture_resize");
	        	pProgram.create(
	        	"																									\n	        	attribute float INDEX;																				\n	        																										\n	        	uniform sampler2D sourceTexture;																	\n				                      																				\n				uniform vec2 v2fSrcTexSize;																			\n				uniform vec2 v2fDstTexSize;																			\n																													\n				varying vec4 v4fValue;																				\n				                   																					\n				void main(void){																					\n					                       																			\n				    vec2 v2fSrcPosition = vec2((mod(INDEX, v2fSrcTexSize.x) + 0.5)/v2fSrcTexSize.x,					\n				    						   (floor(INDEX/v2fSrcTexSize.x) + 0.5)/v2fSrcTexSize.y);				\n	        																										\n	        		vec2 v2fDstPosition = vec2((mod(INDEX, v2fDstTexSize.x) + 0.5)/v2fDstTexSize.x,					\n				    						   (floor(INDEX/v2fDstTexSize.x) + 0.5)/v2fDstTexSize.y);				\n	        																										\n	        		v4fValue = texture2D(sourceTexture, v2fSrcPosition);											\n	        																										\n	        		gl_PointSize = 1.;																				\n	        		gl_Position = vec4(v2fDstPosition*2. - 1., 0., 1.);												\n				}																									\n				",
				"									\n				#ifdef GL_ES                        \n				    precision highp float;          \n				#endif								\n				varying vec4 v4fValue;              \n				                                    \n				void main(void) {                   \n				    gl_FragColor = v4fValue;        \n				}                                   \n				");
	        }

	        if(isNull(WebGLVertexTexture._pWebGLBuffer1)){
		        	WebGLVertexTexture._pWebGLBuffer1 = pWebGLRenderer.createWebGLBuffer();
	        }
	        if(isNull(WebGLVertexTexture._pWebGLBuffer2)){
	        	WebGLVertexTexture._pWebGLBuffer2 = pWebGLRenderer.createWebGLBuffer();
	        }
	        if(isNull(WebGLVertexTexture._pWebGLBuffer3)){
	        	WebGLVertexTexture._pWebGLBuffer3 = pWebGLRenderer.createWebGLBuffer();
	        }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

			this._pWebGLTexture = null;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			{ logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 281 ); logger.assert(!isNull(this._pWebGLTexture), "Буффер еще не создан"); } ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {

/*предпологается, что float*/
			var iTypeSize:  number  		= pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8,
/*число float'ов в пикселе*/
		        nElementsPerPix:  number  	= pixelUtil.getComponentCount(this._ePixelFormat),
/*номер float'a с которого начинается обновление*/
		        iFrom:  number ,
/*исло float'ов для обновления*/
		        iCount:  number ;
/*данные для обновления*/
			var pBufferData: Float32Array;

/*смещение внутри первого пикселя*/
		    var iLeftShift:  number ,
/*смещение внутри последнего пикселя*/
		        iRightShift:  number ,
/*пиксель с которого начинается обновление*/
		        iBeginPix:  number ,
/*пиксель на котором заканчивается обновление*/
		        iEndPix:  number ,
/*число пикселей*/
		        nPixels:  number ,
		        nElements:  number ;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    var pDataU8: Uint8Array = pData;

		    { logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 319 ); logger.assert(bDiscardWholeBuffer === false, "Discard option temporary unsupported."); } ;

		    if (pData.BYTES_PER_ELEMENT > 1) {
		    	pDataU8 = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
		    }

		    iOffset = iOffset || 0;
		    iSize = iSize || pData.byteLength;

		    pDataU8 = pDataU8.subarray(0, iSize);

		    if (this.byteLength < iOffset + iSize) {
		        this.resize(iOffset + iSize);
		    }

		    if (this.isBackupPresent() && this._bForceUpdateBackupCopy) {
		        this._pBackupCopy.writeData(pDataU8, iOffset);
		    }

		    this._bForceUpdateBackupCopy = true;

		    { logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 340 ); logger.assert(iOffset % iTypeSize === 0 && iSize % iTypeSize === 0, "Incorrect data size or offset"); } ;

		    iFrom 	= iOffset / iTypeSize;
		    iCount 	= iSize / iTypeSize;

		    iLeftShift 	= iFrom % nElementsPerPix;
		    iRightShift = ((iFrom + iCount) % nElementsPerPix);
		    iBeginPix 	= Math.floor(iFrom / nElementsPerPix);
		    iEndPix 	= Math.floor((iFrom + iCount) / nElementsPerPix);
		    nPixels 	= Math.ceil((iFrom + iCount) / nElementsPerPix) - Math.floor(iFrom / nElementsPerPix);
		    nElements 	= nPixels * nElementsPerPix;

		    pBufferData = new Float32Array(pDataU8.buffer, pDataU8.byteOffset);

		    if (iLeftShift === 0 && iRightShift === 0) {
		        var iWidth:  number  	= this._iWidth;
		        var iYmin:  number  		= Math.floor(iBeginPix / iWidth);
		        var iYmax:  number  		= Math.ceil(iEndPix / iWidth);
		        var iXbegin:  number  	= iBeginPix % iWidth;
		        var iXend:  number  		= iEndPix % iWidth;
		        var iHeight:  number  	= iYmax - iYmin;

		        var iBeginElement:  number  	= 0,
		        	iEndElement:  number  	= 0;

//hack: if iEndPixel is first pixel from next row

		        iXend = (iXend === 0 ? iWidth : iXend);

//FIX THIS, move this function from here...
		        var me = this;
		        function updatePixelRect(iX:  number , iY:  number , iW:  number , iH:  number ): void {
		            iBeginElement = iEndElement;
		            iEndElement = iW * iH * nElementsPerPix + iEndElement;

		            pWebGLRenderer.bindWebGLTexture( 0x0DE1 , me._pWebGLTexture);

		            pWebGLContext.texSubImage2D( 0x0DE1 , 0, iX, iY, iW, iH,
		            	me._eWebGLFormat, me._eWebGLType, pBufferData.subarray(iBeginElement, iEndElement));

		            pWebGLRenderer.bindWebGLTexture( 0x0DE1 , null);
		        };

		        if (iHeight === 1) {
		            updatePixelRect(iXbegin, iYmin, iXend - iXbegin, 1);
		        }
		        else {

		            updatePixelRect(iXbegin, iYmin, iWidth - iXbegin, 1);

		            if (iHeight > 2) {
		                updatePixelRect(0, iYmin + 1, iWidth, iHeight - 2);
		            }

		            updatePixelRect(0, iYmax - 1, iXend, 1);
		        }
		    }
		    else if (this.isBackupPresent()) {
		        var iRealOffset:  number  	= iBeginPix * nElementsPerPix * iTypeSize;
		        var iRealSize:  number  	= nElements * iTypeSize;
		        var pTempData: Uint8Array = <Uint8Array>this._pBackupCopy.lock(iRealOffset, iRealSize);
//var iTotalSize: uint 	= iRealOffset + iRealSize;

//FIX ME:
		        this._pBackupCopy.unlock();

		        this._bForceUpdateBackupCopy = false;

		        return this.writeData(pTempData, iRealOffset, iRealSize);
		    }
		    else {
//console.error(this);

		        var pMarkupDataIndex: Float32Array = new Float32Array(nPixels);
		        var pMarkupDataShift: Float32Array = new Float32Array(nPixels);
		        var pRealData: Float32Array = new Float32Array(nElements);

		        pMarkupDataIndex[0] = iBeginPix;
		        pMarkupDataShift[0] = iLeftShift;

		        pMarkupDataIndex[nPixels - 1] = iBeginPix + nPixels - 1;
		        pMarkupDataShift[nPixels - 1] = -iRightShift;

		        for (var i:  number  = 1; i < nPixels - 1; ++i) {
		            pMarkupDataIndex[i] = iBeginPix + i;
		        }

		        for (var i:  number  = 0; i < iCount; i++) {
		            pRealData[iLeftShift + i] = pBufferData[i];
		        }

		        var pOldFrameBuffer: WebGLFramebuffer = pWebGLRenderer.getParameter( 0x8CA6 );

		        var pWebGLFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
		        var pWebGLProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_vertex_texture_update");

		        var pValueBuffer: WebGLBuffer 		= WebGLVertexTexture._pWebGLBuffer1;
		        var pMarkupIndexBuffer: WebGLBuffer = WebGLVertexTexture._pWebGLBuffer2;
		        var pMarkupShiftBuffer: WebGLBuffer = WebGLVertexTexture._pWebGLBuffer3;

		        { logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 440 ); logger.assert(isDef(pWebGLProgram), "cound not find WEBGL_vertex_texture_update program"); } ;

		        pWebGLRenderer.disableAllWebGLVertexAttribs();

		        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pWebGLFramebuffer);
		        pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

		        pWebGLRenderer.disable( 0x0B71 );
		        pWebGLRenderer.disable( 0x0C11 );
		        pWebGLRenderer.disable( 0x0BE2 );
		        pWebGLRenderer.disable( 0x0B44 );

		        var iValueAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("VALUE");
		        var iIndexAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("INDEX");
		        var iShiftAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("SHIFT");

		        pWebGLContext.enableVertexAttribArray(iValueAttribLocation);
		        pWebGLContext.enableVertexAttribArray(iIndexAttribLocation);
		        pWebGLContext.enableVertexAttribArray(iShiftAttribLocation);

		        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
		        	0x0DE1 , this._pWebGLTexture, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pValueBuffer);
		        pWebGLContext.bufferData( 0x8892 , pRealData,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(iValueAttribLocation, 4,  0x1406 , false, 0, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pMarkupIndexBuffer);
		        pWebGLContext.bufferData( 0x8892 , pMarkupDataIndex,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(iIndexAttribLocation, 1,  0x1406 , false, 0, 0);


		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pMarkupShiftBuffer);
		        pWebGLContext.bufferData( 0x8892 , pMarkupDataShift,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(iShiftAttribLocation, 1,  0x1406 , false, 0, 0);

		        pWebGLRenderer.activateWebGLTexture( 0x84C0 );
		        pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);

		        pWebGLProgram.setInt("sourceTexture", 0);
		        pWebGLProgram.setVec2("size",  Vec2.stackCeil.set(this._iWidth, this._iHeight) );

		        pWebGLContext.viewport(0, 0, this._iWidth, this._iHeight);
		        pWebGLContext.drawArrays( 0x0000 , 0, nPixels);
		        pWebGLContext.flush();

		        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,  0x0DE1 , null, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , null);
		        pWebGLRenderer.bindWebGLTexture( 0x0DE1 , null);

		        pWebGLContext.disableVertexAttribArray(iValueAttribLocation);
		        pWebGLContext.disableVertexAttribArray(iIndexAttribLocation);
		        pWebGLContext.disableVertexAttribArray(iShiftAttribLocation);

//pWebGLRenderer.deleteWebGLBuffer(pValueBuffer);
//pWebGLRenderer.deleteWebGLBuffer(pMarkupShiftBuffer);
//pWebGLRenderer.deleteWebGLBuffer(pMarkupIndexBuffer);

		        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFrameBuffer);
		        pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);
		    }

		    return true;
		}

		resize(iSize:  number ): bool {

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			var iMax:  number  = 0;
			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					var pVertexData: IVertexData = this._pVertexDataArray[k];

					if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
						iMax = pVertexData.byteOffset + pVertexData.byteLength;
					}
				}

				if(iMax > iSize){
					{ logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 523 ); logger.assert(false, "Уменьшение невозможно. Страая разметка не укладывается в новый размер"); }
                                                                                                                                          ;
					return false;
				}
			}

			var pPOTSize:  number [] = math.calcPOTtextureSize(math.ceil(iSize / pixelUtil.getNumElemBytes(this._ePixelFormat)));

			pPOTSize[0] = (pPOTSize[0] <  32 ) ?  32  : pPOTSize[0];
			pPOTSize[1] = (pPOTSize[1] <  32 ) ?  32  : pPOTSize[1];

			if(pPOTSize[0] !== this._iWidth || pPOTSize[1] !== this._iHeight){
				if(this.isBackupPresent()){
					this._iWidth = pPOTSize[0];
					this._iHeight = pPOTSize[1];

					pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);
				    pWebGLContext.texImage2D( 0x0DE1 , 0, this._eWebGLFormat,
				    	this._iWidth, this._iHeight, 0,  this._eWebGLFormat, this._eWebGLType, null);

				    pWebGLRenderer.bindWebGLTexture( 0x0DE1 , null);

				    var iByteLength:  number  = this.byteLength;

/*resing backup copy don't cause data loss*/

				    this._pBackupCopy.resize(iByteLength);

					var pData: Uint8Array = new Uint8Array(iByteLength);

					if (!this.readData(pData)) {
						{ logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 552 ); logger.warning("cannot read data from buffer"); } ;
						return false;
					}

					this.writeData(pData, 0, iByteLength);
				}
				else{
			        var pWebGLProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_vertex_texture_resize");

			        { logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 561 ); logger.assert(isDef(pWebGLProgram), "cound not find WEBGL_vertex_texture_resize program"); } ;

			        pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

//create new texture for resize
					var pTexture : WebGLTexture = pWebGLRenderer.createWebGLTexture();
					pWebGLRenderer.activateWebGLTexture( 0x84C1 );
					pWebGLRenderer.bindWebGLTexture( 0x0DE1 , pTexture);
				    pWebGLContext.texImage2D( 0x0DE1 , 0, this._eWebGLFormat,
				    	pPOTSize[0], pPOTSize[1], 0,  this._eWebGLFormat, this._eWebGLType, null);

				    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MAG_FILTER, pWebGLContext.NEAREST);
				    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MIN_FILTER, pWebGLContext.NEAREST);
				    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_S, pWebGLContext.CLAMP_TO_EDGE);
				    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_T, pWebGLContext.CLAMP_TO_EDGE);

				    var pOldFrameBuffer: WebGLFramebuffer = pWebGLRenderer.getParameter( 0x8CA6 );

			        var pWebGLFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
			        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pWebGLFramebuffer);
			        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
			        	0x0DE1 , pTexture, 0);

			        if(iSize >= this.byteLength) {
/*in other case we already have iMax*/

						for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
							var pVertexData: IVertexData = this._pVertexDataArray[k];

							if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
								iMax = pVertexData.byteOffset + pVertexData.byteLength;
							}
						}
					}

/*предпологается, что float*/
			        var iTypeSize:  number  		= pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8;
/*число float'ов в пикселе*/
		        	var nElementsPerPix:  number  	= pixelUtil.getComponentCount(this._ePixelFormat);
		        	var nPixels:  number  = math.ceil(iMax/iTypeSize/nElementsPerPix);

		        	var pIndexBufferData: Float32Array = new Float32Array(nPixels);
		        	for(var i: number  = 0; i < nPixels; i++){
		        		pIndexBufferData[i] = i;
		        	}

		        	pWebGLRenderer.disableAllWebGLVertexAttribs();

		        	var iIndexAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("INDEX");

		        	pWebGLContext.enableVertexAttribArray(iIndexAttribLocation);

		        	if(isNull(WebGLVertexTexture._pWebGLBuffer1)){
		        		WebGLVertexTexture._pWebGLBuffer1 = pWebGLRenderer.createWebGLBuffer();
		        	}

			        var pIndexBuffer: WebGLBuffer = WebGLVertexTexture._pWebGLBuffer1;

			        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pIndexBuffer);
			        pWebGLContext.bufferData( 0x8892 , pIndexBufferData,  0x88E0 );
			        pWebGLContext.vertexAttribPointer(iIndexAttribLocation, 1,  0x1406 , false, 0, 0);

			        pWebGLRenderer.disable( 0x0B71 );
			        pWebGLRenderer.disable( 0x0C11 );
			        pWebGLRenderer.disable( 0x0BE2 );
			        pWebGLRenderer.disable( 0x0B44 );

			        pWebGLRenderer.activateWebGLTexture( 0x84C0 );
			        pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);

			        pWebGLProgram.setInt("sourceTexture", 0);
		        	pWebGLProgram.setVec2("v2fSrcTexSize",  Vec2.stackCeil.set(this._iWidth, this._iHeight) );
		        	pWebGLProgram.setVec2("v2fDstTexSize",  Vec2.stackCeil.set(pPOTSize[0], pPOTSize[1]) );

			        pWebGLContext.viewport(0, 0, pPOTSize[0], pPOTSize[1]);
			        pWebGLContext.drawArrays( 0x0000 , 0, nPixels);
			        pWebGLContext.flush();

			        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,  0x0DE1 , null, 0);

			        pWebGLContext.disableVertexAttribArray(iIndexAttribLocation);
			        pWebGLRenderer.bindWebGLBuffer( 0x8892 , null);
			    	pWebGLRenderer.bindWebGLTexture( 0x0DE1 , null);
//pWebGLRenderer.deleteWebGLBuffer(pIndexBuffer);

			        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFrameBuffer);
			        pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);

			        pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

			        this._pWebGLTexture = pTexture;
			        this._iWidth = pPOTSize[0];
			        this._iHeight = pPOTSize[1];
				}
			}

			this._pHeader.setData(this._header());

			this.notifyAltered();

			return true;
		}

		protected lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		protected unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		protected copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}

		protected _header(iTextureSizeX:  number  = this._iWidth, iTextureSizeY:  number  = this._iHeight){
			var pHeader: Float32Array = new Float32Array(8);

			pHeader[ 0 ] = iTextureSizeX;
			pHeader[ 1 ] = iTextureSizeY;
			pHeader[ 2 ] = 1/iTextureSizeX;
			pHeader[ 3 ] = 1/iTextureSizeY;
			pHeader[ 4 ] = iTextureSizeX * iTextureSizeY;
			pHeader[ 5 ] = pHeader[ 4 ] * pixelUtil.getNumElemBytes(this._ePixelFormat);

			return pHeader;
		};

		static _pWebGLBuffer1: WebGLBuffer = null;
		static _pWebGLBuffer2: WebGLBuffer = null;
		static _pWebGLBuffer3: WebGLBuffer = null;
	}


}





















module akra {
	export interface IIndexData extends IBufferData, IBuffer {
		 type: EDataTypes;
		 length:  number ;
		 bytesPerIndex:  number ;
		 id:  number ;

		getData(iOffset:  number , iSize:  number ): ArrayBuffer;
		getTypedData(iStart:  number , iCount:  number ): ArrayBufferView;

		setData(pData: ArrayBufferView): bool;
		setData(pData: ArrayBufferView, iOffset:  number ): bool;
		setData(pData: ArrayBufferView, iOffset:  number , iCount:  number ): bool;

		destroy(): void;

		getPrimitiveType(): EPrimitiveTypes;
		getPrimitiveCount():  number ;
		getBufferHandle():  number ;
	}
}






















module akra.data {
	export class IndexData implements IIndexData {
		private _pIndexBuffer: IIndexBuffer;
		private _iOffset:  number ;
		private _iLength:  number ;
		private _ePrimitiveType: EPrimitiveTypes;
		private _eElementsType: EDataTypes;
		private _iId:  number ;

		/**@inline*/  get id():  number  { return this._iId; }
		/**@inline*/  get type():  number  { return this._eElementsType; };
		/**@inline*/  get length():  number  { return this._iLength; };
		/**@inline*/  get bytesPerIndex():  number  { return getTypeSize(this._eElementsType); };
		/**@inline*/  get byteOffset():  number  { return this._iOffset; };
		/**@inline*/  get byteLength():  number  { return this._iLength * this.bytesPerIndex; };
		/**@inline*/  get buffer(): IIndexBuffer { return this._pIndexBuffer; };

		constructor (
			pIndexBuffer: IIndexBuffer,
			id:  number ,
			iOffset:  number ,
			iCount:  number ,
			ePrimitiveType: EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST,
			eElementsType: EDataTypes = EDataTypes.UNSIGNED_SHORT) {

			{ logger.setSourceLocation( "data/IndexData.ts" , 36 ); logger.assert(eElementsType == EDataTypes.UNSIGNED_SHORT || eElementsType == EDataTypes.UNSIGNED_BYTE || eElementsType == EDataTypes.UNSIGNED_INT, "supported only short, byte, uint data types."); }
                                                                                             ;

			this._pIndexBuffer = pIndexBuffer;
			this._iOffset = iOffset;
			this._iLength = iCount;
			this._iId = id;

			this._ePrimitiveType = ePrimitiveType;
			this._eElementsType = eElementsType;

			{ logger.setSourceLocation( "data/IndexData.ts" , 46 ); logger.assert(pIndexBuffer.byteLength >= this.byteLength + this.byteOffset, "out of buffer limits."); } ;
		}


		getData(iOffset:  number , iSize:  number ): ArrayBuffer {
			{ logger.setSourceLocation( "data/IndexData.ts" , 51 ); logger.assert(iOffset + iSize <= this.byteLength, "out of buffer limits"); } ;
			var pBuffer: Uint8Array = new Uint8Array(iSize);

			if (this._pIndexBuffer.readData(this.byteOffset + iOffset, iSize, pBuffer)) {
				return pBuffer.buffer;
			}

			{ logger.setSourceLocation( "data/IndexData.ts" , 58 ); logger.error("cannot read data from index buffer"); } ;

			return null;
		};

		getTypedData(iStart:  number , iCount:  number ): ArrayBufferView{
			{ logger.setSourceLocation( "data/IndexData.ts" , 64 ); logger.assert((iStart + iCount) <= this._iLength, "out of buffer limits"); } ;

			var iTypeSize:  number  = getTypeSize(this._eElementsType);

			var iOffset:  number  = iStart * iTypeSize;
			var iSize:  number  = iCount * iTypeSize;

			var pBuffer: Uint8Array = new Uint8Array(iSize);

			if (this._pIndexBuffer.readData(this.byteOffset + iOffset, iSize, pBuffer)){
				switch(this._eElementsType){
					case EDataTypes.UNSIGNED_BYTE:
						return pBuffer;
					case EDataTypes.UNSIGNED_SHORT:
						return new Uint16Array(pBuffer.buffer);
					case EDataTypes.UNSIGNED_INT:
						return new Uint32Array(pBuffer.buffer);
					default:
						return null;
				}
			}

			return null;
		};

		setData(pData: ArrayBufferView, iOffset:  number  = 0, iCount:  number  = pData.byteLength / this.bytesPerIndex): bool {
			{ logger.setSourceLocation( "data/IndexData.ts" , 90 ); logger.assert((iOffset + iCount) * this.bytesPerIndex <= this.byteLength, "out of buffer limits."); } ;

			return this._pIndexBuffer.writeData(
				pData,
				this.byteOffset + iOffset * this.bytesPerIndex,
				iCount * this.bytesPerIndex);
		}

		destroy(): void {
			this._pIndexBuffer = null;
			this._iOffset = undefined;
			this._iLength = undefined;
			this._eElementsType = undefined;
			this._eElementsType = undefined;
		}

		/**@inline*/  getPrimitiveType(): EPrimitiveTypes {
			return this._ePrimitiveType;
		}

		/**@inline*/  getPrimitiveCount(iIndexCount:  number  = this.length):  number  {
			return IndexData.getPrimitiveCount(this._ePrimitiveType, iIndexCount);
		}

		/**@inline*/  getBufferHandle():  number  {
			return this._pIndexBuffer.resourceHandle;
		}

		static getPrimitiveCount(eType: EPrimitiveTypes, nVertices:  number ):  number  {
			switch (eType) {
	            case EPrimitiveTypes.POINTLIST:
	                return nVertices;
	            case EPrimitiveTypes.LINELIST:
	            	return nVertices / 2;
	            case EPrimitiveTypes.LINESTRIP:
	            	return nVertices - 1;
	            case EPrimitiveTypes.LINELOOP:
	            	return nVertices;
	            case EPrimitiveTypes.TRIANGLELIST:
	                return nVertices / 3;
	            case EPrimitiveTypes.TRIANGLEFAN:
	            case EPrimitiveTypes.TRIANGLESTRIP:
	            	return nVertices - 2;
	        }

	        { logger.setSourceLocation( "data/IndexData.ts" , 135 ); logger.error("unhandled case detected.."); } ;

	        return 0;
		}
	}
}



module akra.core.pool.resources {

	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class IndexBuffer extends HardwareBuffer implements IIndexBuffer {
		protected _pIndexDataArray: IIndexData[] = [];
		protected _iDataCounter:  number  = 0;

		/**@inline*/  get length():  number  {
			return this._pIndexDataArray.length;
		}

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );

		}

//create(iByteSize: uint, iFlags?: uint, pData?: Uint8Array): bool;
		create(iByteSize:  number , iFlags?:  number , pData?: ArrayBufferView): bool{
//create(iByteSize: uint, iFlags?: uint, pData?: ArrayBufferView): bool {
			super.create(0, iFlags || 0);

			if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
				this._pBackupCopy = new MemoryBuffer();
				this._pBackupCopy.create(iByteSize);
				this._pBackupCopy.writeData(pData, 0, iByteSize);
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			this._pBackupCopy.destroy();
			this.freeIndexData();

			this._iDataCounter = 0;
		}

		getIndexData(iOffset:  number , iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData {
			var pIndexData: IIndexData = new data.IndexData(this, this._iDataCounter ++, iOffset, iCount, ePrimitiveType, eElementsType);
			this._pIndexDataArray.push(pIndexData);
			return pIndexData;
		}

		getEmptyIndexData(iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData {
			var pHole: IBufferHole[] = new Array();
			var i:  number ;
			var pIndexData: IIndexData;

			pHole[0] = {start: 0, end: this.byteLength};

//console.log(pHole[0].end);
			for(var k:  number  = 0; k < this._pIndexDataArray.length; ++ k) {

				pIndexData = this._pIndexDataArray[k];

				for (i = 0; i < pHole.length; i ++) {
//console.log("pHole:",pHole[i].start,pHole[i].end);
//Полностью попадает внутрь
					if (pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						var iTemp:  number  = pHole[i].end;

						pHole[i].end = pIndexData.byteOffset;
						pHole.splice(i + 1, 0, {start: pIndexData.byteOffset + pIndexData.byteLength, end: iTemp});

						i--;
					}
					else if(pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
					}
					else if(pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {

					}
					else if(pIndexData.byteOffset == pHole[i].start && pIndexData.byteLength == (pHole[i].end - pHole[i].start)) {
						pHole.splice(i, 1);
						i--;
					}
//Перекрывает снизу
					else if(pIndexData.byteOffset<pHole[i].start &&
						pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
					}
					else if(pIndexData.byteOffset < pHole[i].start &&
						pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {
						pHole.splice(i, 1);
						i--;
					}
//Перекрывается сверху
					else if(pIndexData.byteOffset + pIndexData.byteLength>pHole[i].end &&
						pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
						pHole[i].end = pIndexData.byteOffset;
					}
					else if(pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end &&
						pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
						pHole.splice(i, 1);
						i--;
					}
//полнстью перекрывает
					else if(pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end) {
						i--;
					}
				}
			}

			pHole.sort((a: IBufferHole, b: IBufferHole): number => ((a.end - a.start) - (b.end - b.start)));

			for (i = 0; i < pHole.length; i ++) {
				if((pHole[i].end - pHole[i].start) >= iCount * getTypeSize(eElementsType)) {
					pIndexData = new data.IndexData(this, this._iDataCounter ++, pHole[i].start, iCount, ePrimitiveType, eElementsType);

					this._pIndexDataArray.push(pIndexData);

					return pIndexData;
				}
			}

			return null;
		}

		freeIndexData(): bool;
		freeIndexData(pIndexData?: IIndexData): bool {
			if(arguments.length == 0) {
				for(var i:  number  = 0; i < this._pIndexDataArray.length; i ++) {
					this._pIndexDataArray[Number(i)].destroy();
				}

				this._pIndexDataArray = null;
			}
			else {
				for (var i:  number  = 0; i < this._pIndexDataArray.length; i ++) {
					if(this._pIndexDataArray[i] == pIndexData) {
						pIndexData.destroy();

						this._pIndexDataArray.splice(i,1);
						this.notifyAltered();
						return true;
					}
				}

				return false;
			}

			this.notifyAltered();
			return true;
		}

		allocateData(ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes, pData: ArrayBufferView): IIndexData {
			var pIndexData: IIndexData;
		    var iCount:  number  = pData.byteLength / getTypeSize(eElementsType);

		    { logger.setSourceLocation( "core/pool/resources/IndexBuffer.ts" , 164 ); logger.assert(iCount === math.floor(iCount), "data size should be a multiple of the vertex declaration"); } ;

		    pIndexData = this.getEmptyIndexData(iCount, ePrimitiveType, eElementsType);
		    pIndexData.setData(pData);

		    return pIndexData;
		}

	}
}







module akra.webgl {

	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class WebGLIndexBuffer extends core.pool.resources.IndexBuffer implements IIndexBuffer {
		protected _iByteSize:  number ;
		protected _pWebGLBuffer: WebGLBuffer;

		private _pLockData: Uint8Array = null;

		/**@inline*/  get byteLength():  number  { return this._iByteSize; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			iByteSize = math.max(iByteSize,  1024 );

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    { logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 45 ); logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated"); } ;

			this._iByteSize = iByteSize;
		    this._iFlags = iFlags;
		    pWebGLContext = pWebGLRenderer.getWebGLContext();

		    { logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 51 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); } ;

//Софтварного рендеринга буфера у нас нет
		    { logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 54 ); logger.assert(!this.isSoftware(), "no sftware rendering"); } ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			{ logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 62 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера"); }
                                                                                                                         ;


		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        { logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 68 ); logger.criticalError("cannot create WebGL index buffer"); } ;

		        this.destroy();
		        return false;
		    }

		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);
		    pWebGLContext.bufferData( 0x8893 , this._iByteSize, getWebGLUsage(this._iFlags));

		    if (pData) {
		        pWebGLContext.bufferSubData(
		        	0x8893 , 0,  <ArrayBufferView>(isArrayBuffer(pData) ?pData: (pData).buffer ));
		    }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);

			this._pWebGLBuffer = null;
			this._iByteSize = 0;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			{ logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 99 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); } ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool = false): bool {

			{ logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 119 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); } ;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);

			{ logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 126 ); logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера"); } ;
			{ logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 127 ); logger.assert(this.byteLength >= iOffset + iSize, "Данные выйдут за предел буфера"); } ;

			var pU8Data: Uint8Array = null;

			if (isArrayBuffer(pData)) {
				pU8Data = new Uint8Array(pData);
			}
			else {
				pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
			}

			pU8Data = pU8Data.subarray(0, iSize);

			pWebGLContext.bufferSubData( 0x8893 , iOffset, pU8Data);

			if (this.isBackupPresent()) {
		        this._pBackupCopy.writeData(pU8Data, iOffset);
		    }

		    this.notifyAltered();

			return true;
		}

		resize(iSize:  number ): bool {
			var eUsage:  number ;
			var pData: Uint8Array;
			var iMax:  number  = 0;
			var pIndexData: IIndexData;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if(this.isBackupPresent()) {
				return false;
			}

			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pIndexDataArray.length; ++ k) {
					pIndexData = this._pIndexDataArray[k];

					if(pIndexData.byteOffset + pIndexData.byteLength > iMax) {
						iMax = pIndexData.byteOffset + pIndexData.byteLength;
					}
				}

				{ logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 174 ); logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер"); }
                                                                                                                                         ;
			}

			if(pWebGLContext.isBuffer(this._pWebGLBuffer)) {
				pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
			}

			eUsage = getWebGLUsage(this._iFlags);

		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        { logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 186 ); logger.criticalError("cannot create WebGL index buffer"); } ;

		        this.destroy();
		        return false;
		    }


		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);
			pWebGLContext.bufferData( 0x8893 , iSize, eUsage);

			pData = new Uint8Array(this._iByteSize);

			if (this.readData(pData)) {
				{ logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 199 ); logger.warning("cannot read data from buffer"); } ;
				return false;
			}


			this.writeData(pData, 0, this._iByteSize);
			this._pBackupCopy.resize(iSize);
			this._iByteSize = iSize;

			this.notifyAltered();

			return true;
		}

		/**@inline*/  getWebGLBuffer(): WebGLBuffer {
			return this._pWebGLBuffer;
		}

		protected lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		protected unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		protected copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}
	}
}













module akra.webgl {
	export class WebGLInternalRenderBuffer extends WebGLPixelBuffer {
		protected _pWebGLRenderbuffer: WebGLRenderbuffer = null;

		constructor() {
			super();
		}

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(iWebGLFormat:  number , iWidth:  number , iHeight:  number , bCreateStorage: bool): bool;
		create(): bool {
			if(arguments.length !== 4){
				{ logger.setSourceLocation( "webgl/WebGLInternalRenderbuffer.ts" , 21 ); logger.criticalError("Invalid number of arguments. For PixelBuffer it must be four"); } ;
			}

			var iWebGLFormat:  number  = arguments[0];
			var iWidth:  number  = arguments[1];
			var iHeight:  number  = arguments[2];
			var bCreateStorage: bool = arguments[3];

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			super.create(iWidth, iHeight, 1, webgl.getClosestAkraFormat(iWebGLFormat, EPixelFormats.A8R8G8B8), 0);

			this._iWebGLInternalFormat = iWebGLFormat;
			this._pWebGLRenderbuffer = pWebGLRenderer.createWebGLRenderbuffer();

			pWebGLRenderer.bindWebGLRenderbuffer( 0x8D41 , this._pWebGLRenderbuffer);

			if(bCreateStorage) {
				pWebGLContext.renderbufferStorage( 0x8D41 , iWebGLFormat, iWidth, iHeight);
			}

			this.notifyCreated();
			return true;
		}

		destroy(): void {
			super.destroy();
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLRenderbuffer(this._pWebGLRenderbuffer);
			this._pWebGLRenderbuffer = null;
		}

		_bindToFramebuffer(iAttachment:  number , iZOffset:  number ): void {
			{ logger.setSourceLocation( "webgl/WebGLInternalRenderbuffer.ts" , 56 ); logger.assert(iZOffset < this._iDepth); } ;

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLContext.framebufferRenderbuffer( 0x8D40 , iAttachment,  0x8D41 , this._pWebGLRenderbuffer);
		}
	}

}

















module akra.core.pool.resources {
	export class DepthBuffer extends ResourcePoolItem implements IDepthBuffer {
		protected _iBitDepth:  number  = 0;
		protected _iWidth:  number  = 0;
		protected _iHeight:  number  = 0;
		protected _isManual: bool = false;
		protected _pAttachedRenderTargetsList: IRenderTarget[] = null;

		constructor() {
            super();
        }

        /**@inline*/  get bitDepth():  number  {
			return this._iBitDepth;
		}

		/**@inline*/  get width():  number  {
			return this._iWidth;
		}

		/**@inline*/  get height():  number  {
			return this._iHeight;
		}

        create(iBitDepth:  number , iWidth:  number , iHeight:  number , isManual: bool): bool {
        	this._iBitDepth = iBitDepth;
        	this._iWidth = iWidth;
        	this._iHeight = iHeight;
        	this._isManual = isManual;
        	this._pAttachedRenderTargetsList = [];

        	this.notifyCreated();

        	return true;
        }

        destroy(): void {
        	this.detachFromAllRenderTargets();
        	this._pAttachedRenderTargetsList = null;
        }

        destroyResource(): bool {
			this.destroy();
			this.notifyDestroyed();
			return true;
		}

        isManual(): bool{
        	return this._isManual;
        }

		isCompatible(pTarget: IRenderTarget): bool {
			if( this._iWidth >= pTarget.width &&
				this._iHeight >= pTarget.height ){
				return true;
			}

			return false;
		}

		_notifyRenderTargetAttached(pTarget: IRenderTarget): void {
			{ logger.setSourceLocation( "core/pool/resources/DepthBuffer.ts" , 70 ); logger.assert(this._pAttachedRenderTargetsList.indexOf(pTarget) === -1, "RenderTarget alrady has been attached to this DepthBuffer"); }
                                                                   ;

			this._pAttachedRenderTargetsList.push(pTarget);
		}

		_notifyRenderTargetDetached(pTarget: IRenderTarget): void {
			var index:  number  = this._pAttachedRenderTargetsList.indexOf(pTarget);
			{ logger.setSourceLocation( "core/pool/resources/DepthBuffer.ts" , 78 ); logger.assert(index !== -1, "Can not detach RenderTarget from DepthBuffer beacuse it hasn`t been attached to it"); }
                                                                                            ;

			this._pAttachedRenderTargetsList.splice(index, 1);
		}

		protected detachFromAllRenderTargets(): void {
			var i:  number  = 0;
			for(i = 0; i < this._pAttachedRenderTargetsList.length; i++) {
//If we call, detachDepthBuffer, we'll invalidate the iterators
				this._pAttachedRenderTargetsList[i].detachDepthBuffer();
			}

			this._pAttachedRenderTargetsList.clear();
		}
	}
}




































module akra.render {
	export class RenderTexture extends RenderTarget implements IRenderTexture {
		protected _pBuffer: IPixelBuffer = null;
		protected _iZOffset:  number  = 0;

		constructor(pRenderer: IRenderer, pBuffer: IPixelBuffer, iZOffset:  number ){
			super(pRenderer);
			this._pBuffer = pBuffer;
			this._iZOffset = iZOffset;
			this._iWidth = pBuffer.width;
			this._iHeight = pBuffer.height;
			this._iColorDepth = pixelUtil.getNumElemBits(pBuffer.format);
		}

		enableSupportFor3DEvent(iType:  number ):  number  {
			return 0;
		}

		/**@inline*/  getPixelBuffer(): IPixelBuffer {
			return this._pBuffer;
		}

		destroy(): void {
			this._pBuffer._clearRTT(this._iZOffset);
			this._pBuffer = null;
		}

		/**@inline*/  suggestPixelFormat(): EPixelFormats {
			return this._pBuffer.format;
		}

		copyContentsToMemory(pDest: IPixelBox, eBuffer: EFramebuffer): void {
			if(eBuffer === EFramebuffer.AUTO){
				eBuffer = EFramebuffer.FRONT;
			}

			if(eBuffer !== EFramebuffer.FRONT) {
				{ logger.setSourceLocation( "render/RenderTexture.ts" , 49 ); logger.criticalError("Invalid buffer."); } ;
			}

			this._pBuffer.blitToMemory(pDest);
		}

		readPixels(ppDest?: IPixelBox, eFramebuffer?: EFramebuffer): IPixelBox {
			if (isNull(ppDest)) {
				var ePixelFormat: EPixelFormats = EPixelFormats.BYTE_RGB;

				ppDest = new pixelUtil.PixelBox(this._iWidth, this._iHeight, 1, ePixelFormat,
					new Uint8Array(pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, ePixelFormat)));
			}

			if ((ppDest.right > this._iWidth) || (ppDest.bottom > this._iHeight) || (ppDest.front != 0) || (ppDest.back != 1)) {
				{ logger.setSourceLocation( "render/RenderTexture.ts" , 64 ); logger.criticalError("Invalid box.", "RenderTexture::readPixels"); } ;
			}

			this._pBuffer.readPixels(ppDest);

			return ppDest;
		}
	}
}













module akra.webgl {
	export class WebGLRenderTexture extends render.RenderTexture {
		protected _pFrameBuffer: WebGLInternalFrameBuffer = null;

		/**@inline*/  get width():  number  { return this._iWidth = this._pFrameBuffer.width; }
		/**@inline*/  get height():  number  { return this._iHeight = this._pFrameBuffer.height; }

		constructor(pRenderer: IRenderer, pTarget: IPixelBuffer){
			super(pRenderer, pTarget, 0);
			this._pFrameBuffer = new WebGLInternalFrameBuffer(pRenderer);

// switch(pTarget.format){
// 	case EPixelFormats.DEPTH8:
// 	case EPixelFormats.DEPTH16:
// 	case EPixelFormats.DEPTH32:
// 		this._pFrameBuffer.bindSurface(GL_DEPTH_ATTACHMENT, pTarget);
// 		break;

// 	case EPixelFormats.DEPTH24STENCIL8:
// 		this._pFrameBuffer.bindSurface(GL_DEPTH_STENCIL_ATTACHMENT, pTarget);
// 		break;

// 	default:
//		this._pFrameBuffer.bindSurface(GL_COLOR_ATTACHMENT0, pTarget);
// 		break;
// }

			this._pFrameBuffer.bindSurface( 0x8CE0 , pTarget);

			this._iWidth = this._pFrameBuffer.width;
			this._iHeight = this._pFrameBuffer.height;

		}

		destroy(): void {
			super.destroy();
		}

		requiresTextureFlipping(): bool {
			return true;
		}

		getCustomAttribute(sName: string): any {
			if(sName === "FBO") {
				return this._pFrameBuffer;
			}

			return null;
		}

		swapBuffers(): void {
			this._pFrameBuffer.swapBuffers();
		}

		attachDepthBuffer(pDepthBuffer: IDepthBuffer): bool {
			var bResult: bool = false;
			bResult = super.attachDepthBuffer(pDepthBuffer);

			if(bResult){
				this._pFrameBuffer.attachDepthBuffer(pDepthBuffer);
			}

			return bResult;
		}

		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool {
			var bResult: bool = false;

			bResult = super.attachDepthPixelBuffer(pBuffer);
			if(bResult) {
				if(pBuffer.format !== EPixelFormats.DEPTH8){
					this.detachDepthPixelBuffer();
					return false;
				}

				this._pFrameBuffer.bindSurface( 0x8D00 , pBuffer);
				(<WebGLPixelBuffer>pBuffer).addRef();
			}

			return bResult;

		}

		attachDepthTexture(pTexture: ITexture): bool {
			this._pFrameBuffer.attachDepthTexture(pTexture);
			return true;
		}


		detachDepthPixelBuffer(): void {
			this._pFrameBuffer.unbindSurface( 0x8D00 );
			(<WebGLPixelBuffer>this._pDepthPixelBuffer).release();
			super.detachDepthPixelBuffer();
		}

		detachDepthBuffer(): void {
			this._pFrameBuffer.detachDepthBuffer();
			super.detachDepthBuffer();
		}

		detachDepthTexture(): void {
			this._pFrameBuffer.detachDepthTexture();
		}
	}
}















module akra.webgl {
	export interface IWebGLAttachments {
		[webGLAttachment:  number ] : WebGLPixelBuffer;
	}

	export class WebGLInternalFrameBuffer {
		private _pWebGLRenderer: WebGLRenderer = null;
		private _pWebGLFramebuffer: WebGLFramebuffer = null;
		private _pAttachments: IWebGLAttachments = null;
		private _iWebglActiveAttachment:  number  = 0;

		constructor(pWebGLRenderer: IRenderer) {
			this._pWebGLRenderer = <WebGLRenderer>pWebGLRenderer;

			this._pWebGLFramebuffer = this._pWebGLRenderer.createWebGLFramebuffer();
			this._pAttachments = <IWebGLAttachments>{};

			for(var i:  number  = 0; i < webgl.maxColorAttachments; i++) {
				this._pAttachments[ 0x8CE0  + i] = null;
			}

			this._pAttachments[ 0x8D00 ] = null;
			this._pAttachments[ 0x8D20 ] = null;
			this._pAttachments[ 0x821A ] = null;
		}

		destroy(): void {
			this._pWebGLRenderer.deleteWebGLFramebuffer(this._pWebGLFramebuffer);
			this._pWebGLFramebuffer = null;
		}

		/**@inline*/  get width():  number  {
        	return this._pAttachments[ 0x8CE0 ].width;
		}

		/**@inline*/  get height():  number  {
			return this._pAttachments[ 0x8CE0 ].height;
		}

		/**@inline*/  get format():  number  {
			return this._pAttachments[ 0x8CE0 ].format;
		}

		/**@inline*/  getColorAttachment(iAttachment:  number ): WebGLPixelBuffer {
			return this._pAttachments[ 0x8CE0  + iAttachment];
		}

		/**@inline*/  getAttachment(iWebGLAttachment:  number ): WebGLPixelBuffer {
			return this._pAttachments[iWebGLAttachment];
		}

		bindSurface(iWebGLAttachment:  number , pSurface: IPixelBuffer): void {
			if(!isDef(this._pAttachments[iWebGLAttachment])){
				return;
			}

			this.releaseAttachment(iWebGLAttachment);
			this._pAttachments[iWebGLAttachment] = <WebGLPixelBuffer>pSurface;
			if(this.checkAttachment(iWebGLAttachment)){
				this._bind();
				(<WebGLPixelBuffer>pSurface)._bindToFramebuffer(iWebGLAttachment, 0);
				(<WebGLPixelBuffer>pSurface).addRef();
			}
		}

		unbindSurface(iWebGLAttachment:  number ): void {
			if(!isDef(this._pAttachments[iWebGLAttachment])){
				return;
			}
			var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();
			this.releaseAttachment(iWebGLAttachment);
			this._pAttachments[iWebGLAttachment] = null;
			pWebGLContext.framebufferRenderbuffer( 0x8D40 , iWebGLAttachment,
									  			  0x8D41 , null);
		}

		/**@inline*/  bindColorSurface(iAttachment:  number , pSurface: IPixelBuffer): void {
			this.bindSurface( 0x8CE0  + iAttachment, pSurface);
		}

		/**@inline*/  _bind(): void {
			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , this._pWebGLFramebuffer);
		}

		attachDepthBuffer(pDepthBuffer: IDepthBuffer): void {
			var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();
			var pOldFramebuffer: WebGLFramebuffer = this._pWebGLRenderer.getParameter( 0x8CA6 );

			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , this._pWebGLFramebuffer);

			if(!isNull(pDepthBuffer)) {
				var pDepthRenderBuffer: WebGLInternalRenderBuffer = (<WebGLDepthBuffer>pDepthBuffer).depthBuffer;
				var pStencilRenderBuffer: WebGLInternalRenderBuffer = (<WebGLDepthBuffer>pDepthBuffer).stencilBuffer;

				if(!isNull(pDepthRenderBuffer)){
					pDepthRenderBuffer._bindToFramebuffer( 0x8D00 , 0);
					this.releaseAttachment( 0x8D00 );
					this._pAttachments[ 0x8D00 ] = pDepthRenderBuffer;
					pDepthRenderBuffer.addRef();
				}

				if(!isNull(pStencilRenderBuffer)){
					pStencilRenderBuffer._bindToFramebuffer( 0x8D20 , 0);
					this.releaseAttachment( 0x8D20 );
					this._pAttachments[ 0x8D20 ] = pStencilRenderBuffer;
					pDepthRenderBuffer.addRef();
				}

				if( !this.checkAttachment( 0x8D00 ) ||
					!this.checkAttachment( 0x8D20 ) ) {
					{ logger.setSourceLocation( "webgl/WebGLInternalFrameBuffer.ts" , 124 ); logger.error("Invalid frame buffer depthbuffer attachment. Wrong size."); } ;
					return;
				}

			}
			else {

				pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D00 ,
										  			  0x8D41 , null);

				pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D20 ,
										  			  0x8D41 , null);

				this.releaseAttachment( 0x8D00 );
				this.releaseAttachment( 0x8D20 );
				this._pAttachments[ 0x8D00 ] = null;
				this._pAttachments[ 0x8D20 ] = null;
			}

			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
		}

		attachDepthTexture(pDepthTexture: ITexture): void {
			var pTextureBuffer: WebGLTextureBuffer = <WebGLTextureBuffer>(<WebGLInternalTexture>pDepthTexture).getBuffer();
			this._bind();
			this.bindSurface( 0x8D00 , pTextureBuffer);
		}

		detachDepthTexture(): void {
			this._bind();
			this.unbindSurface( 0x8D00 );
		}

		detachDepthBuffer(): void {
			var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();
			var pOldFramebuffer: WebGLFramebuffer = this._pWebGLRenderer.getParameter( 0x8CA6 );

			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , this._pWebGLFramebuffer);

			pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D00 ,
									  			  0x8D41 , null);

			pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D20 ,
									  			  0x8D41 , null);

			this.releaseAttachment( 0x8D00 );
			this.releaseAttachment( 0x8D20 );
			this._pAttachments[ 0x8D00 ] = null;
			this._pAttachments[ 0x8D20 ] = null;

			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
		}

		swapBuffers(): void {

		}

		private checkAttachment(iWebGLAttachment:  number ): bool{
			if(iWebGLAttachment ===  0x8CE0 ){
				var isOk: bool = true;

				for(var i:  number  = 1; i < webgl.maxColorAttachments; i++) {
					isOk = this.checkAttachment( 0x8CE0  + i);
					if(!isOk) return false;
				}

				isOk = this.checkAttachment( 0x8D00 );
				if(!isOk) return false;
				isOk = this.checkAttachment( 0x8D20 );
				if(!isOk) return false;
				isOk = this.checkAttachment( 0x821A );
				if(!isOk) return false;

				return true;
			}
			else {
				var pBuffer: IPixelBuffer = this._pAttachments[iWebGLAttachment];
				if(isNull(pBuffer)) return true;

				if(this.width === 0 && this.height === 0) return true;

				if(this.width !== pBuffer.width && this.height !== pBuffer.height) return false;

				if(iWebGLAttachment >  0x8CE0  &&
				   iWebGLAttachment <  0x8CE0  + webgl.maxColorAttachments) {

					if (!isNull(this._pAttachments[ 0x8CE0 ]) &&
						this.format !== pBuffer.format) return false;
				}

				return true;
			}
		}

		private  /**@inline*/  releaseAttachment(iWebGLAttachment): void {
			if(!isNull(this._pAttachments[iWebGLAttachment])){
				this._pAttachments[iWebGLAttachment].release();
			}
		}
	}
}



module akra.webgl {
	export class WebGLDepthBuffer extends core.pool.resources.DepthBuffer {
		protected _pDepthBuffer: WebGLInternalRenderBuffer = null;
		protected _pStencilBuffer: WebGLInternalRenderBuffer = null;

		constructor() {
			super();
		}

		/**@inline*/  get depthBuffer(): WebGLInternalRenderBuffer {
			return this._pDepthBuffer;
		}

		/**@inline*/  get stencilBuffer(): WebGLInternalRenderBuffer {
			return this._pStencilBuffer;
		}

		create(iBitDepth:  number , iWidth:  number , iHeight:  number , bManual: bool): bool;
		create(pDepth: WebGLInternalRenderBuffer, pStencil: WebGLInternalRenderBuffer,
			   iWidth:  number , iHeight:  number , isManual: bool): bool;
		create(): bool {
			if(arguments.length !== 5){
				{ logger.setSourceLocation( "webgl/WebGLDepthBuffer.ts" , 30 ); logger.criticalError("Invalid number of arguments. For WebGLDepthBuffer it must be five"); } ;
			}

			super.create(0, arguments[2], arguments[3], arguments[4]);
			var pDepth: WebGLInternalRenderBuffer = arguments[0];
			var pStencil: WebGLInternalRenderBuffer = arguments[1];

			this._pDepthBuffer = pDepth;
			this._pStencilBuffer = pStencil;

			if(!isNull(pDepth)) {
				switch(pDepth._getWebGLFormat()) {
					case  0x81A5 :
						this._iBitDepth = 16;
						break;
					case  0x81A6 :
		            case  0x81A7 :
	            	case  0x88F0 :
	            		if (webgl.hasExtension( "OES_depth24" ) ||
	            			webgl.hasExtension( "OES_depth32" ) ||
	            			webgl.hasExtension( "OES_packed_depth_stencil" )){

	            			this._iBitDepth = 32;
	            		}
	            		break;
				}
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			if(!isNull(this._pStencilBuffer) && this._pStencilBuffer !== this._pDepthBuffer){
				this._pStencilBuffer.release();
			}

			if(!isNull(this._pDepthBuffer)){
				this._pDepthBuffer.release();
			}

			this._pStencilBuffer = null;
			this._pDepthBuffer = null;
		}

		isCompatible(pTarget: IRenderTarget): bool {
			if( this._iWidth >= pTarget.width &&
				this._iHeight >= pTarget.height ){
				return true;
			}

			return false;
		}


	}
}







module akra.core.pool {
    function determModelFormat(sPath: string): EModelFormats {
        switch (path.info(sPath).ext.toLowerCase()) {
            case "obj":
                return EModelFormats.OBJ;
            case "dae":
                return EModelFormats.COLLADA;
        }

        return EModelFormats.UNKNOWN;
    }

//is this class really singleton??
    export class ResourcePoolManager implements IResourcePoolManager {
//all predefined pools
        private pSurfaceMaterialPool: IResourcePool;
        private pEffectPool: IResourcePool;
        private pRenderMethodPool: IResourcePool;
        private pVertexBufferPool: IResourcePool;
        private pIndexBufferPool: IResourcePool;
        private pColladaPool: IResourcePool;
        private pObjPool: IResourcePool;
        private pImagePool: IResourcePool;
        private pTexturePool: IResourcePool;
        private pVideoBufferPool: IResourcePool;
        private pShaderProgramPool: IResourcePool;
        private pComponentPool: IResourcePool;
        private pTextureBufferPool: IResourcePool;
        private pRenderBufferPool: IResourcePool;
        private pDepthBufferPool: IResourcePool;
        private pEffectDataPool: IResourcePool;

/** Списки пулов по семействам ресурсов */

    	private pResourceFamilyList: IResourcePool[][] = null;
/** Карта пулов по коду ресурса */

    	private pResourceTypeMap: IResourcePool[] = null;
/** Ресурс для ожидания остальных */

    	private pWaiterResource: IResourcePoolItem = null;

        private pEngine: Engine;

        get surfaceMaterialPool(): IResourcePool { return this.pSurfaceMaterialPool; }
        get effectPool(): IResourcePool { return this.pEffectPool; }
        get renderMethodPool(): IResourcePool { return this.pRenderMethodPool; }
        get vertexBufferPool(): IResourcePool { return this.pVertexBufferPool; }
        get indexBufferPool(): IResourcePool { return this.pIndexBufferPool; }
        get colladaPool(): IResourcePool { return this.pColladaPool; }
        get objPool(): IResourcePool { return this.pObjPool; }
        get imagePool(): IResourcePool { return this.pImagePool; }
        get texturePool(): IResourcePool { return this.pTexturePool; }
        get videoBufferPool(): IResourcePool { return this.pVideoBufferPool; }
        get shaderProgramPool(): IResourcePool { return this.pShaderProgramPool; }
        get componentPool(): IResourcePool { return this.pComponentPool; }
        get textureBufferPool(): IResourcePool {return this.pTextureBufferPool; }
        get renderBufferPool(): IResourcePool {return this.pRenderBufferPool; }
        get depthBufferPool(): IResourcePool {return this.pDepthBufferPool; }
        get effectDataPool(): IResourcePool {return this.pEffectDataPool; }

    	constructor(pEngine: IEngine) {
//super();

            this.pEngine = <Engine>pEngine;

    		this.pResourceFamilyList = new Array(EResourceFamilies.TOTAL_RESOURCE_FAMILIES);

    		for (var i = 0; i < EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i++) {
		        this.pResourceFamilyList[i] = new Array();
		    }

		    this.pResourceTypeMap = new Array();
/*this*/
		    this.pWaiterResource = new pool.ResourcePoolItem(        );

            this.createDeviceResource();
    	}

        initialize(): bool {
            this.registerDeviceResources();
            return true;
        }

        destroy(): void {
            this.unregisterDeviceResources();
        }

        registerResourcePool(pCode: IResourceCode, pPool: IResourcePool): void {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 129 ); logger.assert(pCode.family >= 0 && pCode.family < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid code familyi index"); }
                                             ;

            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 131 ); logger.assert(!isDef(this.pResourceTypeMap[pCode.toNumber()]), "Resource type code already registered"); } ;

            this.pResourceTypeMap[pCode.toNumber()] = pPool;
            this.pResourceFamilyList[pCode.family].push(pPool);
        }

    	unregisterResourcePool(pCode: IResourceCode): IResourcePool {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 138 ); logger.assert(pCode.family >= 0, "invalid family index"); } ;
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 139 ); logger.assert(pCode.family < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); } ;

            var iCode = pCode.toNumber();
            var pPool = null;
            if (this.pResourceTypeMap[iCode] != undefined) {
                pPool = this.pResourceTypeMap[iCode];
                delete this.pResourceTypeMap[iCode];
            }

            if (pPool != null) {
                for (var i in this.pResourceFamilyList[pCode.family]) {
                    if (this.pResourceFamilyList[pCode.family][i] == pPool) {
                        delete this.pResourceFamilyList[pCode.family][i];
                        return pPool;
                    }
                }
            }

            return pPool;
        }


        destroyResourceFamily(eFamily: EResourceFamilies): void {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 162 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); } ;


            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].destroyAll();
            }
        }

        restoreResourceFamily(eFamily: EResourceFamilies): void {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 171 ); logger.assert(eFamily >= 0, "invalid family index"); } ;
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 172 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); } ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].restoreAll();
            }
        }

        disableResourceFamily(eFamily: EResourceFamilies): void {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 180 ); logger.assert(eFamily >= 0, "invalid family index"); } ;
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 181 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); } ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].disableAll();
            }
        }

        cleanResourceFamily(eFamily: EResourceFamilies): void  {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 189 ); logger.assert(eFamily >= 0, "invalid family index"); } ;
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 190 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); } ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].clean();
            }
        }

        destroyResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].destroyAll();
            }
        }

        restoreResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].restoreAll();
            }
        }

        disableResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].disableAll();
            }
        }

        cleanResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].clean();
            }
        }

        findResourcePool(pCode: IResourceCode): IResourcePool {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                return this.pResourceTypeMap[pCode.toNumber()];
            }

            return null;
        }

        findResourceHandle(pCode: IResourceCode, sName: string):  number  {
            var pPool: IResourcePool = this.findResourcePool(pCode);
            var iHandle:  number  = INVALID_INDEX;

            if (!isNull(pPool)) {
                iHandle = pPool.findResourceHandle(sName);
            }

            return iHandle;
        }

        findResource(pCode: IResourceCode, sName: string): IResourcePoolItem;
        findResource(pCode: IResourceCode, iHandle:  number ): IResourcePoolItem;
        findResource(pCode, sName): IResourcePoolItem {
            var pPool: IResourcePool = this.findResourcePool(pCode);
            var pResult: IResourcePoolItem = null;
            var iHandle:  number  = 0;

            if (isString(arguments[1])) {
                iHandle = pPool.findResourceHandle(sName);
            }
            else if (isInt(arguments[1])) {
                iHandle = arguments[1];
            }

            if (pPool != null && iHandle != INVALID_INDEX) {
                pResult = pPool.getResource(iHandle);
            }

            return pResult;
        }

        monitorInitResources(fnMonitor: IResourceWatcherFunc): void {
            var me: IResourcePoolManager = this;

            this.pWaiterResource.setStateWatcher(EResourceItemEvents.LOADED, function () {
                fnMonitor.apply(me, arguments);
            });
        }

        setLoadedAllRoutine(fnCallback: Function): void {
            var pPool: IResourcePool;
            var pResource: IResourcePoolItem;
            var iHandleResource:  number ;
            var pWaiterResouse: IResourcePoolItem = this.pWaiterResource;

            var fnResCallback = function (iFlagBit?:  number , iResourceFlags?:  number , isSetting?: bool) {
                if (iFlagBit == <number>EResourceItemEvents.LOADED && isSetting) {
                    fnCallback();
                }
            };

            pWaiterResouse.notifyLoaded();

            for (var n:  number  = 0; n < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; n ++) {
                var nTotal:  number  = parseInt(<any>ResourcePoolManager.pTypedResourseTotal[n]);

                for (var i:  number  = 0; i < nTotal; i ++) {
                    pPool = this.findResourcePool(new ResourceCode(n, i));

                    if (pPool) {

                        var pResources: IResourcePoolItem[] = pPool.getResources();
                        var pResource: IResourcePoolItem;

                        for (var h:  number  = 0; h < pResources.length; ++ h) {
                            pResource = pResources[h];
                            pWaiterResouse.sync(pResource, EResourceItemEvents.LOADED);
                        }
                    }

                }
            }

            if (pWaiterResouse.isResourceLoaded()) {
                fnCallback();
            }
            else {
                pWaiterResouse.setChangesNotifyRoutine(fnResCallback);
            }
        }

        destroyAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.destroyResourceFamily(<EResourceFamilies><number>i);
            }
        }

        restoreAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.restoreResourceFamily(<EResourceFamilies><number>i);
            }
        }

        disableAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.disableResourceFamily(<EResourceFamilies><number>i);
            }
        }


        clean(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.cleanResourceFamily(<EResourceFamilies><number>i);
            }
        }

        createDeviceResources(): bool {
            return true;
        }

        destroyDeviceResources(): bool {
            this.disableDeviceResources();

// then destroy...
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 344 ); logger.log("Destroying Video Device Resources\n"); } ;

            this.destroyResourceFamily(EResourceFamilies.VIDEO_RESOURCE);

            return true;
        }

        restoreDeviceResources(): bool {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 352 ); logger.log("Restoring Video Device Resources\n"); } ;
            this.restoreResourceFamily(EResourceFamilies.VIDEO_RESOURCE);
            return true;
        }

        disableDeviceResources(): bool {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 358 ); logger.log("Disabling Video Device Resources\n"); } ;
            this.disableResourceFamily(EResourceFamilies.VIDEO_RESOURCE);
            return true;
        }

        /**@inline*/  getEngine(): Engine { return this.pEngine; }

        /**@inline*/  createRenderMethod(sResourceName: string): IRenderMethod {
            return <IRenderMethod>this.renderMethodPool.createResource(sResourceName);
        }

        /**@inline*/  createTexture(sResourceName: string): ITexture {
            return <ITexture>this.texturePool.createResource(sResourceName);
        }

        /**@inline*/  createEffect(sResourceName: string): IEffect {
            return <IEffect>this.effectPool.createResource(sResourceName);
        }

        /**@inline*/  createSurfaceMaterial(sResourceName: string): ISurfaceMaterial {
            return <ISurfaceMaterial>this.surfaceMaterialPool.createResource(sResourceName);
        }

        /**@inline*/  createVertexBuffer(sResourceName: string): IVertexBuffer {
            return <IVertexBuffer>this.vertexBufferPool.createResource(sResourceName);
        }

        /**@inline*/  createVideoBuffer(sResourceName: string): IVertexBuffer {
            return <IVertexBuffer>this.videoBufferPool.createResource(sResourceName);
        }

        /**@inline*/  createIndexBuffer(sResourceName: string): IIndexBuffer {
            return <IIndexBuffer>this.indexBufferPool.createResource(sResourceName);
        };

        /**@inline*/  createShaderProgram(sResourceName: string): IShaderProgram {
            return <IShaderProgram>this.shaderProgramPool.createResource(sResourceName);
        };

        /**@inline*/  createModel(sResourceName: string, eFormat?: EModelFormats): IModel {
            var pPool: IResourcePool = this.getModelPoolByFormat(eFormat || determModelFormat(sResourceName));

            if (!isNull(pPool)) {
                return <IModel>pPool.createResource(sResourceName);
            }

            return null;
        }

        getModelPoolByFormat(eFormat: EModelFormats): IResourcePool {
            switch (eFormat) {
                case EModelFormats.OBJ:
                    return this.objPool;
                case EModelFormats.COLLADA:
                    return this.colladaPool;
            }

            return null;
        }

        /**@inline*/  loadModel(sFilename: string, pOptions: IModelLoadOptions = null): IModel {
            var eFormat: EModelFormats = determModelFormat(sFilename);
            var pPool: IResourcePool = this.getModelPoolByFormat(eFormat);
            var pModel: IModel = null;

            if (!isNull(pPool)) {
                pModel = <IModel>pPool.findResource(sFilename);

                if (isNull(pModel)) {
                    pModel = <IModel>pPool.createResource(sFilename);
                }

                if (!pModel.isResourceLoaded()) {
                    pModel.loadResource(sFilename, pOptions);
                }

                return pModel;
            }

            return null;
        }

        /**@inline*/  createImg(sResourceName: string): IImg {
            return <IImg>this.imagePool.createResource(sResourceName);
        }


        loadImage(sFilename: string): IImg {
             var pImg: IImg = <IImg>this.imagePool.findResource(sFilename);

            if (isNull(pImg)) {
                pImg = <IImg>this.imagePool.createResource(sFilename);

                if (!pImg.isResourceLoaded()) {
                    pImg.loadResource(sFilename);
                }
            }

            return pImg;
        }


        private createDeviceResource(): void {
            this.pSurfaceMaterialPool = new ResourcePool(this, resources.SurfaceMaterial);
            this.pSurfaceMaterialPool.initialize(16);

            this.pEffectPool = new ResourcePool(this, resources.Effect);
            this.pEffectPool.initialize(16);

            this.pRenderMethodPool = new ResourcePool(this, resources.RenderMethod);
            this.pRenderMethodPool.initialize(16);


            this.pColladaPool = new ResourcePool(this, resources.Collada);
            this.pColladaPool.initialize(0);

            this.pObjPool = new ResourcePool(this, resources.Obj);
            this.pObjPool.initialize(0);

            this.pImagePool = new ResourcePool(this, resources.Img);
            this.pImagePool.initialize(16);


            this.pTexturePool = new ResourcePool(this, webgl.WebGLInternalTexture);
            this.pTexturePool.initialize(16);

            this.pIndexBufferPool = new ResourcePool(this, webgl.WebGLIndexBuffer);
            this.pIndexBufferPool.initialize(16);

            this.pVertexBufferPool = new ResourcePool(this, webgl.WebGLVertexBuffer);
            this.pVertexBufferPool.initialize(16);

            this.pVideoBufferPool = new ResourcePool(this, webgl.WebGLVertexTexture);
            this.pVideoBufferPool.initialize(16);

            this.pTextureBufferPool = new ResourcePool(this, webgl.WebGLTextureBuffer);
            this.pTextureBufferPool.initialize(16);

            this.pShaderProgramPool = new ResourcePool(this, webgl.WebGLShaderProgram);
            this.pShaderProgramPool.initialize(16);

            this.pRenderBufferPool = new ResourcePool(this, webgl.WebGLInternalRenderBuffer);
            this.pRenderBufferPool.initialize(16);

            this.pDepthBufferPool = new ResourcePool(this, webgl.WebGLDepthBuffer);
            this.pDepthBufferPool.initialize(16);


            this.pEffectDataPool = new ResourcePool(this, resources.EffectData);
            this.pEffectDataPool.initialize(8);


            this.pComponentPool = new ResourcePool(this, resources.Component);
            this.pComponentPool.initialize(16);
        }

        private registerDeviceResources(): void {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 517 ); logger.log("Registering Video Device Resources\n"); } ;
            this.pTexturePool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.TEXTURE_RESOURCE));
            this.pVertexBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.VERTEXBUFFER_RESOURCE));
            this.pIndexBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.INDEXBUFFER_RESOURCE));
            this.pEffectPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.EFFECT_RESOURCE));
            this.pRenderMethodPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.RENDERMETHOD_RESOURCE));
            this.pColladaPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.MODEL_RESOURCE | EModelFormats.COLLADA));
            this.pObjPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.MODEL_RESOURCE | EModelFormats.OBJ));
            this.pImagePool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.IMAGE_RESOURCE));
            this.pSurfaceMaterialPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.SURFACEMATERIAL_RESOURCE));
            this.pVideoBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.VIDEOBUFFER_RESOURCE));
            this.pShaderProgramPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.SHADERPROGRAM_RESOURCE));
            this.pComponentPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.COMPONENT_RESOURCE));
            this.pEffectDataPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.EFFECTDATA_RESOURCE));
        }

        private unregisterDeviceResources(): void {
            { logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 573 ); logger.log("Unregistering Video Device Resources"); } ;

            this.pTexturePool.unregisterResourcePool();
            this.pVertexBufferPool.unregisterResourcePool();
            this.pIndexBufferPool.unregisterResourcePool();
            this.pEffectPool.unregisterResourcePool();
            this.pRenderMethodPool.unregisterResourcePool();
            this.pColladaPool.unregisterResourcePool();
            this.pObjPool.unregisterResourcePool();
            this.pImagePool.unregisterResourcePool();
            this.pSurfaceMaterialPool.unregisterResourcePool();
            this.pVideoBufferPool.unregisterResourcePool();
            this.pShaderProgramPool.unregisterResourcePool();
            this.pComponentPool.unregisterResourcePool();
        }

    	static private pTypedResourseTotal:  number [] = [
	        <number>EVideoResources.TOTAL_VIDEO_RESOURCES,
	        <number>EAudioResources.TOTAL_AUDIO_RESOURCES,
	        <number>EGameResources.TOTAL_GAME_RESOURCES
	    ];
    }
}



















module akra {
	export interface IScene2d extends IScene {

	}
}












// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;

// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;

// getAnimationController(): IAnimationController;

// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;

// addNode(pNode: ISceneNode): void;

// addSkeleton(pSkeleton: ISkeleton): void;

// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;

// getRootNodes(): ISceneNode[];

// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;

// //instead old method: applyShadow();
// _setup(): bool;

// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;



















module akra {
	;
	;

	export interface IModelEntry extends ISceneNode {
		resource: IModel;
	}
}





module akra.scene.objects {
	export class ModelEntry extends SceneNode implements IModelEntry {
		protected _pModelResource: IModel = null;

		/**@inline*/  get resource(): IModel {
			return this._pModelResource;
		}

		constructor (pScene: IScene3d, pModel: IModel)  {
			super(pScene, EEntityTypes.MODEL_ENTRY);

			this._pModelResource = pModel;
		}
	}

	export function isModelEntry(pEntity: IEntity): bool {
		return !isNull(pEntity) && pEntity.type === EEntityTypes.MODEL_ENTRY;
	}
}








module akra {

	;

	export interface IDisplayList extends IEventProvider {
		 name: string;
//если используется <quick search>, то в случае если узлы сцены не были изменены, выдается null.
		_findObjects(pCamera: ICamera, pResultArray?: IObjectArray, bQuickSearch?: bool): IObjectArray;
		_setup(pScene: IScene3d): void;
	}
}















module akra {

	;
	;
	;
	;
	;

	export interface IOcTree extends IDisplayList {

		 depth:  number ;
		 worldScale: IVec3;
		 worldOffset: IVec3;

		create(pWorldBoundingBox: IRect3d, iDepth:  number , nNode?:  number ): void;
		isReady(): bool;
		findTreeNode(pObject: ISceneObject): IOcTreeNode;
		findTreeNodeByRect(iX0:  number , iX1:  number , iY0:  number , iY1:  number , iZ0:  number , iZ1:  number ): IOcTreeNode;
		getAndSetFreeNode(iLevel:  number , iComposedIndex:  number , pParentNode: IOcTreeNode): IOcTreeNode;
		deleteNodeFromTree(pNode: IOcTreeNode): void;

//debug metod
		_toSimpleObject(pNode?: IOcTreeNode): any;

//getAndSetFreeNode(iLevel: int, iX: int, iY: int, iZ: int, iIndex: int): IOcTreeNode;
//getNodeFromLevelXYZ(iLevel: int, iIndex: int): IOcTreeNode;
//destroy(): void;
//findTreeNode(iX0: int, iX1: int, iY0: int, iY1: int, iZ0: int, iZ1: int): IOcTreeNode;
//buildByteRect(pWorldRect: IRect3d, pWorldByteRect: IOcTreeRect): void;
//addOrUpdateSceneObject(pNewNode: ISceneObject): IOcTreeNode;
	}
}





















module akra.scene {
	export class DisplayList implements IDisplayList {
		protected _pScene: IScene3d = null;
		protected _sName: string = "";

		/**@inline*/  get name(): string { return this._sName; }
		/**@inline*/  set name(sName: string) { this._sName = sName; }

		_onNodeAttachment(pScene: IScene3d, pNode: ISceneNode): void {
			this.attachObject(pNode);
		}

		_onNodeDetachment(pScene: IScene3d, pNode: ISceneNode): void {
			this.detachObject(pNode);
		}

		protected attachObject(pNode: ISceneNode): void {
			{ logger.setSourceLocation( "DisplayList.ts" , 29 ); logger.error("pure virtual method DisplayList::attachObject()"); } ;
		}

		protected detachObject(pNode: ISceneNode): void {
			{ logger.setSourceLocation( "DisplayList.ts" , 33 ); logger.error("pure virtual method DisplayList::detachObject()"); } ;
		}

		_setup(pScene: IScene3d): void {
			if (isDefAndNotNull(this._pScene)) {
				{ logger.setSourceLocation( "DisplayList.ts" , 38 ); logger.criticalError("list movement from scene to another scene temprary unsupported!"); } ;
			}

			this._pScene = pScene;

			this.connect(pScene, "nodeAttachment" , "_onNodeAttachment" ) ;
			this.connect(pScene, "nodeDetachment" , "_onNodeDetachment" ) ;

			var me = this;

			pScene.getRootNode().explore(function (pEntity: IEntity) {
					me._onNodeAttachment(pScene, <ISceneNode>pEntity);
				});
		}

		_findObjects(pCamera: ICamera, pResultArray?: IObjectArray, bQuickSearch?: bool = false): IObjectArray {
			{ logger.setSourceLocation( "DisplayList.ts" , 54 ); logger.error("pure virtual method"); } ;
			return null;
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return DisplayList._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
	}
}












module akra {

	;
	;
	;
	;

	export interface IOcTreeNode {
/** Parent tree */

		tree: IOcTree;
/** Level of node */

		level:  number ;
/** Byte x-coord of node */

// x: int;
// /** Byte y-coord of node */
// y: int;
// /** Byte z-coord of node */
// z: int;
/** Index in array of nodes in tree */

		index:  number ;
/** First SceneObject in this node */

		membersList: IObjectList;
/** Rect of node in real world */

		worldBounds: IRect3d;
/** Link ro next node in tree */

//forwardNodeLink: IOcTreeNode;
/** Link ro previous node in tree */

		rearNodeLink: IOcTreeNode;

//eight links to possible children nodes;		
		childrenList: IObjectList[];

		addMember(pMember: ISceneObject): void;
		removeMember(pMember: ISceneObject): void;

		toString(): string;
	}
}
















module akra {
	export interface IListExplorerFunc {
		(data: any, index?:  number ): bool;
//(data: any): void;
	}

/** ObjectList interface. */

	export interface IObjectList {
/** Number of elements in list */

		length:  number ;
/** First element in list */

		first: any;
/** Last element in list */

		last: any;
/** Current element in list */

		current: any;

/** Lock list for midifications. */

		lock(): void;
/** Unlock list */

		unlock(): void;
/** Is list locked ? */

		isLocked(): bool;

/** Set current element to <n> position. */

		seek(n?:  number ): IObjectList;
/** Get next element */

		next(): any;
/** Get prev element */

		prev(): any;
/** Push element to end of list. */

		push(element: any): IObjectList;
/** Pop element from end of list. */

		pop(): any;
/** Add element to list head. */

		prepend(element: any): IObjectList;

/** Add element from array. */

		fromArray(elements: any[], iOffset?:  number , iSize?:  number ): IObjectList;

/** Insert element before <n> element. */

		insert(n:  number , data: any): IObjectList;
/** Get valuie of <n> element */

		value(n:  number , defaultValue?: any): any;
/** Get index of element with given data */

		indexOf(element: any, from?:  number ):  number ;
/** Get sub list from this list */

		mid(pos?:  number , size?:  number ): IObjectList;
/** slice from array */

		slice(start?:  number , end?:  number ): IObjectList;
/** Move element from <from> postion to <to> position.*/

		move(from:  number , to:  number ): IObjectList;

/** Replace data of <n> element. */

		replace(pos:  number , value: any): IObjectList;
/** Erase element with number <n>. */

		erase(pos:  number ): IObjectList;
/** Erase elements from begin to end. */

		erase(begin:  number , end:  number ): IObjectList;
/** Is list contains data with <value>?*/

		contains(value: any): bool;

/** Get data of <n> item and remove it. */

		takeAt(pos:  number ): any;
/** Get data of first item and remove it. */

		takeFirst(): any;
/** Get data of last item and remove it. */

		takeLast(): any;
/** Get data of current item and remove it. */

		takeCurrent(): any;

/** Remove <n> item. */

		removeAt(n:  number ): void;
/** Remove one lement with data <element>. */

		removeOne(element: any): void;
/** Remove all lement with data <element>. */

		removeAll(element: any):  number ;

/** Swap items. */

		swap(i:  number , j:  number ): IObjectList;
/** Add another list to this */

		add(list: IObjectList): IObjectList;
/** Is this list equal to <list>. */

		isEqual(list: IObjectList): bool;

/** Clear list. */

		clear(): IObjectList;
/** For each loop. */

		forEach(fn: IListExplorerFunc): void;
	}
}







module akra.util {
	export interface IObjectListItem {
		next: IObjectListItem;
		prev: IObjectListItem;
		data: any;
	};


	export class ObjectList implements IObjectList {
		protected _pHead: IObjectListItem = null;
		protected _pTail: IObjectListItem = null;
		protected _pCurrent: IObjectListItem = null;
		protected _iLength:  number  = 0;
		protected _bLock: bool = false;


		/**@inline*/  get length():  number  {
			return this._iLength;
		};

		/**@inline*/  get first(): any {
			this._pCurrent = this._pHead;
			return (isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
		};

		/**@inline*/  get last(): any {
			this._pCurrent = this._pTail;
			return (isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
		}

		/**@inline*/  get current(): any {
			return (isDefAndNotNull(this._pCurrent)) ? this._pCurrent.data : null;
		}

		/**@inline*/  lock(): void {
			this._bLock = true;
		}

		/**@inline*/  unlock(): void {
			this._bLock = false;
		}

		/**@inline*/  isLocked(): bool {
			return this._bLock;
		}

		/**@inline*/  value(n:  number ): any{
			return this.find(n).data;
		};

		constructor (pData?: any[]) {
			if (arguments.length) {
				this.fromArray(pData);
			}
		}

		indexOf(pData: any, iFrom:  number  = 0):  number {
			var pItem: IObjectListItem = this.find(iFrom);

			for(var i:  number  = iFrom; i<this._iLength; i++){
				if(pItem.data === pData){
					return i;
				}
				pItem = pItem.next;
			}
			return -1;
		};

		mid(iPos:  number  = 0, iSize:  number  = this._iLength): IObjectList{
			iSize = Math.min(this._iLength - iPos, iSize);

			if (iPos > this._iLength - 1) {
				return null;
			}

			var pNewList: IObjectList = new ObjectList();
			var pItem: IObjectListItem = this.find(iPos);

			for (var i:  number  = 0; i < iSize; ++ i) {
				pNewList.push(pItem.data);
				pItem = pItem.next;
			};

			return pNewList;
		};

		/**@inline*/  slice(iStart:  number  = 0, iEnd:  number  = Math.max(this._iLength - iStart, 0)): IObjectList {
			return this.mid(iStart, iEnd - iStart);
		}

		/**@inline*/  move(iFrom:  number , iTo:  number ): IObjectList{
			return this.insert(iTo - 1, this.takeAt(iFrom));
		};

		/**@inline*/  replace(iPos:  number , pData: any): IObjectList{
			{ logger.setSourceLocation( "util/ObjectList.ts" , 102 ); logger.assert(!this.isLocked(), "list locked."); } ;
			this.find(iPos).data = pData;
			return this;
		};

		erase(pos:  number ): IObjectList;
		erase(begin:  number , end:  number ): IObjectList;
		erase(begin:  number , end?:  number ): IObjectList{
			if(arguments.length < 2){
				this.takeAt(< number >arguments[0]);
			}
			else{
				end = Math.min(end, this._iLength);
				for(var i:  number  = begin; i < end; i++){
					this.takeAt(i);
				}
			}
			return this;
		};

		/**@inline*/  contains(pData: any): bool{
			return (this.indexOf(pData) >= 0);
		};

		/**@inline*/  removeAt(n:  number ): void{
			this.takeAt(n);
		};

		/**@inline*/  removeOne(pData: any): void{
			this.removeAt(this.indexOf(pData));
		};

		/**@inline*/  removeAll(pData: any):  number  {
			var i:  number ;
			var n:  number  = this.length;

			while((i = this.indexOf(pData)) >= 0){
				this.removeAt(i);
				i--;
			}

			return n;
		}

		swap(i:  number , j:  number ): IObjectList {
			{ logger.setSourceLocation( "util/ObjectList.ts" , 147 ); logger.assert(!this.isLocked(), "list locked."); } ;

			i = Math.min(i, this._iLength-1);
			j = Math.min(j, this._iLength-1);

			if (i != j) {
				var pItem1: IObjectListItem = this.find(i);
				var pItem2: IObjectListItem = this.find(j);

				var pTmp: any = pItem1.data;

				pItem1.data = pItem2.data;
				pItem2.data = pTmp;
			}

			return this;
		}

		add(pList: IObjectList): IObjectList{
			pList.seek(0);

			if(pList.length > 1){
				this.push(pList.first());
			}

			for(var i:  number =1; i<pList.length; i++){
				this.push(pList.next());
			}

			return this;
		}

		seek(n:  number  = 0): IObjectList {
			var pElement: IObjectListItem;

			n = Math.min(n, this._iLength - 1);

			if (n > this._iLength / 2) {
				pElement = this._pTail;

				for (var m:  number  = this._iLength - 1 - n; m > 0; -- m) {
					pElement = pElement.prev;
				}
			}
			else {
				pElement = this._pHead;

				for (var i:  number  = 0; i < n; ++ i) {
					pElement = pElement.next;
				}
			}

			this._pCurrent = pElement;

			return this;
		};

		/**@inline*/  next(): any {
			return (isDefAndNotNull(this._pCurrent) && isDefAndNotNull(this._pCurrent.next))? (this._pCurrent = this._pCurrent.next).data: null;
		}

		/**@inline*/  prev(): any {
			return (isDefAndNotNull(this._pCurrent) && isDefAndNotNull(this._pCurrent.prev))? (this._pCurrent = this._pCurrent.prev).data: null;
		}

		/**@inline*/  push(pElement: any): IObjectList{
			return this.insert(this._iLength, pElement)
		};

		/**@inline*/  takeAt(n:  number ): any{
			{ logger.setSourceLocation( "util/ObjectList.ts" , 217 ); logger.assert(!this.isLocked(), "list locked."); } ;

			if(n < 0){
				return null;
			}

			return this.pullElement(this.find(n));
		};

		private pullElement(pItem: IObjectListItem): any {
			if (isNull(pItem)) {
//this case theoretically cannot happen, but ....
				return null;
			}

			if (isNull(pItem.prev)) {
				this._pHead = pItem.next;
			}
			else {
				pItem.prev.next = pItem.next;
			}

			if (isNull(pItem.next)) {
				this._pTail = pItem.prev;
			}
			else {
				pItem.next.prev = pItem.prev;
			}

			this._iLength --;

			if (isNull(pItem.next)) {
				this._pCurrent = this._pTail;
			}
			else {
				this._pCurrent = pItem.next;
			}

			return this.releaseItem(pItem);
		};


		/**@inline*/  takeFirst(): any{
			return this.takeAt(0);
		};

		/**@inline*/  takeLast(): any {
			return this.takeAt(this._iLength - 1);
		};

		/**@inline*/  takeCurrent(isPrev: bool = false): any {
//console.log(isDefAndNotNull(this._pCurrent));
			return this.pullElement(this._pCurrent);
		}

		/**@inline*/  pop(): any{
			return this.takeAt(this._iLength - 1);
		};

		/**@inline*/  prepend(pElement: any): IObjectList{
			return this.insert(0,pElement)
		};

		/**@inline*/  private find(n:  number ): IObjectListItem{
			if (n < this._iLength) {
				this.seek(n);
				return this._pCurrent;
			}

			return null;
		};

		/**@inline*/  private releaseItem(pItem: IObjectListItem): any {
			var pData: any = pItem.data;

			pItem.next = null;
			pItem.prev = null;
			pItem.data = null;

			ObjectList.listItemPool.push(pItem);

			return pData;
		};

		/**@inline*/  private createItem(): IObjectListItem {
			if (ObjectList.listItemPool.length == 0) {
// LOG("allocated object list item");
				return {next: null, prev: null, data: null};
			}
// LOG("before pop <----------", this._iLength, this.first);
			return <IObjectListItem>ObjectList.listItemPool.pop();
		}

		fromArray(elements: any[], iOffset:  number  = 0, iSize:  number  = elements.length): IObjectList{
			iOffset = Math.min(iOffset, this._iLength);

			for(var i:  number  = 0; i < iSize; i++){
				this.insert(iOffset + i, elements[i]);
			}

			return this;
		}

		insert(n:  number , pData: any): IObjectList{
			{ logger.setSourceLocation( "util/ObjectList.ts" , 321 ); logger.assert(!this.isLocked(), "list locked."); } ;

			var pNew: IObjectListItem = this.createItem();
			var pItem: IObjectListItem;

			n = Math.min(n, this._iLength);
			pNew.data = pData;


			if (n == 0) {
				if (isNull(this._pHead)) {
					this._pTail = pNew;
				}

				pNew.next = this._pHead;
				this._pHead = pNew;
			}
			else {
				pItem = this.find(n - 1);

				if(pItem == null) {
					this._pHead = pNew;
				}
				else {

					if (pItem.next == null) {
						this._pTail = pNew;
					}
					else {
						pNew.next = pItem.next;
						pItem.next.prev = pNew;
					}

					pItem.next = pNew;
					pNew.prev = pItem;
				}
			}

			this._iLength ++;
			this._pCurrent = pNew;

			return this;
		};

		isEqual(pList: IObjectList): bool {
			if (this._iLength == pList.length) {
				if (this === pList) {
					return true;
				}

				var l1: IObjectListItem = this.first;
				var l2: IObjectListItem = pList.first;

				for (var i:  number  = 0; i < this._iLength; ++i) {
					if (l1 != l2) {
						return false;
					}

					l1 = this.next();
					l2 = pList.next();
				}

				return true;
			}

			return false;
		}

		clear(): IObjectList {
			{ logger.setSourceLocation( "util/ObjectList.ts" , 390 ); logger.assert(!this.isLocked(), "list locked."); } ;

			var pPrev: IObjectListItem;
			var pNext: IObjectListItem;

			this._pCurrent = this._pHead;

			for (var i:  number  = 0; i < this._iLength; ++ i) {
				pPrev = this._pCurrent;
				pNext = this._pCurrent = this._pCurrent.next;

				this.releaseItem(pPrev);
			}

			this._pHead = this._pCurrent = this._pTail = null;
			this._iLength = 0;

			return this;
		}

		forEach(fn: IListExplorerFunc): void {
			var pItem: IObjectListItem = this._pHead;
			var n:  number  = 0;
			do {
				if (fn(pItem.data, n ++) === false) {
					return;
				}
			} while ((pItem = pItem.next));
		}

		static private listItemPool: IObjectArray = new ObjectArray;

	}
}

module akra {
	export var ObjectList = util.ObjectList;
}





module akra.scene {

/** OcTreeNode class represent node of OcTree */

	export class OcTreeNode implements IOcTreeNode {
/** Parent tree */

		tree: IOcTree;
/** Level of node */

		level:  number  = 0;
/** Byte x-coord of node */

//x: int = 0;
/** Byte y-coord of node */

//y: int = 0;
/** Byte z-coord of node */

//z: int = 0;
/** Index in array of nodes in tree */

		index:  number  = 0;
/** First SceneObject in this node */

		membersList: IObjectList;
/** Rect of node in real world */

		worldBounds: IRect3d;

/** Link to previous node in tree */

		rearNodeLink: IOcTreeNode = null;

//eight links to possible children nodes;		
		childrenList: IObjectList[];

//index - is xyz where x-left = 0, x-right = 1 etc.

		constructor(pTree: IOcTree){
			this.membersList = new util.ObjectList();
			this.worldBounds = new geometry.Rect3d();

			this.childrenList = new Array(8);
			for(var i=0; i<8;i++){
				this.childrenList[i] = new util.ObjectList();
			}

			this.tree = pTree;
		}

/**
		 * Add object in this node
		 */

		addMember(pObject: ISceneObject): void {
			this.membersList.push(pObject);
			this.connect(pObject,  "worldBoundsUpdated" ,  "OcTreeObjectMoved" , EEventTypes.UNICAST);
// console.log(this.membersList);
		};

/**
		 * Remove member object from node and release node if there are not members in it
		 */

		removeMember(pObject: ISceneObject): void {
			var i: number  = this.membersList.indexOf(pObject);
// console.log('position in list ------------>',i);

// make sure this is one of ours
			{ logger.setSourceLocation( "OcTreeNode.ts" , 69 ); logger.assert(i>=0, "error removing member cannot find member"); } ;

	    	if(i>=0){
	    		this.membersList.takeAt(i);
	    		this.disconnect(pObject,  "worldBoundsUpdated" ,  "OcTreeObjectMoved" , EEventTypes.UNICAST);
	    	}

	    	if(this.membersList.length === 0){
	    		this.tree.deleteNodeFromTree(this);
	    	}
		};

		toString(): string{
			var sStr = "guid: " + this._iGuid.toString() + "\n";
			sStr += "level: " + this.level.toString() + "\n";
			sStr += "index: " + this.index.toString() + "\n";
			sStr += "world bounds: " + this.worldBounds.toString() + "\n"
			return sStr;
		};

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return OcTreeNode._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;

		OcTreeObjectMoved(pObject: ISceneObject){
// console.warn('object moving');
			var pNode: IOcTreeNode = this.tree.findTreeNode(pObject);
			if(pNode !== this){
				this.removeMember(pObject);
				pNode.addMember(pObject);
			}
		};
	};

	export class OcTreeRootNode extends OcTreeNode implements IOcTreeNode{

		protected _pBasicWorldBounds: IRect3d;

		constructor(pTree: IOcTree){
			super(pTree);

			var iTmp:  number  = (1 << this.tree.depth);

			this._pBasicWorldBounds = new geometry.Rect3d(0, iTmp, 0, iTmp, 0, iTmp);
		    this._pBasicWorldBounds.divSelf(this.tree.worldScale);
		    this._pBasicWorldBounds.subSelf(this.tree.worldOffset);

		    this.worldBounds.set(this._pBasicWorldBounds);
		};

		addMember(pMember: ISceneObject): void{
			super.addMember(pMember);
//обновляем границы нода, критично, в том случае если объект выходит за границы нода, так как иначе отсекаться будет неправильно
	    	this._updateNodeBoundingBox();
		};

		removeMember(pObject: ISceneObject): void{
			var i: number  = this.membersList.indexOf(pObject);

// make sure this is one of ours
			{ logger.setSourceLocation( "OcTreeNode.ts" , 127 ); logger.assert(i>=0, "error removing member cannot find member"); } ;

	    	if(i>=0){
	    		this.membersList.takeAt(i);
	    		this.disconnect(pObject,  "worldBoundsUpdated" ,  "OcTreeObjectMoved" , EEventTypes.UNICAST);
	    	}

//обновляем границы нода, критично, в том случае если объект выходит за границы нода, так как иначе отсекаться будет неправильно
			this._updateNodeBoundingBox();
		};

		protected _updateNodeBoundingBox(): void {
		    var pNodeWorldBounds: IRect3d = this.worldBounds;
		    pNodeWorldBounds.set(this._pBasicWorldBounds);

		    var pObject: ISceneObject = this.membersList.first;
		    while(isDefAndNotNull(pObject)){
		    	pNodeWorldBounds.unionRect(pObject.worldBounds);

		    	pObject = this.membersList.next();
		    }
		};
	}
}







// #include "IOcTreeRect.ts"
// #include "IRect3d.ts"
// #include "IVec3.ts"
// #include "geometry/Rect3d.ts"

// #define ocTreeRect() OcTreeRect.stackCeil

// module akra.scene {

// 	/** OcTreeRect class represent simple 3d byte rect */
// 	export class OcTreeRect implements IOcTreeRect { 
// 		protected x0: int = 0;
// 		protected x1: int = 0;
// 		protected y0: int = 0;
// 		protected y1: int = 0;
// 		protected z0: int = 0;
// 		protected z1: int = 0;


// 		constructor (pRect: OcTreeRect);
// 		constructor (x0: int, x1: int, y0: int, y1: int, z0: int, z1: int);
// 		constructor (x0, x1?, y0?, y1?, z0?, z1?) {
// 			switch (arguments.length) {
// 		        case 1:
// 		            this.x0 = (<OcTreeRect>arguments[0]).x0;
// 		            this.x1 = (<OcTreeRect>arguments[0]).x1;
// 		            this.y0 = (<OcTreeRect>arguments[0]).y0;
// 		            this.y1 = (<OcTreeRect>arguments[0]).y1;
// 		            this.z0 = (<OcTreeRect>arguments[0]).z0;
// 		            this.z1 = (<OcTreeRect>arguments[0]).z1;
// 		            break;
// 		        case 6:
// 		            this.x0 = arguments[0];
// 		            this.x1 = arguments[1];
// 		            this.y0 = arguments[2];
// 		            this.y1 = arguments[3];
// 		            this.z0 = arguments[4];
// 		            this.z1 = arguments[5];
// 		            break;
// 		    }
// 		}

// 		/**
// 		 * Convert Rect3d to byte rect
// 		 */
// 		convert(pWorldRect: IRect3d, v3fOffset: IVec3, v3fScale: IVec3): void {
// 		    var convertedRect: IRect3d = new geometry.Rect3d(pWorldRect);
// 		    // reposition and v3fScale world coordinates to OcTree coordinates
// 		    convertedRect.addSelf(v3fOffset);
// 		    convertedRect.multSelf(v3fScale);
// 		    //alert([convertedRect.iX0,convertedRect.iY0,convertedRect.iZ0,convertedRect.iX1,convertedRect.iY1,convertedRect.iZ1]);
// 		    // reduce by a tiny amount to handle tiled data
// 		    convertedRect.x1 = math.max(convertedRect.x1 - 0.01, convertedRect.x0);
// 		    convertedRect.y1 = math.max(convertedRect.y1 - 0.01, convertedRect.y0);
// 		    convertedRect.z1 = math.max(convertedRect.z1 - 0.01, convertedRect.z0);

// 		    // convert to integer values, taking the floor of each real
// 		    this.x0 = convertedRect.fX0 << 0;
// 		    this.x1 = convertedRect.fX1 << 0;
// 		    this.y0 = convertedRect.fY0 << 0;
// 		    this.y1 = convertedRect.fY1 << 0;
// 		    this.z0 = convertedRect.fZ0 << 0;
// 		    this.z1 = convertedRect.fZ1 << 0;
// 		    // we must be positive
// 		    this.x0 = math.clamp(this.x0, 0, 1022);
// 		    this.y0 = math.clamp(this.y0, 0, 1022);
// 		    this.z0 = math.clamp(this.z0, 0, 1022);

// 		    // we must be at least one unit large
// 		    this.x1 = math.clamp(this.x1, this.x0 + 1, 1023);
// 		    this.y1 = math.clamp(this.y1, this.y0 + 1, 1023);
// 		    this.z1 = math.clamp(this.z1, this.z0 + 1, 1023);
// 		}

// 		/**
// 		 * Set
// 		 */
// 		set(iX0: int, iX1: int, iY0: int, iY1: int, iZ0: int, iZ: int): void {
// 		    this.iX0 = iX0;
// 		    this.iX1 = iX1;
// 		    this.iY0 = iY0;
// 		    this.iY1 = iY1;
// 		    this.iZ0 = iZ0;
// 		    this.iZ1 = iZ1;
// 		}

// 		ALLOCATE_STORAGE(OcTreeRect, 8);
// 	}
// }






















module akra {

	;

	export interface IRay2d {
		point: IVec2;
		normal: IVec2;
	};
}



module akra.geometry{
	export  class  Ray2d implements IRay2d{
		point: IVec2;
		normal: IVec2;

		constructor(){
			this.point = new Vec2();
			this.normal = new Vec2();
		};
	};
}












module akra {

	;

	export interface IRay3d {
		point: IVec3;
		normal: IVec3;
	};
}



module akra.geometry{
	export  class  Ray3d implements IRay3d{
		point: IVec3;
		normal: IVec3;

		constructor(){
			this.point = new Vec3();
			this.normal = new Vec3();
		};
	};
}

















module akra.geometry{

	export function intersectPlane2dRay2d(pPlane: IPlane2d, pRay: IRay2d): bool{
		var fDistance:  number  = pPlane.signedDistance(pRay.point);
		var fNdotV:  number  = pPlane.normal.dot(pRay.normal);

		if(fDistance == 0.){
			return true;
		}
		else{
			if(fNdotV == 0.){
				return false;
			}
			else{
				if(fDistance/fNdotV < 0.){
					return true;
				}
				else{
					return false;
				}
			}
		}
	};

	export function intersectPlane3dRay3d(pPlane: IPlane3d, pRay: IRay3d): bool{
		var fDistance:  number  = pPlane.signedDistance(pRay.point);
		var fNdotV:  number  = pPlane.normal.dot(pRay.normal);

		if(fDistance == 0.){
			return true;
		}
		else{
			if(fNdotV == 0.){
				return false;
			}
			else{
				if(fDistance/fNdotV < 0.){
					return true;
				}
				else{
					return false;
				}
			}
		}
	};

	export function intersectCircleRay2d(pCircle: ICircle, pRay: IRay2d): bool{
		var v2fCenterToPoint: IVec2 = pRay.point.subtract(pCircle.center,  Vec2.stackCeil.set() );

		var v2fNormal: IVec2 = pRay.normal;

//a*t^2+ 2b*t + c = 0;

		var fA:  number  = v2fNormal.lengthSquare();
		var fB:  number  = v2fCenterToPoint.dot(v2fNormal);
		var fC:  number  = v2fCenterToPoint.lengthSquare() - pCircle.radius*pCircle.radius;

/*b^2/4 - a*c*/
		var fDiscriminant:  number  = fB*fB - fA*fC;

		if(fDiscriminant < 0.){
			return false;
		}

		var fSqrtDiscriminant:  number  = math.sqrt(fDiscriminant);

		var fT1:  number  = (-fB + fSqrtDiscriminant)/fA;
//var fT2: float = (-fB - fSqrtDiscriminant)/fA;
//fT2 don't needed because fT2 < fT1 always
//since fA > 0

		if(fT1 < 0.){
			return false;
		}
		else{
			return true;
		}
	};

	export function intersectSphereRay3d(pSphere: ISphere, pRay: IRay3d): bool{
		var v3fCenterToPoint: IVec3 = pRay.point.subtract(pSphere.center,  Vec3.stackCeil.set() );

		var v3fNormal: IVec3 = pRay.normal;

//a*t^2+ 2b*t + c = 0;

		var fA:  number  = v3fNormal.lengthSquare();
		var fB:  number  = v3fCenterToPoint.dot(v3fNormal);
		var fC:  number  = v3fCenterToPoint.lengthSquare() - pSphere.radius*pSphere.radius;

/*b^2/4 - a*c*/
		var fDiscriminant:  number  = fB*fB - fA*fC;

		if(fDiscriminant < 0.){
			return false;
		}

		var fSqrtDiscriminant:  number  = math.sqrt(fDiscriminant);

		var fT1:  number  = (-fB + fSqrtDiscriminant)/fA;
//var fT2: float = (-fB - fSqrtDiscriminant)/fA;
//fT2 don't needed because fT2 < fT1 always
//since fA > 0

		if(fT1 < 0.){
			return false;
		}
		else{
			return true;
		}
	};

	export function intersectRect2dRay2d(pRect: IRect2d, pRay: IRay2d): bool{
		var v2fNormal: IVec2 = pRay.normal;
		var v2fPoint: IVec2 = pRay.point;

		var fT1:  number , fT2:  number ;

		var fX1:  number , fX2:  number ;
		var fY1:  number , fY2:  number ;

		if(v2fNormal.x != 0.){
			fT1 = (pRect.x0 - v2fPoint.x)/v2fNormal.x;
			fT2 = (pRect.x1 - v2fPoint.x)/v2fNormal.x;
		}
		else{
			fT1 = (pRect.y0 - v2fPoint.y)/v2fNormal.y;
			fT2 = (pRect.y1 - v2fPoint.y)/v2fNormal.y;
		}

		if(fT1 < 0 && fT2 < 0){
			return false;
		}

		fT1 = math.max(fT1,0.);
		fT2 = math.max(fT2,0.);

		fX1 = v2fPoint.x + fT1*v2fNormal.x;
		fX2 = v2fPoint.x + fT2*v2fNormal.x;

		fY1 = v2fPoint.y + fT1*v2fNormal.y;
		fY2 = v2fPoint.y + fT2*v2fNormal.y;

		if(		(fX1 < pRect.x0 && fX2 < pRect.x0)
			||  (fX1 > pRect.x1 && fX2 > pRect.x1)

			||  (fY1 < pRect.y0 && fY2 < pRect.y0)
			||  (fY1 > pRect.y1 && fY2 > pRect.y1)){

			return false;
		}

		return true;
	};

	export function intersectRect3dRay3d(pRect: IRect3d, pRay: IRay3d): bool{
		var v3fNormal: IVec3 = pRay.normal;
		var v3fPoint: IVec3 = pRay.point;

		var fT1:  number , fT2:  number ;

		var fX1:  number , fX2:  number ;
		var fY1:  number , fY2:  number ;
		var fZ1:  number , fZ2:  number ;

		if(v3fNormal.x != 0.){
			fT1 = (pRect.x0 - v3fPoint.x)/v3fNormal.x;
			fT2 = (pRect.x1 - v3fPoint.x)/v3fNormal.x;
		}
		else if(v3fNormal.y != 0.){
			fT1 = (pRect.y0 - v3fPoint.y)/v3fNormal.y;
			fT2 = (pRect.y1 - v3fPoint.y)/v3fNormal.y;
		}
		else{
			fT1 = (pRect.z0 - v3fPoint.z)/v3fNormal.z;
			fT2 = (pRect.z1 - v3fPoint.z)/v3fNormal.z;
		}

		if(fT1 < 0 && fT2 < 0){
			return false;
		}

		fT1 = math.max(fT1,0.);
		fT2 = math.max(fT2,0.);

		fX1 = v3fPoint.x + fT1*v3fNormal.x;
		fX2 = v3fPoint.x + fT2*v3fNormal.x;

		fY1 = v3fPoint.y + fT1*v3fNormal.y;
		fY2 = v3fPoint.y + fT2*v3fNormal.y;

		fZ1 = v3fPoint.z + fT1*v3fNormal.z;
		fZ2 = v3fPoint.z + fT2*v3fNormal.z;

		if(		(fX1 < pRect.x0 && fX2 < pRect.x0)
			||  (fX1 > pRect.x1 && fX2 > pRect.x1)

			||  (fY1 < pRect.y0 && fY2 < pRect.y0)
			||  (fY1 > pRect.y1 && fY2 > pRect.y1)

			||	(fZ1 < pRect.z0 && fZ2 < pRect.z0)
			||  (fZ1 > pRect.z1 && fZ2 > pRect.z1)){

			return false;
		}

		return true;
	};

	export function intersectCircleCircle(pCircle1: ICircle, pCircle2: ICircle): bool{
		var v2fCenter1: IVec2 = pCircle1.center;
		var v2fCenter2: IVec2 = pCircle2.center;

		var fX:  number  = v2fCenter2.x - v2fCenter1.x;
		var fY:  number  = v2fCenter2.y - v2fCenter1.y;

		var fContactRadius:  number  = pCircle1.radius + pCircle2.radius;

		if((fX*fX + fY*fY) > fContactRadius*fContactRadius){
			return false;
		}
		return true;
	};

	export function intersectSphereSphere(pSphere1: ISphere, pSphere2: ISphere): bool{
		var v3fCenter1: IVec3 = pSphere1.center;
		var v3fCenter2: IVec3 = pSphere2.center;

		var fX:  number  = v3fCenter2.x - v3fCenter1.x;
		var fY:  number  = v3fCenter2.y - v3fCenter1.y;
		var fZ:  number  = v3fCenter2.z - v3fCenter1.z;

		var fContactRadius:  number  = pSphere1.radius + pSphere2.radius;

		if((fX*fX + fY*fY + fZ*fZ) > fContactRadius*fContactRadius){
			return false;
		}
		return true;
	};

	export function intersectRect2dCircle(pRect: IRect2d, pCircle: ICircle){
		var v2fCenter: IVec2 = pCircle.center;
		var fOffsetX:  number  = 0., fOffsetY:  number  = 0.;
		var nInside:  number  = 0;

		if(v2fCenter.x < pRect.x0){
			fOffsetX = pRect.x0 - v2fCenter.x;
		}
		else if(v2fCenter.x > pRect.x1){
			fOffsetX = v2fCenter.x - pRect.x1;
		}
		else{
			nInside++;
		}

		if(v2fCenter.y < pRect.y0){
			fOffsetY = pRect.y0 - v2fCenter.y;
		}
		else if(v2fCenter.y > pRect.y1){
			fOffsetY = v2fCenter.y - pRect.y1;
		}
		else{
			nInside++;
		}

//if nInside == 2 then circle inside rect
		if(nInside === 2){
			return true;
		}

		var fOffsetLengthSquare:  number  = fOffsetX*fOffsetX + fOffsetY*fOffsetY;
		var fRadius:  number  = pCircle.radius;

		if(fOffsetLengthSquare > fRadius*fRadius){
			return false;
		}
		return true;
	};

	export function intersectRect3dSphere(pRect: IRect3d, pSphere: ISphere){
		var v3fCenter: IVec3 = pSphere.center;
		var fOffsetX:  number  = 0., fOffsetY:  number  = 0., fOffsetZ:  number  = 0.;
		var nInside:  number  = 0;

		if(v3fCenter.x < pRect.x0){
			fOffsetX = pRect.x0 - v3fCenter.x;
		}
		else if(v3fCenter.x > pRect.x1){
			fOffsetX = v3fCenter.x - pRect.x1;
		}
		else{
			nInside++;
		}

		if(v3fCenter.y < pRect.y0){
			fOffsetY = pRect.y0 - v3fCenter.y;
		}
		else if(v3fCenter.y > pRect.y1){
			fOffsetY = v3fCenter.y - pRect.y1;
		}
		else{
			nInside++;
		}

		if(v3fCenter.z < pRect.z0){
			fOffsetZ = pRect.z0 - v3fCenter.z;
		}
		else if(v3fCenter.z > pRect.z1){
			fOffsetZ = v3fCenter.z - pRect.z1;
		}
		else{
			nInside++;
		}

//if nInside == 3 then sphere inside rect
		if(nInside === 3){
			return true;
		}

		var fOffsetLengthSquare:  number  = fOffsetX*fOffsetX + fOffsetY*fOffsetY + fOffsetZ*fOffsetZ;
		var fRadius:  number  = pSphere.radius;

		if(fOffsetLengthSquare > fRadius*fRadius){
			return false;
		}
		return true;
	};

	export function intersectRect2dRect2d(pRect1: IRect2d, pRect2: IRect2d, pResult?: IRect2d): bool{
		if(!isDef(pResult)){
			var fX0:  number  = math.max(pRect1.x0, pRect2.x0);
			var fX1:  number  = math.min(pRect1.x1, pRect2.x1);
			if(fX0 <= fX1){
				var fY0:  number  = math.max(pRect1.y0, pRect2.y0);
				var fY1:  number  = math.min(pRect1.y1, pRect2.y1);
				if(fY0 <= fY1){
					return true;
				}
			}
			return false;
		}
		else{
			pResult.x0 = math.max(pRect1.x0, pRect2.x0);
			pResult.x1 = math.min(pRect1.x1, pRect2.x1);

			pResult.y0 = math.max(pRect1.y0, pRect2.y0);
			pResult.y1 = math.min(pRect1.y1, pRect2.y1);

			return pResult.isValid();
		}
	};

	export function intersectRect3dRect3d(pRect1: IRect3d, pRect2: IRect3d, pResult?: IRect3d): bool{
		if(!isDef(pResult)){
			var fX0:  number  = math.max(pRect1.x0, pRect2.x0);
			var fX1:  number  = math.min(pRect1.x1, pRect2.x1);
			if(fX0 <= fX1){
				var fY0:  number  = math.max(pRect1.y0, pRect2.y0);
				var fY1:  number  = math.min(pRect1.y1, pRect2.y1);
				if(fY0 <= fY1){
					var fZ0:  number  = math.max(pRect1.z0, pRect2.z0);
					var fZ1:  number  = math.min(pRect1.z1, pRect2.z1);
					if(fZ0 <= fZ1){
						return true;
					}
				}
			}
			return false;
		}
		else{
			pResult.x0 = math.max(pRect1.x0, pRect2.x0);
			pResult.x1 = math.min(pRect1.x1, pRect2.x1);

			pResult.y0 = math.max(pRect1.y0, pRect2.y0);
			pResult.y1 = math.min(pRect1.y1, pRect2.y1);

			pResult.z0 = math.max(pRect1.z0, pRect2.z0);
			pResult.z1 = math.min(pRect1.z1, pRect2.z1);

			return pResult.isValid();
		}
	};

	export function intersect(pPlane: IPlane2d, pRay: IRay2d): bool;
	export function intersect(pPlane: IPlane3d, pRay: IRay3d): bool;
	export function intersect(pCircle: ICircle, pRay: IRay2d): bool;
	export function intersect(pSphere: ISphere, pRay: IRay3d): bool;
	export function intersect(pRect: IRect2d, pRay: IRay2d): bool;
	export function intersect(pRect: IRect3d, pRay: IRay3d): bool;
	export function intersect(pCircle1: ICircle, pCircle2: ICircle): bool;
	export function intersect(pSphere1: ISphere, pSphere2: ISphere): bool;
	export function intersect(pRect: IRect2d, pCircle: ICircle): bool;
	export function intersect(pRect: IRect3d, pSphere: ISphere): bool;
	export function intersect(pRect1: IRect2d, pRect2: IRect2d, pResult?: IRect2d): bool;
	export function intersect(pRect1: IRect3d, pRect2: IRect3d, pResult?: IRect3d): bool;
	export function intersect(pRect1?, pRect2?, pResult?): bool{
		var nArgumentsLength:  number  = arguments.length;

		if(nArgumentsLength === 3){
			if(arguments[2] instanceof Rect2d){
				return intersectRect2dRect2d(arguments[0], arguments[1], arguments[2]);
			}
			else{
				return intersectRect3dRect3d(arguments[0], arguments[1], arguments[2]);
			}
		}
		else{
			var pArg0: any = arguments[0];
			var pArg1: any = arguments[1];

			if(pArg1 instanceof Ray2d){
				if(pArg0 instanceof Plane2d){
					return intersectPlane2dRay2d(pArg0, pArg1);
				}
				else if(pArg0 instanceof Circle){
					return intersectCircleRay2d(pArg0, pArg1);
				}
				else{
					return intersectRect2dRay2d(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Ray3d){
				if(pArg0 instanceof Plane3d){
					return intersectPlane3dRay3d(pArg0, pArg1);
				}
				else if(pArg0 instanceof Sphere){
					return intersectSphereRay3d(pArg0, pArg1);
				}
				else{
					return intersectRect3dRay3d(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Circle){
				if(pArg0 instanceof Circle){
					return intersectCircleCircle(pArg0, pArg1);
				}
				else{
					return intersectRect2dCircle(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Sphere){
				if(pArg0 instanceof Sphere){
					return intersectSphereSphere(pArg0, pArg1);
				}
				else{
					return intersectRect3dSphere(pArg0, pArg1);
				}
			}
			else{
				if(pArg0 instanceof Rect2d){
					return intersectRect2dRect2d(pArg0, pArg1);
				}
				else{
					return intersectRect3dRect3d(pArg0, pArg1);
				}
			}
		}
	};
};



module akra.scene {
	export enum EOcTreeConstants {
	    k_MinimumTreeDepth = 0,
	    k_MaximumTreeDepth = 10
    };

	export class OcTree extends DisplayList implements IOcTree {
/** List of OcTreeNodes on each level */

//protected _ppLevelNodes: IOcTreeNode[][] = null;
/** First node in list of all nodes */

//protected _pFirstNode: IOcTreeNode = null;
		protected _pHead: IOcTreeNode = null;
/** Size of world bounding box */

		protected _v3fWorldExtents: IVec3 = new Vec3();
/** Negate min point of bounding box */

		protected _v3fWorldScale: IVec3 = new Vec3();
/** Value of relation between (1024,1024,1024) and bounding box size */

		protected _v3fWorldOffset: IVec3 = new Vec3();
/** Maximum depth of tree. Value set when you call OcTree::create() */

		protected _iDepth:  number  = 0;
//protected _iSize: int = 0;//2^iDepth;
/** 
		 * Список свободных узлов(объектов OcTreeNode). 
		 * Необходимо для экономии ресурсов памяти и чтобы не делать лишних delete 
		 */

		protected _pFreeNodePool: IOcTreeNode[] = null;
/**
		 * Список байтовых ректов ректа камеры для тестов объектов.
		 */

//protected _pTestLocalRect: IOcTreeRect[] = null;

		constructor () {
			super();
			this.name = "OcTree";
		};

		/**@inline*/  get depth():  number {
			return this._iDepth;
		};

		/**@inline*/  get worldScale(): IVec3{
			return this._v3fWorldScale;
		};

		/**@inline*/  get worldOffset(): IVec3{
			return this._v3fWorldOffset;
		};

/**
		 * Create
		 */

		create(pWorldBoundingBox: IRect3d, iDepth:  number , nNodes:  number  = 64): void {

		    var v3fTemp: IVec3 =  Vec3.stackCeil.set() ;
		    var i:  number  = 0;


		    { logger.setSourceLocation( "OcTree.ts" , 72 ); logger.assert(!this.isReady(), "the Oc tree has already been created"); } ;
		    { logger.setSourceLocation( "OcTree.ts" , 74 ); logger.assert(iDepth >= EOcTreeConstants.k_MinimumTreeDepth && iDepth <= EOcTreeConstants.k_MaximumTreeDepth, "invalid tree depth"); }
                                                                              ;

		    this._iDepth = iDepth;

		    this._v3fWorldExtents.set(pWorldBoundingBox.size(v3fTemp));

		    this._v3fWorldOffset.set(pWorldBoundingBox.minPoint(v3fTemp).negate());

		    var iSize:  number  = 1 << iDepth;

		    this._v3fWorldScale.x = iSize / this._v3fWorldExtents.x;
		    this._v3fWorldScale.y = iSize / this._v3fWorldExtents.y;
		    this._v3fWorldScale.z = iSize / this._v3fWorldExtents.z;

// allocate the nodes
// this._ppLevelNodes = new Array(iDepth);

// for (i = 0; i < iDepth; ++i) {
//     this._ppLevelNodes[i] = new Array();
// }

// this._pTestLocalRect = new Array(iDepth);

// for (i = 0; i < iDepth; ++i) {
//     this._pTestLocalRect[i] = new OcTreeRect;
// }

		    this._pHead = new OcTreeRootNode(this);
		    this._pHead.level = 0;

		    this._pFreeNodePool = new Array();

		    for (i = 0; i < nNodes; ++i) {
		        this._pFreeNodePool.push(new OcTreeNode(this));
		    }
		}

/**
		 * is any levels of tree are availeable(some object in a tree)
		 */

		isReady(): bool {
			if(this._iDepth > 0){
				return true;
			}
			else{
				return false;
			}
		}

/**
		 * find node
		 */

		findTreeNode(pObject: ISceneObject): IOcTreeNode {
		    var pRect: IRect3d = pObject.worldBounds;
		    var iX0:  number  = pRect.x0, iX1:  number  = pRect.x1,
		        iY0:  number  = pRect.y0, iY1:  number  = pRect.y1,
		        iZ0:  number  = pRect.z0, iZ1:  number  = pRect.z1;

		    var v3fWorldOffset: IVec3 = this._v3fWorldOffset;
		    var v3fWorldScale: IVec3 = this._v3fWorldScale;

		    iX0 += v3fWorldOffset.x; iX1 += v3fWorldOffset.x;
		    iY0 += v3fWorldOffset.y; iY1 += v3fWorldOffset.y;
		    iZ0 += v3fWorldOffset.z; iZ1 += v3fWorldOffset.z;

		    iX0 *= v3fWorldScale.x; iX1 *= v3fWorldScale.x;
		    iY0 *= v3fWorldScale.y; iY1 *= v3fWorldScale.y;
		    iZ0 *= v3fWorldScale.z; iZ1 *= v3fWorldScale.z;

//round it
		    iX0 = math.floor(iX0); iX1 = math.ceil(iX1);
		    iY0 = math.floor(iY0); iY1 = math.ceil(iY1);
		    iZ0 = math.floor(iZ0); iZ1 = math.ceil(iZ1);

		    iX1 = (iX1 === iX0) ? iX0 + 1 : iX1;
		    iY1 = (iY1 === iY0) ? iY0 + 1 : iY1;
		    iZ1 = (iZ1 === iZ0) ? iZ0 + 1 : iZ1;

//var iMax1: int = 1 << this._iDepth - 2;
//var iMax2: int = 1 << this._iDepth - 1;

//iX0 = math.clamp(iX0, 0, iMax1);
//iY0 = math.clamp(iY0, 0, iMax1);
//iZ0 = math.clamp(iZ0, 0, iMax1);

//iX1 = math.clamp(iX1, iX0 + 1, iMax2);
//iY1 = math.clamp(iY1, iY0 + 1, iMax2);
//iZ1 = math.clamp(iZ1, iZ0 + 1, iMax2);

// LOG(pRect.toString());
// if(pRect.x0 == 128 && pRect.x1 == 160 && pRect.y0 == 480 && pRect.y1 == 512){
//     console.error(iX0, iX1, iY0, iY1, iZ0, iZ1);
// }

		    var pNode: IOcTreeNode = this.findTreeNodeByRect(iX0, iX1, iY0, iY1, iZ0, iZ1);

		    return pNode;
		};

/**
		 * Find tree node by Rect
		 */

		findTreeNodeByRect(iX0:  number , iX1:  number , iY0:  number , iY1:  number , iZ0:  number , iZ1:  number ): IOcTreeNode {

			var nMax:  number  = (1 << this._iDepth);

			if(iX0 < 0 || iX1 > nMax || iY0 < 0 || iY1 > nMax
				|| iZ0 < 0 || iZ1 > nMax){

				return this._pHead;
			}

			var iDepth:  number  = this._iDepth;
		    var iLevel:  number ;

///////////////////////////
		    iLevel = this._findNodeLevel(iX0, iX1, iY0, iY1, iZ0, iZ1);

// console.warn(iLevel);
///////////////////////////

		    if(iLevel == 0){
		    	return this._pHead;
		    }

		    var iComposedIndex:  number ;
		    var iShift:  number  = iDepth - iLevel;
		    iComposedIndex = (iX0 >> (iDepth - iLevel)) << (2 * iDepth + iShift);
// console.log(iComposedIndex);
		    iComposedIndex += (iY0 >> (iDepth - iLevel)) << (iDepth + iShift);
// console.log(iComposedIndex);
		    iComposedIndex += (iZ0 >> (iDepth - iLevel)) << (iShift);

			var iWay:  number ;

            var pParentNode: IOcTreeNode, pNode: IOcTreeNode;
		    pParentNode = this._pHead;
		    pNode = null;

		    var iX:  number , iY:  number , iZ:  number ;

		    var i:  number  = 0;
			while(i < iLevel){

				iX = (iX0 >> (iDepth - i - 1)) & 1;
		    	iY = (iY0 >> (iDepth - i - 1)) & 1;
		    	iZ = (iZ0 >> (iDepth - i - 1)) & 1;

				iWay = 4*iX + 2*iY + iZ;

				var pNodeList: IObjectList = pParentNode.childrenList[iWay];

				if(pNodeList.length === 0){
					pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
					pNodeList.push(pNode);
					return pNode;
				}

				var iPosition:  number  = 0;
				var pTestNode: IOcTreeNode = pNodeList.first;

				var iTestMask:  number  = (iDepth >= i + 2) ? 1 << (iDepth - i - 2) : 0;


				var iMask:  number   = (iTestMask << (2*iDepth)) + (iTestMask << iDepth) + iTestMask;

				var pParentNodeOld: IOcTreeNode = pParentNode;

				while(isDefAndNotNull(pTestNode)){
					var iTestNodeIndex:  number  = pTestNode.index;

					var iResult1:  number  = iTestNodeIndex & iMask;
					var iResult2:  number  = iComposedIndex & iMask;

					if(iResult1 === iResult2){
						if(pTestNode.level === iLevel && iTestNodeIndex == iComposedIndex){
							return pTestNode;
						}
						else if(pTestNode.level < iLevel && this._parentTest(pTestNode.level, iTestNodeIndex, iComposedIndex)){
							pParentNode = pTestNode;
							i = pTestNode.level;
							break;
						}
						else if(pTestNode.level > iLevel && this._parentTest(iLevel, iComposedIndex, iTestNodeIndex)){
//alert("" + <string><any>pTestNode.level + "  " + <string><any>iLevel);
							if(pNode === null){
								pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
								pParentNode.childrenList[iWay].push(pNode);
								i = iLevel;
							}

							var iShift = iDepth - i - 1;

							iX = (iTestNodeIndex >> (2*iDepth + iShift))&1;
							iY = (iTestNodeIndex >> (iDepth + iShift))&1;
							iZ = (iTestNodeIndex >> iShift)&1;

							var iTestWay:  number  = 4*iX + 2*iY + iZ;

							pNode.childrenList[iTestWay].push(pTestNode);
							pTestNode.rearNodeLink = pNode;

							pNodeList.takeAt(iPosition);
							if(iPosition === 0){
								pNodeList.seek(0);
								pTestNode = pNodeList.first;
								continue;
							}
							pNodeList.seek(iPosition-1);
							iPosition--;
						}
					}

					pTestNode = pNodeList.next();
					iPosition++;
				}

				if(pNode === null && pParentNodeOld === pParentNode){
					pNode = this.getAndSetFreeNode(iLevel, iComposedIndex, pParentNode);
					pParentNode.childrenList[iWay].push(pNode);
					break;
				}
			}

			return pNode;
		};

		private _parentTest(iLevel:  number , iParentIndex:  number , iChildIndex:  number ): bool{
			var iDepth:  number  = this._iDepth;

			var iTmp:  number  = (1 << iDepth)  - (1 << (iDepth - iLevel));
			var iMask:  number  = (iTmp << (2 * iDepth)) + (iTmp << iDepth) + iTmp;

			if((iParentIndex & iMask) == (iChildIndex & iMask)){
				return true;
			}
			return false;
		}

		private _findNodeLevel(iX0:  number , iX1:  number , iY0:  number , iY1:  number , iZ0:  number , iZ1:  number ):  number {
			var iLengthX:  number  = iX1 - iX0;
			var iLengthY:  number  = iY1 - iY0;
			var iLengthZ:  number  = iZ1 - iZ0;

			var iLength:  number  = math.max(iLengthX, math.max(iLengthY, iLengthZ));
//maximum possible level
			var iLevel:  number  = this._iDepth - math.floor(math.log(iLength) / math.LN2);

			while(iLevel > 0){
				var iPitch:  number  = 1 << (this._iDepth - iLevel);
				var iTest1:  number , iTest2:  number ;

//first test for x then for y and z

				var i;
				for(i=0; i<3; i++){
					iTest1 = math.floor(arguments[2*i] / iPitch);
					iTest2 = math.floor(arguments[2*i + 1] / iPitch);

					if(iTest1 != iTest2){
						if((iTest1 + 1) == iTest2){
							if((arguments[2*i+1]%iPitch) != 0){
								break;
							}
						}
						else{
							break;
						}
					}
				}
				if(i!=3){
					iLevel--;
				}
				else{
					break;
				}
			}
			return iLevel;
		};

/**
		 * Get free node. 
		 * Get it from _pFreeNodePull or create new OcTreeNode if it`s empty and set his data.
		 */

		getAndSetFreeNode(iLevel:  number , iComposedIndex:  number , pParentNode: IOcTreeNode): IOcTreeNode {
			var pNode: IOcTreeNode = this._pFreeNodePool.pop();
			if (!isDefAndNotNull(pNode)) {
		        pNode = new OcTreeNode(this);
		    }

			var iDepth:  number  = this._iDepth;
			var iMask:  number  = (1<<this._iDepth) - 1;
			var iIndexX:  number  = (iComposedIndex >> (2*iDepth)) & iMask;
			var iIndexY:  number  = (iComposedIndex >> (iDepth)) & iMask;
			var iIndexZ:  number  = iComposedIndex & iMask;
			var iSize:  number  = 1 << (this._iDepth - iLevel);

		    pNode.level = iLevel;
// pNode.x = iX;
// pNode.y = iY;
// pNode.z = iZ;
		    pNode.index = iComposedIndex;
		    pNode.rearNodeLink = pParentNode;
		    pNode.worldBounds.set(iIndexX, iIndexX + iSize, iIndexY, iIndexY + iSize, iIndexZ, iIndexZ + iSize);
		    pNode.worldBounds.divSelf(this._v3fWorldScale);
		    pNode.worldBounds.subSelf(this._v3fWorldOffset)

		    return pNode;
		};

/**
		 * Delete node from tree
		 */

		deleteNodeFromTree(pNode: IOcTreeNode): void {
			var pParentNode: IOcTreeNode = pNode.rearNodeLink;

			{ logger.setSourceLocation( "OcTree.ts" , 390 ); logger.assert(pNode.membersList.length == 0,"list members of node don't empty"); } ;

			var iDepth:  number  = this._iDepth;
			var iParentLevel:  number  = pParentNode.level;
			var iIndex:  number  = pNode.index;
			var iShift:  number  = iDepth - iParentLevel - 1;

			var iX:  number  = (iIndex >> (2*iDepth + iShift))&1;
			var iY:  number  = (iIndex >> (iDepth + iShift))&1;
			var iZ:  number  = (iIndex >> iShift)&1;

			var iWay:  number  = 4*iX + 2*iY + iZ;

			var pParentBranch: IObjectList = pParentNode.childrenList[iWay];

//console.log('iWay ------------>', iWay);

			var iNode:  number  = pParentBranch.indexOf(pNode);

			{ logger.setSourceLocation( "OcTree.ts" , 409 ); logger.assert(iNode != -1, "can't remove node from parent, node not found"); } ;

//deleting node from parent list
			pParentBranch.takeAt(iNode);

			for(var i:  number  = 0; i < 8; i++){
				var pChildrens: IObjectList = pNode.childrenList[i];
				while(pChildrens.length > 0){
					var pChildNode: IOcTreeNode = pChildrens.pop();
					pChildNode.rearNodeLink = pParentNode;
					pParentBranch.push(pChildNode);
				}
			}

			pNode.level = 0;
			pNode.rearNodeLink = null;
			pNode.worldBounds.clear();

		    this._pFreeNodePool.push(pNode);
		};

		_findObjects(pCamera: ICamera,
				pResultArray?: IObjectArray = new util.ObjectArray(),
				bFastSearch: bool = false): IObjectArray{

//while we ignore second parametr
//don't have normal implementation

			pResultArray.clear();

			if(!isDef(pCamera.frustum)){
				this._buildSearchResultsByRect(pCamera.searchRect, this._pHead, pResultArray);
			}
			else{
				this._buildSearchResultsByRectAndFrustum(pCamera.searchRect,
									pCamera.frustum, this._pHead, pResultArray);
			}

			return pResultArray;
		};

		protected _buildSearchResultsByRect(pSearchRect: IRect3d, pNode: IOcTreeNode, pResultList: IObjectArray){
			var pNodeRect: IRect3d = pNode.worldBounds;

			var kResult: EVolumeClassifications = geometry.classifyRect3d(pSearchRect, pNodeRect);

			if(kResult == EVolumeClassifications.B_CONTAINS_A
				|| kResult == EVolumeClassifications.INTERSECTING){

//надо проводить дополнительные тесты

				var pMemberList: IObjectList = pNode.membersList;
				var pObject: ISceneObject = pMemberList.first;
				while(isDefAndNotNull(pObject)){
					if(geometry.intersectRect3dRect3d(pSearchRect, pObject.worldBounds)){
						pResultList.push(pObject);
					}
					pObject = pMemberList.next();
				}

				for(var i: number  = 0; i < 8; i++){
					var pChildrenList: IObjectList = pNode.childrenList[i];
					var pChildNode: IOcTreeNode = pChildrenList.first;

					while(isDefAndNotNull(pChildNode)){
						this._buildSearchResultsByRect(pSearchRect, pChildNode, pResultList);
						pChildNode = pChildrenList.next();
					}
				}
			}
			else if(kResult != EVolumeClassifications.NO_RELATION){
//объект полностью попал
				this._includeAllTreeSubbranch(pNode, pResultList);
			}
		};

		protected _buildSearchResultsByRectAndFrustum(pSearchRect: IRect3d, pFrustum: IFrustum,
			pNode: IOcTreeNode, pResultList: IObjectArray){

			var pNodeRect: IRect3d = pNode.worldBounds;
//var pChildRect: IRect3d;

			if(geometry.intersectRect3dRect3d(pSearchRect, pNodeRect)){
				var kTestResult:  number  = geometry.classifyFrustumRect3d(pFrustum, pNodeRect);
				if(kTestResult == EVolumeClassifications.A_CONTAINS_B){
//объект полностью попал	
					this._includeAllTreeSubbranch(pNode, pResultList);
				}
				else if(kTestResult == EVolumeClassifications.INTERSECTING){
//объект попал частично
					var pMemberList: IObjectList = pNode.membersList;
					var pObject: ISceneObject = pMemberList.first;
					while(isDefAndNotNull(pObject)){
						if(pFrustum.testRect(pObject.worldBounds)){
							pResultList.push(pObject);
						}
						pObject = pMemberList.next();
					}

					for(var i: number  = 0; i < 8; i++){
//TODO: test by child rect
						var pChildrenList: IObjectList = pNode.childrenList[i];
						var pChildNode: IOcTreeNode = pChildrenList.first;
						while(isDefAndNotNull(pChildNode)){
							this._buildSearchResultsByRectAndFrustum(pSearchRect, pFrustum, pChildNode, pResultList);
							pChildNode = pChildrenList.next();
						}
					}
				}
			}
		};

		protected _includeAllTreeSubbranch(pNode: IOcTreeNode, pResultList: IObjectArray){
//console.warn("----------------> including all subbranch <------------------");
			var pMemberList: IObjectList = pNode.membersList;
			var pObject: ISceneObject = pMemberList.first;
			while(isDefAndNotNull(pObject)){
				pResultList.push(pObject);
				pObject = pMemberList.next();
			}

			for(var i: number  = 0; i < 8; i++){
				var pChildrenList: IObjectList = pNode.childrenList[i];
				var pChildNode: IOcTreeNode = pChildrenList.first;

				while(isDefAndNotNull(pChildNode)){
					this._includeAllTreeSubbranch(pChildNode, pResultList);
					pChildNode = pChildrenList.next();
				}
			}
		};

		protected attachObject(pNode: ISceneNode): void {
			if(isSceneObject(pNode)){
				var pOcTreeNode: IOcTreeNode = this.findTreeNode(<ISceneObject>pNode);
				pOcTreeNode.addMember(<ISceneObject>pNode);
			}
		};

		protected detachObject(pNode: ISceneNode): void {
			if(isSceneObject(pNode)){
				var pOcTreeNode: IOcTreeNode = this.findTreeNode(<ISceneObject>pNode);
				pOcTreeNode.removeMember(<ISceneObject>pNode);
			}
		};

		_toSimpleObject(pNode?: IOcTreeNode = this._pHead): any{

			var pResult: any = {};
			pResult.members = [];
			pResult.childrens = new Array(8);
			for(var i: number  = 0; i < 8; i++){
				pResult.childrens[i] = [];
			}
			pResult.level = pNode.level;
			pResult.index = pNode.index;
			pResult.worldBounds = pNode.worldBounds.toString();


			var pMemberList: IObjectList = pNode.membersList;
			var pObject: ISceneObject = pMemberList.first;
			while(isDefAndNotNull(pObject)){
				pResult.members.push(pObject.worldBounds.toString());
				pObject = pMemberList.next();
			}

			for(var i: number  = 0; i < 8; i++){
				var pList: IObjectList = pNode.childrenList[i];
				var pChildNode: IOcTreeNode = pList.first;

				while(isDefAndNotNull(pChildNode)){
					pResult.childrens[i].push(this._toSimpleObject(pChildNode));
					pChildNode = pList.next();
				}
			}

			return pResult;
		};
	}
}










module akra{

	;
	;
	;

	export interface ILightGraph extends IDisplayList{
	};
};
















module akra.scene.light {

	export class LightPoint extends SceneNode implements ILightPoint {
		protected _isShadowCaster: bool = false;
		protected _isEnabled: bool = true;
		protected _iMaxShadowResolution:  number  = 256;
// protected _pLightParameters: ILightParameters = new LightParameters;
		protected _eLightType: ELightTypes;

//optimized camera frustum for better shadow casting
		protected _pOptimizedCameraFrustum: IFrustum = new geometry.Frustum();

		/**@inline*/  get lightType(): ELightTypes {
			return this._eLightType;
		}

		constructor(pScene: IScene3d, eType: ELightTypes = ELightTypes.UNKNOWN){
			super(pScene, EEntityTypes.LIGHT);

			this._eLightType = eType;
		}

		/**@inline*/  get enabled(): bool{
			return this._isEnabled;
		};

		/**@inline*/  set enabled(bValue: bool){
			this._isEnabled = bValue;
		};

		/**@inline*/  get params(): ILightParameters {
// return this._pLightParameters;
			return null;
		};

		/**@inline*/  get isShadowCaster(): bool {
			return this._isShadowCaster;
		};

		/**@inline*/  set isShadowCaster(bValue: bool) {
			this._isShadowCaster = bValue;
		};

		/**@inline*/  get lightingDistance():  number {
			return -1.;
		};

		/**@inline*/  set lightingDistance(fDistance:  number ){
		};

		/**@inline*/  get optimizedCameraFrustum(): IFrustum{
			return this._pOptimizedCameraFrustum;
		};

		create(isShadowCaster: bool = true, iMaxShadowResolution:  number  = 256): bool {
			var isOk: bool = super.create();

//есть тени от источника или нет
			this._isShadowCaster = isShadowCaster;
//мкасимальный размер shadow текстуры
			this._iMaxShadowResolution = iMaxShadowResolution;

			return isOk;
		};

		_prepareForLighting(pCamera: ICamera): bool{
			{ logger.setSourceLocation( "light/LightPoint.ts" , 74 ); logger.warning("pure virtual method"); } ;
			return false;
		};

		_calculateShadows(): void {
			{ logger.setSourceLocation( "light/LightPoint.ts" , 79 ); logger.log(("\n" + (<any>new Error).stack.split("\n").slice(1).join("\n")) ); } ;
			{ logger.setSourceLocation( "light/LightPoint.ts" , 80 ); logger.criticalError("NOT IMPLEMENTED!"); } ;
		};
	}
	export function isLightPoint(pNode: IEntity){
		return pNode.type === EEntityTypes.LIGHT;
	}
}








module akra.scene {
	export class LightGraph extends DisplayList implements ILightGraph{

		protected _pLightPoints: IObjectList = new util.ObjectList();

		constructor () {
			super();
			this.name = "LightGraph";
		};

		_findObjects(pCamera: ICamera,
				pResultArray?: IObjectArray = new util.ObjectArray(),
				bFastSearch: bool = false): IObjectArray{
//while we ignore second parametr
//don't have normal implementation

			pResultArray.clear();

			var pList: IObjectList = this._pLightPoints;

			var pLightPoint: ILightPoint = pList.first;

			while (isDefAndNotNull(pLightPoint)) {

				if(pLightPoint._prepareForLighting(pCamera)){
// LOG("light point added");
					pResultArray.push(pLightPoint);
				}

				pLightPoint = pList.next();
			}

			return pResultArray;
		};

		protected attachObject(pNode: ISceneNode): void {
			if(light.isLightPoint(pNode)){
				this._pLightPoints.push(pNode);
			}
		};

		protected detachObject(pNode: ISceneNode): void {
			if(light.isLightPoint(pNode)){
				var iPosition:  number  = this._pLightPoints.indexOf(pNode);
				if(iPosition != -1 ){
					this._pLightPoints.takeAt(iPosition);
				}
				else{
					{ logger.setSourceLocation( "LightGraph.ts" , 58 ); logger.assert(false, "cannot find light point"); } ;
				}
			}
		};
	}
}














module akra {
	;

	export interface ISprite extends ISceneObject {
		setTexture(pTex: ITexture): void;
	}
}







module akra.scene {
	export class SpriteManager implements ISpriteManager {


		private _pEngine: IEngine;
		private _pSprites: ISprite[] = [];
		private _pDataFactory: IRenderDataCollection;

		constructor (pEngine: IEngine) {
			this._pDataFactory = pEngine.createRenderDataCollection(EHardwareBufferFlags.READABLE);
		}

		_allocateSprite(pSprite: ISprite): IRenderData {
			var pDataSubset: IRenderData =
				this._pDataFactory.getEmptyRenderData(EPrimitiveTypes.TRIANGLESTRIP, 0);

			this._pSprites.push(pSprite);

			return pDataSubset;
		}
	}

	export class Sprite extends SceneObject implements ISprite {

		protected _pManager: ISpriteManager;
		protected _pRenderable: IRenderableObject;

		/**@inline*/  get totalRenderable():  number  { return 1; }
		/**@inline*/  get manager(): ISpriteManager { return this._pManager; }

		constructor(pScene: IScene3d) {
			super(pScene, EEntityTypes.SPRITE);

			var pEngine: IEngine = pScene.getManager().getEngine();
			var pRsmgr: IResourcePoolManager = pEngine.getResourceManager();
			var pManager: ISpriteManager = pEngine.getSpriteManager();
			var pRenderer: IRenderer = pEngine.getRenderer();
			var pRenderable: IRenderableObject = new render.RenderableObject(ERenderDataTypes.SPRITE);

			pRenderable._setup(pRenderer);

			var iGuid:  number  = this.getGuid();
			var pRenderMethod: IRenderMethod = pRenderable.renderMethod;
			var pEffect: IEffect = pRenderMethod.effect;

			pEffect.addComponent("akra.system.mesh_texture");

			pRenderable.getTechnique().setMethod(pRenderMethod);

			this._pManager = pManager;
			this._pRenderable = pRenderable;

			this.create(2, 2);
		}

		create(fSizeX:  number  = 2, fSizeY:  number  = 2): bool {
			super.create();
//4 vertex * (4 coords + 3 texcoords)
			var pGeometry = new Float32Array(4 * 4);
			var pTexCoords = new Float32Array(4 * 3);
			var pNormals = new Float32Array([0., 0., 1., 0.]);

			for (var i = 0; i < 4; i ++) {
//-1, -1, -1, 1, 1, -1, 1, 1
//0, 0, 0, 1, 1, 0, 1, 1
				var signX:  number  = math.floor(i / 2) * 2 - 1;
				var signY:  number  = (i % 2) * 2 - 1;

				pGeometry[4 * i    ] = signX * fSizeX / 2;
				pGeometry[4 * i + 1] = signY * fSizeY / 2;
				pGeometry[4 * i + 2] = 0;
				pGeometry[4 * i + 3] = 0;

				pTexCoords[3 * i + 0] = (signX + 1) / 2;
				pTexCoords[3 * i + 1] = (signY + 1) / 2;
				pTexCoords[3 * i + 2] = 0;
			}

			var fMaxSize = (fSizeX > fSizeY) ? fSizeX : fSizeY;

			this.accessLocalBounds().set(fMaxSize, fMaxSize, fMaxSize);

			var pData: IRenderData = this.manager._allocateSprite(this);

			pData.allocateData([VE_FLOAT4("POSITION")], pGeometry);
			pData.allocateData([VE_FLOAT3("TEXCOORD0")], pTexCoords);
			pData.allocateData([VE_FLOAT4("NORMAL")], pNormals);
			pData.allocateIndex([VE_FLOAT('INDEX0')], new Float32Array([0,1,2,3]));
			pData.allocateIndex([VE_FLOAT('INDEX1')], new Float32Array([0,1,2,3]));
			pData.allocateIndex([VE_FLOAT('INDEX2')], new Float32Array([0,0,0,0]));
			pData.index('POSITION', 'INDEX0');
			pData.index('TEXCOORD0', 'INDEX1');
			pData.index('NORMAL', 'INDEX2');

			this._pRenderable._setRenderData(pData);

			return true;
		}

		setTexture(pTex: ITexture): void {
			var pSurfaceMaterial: ISurfaceMaterial = this._pRenderable.surfaceMaterial;
			pSurfaceMaterial.setTexture(ESurfaceMaterialTextures.EMISSIVE, pTex, 0);

			(<IColor>pSurfaceMaterial.material.emissive).set(0.);
			(<IColor>pSurfaceMaterial.material.diffuse).set(0.);
			(<IColor>pSurfaceMaterial.material.ambient).set(0.);
			(<IColor>pSurfaceMaterial.material.specular).set(0.);

			this._pRenderable.wireframe(true);
		}

		getRenderable(): IRenderableObject {
			return this._pRenderable;
		}


	}
}













module akra {
	;

	export interface ISceneModel extends ISceneObject {
		visible: bool;
		mesh: IMesh;
		isVisible(): bool;
	}
}






























module akra {

	;
	;
	;
	;

	export interface IMeshSubset extends IEventProvider, IRenderableObject {
		name: string;

		 mesh: IMesh;
		 skin: ISkin;
		 data: IRenderData;
		 boundingBox: IRect3d;
         boundingSphere: ISphere;

		createBoundingBox(): bool;
		deleteBoundingBox(): bool;
		showBoundingBox(): bool;
		hideBoundingBox(): bool;
		isBoundingBoxVisible(): bool;

		createBoundingSphere(): bool;
		deleteBoundingSphere(): bool;
		showBoundingSphere(): bool;
		hideBoundingSphere(): bool;
		isBoundingSphereVisible(): bool;

		computeNormals(): void;
		computeTangents(): void;
		computeBinormals(): void;

		isSkinned(): bool;
		isOptimizedSkinned(): bool;
		getSkin(): ISkin;
		setSkin(pSkin: ISkin): bool;

/** @deprecated */

		applyFlexMaterial(csMaterial: string, pMaterial?: IMaterial): bool;
/** @deprecated */

		getFlexMaterial(iMaterial:  number ): IMaterial;
/** @deprecated */

		getFlexMaterial(csName: string): IMaterial;
/** @deprecated */

		setFlexMaterial(iMaterial:  number ): bool;
/** @deprecated */

		setFlexMaterial(csName: string): bool;

		show(): void;
		hide(): void;
		isRenderable(): bool;

		destroy(): void;

		_calculateSkin(): bool;

		 skinAdded(pSkin: ISkin): void;
	}
}






module akra {
	;
	;
	;
	;
	;
	;
	;

// export interface INodeMap {
// 	[index: string]: INode;
// }

	export interface ISkin {
		 data: IRenderDataCollection;
		 skeleton: ISkeleton;
		 totalBones:  number ;

/**
		 * Set binding matrix. 
		 * @see <bind_shape_matrix> in Collada.
		 */

		setBindMatrix(m4fMatrix: IMat4): void;

/**
		 * @see <bind_shape_matrix> in Collada.
		 */

		getBindMatrix(): IMat4;

/**
		 * Bone offset matrices.
		 * @see Bone offset matrices in Collada.
		 */

		getBoneOffsetMatrices(): IMat4[];
		getBoneOffsetMatrix(sBoneName: string): IMat4;
		setBoneOffsetMatrices(pMatrices: IMat4[]): void;

		setSkeleton(pSkeleton: ISkeleton): bool;

/**
		 * Make a skin dependent on scene node whose names match the
		 * names of the bones that affect the skin.
		 */

		attachToScene(pRootNode: ISceneNode): bool;

// /**
//  * Bind skin to skeleton or scene.
//  */
// bind(pSkeleton: ISkeleton): bool;
// bind(pNode: ISceneNode): bool;

/**
		 * Set names of bones, that affect to skin.
		 */

		setBoneNames(pNames: string[]): bool;


/**
		 * Weights.
		 */

		setWeights(pWeights: Float32Array): bool;

/**
		 * разметка влияний на вершины
		 * пары: {число влияний, адресс индексов влияний}
		 */

		getInfluenceMetaData(): IVertexData;
/**
		 * инф. о вляиниях на вершины
		 * пары: {индекс матрицы кости, индекс веса}
		 */

		getInfluences(): IVertexData;
		setInfluences(pInfluencesCount:  number [], pInfluences: Float32Array): bool;

/**
		 * Short way to call setWeights() && setIfluences();
		 */

		setVertexWeights(pInfluencesCount:  number [], pInfluences: Float32Array, pWeights: Float32Array): bool;

/**
		 * Recalculate skin matrices and fill it to video memory.
		 */

		applyBoneMatrices(bForce?: bool): bool;

/**
		 * Is skin ready to use?
		 */

		isReady(): bool;

/**
		 * Data with result matrices.
		 */

		getBoneTransforms(): IVertexData;

/**
		 * Check, is this skin affect to data?
		 */

		isAffect(pData: IVertexData): bool;

/**
		 * Add skin info to data with vertices.
		 */

		attach(pData: IVertexData): void;
	}
}





























module akra.model {

	export class Skin implements ISkin {
		private _pMesh: IMesh;

		private _pSkeleton: ISkeleton = null;

// name of bones/nodes
		private _pNodeNames: string[] = null;

//bind matrix from collada
		private _m4fBindMatrix: IMat4 = new Mat4(1);

//BONE_MATRIX = WORLD_MATRIX x OFFSET_MATRIX
		private _pBoneTransformMatrices: IMat4[]  = null;

/**
		 * Common buffer for all transform matrices.
		 * _pBoneOffsetMatrixBuffer = [_pBoneTransformMatrices[0], ..., _pBoneTransformMatrices[N]]
		 */

		private _pBoneOffsetMatrixBuffer: Float32Array = null;

// bone offset matrices from collada
		private _pBoneOffsetMatrices: IMat4[] = null;

/**
		 * Pointers to nodes, that affect to this skin.
		 */

		private _pAffectingNodes: ISceneNode[] = null;

/**
		 * Format:
		 * BONE_INF_COUNT - number of bones, that influence to the vertex.
		 * BONE_INF_LOC - address of influence, pointer to InfData structire list.
		 * ..., [BONE_INF_COUNT: float, BONE_INF_LOC: float], ...
		 * 
		 */

		private _pInfMetaData: IVertexData = null;

/**
		 * Format:
		 * BONE_INF_DATA - bone matrix address, pointer to BONE_MATRIX list
		 * BONE_WEIGHT - bone weight
		 * ..., [BONE_INF_DATA: float, BONE_WEIGHT: float], ...
		 */

		private _pInfData: IVertexData = null;

/**
		 * Format:
		 * ..., [BONE_MATRIX: matrix4], ...
		 */

		private _pBoneTransformMatrixData: IVertexData = null;
		private _pWeights: Float32Array = null;

/**
		 * Links to VertexData, that contain meta from this skin.
		 */

		private _pTiedData: IVertexData[] = [];



		/**@inline*/  get data(): IRenderDataCollection {
			return this._pMesh.data;
		}

		/**@inline*/  get skeleton(): ISkeleton{
			return this._pSkeleton;
		}

		/**@inline*/  set skeleton(pSkeleton: ISkeleton) {
			if (isNull(pSkeleton) || pSkeleton.totalBones < this.totalBones) {
				{ logger.setSourceLocation( "Skin.ts" , 83 ); logger.warning("cannnot set skeletonm because skeleton has to little bones"); } ;
		        return;
		    }

		    for (var i:  number  = 0, nMatrices:  number  = this.totalBones; i < nMatrices; i++) {
		        this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
		        { logger.setSourceLocation( "Skin.ts" , 89 ); logger.assert(isDefAndNotNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists..."); } ;
		    }


		    this._pSkeleton = pSkeleton;
		}

		/**@inline*/  get totalBones():  number  {
			return this._pNodeNames.length;
		}

		constructor(pMesh: IMesh) {
		    { logger.setSourceLocation( "Skin.ts" , 101 ); logger.assert(isDefAndNotNull(pMesh), "you must specify mesh for skin"); } ;

		    this._pMesh = pMesh;
		}

		setBindMatrix(m4fMatrix: IMat4): void {
			this._m4fBindMatrix.set(m4fMatrix);
		}

		getBindMatrix(): IMat4 {
			return this._m4fBindMatrix;
		}

		getBoneOffsetMatrices(): IMat4[] {
			return this._pBoneOffsetMatrices;
		}

		getBoneOffsetMatrix(sBoneName: string): IMat4 {
			var pBoneNames: string[] = this._pNodeNames;

			for (var i = 0; i < pBoneNames.length; i++) {
			    if (pBoneNames[i] === sBoneName) {
			        return this._pBoneOffsetMatrices[i];
			    }
			};

			return null;
		}

		setSkeleton(pSkeleton: ISkeleton): bool {
			if (!pSkeleton || pSkeleton.totalBones < this.totalBones) {
				{ logger.setSourceLocation( "Skin.ts" , 133 ); logger.warning("number of bones in skeleton (" + pSkeleton.totalBones + ") less then number of bones in skin (" + this.totalBones + ")."); }
                                                                      ;
			    return false;
			}

			for (var i:  number  = 0, nMatrices = this.totalBones; i < nMatrices; i++) {
			    this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
			    { logger.setSourceLocation( "Skin.ts" , 139 ); logger.assert(!isNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists..."); } ;
			}

			this._pSkeleton = pSkeleton;

			return true;
		}

		attachToScene(pRootNode: ISceneNode): bool {
			for (var i:  number  = 0, nMatrices:  number  = this.totalBones; i < nMatrices; i++) {
			    this._pAffectingNodes[i] = <ISceneNode>pRootNode.findEntity(this._pNodeNames[i]);
			    { logger.setSourceLocation( "Skin.ts" , 150 ); logger.assert(isDefAndNotNull(this._pAffectingNodes[i]), "node<" + this._pNodeNames[i] + "> must exists..."); } ;
			}

			return true;
		}

		setBoneNames(pNames: string[]): bool {
			if (isNull(pNames)) {
				return false;
			}

			this._pNodeNames = pNames;
			this._pAffectingNodes = new Array(pNames.length);

			return true;
		}

		setBoneOffsetMatrices(pMatrices: IMat4[]): void {
			var pMatrixNames: string[] = this._pNodeNames;

			{ logger.setSourceLocation( "Skin.ts" , 173 ); logger.assert(isDefAndNotNull(pMatrices) && isDefAndNotNull(pMatrixNames) && pMatrixNames.length === pMatrices.length, "number of matrix names must equal matrices data length:\n" + pMatrixNames.length + " / " + pMatrices.length); }
                                ;

			var nMatrices:  number  = pMatrixNames.length;
			var pData: IRenderDataCollection = this.data;
			var pMatrixData: Float32Array = new Float32Array(nMatrices * 16);

//FIXME: правильно положить матрицы...
			this._pBoneOffsetMatrices = pMatrices;
			this._pBoneTransformMatrixData = pData._allocateData([VE_MAT4("BONE_MATRIX")], pMatrixData);
			this._pBoneTransformMatrices = new Array(nMatrices);

			for (var i:  number  = 0; i < nMatrices; i++) {
			    this._pBoneTransformMatrices[i] = new Mat4(pMatrixData.subarray(i * 16, (i + 1) * 16), true);
			}


			this._pBoneOffsetMatrixBuffer = pMatrixData;
		}

		setWeights(pWeights: Float32Array): bool {
			this._pWeights = pWeights;
			return true;
		}

		getInfluenceMetaData(): IVertexData {
			return this._pInfMetaData;
		}

		getInfluences(): IVertexData {
			return this._pInfData;
		}

		setInfluences(pInfluencesCount:  number [], pInfluences: Float32Array): bool {
			{ logger.setSourceLocation( "Skin.ts" , 206 ); logger.assert(this._pInfMetaData == null && this._pInfData == null, "vertex weights already setuped."); } ;
			{ logger.setSourceLocation( "Skin.ts" , 207 ); logger.assert(!isNull(this._pWeights), "you must set weight data before setup influences"); } ;

			var pData: IRenderDataCollection = this.data;
			var pInfluencesMeta: Float32Array = new Float32Array(pInfluencesCount.length * 2);
			var pWeights: Float32Array = this._pWeights;

			var iInfLoc:  number  = 0;
			var iTransformLoc:  number  = 0;

//получаем копию массива влияний
			pInfluences = new Float32Array(pInfluences);

//вычисляем адресса матриц транфсормации и весов
			iTransformLoc = this._pBoneTransformMatrixData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;


			for (var i:  number  = 0, n:  number  = pInfluences.length; i < n; i += 2) {
			    pInfluences[i] = pInfluences[i] * 16 + iTransformLoc;
			    pInfluences[i + 1] = pWeights[pInfluences[i + 1]];
			}

//запоминаем модифицированную информацию о влияниях
			this._pInfData = pData._allocateData([
/*адрес матрицы кости*/
			                                         VE_FLOAT('BONE_INF_DATA'),
/*весовой коэффициент*/
			                                         VE_FLOAT('BONE_WEIGHT')
			                                     ],
			                                     pInfluences);

			iInfLoc = this._pInfData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;

//подсчет мета данных, которые укажут, где взять влияния на кость..
			for (var i:  number  = 0, j:  number  = 0, n:  number  = iInfLoc; i < pInfluencesMeta.length; i += 2) {
			    var iCount:  number  = pInfluencesCount[j++];
/*число влияний на вершину*/
			    pInfluencesMeta[i] = iCount;
/*адрес начала информации о влияниях */
			    pInfluencesMeta[i + 1] = n;
//(пары индекс коэф. веса и индекс матрицы)
			    n += 2 * iCount;
			}

//influences meta: разметка влияний
			this._pInfMetaData = pData._allocateData([
/*число костей и весов, влияющих на вершину*/
			                                             VE_FLOAT('BONE_INF_COUNT'),
/*адресс начала влияний на вершину*/
			                                             VE_FLOAT('BONE_INF_LOC'),
			                                         ], pInfluencesMeta);

			return this._pInfMetaData !== null &&
			       this._pInfData !== null;
		}

		setVertexWeights(pInfluencesCount:  number [], pInfluences: Float32Array, pWeights: Float32Array): bool {
			{ logger.setSourceLocation( "Skin.ts" , 257 ); logger.assert(arguments.length > 1, 'you must specify all parameters'); } ;

//загружаем веса 
			if (pWeights) {
			    this.setWeights(pWeights);
			}

			return this.setInfluences(pInfluencesCount, pInfluences);
		}

		applyBoneMatrices(bForce: bool = false): bool {
			var pData: Float32Array;
			var bResult: bool;
			var pNode: ISceneNode;
			var isUpdated: bool = false;

			for (var i:  number  = 0, nMatrices = this.totalBones; i < nMatrices; ++i) {
			    pNode = this._pAffectingNodes[i];

			    if (pNode.isWorldMatrixNew() || bForce) {
			        pNode.worldMatrix.multiply(this._pBoneOffsetMatrices[i], this._pBoneTransformMatrices[i]);
			        isUpdated = true;
			    }
			}

			if (isUpdated) {
			    pData = this._pBoneOffsetMatrixBuffer;
			    return this._pBoneTransformMatrixData.setData(pData, 0, pData.byteLength);
			}

			return false;
		}

		isReady(): bool {
			return !(isNull(this._pInfMetaData) || isNull(this._pInfData) || isNull(this._pWeights) ||
			         isNull(this._pBoneOffsetMatrixBuffer) || isNull(this._pBoneOffsetMatrices) ||
			         isNull(this._pNodeNames) ||
			         isNull(this._m4fBindMatrix));
		}

		getBoneTransforms(): IVertexData {
			return this._pBoneTransformMatrixData;
		}

		isAffect(pData: IVertexData): bool {
			if (isDefAndNotNull(pData)) {
			    for (var i:  number  = 0; i < this._pTiedData.length; i++) {
			        if (this._pTiedData[i] === pData) {
			            return true;
			        }
			    }
			}

			return false;
		}

		attach(pData: IVertexData): void {
			{ logger.setSourceLocation( "Skin.ts" , 315 ); logger.assert(pData.stride === 16, "you cannot add skin to mesh with POSITION: {x, y, z}" + "\nyou need POSITION: {x, y, z, w}"); }
                                                                         ;

			pData.getVertexDeclaration().append(VE_FLOAT(DeclUsages.BLENDMETA, 12));

			this._pTiedData.push(pData);
		}
	}



	export function createSkin(pMesh: IMesh): ISkin {
		return new Skin(pMesh);
	}
}









































module akra {

	;

	export interface ISegment2d{
		ray: IRay2d;
		distance:  number ;

		point: IVec2;
		normal: IVec2;
	};
}



module akra.geometry{
	export class Segment2d implements ISegment2d{
		ray: IRay2d;
		distance:  number ;

		constructor(){
			this.ray = new Ray2d();
			this.distance = 0.;
		};

		get point(): IVec2{
			return this.ray.point;
		};
		set point(v2fPoint: IVec2){
			this.ray.point.set(v2fPoint);
		};

		get normal(): IVec2{
			return this.ray.normal;
		};
		set normal(v2fNormal: IVec2){
			this.ray.normal.set(v2fNormal);
		};
	};
}












module akra {

	;

	export interface ISegment3d{
		ray: IRay3d;
		distance:  number ;

		point: IVec3;
		normal: IVec3;
	};
}



module akra.geometry{
	export class Segment3d implements ISegment3d{
		ray: IRay3d;
		distance:  number ;

		constructor(){
			this.ray = new Ray3d();
			this.distance = 0.;
		};

		get point(): IVec3{
			return this.ray.point;
		};
		set point(v3fPoint: IVec3){
			this.ray.point.set(v3fPoint);
		};

		get normal(): IVec3{
			return this.ray.normal;
		};
		set normal(v3fNormal: IVec3){
			this.ray.normal.set(v3fNormal);
		};
	};
}


































module akra.geometry {
	export function computeBoundingBox(pVertexData: IVertexData, pBoundingBox: IRect3d): bool;
	export function computeDataForCascadeBoundingBox(pBoundingBox: IRect3d, ppVertexes:  number [], ppIndexes:  number [], fMinSize?:  number ): bool;
	export function computeBoundingSphere(pVertexData: IVertexData, pSphere: ISphere, bFastMethod?: bool, pBoundingBox?: IRect3d): bool;
	export function computeBoundingSphereFast(pVertexData: IVertexData, pSphere: ISphere, pBoundingBox: IRect3d = null): bool;
	export function computeBoundingSphereMinimal(pVertexData: IVertexData, pSphere: ISphere): bool;
	export function computeGeneralizingSphere(pSphereA: ISphere, pSphereB: ISphere, pSphereDest?: ISphere): bool;
	export function computeDataForCascadeBoundingSphere(pBoundingSphere: ISphere, ppVertexes:  number [], ppIndexes:  number [], fMinSize?:  number ): bool;

/**
	 * Computes a coordinate-axis oriented bounding box.
	 */

	export function computeBoundingBox (pVertexData, pBoundingBox): bool {
		var fX0:  number  = 0, fY0:  number  = 0, fZ0:  number  = 0,
			fX1:  number  = 0, fY1:  number  = 0, fZ1:  number  = 0;
		var fTemp:  number , pTempData: Float32Array;
		var i:  number  = 0;
		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement, pData: ArrayBuffer;
		var nStride:  number , nCount:  number ;


		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if(isNull(pVertexDeclaration))
			return false;

		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION, 3);

		if(isNull(pVertexElement))
			return false;

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (isNull(pData))
			return false;

		pTempData = new Float32Array(pData, 0, 3);
		fX0 = fX1 = pTempData[0];
		fY0 = fY1 = pTempData[1];
		fZ0 = fZ1 = pTempData[2];

		for (i = nStride; i < nStride * nCount; i += nStride) {

			pTempData = new Float32Array(pData, i, 3);
			fTemp = pTempData[0];
/*Min*/
			fX0 = fX0 > fTemp ? fTemp : fX0;
/*Max*/
			fX1 = fX1 > fTemp ? fX1 : fTemp;

			fTemp = pTempData[1];
/*Min*/
			fY0 = fY0 > fTemp ? fTemp : fY0;
/*Max*/
			fY1 = fY1 > fTemp ? fY1 : fTemp;

			fTemp = pTempData[2];
/*Min*/
			fZ0 = fZ0 > fTemp ? fTemp : fZ0;
/*Max*/
			fZ1 = fZ1 > fTemp ? fZ1 : fTemp;
		}

		pBoundingBox.set(fX0,fX1,fY0,fY1,fZ0,fZ1);

	    return true;
	};

/** расчет данных для отрисовки бокса */

	export function computeDataForCascadeBoundingBox(pBoundingBox: IRect3d, ppVertexes:  number [], ppIndexes:  number [], fMinSize:  number  = .25): bool {

		var pInd:  number [];
		var pPoints: IVec3[][];
		var i:  number , j:  number , k:  number ;

		pPoints = new Array(8);

		for(i = 0; i < 8; i ++) {
			pPoints[i] = new Array(4);
			for(j = 0; j < 4; j++)
				pPoints[i][j] = new Vec3(0);
		}

//Выставление точек Rect3d
		pPoints[0][0].set([pBoundingBox.x0,pBoundingBox.y0,pBoundingBox.z0]);
		pPoints[1][0].set([pBoundingBox.x0,pBoundingBox.y1,pBoundingBox.z0]);
		pPoints[2][0].set([pBoundingBox.x0,pBoundingBox.y0,pBoundingBox.z1]);
		pPoints[3][0].set([pBoundingBox.x0,pBoundingBox.y1,pBoundingBox.z1]);
		pPoints[4][0].set([pBoundingBox.x1,pBoundingBox.y0,pBoundingBox.z0]);
		pPoints[5][0].set([pBoundingBox.x1,pBoundingBox.y1,pBoundingBox.z0]);
		pPoints[6][0].set([pBoundingBox.x1,pBoundingBox.y0,pBoundingBox.z1]);
		pPoints[7][0].set([pBoundingBox.x1,pBoundingBox.y1,pBoundingBox.z1]);

		var fTempFunc = function(pPoints: IVec3[][], iPoint:  number , iToPoint1:  number , iToPoint2:  number , iToPoint3:  number ): void {
			for(var i = 0;i < 3; i ++) {
				pPoints[arguments[i + 2]][0].subtract(pPoints[iPoint][0], pPoints[iPoint][i+1]);

				if(pPoints[iPoint][i + 1].length() > fMinSize) {
					pPoints[iPoint][i + 1].scale(0.1);
				}

				pPoints[iPoint][i + 1].add(pPoints[iPoint][0]);
			}
		}

		fTempFunc(pPoints,0,1,2,4);
		fTempFunc(pPoints,1,0,3,5);
		fTempFunc(pPoints,2,0,3,6);
		fTempFunc(pPoints,3,1,2,7);
		fTempFunc(pPoints,4,0,5,6);
		fTempFunc(pPoints,5,1,4,7);
		fTempFunc(pPoints,6,2,4,7);
		fTempFunc(pPoints,7,3,5,6);

		for(i = 0; i < 8; i++) {
			for(j = 0; j < 4; j++) {
				ppVertexes[i * 12 + j * 3 + 0] = pPoints[i][j].x;
				ppVertexes[i * 12 + j * 3 + 1] = pPoints[i][j].y;
				ppVertexes[i * 12 + j * 3 + 2] = pPoints[i][j].z;
			}
		}

		pInd = [
			0, 1, 0, 2, 0, 3,
			4, 5, 4, 6, 4, 7,
			8, 9, 8,10, 8,11,
			12,13,12,14,12,15,
			16,17,16,18,16,19,
			20,21,20,22,20,23,
			24,25,24,26,24,27,
			28,29,28,30,28,31
		];

		for(var i:  number  = 0; i < pInd.length; ++ i) {
			ppIndexes[i] = pInd[i];
		}

		return true;
	}


/** подсчет обобщающей сферы над двумя сферами */

	export function computeGeneralizingSphere (pSphereA: ISphere, pSphereB: ISphere, pSphereDest?: ISphere): bool {
	    if (!isDef(pSphereDest)) {
	        pSphereDest = pSphereA;
	    }

	    var fR1:  number  = pSphereA.radius;
	    var fR2:  number  = pSphereB.radius;
	    var v3fC1: IVec3 = pSphereA.center;
	    var v3fC2: IVec3 = pSphereB.center;

	    var v3fD: IVec3 = new Vec3;

	    v3fC1.subtract(v3fC2, v3fD);

	    var fD:  number  = v3fD.length();

	    if (fD < fR1 && fR1 > fR2) {
	        pSphereDest.set(pSphereA);
	        return false;
	    }

	    if (fD < fR2) {
	        pSphereDest.set(pSphereB);
	        return false;
	    }

	    var v3fN: IVec3 = new Vec3;
	    v3fD.normalize(v3fN);

	    pSphereDest.radius = v3fD.add(v3fN.scale(fR1 + fR2)).length() / 2.0;

	    var v3fTemp: IVec3 = v3fD;
	    pSphereDest.center = v3fC1.add(v3fC2, v3fTemp).add(v3fN.scale((fR1 - fR2) / (fR1 + fR2))).scale(.5);

	    return true;
	}

/** расчет данных для отрисовки сферы */

	export function computeDataForCascadeBoundingSphere(
		pBoundingSphere: ISphere,
		ppVertexes:  number [],
		ppIndexes:  number [],
		fMinSize:  number  = 0.25): bool {

		var fTheta:  number , fDelta:  number , fAlpha:  number ;
		var nCount:  number  = 10;
		var i:  number , j:  number , k:  number ;

		fDelta = math.TWO_PI / nCount;

		for(i = 0; i <= nCount / 2; i ++) {
			fTheta =- math.PI + (i * fDelta);

			for (j = 0; j <= nCount; j++) {
				fAlpha = j * fDelta;
				ppVertexes[(i*(nCount+1)+j)*3+0] = pBoundingSphere.center.x + pBoundingSphere.radius * math.sin(fTheta) * math.cos(fAlpha);
				ppVertexes[(i*(nCount+1)+j)*3+1] = pBoundingSphere.center.y + pBoundingSphere.radius * math.sin(fTheta) * math.sin(fAlpha);
				ppVertexes[(i*(nCount+1)+j)*3+2] = pBoundingSphere.center.z + pBoundingSphere.radius * math.cos(fTheta);
			}
		}

		for(i = 0; i < nCount / 2; i++) {
			for(j = 0; j < nCount; j++) {
				ppIndexes[(i * (nCount) + j) * 12 + 0] = i * (nCount + 1) + j;
				ppIndexes[(i * (nCount) + j) * 12 + 1] = i * (nCount + 1) + j + 1;

				ppIndexes[(i * (nCount) + j) * 12 + 2] = i * (nCount + 1) + j + 2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 3] = i * (nCount + 1) + j;

				ppIndexes[(i * (nCount) + j) * 12 + 4] = i * (nCount + 1) + j + 1;
				ppIndexes[(i * (nCount) + j) * 12 + 5] = i * (nCount + 1) + j + 2 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 6] = i * (nCount + 1) + j;
				ppIndexes[(i * (nCount) + j) * 12 + 7] = i * (nCount + 1) + j + 1 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 8] = i * (nCount + 1) + j +2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 9] = i * (nCount + 1) + j +1 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 10 ] = i *(nCount + 1) + j +2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 11 ] = i *(nCount + 1) + j;
			}
		}

		return true;
	}

/** 
	 * Computes a bounding sphere.
	 * При использование быстрого вычисления, опционально можно получить баундинг бокс. 
	 */

	export function computeBoundingSphere(pVertexData: IVertexData, pSphere: ISphere, bFastMethod: bool = true, pBoundingBox: IRect3d = null) {
		if(bFastMethod) {
			return computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox);
		}
		else {
			return computeBoundingSphereMinimal(pVertexData, pSphere);
		}

	}

/**
	 * Computes a bounding sphere - not minimal. Also if it need compute dounding box
	 */

	export function computeBoundingSphereFast(pVertexData: IVertexData, pSphere: ISphere, pBoundingBox: IRect3d = null): bool {
	    var i:  number ;
		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement;
		var nCount:  number , nStride:  number ;
		var pData: ArrayBuffer, pTempData: Float32Array;

		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if(isNull(pVertexDeclaration)) {
			return false;
		}


		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION, 3);

		if(isNull(pVertexElement)) {
			return false;
		}

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (isNull(pData)) {
			return false;
		}

		if (isNull(pBoundingBox)) {
			pBoundingBox =  Rect3d.stackCeil.set() ;
		}

		if (pBoundingBox.isClear()) {
			if(!computeBoundingBox(pVertexData, pBoundingBox)) {
				return false;
			}
	    }

	    var fCenterX:  number  = (pBoundingBox.x0 + pBoundingBox.x1) / 2;
	    var fCenterY:  number  = (pBoundingBox.y0 + pBoundingBox.y1) / 2;
	    var fCenterZ:  number  = (pBoundingBox.z0 + pBoundingBox.z1) / 2;
	    var fRadius:  number  = 0;
	    var fDistance:  number  = 0;

	    for (i = 0; i < nStride * nCount; i += nStride) {
			pTempData = new Float32Array(pData, i, 3);
	        fDistance = (pTempData[0] - fCenterX) * (pTempData[0] - fCenterX) +
	            (pTempData[1] - fCenterY) * (pTempData[1] - fCenterY) +
	            (pTempData[2] - fCenterZ) * (pTempData[2] - fCenterZ);
	        fRadius = fDistance > fRadius ? fDistance : fRadius;
	    }

		pSphere.set(fCenterX, fCenterY, fCenterZ ,math.sqrt(fRadius));

	    return true;
	}



/**
	 * Computes a bounding sphere - minimal.
	 */

	export function computeBoundingSphereMinimal (pVertexData: IVertexData, pSphere: ISphere): bool {
	    var i:  number  = 0, j:  number  = 0, k:  number  = 0;
	    var points:  number [] = [];
	    var length:  number  = 0;
	    var isAdd: bool = false;
	    var isNew: bool = true;
	    var fDiametr:  number  = 0;
	    var fDistance:  number  = 0;

		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement;
		var nCount:  number , nStride:  number ;
		var pData: ArrayBuffer, pTempData1: Float32Array, pTempData2: Float32Array;

		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if (isNull(pVertexData)) {
			return false;
		}

		if(isNull(pVertexDeclaration)) {
			return false;
		}

		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION,3);

		if(isNull(pVertexElement))
			return false;

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (!pData)
			return false;


	    for (i = 0; i < nStride * nCount; i += nStride) {
	        isNew = true;
	        isAdd = false;
	        pTempData1 = new Float32Array(pData, i, 3);

	        for (k = 0; k < points.length; k += 3) {
	            if (points[k] == pTempData1[0] &&
	                points[k + 1] == pTempData1[1] &&
	                points[k + 2] == pTempData1[2]) {
	                isNew = false;
	                break;
	            }
	        }

	        if (isNew) {
	            for (j = i + nStride; j < nStride * nCount; j += nStride) {
	                pTempData2 = new Float32Array(pData, j, 3);
	                fDistance = (pTempData1[0] - pTempData2[0]) * (pTempData1[0] - pTempData2[0]) +
	                    (pTempData1[1] - pTempData2[1]) * (pTempData1[1] - pTempData2[1]) +
	                    (pTempData1[2] - pTempData2[2]) * (pTempData1[2] - pTempData2[2]);
	                if (fDistance > fDiametr) {
	                    fDiametr = fDistance;
	                    isAdd = true;
	                    points[0] = pTempData2[0];
	                    points[1] = pTempData2[1];
	                    points[2] = pTempData2[2];
	                    length = 3;
	                }
	                else if (fDistance.toFixed(7) == fDiametr.toFixed(7)) {
	                    isAdd = true;
	                    for (k = 0; k < points.length; k += 3) {
	                        if (points[k] == pTempData2[0] &&
	                            points[k + 1] == pTempData2[1] &&
	                            points[k + 2] == pTempData2[2]) {
	                            isNew = false;
	                            break;
	                        }
	                    }
	                    if (isNew) {
	                        points[length] = pTempData2[0];
	                        points[length + 1] = pTempData2[1];
	                        points[length + 2] = pTempData2[2];
	                        length += 3;
	                    }
	                }
	            }
	            if (isAdd) {
	                points[length] = pTempData1[0];
	                points[length + 1] = pTempData1[1];
	                points[length + 2] = pTempData1[2];
	                length += 3
	            }
	        }
	    }

	    var fX:  number  = 0, fY:  number  = 0, fZ:  number  = 0;

	    for (i = 0; i < points.length; i += 3) {
	        fX += points[i];
	        fY += points[i + 1];
	        fZ += points[i + 2];
	    }

	    var x:  number  = pSphere.center.x = fX / points.length * 3;
	    var y:  number  = pSphere.center.y = fY / points.length * 3;
	    var z:  number  = pSphere.center.z = fZ / points.length * 3;

	    pSphere.radius = math.sqrt((points[0] - x) * (points[0] - x) +
	                                    (points[1] - y) * (points[1] - y) +
	                                    (points[2] - z) * (points[2] - z));
	    return true;
	}

}















module akra.util{

	export function calculateSkin(pMeshSubset: IMeshSubset): bool{
		var pRenderData: IRenderData = pMeshSubset.data;

		var isOk: bool = pRenderData.selectIndexSet(".update_skinned_position");

		if(!isOk){
			return false;
		}

		var pEngine: IEngine = pRenderData.buffer.getEngine();
		var pResourceManager: IResourcePoolManager = pEngine.getResourceManager();
		var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>pEngine.getRenderer();
		var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		var pWebGLVertexTexture: webgl.WebGLVertexTexture = <webgl.WebGLVertexTexture>pRenderData.buffer.buffer;
		var pWebGLTexture: WebGLTexture = pWebGLVertexTexture.getWebGLTexture();

/*update skinned position program*/


		var pWebGLProgram: webgl.WebGLShaderProgram = <webgl.WebGLShaderProgram><IShaderProgram>pResourceManager.shaderProgramPool.findResource(".WEBGL_skinning_update");
		if (isNull(pWebGLProgram)) {
        	pWebGLProgram = <webgl.WebGLShaderProgram><IShaderProgram>pResourceManager.shaderProgramPool.createResource(".WEBGL_skinning_update");
        	pWebGLProgram.create(

        		"																																\n        		#ifndef A_VB_COMPONENT3																											\n				#define A_VB_COMPONENT4																											\n				#endif																															\n				#ifdef A_VB_COMPONENT4																											\n				#define A_VB_ELEMENT_SIZE 4.																									\n				#endif																															\n				#ifdef A_VB_COMPONENT3																											\n				#define A_VB_ELEMENT_SIZE 3.																									\n				#endif																															\n				#define A_tex2D(S, H, X, Y) texture2D(S, vec2(H.stepX * X , H.stepY * Y))														\n				#define A_tex2Dv(S, H, V) texture2D(S, V)																						\n																																				\n				struct A_TextureHeader { float width; float height; float stepX; float stepY; };												\n																																				\n				void A_extractTextureHeader(const sampler2D src, out A_TextureHeader header){													\n					vec4 v = texture2D(src, vec2(0.00001));																						\n					header = A_TextureHeader(v.r, v.g, v.b, v.a);																				\n				}																																\n																																				\n				vec2 A_findPixel(const A_TextureHeader header, const float offset){																\n					float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE);																		\n				return vec2(header.stepX * (mod(pixelNumber, header.width) + .5),																\n					 header.stepY * (floor(pixelNumber / header.width) + .5));																	\n				}																																\n																																				\n				vec2 A_extractVec2(const sampler2D sampler, const A_TextureHeader header, const float offset){									\n					vec2 pPos = A_findPixel(header, offset);																					\n					int shift = int(mod(offset, A_VB_ELEMENT_SIZE));																			\n																																				\n					#ifdef A_VB_COMPONENT4																										\n																																				\n					if(shift == 0) return A_tex2Dv(sampler, header, pPos).rg;																	\n					else if(shift == 1) return A_tex2Dv(sampler, header, pPos).gb;																\n					else if(shift == 2) return A_tex2Dv(sampler, header, pPos).ba;																\n					else if(shift == 3) {																										\n						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n							return vec2(A_tex2Dv(sampler, header, pPos).a,																		\n								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).r);									\n						}																														\n						else{																													\n							return vec2(A_tex2Dv(sampler, header, pPos).a, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).r);	\n						}																														\n					}																															\n					#endif																														\n																																				\n					return vec2(0.);																											\n				}																																\n																																				\n				vec4 A_extractVec4(const sampler2D sampler, const A_TextureHeader header, const float offset){									\n					vec2 pPos = A_findPixel(header, offset);																					\n					int shift = int(mod(offset, A_VB_ELEMENT_SIZE));																			\n																																				\n					#ifdef A_VB_COMPONENT4																										\n																																				\n					if(shift == 0) return A_tex2Dv(sampler, header, pPos);																		\n					else if(shift == 1){																										\n						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n							return vec4(A_tex2Dv(sampler, header, pPos).gba,																	\n								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).r);									\n						}																														\n						else{																													\n							return vec4(A_tex2Dv(sampler, header, pPos).gba, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).r);	\n						}																														\n					}																															\n					else if(shift == 2){																										\n						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n							return vec4(A_tex2Dv(sampler, header, pPos).ba,																		\n								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).rg);									\n						}																														\n						else{																													\n							return vec4(A_tex2Dv(sampler, header, pPos).ba, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).rg);	\n						}																														\n					}																															\n					else if(shift == 3){																										\n						if(int(pPos.x*header.width) == int(header.width - 1.)){																	\n							return vec4(A_tex2Dv(sampler, header, pPos).a,																		\n								A_tex2Dv(sampler, header, vec2(0.5 * header.stepX, pPos.y + header.stepY)).rgb);								\n						}																														\n						else{																													\n							return vec4(A_tex2Dv(sampler, header, pPos).a, A_tex2Dv(sampler, header, vec2(pPos.x + header.stepX, pPos.y)).rgb);	\n						}																														\n					}																															\n																																				\n					#endif																														\n																																				\n					#ifdef A_VB_COMPONENT3																										\n					#endif																														\n																																				\n					return vec4(0.);																											\n				}																																\n																																				\n				mat4 A_extractMat4(const sampler2D sampler, const A_TextureHeader header, const float offset){									\n					return mat4(A_tex2Dv(sampler, header, A_findPixel(header, offset)),															\n								A_tex2Dv(sampler, header, A_findPixel(header, offset + 4.)),													\n								A_tex2Dv(sampler, header, A_findPixel(header, offset + 8.)),													\n								A_tex2Dv(sampler, header, A_findPixel(header, offset + 12.)));													\n				}																																\n																																				\n				attribute float positionIndex;																									\n				attribute float normalIndex;																									\n				attribute float destinationIndex;																								\n																																				\n				uniform sampler2D videoBuffer;																									\n				uniform vec2 frameBufferSize;																									\n				uniform int type;																												\n				uniform mat4 bind_matrix;																										\n																																				\n				varying vec4 data;																												\n																																				\n				void main(void){																												\n					A_TextureHeader header;																										\n					A_extractTextureHeader(videoBuffer, header);																				\n																																				\n					vec4 position = A_extractVec4(videoBuffer, header, positionIndex);															\n					vec2 meta_data = A_extractVec2(videoBuffer, header, position.w);															\n																																				\n					float number_matrix = meta_data.x;																							\n					float bone_inf_ptr = meta_data.y;																							\n																																				\n					mat4 bone_matrix = mat4(0.);																								\n					float weight;																												\n																																				\n					mat4 result_mat = mat4(0.);																									\n																																				\n					for(float i = 0.; i < 16.; i++) {																							\n						if(i < number_matrix){																									\n							//get data about matrix and weight																					\n							vec2 bone_inf = A_extractVec2(videoBuffer, header, bone_inf_ptr + i * 2.);											\n																																				\n							bone_matrix = A_extractMat4(videoBuffer, header, bone_inf.x);														\n							weight = bone_inf.y;																								\n																																				\n							result_mat += bone_matrix * weight;																					\n						}																														\n						else {																													\n							break;																												\n						}																														\n					}																															\n																																				\n					result_mat = result_mat * bind_matrix;																						\n																																				\n					if(type == 0){																												\n						data = result_mat * vec4(position.xyz, 1.);																				\n					}																															\n					else if(type == 1){																											\n						vec4 normal = A_extractVec4(videoBuffer, header, normalIndex);															\n						data = vec4((result_mat * vec4(normal.xyz, 0.)).xyz, normal.w);															\n					}																															\n																																				\n					vec2 outPixelPosition = vec2((mod(destinationIndex/4., frameBufferSize.x) + 0.5)/frameBufferSize.x,							\n												 (floor(destinationIndex/4./frameBufferSize.x) + 0.5)/frameBufferSize.y);						\n																																				\n					gl_Position = vec4(outPixelPosition*2. - 1., 0. ,1.);																		\n					gl_PointSize = 1.;																											\n				}																																\n																																				\n        		",
        		"																																\n				#ifdef GL_ES                        																							\n				    precision highp float;          																							\n				#endif																															\n				varying vec4 data;                  																							\n				                                    																							\n				void main(void) {                   																							\n				    gl_FragColor = data;            																							\n				}                                   																							\n				"
    		);
        }

        var pOldFrameBuffer: WebGLFramebuffer = pWebGLRenderer.getParameter( 0x8CA6 );

        var pWebGLFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();

        pWebGLRenderer.disableAllWebGLVertexAttribs();

        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pWebGLFramebuffer);
        pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

        pWebGLRenderer.disable( 0x0B71 );
        pWebGLRenderer.disable( 0x0C11 );
        pWebGLRenderer.disable( 0x0BE2 );
        pWebGLRenderer.disable( 0x0B44 );

        var iPositionAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("positionIndex");
        var iNormalAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("normalIndex");
        var iDestinationAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("destinationIndex");

        pWebGLContext.enableVertexAttribArray(iPositionAttribLocation);
        pWebGLContext.enableVertexAttribArray(iNormalAttribLocation);
        pWebGLContext.enableVertexAttribArray(iDestinationAttribLocation);

        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
        	0x0DE1 , pWebGLTexture, 0);

//get data from renderData for position update
		pRenderData.selectIndexSet(".update_skinned_position");
		var pIndexData: IVertexData = <IVertexData>pRenderData.getIndices();
		var pBuffer: webgl.WebGLVertexBuffer = <webgl.WebGLVertexBuffer>pIndexData.buffer;
		var pDeclaration: IVertexDeclaration = pIndexData.getVertexDeclaration();

//LOG(pIndexData.toString());

		var iStride:  number  = pDeclaration.stride;
		var iPositionOffset:  number  = pDeclaration.findElement("UPP_INDEX").offset;
		var iDestinationOffset:  number  = pDeclaration.findElement("DESTINATION_SP").offset;
		var iNormalOffset:  number  = 0.;

        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pBuffer.getWebGLBuffer());
        pWebGLContext.vertexAttribPointer(iPositionAttribLocation, 1,  0x1406 , false, iStride, iPositionOffset);
        pWebGLContext.vertexAttribPointer(iDestinationAttribLocation, 1,  0x1406 , false, iStride, iDestinationOffset);

/////////////////////////////////////////////////////////////////////////
//просто подаем данные чтобы можно было порендерить, мы все равно ими не пользуемся
        pWebGLContext.vertexAttribPointer(iNormalAttribLocation, 1,  0x1406 , false, iStride, iPositionOffset);
//
/////////////////////////////////////////////////////////////////////////

        pWebGLRenderer.activateWebGLTexture( 0x84C0 );
        pWebGLRenderer.bindWebGLTexture( 0x0DE1 , pWebGLTexture);

        var iWidth:  number  = pWebGLVertexTexture._getWidth();
        var iHeight:  number  = pWebGLVertexTexture._getHeight();

        pWebGLProgram.setInt("videoBuffer", 0);
        pWebGLProgram.setVec2("frameBufferSize",  Vec2.stackCeil.set(iWidth, iHeight) );
        pWebGLProgram.setInt("type", 0);
        pWebGLProgram.setMat4("bind_matrix", pMeshSubset.skin.getBindMatrix());

        pWebGLContext.viewport(0, 0, iWidth, iHeight);
//PASS 1
///////////////////////////////////////////////
        pWebGLContext.drawArrays( 0x0000 , pIndexData.byteOffset/iStride, pIndexData.length);
///////////////////////////////////////////////

//get data from renderData for normal update
		pRenderData.selectIndexSet(".update_skinned_normal");
		pIndexData = <IVertexData>pRenderData.getIndices();
		pBuffer = <webgl.WebGLVertexBuffer>pIndexData.buffer;
		pDeclaration = pIndexData.getVertexDeclaration();

//LOG(pIndexData.toString());

		iStride = pDeclaration.stride;
		iPositionOffset = pDeclaration.findElement("UNP_INDEX").offset;
		iNormalOffset = pDeclaration.findElement("UNN_INDEX").offset;
		iDestinationOffset = pDeclaration.findElement("DESTINATION_SN").offset;

        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pBuffer.getWebGLBuffer());
        pWebGLContext.vertexAttribPointer(iPositionAttribLocation, 1,  0x1406 , false, iStride, iPositionOffset);
        pWebGLContext.vertexAttribPointer(iNormalAttribLocation, 1,  0x1406 , false, iStride, iNormalOffset);
        pWebGLContext.vertexAttribPointer(iDestinationAttribLocation, 1,  0x1406 , false, iStride, iDestinationOffset);

        pWebGLProgram.setInt("type", 1);

//PASS 2
///////////////////////////////////////////////
        pWebGLContext.drawArrays( 0x0000 , pIndexData.byteOffset/iStride, pIndexData.length);
///////////////////////////////////////////////

        pWebGLContext.flush();

        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFrameBuffer);
        pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);

        pWebGLContext.disableVertexAttribArray(iPositionAttribLocation);
        pWebGLContext.disableVertexAttribArray(iNormalAttribLocation);
        pWebGLContext.disableVertexAttribArray(iDestinationAttribLocation);

        pWebGLRenderer.bindWebGLBuffer( 0x8892 , null);
        pWebGLRenderer.bindWebGLTexture( 0x0DE1 , null);
        pWebGLRenderer._setViewport(null);

		return true;
	};


}



module akra.model {
	export class MeshSubset extends render.RenderableObject implements IMeshSubset {
		protected _sName: string = null;
		protected _pMesh: IMesh = null;
		protected _pSkin: ISkin = null;
		protected _pBoundingBox: IRect3d = null;
		protected _pBoundingSphere: ISphere = null;
		protected _isOptimizedSkinned: bool = false;

		/**@inline*/  get boundingBox(): IRect3d { return this._pBoundingBox; }
		/**@inline*/  get boundingSphere(): ISphere { return this._pBoundingSphere; }
		/**@inline*/  get skin(): ISkin { return this._pSkin; }
		/**@inline*/  get name(): string { return this._sName; }
		/**@inline*/  get mesh(): IMesh { return this._pMesh; }


		constructor (pMesh: IMesh, pRenderData: IRenderData, sName: string = null) {
			super(ERenderDataTypes.MESH_SUBSET);
			this.setup(pMesh, pRenderData, sName);
		}

		protected setup(pMesh: IMesh, pRenderData: IRenderData, sName: string): void {
			{ logger.setSourceLocation( "MeshSubset.ts" , 39 ); logger.assert(this._pMesh === null, "mesh subset already prepared"); } ;

			this._pMesh = pMesh;
			this._pRenderData = pRenderData;
			this._sName = sName;

			super._setup(pMesh.getEngine().getRenderer());
		}

		createBoundingBox(): bool {
			var pVertexData: IVertexData;
			var pNewBoundingBox: IRect3d;

			pNewBoundingBox = new geometry.Rect3d();
			pVertexData = this.data._getData(DeclUsages.POSITION);

			if(isNull(pVertexData))
				return false;

			if(geometry.computeBoundingBox(pVertexData, pNewBoundingBox) == false)
				return false;

			this._pBoundingBox = pNewBoundingBox;

			return true;
		}

		deleteBoundingBox(): bool {
			this._pBoundingBox = null;

			return true;
		}

		showBoundingBox(): bool {
			var pMaterial: IMaterial;
			var iData:  number ;
			var iCurrentIndexSet:  number ;
			var pPoints:  number [],
				pIndexes:  number  [];

			if (isNull(this._pBoundingBox)) {
				if(!this.createBoundingBox()){
					return false;
				}
			}

			pPoints = new Array();
			pIndexes = new Array();

			geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 10.0);

			iCurrentIndexSet = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingBox")) {
				if (this.data.addIndexSet(false, EPrimitiveTypes.LINELIST, ".BoundingBox") == -1) {
					{ logger.setSourceLocation( "MeshSubset.ts" , 94 ); logger.error("could not add index set '.BoundingBox'"); } ;
					return false;
				}

				iData = this.data.allocateData([VE_FLOAT3(DeclUsages.POSITION)], new Float32Array(pPoints));

				this.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));

				this.data.index(iData,DeclUsages.INDEX0);

// this.applyFlexMaterial(".MaterialBoundingBox");

//       //TODO: некорректно задавать так boundingBox, т.к. надо рендерится со своим рендер методом, а его никто не выбирает. 
// pMaterial = this.getFlexMaterial(".MaterialBoundingBox");
// pMaterial.emissive = new Color(0.0, 0.0, 1.0, 1.0);
// pMaterial.diffuse  = new Color(0.0, 0.0, 1.0, 1.0);
			}
			else {
				this.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
			}

			this.data.setRenderable(this.data.getIndexSet(), true);
			this.data.selectIndexSet(iCurrentIndexSet);

			return true;
		}

		/**@inline*/  isBoundingBoxVisible(): bool {
			return this.data.isRenderable(this.data.findIndexSet(".BoundingBox"));
		}

		hideBoundingBox(): bool {
			var iCurrentIndexSet:  number ;
			iCurrentIndexSet = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingBox")) {
				return false;
			}
			else {
				this.data.setRenderable(this.data.getIndexSet(), false);
			}

			return this.data.selectIndexSet(iCurrentIndexSet);
		}

		createBoundingSphere(): bool {
			var pVertexData: IVertexData;
			var pNewBoundingSphere: ISphere;

			pNewBoundingSphere = new geometry.Sphere();
			pVertexData = this.data._getData(DeclUsages.POSITION);

			if(!pVertexData) {
				return false;
			}

			if(!geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere, false, this._pBoundingBox)) {
				return false;
			}

			this._pBoundingSphere = pNewBoundingSphere;

			return true;
		}


		deleteBoundingSphere(): bool {
			this._pBoundingSphere = null;
			return true;
		}



		showBoundingSphere(): bool {
			var pMaterial: IMaterial;
			var iData:  number ;
			var iCurrentIndexSet:  number ;
			var pPoints:  number [], pIndexes:  number [];

			if(isNull(this._pBoundingSphere)) {
				if(!this.createBoundingSphere()){
					return false;
				}
			}

			pPoints = new Array();
			pIndexes = new Array();
			geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);

			iCurrentIndexSet = this.data.getIndexSet();
			if(!this.data.selectIndexSet(".BoundingSphere")) {
				this.data.addIndexSet(false, EPrimitiveTypes.LINELIST, ".BoundingSphere");

				iData = this.data.allocateData([VE_FLOAT3(DeclUsages.POSITION)], new Float32Array(pPoints));

				this.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));
				this.data.index(iData,DeclUsages.INDEX0);

// this.applyFlexMaterial(".MaterialBoundingSphere");

// pMaterial = this.getFlexMaterial(".MaterialBoundingSphere");
// pMaterial.emissive = new Color(0.0, 0.0, 1.0, 1.0);
// pMaterial.diffuse  = new Color(0.0, 0.0, 1.0, 1.0);
			}
			else {
				this.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
			}

			this.data.setRenderable(this.data.getIndexSet(), true);
			this.data.selectIndexSet(iCurrentIndexSet);

			return true;
		}


/*wireframe(bEnable: bool = true): bool {
			if(this.data.findIndexSet(".wireframe") == -1) {
				var ePrimType: EPrimitiveTypes = this.data.getPrimitiveType();

				if (ePrimType !== EPrimitiveTypes.TRIANGLELIST) {
					WARNING("wireframe supported only for TRIANGLELIST");
					return false;
				}

				var pIndices: Float32Array = <Float32Array>this.data.getIndexFor("POSITION");

				var pWFindices: int[] = [];
				var pWFCache: BoolMap = <any>{};
				var pPairs: int[][] = [[0, 1], [1, 2], [2, 0]];

				for (var n = 0; n < pIndices.length / 3; ++ n) {
					var t: int = n * 3;
					for (var i: int = 0; i < pPairs.length; ++ i) {
						
						var i1: int = pPairs[i][0];
						var i2: int = pPairs[i][1];

						var v1: int = pIndices[t + i1];
						var v2: int = pIndices[t + i2];

						if (v2 < v1) {
							var y: int = v2; v1 = v2; v2 = y;
						}

						var k: string = v1 + "_" + v2;

						if (pWFCache[k]) {
							continue;
						}

						pWFCache[k] = true;
						pWFindices.push(v1, v2);
					}
				}

				var iData: int = this.data.getDataLocation("POSITION");
				var iCurrentIndexSet: int = this.data.getIndexSet();
				var iWireframeSet: int = this.data.addIndexSet(false, EPrimitiveTypes.LINELIST, ".wireframe");

				this.data.allocateIndex([VE_FLOAT("WF_INDEX")], new Float32Array(pWFindices));
				this.data.index(iData, "WF_INDEX", false, 0, true);
				
				this.data.setRenderable(iWireframeSet, true);
				this.data.setRenderable(iCurrentIndexSet, false);

				this.data.selectIndexSet(iCurrentIndexSet);
			}

			var iWireframeSet: int = this.data.findIndexSet(".wireframe");
			var iCurrentIndexSet: int = 0;

			this.data.setRenderable(iWireframeSet, bEnable);
			this.data.setRenderable(iCurrentIndexSet, !bEnable);

			return true;
		}*/


		/**@inline*/  isBoundingSphereVisible(): bool {
			return this.data.isRenderable(this.data.findIndexSet(".BoundingSphere"));
		}

		hideBoundingSphere(): bool{
			var iCurrentIndexSet:  number  = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingSphere")) {
				return false;
			}
			else {
				this.data.setRenderable(this.data.getIndexSet(), false);
			}

			return this.data.selectIndexSet(iCurrentIndexSet);
		}


		computeNormals () {
//TODO: calc normals
		}

		computeTangents () {
//TODO: compute normals
		}

		computeBinormals () {
//TODO: calc binormals
		}

		/**@inline*/  isSkinned(): bool {
		    return this._pSkin !== null;
		}

		/**@inline*/  isOptimizedSkinned(): bool{
			return this.isSkinned() && this._isOptimizedSkinned;
		}

		getSkin(): ISkin{
		    return this._pSkin;
		}

		applyFlexMaterial(sMaterial: string, pMaterialData: IMaterial = null): bool {
		    if (this._pMesh.addFlexMaterial(sMaterial, pMaterialData)) {
		        return this.setFlexMaterial(sMaterial);
		    }

		    return false;
		}

		getFlexMaterial(csName: string): IMaterial;
		getFlexMaterial(iMaterial:  number ): IMaterial;
		getFlexMaterial(iMaterial): IMaterial {
		    return this._pMesh.getFlexMaterial(< number >iMaterial);
		}

		hasFlexMaterial (): bool {
		    return this._pRenderData.hasSemantics(DeclUsages.MATERIAL);
		}

		setFlexMaterial (iMaterial:  number ): bool;
		setFlexMaterial (csName: string): bool;
		setFlexMaterial (iMaterial): bool {
		    var pMaterial: IMaterial = this._pMesh.getFlexMaterial(iMaterial);

		    if (isNull(pMaterial)) {
		    	{ logger.setSourceLocation( "MeshSubset.ts" , 337 ); logger.warning("could not find material <" + iMaterial + "> in sub mesh <" + this.name + ">"); } ;
		        return false;
		    }

		    var pRenderData: IRenderData = this._pRenderData;
		    var pIndexData: IBufferData = pRenderData.getIndices();
		    var pMatFlow: IDataFlow = pRenderData._getFlow(DeclUsages.MATERIAL);
		    var eSemantics: string = DeclUsages.INDEX10;
		    var pIndexDecl: IVertexDeclaration, pFloatArray: Float32Array;
		    var iMatFlow:  number ;
			var iMat:  number  = (<IFlexMaterial>pMaterial).data.byteOffset;

		    if (pMatFlow) {
		        iMatFlow = pMatFlow.flow;
		        eSemantics = pMatFlow.mapper.semantics;
		        pIndexData = pMatFlow.mapper.data;

		        pRenderData._addData((<IFlexMaterial>pMaterial).data, iMatFlow);

		        return pRenderData.index(iMat, eSemantics, true);
		    }

		    pIndexDecl = createVertexDeclaration([VE_FLOAT(eSemantics)]);
		    pFloatArray = new Float32Array((<IVertexData>pIndexData).length);
		    iMatFlow = pRenderData._addData((<IFlexMaterial>pMaterial).data);

		    { logger.setSourceLocation( "MeshSubset.ts" , 363 ); logger.assert(iMatFlow >= 0, "cannot add data flow with material for mesh subsset"); } ;

		    if (!pRenderData.allocateIndex(pIndexDecl, pFloatArray)) {
		        { logger.setSourceLocation( "MeshSubset.ts" , 366 ); logger.warning("cannot allocate index for material!!!"); } ;
		        return false;
		    }

		    return pRenderData.index(iMat, eSemantics, true);
		}

		_draw (): void {
//		    this._pRenderData._draw();
			{ logger.setSourceLocation( "MeshSubset.ts" , 375 ); logger.criticalError("Need to do."); } ;
		}

		/**@inline*/  show(): void {
		    this.data.setRenderable(true);
		}

		/**@inline*/  hide(): void {
		    this.data.setRenderable(false);
		}

		/**@inline*/  isRenderable(): bool {
			return this.data.isRenderable();
		}

//исходим из того, что данные скина 1:1 соотносятся с вершинами.
		setSkin(pSkin: ISkin): bool {
			var pRenderData: IRenderData = this.data;
		    var pPosData: IVertexData;
		    var pPositionFlow: IDataFlow;
		    var pNormalFlow: IDataFlow;
		    var pMetaData: Float32Array;
//мета данные разметки
		    var pInfMetaData: IVertexData;
//адресс мета данных во флотах
		    var iInfMetaDataLoc:  number ;
//шаг мета данных во флотах
		    var iInfMetaDataStride:  number ;
/*
		     Получаем данные вершин, чтобы проложить в {W} компоненту адерес мета информации,
		     о влиянии на данную вершины.
		     */


//получаем поток данных с вершиными
		    pPositionFlow = pRenderData._getFlow(DeclUsages.POSITION);
		    { logger.setSourceLocation( "MeshSubset.ts" , 410 ); logger.assert(isDefAndNotNull(pPositionFlow), "skin require position with indices in mesh subset"); } ;

		    pPosData = pPositionFlow.data;

//проверяем, что данные еще не подвязаны к другому Skin'у
		    if (pPosData.hasSemantics(DeclUsages.BLENDMETA)) {
//тоже самый skin?
		        if (pSkin.isAffect(pPosData)) {
		            return true;
		        }

		        { logger.setSourceLocation( "MeshSubset.ts" , 421 ); logger.error("mesh subset already has another skin"); } ;
		        return false;
		    }

//проверяем, что текущий подмеш пренадлежит мешу, на который натягивается skin,
//или его клону.
		    { logger.setSourceLocation( "MeshSubset.ts" , 428 ); logger.assert(this.data.buffer == pSkin.data, "can not bind to skin mesh subset that does not belong skin's mesh."); }

//подвязывем скин, к данным с вершинами текущего подмеша.
//т.е. добавляем разметку в конец каждого пикселя
		    pSkin.attach(pPosData);

/*
		    //получаем данные разметки
		    pMetaData = <Float32Array>pPosData.getTypedData(DeclUsages.BLENDMETA);

		    //если по каким то причинам нет разметки...
		    debug_assert(isDefAndNotNull(pMetaData), "you must specify location for storage blending data");

		    //выставляем разметку мета данных вершин, так чтобы они адрессовали сразу на данные
		    pInfMetaData = pSkin.getInfluenceMetaData();
		    iInfMetaDataLoc = pInfMetaData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;
		    iInfMetaDataStride = pInfMetaData.stride / EDataTypeSizes.BYTES_PER_FLOAT;

		    for (var i: int = 0; i < pMetaData.length; ++ i) {
		        pMetaData[i] = iInfMetaDataLoc + i * iInfMetaDataStride;
		    }

		    //обновляем адреса мета данных вершин
		    pPosData.setData(pMetaData, DeclUsages.BLENDMETA);

		    */


		    var pDeclaration: IVertexDeclaration = pPosData.getVertexDeclaration();
		    var pVEMeta: IVertexElement = pDeclaration.findElement(DeclUsages.BLENDMETA);
//if BLENDMETA not found
		    { logger.setSourceLocation( "MeshSubset.ts" , 458 ); logger.assert(isDefAndNotNull(pVEMeta), "you must specify location for storage blending data"); } ;

//read all data for acceleration
		    pMetaData = new Float32Array(pPosData.getData(0, pDeclaration.stride));

//выставляем разметку мета данных вершин, так чтобы они адрессовали сразу на данные
		    pInfMetaData = pSkin.getInfluenceMetaData();
		    iInfMetaDataLoc = pInfMetaData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;
		    iInfMetaDataStride = pInfMetaData.stride / EDataTypeSizes.BYTES_PER_FLOAT;

		    var iCount:  number  = pMetaData.byteLength/pDeclaration.stride;
		    var iOffset:  number  = pVEMeta.offset/EDataTypeSizes.BYTES_PER_FLOAT;
		    var iStride:  number  = pDeclaration.stride/EDataTypeSizes.BYTES_PER_FLOAT;

		    for (var i:  number  = 0; i < iCount; ++ i) {
		        pMetaData[iOffset + i*iStride] = iInfMetaDataLoc + i * iInfMetaDataStride;
		    }

		    pPosData.setData(pMetaData, 0, pDeclaration.stride);

		    var pIndexData: IVertexData = <IVertexData>pRenderData.getIndices();

		    pNormalFlow = pRenderData._getFlow(DeclUsages.NORMAL);

		    var pIndex0: Float32Array = <Float32Array>pIndexData.getTypedData(pPositionFlow.mapper.semantics);
		    var pIndex1: Float32Array = <Float32Array>pIndexData.getTypedData(pNormalFlow.mapper.semantics);

		    var iAdditionPosition:  number  = pPosData.byteOffset;
		    var iAdditionNormal:  number  = pNormalFlow.data.byteOffset;

	    	for(var i=0; i<pIndex0.length; i++){
	    		pIndex0[i] = (pIndex0[i] * EDataTypeSizes.BYTES_PER_FLOAT - iAdditionPosition)/pPositionFlow.data.stride;
	    		pIndex1[i] = (pIndex1[i] * EDataTypeSizes.BYTES_PER_FLOAT - iAdditionNormal)/pNormalFlow.data.stride;
	    	}

//update position index
	    	var pUPPositionIndex: Float32Array = new Float32Array(pPosData.length);
	    	for(var i:  number =0; i<pPosData.length; i++){
	    		pUPPositionIndex[i] = i;
	    	}

//update normal index

	    	var pTmp: any = {};

	    	var pSkinnedNormalIndex:  number [] = [];
/*update normal position index*/
	    	var pUNPositionIndex:  number [] = [];
/*update normal normal index*/
	    	var pUNNormalIndex:  number [] = [];
	    	var pDestinationSkinnedNormalIndex:  number [] = [];

	    	var iCounter:  number  = 0;

	    	for(var i=0; i<pIndex0.length; i++){
	    		var sKey: string = pIndex0[i].toString() + "_" + pIndex1[i];
	    		if(!isDef(pTmp[sKey])){
	    			pTmp[sKey] = iCounter;
	    			pUNPositionIndex.push(pIndex0[i]);
	    			pUNNormalIndex.push(pIndex1[i]);
	    			pSkinnedNormalIndex.push(iCounter);
	    			pDestinationSkinnedNormalIndex.push(iCounter);
	    			iCounter++;
	    		}
	    		else{
	    			pSkinnedNormalIndex.push(pDestinationSkinnedNormalIndex[pTmp[sKey]]);
	    		}
	    	}

	    	var iSkinnedPos:  number  = pRenderData.allocateData([VE_FLOAT3("SKINNED_POSITION"), VE_END(16)], new Float32Array(pPosData.length * 4));
/*skinned vertices uses same index as vertices*/

	    	pRenderData.allocateIndex([VE_FLOAT("SP_INDEX")], pIndex0);
	    	pRenderData.index(iSkinnedPos, "SP_INDEX");

	    	var iSkinnedNorm:  number  = pRenderData.allocateData([VE_FLOAT3("SKINNED_NORMAL"), VE_END(16)], new Float32Array(pUNNormalIndex.length * 4));
/*skinned normals uses new index*/

	    	pRenderData.allocateIndex([VE_FLOAT("SN_INDEX")], new Float32Array(pSkinnedNormalIndex));
	    	pRenderData.index(iSkinnedNorm, "SN_INDEX");

	    	var iPreviousSet:  number  = pRenderData.getIndexSet();

	    	var iUPIndexSet:  number  = pRenderData.addIndexSet(true, EPrimitiveTypes.POINTLIST, ".update_skinned_position");
	    	pRenderData.allocateIndex([VE_FLOAT("UPP_INDEX")], pUPPositionIndex);
	    	pRenderData.index(pPosData.byteOffset, "UPP_INDEX");
	    	pRenderData.allocateIndex([VE_FLOAT("DESTINATION_SP")], pUPPositionIndex);
	    	pRenderData.index(iSkinnedPos, "DESTINATION_SP");

	    	var iUNIndexSet:  number  = pRenderData.addIndexSet(true, EPrimitiveTypes.POINTLIST, ".update_skinned_normal");
	    	pRenderData.allocateIndex([VE_FLOAT("UNP_INDEX")], new Float32Array(pUNPositionIndex));
	    	pRenderData.index(pPosData.byteOffset, "UNP_INDEX");
	    	pRenderData.allocateIndex([VE_FLOAT("UNN_INDEX")], new Float32Array(pUNNormalIndex));
	    	pRenderData.index(pRenderData._getFlow(DeclUsages.NORMAL, false).data.byteOffset, "UNN_INDEX");
	    	pRenderData.allocateIndex([VE_FLOAT("DESTINATION_SN")], new Float32Array(pDestinationSkinnedNormalIndex));
	    	pRenderData.index(iSkinnedNorm, "DESTINATION_SN");

	    	pRenderData.selectIndexSet(iPreviousSet);
// LOG(pRenderData.toString());

// pRenderData.selectIndexSet(iUPIndexSet);
// LOG(pRenderData.toString());

// pRenderData.selectIndexSet(iUNIndexSet);
// LOG(pRenderData.toString());

	    	pRenderData.setRenderable(iUPIndexSet, false);
	    	pRenderData.setRenderable(iUNIndexSet, false);

// LOG(iPreviousSet, iUPIndexSet);

// LOG(pSkinnedNormalIndex);
// LOG(pUNPositionIndex);
// LOG(pUNNormalIndex);

		    this._pSkin = pSkin;
		    this.skinAdded(pSkin);

		    return true;
		}

		_calculateSkin(): bool{
			var isOk: bool = util.calculateSkin(this);
			this._isOptimizedSkinned = isOk;
			return isOk;
		}

		skinAdded (pSkin): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).skinAdded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pSkin) : _broadcast[i].listener (_recivier, pSkin) ; } } } ; ;
	}
}










module akra.model {

	class Mesh implements IMesh extends util.ReferenceCounter {
        private _sName: string;
        private _pFlexMaterials: IMaterial[] = null;
        private _pBuffer: IRenderDataCollection = null;
        private _pEngine: IEngine;
        private _eOptions:  number  = 0;
        private _pSkeleton: ISkeleton = null;
        private _pBoundingBox: IRect3d = null;
        private _pBoundingSphere: ISphere = null;
        private _pSubMeshes: IMeshSubset[] = [];
        private _bShadow: bool = true;
        private _pSkinList: ISkin[] = [];

        /**@inline*/  get length():  number  {
            return this._pSubMeshes.length;
        }

        /**@inline*/  get flexMaterials(): IMaterial[] {
            return this._pFlexMaterials;
        }

        /**@inline*/  get name(): string{
            return this._sName;
        }

        /**@inline*/  get data(): IRenderDataCollection {
            return this._pBuffer;
        }

        /**@inline*/  get skeleton(): ISkeleton {
            return this._pSkeleton;
        }

        /**@inline*/  set skeleton(pSkeleton: ISkeleton){
            this._pSkeleton = pSkeleton;
        }

        /**@inline*/  get boundingBox(): IRect3d {
            if (isNull(this._pBoundingBox)) {
                if (!this.createBoundingBox()) {
                    { logger.setSourceLocation( "model/Mesh.ts" , 67 ); logger.warning("could not compute bounding box fo mesh"); } ;
                }
            }

            return this._pBoundingBox;
        }

        /**@inline*/  get boundingSphere(): ISphere {
            if (isNull(this._pBoundingSphere)) {
                if (!this.createBoundingSphere()) {
                    { logger.setSourceLocation( "model/Mesh.ts" , 77 ); logger.warning("could not compute bounding sphere for mesh"); } ;
                }
            }

            return this._pBoundingSphere;
        }

        constructor(pEngine: IEngine, eOptions:  number , sName: string, pDataBuffer: IRenderDataCollection) {
            super();

            this._sName = sName || null;
            this._pEngine = pEngine;
            this.setup(sName, eOptions, pDataBuffer);
        }

        setSkeleton(pSkeleton: ISkeleton): void {
            this.skeleton = pSkeleton;
        }

        getOptions():  number  {
            return this._eOptions;
        }

        getEngine(): IEngine {
            return this._pEngine;
        }

        _drawSubset(iSubset:  number ): void {
            this._pBuffer._draw(iSubset);
        }

        _draw(): void {
            for (var i:  number  = 0; i < this.length; i++) {
                this._pSubMeshes[i]._draw();
            };
        }

        isReadyForRender(): bool {
            for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                if (this._pSubMeshes[i].isReadyForRender()) {
                    return true;
                }
            }

            return false;
        }

        private setup(sName: string, eOptions:  number , pDataCollection?: IRenderDataCollection): bool {
            { logger.setSourceLocation( "model/Mesh.ts" , 125 ); logger.assert(this._pBuffer === null, "mesh already setuped."); } ;

            if (isNull(pDataCollection)) {
                this._pBuffer = this._pEngine.createRenderDataCollection(eOptions);
            }
            else {
                { logger.setSourceLocation( "model/Mesh.ts" , 132 ); logger.assert(pDataCollection.getEngine() === this.getEngine(), "you can not use a buffer with a different context"); }
                                                                        ;

                this._pBuffer = pDataCollection;
                eOptions |= pDataCollection.getOptions();
            }

            this._pBuffer.addRef();
            this._eOptions = eOptions || 0;
            this._sName = sName ||  "unknown" ;

            return true;
        }

        createSubset(sName: string, ePrimType: EPrimitiveTypes, eOptions:  number  = 0): IMeshSubset {
            var pData: IRenderData;
//TODO: modify options and create options for data dactory.
/*EPrimitiveTypes.POINTLIST*/
            pData = this._pBuffer.getEmptyRenderData(ePrimType                             , eOptions);
            pData.addRef();

            if (isNull(pData)) {
                return null;
            }

            return this.appendSubset(sName, pData);
        }

        appendSubset(sName: string, pData: IRenderData): IMeshSubset {
            { logger.setSourceLocation( "model/Mesh.ts" , 159 ); logger.assert(pData.buffer === this._pBuffer, "invalid data used"); } ;

            var pSubMesh: IMeshSubset = new MeshSubset(this, pData, sName);
            this._pSubMeshes.push(pSubMesh);

            this.connect(pSubMesh,  "skinAdded" ,  "_skinAdded" );
            this.connect(pSubMesh,  "shadowed" ,  "shadowed" , EEventTypes.UNICAST);

            return pSubMesh;
        }

        _skinAdded(pSubMesh: IMeshSubset, pSkin: ISkin): void {
            if (this._pSkinList.indexOf(pSkin) != -1) {
                return;
            }

            this._pSkinList.push(pSkin);
        }

        replaceFlexMaterials(pFlexMaterials: IMaterial[]): void {
            this._pFlexMaterials = pFlexMaterials;
        }

        freeSubset(sName: string): bool {
            { logger.setSourceLocation( "model/Mesh.ts" , 183 ); logger.error("Метод freeSubset не реализован"); } ;
            return false;
        }

        getFlexMaterial(iMaterial:  number ): IMaterial;
        getFlexMaterial(sName: string): IMaterial;
        getFlexMaterial(arg) {
            if (!this._pFlexMaterials) {
                return null;
            }

            if (typeof arguments[0] === 'number') {
                return this._pFlexMaterials[arguments[0]] || null;
            }
            else {
                for (var i = 0, pMaterials = this._pFlexMaterials; i < pMaterials.length; ++ i) {
                    if (pMaterials[i].name === <string>arguments[0]) {
                        return pMaterials[i];
                    }
                }
            }

            return null;
        }

        addFlexMaterial(sName: string = 'unknown', pMaterialData: IMaterial = null): bool {
            var pMaterial: IMaterial;
            var pMaterialId:  number ;

            { logger.setSourceLocation( "model/Mesh.ts" , 212 ); logger.assert(arguments.length < 7, "only base material supported now..."); } ;
//debug_assert(this.getFlexMaterial(sName) === null, 'material with name <' + sName + '> already exists');

            pMaterial = this.getFlexMaterial(sName);

            if (pMaterial) {
                if (pMaterialData) {
                   pMaterial.set(pMaterialData);
                }
                return true;
            }

            if (!this._pFlexMaterials) {
                this._pFlexMaterials = [];
            }

            pMaterialId = this._pFlexMaterials.length;
            pMaterial = material._createFlex(
                sName,
                this._pBuffer._allocateData(material.VERTEX_DECL, null)
            );

            if (!pMaterialData) {
                pMaterialData = material.create(null, material.DEFAULT)
            }

            pMaterial.set(pMaterialData);
//pMaterial.id = pMaterialId;
            this._pFlexMaterials.push(pMaterial);

            return true;
        }

        setFlexMaterial(iMaterial:  number ): bool;
        setFlexMaterial(csName: string): bool;
        setFlexMaterial(iMaterial): bool {
            var bResult: bool = true;
            for (var i:  number  = 0; i < this.length; ++ i) {
                if (!this._pSubMeshes[i].setFlexMaterial(< number >iMaterial)) {
                    { logger.setSourceLocation( "model/Mesh.ts" , 252 ); logger.warning("cannot set material<" + iMaterial + "> for mesh<" + this.name + "> subset<" + this._pSubMeshes[i].name + ">"); }
                                                                     ;
                    bResult = false;
                }
            }

            return bResult;
        }

        destroy(): void {
            this._pFlexMaterials = null;
            this._pSubMeshes = null;
/*this*/
            this._pBuffer.destroy(        );
        }

        getSubset(sName: string): IMeshSubset;
        getSubset(n:  number ): IMeshSubset;
        getSubset(n: any): IMeshSubset {
            if (isInt(arguments[0])) {
                return this._pSubMeshes[arguments[0]] || null;
            }
            else {
                for (var i = 0; i < this.length; ++ i) {
                    if (this._pSubMeshes[i].name == <string>arguments[0]) {
                        return this._pSubMeshes[i];
                    }
                }
            }

            return null;
        }

        setSkin(pSkin: ISkin): void {
            for (var i = 0; i < this.length; ++ i) {
                this._pSubMeshes[i].setSkin(pSkin);
            }
        }

        createSkin(): ISkin {
            var pSkin: ISkin = createSkin(this);
            return pSkin;
        }

        clone(iCloneOptions:  number ): IMesh {
            var pClone: IMesh = null;
            var pRenderData: IRenderData;
            var pSubMesh: IMeshSubset;

            if (iCloneOptions & EMeshCloneOptions.SHARED_GEOMETRY) {
                pClone = this.getEngine().createMesh(this.name, this.getOptions(), this.data);

                for (var i = 0; i < this.length; ++ i) {
                    pRenderData = this._pSubMeshes[i].data;
                    pRenderData.addRef();
                    pClone.appendSubset(this._pSubMeshes[i].name, pRenderData);
                    pClone.getSubset(i).material.name = this._pSubMeshes[i].material.name;
                }

                pClone.replaceFlexMaterials(this.flexMaterials);

//trace('created clone', pClone);
            }
            else {
//TODO: clone mesh data.
            }

            if (iCloneOptions & EMeshCloneOptions.GEOMETRY_ONLY) {
                return pClone;
            }
            else {
//TODO: clone mesh shading
            }

            return pClone;
        }

        createAndShowSubBoundingBox(): void {
            for(var i = 0; i < this.length; i++) {
                var pSubMesh: IMeshSubset = this.getSubset(i);
                if (pSubMesh.createBoundingBox()) {
                    if (!pSubMesh.showBoundingBox()) {
                        { logger.setSourceLocation( "model/Mesh.ts" , 332 ); logger.error("could not show sub bounding box"); } ;
                    }
                }
                else {
                    { logger.setSourceLocation( "model/Mesh.ts" , 336 ); logger.error("could not create sub bounding box."); } ;
                }
//console.log("SubMesh" + i);
            }
        }

        createAndShowSubBoundingSphere(): void {
            for(var i = 0; i < this.length; i ++) {
                var pSubMesh: IMeshSubset = this.getSubset(i);
                pSubMesh.createBoundingSphere();
                pSubMesh.showBoundingSphere();
//console.log("SubMesh" + i);
            }
        }

        createBoundingBox(): bool {
            var pVertexData: IVertexData;
            var pSubMesh: IMeshSubset;
            var pNewBoundingBox: IRect3d;
            var pTempBoundingBox: IRect3d;
            var i:  number ;

            pNewBoundingBox = new geometry.Rect3d();
            pTempBoundingBox = new geometry.Rect3d();

            pSubMesh = this.getSubset(0);
            pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

            if(isNull(pVertexData)) {
                return false;
            }

            if(geometry.computeBoundingBox(pVertexData, pNewBoundingBox)== false)
                return false;

            if (pSubMesh.isSkinned()) {
                pNewBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                pNewBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
            }

            for(i = 1; i < this.length; i++) {

                pSubMesh = this.getSubset(i);
                pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);
//trace(pSubMesh.name);

                if(!pVertexData) {
                    return false;
                }

                if(geometry.computeBoundingBox(pVertexData, pTempBoundingBox) == false) {
                    return false;
                }

//trace('>>> before box >>');
                if (pSubMesh.isSkinned()) {
//trace('calc skinned box');
                    pTempBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                    pTempBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                }
// trace('<<< after box <<');

                pNewBoundingBox.x0 = Math.min(pNewBoundingBox.x0, pTempBoundingBox.x0);
                pNewBoundingBox.y0 = Math.min(pNewBoundingBox.y0, pTempBoundingBox.y0);
                pNewBoundingBox.z0 = Math.min(pNewBoundingBox.z0, pTempBoundingBox.z0);

                pNewBoundingBox.x1 = Math.max(pNewBoundingBox.x1, pTempBoundingBox.x1);
                pNewBoundingBox.y1 = Math.max(pNewBoundingBox.y1, pTempBoundingBox.y1);
                pNewBoundingBox.z1 = Math.max(pNewBoundingBox.z1, pTempBoundingBox.z1);
            }

            this._pBoundingBox = pNewBoundingBox;
            return true;
        }

        deleteBoundingBox(): bool {
            this._pBoundingBox = null;
            return true;
        }

        showBoundingBox(): bool {
            var pSubMesh: IMeshSubset;
            var pMaterial: IMaterial;
            var iData:  number ;
            var pPoints:  number [], pIndexes:  number [];

            if(isNull(this._pBoundingBox)) {
                if (!this.createBoundingBox()) {
                    return false;
                }
            }

            pPoints = new Array();
            pIndexes = new Array();

            geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 0.1);

            pSubMesh = this.getSubset(".BoundingBox");

            if(!pSubMesh) {
                pSubMesh = this.createSubset(".BoundingBox", EPrimitiveTypes.LINELIST, EHardwareBufferFlags.STATIC);

                if(isNull(pSubMesh)) {
                    { logger.setSourceLocation( "model/Mesh.ts" , 439 ); logger.error("could not create bounding box subset..."); } ;
                    return false;
                }

                iData = pSubMesh.data.allocateData([VE_FLOAT3(DeclUsages.POSITION)], new Float32Array(pPoints));

                pSubMesh.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));

                pSubMesh.data.index(iData, DeclUsages.INDEX0);

// pSubMesh.applyFlexMaterial(".MaterialBoundingBox");
/*getFlexMaterial(".MaterialBoundingBox");*/
                pMaterial = pSubMesh.material;
                pMaterial.emissive = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.diffuse = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.ambient = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.specular = new Color(1.0, 1.0, 1.0, 1.0);

                pSubMesh.effect.addComponent("akra.system.mesh_texture");
                pSubMesh.shadow = false;
            }
            else {
                pSubMesh.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
            }

            pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
            return true;
        }

        hideBoundingBox(): bool {
            var pSubMesh: IMeshSubset = this.getSubset(".BoundingBox");

            if(!pSubMesh) {
                return false;
            }

//TODO: hide bounding box!!
            pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), false);
            return true;
        }

        isBoundingBoxVisible(): bool {
            var pSubMesh: IMeshSubset = this.getSubset(".BoundingBox");

            if(!pSubMesh) {
                return false;
            }

            return pSubMesh.data.isRenderable(pSubMesh.data.getIndexSet());
        }

        createBoundingSphere(): bool {
            var pVertexData: IVertexData;
            var pSubMesh: IMeshSubset;
            var pNewBoundingSphere: ISphere,
                pTempBoundingSphere: ISphere;
            var i:  number ;

            pNewBoundingSphere = new geometry.Sphere();
            pTempBoundingSphere = new geometry.Sphere();


            pSubMesh = this.getSubset(0);
            pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

            if(!pVertexData) {
                return false;
            }


            if(geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere) == false) {
                return false;
            }

            if (pSubMesh.isSkinned()) {
                pNewBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                pNewBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
            }

            for(i = 1; i < this.length; i++) {

                pSubMesh = this.getSubset(i);
                pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

                if(isNull(pVertexData))
                    return false;

                if(geometry.computeBoundingSphere(pVertexData, pTempBoundingSphere) == false)
                    return false;


                if (pSubMesh.isSkinned()) {
                    pTempBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                    pTempBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
// trace(pTempBoundingSphere.fRadius, '<<<');
                }


                geometry.computeGeneralizingSphere(pNewBoundingSphere, pTempBoundingSphere)
            }

            this._pBoundingSphere = pNewBoundingSphere;

            return true;
        }

        deleteBoundingSphere(): bool {
            this._pBoundingSphere = null;
            return true;
        }

        showBoundingSphere(): bool {
            var pSubMesh : IMeshSubset, pMaterial: IMaterial;
            var iData:  number ;
            var pPoints:  number [], pIndexes:  number [];

            if(!this._pBoundingSphere) {
                if (!this.createBoundingSphere()) {
                    return false;
                }
            }

            pPoints = new Array();
            pIndexes = new Array();

            geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);

            pSubMesh = this.getSubset(".BoundingSphere");

            if(!pSubMesh) {
                pSubMesh = this.createSubset(".BoundingSphere", EPrimitiveTypes.LINELIST, EHardwareBufferFlags.STATIC);

                if(isNull(pSubMesh))
                    return false;

                iData=pSubMesh.data.allocateData(
                    [VE_FLOAT3(DeclUsages.POSITION)],
                    new Float32Array(pPoints));

                pSubMesh.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));
                pSubMesh.data.index(iData, DeclUsages.INDEX0);

// pSubMesh.applyFlexMaterial(".MaterialBoundingSphere");
// //pSubMesh.getFlexMaterial(".MaterialBoundingSphere");
                pMaterial = pSubMesh.material;
                pMaterial.emissive = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.diffuse  = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.ambient  = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.specular = new Color(1.0, 1.0, 1.0, 1.0);

                pSubMesh.effect.addComponent("akra.system.mesh_texture");
                pSubMesh.shadow = false;
            }
            else {
                pSubMesh.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
            }

            pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);

            return true;
        }

        hideBoundingSphere(): bool {
            var pSubMesh: IMeshSubset;

            pSubMesh = this.getSubset(".BoundingSphere");

            if(!pSubMesh) {
                return false;
            }

            pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), false);
            return true;
        }

        isBoundingSphereVisible(): bool {
            var pSubMesh: IMeshSubset = this.getSubset(".BoundingSphere");

            if(!pSubMesh) {
                return false;
            }

            return pSubMesh.data.isRenderable(pSubMesh.data.getIndexSet());
        }

        /**@inline*/  get shadow(): bool {
            return this._bShadow;
        }

        set shadow(bValue: bool) {
            for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                this._pSubMeshes[i].shadow = bValue;
            }
        }

        toSceneModel(pParent: ISceneNode, sName: string = null): ISceneModel {
            if (isNull(pParent)) {
                return null;
            }

            var pSceneModel: ISceneModel = pParent.scene.createModel(sName);

            if (!pSceneModel.create()) {
                return null;
            }

            pSceneModel.mesh = this;
            pSceneModel.attachToParent(pParent);

            return pSceneModel;
        }

        update(): bool {
            var isOk: bool = false;

            for (var i:  number  = 0; i < this._pSkinList.length; ++ i) {
                isOk = this._pSkinList[i].applyBoneMatrices() ? true : isOk;
            }

            if(isOk){
                for (var i:  number  = 0; i < this.length; ++ i) {
                	if(this._pSubMeshes[i].isSkinned()){
                    	this._pSubMeshes[i]._calculateSkin();
                	}
                }
            }

            return isOk;
        }

        protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Mesh._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
         shadowed(pSubMesh: IMeshSubset, bShadow: bool): void {

            this._bShadow = bShadow;

            if (!bShadow) {
                for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                    if (this._pSubMeshes[i].shadow) {
                        this._bShadow = true;
                        break;
                    }
                }
            }

            this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).shadowed; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pSubMesh, bShadow) : _broadcast[i].listener (_recivier, pSubMesh, bShadow) ; } } ;
        }

	}

    export function createMesh(pEngine: IEngine, sName: string = null, eOptions:  number  = 0, pDataBuffer: IRenderDataCollection = null): IMesh {
        return new Mesh(pEngine, eOptions, sName, pDataBuffer);
    }
}










module akra.scene {
	export class SceneModel extends SceneObject implements ISceneModel {
		private _pMesh: IMesh = null;
		private _bShow: bool = true;

		/**@inline*/  get visible(): bool {
			return this._bShow;
		}

		/**@inline*/  set visible(bValue: bool) {
			this._bShow = bValue;
		}

		constructor (pScene: IScene3d) {
			super(pScene, EEntityTypes.MODEL);
		}

		/**@inline*/  get mesh(): IMesh {
			return this._pMesh;
		}

		/**@inline*/  set mesh(pMesh: IMesh) {
			if (!isNull(this._pMesh)) {
				this.accessLocalBounds().set(0.01, 0.01, 0.01);
				this._pMesh.disconnect(this.scene,  "postUpdate" ,  "update" );
				this._pMesh = null;
			}

			if (!isNull(pMesh)) {
				this.accessLocalBounds().set(pMesh.boundingBox);
				this._pMesh = pMesh;
				pMesh.connect(this.scene,  "postUpdate" ,  "update" );
			}
		}

		/**@inline*/  get totalRenderable():  number  {
			return isNull(this._pMesh) || !this._bShow? 0: this._pMesh.length;
		}

		/**@inline*/  getRenderable(i:  number  = 0): IRenderableObject {
			if(isNull(this._pMesh)){
				{ logger.setSourceLocation( "SceneModel.ts" , 52 ); logger.warning(this); } ;
			}
			return this._pMesh.getSubset(i);
		}

		/**@inline*/  get shadow(): bool {
			return this._pMesh.shadow;
		}

		/**@inline*/  set shadow(bValue) {
			this._pMesh.shadow = bValue;
		}


		/**@inline*/  isVisible(): bool {
			return this._bShow;
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {

		    if (!isRecursive) {
/* + " height: " + this.worldPosition.y*/
		        var sData: string = "<model" + (this.name? " " + this.name: "") + "(" + (isNull(this._pMesh)? 0: this._pMesh.length) + ")" +  '>'                                         ;

		        if (!isNull(this._pMesh)) {
		            sData += "( " + this._pMesh.name + " )";
		        }

		        return sData;
		    }

		    return super.toString(isRecursive, iDepth);

		}


	}
	var iUpdatedOnce:  number  = 0;

	export  /**@inline*/  function isModel(pEntity: IEntity): bool {
		return !isNull(pEntity) && pEntity.type === EEntityTypes.MODEL;
	}
}













module akra {
	;
	;
	;
	;
	;

	export interface IImageMap{
		[index: string]: IImg;
	}

	export interface ITerrainSampleData {
		iColor:  number ;
		fScale:  number ;
	}

	export interface ITerrain extends ISceneObject {
		 worldExtents: IRect3d;
		 worldSize: IVec3;
		 mapScale: IVec3;
		 sectorCountX:  number ;
		 sectorCountY:  number ;
		 sectorSize: IVec2;
		 tableWidth:  number ;
		 tableHeight:  number ;
		 sectorShift:  number ;
		 dataFactory: IRenderDataCollection;

		 maxHeight:  number ;
		 terrain2DLength:  number ;
		 megaTexture: IMegaTexture;

		manualMegaTextureInit: bool;
		showMegaTexture: bool;

		isCreate(): bool;

/**
		 * Создаем terrain
		 * @param {ISceneNode} pRootNode Узел на сцене к которому цепляется terrain.
		 * @param {IImageMap} pMap набор карт для terrain.
		 * @param {IRect3d} worldExtents Размеры terrain в мире.
		 * @param {uint} iShift Количество векторов в секторе (указывается в степенях двойки).
		 * @param {uint} iShiftX Количество секторов в terrain по оси X (указывается в степенях двойки).
		 * @param {uint} iShiftY Количество секторов в terrain по оси Y (указывается в степенях двойки).
		 * @param {string} sSurfaceTextures Название мега текстуры.
		 */

		init(pMap: IImageMap, worldExtents: IRect3d, iShift:  number , iShiftX:  number , iShiftY:  number , sSurfaceTextures: string, pRootNode?: ISceneNode): bool;
		initMegaTexture(sSurfaceTextures?: string): void;
/**
		 * Ищет секцию по координате
		 */

		findSection(iX:  number , iY:  number );
/**
		 * Возвращает высоту terrain в заданной точке.
		 */

		readWorldHeight(iIndex:  number ):  number ;
		readWorldHeight(iMapX:  number , iMapY:  number ):  number ;

		readWorldNormal(v3fNormal: IVec3, iMapX:  number , iMapY:  number ): IVec3;

		projectPoint(v3fCoord: IVec3, v3fDestenation: IVec3): bool;
/**
		 * Destructor
		 */

		destroy(): void;
/**
		 * Сброс параметров.
		 */

		reset(): void;

		_tableIndex(iMapX:  number , iMapY:  number ):  number ;
		_useVertexNormal(): bool;
	}
}






























module akra.render {
	export interface IIndexSet {
		sName: string;
		pMap: IBufferMap;
		pIndexData: IBufferData;
		pAttribData: IVertexData;
		pI2IDataCache: IntMap;
		pAdditionCache: IntMap;
	};

	export class RenderData extends util.ReferenceCounter implements IRenderData {
/**
		 * Options.
		 */

		private _eOptions:  number  = 0;
/**
		 * Buffer, that create this class.
		 */

		private _pBuffer: IRenderDataCollection = null;
/**
		 * ID of this data.
		 */

		private _iId:  number  = -1;
/**
		 * Buffer with indices.
	     * If the data is the simplest mesh, with no more
	     * than one index, the type will be IndexBuffer,
	     * otherwise VertexBuffer.
	     */

		private _pIndexBuffer: IHardwareBuffer = null;
/**
		 * Buffer with attributes.
		 */

		private _pAttribBuffer: IVertexBuffer = null;
/**
	      * Data with indices.
	      * If _pIndexBuffer has type IndexBuffer, indices data
	      * has type IndexData, otherwise VertexData.
	      */

		private _pIndexData: IBufferData = null;
/**
	     * Data with attributes.
	     */

		private _pAttribData: IVertexData = null;
/**
	     * Buffer map for current index set.
	     */

		private _pMap: IBufferMap = null;
/**
	     * Buffer maps of all index sets.
	     */

		private _pIndicesArray: IIndexSet[] = [];
/**
	     * Current index set.
	     */

		private _iIndexSet:  number  = 0;
		private _iRenderable:  number  = 1;

        private _pComposer: IAFXComposer = null;


		/**@inline*/  get buffer(): IRenderDataCollection {
			return this._pBuffer;
		}

		/**@inline*/  private get indexSet(): IIndexSet {
			return this._pIndicesArray[this._iIndexSet];
		}

		constructor(pCollection: IRenderDataCollection = null) {
			super();
			this._pBuffer = pCollection;
            this._pComposer = pCollection.getEngine().getComposer();
		}

/**
		 * Allocate data for rendering.
		 */

        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBuffer, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBufferView, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, hasIndex: bool = true):  number ;
        allocateData(pDecl: any, pData: any, hasIndex: bool = true):  number {
        	var pDataDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);
        	var eType: ERenderDataTypes = ERenderDataTypes.INDEXED;

		    if (!hasIndex || this.useSingleIndex()) {
		        eType = ERenderDataTypes.DIRECT;
		    }
		    else if (this.useAdvancedIndex()) {
		        eType = ERenderDataTypes.I2I;
		    }

		    return this._allocateData(pDataDecl, pData, eType);
        }

/**
         * Remove data from this render data.
         */

        releaseData(iDataLocation:  number ): void {
//TODO: release data.
        }

/**
		 * Allocate attribute.
		 * Attribute - data without index.
		 */

        allocateAttribute(pDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
        allocateAttribute(pDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateAttribute(pDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
        allocateAttribute(pDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
        allocateAttribute(pDecl: any, pData: any): bool {
            var pAttrDecl: IVertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);
        	var pIndexData = this._pIndexData;
		    var pAttribData: IVertexData = this._pAttribData;
		    var pAttribBuffer: IVertexBuffer = this._pAttribBuffer;
		    var pBuffer: IRenderDataCollection = this._pBuffer;

		    if (!pAttribData) {
		        if (!pAttribBuffer) {
		            pAttribBuffer = pBuffer.getEngine().getResourceManager().createVertexBuffer('render_data_attrs_' + sid());
		            pAttribBuffer.create((<ArrayBufferView>pData).byteLength, EHardwareBufferFlags.BACKUP_COPY);
		            this._pAttribBuffer = pAttribBuffer;
		        }

		        this._pAttribData = this._pAttribBuffer.allocateData(pAttrDecl, pData);
		        this._pIndicesArray[this._iIndexSet].pAttribData = this._pAttribData;
		        this._pMap.flow(this._pAttribData);
		        return this._pAttribData !== null;
		    }

		    if (!pAttribData.extend(pAttrDecl, pData)) {
		        { logger.setSourceLocation( "RenderData.ts" , 142 ); logger.log('invalid data for allocation:', arguments); } ;
		        { logger.setSourceLocation( "RenderData.ts" , 143 ); logger.warning('cannot allocate attribute in data subset..'); } ;
		        return false;
		    }

		    return true;
        }

/**
		 * Allocate index.
		 */

		allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		allocateIndex(pDecl: any, pData: any): bool{
			var pAttrDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);

			if (this.useAdvancedIndex()) {
		        return this._allocateAdvancedIndex(pAttrDecl, pData);
		    }
		    return this._allocateIndex(pAttrDecl, pData);
		}

		getAdvancedIndexData(sSemantics: string): IVertexData {
			return this._getData(sSemantics, true);
		}

/**
		 * Add new set of indices.
		 */

        addIndexSet(usePreviousDataSet: bool = true, ePrimType:EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST, sName: string = null):  number  {

// if (this._pIndexData === null) {
//     return false;
// }


        	if (usePreviousDataSet) {
        	    this._pMap = this._pMap.clone(false);

        	    if (!this._pMap) {
                    { logger.setSourceLocation( "RenderData.ts" , 184 ); logger.warning("could not clone buffer map"); } ;
        	        return -1;
        	    }
        	}
        	else {
        	    this._pMap = this._pBuffer.getEngine().createBufferMap();
        	    this._pAttribData = null;
        	}

        	this._pMap.primType = ePrimType;
        	this._pIndexData = null;
        	this._iIndexSet = this._pIndicesArray.length;
        	this._pIndicesArray.push({
        	                             pMap        	: this._pMap,
        	                             pIndexData  	: this._pIndexData,
        	                             pAttribData 	: this._pAttribData,
        	                             sName       	: sName,
        	                             pI2IDataCache	: <IntMap> null,
										 pAdditionCache	: <IntMap> null
        	                         });

        	return  this._iIndexSet;
        }

        getNumIndexSet():  number  {
        	return this._pIndicesArray.length;
        }

        getIndexSetName(iSet:  number  = this._iIndexSet): string {
        	return this._pIndicesArray[iSet].sName;
        }

/**
         * Select set of indices.
         */

        selectIndexSet(iSet:  number ): bool;
        selectIndexSet(sName: string): bool;
        selectIndexSet(a): bool {
        	var iSet:  number  = -1;

        	if (isString(arguments[0])) {
        		iSet = this.findIndexSet(arguments[0]);

        		if (iSet < 0) {
        			return false;
        		}
        	}
            else{
                iSet = arguments[0];
            }

        	var pIndexSet = this._pIndicesArray[iSet];

        	if (pIndexSet) {
        	    this._pMap = pIndexSet.pMap;
        	    this._pIndexData = pIndexSet.pIndexData;
        	    this._pAttribData = pIndexSet.pAttribData;
        	    this._iIndexSet = iSet;
        	    return true;
        	}

        	return false;
        }

        findIndexSet(sName: string):  number  {
            for (var i:  number  = 0; i < this._pIndicesArray.length; ++ i) {
                if (this._pIndicesArray[i].sName === <string>sName) {
                    return i;
                }
            }

            return -1;
        }

/**
         * Get number of current index set.
         */

        getIndexSet():  number  {
        	return this._iIndexSet;
        }

        /**@inline*/  hasAttributes(): bool {
            return !isNull(this._pAttribData);
        }

/**
		 * Specifies uses advanced index.
		 */

        useAdvancedIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.ADVANCED_INDEX) != 0;
        }

        useSingleIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.SINGLE_INDEX) != 0;
        }

        useMultiIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.SINGLE_INDEX) == 0;
        }

        setRenderable(bValue: bool): void;
        setRenderable(iIndexSet:  number , bValue: bool): void;
        setRenderable(iIndexSet: any, bValue?: bool = true): void {
        	if (arguments.length < 2) {
//mark all render data as renderable or not
        		if (<bool>arguments[0]) {
        			((this._eOptions) |= (ERenderDataOptions.RENDERABLE))
        		}
        		else {
        			((this._eOptions) &= ~(ERenderDataOptions.RENDERABLE)) ;
        		}
        	}

//mark index set is renderable or not
        	(bValue ? ((this._iRenderable) |= (1 << ((< number >iIndexSet))) ) : ((this._iRenderable) &= ~ (1 << ((< number >iIndexSet))) ) ) ;
        }

        isRenderable(): bool;
        isRenderable(iIndexSet:  number ): bool;
        isRenderable(iIndexSet?:  number ): bool {
        	if (arguments.length > 0) {
//is this index set renderable ?
        		return  ((this._iRenderable & (1 << (iIndexSet)) ) != 0) ;
        	}

//is this data renderable ?
        	return this._eOptions & ERenderDataOptions.RENDERABLE ? true : false;
        }

/**
         * Check whether the semantics used in this data set.
         */

        hasSemantics(sSemantics: string, bSearchComplete: bool = true): bool {
        	return this._getFlow(sSemantics, bSearchComplete) !== null;
        }

/**
         * Get data location.
         */

        getDataLocation(sSemantics: string):  number ;
        getDataLocation(iDataLocation:  number ):  number ;
        getDataLocation(sSemantics?):  number  {
        	var pData: IVertexData = this._getData(<string>sSemantics);

        	return pData ? pData.byteOffset : -1;
        }

/**
         * Get indices that uses in current index set.
         */

        getIndices(): IBufferData {
        	return this._pIndexData;
        }

        getIndexFor(sSemantics: string): ArrayBufferView;
        getIndexFor(iDataLocation:  number ): ArrayBufferView;
        getIndexFor(sSemantics?): ArrayBufferView {
            var pFlow: IDataFlow = this._getFlow(<string>sSemantics);

            if (!isNull(pFlow.mapper)) {
                return pFlow.mapper.data.getTypedData(pFlow.mapper.semantics);
            }

            return null;
        }

/**
         * Get number of primitives for rendering.
         */

        /**@inline*/  getPrimitiveCount():  number  {
        	return this._pMap.primCount;
        }

        /**@inline*/  getPrimitiveType(): EPrimitiveTypes {
            return this._pMap.primType;
        }

/**
         * Setup index.
         */

        index(sData: string, sSemantics: string, useSame?: bool, iBeginWith?:  number , bForceUsage?: bool): bool;
        index(iData:  number , sSemantics: string, useSame?: bool, iBeginWith?:  number , bForceUsage?: bool): bool;
        index(data: any, sSemantics: string, useSame: bool = false, iBeginWith:  number  = 0, bForceUsage?: bool = false): bool {
            var iData:  number  = isNumber(arguments[0]) ? arguments[0] : 0;
        	var iFlow:  number  = -1;
        	var iAddition:  number , iRealAddition:  number , iPrevAddition:  number ;
        	var pFlow: IDataFlow;
        	var pData: IVertexData, pRealData: IVertexData;
        	var pFloat32Array: Float32Array;
        	var iIndexOffset:  number ;
        	var pIndexData: IBufferData = this._pIndexData;
        	var sData: string;
        	var iStride:  number ;
        	var iTypeSize:  number  = EDataTypeSizes.BYTES_PER_FLOAT;

        	if (this.useAdvancedIndex()) {
        	    pRealData = this._getData(<string>arguments[0]);
        	    iAddition = pRealData.byteOffset;
        	    iStride = pRealData.stride;
//индекс, который подал юзер
        	    pData = this._getData(sSemantics, true);

        	    pData.applyModifier(sSemantics, function (pTypedData: Float32Array) {
        	        for (var i:  number  = 0; i < pTypedData.length; i++) {
        	            pTypedData[i] = (pTypedData[i] * iStride + iAddition) / iTypeSize;
        	        }
        	    });

        	    iData = pData.byteOffset;
        	    sSemantics = "INDEX_" + sSemantics;
        	}
        	else if (isString(arguments[0])) {
        	    if (arguments[0] === "TEXCOORD") {
        	        iData = this.getDataLocation("TEXCOORD0");
        	    }
        	    else {
        	    	iData = this.getDataLocation(<string>arguments[0]);
        		}

        	    { logger.setSourceLocation( "RenderData.ts" , 403 ); logger.assert(iData >= 0, "cannot find data with semantics: " + arguments[0]); } ;
        	}

            pFlow = this._getFlow(iData);

        	if (pFlow === null) {
//поищем эти данные в общем буфере
                pData = this.buffer.getData(iData);

                if (isNull(pData)) {
                    { logger.setSourceLocation( "RenderData.ts" , 413 ); logger.warning("Could not find data flow <" + iData + "> int buffer map: " + this._pMap.toString(true)); } ;
                    return false;
                }
//все ок, данные найдены, зарегистрируем их у себя в мапе
                { logger.setSourceLocation( "RenderData.ts" , 417 ); logger.assert(this._addData(pData) !== -1, "could not add automatcly add data to map"); } ;
                pFlow = this._getFlow(iData);
        	}

        	iFlow = pFlow.flow;
        	iIndexOffset = (<IVertexData>pIndexData).getVertexDeclaration().findElement(sSemantics).offset;
        	pFloat32Array = <Float32Array>(<IVertexData>pIndexData).getTypedData(sSemantics);
        	iAddition = iData;

        	if (!pFloat32Array) {
        	    return false;
        	}


        	iStride = pFlow.data.stride;

        	if (this.indexSet.pAdditionCache[iIndexOffset] !== iAddition && !bForceUsage) {
        	    if (!useSame) {
        	        iPrevAddition = this.indexSet.pAdditionCache[iIndexOffset] || 0;
        	        iRealAddition = iAddition - iPrevAddition;

        	        for (var i = 0; i < pFloat32Array.length; i++) {
        	            pFloat32Array[i] = (pFloat32Array[i] * iStride + iRealAddition) / iTypeSize;
        	        }

        	    }
        	    else {
        	        iRealAddition = iAddition;
        	        for (var i = 0; i < pFloat32Array.length; i++) {
        	            pFloat32Array[i] = (iBeginWith + iRealAddition) / iTypeSize;
        	        }

        	    }

//remeber addition, that we added to index.
        	    this.indexSet.pAdditionCache[iIndexOffset] = iAddition;

        	    if (!(<IVertexData>pIndexData).setData(pFloat32Array, sSemantics)) {
        	        return false;
        	    }
        	}

        	return this._pMap.mapping(iFlow, <IVertexData>pIndexData, sSemantics);
        }


/*Setup.*/

		_setup(pCollection: IRenderDataCollection, iId:  number , ePrimType: EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST, eOptions:  number  = 0): bool {
			if (this._pBuffer === null && arguments.length < 2) {
		        return false;
		    }

		    this.setRenderable(true);

		    this._eOptions |= eOptions;
		    this._pBuffer = pCollection;
		    this._iId = iId;

//setup buffer map
		    this._pMap = pCollection.getEngine().createBufferMap();
		    this._pMap.primType = ePrimType;

//setup default index set
		    this._pIndicesArray.push({
		                                 sName       	: ".main",
		                                 pMap        	: <IBufferMap>this._pMap,
		                                 pIndexData  	: <IBufferData>null,
		                                 pAttribData 	: <IVertexData>null,
		                                 pI2IDataCache	: <IntMap>{},
		                                 pAdditionCache : <IntMap>null
		                             });

		    { logger.setSourceLocation( "RenderData.ts" , 489 ); logger.assert(this.useSingleIndex() === false, "single indexed data not implimented"); } ;

		    return true;
		}


        private _allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, eType: ERenderDataTypes):  number ;
        private _allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, eType: ERenderDataTypes):  number ;
        private _allocateData(pDataDecl: IVertexDeclaration, pData: any, eType: ERenderDataTypes):  number  {
        	if (eType === ERenderDataTypes.DIRECT) {
		        return this.allocateAttribute(pDataDecl, pData)? 0: -1;
		    }

		    var iFlow:  number ;
		    var pVertexData: IVertexData = this._pBuffer._allocateData(pDataDecl, pData);
		    var iOffset:  number  = pVertexData.byteOffset;

		    iFlow = this._addData(pVertexData, undefined, eType);

		    if (iFlow < 0) {
		        { logger.setSourceLocation( "RenderData.ts" , 509 ); logger.log("invalid data", pDataDecl, pData); } ;
		        { logger.setSourceLocation( "RenderData.ts" , 510 ); logger.error("cannot allocate data for submesh"); } ;
		        return -1;
		    }

		    return iOffset;
        }

/**
		 * Add vertex data to this render data.
		 */

        _addData(pVertexData: IVertexData, iFlow?:  number , eType: ERenderDataTypes = ERenderDataTypes.DIRECT):  number  {

		    if ((arguments.length < 3 && this.useAdvancedIndex()) ||
		        arguments[2] === ERenderDataTypes.I2I) {
		        return this._registerData(pVertexData);
		    }

		    return (!isDef(iFlow) ? this._pMap.flow(pVertexData) :
		            this._pMap.flow(iFlow, pVertexData));
		}

/**
		 * Register data in this render.
		 * Necessary for index to index mode, when data realy
		 * not using in this render data for building final buffer map.
		 */

		private _registerData(pVertexData: IVertexData):  number  {
		    'use strict';
		    var iOffset:  number  = pVertexData.byteOffset;
		    var pDataDecl: data.VertexDeclaration = <data.VertexDeclaration>pVertexData.getVertexDeclaration();

//необходимо запоминать расположение данных, которые подаются,
//т.к. иначе их потом нельзя будет найти среди других данных
		    for (var i:  number  = 0; i < pDataDecl.length; i++) {
		        this.indexSet.pI2IDataCache[pDataDecl.element(i).usage] = iOffset;
		    }


		    return 0;
		};


/**
		 * Allocate advanced index.
		 */

		 private _allocateAdvancedIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		 private _allocateAdvancedIndex(pAttrDecl: any, pData: any): bool {

		    var pDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pAttrDecl);
		    var nCount:  number  = pData.byteLength / pDecl.stride;
//TODO: remove index dublicates
		    var iIndLoc:  number  = this._allocateData(pAttrDecl, pData, ERenderDataTypes.INDEXED);
		    var pI2IData: Float32Array = new Float32Array(nCount);
		    var pI2IDecl: IVertexElementInterface[] = [];

		    for (var i:  number  = 0; i < pDecl.length; i++) {
		        pI2IDecl.push(VE_FLOAT('INDEX_' + pDecl.element(i).usage, 0));
		    }


		    for (var i:  number  = 0; i < pI2IData.length; i++) {
		        pI2IData[i] = i;
		    }


		    if (!this._allocateIndex(pI2IDecl, pI2IData)) {
		        this.releaseData(iIndLoc);
		        pI2IData = null;
		        pI2IDecl = null;
		        { logger.setSourceLocation( "RenderData.ts" , 582 ); logger.warning('cannot allocate index for index in render data subset'); } ;
		        return false;
		    }

		    return true;
		};



/**
		 * Create IndexBuffer/IndexData for storage indices.
		 */

		private _createIndex(pAttrDecl: IVertexDeclaration, pData:ArrayBuffer): bool;
		private _createIndex(pAttrDecl: IVertexDeclaration, pData:ArrayBufferView): bool;
		private _createIndex(pAttrDecl: IVertexDeclaration, pData:any): bool{
		    'use strict';

		    if (!this._pIndexBuffer) {
		        if (this.useMultiIndex()) {
		            this._pIndexBuffer = this._pBuffer.getEngine().getResourceManager().createVertexBuffer('subset_' + sid());
		            this._pIndexBuffer.create(((<ArrayBufferView>pData).byteLength), < number >EHardwareBufferFlags.BACKUP_COPY);
		        }
		        else {
//TODO: add support for sinle indexed mesh.
		        }
		    }

		    this._pIndexData = (<IVertexBuffer>this._pIndexBuffer).allocateData(pAttrDecl, pData);
		    this.indexSet.pIndexData = this._pIndexData;
		    this.indexSet.pAdditionCache = <IntMap>{};
		    return this._pIndexData !== null;
		};

/**
		 * Allocate index.
		 */

		private _allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		private _allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		private _allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		private _allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		private _allocateIndex(pDecl: any, pData: any): bool {
		    'use strict';
            var pAttrDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]> pDecl);

		    var pIndexData: IBufferData = this._pIndexData;
		    var pIndexBuffer: IHardwareBuffer = this._pIndexBuffer;
		    var pBuffer: IRenderDataCollection = this._pBuffer;


		    for (var i:  number  = 0; i < pAttrDecl.length; i++) {
		        if (pAttrDecl.element(i).type !== EDataTypes.FLOAT) {
		            return false;
		        }
		    }


		    if (!this._pIndexData) {
		        return this._createIndex(pAttrDecl, pData);
		    }

		    if (!(<IVertexData>this._pIndexData).extend(pAttrDecl, pData)) {
		        { logger.setSourceLocation( "RenderData.ts" , 643 ); logger.log('invalid data for allocation:', arguments); } ;
		        { logger.setSourceLocation( "RenderData.ts" , 644 ); logger.warning('cannot allocate index in data subset..'); } ;
		        return false;
		    }

		    return true;
		};


		_setIndexLength(iLength:  number ): bool {
			var bResult: bool = (<IVertexData>this._pIndexData).resize(iLength);

			if(bResult) {
				this._pMap._length = iLength;
			}

			return bResult;
		}


/**
         * Get data flow by semantics or data location.
         */

        _getFlow(iDataLocation:  number ): IDataFlow;
        _getFlow(sSemantics: string, bSearchComplete?: bool): IDataFlow;
        _getFlow(a, b?): IDataFlow {
        	if (typeof arguments[0] === 'string') {
		        return this._pMap.getFlow(arguments[0], arguments[1]);
		    }

		    for (var i:  number  = 0, n = this._pMap.limit; i < n; ++i) {
		        var pFlow = this._pMap.getFlow(i, false);

		        if (pFlow.data && pFlow.data.byteOffset === arguments[0]) {
		            return pFlow;
		        }
		    }

		    return null;
        }

/**
         * Get data by semantics or location.
         */

        _getData(iDataLocation:  number , bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(sSemanticsn: string, bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(a, b?): IVertexData {
        	var pFlow: IDataFlow;

        	if (this.useAdvancedIndex() && arguments.length < 2) {
        	    if (typeof arguments[0] === 'string') {
        	        return this._getData(this.indexSet.pI2IDataCache[arguments[0]]);
        	    }

        	    return this._pBuffer.getData(<string>arguments[0]);
        	}

        	if (typeof arguments[0] === 'string') {
        	    for (var i = 0, n = this._pMap.limit; i < n; ++i) {
        	        pFlow = this._pMap.getFlow(i, false);
        	        if (pFlow.data != null && pFlow.data.hasSemantics(arguments[0])) {
        	            return pFlow.data;
        	        }
        	    }

//this._pBuffer._getData(arguments[0]);        	    return null;
        	}

        	pFlow = this._getFlow(arguments[0]);
        	return pFlow === null ? null : pFlow.data;
        }



/**
         * Draw this data.
         */

        _draw(pTechnique: IRenderTechnique, pViewport: IViewport,
              pRenderable: IRenderableObject, pSceneObject: ISceneObject): void {
        	for (var i:  number  = 0; i < this._pIndicesArray.length; i++) {
        	    if (this.isRenderable(i)) {
//this._pIndicesArray[i].pMap._draw();
                    this._pComposer.applyBufferMap(this._pIndicesArray[i].pMap);
                    pTechnique._renderTechnique(pViewport, pRenderable, pSceneObject);
        	    }
        	}
        }

//applyMe(): bool;

        toString(): string {
        	var s: string;
        	s = "\nRENDER DATA SUBSET: #" + this._iId + "\n";
        	s += "        ATTRIBUTES: " + (this._pAttribData ? "TRUE" : "FALSE") + "\n";
        	s += "----------------------------------------------------------------\n";
        	s += this._pMap.toString();

        	return s;
        }
	}
}





module akra.render {

	export class RenderDataCollection extends util.ReferenceCounter implements IRenderDataCollection {
		private _pDataBuffer: IVertexBuffer = null;
		private _pEngine: IEngine = null;
		private _eDataOptions: ERenderDataBufferOptions = 0;
		private _pDataArray: IRenderData[] = [];

		/**@inline*/  get buffer(): IVertexBuffer {
			return this._pDataBuffer;
		}

        /**@inline*/  get length():  number  {
            return this._pDataArray.length;
        }

        /**@inline*/  get byteLength():  number  {
            return this._pDataBuffer.byteLength;
        }


        constructor (pEngine: IEngine, eOptions: ERenderDataBufferOptions = 0) {
            super();
            this._pEngine = pEngine;
            this.setup(eOptions);
        }

        clone(pSrc: IRenderDataCollection): bool {
            { logger.setSourceLocation( "render/RenderDataCollection.ts" , 37 ); logger.criticalError("TODO: RenderDataCollection::clone();"); } ;

            return false;
        }

        getEngine(): IEngine {
        	return this._pEngine;
        }

        getOptions(): ERenderDataBufferOptions {
        	return this._eDataOptions;
        }

/**
         * Find VertexData with given semantics/usage.
         */

        getData(sUsage: string): IVertexData;
        getData(iOffset:  number ): IVertexData;
        getData(a?): IVertexData {
        	var pBuffer: IVertexBuffer = this._pDataBuffer;
            var pData: IVertexData;
            var n:  number ;

        	if (!isNull(pBuffer)) {
        	    n = this._pDataBuffer.length;

        	    if (isString(arguments[0])) {
        	        for (var i:  number  = 0; i < n; i++) {
                        pData = pBuffer.getVertexData(i);
        	            if (pData.hasSemantics(<string>arguments[0])) {
        	                return pData;
        	            }
        	        };
        	    }
        	    else {
        	        for (var i:  number  = 0; i < n; i++) {
                        pData = pBuffer.getVertexData(i);
        	            if (pData.byteOffset === < number >arguments[0]) {
        	                return pData;
        	            }
        	        };
        	    }
        	}

        	return null;
        }

/**
         * Положить данные в буфер.
         */

        _allocateData(pVertexDecl: IVertexDeclaration, iSize:  number ): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBuffer): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], iSize:  number ): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer): IVertexData;
        _allocateData(pDecl, pData) {
        	if (!this._pDataBuffer) {
        	    this.createDataBuffer();
        	}

        	var pVertexDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);
        	var pVertexData: IVertexData;

        	if ((arguments.length < 2) || isNumber(arguments[1]) || isNull(arguments[1])) {
        	    pVertexData = this._pDataBuffer.getEmptyVertexData(< number >pData || 1, pVertexDecl);
        	}
        	else {
        	    pVertexData = this._pDataBuffer.allocateData(pVertexDecl, <ArrayBufferView>pData);
        	}

        	{ logger.setSourceLocation( "render/RenderDataCollection.ts" , 108 ); logger.assert(pVertexData !== null, "cannot allocate data:\n" + pVertexDecl.toString()); } ;

        	return pVertexData;
        }

        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, isCommon: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, isCommon: bool = true):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView, isCommon: bool = true):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer, isCommon: bool = true):  number ;

        allocateData(pDecl?, pData?, isCommon: bool = true):  number  {
        	    var pVertexData: IVertexData;
        	    var pDataDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);



        	    for (var i:  number  = 0; i < pDataDecl.length; i++) {
        	        if (this.getData(pDataDecl.element(i).usage) !== null && pDataDecl.element(i).count !== 0) {
        	            { logger.setSourceLocation( "render/RenderDataCollection.ts" , 127 ); logger.warning("data buffer already contains data with similar vertex decloration <" + pDataDecl.element(i).usage + ">."); }
                                                           ;
        	        }
        	    };



        	    pVertexData = this._allocateData(pDataDecl, <ArrayBufferView>pData);

        	    if (isCommon) {
        	        for (var i:  number  = 0; i < this._pDataArray.length; ++ i) {
        	            this._pDataArray[i]._addData(pVertexData);
        	        }
        	    }

        	    return pVertexData.byteOffset;
        }

        getDataLocation(sSemantics: string):  number  {
        	if (this._pDataBuffer) {
        	    var pData: IVertexData;

        	    for (var i:  number  = 0, n:  number  = this._pDataBuffer.length; i < n; i++) {
                    pData = this._pDataBuffer.getVertexData(i);
        	        if (pData.hasSemantics(sSemantics)) {
        	            return pData.byteOffset;
        	        }
        	    };
        	}

        	return -1;
        }

        private createDataBuffer() {
//TODO: add support for eOptions
            var iVbOption:  number  = 0;
            var eOptions: ERenderDataBufferOptions = this._eDataOptions;

            if (eOptions & ERenderDataBufferOptions.VB_READABLE) {
                iVbOption = ERenderDataBufferOptions.VB_READABLE;
            }

//trace('creating new video buffer for render data buffer ...');
            this._pDataBuffer = this._pEngine.getResourceManager().createVideoBuffer("render_data_buffer" + "_" + sid());
            this._pDataBuffer.create(0, iVbOption);
            this._pDataBuffer.addRef();
            return this._pDataBuffer !== null;
        };

        getRenderData(iSubset:  number ): IRenderData {
        	return this._pDataArray[iSubset];
        }

        getEmptyRenderData(ePrimType: EPrimitiveTypes, eOptions: ERenderDataBufferOptions = 0): IRenderData {

        	var iSubsetId:  number  = this._pDataArray.length;
        	var pDataset: IRenderData = new RenderData(this);

        	eOptions |= this._eDataOptions;

        	if (!pDataset._setup(this, iSubsetId, ePrimType, eOptions)) {
        	    { logger.setSourceLocation( "render/RenderDataCollection.ts" , 187 ); logger.error("cannot setup submesh..."); } ;
        	}


        	this._pDataArray.push(pDataset);

        	return pDataset;
        }

        _draw(): void;
        _draw(iSubset?:  number ): void {
// if (arguments.length > 0) {
//     this._pDataArray[iSubset]._draw();
// }

// for (var i: int = 0; i < this._pDataArray.length; i++) {
//     this._pDataArray[i]._draw();
// };
            { logger.setSourceLocation( "render/RenderDataCollection.ts" , 205 ); logger.criticalError("TODO"); } ;
        }

        destroy(): void {
        	this._pDataArray = null

            if (this._pDataBuffer) {
// this._pDataBuffer.release();
                this._pDataBuffer.destroy();
                this._pDataBuffer = null;
            }

            this._pEngine = null;
            this._eDataOptions = 0;
        }

        private setup(eOptions: ERenderDataBufferOptions = 0) {
            this._eDataOptions = eOptions;
        };

// inline isValid(): bool { return true; }
// inline isDynamic(): bool { return false; }
// inline isStatic(): bool { return false; }
// inline isStream(): bool { return false; }
// inline isReadable(): bool { return true; }
// inline isBackupPresent(): bool { return true; }

	}

    export function createRenderDataCollection(pEngine: IEngine, eOptions: ERenderDataBufferOptions = 0): IRenderDataCollection {
        return new RenderDataCollection(pEngine, eOptions);
    }
}












module akra {
	;
	;
	;
	;
	;

	export interface IMegaTexture extends IEventProvider {
		manualMinLevelLoad: bool;

		init(pObject: ISceneObject, sSurfaceTextures: string): void;
		prepareForRender(pViewport: IViewport): void;
		applyForRender(pRenderPass: IRenderPass): void;

		getWidthOrig(iLevel:  number ):  number ;
		getHeightOrig(iLevel:  number ):  number ;

		setMinLevelTexture(pImg: IImg);
	}
}


















module akra {
	export enum ERPCPacketTypes {
        FAILURE,
        REQUEST,
        RESPONSE
    }

    export interface IRPCCallback {
        n:  number ;
        fn: Function;
        timestamp:  number ;
        procInfo?: string;
    }

	export interface IRPCPacket {
        n:  number ;
        type: ERPCPacketTypes;
        next: IRPCPacket;
    }

    export interface IRPCRequest extends IRPCPacket {
        proc: string;
        argv: any[];
//ms - life time
        lt:  number ;
        pr:  number ;
    }

    export interface IRPCResponse extends IRPCPacket  {
//procedure result
        res: any;
    }

    export interface IRPCProcOptions {
//-1 - unknown, 0 - immortal
        lifeTime?:  number ;
        priority?:  number ;
    }

    export interface IRPCProcOptionsMap {
        [proc: string]: IRPCProcOptions;
    }

    export interface IRPCError extends Error {
        code:  number ;
    }

    export interface IRPCOptions {
        addr?: string;
/* -1 - unlimited */
        deferredCallsLimit?:  number ;
/* -1 - unlimited */
        maxCallbacksCount?:  number ;
/* -1 - never */
        reconnectTimeout?:  number ;
/* -1 - never*/
        systemRoutineInterval?:  number ;
/* 0 - immortal */
        callbackLifetime?:  number ;
/* имя процедуры, для получения все поддерживаемых процедур */
        procListName?: string;
/* 0 or -1 - disable group calls */
        callsFrequency?:  number ;
/* контекст, у которого будут вызываться методы, при получении REQUEST запросов со стороны сервера */
        context?: any;
        procMap?: IRPCProcOptionsMap;

    }

	export interface IRPC extends IEventProvider {
		options: IRPCOptions;
        remote: any;
        group:  number ;

		join(sAddr?: string): void;
		rejoin(): void;
		free(): void;
        detach(): void;
		proc(...argv: any[]): bool;

		parse(pResponse: IRPCResponse): void;
		parseBinary(pData: Uint8Array): void;

        groupCall():  number ;
        dropGroupCall():  number ;

        setProcedureOption(sProc: string, sOpt: string, pValue: any): void;

		 joined(): void;
         error(pError: Error): void;

        _createRequest(): IRPCRequest;
        _releaseRequest(pReq: IRPCRequest): void;

        _createCallback(): IRPCCallback;
        _releaseCallback(pCallback: IRPCCallback): void;


        _startRoutines(): void;
        _stopRoutines(): void;
        _removeExpiredCallbacks(): void;
	}
}














module akra {
	export enum EPipeTypes {
		UNKNOWN,

/** Connect to websocket. */
		WEBSOCKET,
/** Connect to webworker. */
		WEBWORKER
	}

	export enum EPipeDataTypes {
		BINARY,
		STRING
	}

	export interface IPipe extends IEventProvider {
		 uri: IURI;

		open(pAddr?: IURI): bool;
		open(sAddr?: string): bool;
		close(): void;

		write(sValue: string): bool;
		write(pValue: Object): bool;
		write(pValue: ArrayBuffer): bool;
		write(pValue: ArrayBufferView): bool;

		isOpened(): bool;
		isCreated(): bool;
		isClosed(): bool;

		 opened(pEvent: Event): void;
		 error(pErr: ErrorEvent): void;
		 closed(pEvent: CloseEvent): void;
		 message(pData: any, eType: EPipeDataTypes): void;
	}
}








module akra.net {
	export  /**@const*/var  WEBSOCKET_PORT = 1337;

	interface IVirualDescriptor {
		onmessage: (pMessage: any) => void;
		onerror: (pErr: ErrorEvent) => void;
		onclose: (pEvent: CloseEvent) => void;
		onopen: (pEvent: Event) => void;
	}

	class Pipe implements IPipe {
		protected _pAddr: IURI = null;
/** Number of sended messages.*/
		protected _nMesg:  number  = 0;
		protected _eType: EPipeTypes = EPipeTypes.UNKNOWN;
		protected _pConnect: IVirualDescriptor = null;
		protected _bSetupComplete: bool = false;

		/**@inline*/  get uri(): IURI {
			return path.uri(this._pAddr.toString());
		}

		constructor (sAddr: string = null) {
			if (!isNull(sAddr)) {
				this.open(sAddr);
			}
		}

		open(pAddr?: IURI): bool;
		open(sAddr?: string): bool;
		open(sAddr: any = null): bool {
			var pAddr: IURI;
			var eType: EPipeTypes;
			var pSocket: WebSocket = null;
			var pWorker: Worker = null;
			var pPipe: IPipe = this;

			if (!isNull(sAddr)) {
				pAddr = path.uri(<string>sAddr);
			}
			else {
				if (this.isCreated()) {
					this.close();
				}

				pAddr = this.uri;
			}

// pipe to websocket
			if (pAddr.protocol.toLowerCase() === "ws") {
//unknown port
				if (!(pAddr.port > 0)) {
					pAddr.port = WEBSOCKET_PORT;
				}

//websocket unsupported
				if (!isDefAndNotNull(WebSocket)) {
					{ logger.setSourceLocation( "Pipe.ts" , 64 ); logger.error("Your browser does not support websocket api."); } ;
					return false;
				}

				pSocket = new WebSocket(pAddr.toString());


				pSocket.binaryType = "arraybuffer";
				eType = EPipeTypes.WEBSOCKET;
			}
			else if (path.info(pAddr.path).ext.toLowerCase() === "js") {
				if (!isDefAndNotNull(Worker)) {
					{ logger.setSourceLocation( "Pipe.ts" , 76 ); logger.error("Your browser does not support webworker api."); } ;
					return false;
				}

				pWorker = new Worker(pAddr.toString());
				eType = EPipeTypes.WEBWORKER;
			}
			else {
				{ logger.setSourceLocation( "Pipe.ts" , 84 ); logger.error("Pipe supported only websockets/webworkers."); } ;
				return false;
			}

			this._pConnect = pWorker || pSocket;
			this._pAddr = pAddr;
			this._eType = eType;

			if (isDefAndNotNull(window)) {
				window.onunload = function (): void {
					pPipe.close();
				}
			}

			if (!isNull(this._pConnect)) {
				this.setupConnect();

				return true;
			}

			return false;
		}

		private setupConnect(): void {
			var pConnect: IVirualDescriptor = this._pConnect;
			var pPipe: IPipe = this;
			var pAddr: IURI = this._pAddr;

			if (this._bSetupComplete) {
				return;
			}

			pConnect.onmessage = function (pMessage: any): void {
				if (isArrayBuffer(pMessage.data)) {
					pPipe.message(pMessage.data, EPipeDataTypes.BINARY);
				}
				else {
					pPipe.message(pMessage.data, EPipeDataTypes.STRING);
				}
			}

			pConnect.onopen = function (pEvent: Event): void {
				{ logger.setSourceLocation( "Pipe.ts" , 126 ); logger.log("created connect to: " + pAddr.toString()); } ;

				pPipe.opened(pEvent);
			}

			pConnect.onerror = function (pErr: ErrorEvent): void {
				{ logger.setSourceLocation( "Pipe.ts" , 132 ); logger.warning("pipe error detected: " + pErr.message); } ;
				pPipe.error(pErr);
			}

			pConnect.onclose = function (pEvent: CloseEvent): void {
				{ logger.setSourceLocation( "Pipe.ts" , 137 ); logger.log("connection to " + pAddr.toString() + " closed"); } ;
				{ logger.setSourceLocation( "Pipe.ts" , 138 ); logger.log("Close event:", pEvent); } ;
				pPipe.closed(pEvent);
			}

			this._bSetupComplete = true;
		}

		close(): void {
			var pSocket: WebSocket;
			var pWorker: Worker;
			if (this.isOpened()) {
		    	switch (this._eType) {
			    	case EPipeTypes.WEBSOCKET:
			    		pSocket = <WebSocket>this._pConnect;
						pSocket.onmessage = null;
				    	pSocket.onerror = null;
				    	pSocket.onopen = null;
						pSocket.close();
						break;
					case EPipeTypes.WEBWORKER:
						pWorker = <Worker><any>this._pConnect;
						pWorker.terminate();
				}
			}

			this._pConnect = null;
			this._bSetupComplete = false;
		}

		write(pValue: any): bool {
			var pSocket: WebSocket;
			var pWorker: Worker;

			if (this.isOpened()) {
				this._nMesg ++;

				switch (this._eType) {
			    	case EPipeTypes.WEBSOCKET:
			    		pSocket = <WebSocket>this._pConnect;

						if (isObject(pValue)) {
							pValue = JSON.stringify(pValue);
						}

						pSocket.send(pValue);

						return true;

					case EPipeTypes.WEBWORKER:
						pWorker = <Worker><any>this._pConnect;

						if (isDef(pValue.byteLength)) {
							pWorker.postMessage(pValue, [pValue]);
						}
						else {
							pWorker.postMessage(pValue);
						}

						return true;
				}
			}

			return false;
		}

		isClosed(): bool {
			switch (this._eType) {
				case EPipeTypes.WEBSOCKET:
					return isNull(this._pConnect) || ((<WebSocket>this._pConnect).readyState === WebSocket.CLOSED);
			}

			return isNull(this._pConnect);
		}

		isOpened(): bool {
			switch (this._eType) {
				case EPipeTypes.WEBSOCKET:
					return !isNull(this._pConnect) && (<WebSocket>this._pConnect).readyState === WebSocket.OPEN;
			}

			return !isNull(this._pConnect);
		}


		/**@inline*/  isCreated(): bool {
			return !isNull(this._pConnect);
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Pipe._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		opened (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).opened; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		closed (ev): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).closed; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, ev) : _broadcast[i].listener (_recivier, ev) ; } } } ; ;
		error (err): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).error; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, err) : _broadcast[i].listener (_recivier, err) ; } } } ; ;
		message (data, type): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).message; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, data, type) : _broadcast[i].listener (_recivier, data, type) ; } } } ; ;
	}

	export function createPipe(sAddr: string = null): IPipe {
		return new Pipe(sAddr);
	}
}


















module akra {
	export interface ICollectionIndexFunction {
		(pElement: any):  number ;
	}

	export interface IObjectSortCollection {
		getElementAt(iIndex:  number ): any;
		setElementAt(iIndex:  number , pValue: any): void;
		removeElementAt(iIndex:  number ): void;

		setCollectionFuncion(fnCollection: ICollectionIndexFunction): void;

		push(pElement: any): void;
		findElement(iCollectionIndex:  number ): any;
		takeElement(iCollectionIndex:  number ): any;
		clear(): void;
	}
}


module akra.util {
	export class ObjectSortCollection implements IObjectSortCollection {
		private _iSize:  number  = 0;
		private _iCursor:  number  = 0;
		private _pElements: any[] = null;
		private _fnCollectionIndex: ICollectionIndexFunction = null;

		private _iCursorElementIndex:  number  = 0xFFFFFFFF;
		private _iStartElementIndex:  number  = 0xFFFFFFFF;
		private _iLastElementIndex:  number  = 0xFFFFFFFF;

		constructor(iSize:  number ){
			this._iSize = iSize;
			this._pElements = new Array(iSize);
			this._iCursor = -1;

			for(var i:  number  = 0; i < iSize; i++) {
				this._pElements[i] = null;
			}
		}

		push(pElement: any): void {
			if(this._iCursor === this._iSize - 1){
				this._iCursor = -1;
			}

			this._iCursor++;

			this._pElements[this._iCursor] = pElement;

			this._iCursorElementIndex = this._fnCollectionIndex.call(null, this._pElements[this._iCursor]);

			if(this._iCursor === 0){
				this._iStartElementIndex = this._fnCollectionIndex.call(null, this._pElements[0]);
			}
			else if(this._iCursor === this._iSize - 1){
				this._iLastElementIndex = this._fnCollectionIndex.call(null, this._pElements[this._iSize - 1]);
			}
		}

		findElement(iCollectionIndex:  number ): any {
			if (this._iStartElementIndex === 0xFFFFFFFF ||
				this._iCursorElementIndex === 0xFFFFFFFF ||
				iCollectionIndex > this._iCursorElementIndex){

				return null;
			}

			if(iCollectionIndex >= this._iStartElementIndex){
				return this._pElements[iCollectionIndex - this._iStartElementIndex];
			}
			else if(iCollectionIndex <= this._iLastElementIndex){
				return this._pElements[this._iSize - 1 - (this._iLastElementIndex - iCollectionIndex)];
			}

			return null;
		}

		takeElement(iCollectionIndex:  number ): any {
			if (this._iStartElementIndex === 0xFFFFFFFF ||
				this._iCursorElementIndex === 0xFFFFFFFF ||
				iCollectionIndex > this._iCursorElementIndex){

				{ logger.setSourceLocation( "util/ObjectSortCollection.ts" , 69 ); logger.log("i must not be here 1"); } ;
				return null;
			}

			var iResultIndex:  number  = -1;

			if(iCollectionIndex >= this._iStartElementIndex){
				iResultIndex = iCollectionIndex - this._iStartElementIndex;
			}
			else if(iCollectionIndex <= this._iLastElementIndex){
				iResultIndex = this._iSize - 1 - (this._iLastElementIndex - iCollectionIndex);
			}

			if(iResultIndex >= 0){
				var pResult: any = this._pElements[iResultIndex];
				this._pElements[iResultIndex] = null;
				return pResult;
			}
			else {
//LOG("i must not be here 2");
				return null;
			}
		}

		/**@inline*/  getElementAt(iIndex:  number ): any {
			return this._pElements[iIndex];
		}

		/**@inline*/  setElementAt(iIndex:  number , pValue: any): void {
			this._pElements[iIndex] = pValue;
		}

		/**@inline*/  removeElementAt(iIndex:  number ): void {
			this._pElements[iIndex] = null;
		}

		clear(): void {
			this._iCursor = -1;

			for(var i:  number  = 0; i < this._iSize - 1; i++){
				this._pElements[i] = null;
			}
		}

		setCollectionFuncion(fnCollection: ICollectionIndexFunction): void {
			this._fnCollectionIndex = fnCollection;
		}
	}
}



/// @: {data}/server|src(inc/net/server)|location()|data_location({data},DATA)









module akra.net {



    enum ERpcStates {
//not connected
        k_Deteached,
//connected, and connection must be established
        k_Joined,
//must be closed
        k_Closing
    }

    class RPC implements IRPC {
        protected _pOption: IRPCOptions;

        protected _pPipe: IPipe = null;

        protected _iGroupID:  number  = -1;
        protected _pGroupCalls: IRPCRequest = null;

//стек вызововы, которые были отложены
        protected _pDefferedRequests: IObjectList = new ObjectList;
//стек вызовов, ожидающих результата
//type: ObjectList<IRPCCallback>
        protected _pCallbacksList: IObjectList = null;
        protected _pCallbacksCollection: IObjectSortCollection = null;
//число совершенных вызовов
        protected _nCalls:  number  = 0;

        protected _pRemoteAPI: Object = {};
        protected _eState: ERpcStates = ERpcStates.k_Deteached;

//rejoin timer
        protected _iReconnect:  number  = -1;
//timer for system routine
        protected _iSystemRoutine:  number  = -1;
        protected _iGroupCallRoutine:  number  = -1;


        /**@inline*/  get remote(): any { return this._pRemoteAPI; }
        /**@inline*/  get options(): IRPCOptions { return this._pOption; };
        /**@inline*/  get group():  number  { return !isNull(this._pGroupCalls)? this._iGroupID: -1; }

        constructor (sAddr?: string, pOption?: IRPCOptions);
        constructor (pAddr: any = null, pOption: IRPCOptions = {}) {
            for (var i in RPC.OPTIONS) {
                if (!isDef(pOption[i])) {
                    pOption[i] = RPC.OPTIONS[i];
                }
            }

            this._pOption = pOption;

            if (!isDefAndNotNull(pOption.procMap)) {
                pOption.procMap = {};
            }

            pOption.procMap[pOption.procListName] = {
                lifeTime: -1,
                priority: 10
            };

            if( (this.options.maxCallbacksCount > 0) ){
                this._pCallbacksCollection = new util.ObjectSortCollection(this._pOption.maxCallbacksCount);
                this._pCallbacksCollection.setCollectionFuncion((pCallback: IRPCCallback):  number  => {
                    return isNull(pCallback) ? -1 : pCallback.n;
                });
            }
            else {
                this._pCallbacksList = new util.ObjectList();
            }
            pAddr = pAddr || pOption.addr;

            if (isDefAndNotNull(pAddr)) {
                this.join(<string>pAddr);
            }
        }

        join(sAddr: string = null): void {
            var pPipe: IPipe = this._pPipe;
            var pRPC: RPC = this;
            var pDeffered: IObjectList = this._pDefferedRequests;

            if (isNull(pPipe)) {
                pPipe = net.createPipe();

                pPipe.bind( "message" ,
                    function (pPipe: IPipe, pMessage: any, eType: EPipeDataTypes): void {
// LOG(pMessage);
                        if (eType !== EPipeDataTypes.BINARY) {
                            pRPC.parse(JSON.parse(<string>pMessage));
                        }
                        else {
                            pRPC.parseBinary(new Uint8Array(pMessage));
                        }
                    }
                );

                pPipe.bind( "opened" ,
                    function (pPipe: IPipe, pEvent: Event): void {

                        pRPC._startRoutines();

//if we have unhandled call in deffered...
                        if (pDeffered.length) {
                            pDeffered.seek(0);

                            while(pDeffered.length > 0) {
                                pPipe.write(pDeffered.current);
                                pRPC._releaseRequest(<IRPCRequest>pDeffered.takeCurrent());
                            }

                            { logger.setSourceLocation( "net/RPC.ts" , 135 ); logger.assert(pDeffered.length === 0, "something going wrong. length is: " + pDeffered.length); } ;
                        }

                        pRPC.proc(pRPC.options.procListName,
                            function (pError: Error, pList: string[]) {
                                if (!akra.isNull(pError)) {
                                    { logger.setSourceLocation( "net/RPC.ts" , 141 ); logger.criticalError("could not get proc. list"); } ;
                                }
//TODO: FIX akra. prefix...
                                if (!akra.isNull(pList) && akra.isArray(pList)) {

                                    for (var i:  number  = 0; i < pList.length; ++ i) {
                                        (function (sMethod) {

                                            pRPC.options.procMap[sMethod] = pRPC.options.procMap[sMethod] || {
                                                lifeTime: -1,
                                                priority: 0
                                            };

                                            pRPC.remote[sMethod] = function () {
                                                var pArguments: string[] = [sMethod];

                                                for (var j:  number  = 0; j < arguments.length; ++ j) {
                                                    pArguments.push(arguments[j]);
                                                }

                                                return pRPC.proc.apply(pRPC, pArguments);
                                            }
                                        })(String(pList[i]));
                                    }

// debug_print("rpc options: ", pRPC.options);
                                }

                                pRPC.joined();
                            }
                        );
                    }
                );

                pPipe.bind( "error" ,
                    function(pPipe: IPipe, pError: Error): void {
                        { logger.setSourceLocation( "net/RPC.ts" , 177 ); logger.error("pipe e rror occured..."); } ;
                        pRPC.error(pError);
//pRPC.rejoin();
                    }
                );

                pPipe.bind( "closed" ,
                    function (pPipe: IPipe, pEvent: CloseEvent): void {
                        pRPC._stopRoutines();
                        pRPC.rejoin();
                    }
                );
            }

            pPipe.open(<string>sAddr);

            this._pPipe = pPipe;
            this._eState = ERpcStates.k_Joined;
        }

        rejoin(): void {
            var pRPC: IRPC = this;

            clearTimeout(this._iReconnect);

//rejoin not needed, because pipe already connected
            if (this._pPipe.isOpened()) {
                this._eState = ERpcStates.k_Joined;
                return;
            }

//rejoin not needed, because we want close connection
            if (this._eState == ERpcStates.k_Closing) {
                this._eState = ERpcStates.k_Deteached;
                return;
            }

            if (this._pPipe.isClosed()) {
//callbacks that will not be called, because connection was lost 
                this.freeCallbacks();

                if ( (this.options.reconnectTimeout > 0) ) {
                    this._iReconnect = setTimeout(() => {
                        pRPC.join();
                    }, this.options.reconnectTimeout);
                }
            }
        }

        parse(pRes: IRPCResponse): void {
            if (!isDef(pRes.n)) {
                { logger.setSourceLocation( "net/RPC.ts" , 228 ); logger.log(pRes); } ;
                { logger.setSourceLocation( "net/RPC.ts" , 229 ); logger.warning("message droped, because seriial not recognized."); } ;
            };

            this.response(pRes.n, pRes.type, pRes.res);
        }


        parseBinary(pBuffer: Uint8Array): void {

            var iHeaderByteLength:  number  = 12;
            var pHeader: Uint32Array = new Uint32Array(pBuffer.buffer, pBuffer.byteOffset, iHeaderByteLength / 4);

            var nMsg:  number  = pHeader[0];
            var eType: ERPCPacketTypes = <ERPCPacketTypes>pHeader[1];
            var iByteLength:  number  = pHeader[2];

            var pResult: Uint8Array = pBuffer.subarray(iHeaderByteLength, iHeaderByteLength + iByteLength);

            this.response(nMsg, eType, pResult);

            var iPacketByteLength:  number  = iHeaderByteLength + iByteLength;

            if (pBuffer.byteLength > iPacketByteLength) {
// console.log("group message detected >> ");
                this.parseBinary(pBuffer.subarray(iPacketByteLength));
            }
        }

        private response(nSerial:  number , eType: ERPCPacketTypes, pResult: any): void {
            if (eType === ERPCPacketTypes.RESPONSE) {
                var fn: Function = null;
                var pCallback: IRPCCallback = null;
// WARNING("---------------->",nSerial,"<-----------------");
// LOG(pStack.length);
                if( (this.options.maxCallbacksCount > 0) ){
                    var pCollection: IObjectSortCollection = this._pCallbacksCollection;
                    pCallback = pCollection.takeElement(nSerial);
                    if(!isNull(pCallback)){
                        fn = pCallback.fn;
                        this._releaseCallback(pCallback);

                        if (!isNull(fn)) {
                            fn(null, pResult);
                        }
                        return;
                    }
                }
                else {
                    var pStack: IObjectList = this._pCallbacksList;
                    pCallback = <IRPCCallback>pStack.last;
                    do {
// LOG("#n: ", nSerial, " result: ", pResult);
                        if (pCallback.n === nSerial) {
                            fn = pCallback.fn;
                            this._releaseCallback(pStack.takeCurrent());

                            if (!isNull(fn)) {
                                fn(null, pResult);
                            }
                            return;
                        }
                    } while (pCallback = pStack.prev());
                }


// WARNING("package droped, invalid serial: " + nSerial);
            }
            else if (eType === ERPCPacketTypes.REQUEST) {
                { logger.setSourceLocation( "net/RPC.ts" , 297 ); logger.error("TODO: REQUEST package type temprary unsupported."); } ;
            }
            else if (eType === ERPCPacketTypes.FAILURE) {
                { logger.setSourceLocation( "net/RPC.ts" , 300 ); logger.error("detected FAILURE on " + nSerial + " package"); } ;
                { logger.setSourceLocation( "net/RPC.ts" , 301 ); logger.log(pResult); } ;
            }
            else {
                { logger.setSourceLocation( "net/RPC.ts" , 304 ); logger.error("unsupported response type detected: " + eType); } ;
            }
        }

        private freeRequests(): void {
            var pStack: IObjectList = this._pDefferedRequests;
            var pReq: IRPCRequest = <IRPCRequest>pStack.first;

            if (pReq) {
                do {
                    this._releaseRequest(pReq);
                } while (pReq = pStack.next());

                pStack.clear();
            }
        }

        private freeCallbacks(): void {
            if( (this.options.maxCallbacksCount > 0) ){
                this._pCallbacksCollection.clear();
            }
            else {
                var pStack: IObjectList = this._pCallbacksList;
                var pCallback: IRPCCallback = <IRPCCallback>pStack.first;

                if (pCallback) {
                    do {
                        this._releaseCallback(pCallback);
                    } while (pCallback = pStack.next());

                    pStack.clear();
                }
            }
        }

        free(): void {
            this.freeRequests();
            this.freeCallbacks();
        }

        detach(): void {
            this._eState = ERpcStates.k_Closing;

            if (!isNull(this._pPipe) && this._pPipe.isOpened()) {
                this._pPipe.close();
            }

            this.free();
        }

        private  /**@inline*/  findLifeTimeFor(sProc: string):  number  {
            var pProcOpt: IRPCProcOptions = this._pOption.procMap[sProc];

            if (pProcOpt) {
                var iProcLt:  number  = pProcOpt.lifeTime;

                if (iProcLt >= 0)
                    return iProcLt;
            }

            return this._pOption.callbackLifetime;
        }

        private findPriorityFor(sProc: string):  number  {
            var pProcOpt: IRPCProcOptions = this._pOption.procMap[sProc];

            if (pProcOpt) {
                var iProcPr:  number  = pProcOpt.priority || 0;

                return iProcPr;
            }

            return 0;
        }

        setProcedureOption(sProc: string, sOpt: string, pValue: any): void {
            var pOptions: IRPCProcOptions = this.options.procMap[sProc];

            if (!pOptions) {
                pOptions = this.options.procMap[sProc] = {
                    lifeTime: -1
                };
            }

            pOptions[sOpt] = pValue;
        }

        proc(...argv: any[]): bool {

            var IRPCCallback:  number  = arguments.length - 1;
            var fnCallback: Function =
                isFunction(arguments[IRPCCallback])? <Function>arguments[IRPCCallback]: null;
            var nArg:  number  = arguments.length - (fnCallback? 2: 1);
            var pArgv: any[] = new Array(nArg);
            var pPipe: IPipe = this._pPipe;
            var pCallback: IRPCCallback = null;

            for (var i = 0; i < nArg; ++ i) {
                pArgv[i] = arguments[i + 1];
            }

            var pProc: IRPCRequest = this._createRequest();

            pProc.n     = this._nCalls ++;
            pProc.type  = ERPCPacketTypes.REQUEST;
            pProc.proc  = String(arguments[0]);
            pProc.argv  = pArgv;
            pProc.next  = null;
            pProc.lt    = this.findLifeTimeFor(pProc.proc);
            pProc.pr    = this.findPriorityFor(pProc.proc);

            pCallback = <IRPCCallback>this._createCallback();
            pCallback.n = pProc.n;
            pCallback.fn = fnCallback;
            pCallback.timestamp = now();

            pCallback.procInfo = pProc.proc + "(" + pArgv.join(',') + ")";


            if (isNull(pPipe) || !pPipe.isOpened()) {
                if (! (this.options.deferredCallsLimit >= 0)  ||
                    this._pDefferedRequests.length <= this.options.deferredCallsLimit) {

                    this._pDefferedRequests.push(pProc);

                    if( (this.options.maxCallbacksCount > 0) ){
                        this._pCallbacksCollection.push(pCallback);
                    }
                    else {
                        this._pCallbacksList.push(pCallback);
                    }
                }
                else {
                    pCallback.fn(RPC.ERRORS.STACK_SIZE_EXCEEDED);
                    { logger.setSourceLocation( "net/RPC.ts" , 438 ); logger.warning(RPC.ERRORS.STACK_SIZE_EXCEEDED); } ;

                    this._releaseCallback(pCallback);
                    this._releaseRequest(pProc);
                }

                return false;
            }

            if( (this.options.maxCallbacksCount > 0) ){
                this._pCallbacksCollection.push(pCallback);
            }
            else {
                this._pCallbacksList.push(pCallback);
            }

            return this.callProc(pProc);
        }

        private callProc(pProc: IRPCRequest): bool {
            var pPipe: IPipe = this._pPipe;
            var bResult: bool = false;

            if ( (this.options.callsFrequency > 0) ) {
                if (isNull(this._pGroupCalls)) {
                    this._pGroupCalls = pProc;
                    this._iGroupID ++;
                }
                else {
                    pProc.next = this._pGroupCalls;
                    this._pGroupCalls = pProc;
                }

                return true;
            }
            else {
                bResult = pPipe.write(pProc);
                this._releaseRequest(pProc);
            }

            return bResult;
        }

        /**@inline*/  _systemRoutine(): void {
            this._removeExpiredCallbacks();
        }

        _startRoutines(): void {
            var pRPC: RPC = this;

            if ( (this.options.systemRoutineInterval > 0) ) {
                this._iSystemRoutine = setInterval(() => {
                    pRPC._systemRoutine();
                }, this.options.systemRoutineInterval);
            }

            if ( (this.options.callsFrequency > 0) ) {
                this._iGroupCallRoutine = setInterval(() => {
                    pRPC.groupCall();
                }, this.options.callsFrequency);
            }
        }

        _stopRoutines(): void {
            clearInterval(this._iSystemRoutine);
            this._systemRoutine();

            clearInterval(this._iGroupCallRoutine);
//TODO: remove calls from group call, if RPC finally detached!
        }

        groupCall():  number  {
            var pReq: IRPCRequest = this._pGroupCalls;

            if (isNull(pReq)) {
                return;
            }

            this._pPipe.write(pReq);

           return this.dropGroupCall();
        }

        dropGroupCall():  number  {
            var pReq: IRPCRequest = this._pGroupCalls;

            for (;;) {
                var pNext = pReq.next;
                this._releaseRequest(pReq);

                if (!pNext) {
                    break;
                }

                pReq = <IRPCRequest>pNext;
            }

            this._pGroupCalls = null;
            return this._iGroupID;
        }

        _removeExpiredCallbacks(): void {
            var pCallback: IRPCCallback = null;
            var iNow:  number  = now();
            var fn: Function = null;
            var sInfo: string = null;

            if( (this.options.maxCallbacksCount > 0) ){
//                 for(var i: uint = 0; i < this.options.maxCallbacksCount; i++){
//                     pCallback = <IRPCCallback>this._pCallbacksCollection.getElementAt(i);

//                     if (!isNull(pCallback) && HAS_CALLBACK_LIFETIME(this) && (iNow - pCallback.timestamp) >= this.options.callbackLifetime) {
//                         fn = pCallback.fn;
// #ifdef DEBUG                    
//                         sInfo = pCallback.procInfo;
// #endif
//                         this._releaseCallback(pCallback);
//                         this._pCallbacksCollection.removeElementAt(i);

//                         if (!isNull(fn)) {
//                             // debug_print("procedure info: ", sInfo);
//                             fn(RPC.ERRORS.CALLBACK_LIFETIME_EXPIRED, null);
//                         }
//                     }
//                 }
            }
            else {
                var pCallbacks: IObjectList = this._pCallbacksList;
                pCallback = <IRPCCallback>pCallbacks.first;
                while(!isNull(pCallback)) {

                    if ( (this.options.callbackLifetime > 0)  && (iNow - pCallback.timestamp) >= this.options.callbackLifetime) {
                        fn = pCallback.fn;

                        sInfo = pCallback.procInfo;

                        this._releaseCallback(<IRPCCallback>pCallbacks.takeCurrent());

                        pCallback = pCallbacks.current;

                        if (!isNull(fn)) {
// debug_print("procedure info: ", sInfo);
                            fn(RPC.ERRORS.CALLBACK_LIFETIME_EXPIRED, null);
                        }
                    }
                    else {
                        pCallback = <IRPCCallback>pCallbacks.next();
                    }
                }
            }
        }

        _releaseRequest(pReq: IRPCRequest): void {
            pReq.n = 0;
            pReq.proc = null;
            pReq.argv = null;
            pReq.next = null;
            pReq.lt = 0;
            pReq.pr = 0;

            RPC.requestPool.push(pReq);
        };

        _createRequest(): IRPCRequest {
            if (RPC.requestPool.length == 0) {
// LOG("allocated rpc request");
                return {n: 0, type: ERPCPacketTypes.REQUEST, proc: null, argv: null, next: null, lt: 0, pr: 0};
            }

            return <IRPCRequest>RPC.requestPool.pop();
        }

        _releaseCallback(pCallback: IRPCCallback): void {
            pCallback.n = 0;
            pCallback.fn = null;
            pCallback.timestamp = 0;
            pCallback.procInfo = null;

            RPC.callbackPool.push(pCallback);
        };

        _createCallback(): IRPCCallback {
            if (RPC.callbackPool.length == 0) {
// LOG("allocated callback");
                return { n: 0, fn: null, timestamp: 0, procInfo: <string>null };
            }

            return <IRPCCallback>RPC.callbackPool.pop();
        }

        protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return RPC._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
        joined (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).joined; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
        error (pError): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).error; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pError) : _broadcast[i].listener (_recivier, pError) ; } } } ; ;

        private static requestPool: IObjectArray = new ObjectArray;
        private static callbackPool: IObjectArray = new ObjectArray;

        static OPTIONS: IRPCOptions = {
            deferredCallsLimit        : 20000,
            reconnectTimeout          : 2500,
            systemRoutineInterval     : 10000,
            callbackLifetime          : 60000,
            maxCallbacksCount         : -1,
            procListName              : "proc_list",
            callsFrequency            : -1
        }

        static ERRORS = {
            STACK_SIZE_EXCEEDED: <IRPCError>{
                name: "RPC err.",
                message: "stack size exceeded",
                code:  1
            },
            CALLBACK_LIFETIME_EXPIRED: <IRPCError>{
                name: "RPC err.",
                message: "procedure life time expired",
                code:  2
            }
        }

    }

    export function createRpc(opt?: IRPCOptions): IRPC;
    export function createRpc(addr?: string, opt?: IRPCOptions): IRPC;
    export function createRpc(addr?: any, opt?: any): IRPC {
        if (arguments.length == 1) {
            if (isString(addr)) {
                return new RPC(addr);
            }

            return new RPC(null, arguments[0]);
        }

        return new RPC(addr, opt);
    }
}















module akra.terrain {
	interface ISubTextureSettings {
		iX:  number ;
/*Координты буфера в основной текстуре, для простыты должны быть кратну размеру блока*/
		iY:  number ;
    	iTexX: number ;
/*Координаты мегатекстуры в текстуре*/
    	iTexY: number ;
    	width:  number ;
    	height:  number ;
    	isUpdated : bool;
    	isLoaded : bool;
	}

	export class MegaTexture implements IMegaTexture {
	    private _pEngine: IEngine = null;
// private _pDevice = null;

	    private _pObject: any = null;
	    private _pWorldExtents: IRect3d = null;
//Координаты камеры на объекте
	    private _v2fCameraCoord: IVec2 = new Vec2(0, 0);

//Путь откуда запрашиваются куски текстуры
	    private _sSurfaceTextures: string = "";

//Маскимальный размер стороны текстуры
	    private _v2iOriginalTextreMaxSize: IVec2 = new Vec2(1024 * 32.);
	    private _v2iOriginalTextreMinSize: IVec2 = new Vec2(1024 * 4.);
	    private _v2iTextureLevelSize: IVec2 = new Vec2(1024);

	    private _iMinLevel:  number  = 0;
	    private _iMaxLevel:  number  = 0;

//Тип хранимых тектсур
	    private _eTextureFormat: EPixelFormats = EPixelFormats.BYTE_RGB;

//Размер блока текстуры(минимальный размер выгружаемого куска текстуры)
	    private _iBlockSize:  number  = 32;

	    private _iBufferWidth:  number  = 0;
	    private _iBufferHeight:  number  = 0;

	    private _pTextures: ITexture[] = null;
	    private _pTextureForSwap: ITexture = null;

//Карта с разметкой буфера, чтобы знать какой части буффер уже отсылалось задание на заполнение
	    private _pSectorLoadInfo: Uint32Array[] = null;
	    private _pXY: ISubTextureSettings[] = null;

//Всякие темповые буферы
	    private _pLoadInfoForSwap: Uint32Array  = null;
	    private _pDefaultSectorLoadInfo: Uint32Array = null;

	    private _pRPC: IRPC = null;

	    private _fTexCourdXOld:  number  = 0xFFFFFFFF;
	    private _fTexCourdYOld:  number  = 0xFFFFFFFF;
	    private _nCountRender:  number  = 0;

	    private _iSectorLifeTime:  number  = 60000;

	    private _pSamplerUniforms: IAFXSamplerState[] = null;
		private _pLoadStatusUniforms:  number [] = null;
		private _pTexcoordOffsetUniforms: IVec2[] = null;

		private _bManualMinLevelLoad: bool = false;

	    constructor(pEngine: IEngine) {
	    	this._pEngine = pEngine;
	    }

	    init(pObject: ISceneObject, sSurfaceTextures: string): void {
	    	this._pObject = pObject;
	    	this._pWorldExtents = pObject.localBounds;
	    	this._sSurfaceTextures = sSurfaceTextures;

	    	if(!this.checkTextureSizeSettings()){
	    		{ logger.setSourceLocation( "terrain/MegaTexture.ts" , 89 ); logger.criticalError("Wrong texture size settings for MegaTexture"); } ;
	    	}

	    	var iCountTex:  number  = this._iMaxLevel - this._iMinLevel + 1;

	    	this._pTextures = <ITexture[]> new Array(iCountTex);
	    	this._pSectorLoadInfo = <Uint32Array[]> new Array(iCountTex);
	    	this._pXY = <ISubTextureSettings[]> new Array(iCountTex);

	    	this._iBufferWidth = this._v2iTextureLevelSize.x * 1;
	    	this._iBufferHeight = this._v2iTextureLevelSize.y * 1;

	    	this._pLoadInfoForSwap  = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x / (this._iBlockSize * this._iBlockSize));
	    	this._pDefaultSectorLoadInfo = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x / (this._iBlockSize * this._iBlockSize));

	    	for (var i:  number  = 0; i < this._pDefaultSectorLoadInfo.length; i++) {
	    	    this._pDefaultSectorLoadInfo[i] = 0;
	    	}

	    	this.setSectorLoadInfoToDefault(this._pLoadInfoForSwap);

//Создаем куски мегатекстуры
	    	var pRmgr: IResourcePoolManager = this._pEngine.getResourceManager();

	    	this._pTextureForSwap = pRmgr.createTexture(".texture-for-mega-swap_" + sid());
	    	this._pTextureForSwap.create(this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y, 1, null, ETextureFlags.DYNAMIC, 0, 1, ETextureTypes.TEXTURE_2D, this._eTextureFormat);
	    	this._pTextureForSwap.setWrapMode(ETextureParameters.WRAP_S, ETextureWrapModes.CLAMP_TO_EDGE);
    		this._pTextureForSwap.setWrapMode(ETextureParameters.WRAP_T, ETextureWrapModes.CLAMP_TO_EDGE);

//create texture levels
    	    for (var i:  number  = 0; i < this._pTextures.length; i++)
    	    {
    	        this._pTextures[i] = pRmgr.createTexture(".texture-for-mega-" + i + "_" + sid());
    	        if(i === 0){
    	        	this._pTextures[i].create(this._v2iOriginalTextreMinSize.x, this._v2iOriginalTextreMinSize.y, 1, null, ETextureFlags.DYNAMIC, 0, 1, ETextureTypes.TEXTURE_2D, EPixelFormats.BYTE_RGB);

/*this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x*/
    	        	this._pSectorLoadInfo[i] = new Uint32Array(this._v2iOriginalTextreMinSize.y * this._v2iOriginalTextreMinSize.x                                                              /
	                                                  	   	   (this._iBlockSize * this._iBlockSize));
    	        	this._pXY[i] = <ISubTextureSettings> {
/*Координты буфера в основной текстуре, для простыты должны быть кратну размеру блока*/
			    	        				iX : 0, iY : 0,
/*Координаты мегатекстуры в текстуре*/
			    							iTexX:0, iTexY:0,
			    							width: this._v2iOriginalTextreMinSize.x,
			    							height: this._v2iOriginalTextreMinSize.y,
			    							isUpdated : true, isLoaded : false
			    						};
    	        }
    	        else {
    	        	this._pTextures[i].create(this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y, 1, null, ETextureFlags.DYNAMIC, 0, 1, ETextureTypes.TEXTURE_2D, this._eTextureFormat);

    				this._pSectorLoadInfo[i] = new Uint32Array(this._v2iTextureLevelSize.y * this._v2iTextureLevelSize.x /
	                                                  	   (this._iBlockSize * this._iBlockSize));

	            	this.setSectorLoadInfoToDefault(this._pSectorLoadInfo[i]);

	    			this._pTextures[i].setWrapMode(ETextureParameters.WRAP_S, ETextureWrapModes.CLAMP_TO_EDGE);
    				this._pTextures[i].setWrapMode(ETextureParameters.WRAP_T, ETextureWrapModes.CLAMP_TO_EDGE);

    	        	this._pXY[i] = <ISubTextureSettings> {
/*Координты буфера в основной текстуре, для простыты должны быть кратну размеру блока*/
			    	        				iX : 0, iY : 0,
/*Координаты мегатекстуры в текстуре*/
			    							iTexX:0, iTexY:0,
			    							width: this._pTextures[i].width,
			    							height: this._pTextures[i].height,
			    							isUpdated : true, isLoaded : false
			    						};
    			}


    	    }

    	    this.createUniforms();

    	    this.testDataInit();

    	    this._pRPC = net.createRpc();

    	    if(!this._bManualMinLevelLoad){
    	    	this.connect(this._pRPC,  "joined" ,  "loadMinTextureLevel" , EEventTypes.BROADCAST);
    	    	this.connect(this._pRPC,  "error" ,  "rpcErrorOccured" , EEventTypes.BROADCAST);
    		}

// this._pRPC.join("ws://23.21.68.208:6112");
    	    this._pRPC.join("ws://localhost:6112");

    	    this._pRPC.setProcedureOption("getMegaTexture", "lifeTime", 60000);
    	    this._pRPC.setProcedureOption("getMegaTexture", "priority", 1);

    	    this._pRPC.setProcedureOption("loadMegaTexture", "lifeTime", 60000);
    	    this._pRPC.setProcedureOption("loadMegaTexture", "priority", 1);
	    }

		/**@inline*/  set manualMinLevelLoad(bManual: bool) {
			this._bManualMinLevelLoad = bManual;
		}

		/**@inline*/  get manualMinLevelLoad(): bool {
			return this._bManualMinLevelLoad;
		}

	    private _bError: bool = false;
	    private _tLastTime:  number  = 0;
		prepareForRender(pViewport: IViewport): void {
			if(this._bError){
				{ logger.setSourceLocation( "terrain/MegaTexture.ts" , 191 ); logger.criticalError("ERROR"); } ;
			}

			if(!this._pXY[0].isLoaded){
// var tCurrentTime: uint = (this._pEngine.getTimer().absoluteTime * 1000) >>> 0;

// if(tCurrentTime - this._pSectorLoadInfo[0][0] > 90000){
// 	this.loadMinTextureLevel();
// }

				return;
			}

			var tCurrentTime:  number  = (this._pEngine.getTimer().absoluteTime * 1000) >>> 0;

			if(tCurrentTime - this._tLastTime < 30){
				return;
			}
			this._tLastTime = tCurrentTime;

		    var pCamera: ICamera = pViewport.getCamera();
		    var v4fCameraCoord: IVec4 =  Vec4.stackCeil.set(pCamera.worldPosition, 1.) ;
		    var m4fTransposeInverse: IMat4 = this._pObject.inverseWorldMatrix;

		    v4fCameraCoord = m4fTransposeInverse.multiplyVec4(v4fCameraCoord);

//Вычисление текстурных координат над которыми находиться камера
		    var fTexCourdX:  number  = (v4fCameraCoord.x - this._pWorldExtents.x0) /
		                     math.abs(this._pWorldExtents.x1 - this._pWorldExtents.x0);
		    var fTexCourdY:  number  = (v4fCameraCoord.y - this._pWorldExtents.y0) /
		                     math.abs(this._pWorldExtents.y1 - this._pWorldExtents.y0);

		    this._v2fCameraCoord.set(fTexCourdX, fTexCourdY);

		    var iX:  number  = 0, iX1:  number  = 0, iX2:  number  = 0;
		    var iY:  number  = 0, iY1:  number  = 0, iY2:  number  = 0;
		    var iWidth:  number  = 0, iHeight:  number  = 0;

//Нужно ли перекладвывать, отсавим на запас 8 блоков

//Опираемся на текстуру самого хорошего разрешения

//Координаты квадрата this._v2iTextureLevelSize.x Х this._v2iTextureLevelSize.y с центром в камере на текстуре самого большого разрешения.

		    iX = math.round(fTexCourdX * (this.getWidthOrig(this._pTextures.length - 1)) - this._v2iTextureLevelSize.x / 2);
		    iY = math.round(fTexCourdY * (this.getHeightOrig(this._pTextures.length - 1)) - this._v2iTextureLevelSize.y / 2);

		    iWidth  = this._v2iTextureLevelSize.x;
		    iHeight = this._v2iTextureLevelSize.y;

// Перемещаем данные из одного пиксель буффера в другой

		    if ((this._fTexCourdXOld !== fTexCourdX || this._fTexCourdYOld !== fTexCourdY)) {
//Перемещаем
//Для всех уровней текстур

		        for (i = 1; i < this._pTextures.length; i++) {
// LOG("Уровень", i)
//Вычисляем новые координаты буфера в текстуре
		            var iXnew:  number  = math.round(fTexCourdX * this.getWidthOrig(i) - this._v2iTextureLevelSize.x / 2);
		            var iYnew:  number  = math.round(fTexCourdY * this.getHeightOrig(i) - this._v2iTextureLevelSize.y / 2);

// iXnew -= (this._iBufferWidth - this._v2iTextureLevelSize.x) / 2;
// iYnew -= (this._iBufferHeight - this._v2iTextureLevelSize.y) / 2;

//Округлили на размер блока
		            iXnew = math.round((iXnew / this._iBlockSize)) * this._iBlockSize;
		            iYnew = math.round((iYnew / this._iBlockSize)) * this._iBlockSize;
//Копирование совпадающего куска

		            var iXOverlappingBlockInOldBuf:  number  = iXnew - this._pXY[i].iX;
		            var iYOverlappingBlockInOldBuf:  number  = iYnew - this._pXY[i].iY;
		            var iXOverlappingBlockInNewBuf:  number  = -iXOverlappingBlockInOldBuf;
		            var iYOverlappingBlockInNewBuf:  number  = -iYOverlappingBlockInOldBuf;

		            iXOverlappingBlockInOldBuf = math.max(0, iXOverlappingBlockInOldBuf);
		            iYOverlappingBlockInOldBuf = math.max(0, iYOverlappingBlockInOldBuf);
		            iXOverlappingBlockInNewBuf = math.max(0, iXOverlappingBlockInNewBuf);
		            iYOverlappingBlockInNewBuf = math.max(0, iYOverlappingBlockInNewBuf);


		            if (iXOverlappingBlockInOldBuf < this._iBufferWidth && iYOverlappingBlockInOldBuf < this._iBufferHeight &&
		                iXOverlappingBlockInNewBuf < this._iBufferWidth && iYOverlappingBlockInNewBuf < this._iBufferHeight) {
//произошло совпадение кусков
		                var iOverlappingBlockWidth:  number  = this._iBufferWidth - math.abs(iXnew - this._pXY[i].iX);
		                var iOverlappingBlockHeight:  number  = this._iBufferHeight - math.abs(iYnew - this._pXY[i].iY);

//копируем данные
		                var pSwapBuffer: IPixelBuffer = this._pTextureForSwap.getBuffer(0, 0);
		                var pTextureBuffer: IPixelBuffer = this._pTextures[i].getBuffer(0, 0);

		                var pTmpBox1: IBox = geometry.box(iXOverlappingBlockInNewBuf, iYOverlappingBlockInNewBuf,
		                								  iOverlappingBlockWidth + iXOverlappingBlockInNewBuf,
		                								  iOverlappingBlockHeight + iYOverlappingBlockInNewBuf);
		                var pTmpBox2: IBox = geometry.box(iXOverlappingBlockInOldBuf, iYOverlappingBlockInOldBuf,
		                								  iOverlappingBlockWidth + iXOverlappingBlockInOldBuf,
		                								  iOverlappingBlockHeight + iYOverlappingBlockInOldBuf);

		                var pTmpBox3: IBox = geometry.box(0, 0, this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y);

		                var pTempPixelBox: IPixelBox = pixelUtil.pixelBox(pTmpBox3, this._eTextureFormat);
		                pTempPixelBox.data = null;

/* Save overlapped data */
		                pSwapBuffer.blit(pTextureBuffer, pTmpBox2, pTmpBox2);

/* Clear texture */
		                pTextureBuffer.blitFromMemory(pTempPixelBox, pTmpBox3);

/* Put overlapperd data */
		               	pTextureBuffer.blit(pSwapBuffer, pTmpBox2, pTmpBox1);

		                this.setSectorLoadInfoToDefault(this._pLoadInfoForSwap);

// LOG(iXOverlappingBlockInOldBuf + " ---> " + iXOverlappingBlockInNewBuf, 
// 	iYOverlappingBlockInOldBuf + " ---> " + iYOverlappingBlockInNewBuf);

		                this._setDataBetweenBufferMap(this._pLoadInfoForSwap,
		                							  iXOverlappingBlockInNewBuf / this._iBlockSize,
		                                              iYOverlappingBlockInNewBuf / this._iBlockSize,

		                                              this._pSectorLoadInfo[i],
		                                              iXOverlappingBlockInOldBuf / this._iBlockSize,
		                                              iYOverlappingBlockInOldBuf / this._iBlockSize,
		                                              iOverlappingBlockWidth / this._iBlockSize,
		                                              iOverlappingBlockHeight / this._iBlockSize);

		                var s: Uint32Array = this._pSectorLoadInfo[i];
		                this._pSectorLoadInfo[i] = this._pLoadInfoForSwap;
		                this._pLoadInfoForSwap = s;
		            }
		            else {
		                var pTextureBuffer: IPixelBuffer = this._pTextures[i].getBuffer(0, 0);
		                var pTmpBox3: IBox = geometry.box(0, 0, this._v2iTextureLevelSize.x, this._v2iTextureLevelSize.y);

		                var pTempPixelBox: IPixelBox = pixelUtil.pixelBox(pTmpBox3, this._eTextureFormat);
		                pTempPixelBox.data = null;

		                pTextureBuffer.blitFromMemory(pTempPixelBox, pTmpBox3);

		                this.setSectorLoadInfoToDefault(this._pSectorLoadInfo[i]);
		            }

					this._pXY[i].iX = iXnew;
	            	this._pXY[i].iY = iYnew;
		        }
		    }

//Подгрузка части буфера которую ложиться в текстуру + 8 блоков
//Нулевая статична, поэтому ее не меняем
		   	for (var i:  number  = 1; i < this._pTextures.length; i++) {
// for (var i: uint = this._pTextures.length - 1; i >= 1; i--) {
	            iX = math.round(fTexCourdX * this.getWidthOrig(i) - this._v2iTextureLevelSize.x / 2);
	            iY = math.round(fTexCourdY * this.getHeightOrig(i) - this._v2iTextureLevelSize.y / 2);

				iX = math.round((iX / this._iBlockSize)) * this._iBlockSize;
	            iY = math.round((iY / this._iBlockSize)) * this._iBlockSize;

	            this._pXY[i].iTexX = iX / this.getWidthOrig(i);
				this._pXY[i].iTexY = iY / this.getHeightOrig(i);

	            iWidth = this._v2iTextureLevelSize.x;
	            iHeight = this._v2iTextureLevelSize.y;
//На данный момент нужен кусок текстуры таких размеров iX1,iY1,iWidth,iHeight,

	            var iAreaX1:  number  = iX;
	            var iAreaY1:  number  = iY;
	            var iAreaX2:  number  = iX + iWidth;
	            var iAreaY2:  number  = iY + iHeight;

//Смотрим попадаем ли мы в текущий буфер

//Типа попали
//Значит нужно загрузить необходимые куски
//Обрезаемся чтобы не вылезти за пределы

// iX -= this._iBlockSize * 8;
// iY -= this._iBlockSize * 8;
// iWidth += this._iBlockSize * 16;
// iHeight += this._iBlockSize * 16;
                iX1 = math.clamp(iX, 0, this.getWidthOrig(i));
                iY1 = math.clamp(iY, 0, this.getHeightOrig(i));
                iX2 = math.clamp(iX + iWidth, 0, this.getWidthOrig(i));
                iY2 = math.clamp(iY + iHeight, 0, this.getHeightOrig(i));

                var iAreaX1:  number  = math.clamp(iAreaX1, 0, this.getWidthOrig(i));
                var iAreaY1:  number  = math.clamp(iAreaY1, 0, this.getHeightOrig(i));
                var iAreaX2:  number  = math.clamp(iAreaX2, 0, this.getWidthOrig(i));
                var iAreaY2:  number  = math.clamp(iAreaY2, 0, this.getHeightOrig(i));

               	if(this._pXY[i-1].isLoaded){
/*Остальные область проверки*/
		   			this.getDataFromServer(i, iX1, iY1, iX2 - iX1, iY2 - iY1,                                                       iAreaX1,
                                       iAreaY1, iAreaX2 - iAreaX1, iAreaY2 - iAreaY1);
		   		}
		   		else {
		   			this._pXY[i].isLoaded = false;
		   		}
// this.getDataFromServer(i, iX1, iY1, iX2 - iX1, iY2 - iY1, /*Остальные область проверки*/iAreaX1,
//                        iAreaY1, iAreaX2 - iAreaX1, iAreaY2 - iAreaY1);
		    }

		    this._fTexCourdXOld = fTexCourdX;
		    this._fTexCourdYOld = fTexCourdY;
		}

		private _fThresHold:  number  = 0.1;
		private _bColored: bool = false;
		applyForRender(pRenderPass: IRenderPass): void {
			pRenderPass.setForeign("nTotalLevels", this._iMaxLevel - this._iMinLevel + 1);
			pRenderPass.setUniform("MIN_MEGATEXTURE_LEVEL", this._iMinLevel);
			pRenderPass.setUniform("threshold", this._fThresHold);
			pRenderPass.setUniform("bColored", this._bColored);

		    for (var i:  number  = 0; i < this._pTextures.length; i++) {
		    	this._pLoadStatusUniforms[i] = this._pXY[i].isLoaded ? 1 : 0;
		    	this._pTexcoordOffsetUniforms[i].set(this._pXY[i].iTexX, this._pXY[i].iTexY);
		    	this._pSamplerUniforms[i].texture = this._pTextures[i];
		    }

		    pRenderPass.setUniform("S_TERRAIN", this._pSamplerUniforms);
		    pRenderPass.setUniform("TEXTURE_LOAD_STATUS", this._pLoadStatusUniforms);
		    pRenderPass.setUniform("TEXTURE_LEVEL_OFFSET", this._pTexcoordOffsetUniforms);
		}

		getWidthOrig(iLevel:  number ):  number  {
			return this._v2iTextureLevelSize.x << (this._iMinLevel + iLevel);
		}

		getHeightOrig(iLevel:  number ):  number  {
			return this._v2iTextureLevelSize.y << (this._iMinLevel + iLevel);
		}

		setMinLevelTexture(pImg: IImg): void {
			this._pTextures[0].destroyResource();
			this._pTextures[0].loadImage(pImg);
			this._pXY[0].isLoaded = true;

			this.minLevelLoaded();
		}

		protected checkTextureSizeSettings(): bool {
			var v2iCountTexMin: IVec2 =  Vec2.stackCeil.set() ;
			var v2iCountTexMax: IVec2 =  Vec2.stackCeil.set() ;

			v2iCountTexMin.x = math.log2(this._v2iOriginalTextreMinSize.x/this._v2iTextureLevelSize.x);
			v2iCountTexMin.y = math.log2(this._v2iOriginalTextreMinSize.y/this._v2iTextureLevelSize.y);

			v2iCountTexMax.x = math.log2(this._v2iOriginalTextreMaxSize.x/this._v2iTextureLevelSize.x);
			v2iCountTexMax.y = math.log2(this._v2iOriginalTextreMaxSize.y/this._v2iTextureLevelSize.y);

			if (v2iCountTexMin.x !== v2iCountTexMin.y ||
				v2iCountTexMax.x !== v2iCountTexMax.y){
				return false;
			}

			if(v2iCountTexMax.x < v2iCountTexMin.x) {
				return false;
			}

			this._iMinLevel = v2iCountTexMin.x;
			this._iMaxLevel = v2iCountTexMax.x;

			return true;
		}

		protected createUniforms(): void {
			var iCountTex:  number  = this._iMaxLevel - this._iMinLevel + 1;

			this._pSamplerUniforms = new Array(iCountTex);
			this._pLoadStatusUniforms = new Array(iCountTex);
			this._pTexcoordOffsetUniforms = new Array(iCountTex);

			for(var i:  number  = 0; i < iCountTex; i++){
				this._pSamplerUniforms[i] = <IAFXSamplerState>{
					textureName: "",
					texture: this._pTextures[i],
					wrap_s: ETextureWrapModes.CLAMP_TO_EDGE,
					wrap_t: ETextureWrapModes.CLAMP_TO_EDGE,
					mag_filter: ETextureFilters.LINEAR,
					min_filter: ETextureFilters.LINEAR
				};

				this._pLoadStatusUniforms[i] = 0;
				this._pTexcoordOffsetUniforms[i] = new Vec2();
			}
		}


		protected rpcErrorOccured(pRPC: IRPC, pError: Error): void {
			this.disconnect(this._pRPC,  "error" ,  "rpcErrorOccured" , EEventTypes.BROADCAST);

			{ logger.setSourceLocation( "terrain/MegaTexture.ts" , 479 ); logger.warning("Server for MeagTexture not response. Connection can not be established. Report us please."); } ;
		}


		private _iTryCount:  number  = 0;
		protected loadMinTextureLevel(): void {

			var me: MegaTexture = this;
    		var sExt: string = "dds";

			this._pSectorLoadInfo[0][0] = (this._pEngine.getTimer().absoluteTime * 1000) >>> 0;
    		this._iTryCount++;

    		if(this._iTryCount > 5){
    			{ logger.setSourceLocation( "terrain/MegaTexture.ts" , 493 ); logger.criticalError("Server for MegaTexture not response. Wait time out exceeded. Report us please."); } ;
    		}

			this._pRPC.proc('loadMegaTexture', me._sSurfaceTextures, sExt, me._v2iOriginalTextreMinSize.x, me._v2iOriginalTextreMinSize.x,
				function (pError: IRPCError, pData: Uint8Array) {
					if(me._pXY[0].isLoaded){
						return;
					}

					if(!isNull(pError)){
						if(pError.code ===  2 ){
							me.loadMinTextureLevel();
						}
						else {
							{ logger.setSourceLocation( "terrain/MegaTexture.ts" , 507 ); logger.criticalError("Server for MegaTexture not response correctly. Report us please."); } ;
						}
						return;
					}

					var pTempImg: IImg = <IImg>me._pEngine.getResourceManager().imagePool.findResource(".megatexture.temp_image");

		            if(isNull(pTempImg)){
		                pTempImg = <IImg>me._pEngine.getResourceManager().imagePool.createResource(".megatexture.temp_image");
		            }

		            pTempImg.load(pData, sExt, function(isLoaded){
		            	me._pTextures[0].destroyResource();
						me._pTextures[0].loadImage(pTempImg);
						me._pXY[0].isLoaded = true;
						pTempImg.destroyResource();

						me.disconnect(me._pRPC,  "joined" ,  "loadMinTextureLevel" , EEventTypes.BROADCAST);
						me.disconnect(me._pRPC,  "error" ,  "rpcErrorOccured" , EEventTypes.BROADCAST);

						me.minLevelLoaded();
		            });
				});

// this.getDataFromServer(0, 0, 0, this._v2iOriginalTextreMinSize.x, this._v2iOriginalTextreMinSize.y);

		}

		protected getDataFromServer(iLevelTex:  number ,
						  iOrigTexX:  number , iOrigTexY:  number ,
						  iWidth:  number , iHeight:  number ,
						  iAreaX?:  number , iAreaY?:  number ,
						  iAreaWidth?:  number , iAreaHeight?:  number ): void
		{
/** this._pXY[iLevelTex].width / this._v2iTextureLevelSize.x*/
		    var iBlockSize:  number  = this._iBlockSize                                                               ;

		    var iOrigTexEndX:  number  = math.ceil((iOrigTexX + iWidth) / iBlockSize) * iBlockSize;
		    var iOrigTexEndY:  number  = math.ceil((iOrigTexY + iHeight) / iBlockSize) * iBlockSize;
		    iOrigTexX = math.max(0, iOrigTexX);
		    iOrigTexY = math.max(0, iOrigTexY);
// iOrigTexX = math.floor(iOrigTexX / iBlockSize) * iBlockSize;
// iOrigTexY = math.floor(iOrigTexY / iBlockSize) * iBlockSize;
		    iOrigTexEndX = math.min(iOrigTexEndX, this.getWidthOrig(iLevelTex));
		    iOrigTexEndY = math.min(iOrigTexEndY, this.getHeightOrig(iLevelTex));

		    var iAreaEndX:  number  = iAreaX + iAreaWidth;
		    var iAreaEndY:  number  = iAreaY + iAreaHeight;
		    iAreaX = math.max(0, iAreaX);
		    iAreaY = math.max(0, iAreaY);
		    iAreaEndX = math.min(iAreaEndX, this.getWidthOrig(iLevelTex));
		    iAreaEndY = math.min(iAreaEndY, this.getHeightOrig(iLevelTex));

		    var isLoaded: bool = true;
		    var tCurrentTime:  number  = (this._pEngine.getTimer().absoluteTime * 1000) >>> 0;

		    for (var i:  number  = iOrigTexY; i < iOrigTexEndY; i += iBlockSize) {
		        for (var j:  number  = iOrigTexX; j < iOrigTexEndX; j += iBlockSize) {
		        	var iSectorInfoCoord:  number  = (i - this._pXY[iLevelTex].iY) / iBlockSize *
	                                             (this._pXY[iLevelTex].width / iBlockSize) +
	                                             (j - this._pXY[iLevelTex].iX) / iBlockSize;

	                if (this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] !== 0xFFFFFFFF) {
	                    isLoaded = false;
	                }

	                if (tCurrentTime - this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] < this._iSectorLifeTime) {
	                    continue;
	                }
	                if (this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] === 0xFFFFFFFF) {
	                    continue;
	                }

	                this._pSectorLoadInfo[iLevelTex][iSectorInfoCoord] = tCurrentTime;

		            var iLev:  number  = iLevelTex;
		            var iX:  number  = j, iY:  number  = i;

		            var iXBuf:  number  = j - this._pXY[iLevelTex].iX;
		            var iYBuf:  number  = i - this._pXY[iLevelTex].iY;

		            if (iXBuf < 0 || iXBuf > this._pXY[iLevelTex].width - iBlockSize ||
	                  	iYBuf < 0 || iYBuf > this._pXY[iLevelTex].height - iBlockSize)
		            {
	                	return;
	                }

	                this._iQueryCount ++;

		            this.getDataByRPC(iLevelTex, j, i, iBlockSize);
		        }
		    }
		   this._pXY[iLevelTex].isLoaded = isLoaded;
		}

		private _iTrafficCounter:  number  = 0;
		private _iResponseCount:  number  = 0;
		private _iQueryCount:  number  = 0;

		private _printTraffic(): void {
			{ logger.setSourceLocation( "terrain/MegaTexture.ts" , 606 ); logger.log(this._iTrafficCounter/1000000 + "Mb", this._iQueryCount + "/" + this._iResponseCount); } ;
		}

		private _fnPRCCallBack: Function = null;

		private getDataByRPC(iLev:  number , iX:  number , iY:  number , iBlockSize:  number ): void {
			var me: MegaTexture = this;

			if(isNull(this._fnPRCCallBack)){
				this._fnPRCCallBack = function (pError: Error, pData: Uint8Array) {

					if(!isNull(pError)){
// debug_print(pError.message);
						return;
					}

					me._iTrafficCounter += pData.length;
					var pHeaderData: Uint16Array = new Uint16Array(pData.buffer, pData.byteOffset, 4);
					var pTextureData: Uint8Array = pData.subarray(8);
					var iLev:  number  = math.log2(pHeaderData[0]/me._v2iTextureLevelSize.x) - me._iMinLevel;
					var iBlockSize:  number  = pHeaderData[1];
					var iX:  number  = pHeaderData[2];
					var iY:  number  = pHeaderData[3];

// var pTextureData = this.pDataList[this._iMinLevel + iLev];
// pHeaderData.set(pData.subarray(0, 8));

					var iXBuf:  number  = iX - me._pXY[iLev].iX;
					var iYBuf:  number  = iY - me._pXY[iLev].iY;

					if (iXBuf < 0 || iXBuf > me._pXY[iLev].width - iBlockSize ||
						iYBuf < 0 || iYBuf > me._pXY[iLev].height - iBlockSize) {
						return;
					}

					var iSectorInfoCoord:  number  = iYBuf / iBlockSize *
												 (me._pXY[iLev].width / iBlockSize) +
												 iXBuf / iBlockSize;

					if(me._pSectorLoadInfo[iLev][iSectorInfoCoord] === 0xFFFFFFFF){
						return;
					}

					me._iResponseCount++;
					me._pSectorLoadInfo[iLev][iSectorInfoCoord] = 0xFFFFFFFF;

					var pTmpBox1: IBox = geometry.box(0, 0, iBlockSize, iBlockSize);
					var pTmpBox2: IBox = geometry.box(iXBuf, iYBuf, iBlockSize + iXBuf, iBlockSize + iYBuf);

					var pSourceBox: IPixelBox = pixelUtil.pixelBox(pTmpBox1, me._eTextureFormat, pTextureData);

					me._pTextures[iLev].getBuffer(0, 0).blitFromMemory(pSourceBox, pTmpBox2);
					pSourceBox.data = null;
				};
			}

			this._pRPC.proc('getMegaTexture', me._sSurfaceTextures, me.getWidthOrig(iLev), me.getHeightOrig(iLev), iX,
                iY, iBlockSize, iBlockSize, me._eTextureFormat, this._fnPRCCallBack);
		}

		protected setDataT(pBuffer, iX:  number , iY:  number , iWidth:  number , iHeight:  number , pBufferIn, iInX:  number , iInY:  number , iInWidth:  number , iInHeight:  number , iBlockWidth:  number , iBlockHeight:  number , iComponents:  number ): void {
			iBlockHeight = math.max(0, iBlockHeight);
			iBlockWidth = math.max(0, iBlockWidth);
			iBlockHeight = math.min(iBlockHeight, iHeight - iY, iInHeight - iInY);
			iBlockWidth = math.min(iBlockWidth, iWidth - iX, iInWidth - iInX);

			if (pBuffer.length < ((iY + iBlockHeight - 1) * iWidth + iX + iBlockWidth) * iComponents) {
			    { logger.setSourceLocation( "terrain/MegaTexture.ts" , 673 ); logger.error("Выход за предел массива 1"); } ;
			}
			if (pBufferIn.length < ((iInY + iBlockHeight - 1) * iInWidth + iInX + iBlockWidth) * iComponents) {
			    { logger.setSourceLocation( "terrain/MegaTexture.ts" , 676 ); logger.error("Выход за предел массива 2"); } ;
			}

			var iLenStr:  number  = iBlockWidth * iComponents;
			var iStartIn:  number  = 0;
			var iStartOut:  number  = 0;
			for (var i:  number  = 0; i < iBlockHeight; i++) {
			    iStartIn = ((iInY + i) * iInWidth + iInX) * iComponents;
			    iStartOut = ((iY + i) * iWidth + iX) * iComponents;

			    if (pBufferIn.BYTES_PER_ELEMENT == 8) {
			        pBuffer.set(new Float64Array(pBufferIn.buffer.slice(iStartIn * 8, (iStartIn + iLenStr) * 8)), iStartOut);
			    } else if (pBufferIn.BYTES_PER_ELEMENT == 4) {
			        pBuffer.set(new Uint32Array(pBufferIn.buffer.slice(iStartIn * 4, (iStartIn + iLenStr) * 4)), iStartOut);
			    } else if (pBufferIn.BYTES_PER_ELEMENT == 2) {
			        pBuffer.set(new Uint16Array(pBufferIn.buffer.slice(iStartIn * 2, (iStartIn + iLenStr) * 2)), iStartOut);
			    } else {
			        pBuffer.set(new Uint8Array(pBufferIn.buffer.slice(iStartIn, iStartIn + iLenStr)), iStartOut);
			    }

			}
		}

		private _setDataBetweenBufferMap(pBuffer, iX:  number , iY:  number , pBufferIn, iInX:  number , iInY:  number , iBlockWidth:  number , iBlockHeight:  number ): void {
		    var iInWidth:  number     = this._iBufferWidth / this._iBlockSize;
		    var iInHeight:  number    = this._iBufferHeight / this._iBlockSize;
		    var iComponents:  number  = 1;
		    var iWidth:  number       = this._iBufferWidth / this._iBlockSize;
		    var iHeight:  number      = this._iBufferHeight / this._iBlockSize;
		    this.setDataT(pBuffer, iX, iY, iWidth, iHeight, pBufferIn, iInX, iInY, iInWidth, iInHeight, iBlockWidth, iBlockHeight, iComponents);
		}

		protected setSectorLoadInfoToDefault(pBuffer: Uint32Array): void {
			pBuffer.set(this._pDefaultSectorLoadInfo, 0);
		}


		private pDataList: Uint8Array[] = new Array(8);
		private testDataInit(): void {
			for(var i:  number  = 0; i < this.pDataList.length; i++){
				this.pDataList[i] = new Uint8Array(this._iBlockSize * this._iBlockSize * 3);

				var iLev = i;
				var pData = this.pDataList[i];

				for(var k:  number  = 0; k < pData.length; k+= 3){
		          	if(iLev === 0){
		              	pData[k] = 0;
		              	pData[k + 1] = 255;
		              	pData[k + 2] = 0;
		          	}
		          	else if(iLev === 1){
		          		pData[k] = 255;
		              	pData[k + 1] = 0;
		              	pData[k + 2] = 0;
		          	}
		          	else if(iLev === 2) {
		          		pData[k] = 0;
		              	pData[k + 1] = 0;
		              	pData[k + 2] = 255;
		          	}
		          	else if(iLev === 3){
		          		pData[k] = 255;
		              	pData[k + 1] = 0;
		              	pData[k + 2] = 255;
		          	}
		          	else if(iLev === 4){
		          		pData[k] = 255;
		              	pData[k + 1] = 255;
		              	pData[k + 2] = 0;
		          	}
		          	else if(iLev === 5) {
		          		pData[k] = 0;
		              	pData[k + 1] = 255;
		              	pData[k + 2] = 255;
		          	}
		          	else {
		              	pData[k] = 170;
		                pData[k + 1] = 50;
		                pData[k + 2] = 170;
		          	}
	          	}
			}
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return MegaTexture._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		minLevelLoaded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).minLevelLoaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;

	}
}















module akra {
	;
	;
	;
	;
	;

	export interface ITerrainSection extends ISceneObject {
		 sectorX:  number ;
		 sectorY:  number ;
		 terrainSystem: ITerrain;
		 sectionIndex:  number ;
		 heightY:  number ;
		 heightX:  number ;
		 vertexDescription: IVertexElementInterface[];

		_internalCreate(pParentSystem: ITerrain,
						iSectorX:  number , iSectorY:  number ,
						iHeightMapX:  number , iHeightMapY:  number ,
						iXVerts:  number , iYVerts:  number ,
						pWorldRect: IRect2d): bool;
		_createRenderable(): void;
	}
}














module akra.terrain {
	export class TerrainSection implements ITerrainSection extends scene.SceneObject{
		private _pTerrainSystem: ITerrain = null;

		protected _iVertexID:  number  = 0;
//Ее коорлинаты на карте высот
		protected _iHeightMapX:  number  = 0;
	    protected _iHeightMapY:  number  = 0;
//номер сектора по иксу и по игрику
	    protected _iSectorX:  number  = 0;
	    protected _iSectorY:  number  = 0;
	    protected _iSectorIndex:  number  = 0;
//Ращмеры сетки вершин
	    protected _iXVerts:  number  = 0;
	    protected _iYVerts:  number  = 0;
//Положение сетора в мире
	    protected _pWorldRect: IRect3d = new geometry.Rect3d();
	    private _pRenderableObject: IRenderableObject = null;
	    private _pVertexDescription: IVertexElementInterface[] = null;

		constructor(pScene: IScene3d, eType: EEntityTypes = EEntityTypes.TERRAIN_SECTION) {
			super(pScene, eType);
		}

		/**@inline*/  get sectorX():  number  {
			return this._iSectorX;
		};

		/**@inline*/  get sectorY():  number {
			return this._iSectorY;
		};

		/**@inline*/  get terrainSystem(): ITerrain{
			return this._pTerrainSystem;
		};

		/**@inline*/  get sectionIndex():  number  {
			return this._iSectorIndex;
		}

		/**@inline*/  get heightX():  number  {
			return math.abs(this._pWorldRect.x1-this._pWorldRect.x0);
		};

		/**@inline*/  get heightY():  number  {
			return math.abs(this._pWorldRect.y1-this._pWorldRect.y0);
		};

		/**@inline*/  get vertexDescription(): IVertexElementInterface[]{
			return this._pVertexDescription;
		};

		/**@inline*/  get totalRenderable():  number  {
			return !isNull(this._pRenderableObject) ? 1 : 0;
		}

		/**@inline*/  getRenderable(i?:  number ): IRenderableObject {
			return this._pRenderableObject;
		}


		_internalCreate(pParentSystem: ITerrain,
						iSectorX:  number , iSectorY:  number ,
						iHeightMapX:  number , iHeightMapY:  number ,
						iXVerts:  number , iYVerts:  number ,
						pWorldRect: IRect2d): bool {

			var bResult: bool = false;

			this._pTerrainSystem = pParentSystem;
			this._iXVerts = iXVerts;
			this._iYVerts = iYVerts;
			this._iSectorX = iSectorX;
			this._iSectorY = iSectorY;
			this._iSectorIndex = (this._iSectorY * this._pTerrainSystem.sectorCountX +  this._iSectorX);
			this._pWorldRect.x0 = pWorldRect.x0;
			this._pWorldRect.x1 = pWorldRect.x1;
			this._pWorldRect.y0 = pWorldRect.y0;
//??
			this._pWorldRect.y1 = pWorldRect.y1;
			this._iHeightMapX = iHeightMapX;
			this._iHeightMapY = iHeightMapY;

			if(this.terrainSystem._useVertexNormal()) {
				this._pVertexDescription = [VE_FLOAT3(DeclarationUsages.POSITION), VE_FLOAT3(DeclarationUsages.NORMAL), VE_FLOAT2(DeclarationUsages.TEXCOORD)];
			}
			else {
				this._pVertexDescription = [VE_FLOAT3(DeclarationUsages.POSITION), VE_FLOAT2(DeclarationUsages.TEXCOORD)];
			}

			bResult = this._createRenderDataForVertexAndIndex();
			bResult = bResult && this._buildVertexBuffer();
			bResult = bResult && this._buildIndexBuffer();

// set the scene object bounds data
			this.accessLocalBounds().set(this._pWorldRect.x0,
										 this._pWorldRect.x1,
										 this._pWorldRect.y0,
										 this._pWorldRect.y1,
										 this._pWorldRect.z0,
										 this._pWorldRect.z1);

			if(bResult) {
				this.attachToParent(this._pTerrainSystem);
				this.setInheritance(ENodeInheritance.ALL);

				return true;
			}
			else {
				return false;
			}
		};

		_createRenderable(): void {
			if(isNull(this._pRenderableObject)){
				this._pRenderableObject = new render.RenderableObject();
				this._pRenderableObject._setup(this.scene.getManager().getEngine().getRenderer());
			}
		}

		protected _createRenderDataForVertexAndIndex(): bool {
			var pRenderable: IRenderableObject = this.getRenderable();

			if(isNull(pRenderable)){
				return true;
			}

			{ logger.setSourceLocation( "terrain/TerrainSection.ts" , 137 ); logger.assert(isNull(pRenderable.data), "У терраин сектиона уже созданы данные"); } ;

			pRenderable._setRenderData(this.terrainSystem.dataFactory.getEmptyRenderData(EPrimitiveTypes.TRIANGLESTRIP,0));

			if(isNull(pRenderable.data)) {
				return false;
			}

			return true;
		}

		protected _buildVertexBuffer(): bool {
			this._pWorldRect.z0 = MAX_FLOAT64;
			this._pWorldRect.z1 = MIN_FLOAT64;

			if(!isNull(this.getRenderable())){
				var nElementSize:  number  = 0;
				if(this.terrainSystem._useVertexNormal()){
/*кординаты вершин*/
/*нормаль*/
/*текстурные координаты*/
					nElementSize = (3                                    + 3                   + 2                                             );
				}
				else {
/*кординаты вершин*/
/*текстурные координаты*/
					nElementSize =  (3                                    + 2                                             );
				}

				var pVerts:  number [] = new Array(this._iXVerts * this._iYVerts * nElementSize);
				var v3fNormal: IVec3 = new Vec3();

//размер ячейки сектора
				var v2fCellSize: IVec2 = new Vec2();
				v2fCellSize.set(this.heightX / (this._iXVerts-1),
//размер сектора/количество ячеек в секторе
					this.heightY / (this._iYVerts-1));

//Координаты вершина в секторе
				var v2fVert: IVec2 = new Vec2();
				v2fVert.set(0.0, 0.0);

				for (var y:  number  = 0; y < this._iYVerts; ++y) {

					v2fVert.set(this._pWorldRect.x0, y * v2fCellSize.y+this._pWorldRect.y0);

					for (var x:  number  = 0; x < this._iXVerts; ++x) {

						var fHeight:  number  = this.terrainSystem.readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);

						pVerts[((y * this._iXVerts) + x) * nElementSize + 0] = v2fVert.x;
						pVerts[((y * this._iXVerts) + x) * nElementSize + 1] = v2fVert.y;
						pVerts[((y * this._iXVerts) + x) * nElementSize + 2] = fHeight;

						if(this.terrainSystem._useVertexNormal()){
							this.terrainSystem.readWorldNormal(v3fNormal, this._iHeightMapX + x, this._iHeightMapY + y);

							pVerts[((y * this._iXVerts) + x) * nElementSize + 3] = v3fNormal.x;
							pVerts[((y * this._iXVerts) + x) * nElementSize + 4] = v3fNormal.y;
							pVerts[((y * this._iXVerts) + x) * nElementSize + 5] = v3fNormal.z;

							pVerts[((y * this._iXVerts) + x) * nElementSize + 6] = (this._iSectorX + x / (this._iXVerts - 1))/this.terrainSystem.sectorCountX;
							pVerts[((y * this._iXVerts) + x) * nElementSize + 7] = (this._iSectorY + y / (this._iYVerts - 1))/this.terrainSystem.sectorCountY;
						}
						else {
							pVerts[((y * this._iXVerts) + x) * nElementSize + 3] = (this._iSectorX + x / (this._iXVerts - 1))/this.terrainSystem.sectorCountX;
							pVerts[((y * this._iXVerts) + x) * nElementSize + 4] = (this._iSectorY + y / (this._iYVerts - 1))/this.terrainSystem.sectorCountY;
						}

						this._pWorldRect.z0 = math.min(this._pWorldRect.z0, fHeight);
						this._pWorldRect.z1 = math.max(this._pWorldRect.z1, fHeight);

						v2fVert.x += v2fCellSize.x;
					}
				}

				this._iVertexID = this.getRenderable().data.allocateData(this.vertexDescription, new Float32Array(pVerts));
			}
			else {
				for (var y:  number  = 0; y < this._iYVerts; ++y) {
					for (var x:  number  = 0; x < this._iXVerts; ++x) {
						var fHeight:  number  = this.terrainSystem.readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);

						this._pWorldRect.z0 = math.min(this._pWorldRect.z0, fHeight);
						this._pWorldRect.z1 = math.max(this._pWorldRect.z1, fHeight);
					}
				}
			}

			return true;
		}

		protected _buildIndexBuffer(): bool {
			if(!isNull(this.getRenderable())){
				var pIndexList: Float32Array = new Float32Array(TerrainSection.getCountIndexForStripGrid(this._iXVerts, this._iYVerts));

				TerrainSection.createSingleStripGrid(pIndexList,
/*width of grid*/
									this._iXVerts,
/*height of grid*/
									this._iYVerts,
/*horz vertex count per cell*/
									1,
/*vert vertex count per cell*/
									1,
/*horz vertex count in vbuffer*/
									this._iYVerts,
									0);

				this.getRenderable().data.allocateIndex([VE_FLOAT(DeclarationUsages.INDEX0)], pIndexList);
				this.getRenderable().data.index(this._iVertexID, DeclarationUsages.INDEX0);
			}
			return true;
		}

		static protected createSingleStripGrid (pIndexValues: Float32Array, iXVerts:  number , iYVerts:  number , iXStep:  number , iYStep:  number , iSride:  number , iFlags:  number ):  number {
//TRIANGLESTRIP
		    var iTotalStrips:  number  = iYVerts - 1;
		    var iTotalIndexesPerStrip:  number  = iXVerts << 1;

// the total number of indices is equal
// to the number of strips times the
// indices used per strip plus one
// degenerate triangle between each strip

//общее количество идексов равно количесву линий умноженному на колчесвто идексов в линии + вырожденный треуголник между полосами

		    var iTotalIndexes:  number  = (iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1) - 2;

		    if(pIndexValues.length < iTotalIndexes)
			{
				return 0;
			}

		    var iIndex:  number  = 0;
		    var iStartVert:  number  = 0;
		    var iLineStep:  number  = iYStep * iSride;

		    for (var j:  number  = 0; j < iTotalStrips; ++j) {
		        var k:  number  = 0;
		        var iVert:  number  = iStartVert;
// create a strip for this row
		        for (k = 0; k < iXVerts; ++k) {
		            pIndexValues[iIndex++] = iVert;
		            pIndexValues[iIndex++] = iVert + iLineStep;
		            iVert += iXStep;
		        }
		        iStartVert += iLineStep;

		        if (j + 1 < iTotalStrips) {
// add a degenerate to attach to
// the next row
		            pIndexValues[iIndex++] = (iVert - iXStep) + iLineStep;
		            pIndexValues[iIndex++] = iStartVert;
		        }
		    }

// return
		    return iTotalIndexes;
		}

		static protected getCountIndexForStripGrid(iXVerts:  number , iYVerts:  number ):  number  {
//TRIANGLESTRIP
			var iTotalStrips:  number  = iYVerts - 1;
			var iTotalIndexesPerStrip:  number  = iXVerts << 1;
			var iTotalIndexes:  number  = (iTotalStrips * iTotalIndexesPerStrip) + (iTotalStrips << 1) - 2;
			return iTotalIndexes;
		}

	}
}


















module akra.terrain {

	export class Terrain extends scene.SceneObject implements ITerrain {
		protected _pEngine: IEngine = null;
// private _pDevice = null;

		protected _pWorldExtents: IRect3d = new geometry.Rect3d();
		private _v3fWorldSize: IVec3 = new Vec3();
		private _v3fMapScale: IVec3 = new Vec3();
//количество секций по иксу
		protected _iSectorCountX:  number ;
//количество секций по игрику
		protected _iSectorCountY:  number ;
//массив подчиненный секций 
		protected _pSectorArray: ITerrainSection[] = null;


		protected _pDataFactory: IRenderDataCollection = null;

		protected _v2fSectorSize: IVec2 = new Vec2();

		protected _iSectorShift:  number ;
//Количество секторов по осям
		protected _iSectorUnits:  number ;
		protected _iSectorVerts:  number ;

//размер карты высот
		protected _iTableWidth:  number ;
//размер карты высот
		protected _iTableHeight:  number ;
//Таблица(карта высот)
		protected _pHeightTable: Float32Array = null;

		private _pNormalMapTexture: ITexture = null;
		private _pNormalMapImage: IImg = null;

		private _pBaseNormalTexture: ITexture = null;
		private _pBaseNormalImage: IImg = null;

		private _pHeightMapTexture: ITexture = null;

		private _pTempNormalColor: IColor = new Color();

//отоброжаемые куски текстуры
		private _pMegaTexures: IMegaTexture = null;
		protected _bUseVertexNormal: bool = false;

		protected _pDefaultRenderMethod: IRenderMethod = null;
		protected _pRenderMethod: IRenderMethod = null;
		protected _pDefaultScreen: IRenderableObject = null;

		private _fMaxHeight:  number  = 0.;
		private _f2DDiagonal:  number  = 0.;

		protected _isCreate: bool = false;
		protected _bManualMegaTextureInit: bool = false;
		protected _bShowMegaTexture: bool = true;
		protected _bMegaTextureCreated: bool = false;
		protected _sSurfaceTextures: string = "";

		constructor(pScene: IScene3d, eType: EEntityTypes = EEntityTypes.TERRAIN) {
			super(pScene, eType);
			this._pEngine = pScene.getManager().getEngine();
			this._pDataFactory = render.createRenderDataCollection(this._pEngine, ERenderDataBufferOptions.VB_READABLE);


			this._pMegaTexures = new MegaTexture(this._pEngine);

		}

		/**@inline*/  get dataFactory(): IRenderDataCollection{
			return this._pDataFactory;
		};

		/**@inline*/  get worldExtents(): IRect3d{
			return this._pWorldExtents;
		};

		/**@inline*/  get worldSize(): IVec3{
			return this._v3fWorldSize;
		};

		/**@inline*/  get mapScale(): IVec3{
			return this._v3fMapScale;
		};

		/**@inline*/  get sectorCountX():  number {
			return this._iSectorCountX;
		};

		/**@inline*/  get sectorCountY():  number {
			return this._iSectorCountY;
		};

		/**@inline*/  get sectorSize(): IVec2{
			return this._v2fSectorSize;
		};

		/**@inline*/  get tableWidth():  number {
			return this._iTableWidth;
		};

		/**@inline*/  get tableHeight():  number {
			return this._iTableHeight;
		};

		/**@inline*/  get sectorShift():  number {
			return this._iSectorShift;
		};

		/**@inline*/  get maxHeight():  number {
			return this._fMaxHeight;
		};

		/**@inline*/  get terrain2DLength():  number {
			return this._f2DDiagonal;
		};

		/**@inline*/  isCreate(): bool {
			return this._isCreate;
		}

		/**@inline*/  get megaTexture(): IMegaTexture {
			return this._pMegaTexures;
		}

		/**@inline*/  get manualMegaTextureInit(): bool {
			return this._bManualMegaTextureInit;
		}

		/**@inline*/  set manualMegaTextureInit(bManual: bool) {
			this._bManualMegaTextureInit = bManual;
		}

		/**@inline*/  get showMegaTexture(): bool {
			return this._bShowMegaTexture;
		}

		/**@inline*/  set showMegaTexture(bShow: bool) {
			this._bShowMegaTexture = bShow;
		}

		protected _initSystemData(): bool {
			var pEngine: IEngine = this._pEngine,
			    pRmgr: IResourcePoolManager = pEngine.getResourceManager();

			if(isNull(this._pDefaultRenderMethod)){
				var pMethod: IRenderMethod = null,
					pEffect: IEffect = null;

			    pMethod = <IRenderMethod>pRmgr.renderMethodPool.findResource(".terrain_render");

			    if (!isNull(pMethod)) {
			        this._pDefaultRenderMethod = pMethod;
			        return true;
			    }

			    pEffect = pRmgr.createEffect(".terrain_render");
			    pEffect.addComponent("akra.system.terrain");

			    pMethod = pRmgr.createRenderMethod(".terrain_render");
			    pMethod.effect = pEffect;
			    pMethod.surfaceMaterial = pRmgr.createSurfaceMaterial(".terrain_render");
			    var pMat: IMaterial = pMethod.surfaceMaterial.material;
			    pMat.name = "terrain";

			    pMat.shininess = 30;
			    (<IColor>pMat.emissive).set(0);
			    (<IColor>pMat.specular).set(1);



			    this._pDefaultRenderMethod = pMethod;
			}

			if(isNull(this._pDefaultScreen)){
				this._pDefaultScreen = new render.Screen(pEngine.getRenderer());

				var pMethod: IRenderMethod = null,
					pEffect: IEffect = null;

				pMethod = <IRenderMethod>pRmgr.renderMethodPool.findResource(".terrain_generate_normal");

				if(isNull(pMethod)){
					pEffect = pRmgr.createEffect(".terrain_generate_normal");
					pEffect.addComponent("akra.system.generateNormalMapByHeightMap");

					pMethod = pRmgr.createRenderMethod(".terrain_generate_normal");
			    	pMethod.effect = pEffect;
				}

				this._pDefaultScreen.addRenderMethod(pMethod, ".terrain_generate_normal");

				this.connect(this._pDefaultScreen.getTechnique(".terrain_generate_normal"),  "render" ,  "_onGenerateNormalRender" );
			}

		    return true;
		}

		init(pMap: IImageMap, worldExtents: IRect3d, iShift:  number , iShiftX:  number , iShiftY:  number , sSurfaceTextures: string, pRootNode?: ISceneNode = null): bool {
			if(!isNull(pRootNode)) {
				if(!this.attachToParent(pRootNode)) {
					return false;
				}
			}

			this._initSystemData();
//Основные параметры
			this._iSectorShift = iShift;
			this._iSectorUnits = 1 << iShift;
			this._iSectorVerts = this._iSectorUnits + 1;

			this._pWorldExtents = new geometry.Rect3d(worldExtents.x0, worldExtents.x1, worldExtents.y0, worldExtents.y1,
			                                   worldExtents.z0, worldExtents.z1)
			this._pWorldExtents.normalize();
			this._v3fWorldSize = this._pWorldExtents.size(this._v3fWorldSize);

//this._iTableWidth >> this._iSectorShift;
			this._iSectorCountX = 1 << iShiftX;
//this._iTableHeight >> this._iSectorShift;
			this._iSectorCountY = 1 << iShiftY;

			this._iTableWidth = this._iSectorCountX * this._iSectorUnits + 1;
			this._iTableHeight = this._iSectorCountY * this._iSectorUnits + 1;


			this._v2fSectorSize.set(this._v3fWorldSize.x / this._iSectorCountX, this._v3fWorldSize.y / this._iSectorCountY);

			this._v3fMapScale.x = this._v3fWorldSize.x / this._iTableWidth;
			this._v3fMapScale.y = this._v3fWorldSize.y / this._iTableHeight;
			this._v3fMapScale.z = this._v3fWorldSize.z;

// convert the height map to
// data stored in local tables
			this._buildHeightAndNormalTables(pMap["height"], pMap["normal"]);

			for (var sImgMap in pMap) {
			    if (pMap[sImgMap].destroyResource) {
			        pMap[sImgMap].destroyResource();
			    }
			}

			if(!this._allocateSectors()){
				{ logger.setSourceLocation( "terrain/Terrain.ts" , 262 ); logger.error("Can not alloacte terrain sections"); } ;
				return false;
			}

			this.computeBoundingBox();


			this._sSurfaceTextures = sSurfaceTextures;
			if(!this._bManualMegaTextureInit){
//Мегатекстурные параметры
				this.initMegaTexture(sSurfaceTextures);
			}


			this._isCreate = true;

			return true;
		}

		initMegaTexture(sSurfaceTextures?: string = this._sSurfaceTextures): void {

			this._pMegaTexures.init(this, sSurfaceTextures);
			this._bMegaTextureCreated = true;

		}

		findSection(iX:  number , iY:  number ) {
			var pSection: ITerrainSection = null;

			if (iX >= 0 && iX < this._iSectorCountX &&
				iY >= 0 && iY < this._iSectorCountY) {
			    pSection = this._pSectorArray[(iY * this._iSectorCountX) + iX];
			}
			else {
// if we had additional cRoamTerrain objects,
// we could reach out here to link with neighbors
			}

			return pSection;
		}

		protected _allocateSectors(): bool {
			this._pSectorArray = new Array(this._iSectorCountX * this._iSectorCountY);

// create the sector objects themselves
			for (var y:  number  = 0; y < this._iSectorCountY; ++y) {
			    for (var x:  number  = 0; x < this._iSectorCountX; ++x) {
			    	var v2fSectorPos: IVec2 = new Vec2();
					var r2fSectorRect: IRect2d = new geometry.Rect2d();

			        v2fSectorPos.set(
			            this._pWorldExtents.x0 + (x * this._v2fSectorSize.x),
			            this._pWorldExtents.y0 + (y * this._v2fSectorSize.y));

			        r2fSectorRect.set(
			            v2fSectorPos.x, v2fSectorPos.x + this._v2fSectorSize.x,
			            v2fSectorPos.y, v2fSectorPos.y + this._v2fSectorSize.y);

			        var iXPixel:  number  = x << this._iSectorShift;
			        var iYPixel:  number  = y << this._iSectorShift;
			        var iIndex:  number  = (y * this._iSectorCountX) + x;

			        this._pSectorArray[iIndex] = this.scene.createTerrainSection();
			        this._pSectorArray[iIndex]._createRenderable();

			        if (!this._pSectorArray[iIndex]._internalCreate(
			            this,
			            x, y,
			            iXPixel, iYPixel,
			            this._iSectorVerts,
			            this._iSectorVerts,
			            r2fSectorRect)) {
			            return false;
			        }
			    }
			}

			this._setRenderMethod(this._pDefaultRenderMethod);

			return true;
		}

		protected _setRenderMethod(pRenderMethod: IRenderMethod): void {
		    this._pRenderMethod = pRenderMethod;

		    if (this._pRenderMethod) {
		        this._pRenderMethod.addRef();
		    }

		    var pSection: ITerrainSection = null;

		    for (var i = 0; i < this._pSectorArray.length; i++) {
		        pSection = this._pSectorArray[i];

		        pSection.getRenderable().getTechnique().setMethod(this._pDefaultRenderMethod);

		        this.connect(pSection.getRenderable().getTechnique(),  "render" ,  "_onRender" );
		    }
		}

		protected _buildHeightAndNormalTables(pImageHightMap: IImg, pImageNormalMap: IImg): void {
			    var fHeight:  number  = 0;
			    var iComponents:  number  = 4;
			    this._pHeightTable = null;


			    var iMaxY:  number  = this._iTableHeight;
			    var iMaxX:  number  = this._iTableWidth;

//var pColorData: Uint8Array = new Uint8Array(4 * iMaxY * iMaxX);
/*float*/
			    this._pHeightTable = new Float32Array(iMaxX * iMaxY);

// first, build a table of heights
			    if (pImageHightMap.isResourceLoaded()) {
			        if(pImageHightMap.width !== iMaxX && pImageHightMap.height !== iMaxY){
			        	{ logger.setSourceLocation( "terrain/Terrain.ts" , 378 ); logger.warning("Размеры карты высот не совпадают с другими размерами. Нужно: " + iMaxX + "x" + iMaxY + ". Есть: " + pImageHightMap.width + "x" + pImageHightMap.height); }
                                                                                                        ;
			        	return;
			        }

			        for (var iY:  number  = 0; iY < iMaxY; iY++) {
			        	for(var iX:  number  = 0; iX < iMaxX; iX++){
			        		fHeight = pImageHightMap.getColorAt(this._pTempNormalColor, iX, iY).r;
			        		fHeight = (fHeight * this._v3fMapScale.z) + this._pWorldExtents.z0;

			        		this._pHeightTable[iY*iMaxX + iX] = fHeight;
			        	}
			        }

			        if(this._useVertexNormal()){
			        	this.computeBaseNormal(pImageHightMap);
			        }
			    }
			    else {
			        { logger.setSourceLocation( "terrain/Terrain.ts" , 396 ); logger.warning("Height map not loaded"); }
			    }

			    if (pImageNormalMap.isResourceLoaded()) {
			    	this._pNormalMapTexture = this._pEngine.getResourceManager().createTexture(".terrain-normal-texture" + this.getGuid());
			        this._pNormalMapTexture.loadImage(pImageNormalMap);
			        this._pNormalMapImage = pImageNormalMap;
			    }
			    else {
			        { logger.setSourceLocation( "terrain/Terrain.ts" , 405 ); logger.warning("Normal map not loaded"); }
			    }
		}

		readWorldHeight(iIndex:  number ):  number ;
		readWorldHeight(iMapX:  number , iMapY:  number ):  number ;
		readWorldHeight(iMapX: any, iMapY?:  number ):  number  {
			if (arguments.length === 2) {
				var iFixedMapX:  number  = iMapX, iFixedMapY:  number  = iMapY;

			    if (iFixedMapX >= this._iTableWidth) {
			        iFixedMapX = this._iTableWidth - 1;
			    }
			    if (iFixedMapY >= this._iTableHeight) {
			        iFixedMapY = this._iTableHeight - 1;
			    }

			    return this._pHeightTable[(iFixedMapY * this._iTableWidth) + iFixedMapX];
			}
			else {
			    var iMapIndex:  number  = iMapX;
			    { logger.setSourceLocation( "terrain/Terrain.ts" , 426 ); logger.assert(iMapIndex < this._iTableWidth * this._iTableHeight, "invalid index"); } ;
			    return this._pHeightTable[iMapIndex];
			}
		}

		readWorldNormal(v3fNormal: IVec3, iMapX:  number , iMapY:  number ): IVec3 {
			if (iMapX >= this._pBaseNormalImage.width) {
			    iMapX = this._pBaseNormalImage.width - 1;
			}
			if (iMapY >= this._pBaseNormalImage.height) {
			    iMapY = this._pBaseNormalImage.height - 1;
			}

			this._pBaseNormalImage.getColorAt(this._pTempNormalColor, iMapX, iMapY);
			v3fNormal.set(this._pTempNormalColor.r,
			              this._pTempNormalColor.g,
			              this._pTempNormalColor.b);

			return v3fNormal;
		}

		projectPoint(v3fCoord: IVec3, v3fDestenation: IVec3): bool {
			var v4fTerrainCoord: IVec4 =  Vec4.stackCeil.set(v3fCoord, 1.) ;

		    v4fTerrainCoord = this.inverseWorldMatrix.multiplyVec4(v4fTerrainCoord);

		    if (v4fTerrainCoord.x < this.worldExtents.x0 || v4fTerrainCoord.x > this.worldExtents.x1 ||
		    	v4fTerrainCoord.y < this.worldExtents.y0 || v4fTerrainCoord.y > this.worldExtents.y1){

		    	return false;
		    }

		    var iMapX:  number  = math.floor((v4fTerrainCoord.x - this.worldExtents.x0) / this.worldExtents.sizeX() * this.tableWidth);
		    var iMapY:  number  = math.floor((v4fTerrainCoord.y - this.worldExtents.y0) / this.worldExtents.sizeY() * this.tableHeight);
		    var fHeight:  number  = this.readWorldHeight(iMapX, iMapY);

		    var v4fTempDestenation: IVec4 =  Vec4.stackCeil.set(v4fTerrainCoord.x, v4fTerrainCoord.y, fHeight, 1.) ;

		    v4fTempDestenation = this.worldMatrix.multiplyVec4(v4fTempDestenation);
		    v3fDestenation.set(v4fTempDestenation.x, v4fTempDestenation.y, v4fTempDestenation.z);

		    return true;
		}

/**
		 * Подготовка терраина к рендерингу.
		 */

		prepareForRender(pViewport: IViewport): void {

			if(this._bMegaTextureCreated && this._bShowMegaTexture){
				this._pMegaTexures.prepareForRender(pViewport);
			}

		}

/**
		 * Сброс параметров.
		 */

		reset(): void {
		}

		protected computeBaseNormal(pImageHightMap: IImg): void {
			var pRmgr: IResourcePoolManager = this._pEngine.getResourceManager();

			this._pHeightMapTexture = pRmgr.createTexture(".terrain-hight-texture" + this.getGuid());
			this._pHeightMapTexture.loadImage(pImageHightMap);

			this._pBaseNormalTexture = pRmgr.createTexture(".terrain-base-normal-texture" + this.getGuid());
			this._pBaseNormalTexture.create(pImageHightMap.width, pImageHightMap.height, 1, null,
											ETextureFlags.RENDERTARGET, 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.R8G8B8A8);

			var pTarget: IRenderTarget = this._pBaseNormalTexture.getBuffer().getRenderTarget();
			pTarget.setAutoUpdated(false);

			var pViewport: IViewport = pTarget.addViewport(new render.Viewport(null, ".terrain_generate_normal"));
			pViewport.setDepthParams(false, false, 0);
			pViewport.setClearEveryFrame(false);

			pViewport.startFrame();
			pViewport.renderObject(this._pDefaultScreen);
			pViewport.endFrame();

			this._pBaseNormalImage = pRmgr.createImg(".terrain-base-normal-img" + this.getGuid());
			this._pBaseNormalTexture.convertToImage(this._pBaseNormalImage, false);
		}

		_tableIndex(iMapX:  number , iMapY:  number ):  number  {
// clamp to the table dimensions
			if (iMapX >= this._iTableWidth) {
			    iMapX = this._iTableWidth - 1;
			}

			if (iMapY >= this._iTableHeight) {
			    iMapY = this._iTableHeight - 1;
			}

			return (iMapY * this._iTableWidth) + iMapX;
		}

		_useVertexNormal(): bool {
			return this._bUseVertexNormal;
		}

		protected computeBoundingBox(): void {
			var fX0:  number , fY0:  number , fZ0:  number ,
				fX1:  number , fY1:  number , fZ1:  number ;

			fX0 = fY0 = fZ0 = MAX_FLOAT64;
			fX1 = fY1 = fZ1 = MIN_FLOAT64;

			for(var i:  number  = 0; i < this._pSectorArray.length; i++) {
				var pSectionBox: IRect3d = this._pSectorArray[i].localBounds;

				fX0 = math.min(fX0, pSectionBox.x0);
				fY0 = math.min(fY0, pSectionBox.y0);
				fZ0 = math.min(fZ0, pSectionBox.z0);

				fX1 = math.max(fX1, pSectionBox.x1);
				fY1 = math.max(fY1, pSectionBox.y1);
				fZ1 = math.max(fZ1, pSectionBox.z1);
			}

			this.accessLocalBounds().set(fX0, fX1, fY0, fY1, fZ0, fZ1);

			this._fMaxHeight = fZ1 - fZ0;
			this._f2DDiagonal = math.sqrt((fX1 - fX0) * (fX1 - fX0) + (fY1 - fY0) * (fY1 - fY0));
		}

		_onRender(pTechnique: IRenderTechnique, iPass:  number ): void {
			var pPass: IRenderPass = pTechnique.getPass(iPass);

//pPass.setTexture("TEXTURE6", this._pBaseNormalTexture);
			pPass.setSamplerTexture("S_NORMAL_MAP", this._pNormalMapTexture);


			if(this._bMegaTextureCreated && this._bShowMegaTexture){
				this._pMegaTexures.applyForRender(pPass);
			}
			else {
				pPass.setUniform("S_TERRAIN", null);
				pPass.setForeign("nTotalLevels", 0);
			}

		}

		_onGenerateNormalRender(pTechnique: IRenderTechnique, iPass:  number ): void {

			var pPass: IRenderPass = pTechnique.getPass(iPass);

			pPass.setSamplerTexture("HEIGHT_SAMPLER", this._pHeightMapTexture);
			pPass.setUniform("STEPS",  Vec2.stackCeil.set(1./this._pHeightMapTexture.width, 1./this._pHeightMapTexture.height) );
			pPass.setUniform("SCALE", this._v3fMapScale.z);
			pPass.setUniform("CHANNEL", 0);
		}
	}
}













module akra {
	;
	;
	;
	;
	;
	;

	export interface ITerrainROAM extends ITerrain {
		tessellationScale:  number ;
		tessellationLimit:  number ;

		useTessellationThread: bool;

		 verts:  number [];
		 index: Float32Array;
		 maxTriTreeNodes:  number ;
		 vertexId:  number ;
		 localCameraCoord: IVec3;

		totalIndex:  number ;

		requestTriNode(): ITriTreeNode;

		addToTessellationQueue(pSection: ITerrainSectionROAM): bool;

		resetWithCamera(pCamera: ICamera): void;
	}
}















module akra {
	;
	;
	;
	;

	export interface ITerrainSectionROAM extends ITerrainSection{
		 triangleA: ITriTreeNode;
		 triangleB: ITriTreeNode;
		 queueSortValue:  number ;
		 terrainSystem: ITerrainROAM;

		_internalCreate(pParentSystem: ITerrainROAM,
						iSectorX:  number , iSectorY:  number ,
						iHeightMapX:  number , iHeightMapY:  number ,
						iXVerts:  number , iYVerts:  number ,
						pWorldRect: IRect2d, iStartIndex?:  number ): bool;

		_initTessellationData(): void;

		reset(): void;
		tessellate(fScale:  number , fLimit:  number ): void;
		buildTriangleList(): void;
	}
}








module akra.terrain {
	export class TerrainSectionROAM implements ITerrainSectionROAM extends TerrainSection{
		private _iTotalDetailLevels:  number ;
		private _iTotalVariances:  number ;
		private _iOffsetInVertexBuffer:  number ;

//два дерева треугольников
		private _pRootTriangleA: ITriTreeNode = new TriTreeNode();
		private _pRootTriangleB: ITriTreeNode = new TriTreeNode();

//Урове5нь погрещности для двух деревьев
		private _pVarianceTreeA:  number [] = null;
		private _pVarianceTreeB:  number [] = null;

//расстояние от камеры до углов секции
		private _v3fDistance0: IVec3 = new Vec3();
		private _v3fDistance1: IVec3 = new Vec3();
		private _v3fDistance2: IVec3 = new Vec3();
		private _v3fDistance3: IVec3 = new Vec3();

		private _fDistance0:  number ;
		private _fDistance1:  number ;
		private _fDistance2:  number ;
		private _fDistance3:  number ;

//Нименьшее растояние от камеры до секции, необходимо для очереди
		private _fQueueSortValue:  number ;


		private _leftNeighborOfA:  ITriTreeNode = null;
		private _rightNeighborOfA: ITriTreeNode = null;
		private _leftNeighborOfB:  ITriTreeNode = null;
		private _rightNeighborOfB: ITriTreeNode = null;

	    private _iStartIndex:  number  = undefined;

	    private _pTerrainSystem: ITerrainROAM = null;
	    private _iTempTotalIndices:  number  = undefined;
	    private _pTempIndexList: Float32Array = undefined;
	    private _iMaxIndices:  number  = undefined;

		constructor(pScene: IScene3d, eType: EEntityTypes = EEntityTypes.TERRAIN_SECTION_ROAM) {
			super(pScene, eType);
		}

		/**@inline*/  get terrainSystem(): ITerrainROAM{
			return this._pTerrainSystem;
		};

		/**@inline*/  get triangleA(): ITriTreeNode {
			return this._pRootTriangleA;
		}

		/**@inline*/  get triangleB(): ITriTreeNode {
			return this._pRootTriangleB;
		}

		/**@inline*/  get queueSortValue():  number  {
			return this._fQueueSortValue;
		}

		_internalCreate(pParentSystem: ITerrainROAM,
						iSectorX:  number , iSectorY:  number ,
						iHeightMapX:  number , iHeightMapY:  number ,
						iXVerts:  number , iYVerts:  number ,
						pWorldRect: IRect2d, iStartIndex?:  number ): bool {

			{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 74 ); logger.assert(arguments.length === 9, "Not valid arguments count."); } ;

			var iVerts:  number  = math.max(iXVerts, iYVerts)
			this._iStartIndex = iStartIndex;

			var bResult: bool = super._internalCreate(pParentSystem,
													iSectorX, iSectorY,
													iHeightMapX, iHeightMapY,
													iVerts, iVerts,
													pWorldRect);

			if(!(<ITerrainROAM>this.terrainSystem).useTessellationThread){
				this._initTessellationData();
			}

			return bResult;
		}

		_initTessellationData(): void {
			var iVerts:  number  = math.max(this._iXVerts, this._iYVerts);
			this._iTotalDetailLevels = 2*(math.round(math.log(iVerts - 1)/math.LN2));
			this._iTotalVariances = 1<<this._iTotalDetailLevels;

			this._pVarianceTreeA = new Array( this._iTotalVariances);
// this._pVarianceTreeA.set(0);

			this._pVarianceTreeB = new Array(this._iTotalVariances);
// this._pVarianceTreeB.set(0);
			for(var i:  number  = 0; i < this._iTotalVariances; i++) {
				this._pVarianceTreeA[i] = 0;
				this._pVarianceTreeB[i] = 0;
			}

			var pRoamTerrain: ITerrainROAM = this.terrainSystem;
			var pNorthSection: ITerrainSectionROAM = pRoamTerrain.findSection(this._iSectorX, this._iSectorY - 1);
			var pSouthSection: ITerrainSectionROAM = pRoamTerrain.findSection(this._iSectorX, this._iSectorY + 1);
			var pEastSection: ITerrainSectionROAM  = pRoamTerrain.findSection(this._iSectorX + 1, this._iSectorY);
			var pWestSection: ITerrainSectionROAM  = pRoamTerrain.findSection(this._iSectorX - 1, this._iSectorY);

			if (pNorthSection) {
				this._leftNeighborOfA = pNorthSection.triangleB;
			}

			if (pSouthSection) {
				this._leftNeighborOfB = pSouthSection.triangleA;
			}

			if (pEastSection) {
				this._rightNeighborOfB = pEastSection.triangleA;
			}

			if (pWestSection) {
				this._rightNeighborOfA = pWestSection.triangleB;
			}

// establish basic links
			this.reset();

// build the variance trees
			this.computeVariance();
		}

//private _v3fOldPosition: 
		prepareForRender(pViewport: IViewport): void {
			super.prepareForRender(pViewport);

			var pCamera: ICamera = pViewport.getCamera();

			if(!this.terrainSystem.resetWithCamera(pCamera)){
				return;
			}

			var v3fViewPoint: IVec3 = this.terrainSystem.localCameraCoord;

// compute view distance to our 4 corners
			var fHeight0:  number  = this.terrainSystem.readWorldHeight(math.ceil(this._iHeightMapX), math.ceil(this._iHeightMapY));
			var fHeight1:  number  = this.terrainSystem.readWorldHeight(math.ceil(this._iHeightMapX), math.ceil(this._iHeightMapY + this._iYVerts));
			var fHeight2:  number  = this.terrainSystem.readWorldHeight(math.ceil(this._iHeightMapX + this._iXVerts), math.ceil(this._iHeightMapY + this._iYVerts));
			var fHeight3:  number  = this.terrainSystem.readWorldHeight(math.ceil(this._iHeightMapX + this._iXVerts), math.ceil(this._iHeightMapY));

			this._v3fDistance0.set(v3fViewPoint.x-this._pWorldRect.x0, v3fViewPoint.y-this._pWorldRect.y0,v3fViewPoint.z-fHeight0);
			this._v3fDistance1.set(v3fViewPoint.x-this._pWorldRect.x0, v3fViewPoint.y-this._pWorldRect.y1,v3fViewPoint.z-fHeight1);
			this._v3fDistance2.set(v3fViewPoint.x-this._pWorldRect.x1, v3fViewPoint.y-this._pWorldRect.y1,v3fViewPoint.z-fHeight2);
			this._v3fDistance3.set(v3fViewPoint.x-this._pWorldRect.x1, v3fViewPoint.y-this._pWorldRect.y0,v3fViewPoint.z-fHeight3);

			this._fDistance0 = this._v3fDistance0.length();
			this._fDistance1 = this._v3fDistance1.length();
			this._fDistance2 = this._v3fDistance2.length();
			this._fDistance3 = this._v3fDistance3.length();

// compute min distance as our sort value
			this._fQueueSortValue = math.min(this._fDistance0 , this._fDistance1);
			this._fQueueSortValue = math.min(this._fQueueSortValue, this._fDistance2);
			this._fQueueSortValue = math.min(this._fQueueSortValue, this._fDistance3);


// submit to the tessellation queue of our parent
			this.terrainSystem.addToTessellationQueue(this);
		}

		reset(): void {
			if((<ITerrainROAM>this.terrainSystem).useTessellationThread){
				return;
			}

			this._pRootTriangleA.leftChild  = null;
			this._pRootTriangleA.rightChild = null;
			this._pRootTriangleB.leftChild  = null;
			this._pRootTriangleB.rightChild = null;

			this._pRootTriangleA.baseNeighbor = this._pRootTriangleB;
			this._pRootTriangleB.baseNeighbor = this._pRootTriangleA;

// link to our neighbors
			this._pRootTriangleA.leftNeighbor  = this._leftNeighborOfA;
			this._pRootTriangleA.rightNeighbor = this._rightNeighborOfA;
			this._pRootTriangleB.leftNeighbor  = this._leftNeighborOfB;
			this._pRootTriangleB.rightNeighbor = this._rightNeighborOfB;
		}

		tessellate(fScale:  number , fLimit:  number ): void {
			if((<ITerrainROAM>this.terrainSystem).useTessellationThread){
				return;
			}

			var iIndex0:  number  =  this.terrainSystem._tableIndex(this._iHeightMapX,						this._iHeightMapY);
			var iIndex1:  number  =  this.terrainSystem._tableIndex(this._iHeightMapX,						this._iHeightMapY + this._iYVerts-1);
			var iIndex2:  number  =  this.terrainSystem._tableIndex(this._iHeightMapX + this._iXVerts-1,	this._iHeightMapY + this._iYVerts-1);
			var iIndex3:  number  =  this.terrainSystem._tableIndex(this._iHeightMapX + this._iXVerts-1,	this._iHeightMapY);

			var fHeight0:  number  = this.terrainSystem.readWorldHeight(iIndex0);
			var fHeight1:  number  = this.terrainSystem.readWorldHeight(iIndex1);
			var fHeight2:  number  = this.terrainSystem.readWorldHeight(iIndex2);
			var fHeight3:  number  = this.terrainSystem.readWorldHeight(iIndex3);

			this.recursiveTessellate(
				this._pRootTriangleA,
				this._iHeightMapX, 					 this._iHeightMapY + this._iYVerts-1, fHeight1,
				this._iHeightMapX + this._iXVerts-1, this._iHeightMapY + this._iYVerts-1, fHeight2,
				this._iHeightMapX,					 this._iHeightMapY, 				  fHeight0,
				this._pVarianceTreeA, 1);

			this.recursiveTessellate(
				this._pRootTriangleB,
				this._iHeightMapX + this._iXVerts-1, this._iHeightMapY,					  fHeight3,
				this._iHeightMapX,					 this._iHeightMapY,					  fHeight0,
				this._iHeightMapX + this._iXVerts-1, this._iHeightMapY + this._iYVerts-1, fHeight2,
				this._pVarianceTreeB, 1);
		}

		protected recursiveTessellate(pTri: ITriTreeNode,
									  iCornerAX:  number , iCornerAY:  number , fCornerAZ:  number ,
									  iCornerBX:  number , iCornerBY:  number , fCornerBZ:  number ,
									  iCornerCX:  number , iCornerCY:  number , fCornerCZ:  number ,
									  pVTree:  number [], iIndex:  number ): void {
			if((iIndex<<1)+1 > this._iTotalVariances){
				return;
			}

			var iMidpointX:  number  = (iCornerBX + iCornerCX) >> 1;
			var iMidpointY:  number  = (iCornerBY + iCornerCY) >> 1;

			if ((iMidpointX === iCornerBX || iMidpointX === iCornerCX) &&
				(iMidpointY === iCornerBY || iMidpointY === iCornerCY)){
				return;
			}

			var fMidPointZ:  number  = (fCornerBZ + fCornerCZ)/2;
			var fRealMidPointZ:  number  = this.terrainSystem.readWorldHeight(iMidpointX, iMidpointY);

			var v3fLoaclCameraCoord: IVec3 = this.terrainSystem.localCameraCoord;
			var pTerrainExtents: IRect3d = this.terrainSystem.worldExtents;
			var iHeightMapWidth:  number  = this.terrainSystem.tableWidth;
			var iHeightMapHeight:  number  = this.terrainSystem.tableHeight;
			var fTerrainSizeZ:  number  = this.terrainSystem.maxHeight;
			var fTerrainDiagonal:  number  = this.terrainSystem.terrain2DLength;

			var fLocalMidX:  number  = pTerrainExtents.x0 + iMidpointX * pTerrainExtents.sizeX() / iHeightMapWidth;
			var fLocalMidY:  number  = pTerrainExtents.y0 + iMidpointY * pTerrainExtents.sizeY() / iHeightMapHeight;

			var fDistanceSquare:  number  = (v3fLoaclCameraCoord.x - fLocalMidX) * (v3fLoaclCameraCoord.x - fLocalMidX) +
										 (v3fLoaclCameraCoord.y - fLocalMidY) * (v3fLoaclCameraCoord.y - fLocalMidY) +
										 (v3fLoaclCameraCoord.z - fMidPointZ) * (v3fLoaclCameraCoord.z - fMidPointZ);

// Если треугольник не поделен
			if (!pTri.leftChild) {
				var fScale:  number  = this.terrainSystem.tessellationScale;
				var fLimit:  number  = this.terrainSystem.tessellationLimit;

				var fDistance:  number  = math.sqrt(fDistanceSquare+0.0001);
				var fRatio:  number  = 0.;

/*1 +*/
				fRatio = (pVTree[iIndex] / fTerrainSizeZ * fScale) /((        fDistance/fTerrainDiagonal) * fLimit);

				if (fRatio > 1.) {
// subdivide this triangle
					this.split(pTri);
				}
			}

// Если треугольник поделен, продолжаем
			if (pTri.leftChild) {
				this.recursiveTessellate(pTri.leftChild,
					iMidpointX, iMidpointY, fRealMidPointZ,
					iCornerAX, iCornerAY, fCornerAZ,
					iCornerBX, iCornerBY, fCornerBZ,
					pVTree, iIndex<<1);

				this.recursiveTessellate(pTri.rightChild,
					iMidpointX, iMidpointY, fRealMidPointZ,
					iCornerCX, iCornerCY, fCornerCZ,
					iCornerAX, iCornerAY, fCornerAZ,
					pVTree, (iIndex<<1)+1);
			}
		}

		protected split(pTri: ITriTreeNode): void {
// Если разбит то смысла разбивать еще нет
			if (pTri.leftChild){
				return;
			}

// If this triangle is not in a proper diamond, force split our base neighbor
			if (pTri.baseNeighbor && (pTri.baseNeighbor.baseNeighbor !== pTri)){
				this.split(pTri.baseNeighbor);
			}
// Create children and link into mesh
			pTri.leftChild  = this.terrainSystem.requestTriNode();
			pTri.rightChild = this.terrainSystem.requestTriNode();

			{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 304 ); logger.assert(pTri.leftChild != pTri, "recursive link"); } ;
			{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 305 ); logger.assert(pTri.rightChild != pTri, "recursive link"); } ;

// Если не удалось выделить треугольник, то не разбиваем
			if ( (!pTri.leftChild) || (!pTri.rightChild)) {
				pTri.leftChild  = null;
				pTri.rightChild = null;
				return;
			}

// Fill in the information we can get from the parent (neighbor pointers)
			pTri.leftChild.baseNeighbor  = pTri.leftNeighbor;
			pTri.leftChild.leftNeighbor  = pTri.rightChild;

			pTri.rightChild.baseNeighbor  = pTri.rightNeighbor;
			pTri.rightChild.rightNeighbor = pTri.leftChild;

// Link our Left Neighbor to the new children
			if (pTri.leftNeighbor) {
				if (pTri.leftNeighbor.baseNeighbor == pTri) {
					pTri.leftNeighbor.baseNeighbor = pTri.leftChild;
				} else if (pTri.leftNeighbor.leftNeighbor == pTri) {
					pTri.leftNeighbor.leftNeighbor = pTri.leftChild;
				} else if (pTri.leftNeighbor.rightNeighbor == pTri) {
					pTri.leftNeighbor.rightNeighbor = pTri.leftChild;
				} else {
					console.log(pTri);
					{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 331 ); logger.warning("Invalid Left Neighbor!"); } ;
					{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 332 ); logger.criticalError("stop"); } ;
// debugger;
				}
			}

// Link our Right Neighbor to the new children
			if (pTri.rightNeighbor) {
				if (pTri.rightNeighbor.baseNeighbor == pTri) {
					pTri.rightNeighbor.baseNeighbor = pTri.rightChild;
				} else if (pTri.rightNeighbor.rightNeighbor == pTri) {
					pTri.rightNeighbor.rightNeighbor = pTri.rightChild;
				} else if (pTri.rightNeighbor.leftNeighbor == pTri) {
					pTri.rightNeighbor.leftNeighbor = pTri.rightChild;
				} else {
					{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 346 ); logger.warning("Invalid Right Neighbor!"); } ;
				}
			}

// Link our Base Neighbor to the new children
			if (pTri.baseNeighbor) {
				if ( pTri.baseNeighbor.leftChild ) {
					pTri.baseNeighbor.leftChild.rightNeighbor = pTri.rightChild;
					pTri.baseNeighbor.rightChild.leftNeighbor = pTri.leftChild;
					pTri.leftChild.rightNeighbor = pTri.baseNeighbor.rightChild;
					pTri.rightChild.leftNeighbor = pTri.baseNeighbor.leftChild;
				} else {
// Base Neighbor (in a diamond with us) was not split yet, so do that now.
					this.split(pTri.baseNeighbor);
				}
			} else {
// An edge triangle, trivial case.
				pTri.leftChild.rightNeighbor = null;
				pTri.rightChild.leftNeighbor = null;
			}
		}

		private _createRenderDataForVertexAndIndex(): bool {
			return true;
		}

		private _buildIndexBuffer(): bool {
// this._iMaxIndices=a.TerrainROAM.MaxTriTreeNodes*3;
			this._iMaxIndices = this.terrainSystem.maxTriTreeNodes * 3;
			return true;
		}

		private _buildVertexBuffer(): bool {
			this._pWorldRect.z0 = MAX_FLOAT64;
			this._pWorldRect.z1 = MIN_FLOAT64;

			var nElementSize:  number  = 0;
			if(this.terrainSystem._useVertexNormal()){
/*кординаты вершин*/
/*нормаль*/
/*текстурные координаты*/
				nElementSize = (3                                    + 3                   + 2                                             );
			}
			else {
/*кординаты вершин*/
/*текстурные координаты*/
				nElementSize =  (3                                    + 2                                             );
			}

			var pVerts:  number [] = this.terrainSystem.verts;

			var v3fNormal: IVec3 = new Vec3();

// размер ячейки сектора
			var v2fCellSize: IVec2 = new Vec2();
			v2fCellSize.set(this.heightX / (this._iXVerts-1),
/*размер сектора/количество ячеек в секторе*/
				this.heightY / (this._iYVerts-1));

//Координаты вершина в секторе
			var v2fVert: IVec2 = new Vec2();
			v2fVert.set(0.0, 0.0);

			for (var y:  number  = 0; y < this._iYVerts; ++y) {

				v2fVert.set(this._pWorldRect.x0, y * v2fCellSize.y+this._pWorldRect.y0);

				for (var x:  number  = 0; x < this._iXVerts; ++x) {

					var fHeight:  number  = this.terrainSystem.readWorldHeight(this._iHeightMapX + x, this._iHeightMapY + y);

					pVerts[((y * this._iXVerts) + x) * nElementSize + 0 + this._iStartIndex * nElementSize] = v2fVert.x;
					pVerts[((y * this._iXVerts) + x) * nElementSize + 1 + this._iStartIndex * nElementSize] = v2fVert.y;
					pVerts[((y * this._iXVerts) + x) * nElementSize + 2 + this._iStartIndex * nElementSize] = fHeight;

					if(this.terrainSystem._useVertexNormal()){
						this.terrainSystem.readWorldNormal(v3fNormal, this._iHeightMapX + x, this._iHeightMapY + y);

						pVerts[((y * this._iXVerts) + x) * nElementSize + 3 + this._iStartIndex * nElementSize] = v3fNormal.x;
						pVerts[((y * this._iXVerts) + x) * nElementSize + 4 + this._iStartIndex * nElementSize] = v3fNormal.y;
						pVerts[((y * this._iXVerts) + x) * nElementSize + 5 + this._iStartIndex * nElementSize] = v3fNormal.z;

						pVerts[((y * this._iXVerts) + x) * nElementSize + 6 + this._iStartIndex * nElementSize] = (this._iSectorX + x / (this._iXVerts - 1))/this.terrainSystem.sectorCountX;
						pVerts[((y * this._iXVerts) + x) * nElementSize + 7 + this._iStartIndex * nElementSize] = (this._iSectorY + y / (this._iYVerts - 1))/this.terrainSystem.sectorCountY;
					}
					else {
						pVerts[((y * this._iXVerts) + x) * nElementSize + 3 + this._iStartIndex * nElementSize] = (this._iSectorX + x / (this._iXVerts - 1))/this.terrainSystem.sectorCountX;
						pVerts[((y * this._iXVerts) + x) * nElementSize + 4 + this._iStartIndex * nElementSize] = (this._iSectorY + y / (this._iYVerts - 1))/this.terrainSystem.sectorCountY;
					}

					this._pWorldRect.z0 = math.min(this._pWorldRect.z0, fHeight);
					this._pWorldRect.z1 = math.max(this._pWorldRect.z1, fHeight);

					v2fVert.x += v2fCellSize.x;
				}
			}

			return true;
		}

		buildTriangleList(): void {
			if((<ITerrainROAM>this.terrainSystem).useTessellationThread){
				return;
			}

			this._iTempTotalIndices = this.terrainSystem.totalIndex;

			this._pTempIndexList = this.terrainSystem.index;
			this._iVertexID = this.terrainSystem.vertexId;
// add all the triangles to the roamTerrain
// in root triangle A


			this.recursiveBuildTriangleList(
				this._pRootTriangleA,
				0,this._iXVerts-1,(this._iYVerts-1)*this._iXVerts);

// add all the triangles to the roamTerrain
// in root triangle B
			this.recursiveBuildTriangleList(
				this._pRootTriangleB,
				(this._iYVerts*this._iXVerts)-1, (this._iYVerts-1)*this._iXVerts, this._iXVerts-1);

			this.terrainSystem.totalIndex = this._iTempTotalIndices;


			this._iTempTotalIndices = undefined;
			this._iVertexID = undefined;
			this._pTempIndexList = null;
		}

		protected recursiveBuildTriangleList(pTri: ITriTreeNode, iPointBase:  number , iPointLeft:  number , iPointRight:  number ): void {
			if (pTri.leftChild) {

				if(!pTri.rightChild) {
					{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 475 ); logger.warning("invalid triangle node"); } ;
				}

				var iPointMid:  number  = (iPointLeft + iPointRight) * 0.5;
				this.recursiveBuildTriangleList(
					pTri.leftChild,
					iPointMid, iPointBase, iPointLeft);
				this.recursiveBuildTriangleList(
					pTri.rightChild,
					iPointMid, iPointRight, iPointBase);

			}
			else if (this._iTempTotalIndices + 3 < this._iMaxIndices) {
				var nElementSize:  number  = 0;
				if(this.terrainSystem._useVertexNormal()){
/*кординаты вершин*/
/*нормаль*/
/*текстурные координаты*/
					nElementSize = (3                                    + 3                   + 2                                             );
				}
				else {
/*кординаты вершин*/
/*текстурные координаты*/
					nElementSize =  (3                                    + 2                                             );
				}

// add the local triangle to the index list

				this._pTempIndexList[this._iTempTotalIndices++]=((iPointRight+this._iStartIndex) * nElementSize * 4 + this._iVertexID)/4;
				this._pTempIndexList[this._iTempTotalIndices++]=((iPointLeft+this._iStartIndex) * nElementSize * 4 + this._iVertexID)/4;
				this._pTempIndexList[this._iTempTotalIndices++]=((iPointBase+this._iStartIndex) * nElementSize * 4 + this._iVertexID)/4;
			}
			else {
				{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 503 ); logger.log("else", this._iTempTotalIndices, this._iMaxIndices); }
			}
		}

		protected computeVariance(): void {
			var iTableWidth:  number  = this.terrainSystem.tableWidth;
			var iTableHeight:  number  = this.terrainSystem.tableHeight;

			var iIndex0:  number  =  this.terrainSystem._tableIndex(this._iHeightMapX,						this._iHeightMapY);
			var iIndex1:  number  =  this.terrainSystem._tableIndex(this._iHeightMapX,						this._iHeightMapY + this._iYVerts-1);
			var iIndex2:  number  =  this.terrainSystem._tableIndex(this._iHeightMapX + this._iXVerts-1,	this._iHeightMapY + this._iYVerts-1);
			var iIndex3:  number  =  this.terrainSystem._tableIndex(this._iHeightMapX + this._iXVerts-1,	this._iHeightMapY);

			var fHeight0:  number  = this.terrainSystem.readWorldHeight(iIndex0);
			var fHeight1:  number  = this.terrainSystem.readWorldHeight(iIndex1);
			var fHeight2:  number  = this.terrainSystem.readWorldHeight(iIndex2);
			var fHeight3:  number  = this.terrainSystem.readWorldHeight(iIndex3);

			this.recursiveComputeVariance(
				this._iHeightMapX, 					 this._iHeightMapY + this._iYVerts-1,
				this._iHeightMapX + this._iXVerts-1, this._iHeightMapY + this._iYVerts-1,
				this._iHeightMapX,					 this._iHeightMapY,
				fHeight1, fHeight2, fHeight0,
				this._pVarianceTreeA, 1);

			this.recursiveComputeVariance(
				this._iHeightMapX + this._iXVerts-1, this._iHeightMapY,
				this._iHeightMapX,					 this._iHeightMapY,
				this._iHeightMapX + this._iXVerts-1, this._iHeightMapY + this._iYVerts-1,
				fHeight3, fHeight0, fHeight2,
				this._pVarianceTreeB, 1);
		}

		protected recursiveComputeVariance(iCornerAX:  number , iCornerAY:  number ,
										   iCornerBX:  number , iCornerBY:  number ,
										   iCornerCX:  number , iCornerCY:  number ,
										   fHeightA:  number , fHeightB:  number , fHeightC:  number , pVTree:  number [], iIndex:  number ):  number  {
			if (iIndex < pVTree.length) {

				var iMidpointX:  number  = (iCornerBX + iCornerCX) >> 1;
				var iMidpointY:  number  = (iCornerBY + iCornerCY) >> 1;

				if ((iMidpointX === iCornerBX || iMidpointX === iCornerCX) &&
					(iMidpointY === iCornerBY || iMidpointY === iCornerCY)){
					return 0;
				}

				var fMidHeight:  number  = this.terrainSystem.readWorldHeight(iMidpointX, iMidpointY);
				var fInterpolatedHeight:  number  = (fHeightB + fHeightC)*0.5;
				var fVariance:  number  = math.abs(fMidHeight - fInterpolatedHeight);

// find the variance of our children
				var fLeft:  number  = this.recursiveComputeVariance(
					iMidpointX, iMidpointY,
					iCornerAX,  iCornerAY,
					iCornerBX,  iCornerBY,
					fMidHeight, fHeightA, fHeightB,
					pVTree, iIndex<<1);

				var fRight:  number  = this.recursiveComputeVariance(
					iMidpointX, iMidpointY,
					iCornerCX,  iCornerCY,
					iCornerAX,  iCornerAY,
					fMidHeight, fHeightC, fHeightA,
					pVTree, 1+(iIndex<<1));

// local variance is the minimum of all three
				fVariance = math.max(fVariance, fLeft);
				fVariance = math.max(fVariance, fRight);

// store the variance as 1/(variance+1)
				pVTree[iIndex] = fVariance;


// this.drawVariance(iIndex,
// 	this.terrainSystem._tableIndex(iCornerAX, iCornerAY),
// 	this.terrainSystem._tableIndex(iCornerBX, iCornerBY), 
// 	this.terrainSystem._tableIndex(iCornerCX, iCornerCY), pVTree);

				return fVariance;
			}
// return a value which will be ignored by the parent
// (because the minimum function is used with this result)

			return 0;
		}

		protected maxVariance(): void {
			var fVarianceMaxA:  number  = 0;
			var fVarianceMaxB:  number  = 0;
			for(var i:  number  = 0; i < this._pVarianceTreeA.length; i++){
				if(fVarianceMaxA < this._pVarianceTreeA[i]){
					fVarianceMaxA = this._pVarianceTreeA[i];
				}

				if(fVarianceMaxB < this._pVarianceTreeB[i]){
					fVarianceMaxB = this._pVarianceTreeB[i];
				}
			}

			{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 603 ); logger.log("MAX ---> In A: " + fVarianceMaxA + ". In B: " + fVarianceMaxB); } ;
		}

		protected minVariance(): void {
			var fVarianceMaxA:  number  = 0xffffff;
			var fVarianceMaxB:  number  = 0xffffff;

			for(var i:  number  = 0; i < this._pVarianceTreeA.length; i++){
				if(fVarianceMaxA > this._pVarianceTreeA[i]  && this._pVarianceTreeA[i] !== 0){
					fVarianceMaxA = this._pVarianceTreeA[i];
				}

				if(fVarianceMaxB > this._pVarianceTreeB[i] && this._pVarianceTreeB[i] !== 0){
					fVarianceMaxB = this._pVarianceTreeB[i];
				}
			}

			{ logger.setSourceLocation( "terrain/TerrainSectionROAM.ts" , 620 ); logger.log("MIN ---> In A: " + fVarianceMaxA + ". In B: " + fVarianceMaxB); } ;
		}

		protected drawVariance(iIndex:  number , iCornerA:  number , iCornerB:  number , iCornerC:  number , pVTree:  number []): void {

			var iLevel:  number  = math.floor(math.log(iIndex)/math.LN2);
			var iStart:  number  = 3;
			if(iLevel >= iStart && iLevel < iStart + 4) {
//#####################################################################################
//Получение канваса
				var pCanvas: HTMLCanvasElement = <HTMLCanvasElement>document.getElementById("canvasVariance"+(iLevel-iStart));
				var p2D = pCanvas.getContext("2d");
// цвет фона

				p2D.fillStyle = "rgb(0,"+math.floor(pVTree[iIndex])+",0)";

//#####################################################################################
//Рисование треугольников

//цвет линий
				p2D.strokeStyle = "#f00";
				p2D.lineWidth = 1;
				p2D.beginPath();
				var iTW:  number  = this.terrainSystem.tableWidth;
				var iTH:  number  = this.terrainSystem.tableHeight;

				var iXA:  number  = iCornerA%iTW;
				var iYA:  number  = math.floor(iCornerA/iTW);
				var iXB:  number  = iCornerB%iTW;
				var iYB:  number  = math.floor(iCornerB/iTW);
				var iXC:  number  = iCornerC%iTW;
				var iYC:  number  = math.floor(iCornerC/iTW);

				var iXMid:  number  = math.floor((iXA+iXB+iXC)/3);
				var iYMid:  number  = math.floor((iYA+iYB+iYC)/3);

				p2D.arc(math.floor(iXMid/iTW*pCanvas.width), math.floor(iYMid/iTH*pCanvas.height), 1, 0, math.PI*2, false);
				p2D.fill();
			}
		}
	}
}













module akra {
	export interface ITriTreeNode {
		baseNeighbor:  ITriTreeNode;
		leftNeighbor:  ITriTreeNode;
		rightNeighbor: ITriTreeNode;
		leftChild:     ITriTreeNode;
		rightChild:    ITriTreeNode;
	}

	export interface ITriangleNodePool {
		request(): ITriTreeNode;
		reset(): void;
	}
}



module akra.terrain {
	export class TriTreeNode implements ITriTreeNode{
		private _pBaseNeighbor:  ITriTreeNode = null;
		private _pLeftNeighbor:  ITriTreeNode = null;
		private _pRightNeighbor: ITriTreeNode = null;
		private _pLeftChild:     ITriTreeNode = null;
		private _pRightChild:    ITriTreeNode = null;

		/**@inline*/  get baseNeighbor(): ITriTreeNode {
			return this._pBaseNeighbor;
		}

		/**@inline*/  set baseNeighbor(pBaseNeighbor: ITriTreeNode) {
			this._pBaseNeighbor = pBaseNeighbor;
		}

		/**@inline*/  get leftNeighbor(): ITriTreeNode {
			return this._pLeftNeighbor;
		}

		/**@inline*/  set leftNeighbor(pLeftNeighbor: ITriTreeNode) {
			this._pLeftNeighbor = pLeftNeighbor;
		}

		/**@inline*/  get rightNeighbor(): ITriTreeNode {
			return this._pRightNeighbor;
		}

		/**@inline*/  set rightNeighbor(pRightNeighbor: ITriTreeNode) {
			this._pRightNeighbor = pRightNeighbor;
		}

		/**@inline*/  get leftChild(): ITriTreeNode {
			return this._pLeftChild;
		}

		/**@inline*/  set leftChild(pLeftChild: ITriTreeNode) {
			this._pLeftChild = pLeftChild;
		}

		/**@inline*/  get rightChild(): ITriTreeNode {
			return this._pRightChild;
		}

		/**@inline*/  set rightChild(pRightChild: ITriTreeNode) {
			this._pRightChild = pRightChild;
		}
	}

	export class TriangleNodePool implements ITriangleNodePool{
		private _iNextTriNode:  number  = 0;
		private _iMaxCount:  number  = undefined;
		private _pPool: ITriTreeNode[] = null;

		/**@inline*/  get nextTriNode():  number  {
			return this._iNextTriNode;
		}

		/**@inline*/  set nextTriNode(iNextTriNode:  number ) {
			this._iNextTriNode = iNextTriNode;
		}

		/**@inline*/  get maxCount():  number  {
			return this._iMaxCount;
		}

		/**@inline*/  get pool(): ITriTreeNode[] {
			return this._pPool;
		}

		/**@inline*/  set pool(pPool: ITriTreeNode[]) {
			this._pPool = pPool;
		}

		constructor(iCount:  number ) {
			this._iMaxCount = iCount;
			this.pool = <ITriTreeNode[]>Array(iCount);

// console.log("TriangleNodePool",this.maxCount);

			for(var i:  number  = 0; i < this.maxCount; i++) {
				this.pool[i] = new TriTreeNode();
			}
		}

		request(): ITriTreeNode {
			var pNode: ITriTreeNode = null;

			if(this.nextTriNode < this.maxCount) {
				pNode = this.pool[this.nextTriNode];
				pNode.baseNeighbor  = null;
				pNode.leftNeighbor  = null;
				pNode.rightNeighbor = null;
				pNode.leftChild     = null;
				pNode.rightChild    = null;
				this.nextTriNode++;
			}

			return pNode;
		}

		reset(): void {
			this.nextTriNode = 0;
		}
	}
}











var pTmpTransferableArray: ArrayBuffer[] = [null];

enum ECommandTypes{
	INITTERRAIN = 1,
	HEIGHTMAP = 2,
	UPDATEPARAMS = 3,
	TESSELATE = 4
}

interface ICommand{
	type: ECommandTypes;
	info: any;
}

(<any>self).onmessage = function(event: any){
	if(event.data instanceof ArrayBuffer){
		processTesselate(event.data);
	}
	else {
		var pCommand: ICommand = <ICommand>event.data;
		switch(pCommand.type){
			case ECommandTypes.INITTERRAIN:
				processInitTerrain(<ITerrainInitInfo>pCommand.info);
				return;
			case ECommandTypes.UPDATEPARAMS:
				processUpdateParams(pCommand.info);
				return;

		}
	}
}

// module akra.util{
/*export*/
           interface IRect3d{
	x0: number;
	y0: number;
	z0: number;

	x1: number;
	y1: number;
	z1: number;
}

/*export*/
           interface ITriTreeNode {
	baseNeighbor: ITriTreeNode;
	leftNeighbor: ITriTreeNode;
	rightNeighbor: ITriTreeNode;
	leftChild: ITriTreeNode;
	rightChild: ITriTreeNode;
}

/*export*/
           interface ITerrainSectionInfo{
	x: number;
	y: number;
	pixelX: number;
	pixelY: number;

	varianceTreeA: number[];
	varianceTreeB: number[];

	rootTriangleA: ITriTreeNode;
	rootTriangleB: ITriTreeNode;

	leftNeighborOfA: ITriTreeNode;
	rightNeighborOfA: ITriTreeNode;
	leftNeighborOfB: ITriTreeNode;
	rightNeighborOfB: ITriTreeNode;

	startIndex: number;
}

/*export*/
           interface ITerrainInitInfo{
	heightMapTable: ArrayBuffer;
	tableWidth: number;
	tableHeight: number;
	sectorUnits: number;
	sectorCountX: number;
	sectorCountY: number;
	isUsedVertexNormal: bool;
	worldExtents: IRect3d;
	maxHeight: number;
	maxTriTreeNodeCount: number;

	tessellationScale: number;
	tessellationLimit: number;

	vertexID: number;
}

/*export*/
           function createTriTreeNode(): ITriTreeNode {
	return <ITriTreeNode>{
		baseNeighbor: null,
		leftNeighbor: null,
		rightNeighbor: null,
		leftChild: null,
		rightChild: null
	};
}

/*export*/
           class TriangleNodePool {
	private _iNextTriNode: number = 0;
	private _iMaxCount: number = 0;
	private _pPool: ITriTreeNode[] = null;

	constructor(iCount: number){
		this._iMaxCount = iCount;
		this._pPool = new Array(iCount);

		for(var i: number = 0; i < this._iMaxCount; i++){
			this._pPool[i] = createTriTreeNode();
		}
	}

	request(): ITriTreeNode {
		if(this._iNextTriNode >= this._iMaxCount){
			return null;
		}
		else {
			var pNode: ITriTreeNode = this._pPool[this._iNextTriNode];
			pNode.baseNeighbor  = null;
			pNode.leftNeighbor  = null;
			pNode.rightNeighbor = null;
			pNode.leftChild     = null;
			pNode.rightChild    = null;
			this._iNextTriNode++;
			return pNode;
		}
	}

	reset(): void {
		this._iNextTriNode = 0;
	}
}


/*export*/
           interface ITerrainInfo{
	heightMapTable: Float32Array;

	tableWidth: number;
	tableHeight: number;

	sectorUnits: number;
	sectorCountX: number;
	sectorCountY: number;

	isUsedVertexNormal: bool;

	worldExtents: IRect3d;
	maxHeight: number;
	terrain2DLength: number;

	maxTriTreeNodeCount: number;
	triNodePool: TriangleNodePool;

	sections: ITerrainSectionInfo[];
	sectorTotalDetailLevels: number;
	sectorTotalVariances: number;

	tessellationScale: number;
	tessellationLimit: number;

	cameraCoord: Float32Array;
	tessellationQueue: Uint32Array;
	tessellationQueueSize: number;

	tessellationIndices: Float32Array;
	totalIndices: number;

	vertexID: number;

	processTessellationQueue(): void;
}

/*export*/
           class TerrainInfo implements ITerrainInfo {
	heightMapTable: Float32Array;

	tableWidth: number;
	tableHeight: number;

	sectorUnits: number;
	sectorCountX: number;
	sectorCountY: number;

	isUsedVertexNormal: bool;

	worldExtents: IRect3d;
	maxHeight: number;
	terrain2DLength: number;

	maxTriTreeNodeCount: number;
	triNodePool: TriangleNodePool;

	sections: ITerrainSectionInfo[];

	sectorTotalDetailLevels: number;
	sectorTotalVariances: number;

	tessellationScale: number;
	tessellationLimit: number;

	cameraCoord: Float32Array;
	tessellationQueue: Uint32Array;
	tessellationQueueSize: number;

	tessellationIndices: Float32Array;
	totalIndices: number;

	vertexID: number;


	constructor(pInitInfo: ITerrainInitInfo){
		this.heightMapTable = new Float32Array(pInitInfo.heightMapTable);

		this.tableWidth = pInitInfo.tableWidth;
		this.tableHeight = pInitInfo.tableHeight;

		this.sectorUnits = pInitInfo.sectorUnits;
		this.sectorTotalDetailLevels = 0;
		this.sectorTotalVariances = 0;
		this.sectorCountX = pInitInfo.sectorCountX;
		this.sectorCountY = pInitInfo.sectorCountY;

		this.isUsedVertexNormal = pInitInfo.isUsedVertexNormal;

		this.worldExtents = pInitInfo.worldExtents;
		this.maxHeight = pInitInfo.maxHeight;
		this.terrain2DLength = 0;

		this.maxTriTreeNodeCount = pInitInfo.maxTriTreeNodeCount;
		this.triNodePool = new TriangleNodePool(pInitInfo.maxTriTreeNodeCount);

		this.sections = null;

		this.tessellationScale = pInitInfo.tessellationScale;
		this.tessellationLimit = pInitInfo.tessellationLimit;

		this.cameraCoord = new Float32Array(3);
		this.tessellationQueue = new Uint32Array(this.sectorCountX * this.sectorCountY);
		this.tessellationQueueSize = 0;

		this.tessellationIndices = null;
		this.vertexID = pInitInfo.vertexID;
		this.totalIndices = 0;


		this.sectorTotalDetailLevels = 2 * (Math.round(Math.log(this.sectorUnits)/Math.LN2));
		this.sectorTotalVariances = 1 << this.sectorTotalDetailLevels;
		this.terrain2DLength = Math.sqrt((this.worldExtents.x1 - this.worldExtents.x0) * (this.worldExtents.x1 - this.worldExtents.x0) +
									     (this.worldExtents.y1 - this.worldExtents.y0) * (this.worldExtents.y1 - this.worldExtents.y0));
		this.sections = new Array(this.sectorCountX * this.sectorCountY);

		this.initSections();
	}

	processTessellationQueue(): void {
		this.totalIndices = 0;
		this.triNodePool.reset();

		for(var i: number = 0; i < this.tessellationQueueSize; i++){
			this.tesselateSection(this.sections[this.tessellationQueue[i]]);
		}

		for(var i: number = 0; i < this.tessellationQueueSize; i++){
			this.buildTriangleList(this.sections[this.tessellationQueue[i]]);
		}

		for(var i: number = 0; i < this.sections.length; i++){
			this.resetSection(this.sections[i]);
		}
	}

	private initSections(): void {
		var iShift: number = (Math.log(this.sectorUnits)/Math.LN2) | 0;
		var iSectorVerts: number = this.sectorUnits + 1;

		for(var y: number = 0; y < this.sectorCountY; y++) {
			for(var x: number = 0; x < this.sectorCountX; x++) {
				var iXPixel: number = x << iShift;
				var iYPixel: number = y << iShift;
				var iIndex: number = (y * this.sectorCountX) + x;

				this.sections[iIndex] = <ITerrainSectionInfo>{
					x: x,
					y: y,
					pixelX: iXPixel,
					pixelY: iYPixel,

					varianceTreeA: new Array(this.sectorTotalVariances),
					varianceTreeB: new Array(this.sectorTotalVariances),

					rootTriangleA: createTriTreeNode(),
					rootTriangleB: createTriTreeNode(),
					leftNeighborOfA: null,
					rightNeighborOfA: null,
					leftNeighborOfB: null,
					rightNeighborOfB: null,

					startIndex: iIndex * (iSectorVerts * iSectorVerts)
				};

				for(var i: number = 0; i < this.sectorTotalVariances; i++){
                    this.sections[iIndex].varianceTreeA[i] = 0;
                    this.sections[iIndex].varianceTreeB[i] = 0;
                }
			}
		}

//set neighbors for sections
		for(var y: number = 0; y < this.sectorCountY; y++) {
			for(var x: number = 0; x < this.sectorCountX; x++) {
				var pSection: ITerrainSectionInfo = this.findSection(x, y);
				var pNorthSection: ITerrainSectionInfo = this.findSection(x, y - 1);
				var pSouthSection: ITerrainSectionInfo = this.findSection(x, y + 1);
				var pEastSection: ITerrainSectionInfo  = this.findSection(x + 1, y);
				var pWestSection: ITerrainSectionInfo  = this.findSection(x - 1, y);

				if (pNorthSection !== null) {
					pSection.leftNeighborOfA = pNorthSection.rootTriangleB;
				}

				if (pSouthSection !== null) {
					pSection.leftNeighborOfB = pSouthSection.rootTriangleA;
				}

				if (pEastSection !== null) {
					pSection.rightNeighborOfB = pEastSection.rootTriangleA;
				}

				if (pWestSection !== null) {
					pSection.rightNeighborOfA = pWestSection.rootTriangleB;
				}

				this.resetSection(pSection);
				this.computeVariance(pSection);
			}
		}
	}

	private resetSection(pSection: ITerrainSectionInfo): void {
		pSection.rootTriangleA.leftChild  = null;
		pSection.rootTriangleA.rightChild = null;
		pSection.rootTriangleB.leftChild  = null;
		pSection.rootTriangleB.rightChild = null;

		pSection.rootTriangleA.baseNeighbor = pSection.rootTriangleB;
		pSection.rootTriangleB.baseNeighbor = pSection.rootTriangleA;

// link to our neighbors
		pSection.rootTriangleA.leftNeighbor  = pSection.leftNeighborOfA;
		pSection.rootTriangleA.rightNeighbor = pSection.rightNeighborOfA;
		pSection.rootTriangleB.leftNeighbor  = pSection.leftNeighborOfB;
		pSection.rootTriangleB.rightNeighbor = pSection.rightNeighborOfB;
	}

	private findSection(iX: number, iY: number): ITerrainSectionInfo {
		var pSection: ITerrainSectionInfo = null;

		if (iX >= 0 && iX < this.sectorCountX &&
			iY >= 0 && iY < this.sectorCountY) {
		    pSection = this.sections[(iY * this.sectorCountX) + iX];
		}

		return pSection;
	}

	private tableIndex(iMapX: number, iMapY: number): number {
// clamp to the table dimensions
		if (iMapX >= this.tableWidth) {
		    iMapX = this.tableWidth - 1;
		}

		if (iMapY >= this.tableHeight) {
		    iMapY = this.tableHeight - 1;
		}

		return (iMapY * this.tableWidth) + iMapX;
	}

	private readWorldHeight(iIndex: number): number;
	private readWorldHeight(iMapX: number, iMapY: number): number;
	private readWorldHeight(iMapX: any, iMapY?: number): number {
		if (arguments.length === 2) {
			var iFixedMapX: number = iMapX, iFixedMapY: number = iMapY;

		    if (iFixedMapX >= this.tableWidth) {
		        iFixedMapX = this.tableWidth - 1;
		    }
		    if (iFixedMapY >= this.tableHeight) {
		        iFixedMapY = this.tableHeight - 1;
		    }

		    return this.heightMapTable[(iFixedMapY * this.tableWidth) + iFixedMapX];
		}
		else {
		    var iMapIndex: number = iMapX;
		    return this.heightMapTable[iMapIndex];
		}
	}

	private computeVariance(pSection: ITerrainSectionInfo): void {
		var iTableWidth: number = this.tableWidth;
		var iTableHeight: number = this.tableHeight;

		var iIndex0: number = this.tableIndex(pSection.pixelX,						pSection.pixelY);
		var iIndex1: number = this.tableIndex(pSection.pixelX,						pSection.pixelY + this.sectorUnits);
		var iIndex2: number = this.tableIndex(pSection.pixelX + this.sectorUnits,	pSection.pixelY + this.sectorUnits);
		var iIndex3: number = this.tableIndex(pSection.pixelX + this.sectorUnits,	pSection.pixelY);

		var fHeight0: number = this.heightMapTable[iIndex0];
		var fHeight1: number = this.heightMapTable[iIndex1];
		var fHeight2: number = this.heightMapTable[iIndex2];
		var fHeight3: number = this.heightMapTable[iIndex3];

		this.recursiveComputeVariance(
			pSection.pixelX, 					pSection.pixelY + this.sectorUnits,
			pSection.pixelX + this.sectorUnits, pSection.pixelY + this.sectorUnits,
			pSection.pixelX,					pSection.pixelY,
			fHeight1, fHeight2, fHeight0,
			pSection.varianceTreeA, 1);

		this.recursiveComputeVariance(
			pSection.pixelX + this.sectorUnits, pSection.pixelY,
			pSection.pixelX,					pSection.pixelY,
			pSection.pixelX + this.sectorUnits, pSection.pixelY + this.sectorUnits,
			fHeight3, fHeight0, fHeight2,
			pSection.varianceTreeB, 1);
	}

	private recursiveComputeVariance(iCornerAX: number, iCornerAY: number,
											iCornerBX: number, iCornerBY: number,
											iCornerCX: number, iCornerCY: number,
											fHeightA: number, fHeightB: number, fHeightC: number,
											pVTree: number[], iIndex: number): number {
		if (iIndex < pVTree.length) {

			var iMidpointX: number = (iCornerBX + iCornerCX) >> 1;
			var iMidpointY: number = (iCornerBY + iCornerCY) >> 1;

			if ((iMidpointX === iCornerBX || iMidpointX === iCornerCX) &&
				(iMidpointY === iCornerBY || iMidpointY === iCornerCY)){
				return 0;
			}

			var fMidHeight: number = this.readWorldHeight(iMidpointX, iMidpointY);
			var fInterpolatedHeight: number = (fHeightB + fHeightC)*0.5;
			var fVariance: number = Math.abs(fMidHeight - fInterpolatedHeight);

// find the variance of our children
			var fLeft: number = this.recursiveComputeVariance(
				iMidpointX, iMidpointY,
				iCornerAX,  iCornerAY,
				iCornerBX,  iCornerBY,
				fMidHeight, fHeightA, fHeightB,
				pVTree, iIndex<<1);

			var fRight: number = this.recursiveComputeVariance(
				iMidpointX, iMidpointY,
				iCornerCX,  iCornerCY,
				iCornerAX,  iCornerAY,
				fMidHeight, fHeightC, fHeightA,
				pVTree, 1+(iIndex<<1));

// local variance is the minimum of all three
			fVariance = Math.max(fVariance, fLeft);
			fVariance = Math.max(fVariance, fRight);

// store the variance as 1/(variance+1)
			pVTree[iIndex] = fVariance;


// this.drawVariance(iIndex,
// 	this.terrainSystem._tableIndex(iCornerAX, iCornerAY),
// 	this.terrainSystem._tableIndex(iCornerBX, iCornerBY), 
// 	this.terrainSystem._tableIndex(iCornerCX, iCornerCY), pVTree);

			return fVariance;
		}
// return a value which will be ignored by the parent
// (because the minimum function is used with this result)

		return 0;
	}

	private tesselateSection(pSection: ITerrainSectionInfo): void {
		var iIndex0: number =  this.tableIndex(pSection.pixelX,						pSection.pixelY);
		var iIndex1: number =  this.tableIndex(pSection.pixelX,						pSection.pixelY + this.sectorUnits);
		var iIndex2: number =  this.tableIndex(pSection.pixelX + this.sectorUnits,	pSection.pixelY + this.sectorUnits);
		var iIndex3: number =  this.tableIndex(pSection.pixelX + this.sectorUnits,	pSection.pixelY);

		var fHeight0: number = this.readWorldHeight(iIndex0);
		var fHeight1: number = this.readWorldHeight(iIndex1);
		var fHeight2: number = this.readWorldHeight(iIndex2);
		var fHeight3: number = this.readWorldHeight(iIndex3);

		this.recursiveTessellate(
			pSection.rootTriangleA,
			pSection.pixelX, 					pSection.pixelY + this.sectorUnits, fHeight1,
			pSection.pixelX + this.sectorUnits, pSection.pixelY + this.sectorUnits, fHeight2,
			pSection.pixelX,					pSection.pixelY, 				  	fHeight0,
			pSection.varianceTreeA, 1);

		this.recursiveTessellate(
			pSection.rootTriangleB,
			pSection.pixelX + this.sectorUnits, pSection.pixelY,					fHeight3,
			pSection.pixelX,					pSection.pixelY,					fHeight0,
			pSection.pixelX + this.sectorUnits, pSection.pixelY + this.sectorUnits, fHeight2,
			pSection.varianceTreeB, 1);
	}

	private recursiveTessellate(pTri: ITriTreeNode,
								iCornerAX: number, iCornerAY: number, fCornerAZ: number,
								iCornerBX: number, iCornerBY: number, fCornerBZ: number,
								iCornerCX: number, iCornerCY: number, fCornerCZ: number,
								pVTree: number[], iIndex: number): void {
		if((iIndex<<1)+1 > this.sectorTotalVariances){
			return;
		}

		var iMidpointX: number = (iCornerBX + iCornerCX) >> 1;
		var iMidpointY: number = (iCornerBY + iCornerCY) >> 1;

		if ((iMidpointX === iCornerBX || iMidpointX === iCornerCX) &&
			(iMidpointY === iCornerBY || iMidpointY === iCornerCY)){
			return;
		}

		var fMidPointZ: number = (fCornerBZ + fCornerCZ)/2;
		var fRealMidPointZ: number = this.readWorldHeight(iMidpointX, iMidpointY);

		var pTerrainExtents: IRect3d = this.worldExtents;
		var iHeightMapWidth: number = this.tableWidth;
		var iHeightMapHeight: number = this.tableHeight;
		var fTerrainSizeZ: number = this.maxHeight;
		var fTerrainDiagonal: number = this.terrain2DLength;

		var fLocalMidX: number = pTerrainExtents.x0 + iMidpointX * (pTerrainExtents.x1 - pTerrainExtents.x0) / iHeightMapWidth;
		var fLocalMidY: number = pTerrainExtents.y0 + iMidpointY * (pTerrainExtents.y1 - pTerrainExtents.y0) / iHeightMapHeight;

		var fDistanceSquare: number = (this.cameraCoord[0] - fLocalMidX) * (this.cameraCoord[0] - fLocalMidX) +
									  (this.cameraCoord[1] - fLocalMidY) * (this.cameraCoord[1] - fLocalMidY) +
									  (this.cameraCoord[2] - fMidPointZ) * (this.cameraCoord[2] - fMidPointZ);

// Если треугольник не поделен
		if (!pTri.leftChild) {
			var fScale: number = this.tessellationScale;
			var fLimit: number = this.tessellationLimit;

			var fDistance: number = Math.sqrt(fDistanceSquare+0.0001);
			var fRatio: number = 0.;

/*1 +*/
			fRatio = (pVTree[iIndex] / fTerrainSizeZ * fScale) /((        fDistance/fTerrainDiagonal) * fLimit);

			if (fRatio > 1.) {
// subdivide this triangle
				this.split(pTri);
			}
		}

// Если треугольник поделен, продолжаем
		if (pTri.leftChild) {
			this.recursiveTessellate(pTri.leftChild,
				iMidpointX, iMidpointY, fRealMidPointZ,
				iCornerAX, iCornerAY, fCornerAZ,
				iCornerBX, iCornerBY, fCornerBZ,
				pVTree, iIndex<<1);

			this.recursiveTessellate(pTri.rightChild,
				iMidpointX, iMidpointY, fRealMidPointZ,
				iCornerCX, iCornerCY, fCornerCZ,
				iCornerAX, iCornerAY, fCornerAZ,
				pVTree, (iIndex<<1)+1);
		}
	}

	private split(pTri: ITriTreeNode): void {
// Если разбит то смысла разбивать еще нет
		if (pTri.leftChild){
			return;
		}

// If this triangle is not in a proper diamond, force split our base neighbor
		if (pTri.baseNeighbor && (pTri.baseNeighbor.baseNeighbor !== pTri)){
			this.split(pTri.baseNeighbor);
		}
// Create children and link into mesh
		pTri.leftChild  = this.triNodePool.request();
		pTri.rightChild = this.triNodePool.request();

// Если не удалось выделить треугольник, то не разбиваем
		if ( (!pTri.leftChild) || (!pTri.rightChild)) {
			pTri.leftChild  = null;
			pTri.rightChild = null;
			return;
		}

// Fill in the information we can get from the parent (neighbor pointers)
		pTri.leftChild.baseNeighbor  = pTri.leftNeighbor;
		pTri.leftChild.leftNeighbor  = pTri.rightChild;

		pTri.rightChild.baseNeighbor  = pTri.rightNeighbor;
		pTri.rightChild.rightNeighbor = pTri.leftChild;

// Link our Left Neighbor to the new children
		if (pTri.leftNeighbor) {
			if (pTri.leftNeighbor.baseNeighbor == pTri) {
				pTri.leftNeighbor.baseNeighbor = pTri.leftChild;
			}
			else if (pTri.leftNeighbor.leftNeighbor == pTri) {
				pTri.leftNeighbor.leftNeighbor = pTri.leftChild;
			}
			else if (pTri.leftNeighbor.rightNeighbor == pTri) {
				pTri.leftNeighbor.rightNeighbor = pTri.leftChild;
			}
		}

// Link our Right Neighbor to the new children
		if (pTri.rightNeighbor) {
			if (pTri.rightNeighbor.baseNeighbor == pTri) {
				pTri.rightNeighbor.baseNeighbor = pTri.rightChild;
			}
			else if (pTri.rightNeighbor.rightNeighbor == pTri) {
				pTri.rightNeighbor.rightNeighbor = pTri.rightChild;
			}
			else if (pTri.rightNeighbor.leftNeighbor == pTri) {
				pTri.rightNeighbor.leftNeighbor = pTri.rightChild;
			}
		}

// Link our Base Neighbor to the new children
		if (pTri.baseNeighbor) {
			if ( pTri.baseNeighbor.leftChild ) {
				pTri.baseNeighbor.leftChild.rightNeighbor = pTri.rightChild;
				pTri.baseNeighbor.rightChild.leftNeighbor = pTri.leftChild;
				pTri.leftChild.rightNeighbor = pTri.baseNeighbor.rightChild;
				pTri.rightChild.leftNeighbor = pTri.baseNeighbor.leftChild;
			}
			else {
// Base Neighbor (in a diamond with us) was not split yet, so do that now.
				this.split(pTri.baseNeighbor);
			}
		}
		else {
// An edge triangle, trivial case.
			pTri.leftChild.rightNeighbor = null;
			pTri.rightChild.leftNeighbor = null;
		}
	}

	private buildTriangleList(pSection: ITerrainSectionInfo): void {
		var iSectorVerts: number = this.sectorUnits + 1;
// add all the triangles to the roamTerrain
// in root triangle A

		this.recursiveBuildTriangleList(pSection, pSection.rootTriangleA,
			0, iSectorVerts - 1, (iSectorVerts - 1) * iSectorVerts);

// add all the triangles to the roamTerrain
// in root triangle B
		this.recursiveBuildTriangleList(pSection, pSection.rootTriangleB,
			(iSectorVerts * iSectorVerts) - 1, (iSectorVerts - 1) * iSectorVerts, iSectorVerts - 1);
	}

	private recursiveBuildTriangleList(pSection: ITerrainSectionInfo, pTri: ITriTreeNode,
									   iPointBase: number, iPointLeft: number, iPointRight: number): void {
		if (pTri.leftChild) {

			var iPointMid: number = (iPointLeft + iPointRight) * 0.5;
			this.recursiveBuildTriangleList(
				pSection,
				pTri.leftChild,
				iPointMid, iPointBase, iPointLeft);
			this.recursiveBuildTriangleList(
				pSection,
				pTri.rightChild,
				iPointMid, iPointRight, iPointBase);

		}
		else {
			var nElementSize: number = 0;
			if(this.isUsedVertexNormal){
/*кординаты вершин*/
/*нормаль*/
/*текстурные координаты*/
				nElementSize = (3                                    + 3                   + 2                                             );
			}
			else {
/*кординаты вершин*/
/*текстурные координаты*/
				nElementSize =  (3                                    + 2                                             );
			}

// add the local triangle to the index list

			this.tessellationIndices[this.totalIndices++] = ((iPointRight + pSection.startIndex) * nElementSize * 4 + this.vertexID)/4;
			this.tessellationIndices[this.totalIndices++] = ((iPointLeft  + pSection.startIndex) * nElementSize * 4 + this.vertexID)/4;
			this.tessellationIndices[this.totalIndices++] = ((iPointBase  + pSection.startIndex) * nElementSize * 4 + this.vertexID)/4;
		}
	}
}






var pTerrain: ITerrainInfo = null;
function processInitTerrain(pInitInfo: ITerrainInitInfo): void {
	pTerrain = new TerrainInfo(pInitInfo);
	(<any>self).postMessage("ok");
}

/** 
 * format of pData. pData size in bytes = ( 4 * (pTerrain.maxTriTreeNodeCount * 3) + 4) 
 * 3 float32 - float camera coords
 * 1 uint32 - length of tessellation queue of terrainSection. Define as L.
 * L uint32 - index of sections to tesselate
 * @type {[type]}
 */

function processTesselate(pData: ArrayBuffer): void {
	var pDataView: DataView = new DataView(pData, 0, 16);
	var iTesselationQueueSize: number = pDataView.getUint32(12, true);

	pTerrain.cameraCoord.set(new Float32Array(pData, 0, 3));
	pTerrain.tessellationQueueSize = iTesselationQueueSize;
	pTerrain.tessellationQueue.set(new Uint32Array(pData, 4*4, iTesselationQueueSize));
	pTerrain.tessellationIndices = new Float32Array(pData, 4);

	pTerrain.processTessellationQueue();

	pDataView.setUint32(0, pTerrain.totalIndices, true);
	pTmpTransferableArray[0] = pData;

	(<any>self).postMessage(pData, pTmpTransferableArray);
}


function processUpdateParams(pUpdateInfo: any): void{

}




//copy threads from sources to {data} folder and modify path to relative

/// @TESSELLATION_THREAD: {data}/js/TessellationThread.t.js|src(inc/util/TessellationThread.t.js)|data_location({data},DATA)





// #define PROFILE_TESSEALLATION 1

module akra.terrain {
	export class TerrainROAM implements ITerrainROAM extends Terrain {
		private _pRenderableObject: IRenderableObject = null;
		private _pRenderData: IRenderData = null;
		private _pDataIndex: IVertexData = null;

		private _iTotalIndices:  number ;
		private _iTotalIndicesOld:  number ;
	    private _iTotalIndicesMax:  number ;
	    private _pIndexList: Float32Array = null;
	    private _pVerts:  number [];
	    private _iVertexID:  number ;
	    private _pTessellationQueue: ITerrainSectionROAM[] = null;
		private _iTessellationQueueCount:  number  = 0;
		private _isRenderInThisFrame: bool = false;
/*64k triangle nodes*/
		private _iMaxTriTreeNodes:  number  = (1024*64*4);
		private _iTessellationQueueSize:  number  = 0;
//массив подчиненный секций 
		protected _pSectorArray: ITerrainSectionROAM[] = null;

		protected _fScale:  number  = 0.0;
		protected _fLimit:  number  = 0.0;

		private _iTessellationQueueCountOld:  number  = 0;
		private _nCountRender:  number  = 0;

		private _m4fLastCameraMatrix: IMat4 = new Mat4();
		private _m4fLastTessellationMatrix: IMat4 = new Mat4();
		private _v3fLocalCameraCoord: IVec3 = new Vec3();
		private _isNeedReset: bool = true;

		private _fLastTessellationTime:  number  = 0.;
		private _fTessellationSelfInterval:  number  = 1./25.;
		private _fTessellationThreadInterval:  number  = 1./60.;

		private _bUseTessellationThread: bool = false;
		private _bIsInitTessellationSelfData: bool = false;
		private _bIsInitTessellationThreadData: bool = false;

		private _pTessellationThread: Worker = null;
		private _pTessellationTransferableData: ArrayBuffer = null;
		private _pTmpTransferableArray: any[] = null;

		private _bIsReadyForTesseltion: bool = false;

		private _pNodePool: ITriangleNodePool = null;

// private _pTestTerrainInfo: util.TerrainInfo = null;


		constructor(pScene: IScene3d, eType: EEntityTypes = EEntityTypes.TERRAIN_ROAM) {
			super(pScene, eType);
			this._pRenderData = this._pDataFactory.getEmptyRenderData(EPrimitiveTypes.TRIANGLELIST,ERenderDataBufferOptions.RD_ADVANCED_INDEX);
			this._pRenderableObject = new render.RenderableObject();
			this._pRenderableObject._setup(this._pEngine.getRenderer());
			this._pRenderableObject._setRenderData(this._pRenderData);

/*, EEventTypes.UNICAST*/
			this.connect(this._pRenderableObject,  "beforeRender" ,  "_onBeforeRender"                          );
		}

		/**@inline*/  get tessellationScale():  number {
			return this._fScale;
		};

		/**@inline*/  set tessellationScale(fScale:  number ){
			this._fScale = fScale;
		};

		/**@inline*/  get tessellationLimit():  number {
			return this._fLimit;
		};

		/**@inline*/  set tessellationLimit(fLimit:  number ){
			this._fLimit = fLimit;
		};

		/**@inline*/  get useTessellationThread(): bool {
			return this._bUseTessellationThread;
		}

		/**@inline*/  set useTessellationThread(bUseThread: bool) {
			this._bUseTessellationThread = bUseThread;

			if(this._isCreate){
				if(bUseThread && !this._bIsInitTessellationThreadData){
					this.initTessellationThreadData();
				}
				else if(!bUseThread && !this._bIsInitTessellationSelfData){
					this.initTessellationSelfData();
				}
			}

		}

		/**@inline*/  get maxTriTreeNodes():  number  {
			return this._iMaxTriTreeNodes;
		}

		/**@inline*/  get verts():  number [] {
			return this._pVerts;
		}

		/**@inline*/  get index(): Float32Array {
			return this._pIndexList;
		}

		/**@inline*/  get totalIndex():  number  {
			return this._iTotalIndices;
		}

		/**@inline*/  set totalIndex(iTotalIndices:  number ) {
			this._iTotalIndices = iTotalIndices;
		}

		/**@inline*/  get vertexId():  number  {
			return this._iVertexID;
		}

		/**@inline*/  get totalRenderable():  number  {
			return !isNull(this._pRenderableObject) ? 1 : 0;
		}

		/**@inline*/  getRenderable(i?:  number ): IRenderableObject {
			return this._pRenderableObject;
		}

		/**@inline*/  get localCameraCoord(): IVec3 {
			return this._v3fLocalCameraCoord;
		}


		init(pImgMap: IImageMap, worldExtents: IRect3d, iShift:  number , iShiftX:  number , iShiftY:  number , sSurfaceTextures: string, pRootNode?: ISceneObject = null)
		{
			var bResult: bool = super.init(pImgMap,worldExtents, iShift, iShiftX, iShiftY, sSurfaceTextures, pRootNode);
			if (bResult)
			{
				this._iTessellationQueueSize = this.sectorCountX * this.sectorCountY;
				this._pTessellationQueue = new Array(this._iTessellationQueueSize);
				this._iTessellationQueueCount = 0;
				this._isCreate = true;
				this._iTotalIndicesMax=0;

				for(var i:  number  = 0; i < this._pTessellationQueue.length; i++){
					this._pTessellationQueue[i] = null;
				}

				this._pRenderableObject.getTechnique().setMethod(this._pDefaultRenderMethod);
				this.connect(this._pRenderableObject.getTechnique(),  "render" ,  "_onRender" );

				if(!this._bUseTessellationThread){
					this._pNodePool = new TriangleNodePool(this._iMaxTriTreeNodes);
				}

				this._setTessellationParameters(10.0, 0.5);
				this.reset();


				if(this._bUseTessellationThread){
					this.initTessellationThreadData();
				}
				else {
					this._bIsInitTessellationSelfData = true;
					this._bIsReadyForTesseltion = true;
				}

				this._isCreate = true;
			}
			else {
				this._isCreate = false;
			}

			return bResult;
		}

		destroy(): void {
			delete this._pNodePool;
			delete this._pTessellationQueue;

			this._iTessellationQueueCount = 0;
			this._fScale = 0;
			this._fLimit = 0;
//Terrain.prototype.destroy.call(this); с какого то хуя этого метода не оказалось
		}

		protected initTessellationSelfData(): void {
			this._bIsReadyForTesseltion = true;

			if(this._bIsInitTessellationSelfData){
				return;
			}

			this._pNodePool = new TriangleNodePool(this._iMaxTriTreeNodes);
			for(var i:  number  = 0; i < this._pSectorArray.length; i++){
				this._pSectorArray[i]._initTessellationData();
			}

			this._bIsInitTessellationSelfData = true;
		}

		protected initTessellationThreadData(): void {
			this._bIsReadyForTesseltion = false;

			if(this._bIsInitTessellationThreadData){
				return;
			}

			var me: TerrainROAM = this;
			var pThread: Worker = this._pTessellationThread = new  Worker("@TESSELLATION_THREAD") ;

			pThread.onmessage = function(event: any){
				if(event.data === "ok"){
					me.successThreadInit();
				}
				else {
					{ logger.setSourceLocation( "terrain/TerrainROAM.ts" , 256 ); logger.warning("Cannot inititalize tessellation thread. So we will tessellate terraint in main thread."); } ;
					me.useTessellationThread = false;
					me.terminateTessellationThread();
				}
			};

			pThread.onerror = function (event: any){
				{ logger.setSourceLocation( "terrain/TerrainROAM.ts" , 263 ); logger.warning("Error occured in tessellation thread. So we will tessellate terraint in main thread."); } ;
				{ logger.setSourceLocation( "terrain/TerrainROAM.ts" , 264 ); logger.log(event); } ;
				pThread.onmessage = null;
				me.useTessellationThread = false;
				me.terminateTessellationThread();
			};

			this._bIsInitTessellationThreadData = true;

			var pHeightTableCopy: Float32Array = new Float32Array(this._pHeightTable.length);
			pHeightTableCopy.set(this._pHeightTable);

			pThread.postMessage({
				type: 1,
				info: {
					heightMapTable: pHeightTableCopy.buffer,
					tableWidth: this.tableWidth,
					tableHeight: this.tableHeight,
					sectorUnits: this._iSectorUnits,
					sectorCountX: this._iSectorCountX,
					sectorCountY: this._iSectorCountY,
					isUsedVertexNormal: this._bUseVertexNormal,
					worldExtents: {
						x0: this._pWorldExtents.x0,
						x1: this._pWorldExtents.x1,
						y0: this._pWorldExtents.y0,
						y1: this._pWorldExtents.y1,
						z0: this._pWorldExtents.z0,
						z1: this._pWorldExtents.z1
					},
					maxHeight: this.maxHeight,
					maxTriTreeNodeCount: this._iMaxTriTreeNodes,

					tessellationScale: this._fScale,
					tessellationLimit: this._fLimit,

					vertexID: this._iVertexID
				}
			}, [pHeightTableCopy.buffer]);

		}

		protected terminateTessellationThread(): void {
			this._pTessellationThread.terminate();
			this._bIsInitTessellationThreadData = false;
		}

		/**@inline*/  successThreadInit(): void {
			var me: TerrainROAM = this;
			this._pTessellationTransferableData = new ArrayBuffer(4 * this._iMaxTriTreeNodes * 3 + 4);
			this._pTmpTransferableArray = [null];
			this._bIsReadyForTesseltion = true;

			this._pTessellationThread.onmessage = function(event: any){
				me.prepareIndexData(<ArrayBuffer>event.data);
			};
		}

		protected _allocateSectors(): bool {
			var nElementSize:  number  = 0;
			if(this._useVertexNormal()){
/*кординаты вершин*/
/*нормаль*/
/*текстурные координаты*/
				nElementSize = (3                                    + 3                   + 2                                             );
			}
			else {
/*кординаты вершин*/
/*текстурные координаты*/
				nElementSize =  (3                                    + 2                                             );
			}

			this._pSectorArray = new Array(this._iSectorCountX * this._iSectorCountY);

//Вершинный буфер для всех
/*количество секции*/
			this._pVerts = new Array((this._iSectorCountX*this._iSectorCountY                                     ) *
/*размер секции в вершинах*/
									 (this._iSectorVerts * this._iSectorVerts                                                 ) *
									 (nElementSize));

			for(var i:  number  = 0; i < this._pSectorArray.length; i++) {
				this._pSectorArray[i] = this.scene.createTerrainSectionROAM();
			}

// create the sector objects themselves
			for (var y:  number  = 0; y < this._iSectorCountY; ++y) {
				for (var x:  number  = 0; x < this._iSectorCountX; ++x) {
//cVector2 sectorPos(
					var v2fSectorPos: IVec2 = new Vec2();
					v2fSectorPos.set(
						this._pWorldExtents.x0 + (x * this._v2fSectorSize.x),
						this._pWorldExtents.y0 + (y * this._v2fSectorSize.y));

//cRect2d r2fSectorRect(
					var r2fSectorRect: IRect2d = new geometry.Rect2d();
					r2fSectorRect.set(
						v2fSectorPos.x, v2fSectorPos.x + this._v2fSectorSize.x,
						v2fSectorPos.y, v2fSectorPos.y + this._v2fSectorSize.y);

					var iXPixel:  number  = x << this._iSectorShift;
					var iYPixel:  number  = y << this._iSectorShift;
					var iIndex:  number  = (y * this._iSectorCountX) + x;

					if (!this._pSectorArray[iIndex]._internalCreate(
/*Терраин*/
						this,
/*Номер секции оп иксу и игрику*/
						x, y,
/*Координаты секции в картах нормалей и врешин*/
						iXPixel, iYPixel,
/*Количесвто вершин в секции по иску и игрику*/
						this._iSectorVerts,
						this._iSectorVerts,
						r2fSectorRect,
/*размер секции в вершинах*/
						iIndex*(this._iSectorVerts * this._iSectorVerts                                                 ))){
						return false;
					}
				}
			}

			var pVertexDescription: IVertexElementInterface[] = null;
			if(this._useVertexNormal()){
				pVertexDescription = [VE_FLOAT3(DeclarationUsages.POSITION), VE_FLOAT3(DeclarationUsages.NORMAL), VE_FLOAT2(DeclarationUsages.TEXCOORD)];
			}
			else {
				pVertexDescription = [VE_FLOAT3(DeclarationUsages.POSITION), VE_FLOAT2(DeclarationUsages.TEXCOORD)];
			}

			this._iVertexID = this._pRenderData.allocateData(pVertexDescription, new Float32Array(this._pVerts));


//Индексны буфер для всех
			this._iTotalIndices = 0;
//Максимальное количество треугольников помноженное на 3 вершины на каждый треугольник
			this._pIndexList = new Float32Array(this._iMaxTriTreeNodes*3);
			this._pRenderData.allocateIndex([VE_FLOAT(DeclarationUsages.INDEX0), VE_FLOAT(DeclarationUsages.POSITION, 0)],this._pIndexList);
			this._pRenderData.index(this._iVertexID, DeclarationUsages.INDEX0);
			this._pDataIndex = this._pRenderData.getAdvancedIndexData(DeclarationUsages.INDEX0);

			return true;
		}

		reset(): void {
			this._isRenderInThisFrame = false;

			if(this._isCreate) {
				super.reset();
// reset internal counters
				for(var i:  number  = 0; i < this._iTessellationQueueCount; i++){
					this._pTessellationQueue[i] = null;
				}

				this._iTessellationQueueCount = 0;
// this._pTessellationQueue.length = this._iTessellationQueueSize;

				if(!this._bUseTessellationThread && this._bIsInitTessellationSelfData){
					this._pNodePool.reset();

// reset each section
					for (var i:  number  = 0; i < this._pSectorArray.length; i++) {
						this._pSectorArray[i].reset();
					}
				}
			}
		}

		resetWithCamera(pCamera: ICamera): bool {
			if(this._bIsReadyForTesseltion && !this._isOldCamera(pCamera)){
				if(this._isNeedReset){

					this.reset();
					this._isNeedReset = false;

					var v4fCameraCoord: IVec4 =  Vec4.stackCeil.set(pCamera.worldPosition, 1.) ;

		    		v4fCameraCoord = this.inverseWorldMatrix.multiplyVec4(v4fCameraCoord);

		    		this._v3fLocalCameraCoord.set(v4fCameraCoord.x, v4fCameraCoord.y, v4fCameraCoord.z);

// return true;
				}

				return true;
// return false;
			}
			else {
// return true;
				return false;
			}
		}

		requestTriNode(): ITriTreeNode {
			return this._pNodePool.request();
		}

		addToTessellationQueue(pSection: ITerrainSectionROAM): bool {
			if (this._iTessellationQueueCount < this._iTessellationQueueSize) {
				this._pTessellationQueue[this._iTessellationQueueCount] = pSection;
				this._iTessellationQueueCount++;
				return true;
			}

// while we handle this failure gracefully
// in release builds, we alert ourselves
// to the situation with an assert in debug
// builds so we can increase the queue size
			{ logger.setSourceLocation( "terrain/TerrainROAM.ts" , 459 ); logger.warning("increase the size of the ROAM tessellation queue"); } ;
			return false;
		}

		protected processTessellationQueue(): void {
// this._pTessellationQueue.length = this._iTessellationQueueCount;
			this._pTessellationQueue.sort(TerrainROAM.fnSortSection);

			if(this._bUseTessellationThread){
				var pDataView: DataView = new DataView(this._pTessellationTransferableData);

				pDataView.setFloat32(0, this._v3fLocalCameraCoord.x, true);
				pDataView.setFloat32(4, this._v3fLocalCameraCoord.y, true);
				pDataView.setFloat32(8, this._v3fLocalCameraCoord.z, true);

				pDataView.setUint32(12, this._iTessellationQueueCount, true);

// var pSectionIndices: Uint32Array = new Uint32Array(this._pTessellationTransferableData, 16);
				for (var i:  number  = 0; i < this._iTessellationQueueCount; ++i) {
					pDataView.setUint32(16 + i * 4, this._pTessellationQueue[i].sectionIndex, true);
// pSectionIndices[i] = this._pTessellationQueue[i].sectionIndex;
				}

				this._pTmpTransferableArray[0] = this._pTessellationTransferableData;
				this._pTessellationThread.postMessage(this._pTessellationTransferableData, this._pTmpTransferableArray);
				this._bIsReadyForTesseltion = false;
			}
			else {
				for (var i:  number  = 0; i < this._iTessellationQueueCount; ++i) {
// split triangles based on the
// scale and limit values
					this._pTessellationQueue[i].tessellate(
						this._fScale, this._fLimit);
				}

				this._iTotalIndices = 0;

// gather up all the triangles into
// a final index buffer per section

				for (var i:  number  = 0; i < this._iTessellationQueueCount; ++i) {
					this._pTessellationQueue[i].buildTriangleList();
				}

				if(this._iTotalIndicesOld === this._iTotalIndices && this._iTotalIndices !== this._iTotalIndicesMax) {
					return;
				}


				this._pRenderData._setIndexLength(this._iTotalIndices);
				this._pDataIndex.setData(this._pIndexList, 0, getTypeSize(EDataTypes.FLOAT), 0, this._iTotalIndices);
				this._iTotalIndicesOld = this._iTotalIndices;
				this._iTotalIndicesMax = math.max(this._iTotalIndicesMax,this._iTotalIndices);

				this._pRenderableObject._setRenderData(this._pRenderData);
			}
		}

		protected prepareIndexData(pData: ArrayBuffer): void {
			var iTotalIndices:  number  = (new Uint32Array(pData, 0, 1))[0];
			var pTmpData: Float32Array =  new Float32Array(pData, 4, iTotalIndices);

			this._iTotalIndices = iTotalIndices;
			this._pIndexList.set(pTmpData);

			this._pRenderData._setIndexLength(this._iTotalIndices);
			this._pDataIndex.setData(this._pIndexList, 0, getTypeSize(EDataTypes.FLOAT), 0, this._iTotalIndices);

			this._pRenderableObject._setRenderData(this._pRenderData);

			this._pTessellationTransferableData = pData;

			this._bIsReadyForTesseltion = true;
		}


		protected _setTessellationParameters(fScale:  number , fLimit:  number ): void {
		    this._fScale = fScale;
		    this._fLimit = fLimit;
		}

		/**@inline*/  _isOldCamera(pCamera: ICamera): bool {
			return this._m4fLastCameraMatrix.isEqual(pCamera.worldMatrix);
		}

		_onBeforeRender(pRenderableObject: IRenderableObject, pViewport: IViewport): void {
			if(this._bIsReadyForTesseltion) {

				var pCamera: ICamera = pViewport.getCamera();
				var fCurrentTime:  number  = this.scene.getManager().getEngine().time;

				this._m4fLastCameraMatrix.set(pCamera.worldMatrix);

				if ((this._bUseTessellationThread &&
					fCurrentTime - this._fLastTessellationTime > this._fTessellationThreadInterval) ||
					fCurrentTime - this._fLastTessellationTime > this._fTessellationSelfInterval) {



					if(!this._m4fLastCameraMatrix.isEqual(this._m4fLastTessellationMatrix)) {
						this.processTessellationQueue();
						this._m4fLastTessellationMatrix.set(this._m4fLastCameraMatrix);
//this._iTessellationQueueCountOld = this._iTessellationQueueCount;
					}

					this._fLastTessellationTime = fCurrentTime;
				}
			}

			this._isNeedReset = true;
		}

		static private fnSortSection(pSectionA: ITerrainSectionROAM, pSectionB: ITerrainSectionROAM):  number  {
			if(isNull(pSectionA)){
				return 1;
			}
			else if(isNull(pSectionB)){
				return -1;
			}
			else {
				return pSectionA.queueSortValue - pSectionB.queueSortValue;
			}
		}
	}
}















































module akra.util{
	export function calculatePlanesForFrustumLighting(pLightFrustum: IFrustum, v3fLightPosition: IVec3,
					 pCameraFrustum: IFrustum, pResultArray: IPlane3d[]) :  number {

		var pFrustumPlanesKeys: string[] = geometry.Frustum.frustumPlanesKeys;

		var v3fNormal: IVec3 =  Vec3.stackCeil.set() ;
		var fDistance:  number ;

		var pPlanePoints: IVec3[] = [ Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ];

		var v3fTmp: IVec3 =  Vec3.stackCeil.set() ;
		var fThreshold:  number  = 0.1;

		for(var i:  number  = 0; i<6; i++){
			var sKey: string = pFrustumPlanesKeys[i];
			var pPlane: IPlane3d = pCameraFrustum[sKey];

			v3fNormal.set(pPlane.normal);
			fDistance = pPlane.distance;

			if(pPlane.signedDistance(v3fLightPosition) > 0){
//extract four plane points (frustum verticies)
				pCameraFrustum.getPlanePoints(sKey, pPlanePoints);

//we need find two farest points from v3fLightPosition;

				var fLength0:  number  = pPlanePoints[0].subtract(v3fLightPosition,v3fTmp).lengthSquare();
				var fLength1:  number  = pPlanePoints[1].subtract(v3fLightPosition,v3fTmp).lengthSquare();
				var fLength2:  number  = pPlanePoints[2].subtract(v3fLightPosition,v3fTmp).lengthSquare();
				var fLength3:  number  = pPlanePoints[3].subtract(v3fLightPosition,v3fTmp).lengthSquare();

				var pIndexes;

				if(fLength0 > fLength1 && fLength0 > fLength2 && fLength0 > fLength3){
					if(fLength1 > fLength2 && fLength1 > fLength3)
						pIndexes = [0, 1, 2, 3];
					else if(fLength2 > fLength1 && fLength2 > fLength3)
						pIndexes = [0, 2, 1, 3];
					else
						pIndexes = [0, 3, 1, 2];
				}
				else if(fLength1 > fLength0 && fLength1 > fLength2 && fLength1 > fLength3){
					if(fLength0 > fLength2 && fLength0 > fLength3)
						pIndexes = [1, 0, 2, 3];
					else if(fLength2 > fLength0 && fLength2 > fLength3)
						pIndexes = [1, 2, 0, 3];
					else
						pIndexes = [1, 3, 0, 2];
				}
				else if(fLength2 > fLength0 && fLength2 > fLength1 && fLength2 > fLength3){
					if(fLength0 > fLength1 && fLength0 > fLength3)
						pIndexes = [2, 0, 1, 3];
					else if(fLength1 > fLength0 && fLength1 > fLength3)
						pIndexes = [2, 1, 0, 3];
					else
						pIndexes = [2, 3, 0, 1];
				}
				else{
					if(fLength0 > fLength1 && fLength0 > fLength2)
						pIndexes = [3, 0, 1, 2];
					else if(fLength1 > fLength0 && fLength1 > fLength2)
						pIndexes = [3, 1, 0, 2];
					else
						pIndexes = [3, 2, 0, 1];
				}

				var pTestPlane: IPlane3d = pResultArray[i];
				pTestPlane.set(v3fLightPosition, pPlanePoints[pIndexes[0]], pPlanePoints[pIndexes[1]]);

//test with two remaining points

				fLength1 = pTestPlane.signedDistance(pPlanePoints[pIndexes[2]]);
				fLength2 = pTestPlane.signedDistance(pPlanePoints[pIndexes[3]]);

				if(math.abs(fLength1) <= fThreshold || math.abs(fLength2) <= fThreshold){
					pTestPlane.set(pPlane.normal, -pPlane.normal.dot(v3fLightPosition));
				}
				else if(fLength1 > 0 && fLength2 > 0) {
					pTestPlane.negate();
				}
			}
			else{
				pResultArray[i].set(v3fNormal, fDistance);
			}
		}
		return 6;
	};

	export function calculatePlanesForOrthogonalLighting(pLightFrustum: IFrustum, v3fLightPosition: IVec3,
					 pCameraFrustum: IFrustum, pResultArray: IPlane3d[]) :  number {

//orthogonal projection
//defining light sight direction;

		var pFrustumPlanesKeys: string[] = geometry.Frustum.frustumPlanesKeys;

		var v3fLightDirection: IVec3 = pLightFrustum.getViewDirection( Vec3.stackCeil.set() );
		var fThreshold:  number  = 0.1;

		var pPlanePoints: IVec3[] = [ Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ,  Vec3.stackCeil.set() ];

		var v3fTmp: IVec3 =  Vec3.stackCeil.set() ;

		var nAdditionalTestLength:  number  = 0;

		for(var i:  number  = 0; i<6; i++){
			var sKey: string = pFrustumPlanesKeys[i];
			var pPlane: IPlane3d = pCameraFrustum[sKey];

			if(v3fLightDirection.dot(pPlane.normal) >= 0.){
//adding plane

				pResultArray[nAdditionalTestLength].set(pPlane);
				nAdditionalTestLength++;
			}
			else{

				pCameraFrustum.getPlanePoints(sKey, pPlanePoints);

//we need find two farest points from v3fLightPosition;

				var fLength0:  number  = pPlanePoints[0].subtract(v3fLightPosition,v3fTmp).lengthSquare();
				var fLength1:  number  = pPlanePoints[1].subtract(v3fLightPosition,v3fTmp).lengthSquare();
				var fLength2:  number  = pPlanePoints[2].subtract(v3fLightPosition,v3fTmp).lengthSquare();
				var fLength3:  number  = pPlanePoints[3].subtract(v3fLightPosition,v3fTmp).lengthSquare();

				var pIndexes;

				if(fLength0 > fLength1 && fLength0 > fLength2 && fLength0 > fLength3){
					if(fLength1 > fLength2 && fLength1 > fLength3)
						pIndexes = [0, 1, 2, 3];
					else if(fLength2 > fLength1 && fLength2 > fLength3)
						pIndexes = [0, 2, 1, 3];
					else
						pIndexes = [0, 3, 1, 2];
				}
				else if(fLength1 > fLength0 && fLength1 > fLength2 && fLength1 > fLength3){
					if(fLength0 > fLength2 && fLength0 > fLength3)
						pIndexes = [1, 0, 2, 3];
					else if(fLength2 > fLength0 && fLength2 > fLength3)
						pIndexes = [1, 2, 0, 3];
					else
						pIndexes = [1, 3, 0, 2];
				}
				else if(fLength2 > fLength0 && fLength2 > fLength1 && fLength2 > fLength3){
					if(fLength0 > fLength1 && fLength0 > fLength3)
						pIndexes = [2, 0, 1, 3];
					else if(fLength1 > fLength0 && fLength1 > fLength3)
						pIndexes = [2, 1, 0, 3];
					else
						pIndexes = [2, 3, 0, 1];
				}
				else{
					if(fLength0 > fLength1 && fLength0 > fLength2)
						pIndexes = [3, 0, 1, 2];
					else if(fLength1 > fLength0 && fLength1 > fLength2)
						pIndexes = [3, 1, 0, 2];
					else
						pIndexes = [3, 2, 0, 1];
				}

				var pPoint1: IVec3 = pPlanePoints[pIndexes[0]];
				var pPoint2: IVec3 = pPlanePoints[pIndexes[1]];

				var v3fDir: IVec3 = pPoint2.subtract(pPoint1, v3fTmp);

				var v3fNormal: IVec3 = v3fDir.cross(v3fLightDirection).normalize();

				var pTestPlane: IPlane3d = pResultArray[nAdditionalTestLength];
				pTestPlane.set(v3fNormal, -v3fNormal.dot(pPoint1));

				var pVertices: IVec3[] = pCameraFrustum.frustumVertices;

//test on right orientation new plane (two point already on plane)
				var iTest:  number  = 0;
				for(var k:  number  = 0; k < 8; k++){
					if(pTestPlane.signedDistance(pVertices[k]) > fThreshold){
						iTest++;
					}
				}

				if(iTest == 6){
					pTestPlane.negate();
				}
				else if(iTest != 0){
					continue;
				}

				nAdditionalTestLength++;
			}
		}

		return nAdditionalTestLength;
	};
}



module akra.scene.light {

	export  class  ProjectParameters implements IProjectParameters {
		ambient: IColor = new Color;
	    diffuse: IColor = new Color;
	    specular: IColor = new Color;
	    attenuation: IVec3 = new Vec3;
	}

	export class ProjectLight extends LightPoint implements IProjectLight {
		protected _pDepthTexture: ITexture = null;
		protected _pColorTexture: ITexture = null;
		protected _pLightParameters: IProjectParameters = new ProjectParameters;
		protected _pShadowCaster: IShadowCaster;

		/**@inline*/  get params(): IProjectParameters {
			return this._pLightParameters;
		};

		constructor (pScene: IScene3d) {
			super(pScene, ELightTypes.PROJECT);
			this._pShadowCaster = pScene._createShadowCaster(this);
		};

		create(isShadowCaster: bool = true, iMaxShadowResolution:  number  = 256): bool{
			var isOk: bool = super.create(isShadowCaster, iMaxShadowResolution);

			var pCaster: IShadowCaster = this._pShadowCaster;

			pCaster.setParameter(ECameraParameters.CONST_ASPECT, true);
			pCaster.setInheritance(ENodeInheritance.ALL);
			pCaster.attachToParent(this);

			if (this.isShadowCaster) {
				this.initializeTextures();
			}

			return isOk;
		};

		/**@inline*/  getDepthTexture(): ITexture {
			return this._pDepthTexture;
		};

		/**@inline*/  getRenderTarget(): IRenderTarget {
// return this._pDepthTexture.getBuffer().getRenderTarget();
			return this._pColorTexture.getBuffer().getRenderTarget();
		};

		/**@inline*/  getShadowCaster(): IShadowCaster {
			return this._pShadowCaster;
		};

		/**@inline*/  get isShadowCaster(): bool {
			return this._isShadowCaster;
		};

/**
		 * overridden setter isShadow caster,
		 * if depth texture don't created then create depth texture
		 */

		set isShadowCaster(bValue: bool){
			this._isShadowCaster = bValue;
			if(bValue && isNull(this._pDepthTexture)){
				this.initializeTextures();
			}
		};

		/**@inline*/  get lightingDistance():  number {
			return this._pShadowCaster.farPlane;
		};

		/**@inline*/  set lightingDistance(fDistance){
			this._pShadowCaster.farPlane = fDistance;
		};

		protected initializeTextures(): void {
			var pEngine: IEngine = this.scene.getManager().getEngine();
			var pResMgr: IResourcePoolManager = pEngine.getResourceManager();
			var iSize:  number  = this._iMaxShadowResolution;

// if (!isNull(this._pDepthTexture)){
// 	this._pDepthTexture.destroyResource();
// }

			var pDepthTexture: ITexture = this._pDepthTexture =
				pResMgr.createTexture("depth_texture_" + this.getGuid());
			pDepthTexture.create(iSize, iSize, 1, null, 0,
								 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.DEPTH32);

			pDepthTexture.setWrapMode(ETextureParameters.WRAP_S, ETextureWrapModes.CLAMP_TO_EDGE);
			pDepthTexture.setWrapMode(ETextureParameters.WRAP_T, ETextureWrapModes.CLAMP_TO_EDGE);
			pDepthTexture.setFilter(ETextureParameters.MAG_FILTER, ETextureFilters.LINEAR);
			pDepthTexture.setFilter(ETextureParameters.MIN_FILTER, ETextureFilters.LINEAR);

// if (this._pColorTexture) {
// 	this._pColorTexture.destroy();
// }

			var pColorTexture: ITexture = pResMgr.createTexture("light_color_texture_" + this.getGuid());
			pColorTexture.create(iSize, iSize, 1, null, ETextureFlags.RENDERTARGET,
						  0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.R8G8B8A8);

			this._pColorTexture = pColorTexture;

// this._pColorTexture = pColorTexture;
//TODO: Multiple render target
			this.getRenderTarget().attachDepthTexture(pDepthTexture);
			this.getRenderTarget().setAutoUpdated(false);
			this.getRenderTarget().addViewport(new render.ShadowViewport(this._pShadowCaster));
		};

		_calculateShadows(): void {
			if (this.enabled && this.isShadowCaster) {
				this.getRenderTarget().update();
			}
		};

		_prepareForLighting(pCamera: ICamera): bool{
			if(!this.enabled){
				return false;
			}
			else{
/*************************************************************/

//optimize camera frustum
				var pDepthRange: IDepthRange = pCamera.getDepthRange();

				var fFov:  number  = pCamera.fov;
				var fAspect:  number  = pCamera.aspect;

				var m4fTmp: IMat4 = Mat4.perspective(fFov, fAspect, -pDepthRange.min, -pDepthRange.max,  Mat4.stackCeil.set() );

				this.optimizedCameraFrustum.extractFromMatrix(m4fTmp, pCamera.worldMatrix);
/*************************************************************/


				if(!this.isShadowCaster){
					var pResult: IObjectArray = this._defineLightingInfluence(pCamera);
					return (pResult.length == 0) ? false : true;
				}
				else{
					var pResult: IObjectArray = this._defineShadowInfluence(pCamera);
					return (pResult.length == 0) ? false : true;
				}
			}
		};

		protected _defineLightingInfluence(pCamera: ICamera): IObjectArray{
			var pShadowCaster: IShadowCaster = this._pShadowCaster;
			var pCameraFrustum: IFrustum = this.optimizedCameraFrustum;

			var pResult: IObjectArray = pShadowCaster.affectedObjects;
			pResult.clear();

//fast test on frustum intersection
			if(!pCameraFrustum.testFrustum(pShadowCaster.frustum)){
//frustums don't intersecting
				return pResult;
			}

			var pRawResult: IObjectArray = pShadowCaster.display( 0 );

			for(var i: number  = 0; i<pRawResult.length; i++){
				var pObject: ISceneObject = pRawResult.value(i);

				if(pCameraFrustum.testRect(pObject.worldBounds)){
					pResult.push(pObject);
				}
			}

			return pResult;
		};

		protected _defineShadowInfluence(pCamera: ICamera): IObjectArray{
			var pShadowCaster: IShadowCaster = this._pShadowCaster;
			var pCameraFrustum: IFrustum = this.optimizedCameraFrustum;

			var pResult: IObjectArray = pShadowCaster.affectedObjects;
			pResult.clear();

//fast test on frustum intersection
			if(!pCameraFrustum.testFrustum(pShadowCaster.frustum)){
//frustums don't intersecting
				pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
				return pResult;
			}

			var pRawResult: IObjectArray = pShadowCaster.display( 0 );

			var pTestArray: IPlane3d[] = ProjectLight._pFrustumPlanes;
			var nAdditionalTestLength:  number  = 0;

			if(pShadowCaster.projectionMatrix.isOrthogonalProjection()){
				nAdditionalTestLength = util.calculatePlanesForOrthogonalLighting(
											pShadowCaster.frustum, pShadowCaster.worldPosition,
											pCameraFrustum, pTestArray);
			}
			else{
				nAdditionalTestLength = util.calculatePlanesForFrustumLighting(
											pShadowCaster.frustum, pShadowCaster.worldPosition,
											pCameraFrustum, pTestArray);
			}

			var v3fMidPoint: IVec3 =  Vec3.stackCeil.set() ;
			var v3fShadowDir: IVec3 =  Vec3.stackCeil.set() ;
			var v3fCameraDir: IVec3 =  Vec3.stackCeil.set() ;

			for(var i: number  = 0; i<pRawResult.length; i++){
				var pObject: ISceneObject = pRawResult.value(i);
				var pWorldBounds: IRect3d = pObject.worldBounds;

//have object shadows?
				if(pObject.shadow){
					var j: number  = 0;
					for(j = 0; j<nAdditionalTestLength; j++){
						var pPlane: IPlane3d = pTestArray[j];

						if(geometry.planeClassifyRect3d(pPlane, pWorldBounds)
								== EPlaneClassifications.PLANE_FRONT){
							break;
						}
					}
					if(j == nAdditionalTestLength){
//discard shadow by distance?

						pWorldBounds.midPoint(v3fMidPoint);

						v3fMidPoint.subtract(pShadowCaster.worldPosition, v3fShadowDir);
						v3fMidPoint.subtract(pCamera.worldPosition, v3fCameraDir);

						if(v3fCameraDir.dot(v3fShadowDir) > 0 &&
							pWorldBounds.distanceToPoint(pCamera.worldPosition) >=  70. ){
						}
						else{
							pResult.push(pObject);
						}
					}
				}
				else{
					if(pCameraFrustum.testRect(pWorldBounds)){
						pResult.push(pObject);
					}
				}
			}

			pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);

			return pResult;
		};

//list of frustum planes with which additional testing must be done.
//created just for prevent reallocation
/*new geometry.Plane3d[];*/
		static _pFrustumPlanes: IPlane3d[] = new Array(6);
	}

	for(var i: number  = 0; i<6; i++){
		ProjectLight._pFrustumPlanes[i] = new geometry.Plane3d();
	}

}



















module akra.scene.light {
	export  class  OmniParameters implements IOmniParameters {
		ambient: IColor = new Color;
	    diffuse: IColor = new Color;
	    specular: IColor = new Color;
	    attenuation: IVec3 = new Vec3;
	}


	export class OmniLight extends LightPoint implements IOmniLight {
		protected _pDepthTextureCube: ITexture[] = null;
		protected _pColorTextureCube: ITexture[] = null;
		protected _pLightParameters: IOmniParameters = new OmniParameters;
		protected _pShadowCasterCube: IShadowCaster[] = null;

		/**@inline*/  get params(): IOmniParameters {
			return this._pLightParameters;
		};

		constructor (pScene: IScene3d) {
			super(pScene, ELightTypes.OMNI);

			this._pShadowCasterCube = new Array(6);

			for(var i:  number  = 0; i<6; i++){
				this._pShadowCasterCube[i] = pScene._createShadowCaster(this, i);
			}
		}

		create(isShadowCaster: bool = true, iMaxShadowResolution:  number  = 256): bool {
			var isOk: bool = super.create(isShadowCaster, iMaxShadowResolution);

			var pCasterCube: IShadowCaster[] = this._pShadowCasterCube;
			var pCaster: IShadowCaster;

			for (var i = 0; i < 6; i++) {
	            pCaster = pCasterCube[i];
				pCaster.setInheritance(ENodeInheritance.ALL);
				pCaster.attachToParent(this);
	            pCaster.setProjParams(math.PI / 2, 1, 0.01, 1000);
	            pCaster.setParameter(ECameraParameters.CONST_ASPECT, true);
	        }

//POSITIVE_X
/*first column, not row!*/
	        pCasterCube[0].localMatrix =  Mat4.stackCeil.set([ 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 1 ])
               ;

//NEGATIVE_X
/*first column, not row!*/
	        pCasterCube[1].localMatrix =  Mat4.stackCeil.set([ 0, 0, -1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 ])
               ;

//POSITIVE_Y
/*first column, not row!*/
	        pCasterCube[2].localMatrix =  Mat4.stackCeil.set([ 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1 ])
               ;

//NEGATIVE_Y
/*first column, not row!*/
	        pCasterCube[3].localMatrix =  Mat4.stackCeil.set([ 1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1 ])
               ;

//POSITIVE_Z
/*first column, not row!*/
	        pCasterCube[4].localMatrix =  Mat4.stackCeil.set([ -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1 ])
               ;

//NEGATIVE_Z
/*first column, not row!*/
	        pCasterCube[5].localMatrix =  Mat4.stackCeil.set([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ])
               ;

	        if (this.isShadowCaster) {
				this.initializeTextures();
			}

			return isOk;
		};

		/**@inline*/  getDepthTextureCube(): ITexture[] {
			return this._pDepthTextureCube;
		};

		/**@inline*/  getRenderTarget(iFace:  number ): IRenderTarget {
// return this._pDepthTextureCube[iFace].getBuffer().getRenderTarget();
			return this._pColorTextureCube[iFace].getBuffer().getRenderTarget();
		};

		/**@inline*/  getShadowCaster(): IShadowCaster[] {
			return this._pShadowCasterCube;
		};

		/**@inline*/  get isShadowCaster(): bool {
			return this._isShadowCaster;
		};

/**
		 * overridden setter isShadow caster,
		 * if depth textures don't created then create depth textures
		 */

		set isShadowCaster(bValue: bool){
			this._isShadowCaster = bValue;
			if(bValue && isNull(this._pDepthTextureCube)){
				this.initializeTextures();
			}
		};

		/**@inline*/  get lightingDistance():  number {
			return this._pShadowCasterCube[0].farPlane;
		};

		set lightingDistance(fDistance){
			var pCube: IShadowCaster[] = this._pShadowCasterCube;
			for(var i: number  = 0; i < 6; i++){
				pCube[i].farPlane = fDistance;
			}
		};

		protected initializeTextures(): void {
			var pEngine: IEngine = this.scene.getManager().getEngine();
			var pResMgr: IResourcePoolManager = pEngine.getResourceManager();
			var iSize:  number  = this._iMaxShadowResolution;

			this._pDepthTextureCube = new Array(6);
			this._pColorTextureCube = new Array(6);

			for (var i:  number  = 0; i < 6; ++ i) {

// if (this._pDepthTextureCube[i]) {
// 	this._pDepthTextureCube[i].destroyResource();
// }

				var pDepthTexture: ITexture = this._pDepthTextureCube[i] =
					pResMgr.createTexture("depth_texture_" + i + "_" + this.getGuid());
				pDepthTexture.create(iSize, iSize, 1, null, 0,
									 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.DEPTH32);

				pDepthTexture.setWrapMode(ETextureParameters.WRAP_S, ETextureWrapModes.CLAMP_TO_EDGE);
				pDepthTexture.setWrapMode(ETextureParameters.WRAP_T, ETextureWrapModes.CLAMP_TO_EDGE);
				pDepthTexture.setFilter(ETextureParameters.MAG_FILTER, ETextureFilters.LINEAR);
				pDepthTexture.setFilter(ETextureParameters.MIN_FILTER, ETextureFilters.LINEAR);

				var pColorTexture: ITexture = this._pColorTextureCube[i] =
					pResMgr.createTexture("light_color_texture_" + i + "_" + this.getGuid());
				pColorTexture.create(iSize, iSize, 1, null, ETextureFlags.RENDERTARGET,
						  			 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.R8G8B8A8);

//TODO: Multiple render target
				this.getRenderTarget(i).attachDepthTexture(pDepthTexture);
				this.getRenderTarget(i).setAutoUpdated(false);
				this.getRenderTarget(i).addViewport(new render.ShadowViewport(this._pShadowCasterCube[i]));
			}
		};

		_calculateShadows(): void {
			if (this.enabled && this.isShadowCaster) {
				for(var i:  number  = 0; i<6; i++){
					this.getRenderTarget(i).update();
// this.getRenderTarget(i).getRenderer()._setViewport(this.getRenderTarget(i).getViewport(0));
// console.log("GL_DEPTH_RANLE", (<webgl.WebGLRenderer>this.getRenderTarget(i).getRenderer()).getWebGLContext().getParameter(0x0B70));
				}
			}
		};

		_prepareForLighting(pCamera: ICamera): bool{
			if(!this.enabled){
				return false;
			}
			else{

/*************************************************************/

//optimize camera frustum
				var pDepthRange: IDepthRange = pCamera.getDepthRange();

				var fFov:  number  = pCamera.fov;
				var fAspect:  number  = pCamera.aspect;

				var m4fTmp: IMat4 = Mat4.perspective(fFov, fAspect, -pDepthRange.min, -pDepthRange.max,  Mat4.stackCeil.set() );

				this.optimizedCameraFrustum.extractFromMatrix(m4fTmp, pCamera.worldMatrix);
/*************************************************************/


				var haveInfluence: bool = false;
				if(!this.isShadowCaster){
					for(var i=0; i<6; i++){
						var pResult: IObjectArray = this._defineLightingInfluence(pCamera, i);
						if(pResult.length != 0){
							haveInfluence = true;
						}
					}
					return haveInfluence;
				}
				else{
					for(var i=0; i<6; i++){
						var pResult: IObjectArray = this._defineShadowInfluence(pCamera, i);
						if(pResult.length != 0){
							haveInfluence = true;
						}
					}
					return haveInfluence;
				}
			}
		};

		protected _defineLightingInfluence(pCamera: ICamera, iFace:  number ): IObjectArray{
			var pShadowCaster: IShadowCaster = this._pShadowCasterCube[iFace];
			var pCameraFrustum: IFrustum = this.optimizedCameraFrustum;
// var pCameraFrustum: IFrustum = pCamera.frustum;

			var pResult: IObjectArray = pShadowCaster.affectedObjects;
			pResult.clear();

//fast test on frustum intersection
			if(!pCameraFrustum.testFrustum(pShadowCaster.frustum)){
//frustums don't intersecting
				return pResult;
			}

			var pRawResult: IObjectArray = pShadowCaster.display( 0 );

			for(var i: number  = 0; i<pRawResult.length; i++){
				var pObject: ISceneObject = pRawResult.value(i);

				if(pCameraFrustum.testRect(pObject.worldBounds)){
					pResult.push(pObject);
				}
			}

			return pResult;
		};

		protected _defineShadowInfluence(pCamera: ICamera, iFace:  number ): IObjectArray{
			var pShadowCaster: IShadowCaster = this._pShadowCasterCube[iFace];
			var pCameraFrustum: IFrustum = this.optimizedCameraFrustum;

			var pResult: IObjectArray = pShadowCaster.affectedObjects;
			pResult.clear();

//fast test on frustum intersection
			if(!pCameraFrustum.testFrustum(pShadowCaster.frustum)){
//frustums don't intersecting
				pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
				return pResult;
			}

			var pRawResult: IObjectArray = pShadowCaster.display( 0 );

			var pTestArray: IPlane3d[] = OmniLight._pFrustumPlanes;
			var pFrustumPlanesKeys: string[] = geometry.Frustum.frustumPlanesKeys;

			util.calculatePlanesForFrustumLighting(
											pShadowCaster.frustum, pShadowCaster.worldPosition,
											pCameraFrustum, pTestArray);

			var v3fMidPoint: IVec3 =  Vec3.stackCeil.set() ;
			var v3fShadowDir: IVec3 =  Vec3.stackCeil.set() ;
			var v3fCameraDir: IVec3 =  Vec3.stackCeil.set() ;

			for(var i: number  = 0; i<pRawResult.length; i++){
				var pObject: ISceneObject = pRawResult.value(i);
				var pWorldBounds: IRect3d = pObject.worldBounds;

//have object shadows?
				if(pObject.shadow){
					var j: number  = 0;
					for(j = 0; j<6; j++){
						var pPlane: IPlane3d = pTestArray[j];

						if(geometry.planeClassifyRect3d(pPlane, pWorldBounds)
								== EPlaneClassifications.PLANE_FRONT){
							break;
						}
					}

					if(j == 6){
//discard shadow by distance?

						pWorldBounds.midPoint(v3fMidPoint);

						v3fMidPoint.subtract(pShadowCaster.worldPosition, v3fShadowDir);
						v3fMidPoint.subtract(pCamera.worldPosition, v3fCameraDir);

						if(v3fCameraDir.dot(v3fShadowDir) > 0 &&
							pWorldBounds.distanceToPoint(pCamera.worldPosition) >=  70. ){
						}
						else{
							pResult.push(pObject);
						}
					}
				}
				else{
					if(pCameraFrustum.testRect(pWorldBounds)){
						pResult.push(pObject);
					}
				}

			}

			pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);

			return pResult;
		};

//list of frustum planes with which additional testing must be done.
//created just for prevent reallocation
/*new geometry.Plane3d[];*/
		static _pFrustumPlanes: IPlane3d[] = new Array(6);
	}

	for(var i: number  = 0; i<6; i++){
		OmniLight._pFrustumPlanes[i] = new geometry.Plane3d();
	}
}










module akra {

	;
	;
	;
	;

	export interface ISunParameters extends ILightParameters {
		eyePosition: IVec3;
		sunDir: IVec3;
		groundC0: IVec3;
		groundC1: IVec3;
		hg: IVec3;
	}

	export interface ISunLight extends ILightPoint {
		params: ISunParameters;
		skyDome: ISceneModel;

		updateSunDirection(v3fSunDir: IVec3): void;

		getDepthTexture(): ITexture;
		getShadowCaster(): IShadowCaster;
	}
}














module akra.scene.light {

	export  class  SunParameters implements ISunParameters {
		eyePosition: IVec3 = new Vec3;
	    sunDir: IVec3 = new Vec3;
	    groundC0: IVec3 = new Vec3;
	    groundC1: IVec3 = new Vec3;
	    hg: IVec3 = new Vec3;
	}

	export class SunLight extends LightPoint implements ISunLight {
		protected _pLightParameters: ISunParameters = new SunParameters;
		protected _pSkyDome: ISceneModel = null;


		protected _pColorTexture: ITexture = null;
		protected _pDepthTexture: ITexture = null;
		protected _pShadowCaster: IShadowCaster;

		/**@inline*/  get params(): ISunParameters {
			return this._pLightParameters;
		}

		/**@inline*/  get skyDome(): ISceneModel {
			return this._pSkyDome;
		}

		/**@inline*/  set skyDome(pSkyDome: ISceneModel) {
			this._pSkyDome = pSkyDome;
		}

		/**@inline*/  get lightingDistance():  number {
			return this._pShadowCaster.farPlane;
		};

		/**@inline*/  set lightingDistance(fDistance){
			this._pShadowCaster.farPlane = fDistance;
		};

		constructor (pScene: IScene3d) {
			super(pScene, ELightTypes.SUN);
			this._pShadowCaster = pScene._createShadowCaster(this);
		}

		create(isShadowCaster: bool = true, iMaxShadowResolution:  number  = 256): bool{
			var isOk: bool = super.create(isShadowCaster, iMaxShadowResolution);

			var pCaster: IShadowCaster = this._pShadowCaster;

			pCaster.setParameter(ECameraParameters.CONST_ASPECT, true);
			pCaster.setOrthoParams(1000., 1000., 0., 1000.);
			pCaster.setInheritance(ENodeInheritance.ALL);
			pCaster.attachToParent(this);

			if (this.isShadowCaster) {
				this.initializeTextures();
			}

			return isOk;
		};

		/**@inline*/  getDepthTexture(): ITexture {
			return this._pDepthTexture;
		}

		/**@inline*/  getRenderTarget(): IRenderTarget {
// return this._pDepthTexture.getBuffer().getRenderTarget();
			return this._pColorTexture.getBuffer().getRenderTarget();
		}

		/**@inline*/  getShadowCaster(): IShadowCaster {
			return this._pShadowCaster;
		}

		/**@inline*/  get isShadowCaster(): bool {
			return this._isShadowCaster;
		}

		set isShadowCaster(bValue: bool){
			this._isShadowCaster = bValue;
			if(bValue && isNull(this._pDepthTexture)){
				this.initializeTextures();
			}
		}

		_calculateShadows(): void {
			if (this.enabled && this.isShadowCaster) {

// LOG(this._pShadowCaster.affectedObjects);
				this.getRenderTarget().update();
			}
		}

// create(caster: bool): bool{
// 	return super.create(false, 0);
// };

		_prepareForLighting(pCamera: ICamera): bool{
// if(!this.enabled){
// 	return false;
// }

// return true;
			if(!this.enabled){
				return false;
			}
			else{
/*************************************************************/

//optimize camera frustum
				var pDepthRange: IDepthRange = pCamera.getDepthRange();

				var fFov:  number  = pCamera.fov;
				var fAspect:  number  = pCamera.aspect;

				var m4fTmp: IMat4 = Mat4.perspective(fFov, fAspect, -pDepthRange.min, -pDepthRange.max,  Mat4.stackCeil.set() );

				this.optimizedCameraFrustum.extractFromMatrix(m4fTmp, pCamera.worldMatrix);
/*************************************************************/


				if(!this.isShadowCaster){
					var pResult: IObjectArray = this._defineLightingInfluence(pCamera);
					return (pResult.length == 0) ? false : true;
				}
				else{
					var pResult: IObjectArray = this._defineShadowInfluence(pCamera);
// this._pShadowCaster.optimizedProjection.set(this._pShadowCaster.projectionMatrix);
					return (pResult.length == 0) ? false : true;
				}
			}
		}

		protected _defineLightingInfluence(pCamera: ICamera): IObjectArray{
			var pShadowCaster: IShadowCaster = this._pShadowCaster;
			var pCameraFrustum: IFrustum = this.optimizedCameraFrustum;

			var pResult: IObjectArray = pShadowCaster.affectedObjects;
			pResult.clear();

// fast test on frustum intersection
			if(!pCameraFrustum.testFrustum(pShadowCaster.frustum)){
//frustums don't intersecting
				return pResult;
			}

			var pRawResult: IObjectArray = pShadowCaster.display( 0 );

			for(var i: number  = 0; i<pRawResult.length; i++){
				var pObject: ISceneObject = pRawResult.value(i);

				if(pCameraFrustum.testRect(pObject.worldBounds)){
					pResult.push(pObject);
				}
			}

			return pResult;
		};

		protected _defineShadowInfluence(pCamera: ICamera): IObjectArray{
			var pShadowCaster: IShadowCaster = this._pShadowCaster;
			var pCameraFrustum: IFrustum = this.optimizedCameraFrustum;

			var pResult: IObjectArray = pShadowCaster.affectedObjects;
			pResult.clear();

// fast test on frustum intersection
			if(!pCameraFrustum.testFrustum(pShadowCaster.frustum)){
//frustums don't intersecting
				pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);
// pShadowCaster.optimizedProjection.set(pShadowCaster.projectionMatrix);
				return pResult;
			}

			var pRawResult: IObjectArray = pShadowCaster.display( 0 );

			var pTestArray: IPlane3d[] = SunLight._pFrustumPlanes;
			var nAdditionalTestLength:  number  = 0;

			nAdditionalTestLength = util.calculatePlanesForOrthogonalLighting(
											pShadowCaster.frustum, pShadowCaster.worldPosition,
											pCameraFrustum, pTestArray);

			var v3fMidPoint: IVec3 =  Vec3.stackCeil.set() ;
			var v3fShadowDir: IVec3 =  Vec3.stackCeil.set() ;
			var v3fCameraDir: IVec3 =  Vec3.stackCeil.set() ;

			for(var i: number  = 0; i<pRawResult.length; i++){
				var pObject: ISceneObject = pRawResult.value(i);
				var pWorldBounds: IRect3d = pObject.worldBounds;

//have object shadows?
				if(pObject.shadow){
					var j: number  = 0;
					for(j = 0; j<nAdditionalTestLength; j++){
						var pPlane: IPlane3d = pTestArray[j];

						if(geometry.planeClassifyRect3d(pPlane, pWorldBounds)
								== EPlaneClassifications.PLANE_FRONT){
							break;
						}
					}
					if(j == nAdditionalTestLength){

//discard shadow by distance?

						pWorldBounds.midPoint(v3fMidPoint);

						v3fMidPoint.subtract(pShadowCaster.worldPosition, v3fShadowDir);
						v3fMidPoint.subtract(pCamera.worldPosition, v3fCameraDir);

						if(v3fCameraDir.dot(v3fShadowDir) > 0 &&
							pWorldBounds.distanceToPoint(pCamera.worldPosition) >=  70. ){
						}
						else{
							pResult.push(pObject);
						}
					}
				}
				else{
					if(pCameraFrustum.testRect(pWorldBounds)){
						pResult.push(pObject);
					}
				}
			}

			pShadowCaster._optimizeProjectionMatrix(pCameraFrustum);

			return pResult;
		};

		updateSunDirection(v3fSunDir: IVec3): void {
// var m4fMat: IMat4 = mat4(this.localMatrix);
// m4fMat.data[__13] = -v3fSunDir.x;
// m4fMat.data[__23] = -v3fSunDir.y;
// m4fMat.data[__33] = -v3fSunDir.z;
//this.localMatrix = Mat4.fromXYZ(vec3(v3fSunDir.x, v3fSunDir.y, v3fSunDir.z).scale(-1., vec3()), mat4()).setTranslation(vec3(0., 0., 1.));

// var pViewMat = mat4();

			var pViewMat = Mat4.lookAt( Vec3.stackCeil.set(0.) ,  Vec3.stackCeil.set(v3fSunDir) .scale(-1.),  Vec3.stackCeil.set(0., 0., 1.) ,  Mat4.stackCeil.set() );

			this.localMatrix = pViewMat.inverse();

			this.localMatrix.setTranslation(v3fSunDir.scale(500.,  Vec3.stackCeil.set() ));

//this.localMatrix.setTranslation();
		}

		protected initializeTextures(): void {
			var pEngine: IEngine = this.scene.getManager().getEngine();
			var pResMgr: IResourcePoolManager = pEngine.getResourceManager();
			var iSize:  number  = this._iMaxShadowResolution;

// if (!isNull(this._pDepthTexture)){
// 	this._pDepthTexture.destroyResource();
// }

			var pDepthTexture: ITexture = this._pDepthTexture =
				pResMgr.createTexture("depth_texture_" + this.getGuid());
			pDepthTexture.create(iSize, iSize, 1, null, 0,
								 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.DEPTH32);

			pDepthTexture.setWrapMode(ETextureParameters.WRAP_S, ETextureWrapModes.CLAMP_TO_EDGE);
			pDepthTexture.setWrapMode(ETextureParameters.WRAP_T, ETextureWrapModes.CLAMP_TO_EDGE);
			pDepthTexture.setFilter(ETextureParameters.MAG_FILTER, ETextureFilters.LINEAR);
			pDepthTexture.setFilter(ETextureParameters.MIN_FILTER, ETextureFilters.LINEAR);

// if (this._pColorTexture) {
// 	this._pColorTexture.destroy();
// }

			var pColorTexture: ITexture = pResMgr.createTexture("light_color_texture_" + this.getGuid());
			pColorTexture.create(iSize, iSize, 1, null, ETextureFlags.RENDERTARGET,
						  0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.R8G8B8A8);

			this._pColorTexture = pColorTexture;

// this._pColorTexture = pColorTexture;
//TODO: Multiple render target
			this.getRenderTarget().attachDepthTexture(pDepthTexture);
			this.getRenderTarget().setAutoUpdated(false);
			this.getRenderTarget().addViewport(new render.ShadowViewport(this._pShadowCaster));
		}

//list of frustum planes with which additional testing must be done.
//created just for prevent reallocation
/*new geometry.Plane3d[];*/
		static _pFrustumPlanes: IPlane3d[] = new Array(6);
		static _pTmpPlanePoints: IVec3[] = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];
		static _pTmpIndexList:  number [] = [0, 0, 0, 0];
		static _pTmpDirLengthList:  number [] = [0.0, 0.0, 0.0, 0.0];
	}

	for(var i: number  = 0; i<6; i++){
		SunLight._pFrustumPlanes[i] = new geometry.Plane3d();
	}
}







module akra.scene {

	export class Scene3d implements IScene3d {
		protected _sName: string;
		protected _pRootNode: ISceneNode;
		protected _pSceneManager: ISceneManager;
// protected _pNodeList: ISceneNode[];
// protected _pObjectList: ISceneObject[];

		protected _pDisplayLists: IDisplayList[] = [];
		protected _pDisplayListsCount:  number  = 0;
		protected _isUpdated: bool = false;

		/**@inline*/  get type(): ESceneTypes {
			return ESceneTypes.TYPE_3D;
		}

		/**@inline*/  get totalDL():  number  {
			return this._pDisplayListsCount;
		}

		/**@inline*/  get name(): string {
			return this._sName;
		}

		constructor (pSceneManager: ISceneManager, sName: string = null) {
			this._pSceneManager = pSceneManager;
			this._sName = sName;
			this._pRootNode = this.createNode("root-node");
			this._pRootNode.create();

			var i:  number ;

//TODO: fix this method, do right!!
			var pOctree: IOcTree = new scene.OcTree();
			pOctree.create(new geometry.Rect3d(1024, 1024, 1024), 5, 100);

			var i:  number  = this.addDisplayList(pOctree);
			{ logger.setSourceLocation( "Scene3d.ts" , 69 ); logger.assert(i == 0 , "invalid default list index"); } ;

			var pLightGraph: ILightGraph = new scene.LightGraph();

			i = this.addDisplayList(pLightGraph);
			{ logger.setSourceLocation( "Scene3d.ts" , 74 ); logger.assert(i == 1 , "invalid default list index"); } ;


// this._pNodeList = [];
// this._pObjectList = [];

//TODO передача пользовательских параметров в OcTree

// i = this.addDisplayList(new OcTree);
// debug_assert(i == DL_DEFAULT, "invalid default list index");

//TODO передача пользовательских параметров в LightGraph

// i = this.addDisplayList(new LightGraph);
// debug_assert(i == DL_LIGHTING, "invalid lighting list index");

		}

		/**@inline*/  getManager(): ISceneManager{
			return this._pSceneManager;
		}

		/**@inline*/  isUpdated(): bool {
			return this._isUpdated;
		}

		/**@inline*/  getRootNode(): ISceneNode {
			return this._pRootNode;
		}

		recursivePreUpdate(): void {
			this._isUpdated = false;
			this.preUpdate();
			this._pRootNode.recursivePreUpdate();
		}

		recursiveUpdate(): void {
			this.beforeUpdate();
			this._isUpdated = this._pRootNode.recursiveUpdate();
			this.postUpdate();
		}

		updateCamera(): bool {
			return false;
		}

		updateScene(): bool {
			return false;
		}



		createObject(sName: string = null): ISceneObject {
			var pNode: ISceneNode = new SceneObject(this);

			if (!pNode.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 130 ); logger.error("cannot create scene node.."); } ;
				return null;
			}

			return <ISceneObject>this.setupNode(pNode, sName);
		}



		createNode(sName: string = null): ISceneNode {
			var pNode: ISceneNode = new SceneNode(this);

			if (!pNode.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 143 ); logger.error("cannot create scene node.."); } ;
				return null;
			}

			return this.setupNode(pNode, sName);
		}

		createModel(sName: string = null): ISceneModel {
			var pNode: ISceneModel = new SceneModel(this);

			if (!pNode.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 154 ); logger.error("cannot create model.."); } ;
				return null;
			}

			return <ISceneModel>this.setupNode(pNode, sName);
		}

		createCamera(sName: string = null): ICamera {
			var pCamera: ICamera = new objects.Camera(this);

			if (!pCamera.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 165 ); logger.error("cannot create camera.."); } ;
				return null;
			}

			return <ICamera>this.setupNode(pCamera, sName);
		};

		createLightPoint(eType: ELightTypes = ELightTypes.UNKNOWN, isShadowCaster: bool = true,
						 iMaxShadowResolution:  number  = 256, sName: string = null): ILightPoint {

			var pLight: ILightPoint;

			switch(eType){
				case ELightTypes.PROJECT:
					pLight = <ILightPoint>(new light.ProjectLight(this));
					break;
				case ELightTypes.OMNI:
					pLight = <ILightPoint>(new light.OmniLight(this));
					break;
				case ELightTypes.SUN:
					pLight = <ILightPoint>(new light.SunLight(this));
					break;
				default:
					return null;
			}

			if(!pLight.create(isShadowCaster, iMaxShadowResolution)){
				{ logger.setSourceLocation( "Scene3d.ts" , 192 ); logger.error("cannot create light"); } ;
				return null;
			}

			return <ILightPoint>this.setupNode(pLight, sName);
		};


		createSprite(sName: string = null): ISprite {
			var pSprite: ISprite = new Sprite(this);

			if (!pSprite.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 204 ); logger.error("cannot create sprite.."); } ;
				return null;
			}

			return <ISprite>this.setupNode(pSprite, sName);
		};

		createJoint(sName: string = null): IJoint {
			return <IJoint>this.setupNode(new Joint(this), sName);
		}

		_createModelEntry(pModel: IModel): IModelEntry {
			return <IModelEntry>this.setupNode(new objects.ModelEntry(this, pModel));
		}

		createText3d(sName: string = null): IText3d {
			return null;
		};

		createTerrain(sName?: string): ITerrain {
			var pTerrain: ITerrain = new terrain.Terrain(this);

			if (!pTerrain.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 227 ); logger.error("cannot create terrain.."); } ;
				return null;
			}

			return <ITerrain>this.setupNode(pTerrain, sName);
		}

		createTerrainROAM(sName?: string): ITerrainROAM {
			var pTerrainROAM: ITerrainROAM = new terrain.TerrainROAM(this);

			if (!pTerrainROAM.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 238 ); logger.error("cannot create terrain.."); } ;
				return null;
			}

			return <ITerrainROAM>this.setupNode(pTerrainROAM, sName);
		}

		createTerrainSection(sName?: string): ITerrainSection {
			var pNode: ISceneNode = new terrain.TerrainSection(this);

			if (!pNode.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 249 ); logger.error("cannot create terrain section.."); } ;
				return null;
			}

			return <ITerrainSection>this.setupNode(pNode, sName);
		};

		createTerrainSectionROAM(sName?: string): ITerrainSectionROAM {
			var pNode: ISceneNode = new terrain.TerrainSectionROAM(this);

			if (!pNode.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 260 ); logger.error("cannot create terrain section roam.."); } ;
				return null;
			}

			return <ITerrainSectionROAM>this.setupNode(pNode, sName);
		};

		_createShadowCaster(pLightPoint: ILightPoint, iFace:  number  = ECubeFace.POSITIVE_X, sName: string = null){
			var pShadowCaster: IShadowCaster = new light.ShadowCaster(pLightPoint, iFace);

			if (!pShadowCaster.create()) {
				{ logger.setSourceLocation( "Scene3d.ts" , 271 ); logger.error("cannot create shadow caster.."); } ;
				return null;
			}

			return <IShadowCaster>this.setupNode(pShadowCaster, sName);
		};


// inline getAllNodes(): ISceneNode[] {
// 	return this._pNodeList;
// }

// inline getAllObjects(): ISceneObject[] {
// 	return this._pObjectList;
// }

		/**@inline*/  getDisplayList(i:  number ): IDisplayList {
			{ logger.setSourceLocation( "Scene3d.ts" , 288 ); logger.assert(isDefAndNotNull(this._pDisplayLists[i]), "display list not defined"); } ;
			return this._pDisplayLists[i];
		}

		getDisplayListByName(csName: string):  number  {
			for (var i:  number  = 0; i < this._pDisplayLists.length; ++ i) {
				if (this._pDisplayLists[i].name === csName) {
					return i;
				}
			}

			return -1;
		}


// _findObjects(pCamera: ICamera, csList: string = null): ISceneObject[] {
// 	var pList: IDisplayList = this._pDisplayListMap[csList || DEFAULT_DLIST];

// 	debug_assert(!isNull(pList), "display list not founded.");

// 	return pList.findObjects(pCamera);
// }

		_render(pCamera: ICamera, pViewport: IViewport): void {

		}

		private setupNode(pNode: ISceneNode, sName: string = null): ISceneNode {
			pNode.name = sName;

			this.connect(pNode,  "attached" ,  "nodeAttachment" , EEventTypes.UNICAST);
			this.connect(pNode,  "detached" ,  "nodeDetachment" , EEventTypes.UNICAST);

			return pNode;
		}

		delDisplayList(index:  number ): bool {
			var pLists: IDisplayList[] = this._pDisplayLists;

			for (var i:  number  = 0; i < pLists.length; ++ i) {
				if (i === index && isDefAndNotNull(pLists[i])) {
					pLists[i] = null;
					this._pDisplayListsCount --;

					this.displayListRemoved(pLists[i], i);

					return true;
				}
			};

			return false;
		}

		/**@inline*/  addDisplayList(pList: IDisplayList):  number  {
			{ logger.setSourceLocation( "Scene3d.ts" , 343 ); logger.assert(isDefAndNotNull(this.getDisplayListByName(pList.name)), "DL with name <" + pList.name + "> already exists"); }
                                                       ;


			var pLists: IDisplayList[] = this._pDisplayLists;
			var iIndex:  number  = this._pDisplayLists.length;

			for (var i:  number  = 0; i < pLists.length; ++ i) {
				if (pLists[i] === null) {
					pLists[i] = pList;
					iIndex = i;
					break;
				}
			};

			if (iIndex == this._pDisplayLists.length) {
				this._pDisplayLists.push(pList);
			}

			pList._setup(this);

			this.displayListAdded(pList, iIndex);

			this._pDisplayListsCount ++;

			return iIndex;
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Scene3d._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;

		nodeAttachment (pNode: ISceneNode): void {
// this._pNodeList.push(pNode);

// if (SceneObject.isSceneObject(pNode)) {
// 	this._pObjectList.push(<ISceneObject>pNode);
// }
// console.warn("------>here");
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).nodeAttachment; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pNode) : _broadcast[i].listener (_recivier, pNode) ; } } ;
		}

		nodeDetachment (pNode: ISceneNode): void {

// for (var i: int = 0; i < this._pNodeList.length; ++ i) {
// 	if (pNode == this._pNodeList[i]) {
// 		this._pNodeList.splice(i, 1);
// 		break;
// 	}
// };

// if (SceneObject.isSceneObject(pNode)) {
// 	for (var i: int = 0; i < this._pObjectList.length; ++ i) {
// 		if (<ISceneObject>pNode == this._pObjectList[i]) {
// 			this._pObjectList.splice(i, 1);
// 			break;
// 		}
// 	};
// }


			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).nodeDetachment; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pNode) : _broadcast[i].listener (_recivier, pNode) ; } } ;
		}


		displayListAdded (list, index): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).displayListAdded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, list, index) : _broadcast[i].listener (_recivier, list, index) ; } } } ; ;
		displayListRemoved (list, index): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).displayListRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, list, index) : _broadcast[i].listener (_recivier, list, index) ; } } } ; ;
		beforeUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).beforeUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		postUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).postUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		preUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).preUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;

// BROADCAST(nodeAttachment, CALL(pNode));
// BROADCAST(nodeDetachment, CALL(pNode));
	}
}



module akra.scene {
    export class SceneManager implements ISceneManager {
        private _pEngine: IEngine = null;
        private _pSceneList: IScene[] = [];

        private _fUpdateTimeCount:  number  = 0.;
/*60 updates per frame*/
        private _fMillisecondsPerTick:  number  = 0.01666;


        constructor (pEngine: IEngine) {
            this._pEngine = pEngine;
        }

        getEngine(): IEngine{
            return this._pEngine;
        }

        update(): void {
            var isSceneUpdated: bool = false;
// add the real time elapsed to our
// internal delay counter
            this._fUpdateTimeCount += this._pEngine.elapsedTime;
// is there an update ready to happen?

// LOG(this._fUpdateTimeCount, this._pEngine.elapsedTime);

            var fUpdateTime:  number  = this._fUpdateTimeCount;

            while (this._fUpdateTimeCount > this._fMillisecondsPerTick) {
// update the scene
                this.notifyUpdateScene();


// subtract the time interval
// emulated with each tick
                this._fUpdateTimeCount -= this._fMillisecondsPerTick;
            }

            if (fUpdateTime !== this._fUpdateTimeCount) {
                this.notifyPreUpdateScene();
            }
        }

// inline preUpdate(): void {
//     this.notifyPreUpdateScene();
// }

        notifyUpdateScene(): void {
// update the scene attached to the root node
            for (var i = 0; i < this._pSceneList.length; ++ i) {
                var pScene: IScene = this._pSceneList[i];

                if (pScene.type != ESceneTypes.TYPE_3D) {
                    continue;
                }

                (<IScene3d>pScene).recursiveUpdate();
            }
        }

        notifyPreUpdateScene(): void {
            for (var i = 0; i < this._pSceneList.length; ++ i) {
                var pScene: IScene = this._pSceneList[i];

                if (pScene.type != ESceneTypes.TYPE_3D) {
                    continue;
                }

                (<IScene3d>pScene).recursivePreUpdate();
            }
        }

        createScene3D(sName: string = null): IScene3d {
            var pScene: IScene3d = new Scene3d(this, sName);
            this._pSceneList.push(pScene);

            return pScene;
        }

        createScene2D(sName: string = null): IScene2d {
            return null;
        }

        createUI(): IUI {




                return null;

        }

        getScene3D(): IScene3d;
        getScene3D(sName: string): IScene3d;
        getScene3D(iScene:  number ): IScene3d;
        getScene3D(scene?: any): IScene3d {
        	if (isNumber(arguments[0]) || !isDef(arguments[0])) {
        		var iScene:  number  = < number >arguments[0] || 0;
	            var pScene: IScene;

	            if (iScene === 0 && this._pSceneList.length === 0) {
	                this.createScene3D();
	                { logger.setSourceLocation( "scene/SceneManager.ts" , 114 ); logger.log("Default scene automatically created."); } ;
	            }

	            pScene = this._pSceneList[iScene];

	            if (pScene && pScene.type === ESceneTypes.TYPE_3D) {
	                return <IScene3d>pScene;
	            }

	            return null;
            }
            else if (isString(arguments[0])) {
            	for (var i:  number  = 0; i < this._pSceneList.length; ++ i) {
            		if (this._pSceneList[i].name === <string>arguments[0]) {
            			return <IScene3d>this._pSceneList[i];
            		}
            	}
            }

            return null;

        }

        getScene2D(): IScene2d;
        getScene2D(sName: string): IScene2d;
        getScene2D(iScene:  number ): IScene2d;
        getScene2D(scene?:  number ): IScene2d {
        	if (isNumber(arguments[0]) || !isDef(arguments[0])) {
        		var iScene:  number  = arguments[0] || 0;
	            var pScene: IScene = this._pSceneList[iScene];

	            if (pScene && pScene.type === ESceneTypes.TYPE_2D) {
	                return <IScene2d>pScene;
	            }
        	}

            return null;
        }

        getScene(IScene?:  number , eType?: ESceneTypes): IScene {
            return this._pSceneList[IScene] || null;
        }


        initialize(): bool {
//this.initText2Dlayer();
            return true;
        }

        destroy(): void {

        }
    }
}





/** @inline */
/*
        draw2DText(iX: int = 0, iY: int = 0, sText: string = "", pFont: IFont2d = new util.Font2d()): IString2d {
            return (new a.String2D(iX, iY, pFont, sStr, this.pTextLayer));
        }

        

        private initText2Dlayer(): void {
            var pCanvas: HTMLCanvasElement = this.pEngine.canvas;
            var x: int = findPosX(pCanvas);
            var y: int = findPosY(pCanvas);

            var pDiv: HTMLDivElement = <HTMLDivElement>document.createElement('div');
            var pStyle: CSSStyleDeclaration = pDiv.style;
            var pScreen: IScreenInfo = info.screen;

            var iBorder: int = 0;

            pDiv.setAttribute("id", "akra-canvas-overlay");

            pStyle.width = String(pScreen.width) + "px";
            pStyle.height = String(pScreen.height) + "px";
            
            if (pCanvas.style.border != "none") {
                iBorder = parseInt(pCanvas.style.border);
            }

            pStyle.position = 'absolute';
            pStyle.left = String(x) + 'px';
            pStyle.top = String(y) + 'px';

            pStyle.overflow = 'hidden';
            pStyle.whiteSpace = 'nowrap';

            if (pCanvas.style.zIndex) {
                pStyle.zIndex = pCanvas.style.zIndex + 1;
            }
            else {
                pStyle.zIndex = 2;
            }

            document.body.appendChild(pDiv);

            this.pTextLayer = pDiv;
        }
*/















// #ifndef IAFXEFFECT_TS
// #define IAFXEFFECT_TS

// #include "IResourcePoolItem.ts"

// module akra {
// 	export interface IAFXEffect extends IResourcePoolItem {

// 	}
// }

// #endif








// #ifndef IAFXEFFECT_TS
// #define IAFXEFFECT_TS

// #include "IResourcePoolItem.ts"

// module akra {
// 	export interface IAFXEffect extends IResourcePoolItem {

// 	}
// }

// #endif




























module akra.fx {
//Errors























































































    akra.logger.registerCode( 2201 ,
    						 "You trying to redefine system type: {typeName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2202 ,
    	 					 "You trying to redefine type: {typeName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2203 ,
    						 "You try to use unssuported type declaration. We implement it soon. In line: {line}.");
    akra.logger.registerCode( 2204 ,
    						 "You try to use unssuported expr: {exprName}. We implement it soon. In line: {line}.");
    akra.logger.registerCode( 2205 ,
    						 "Unknown variable name: {varName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2206 ,
    						 "Invalid arithmetic operation!. There no operator '{operator}'" +
    						 " for left-type '{leftTypeName}' " +
    						 " and right-type '{rightTypeName}'. In line: {line}.");
    akra.logger.registerCode( 2207 ,
    						 "Invalid arithmetic-assignment operation!. " +
    						 " There no operator {operator} for left-type '{leftTypeName}' " +
    						 " and right-type '{rightTypeName}'. In line: {line}.");
    akra.logger.registerCode( 2208 ,
    						 "Invalid assignment operation!. It`s no possible to do assignment " +
    						 " between left-type '{leftTypeName}' " +
    						 " and right-type '{rightTypeName}'. In line: {line}.");
    akra.logger.registerCode( 2209 ,
    						 "Invalid relational operation!. There no operator {operator} " +
    						 " for left-type '{leftTypeName}' " +
    						 " and right-type '{rightTypeName}'. In line: {line}.");
    akra.logger.registerCode( 2210 ,
    						 "Invalid logical operation!. In operator: {operator}. " +
    						 " Cannot convert type '{typeName}' to 'bool'. In line: {line}.");
    akra.logger.registerCode( 2211 ,
    						 "Invalid conditional expression!. Cannot convert type '{typeName}' to 'bool'. " +
    						 " In line: {line}.");
    akra.logger.registerCode( 2212 ,
    						 "Invalid conditional expression!. Type '{leftTypeName}' and type '{rightTypeName}'" +
    						  " are not equal. In line: {line}.");
	akra.logger.registerCode( 2213 ,
    						 "Invalid type cast!. Bad type casting. Only base types without usages are supported. " +
    						 " WebGL don`t support so casting. In line: {line}.");
	akra.logger.registerCode( 2214 ,
    						 "Invalid type cast!. Bad type for casting '{typeName}'. " +
    						 " WebGL support only base-type casting. In line: {line}.");
	akra.logger.registerCode( 2216 ,
    						 "Invalid unary expression!. Bad type: '{typeName}' " +
    						 " for operator '{opeator}'. In line: {line}.");
	akra.logger.registerCode( 2217 ,
    						 "Invalid postfix-array expression!. " +
    						 " Type of expression is not array: '{typeName}'. In line: {line}.");
	akra.logger.registerCode( 2218 ,
    						 "Invalid postfix-array expression!. Bad type of index: '{typeName}'. " +
    						 "Must be 'int'. In line: {line}.");
	akra.logger.registerCode( 2219 ,
    						 "Invalid postfix-point expression!. Type '{typeName}' has no field '{fieldName}'. " +
    						 "In line: {line}.");
	akra.logger.registerCode( 2220 ,
    						 "Invalid postfix-point expression!. Type '{typeName}' is not pointer. " +
    						 "In line: {line}.");
	akra.logger.registerCode( 2221 ,
    						 "Invalid postfix-arithmetic expression!. Bad type '{typeName}' " +
    						 "for operator {operator}. In line: {line}.");
	akra.logger.registerCode( 2222 ,
    						 "Invalid primary expression!. Bad type '{typeName}'." +
    						 "It`s not pointer. In line: {line}.");
	akra.logger.registerCode( 2223 ,
    						 "Invalid function call expression!. Could not find function-signature " +
    						 "with name {funcName} and so types. In line: {line}.");
	akra.logger.registerCode( 2224 ,
    						 "Invalid constructor call!. There are not so type. In line: {line}.");
	akra.logger.registerCode( 2225 ,
    						 "Invalid constructor call!. Could not find constructor-signature " +
    						 "with name {typeName} and so types. In line: {line}.");
	akra.logger.registerCode( 2226 ,
    						 "Invalid compile expression!. Could not find function-signature " +
    						 "with name {funcName} and so types. In line: {line}.");
	akra.logger.registerCode( 2227 ,
    						 "You try to redefine function. With name {funcName}. In line: {line}.");
	akra.logger.registerCode( 2228 ,
							 "Bad type of while-condition. Must be 'bool' but it is '{typeName}'. " +
							 "In line: {line}.");
	akra.logger.registerCode( 2229 ,
							 "Bad type of do-while-condition. Must be 'bool' but it is '{typeName}'. " +
							 "In line: {line}.");
	akra.logger.registerCode( 2230 ,
							 "Bad type of if-condition. Must be 'bool' but it is '{typeName}'. " +
							 "In line: {line}.");
	akra.logger.registerCode( 2231 ,
							 "Bad for-init expression. WebGL support only VariableDecl as for-init expression, " +
							 "like \"int i = 0;\" or \"float i = 0.0;\". " +
							 "In line: {line}.");
	akra.logger.registerCode( 2232 ,
							 "Bad for-init expression. WebGL support only VariableDecl as for-init expression, " +
							 "like \"int i = 0;\" or \"float i = 0.0;\". " +
							 "In line: {line}.");
	akra.logger.registerCode( 2233 ,
							 "Bad for-cond expression. WebGL does not support empty conditional expression in for-loop. " +
							 "In line: {line}.");
	akra.logger.registerCode( 2238 ,
							 "Bad for-cond expression. WebGL support only relational expression for condition in for-loop. " +
							 "In line: {line}.");
	akra.logger.registerCode( 2239 ,
							 "Bad for-step expression. WebGL does not support empty step expression. " +
							 "In line: {line}.");
	akra.logger.registerCode( 2240 ,
							 "Bad for-step expression. WebGL does not support operator '{operator}' in step expression. " +
							 "In line: {line}.");
	akra.logger.registerCode( 2241 ,
							 "Bad for-step expression. WebGL support only unary and assignment expression in for-step. " +
							 "In line: {line}.");
	akra.logger.registerCode( 2235 ,
    						 "You trying to redefine system variable: {varName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2234 ,
    	 					 "You trying to redefine variable: {varName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2237 ,
    						 "You trying to redefine system function: {funcName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2236 ,
    	 					 "You trying to redefine function: {funcName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2242 ,
    						 "You trying to add field to struct with name '{varName}', but it`s already in it. " +
    						 "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2243 ,
    	 					 "You trying to add field to struct with semantic '{semanticName}'," +
    	 					  "but struct already has this semantic." +
    	 					  "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2244 ,
       					     "Bad variable name '{varName}'. Annotation already has variable with that name." +
    	 					  "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2245 ,
                             "Bad parameter '{varName}' in function '{funcName}'. Need default value." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2246 ,
                             "Bad function call. There are two or more call signatures for function '{funcName}'." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2247 ,
                             "Bad function definition. There are two or more different retturn type signatures for function '{funcName}'." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2248 ,
                             "Bad system function '{funcName}'. Already have this function.");
    akra.logger.registerCode( 2250 ,
                             "Bad type. Could not find type with name '{typeName}'." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2251 ,
                             "Bad type. We don`t support vector and matrix typename." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2252 ,
                             "Bad technique name '{techName}'. Effect already have technique with that name." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2253 ,
                             "Bad 'memof'-operator argument. Literal for its argument is bad idea." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2254 ,
                             "Bad 'memof'-operator argument. No buffer for argument." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2255 ,
                             "Bad function '{funcDef}'. It is recursion.");
    akra.logger.registerCode( 2256 ,
                             "Bad function '{funcDef}'. It use bad-function with recursion.");
    akra.logger.registerCode( 2257 ,
                             "Bad function '{funcDef}'. Can not use in vertex-shader.");
    akra.logger.registerCode( 2258 ,
                             "Bad function '{funcDef}'. Can not use in pixel-shader.");
    akra.logger.registerCode( 2259 ,
                             "Bad function with defenition '{funcDef}'. Can not be used as vertex-shader.");
    akra.logger.registerCode( 2260 ,
                             "Bad function with defenition '{funcDef}'. Can not be used as pixel-shader.");
    akra.logger.registerCode( 2261 ,
                             "Bad return stmt. You try to return something in void-function." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2262 ,
                             "Bad return stmt. You can not call empty return in non-void-function." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2263 ,
                             "Bad return stmt. Types of return expression and return type of function are not equal." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2264 ,
                             "Bad return type for '{funcName}'. Return type for function can not contain or be sampler/pointer." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2265 ,
                             "Bad parameter '{varName}' in function '{funcName}'. Bad usage." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2266 ,
                             "Bad variable with name 'Out'. It is sytem for used like return variable in shaders." +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2267 ,
                             "Variable type is not writable. " +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2268 ,
                             "Variable type is not readable. " +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2269 ,
                             "Bad init expr for variable '{varName}'. " +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2270 ,
                             "Don`t supported construction '[uint]' in sampler_state. " +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2271 ,
                             "Incorrect texture setup for sampler. " +
                             "In line: {line}. In column: {column}");
    akra.logger.registerCode( 2272 ,
                             "Can not calculate padding for type '{typeName}'.");
    akra.logger.registerCode( 2273 ,
                             "Can not extract type '{typeName}'.");
    akra.logger.registerCode( 2274 ,
                             "Bad extract exrpression.");
    akra.logger.registerCode( 2275 ,
                             "Bad imports in technique '{techniqueName}'.");
    akra.logger.registerCode( 2276 ,
                             "You try use 'engine' variable in out of pass." +
                             "In line: {line}. In column: {column}.");
    akra.logger.registerCode( 2277 ,
                             "You try to import not exuisted component '{componentName}'");



    akra.logger.registerCode( 2300 ,
                             "We don`t support array of pinters now. Only pointe to array.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2301 ,
                             "We don`t support using complex shader input like functions params.                             Shader: '{funcName}'");
    akra.logger.registerCode( 2302 ,
                             "We don`t support using complex shader output like functions params.                             Shader: '{funcName}'");
    akra.logger.registerCode( 2303 ,
                             "We don`t support 'provide ... as' operator now.");


    function sourceLocationToString(pLocation: ISourceLocation): string {
        var sLocation:string = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
        return sLocation;
    }

    function syntaxErrorLogRoutine(pLogEntity: ILoggerEntity): void{
        var sPosition:string = sourceLocationToString(pLogEntity.location);
        var sError: string = "Code: " + pLogEntity.code.toString() + ". ";
        var pParseMessage: string[] = pLogEntity.message.split(/\{(\w+)\}/);
        var pInfo:any = pLogEntity.info;

        for(var i = 0; i < pParseMessage.length; i++){
            if(isDef(pInfo[pParseMessage[i]])){
                pParseMessage[i] = <string><any>pInfo[pParseMessage[i]];
            }
        }

        var sMessage = sPosition + sError + pParseMessage.join("");

        console["error"].call(console, sMessage);
    }

    akra.logger.setCodeFamilyRoutine("EffectSyntaxErrors", syntaxErrorLogRoutine, ELogLevel.ERROR);

    export interface IEffectErrorInfo{

    	typeName?: string;
        techName?: string;
   		exprName?: string;
   		varName?: string;
   		operator?: string;
   		leftTypeName?: string;
   		rirgtTypeName?: string;
   		fieldName?: string;
   		funcName?: string;
        funcDef?: string;
   		semanticName?: string;
        techniqueName?: string;
        componentName?: string;

    	line?:  number ;
    	column?:  number ;
    }

}











module akra.fx {



	export enum EScopeType{
		k_Default,
		k_Struct,
		k_Annotation
	}

	export interface IAFXFunctionDeclListMap {
		[functionName: string] : IAFXFunctionDeclInstruction[];
	}

	export interface IScope {
		parent : IScope;
		index:  number ;
		type: EScopeType;
		isStrictMode: bool;

		variableMap : IAFXVariableDeclMap;
		typeMap : IAFXTypeDeclMap;
		functionMap : IAFXFunctionDeclListMap;
	}

	export interface IScopeMap {
		[scopeIndex:  number ] : IScope;
	}

	export class ProgramScope {

		private _pScopeMap: IScopeMap;
		private _iCurrentScope:  number ;
		private _nScope:  number ;

		constructor() {
			this._pScopeMap = <IScopeMap>{};
			this._iCurrentScope = null;
			this._nScope = 0;
		}

		isStrictMode(iScope?:  number  = this._iCurrentScope): bool {
			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				if(pScope.isStrictMode){
					return true;
				}

				pScope = pScope.parent;
			}

			return false;
		}

		setStrictModeOn(iScope?:  number  = this._iCurrentScope): void {
			this._pScopeMap[iScope].isStrictMode = true;
		}

		newScope(eType: EScopeType): void {
			var isFirstScope: bool = false;
			var pParentScope: IScope;

			if(isNull(this._iCurrentScope)){
				pParentScope = null;
			}
			else {
				pParentScope = this._pScopeMap[this._iCurrentScope];
			}

			this._iCurrentScope = this._nScope++;

			var pNewScope: IScope = <IScope> {
										parent: pParentScope,
										index: this._iCurrentScope,
										type: eType,
										isStrictMode: false,
										variableMap: null,
										typeMap: null,
										functionMap: null
									};

			this._pScopeMap[this._iCurrentScope] = pNewScope;
		}

		resumeScope(): void {
			if(this._nScope === 0) {
				return;
			}

			this._iCurrentScope = this._nScope - 1;
		}

		setScope(iScope:  number ): void {
			this._iCurrentScope = iScope;
		}

		getScope():  number  {
			return this._iCurrentScope;
		}

		endScope(): void {
			if(isNull(this._iCurrentScope)){
				return;
			}

			var pOldScope: IScope = this._pScopeMap[this._iCurrentScope];
			var pNewScope: IScope = pOldScope.parent;

			if(isNull(pNewScope)){
				this._iCurrentScope = null;
			}
			else {
				this._iCurrentScope = pNewScope.index;
			}
		}

		/**@inline*/  getScopeType(): EScopeType {
			return this._pScopeMap[this._iCurrentScope].type;
		}

		getVariable(sVariableName: string, iScope?:  number  = this._iCurrentScope): IAFXVariableDeclInstruction {
			if(isNull(iScope)){
				return null;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pVariableMap: IAFXVariableDeclMap = pScope.variableMap;

				if(!isNull(pVariableMap)){
					var pVariable: IAFXVariableDeclInstruction = pVariableMap[sVariableName];

					if(isDef(pVariable)){
						return pVariable;
					}
				}

				pScope = pScope.parent;
			}

			return null;
		}

		getType(sTypeName: string, iScope?:  number  = this._iCurrentScope): IAFXTypeInstruction {
			var pTypeDecl: IAFXTypeDeclInstruction = this.getTypeDecl(sTypeName, iScope);

			if(!isNull(pTypeDecl)){
				return pTypeDecl.getType();
			}
			else {
				return null;
			}
		}

		getTypeDecl(sTypeName: string, iScope?:  number  = this._iCurrentScope): IAFXTypeDeclInstruction {
			if(isNull(iScope)){
				return null;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pTypeMap: IAFXTypeDeclMap = pScope.typeMap;

				if(!isNull(pTypeMap)){
					var pType: IAFXTypeDeclInstruction = pTypeMap[sTypeName];

					if(isDef(pType)){
						return pType;
					}
				}

				pScope = pScope.parent;
			}

			return null;
		}

/**
		 * get function by name and list of types
		 * return null - if threre are not function; undefined - if there more then one function; function - if all ok
		 */

		getFunction(sFuncName: string, pArgumentTypes: IAFXTypedInstruction[], iScope?:  number  =  0 ): IAFXFunctionDeclInstruction {
			if(isNull(iScope)){
				return null;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pFunction: IAFXFunctionDeclInstruction = null;

			while(!isNull(pScope)){
				var pFunctionListMap: IAFXFunctionDeclListMap = pScope.functionMap;

				if(!isNull(pFunctionListMap)){
					var pFunctionList: IAFXFunctionDeclInstruction[] = pFunctionListMap[sFuncName];

					if(isDef(pFunctionList)){

						for(var i:  number  = 0; i < pFunctionList.length; i++){
							var pTestedFunction: IAFXFunctionDeclInstruction  = pFunctionList[i];
							var pTestedArguments: IAFXTypedInstruction[] = pTestedFunction.getArguments();

							if(pArgumentTypes.length > pTestedArguments.length ||
							   pArgumentTypes.length < pTestedFunction.getNumNeededArguments()){
								continue;
							}

							var isParamsEqual: bool = true;

							for(var j:  number  = 0; j < pArgumentTypes.length; j++){
								isParamsEqual = false;

								if(!pArgumentTypes[j].getType().isEqual(pTestedArguments[j].getType())){
									break;
								}

								isParamsEqual = true;
							}

							if(isParamsEqual){
								if(!isNull(pFunction)){
									return undefined;
								}
								pFunction = pTestedFunction;
							}
						}
					}

				}

				pScope = pScope.parent;
			}

			return pFunction;
		}

/**
		 * get shader function by name and list of types
		 * return null - if threre are not function; undefined - if there more then one function; function - if all ok
		 */

		getShaderFunction(sFuncName: string, pArgumentTypes: IAFXTypedInstruction[], iScope?:  number  =  0 ): IAFXFunctionDeclInstruction {
			if(isNull(iScope)){
				return null;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pFunction: IAFXFunctionDeclInstruction = null;

			while(!isNull(pScope)){
				var pFunctionListMap: IAFXFunctionDeclListMap = pScope.functionMap;

				if(!isNull(pFunctionListMap)){
					var pFunctionList: IAFXFunctionDeclInstruction[] = pFunctionListMap[sFuncName];

					if(isDef(pFunctionList)){

						for(var i:  number  = 0; i < pFunctionList.length; i++){
							var pTestedFunction: IAFXFunctionDeclInstruction  = pFunctionList[i];
							var pTestedArguments: IAFXVariableDeclInstruction[] = <IAFXVariableDeclInstruction[]>pTestedFunction.getArguments();

							if(pArgumentTypes.length > pTestedArguments.length){
								continue;
							}

							var isParamsEqual: bool = true;
							var iArg:  number  = 0;

							if(pArgumentTypes.length === 0){
								if(!isNull(pFunction)){
									return undefined;
								}

								pFunction = pTestedFunction;
								continue;
							}

							for(var j:  number  = 0; j < pTestedArguments.length; j++){
								isParamsEqual = false;

								if(iArg >= pArgumentTypes.length) {
									if(pTestedArguments[j].isUniform()){
										break;
									}
									else {
										isParamsEqual = true;
									}
								}
								else if(pTestedArguments[j].isUniform()){
									if(!pArgumentTypes[iArg].getType().isEqual(pTestedArguments[j].getType())){
										break;
									}
									else{
										iArg++;
										isParamsEqual = true;
									}
								}
							}

							if(isParamsEqual){
								if(!isNull(pFunction)){
									return undefined;
								}
								pFunction = pTestedFunction;
							}
						}
					}

				}

				pScope = pScope.parent;
			}

			return pFunction;
		}

		addVariable(pVariable: IAFXVariableDeclInstruction, iScope?:  number  = this._iCurrentScope): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pVariableMap: IAFXVariableDeclMap = pScope.variableMap;

			if(isNull(pVariableMap)){
				pVariableMap = pScope.variableMap = <IAFXVariableDeclMap>{};
			}

			var sVariableName: string = pVariable.getName();

			if(!pVariable.getType().isShared()){
				if(this.hasVariableInScope(sVariableName, iScope)){
					return false;
				}

				pVariableMap[sVariableName] = pVariable;
				pVariable._setScope(iScope);
			}
			else {
				if(!this.hasVariableInScope(sVariableName, iScope)){
					pVariableMap[sVariableName] = pVariable;
					pVariable._setScope(iScope);
				}
				else {
					var pBlendVariable: IAFXVariableDeclInstruction = pVariableMap[sVariableName].blend(pVariable, EAFXBlendMode.k_Shared);
					if(isNull(pBlendVariable)){
						return false;
					}
					pVariableMap[sVariableName] = pBlendVariable;
					pBlendVariable._setScope(iScope);
				}
			}

			return true;
		}

		addType(pType: IAFXTypeDeclInstruction, iScope?:  number  = this._iCurrentScope): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pTypeMap: IAFXTypeDeclMap = pScope.typeMap;

			if(isNull(pTypeMap)){
				pTypeMap = pScope.typeMap = <IAFXTypeDeclMap>{};
			}

			var sTypeName: string = pType.getName();

			if(this.hasTypeInScope(sTypeName, iScope)){
				return false;
			}

			pTypeMap[sTypeName] = pType;
			pType._setScope(iScope);

			return true;
		}

		addFunction(pFunction: IAFXFunctionDeclInstruction, iScope?:  number  =  0 ): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pFunctionMap: IAFXFunctionDeclListMap = pScope.functionMap;

			if(isNull(pFunctionMap)){
				pFunctionMap = pScope.functionMap = <IAFXFunctionDeclListMap>{};
			}

			var sFuncName: string = pFunction.getName();

			if(this.hasFunctionInScope(pFunction, iScope)){
				return false;
			}

			if(!isDef(pFunctionMap[sFuncName])){
				pFunctionMap[sFuncName] = [];
			}

			pFunctionMap[sFuncName].push(pFunction);
			pFunction._setScope(iScope);

			return true;
		}

		hasVariable(sVariableName: string, iScope?:  number  = this._iCurrentScope): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pVariableMap: IAFXVariableDeclMap = pScope.variableMap;

				if(!isNull(pVariableMap)){
					var pVariable: IAFXVariableDeclInstruction = pVariableMap[sVariableName];

					if(isDef(pVariable)){
						return true;
					}
				}

				pScope = pScope.parent;
			}

			return false;
		}

		hasType(sTypeName: string, iScope?:  number  = this._iCurrentScope): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pTypeMap: IAFXTypeDeclMap = pScope.typeMap;

				if(!isNull(pTypeMap)){
					var pType: IAFXTypeDeclInstruction = pTypeMap[sTypeName];

					if(isDef(pType)){
						return true;
					}
				}

				pScope = pScope.parent;
			}

			return false;
		}

		hasFunction(sFuncName: string, pArgumentTypes: IAFXTypedInstruction[], iScope?:  number  =  0 ): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pFunctionListMap: IAFXFunctionDeclListMap = pScope.functionMap;

				if(!isNull(pFunctionListMap)){
					var pFunctionList: IAFXFunctionDeclInstruction[] = pFunctionListMap[sFuncName];

					if(isDef(pFunctionList)){
						var pFunction: IAFXFunctionDeclInstruction = null;

						for(var i:  number  = 0; i < pFunctionList.length; i++){
							var pTestedFunction: IAFXFunctionDeclInstruction  = pFunctionList[i];
							var pTestedArguments: IAFXTypedInstruction[] = pTestedFunction.getArguments();

							if(pArgumentTypes.length > pTestedArguments.length ||
							   pArgumentTypes.length < pTestedFunction.getNumNeededArguments()){
								continue;
							}

							var isParamsEqual: bool = true;

							for(var j:  number  = 0; j < pArgumentTypes.length; j++){
								isParamsEqual = false;

								if(!pArgumentTypes[j].getType().isEqual(pTestedArguments[j].getType())){
									break;
								}

								isParamsEqual = true;
							}

							if(isParamsEqual){
								return true;
							}
						}
					}

				}

				pScope = pScope.parent;
			}

			return false;
		}

		private  /**@inline*/  hasVariableInScope(sVariableName: string, iScope:  number ): bool {
			return isDef(this._pScopeMap[iScope].variableMap[sVariableName]);
		}

		private  /**@inline*/  hasTypeInScope(sTypeName: string, iScope:  number ): bool {
			return isDef(this._pScopeMap[iScope].typeMap[sTypeName]);
		}

		private hasFunctionInScope(pFunction: IAFXFunctionDeclInstruction, iScope:  number ): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pFunctionListMap:IAFXFunctionDeclListMap = pScope.functionMap;
			var pFunctionList: IAFXFunctionDeclInstruction[] = pFunctionListMap[pFunction.getName()];

			if(!isDef(pFunctionList)){
				return false;
			}

			var pFunctionArguments: IAFXTypedInstruction[] = <IAFXTypedInstruction[]>pFunction.getArguments();
			var hasFunction: bool = false;

			for(var i:  number  = 0; i < pFunctionList.length; i++){
				var pTestedArguments: IAFXTypedInstruction[] = <IAFXTypedInstruction[]>pFunctionList[i].getArguments();

				if(pTestedArguments.length !== pFunctionArguments.length){
					continue;
				}

				var isParamsEqual: bool = true;

				for(var j:  number  = 0; j < pFunctionArguments.length; j++){
					isParamsEqual = false;

					if(!pTestedArguments[j].getType().isEqual(pFunctionArguments[j].getType())){
						break;
					}

					isParamsEqual = true;
				}

				if(isParamsEqual){
					hasFunction = true;
					break;
				}
			}

			return hasFunction;
		}

	}



	export class ExprTemplateTranslator {
		private _pInToOutArgsMap: IntMap = null;
	    private _pExprPart: IAFXSimpleInstruction[] = null;

	    constructor(sExprTemplate: string){
	    	this._pInToOutArgsMap = <IntMap>{};
	    	this._pExprPart = <IAFXSimpleInstruction[]>[];

	    	var pSplitTemplate: string[] = sExprTemplate.split(/(\$\d+)/);

	    	for(var i:  number  = 0; i < pSplitTemplate.length; i++){
	    		if (pSplitTemplate[i]) {
		            if (pSplitTemplate[i][0] !== '$') {
		                this._pExprPart.push(new SimpleInstruction(pSplitTemplate[i]));
		            }
		            else {
		                this._pExprPart.push(null);
		                this._pInToOutArgsMap[this._pExprPart.length - 1] = ((<number><any>(pSplitTemplate[i].substr(1))) * 1 - 1);
		            }
	        	}
	    	}
	    }

	    toInstructionList(pArguments: IAFXInstruction[]): IAFXInstruction[] {
			var pOutputInstructionList: IAFXInstruction[] = <IAFXInstruction[]>[];

	    	for(var i:  number  = 0; i < this._pExprPart.length; i++){
	    		if(isNull(this._pExprPart[i])){
	    			pOutputInstructionList.push(pArguments[this._pInToOutArgsMap[i]]);
	    		}
	    		else {
	    			pOutputInstructionList.push(this._pExprPart[i]);
	    		}
	    	}

	    	return pOutputInstructionList;
		}
	}

}









module akra.fx {
	export class Instruction implements IAFXInstruction{
		protected _pParentInstruction: IAFXInstruction = null;
		protected _sOperatorName: string = null;
		protected _pInstructionList: IAFXInstruction[] = null;
		protected _nInstructions:  number  = 0;
		protected   _eInstructionType: EAFXInstructionTypes = 0;
		protected _pLastError: IAFXInstructionError = null;
		protected _bErrorOccured: bool = false;
		protected _iInstructionID:  number  = 0;
		protected _iScope:  number  =  0xffffff ;
		private static _nInstructionCounter:  number  = 0;

		private _isVisible: bool = true;

		/**@inline*/  getGuid():  number  {
			return this._getInstructionID();
		}

		/**@inline*/  getParent(): IAFXInstruction{
			return this._pParentInstruction;
		}

		/**@inline*/  setParent(pParentInstruction: IAFXInstruction): void {
			this._pParentInstruction = pParentInstruction;
		}

		/**@inline*/  getOperator(): string {
			return this._sOperatorName;
		}

		/**@inline*/  setOperator(sOperator: string): void {
			this._sOperatorName = sOperator;
		}

		/**@inline*/  getInstructions(): IAFXInstruction[] {
			return this._pInstructionList;
		}

		/**@inline*/  setInstructions(pInstructionList: IAFXInstruction[]): void{
			this._pInstructionList = pInstructionList;
		}

		/**@inline*/  _getInstructionType(): EAFXInstructionTypes {
			return this._eInstructionType;
		}

		/**@inline*/  _getInstructionID():  number  {
			return this._iInstructionID;
		}

		_getScope():  number  {
			return this._iScope !==  0xffffff  ? this._iScope :
						!isNull(this.getParent()) ? this.getParent()._getScope() :  0xffffff ;
		}

        /**@inline*/  _setScope(iScope:  number ): void {
        	this._iScope = iScope;
        }

        /**@inline*/  _isInGlobalScope(): bool{
        	return this._getScope() === 0;
        }

		/**@inline*/  getLastError(): IAFXInstructionError {
			return this._pLastError;
		}

		/**@inline*/  setError(eCode:  number , pInfo?: any = null): void {
			this._pLastError.code = eCode;
			this._pLastError.info = pInfo;
			this._bErrorOccured = true;
		}

		/**@inline*/  clearError(): void {
			this._bErrorOccured = false;
			this._pLastError.code = 0;
			this._pLastError.info = null;
		}

		/**@inline*/  isErrorOccured(): bool {
			return this._bErrorOccured;
		}

		/**@inline*/  setVisible(isVisible: bool): void {
            this._isVisible = isVisible;
        }

        /**@inline*/  isVisible(): bool {
            return this._isVisible;
        }

        /**@inline*/  initEmptyInstructions(): void {
        	this._pInstructionList = [];
        }

		constructor(){
			this._iInstructionID = Instruction._nInstructionCounter++;
			this._pParentInstruction = null;
			this._sOperatorName = null;
			this._pInstructionList = null;
			this._nInstructions = 0;
			this._eInstructionType = EAFXInstructionTypes.k_Instruction;
			this._pLastError = {code: 0, info: null};
		}

		push(pInstruction: IAFXInstruction, isSetParent?: bool = false): void {
			if(!isNull(this._pInstructionList)){
				this._pInstructionList[this._nInstructions] = pInstruction;
				this._nInstructions += 1;
			}
			if(isSetParent && !isNull(pInstruction)){
				pInstruction.setParent(this);
			}
		}

    	addRoutine(fnRoutine: IAFXInstructionRoutine, iPriority?:  number ): void {
//TODO
    	}

    	prepareFor(eUsedType: EFunctionType): void {
    		if(!isNull(this._pInstructionList) && this._nInstructions > 0) {
    			for(var i:  number  = 0; i < this._nInstructions; i++){
    				this._pInstructionList[i].prepareFor(eUsedType);
    			}
    		}
    	}
/**
    	 * Проверка валидности инструкции
    	 */

    	check(eStage: ECheckStage, pInfo: any = null): bool {
    		if(this._bErrorOccured){
    			return false;
    		}
    		else {
    			return true;
    		}
    	}

/**
    	 * Подготовка интсрукции к дальнейшему анализу
    	 */

    	prepare(): bool {
    		return true;
    	}

    	toString(): string {
    		return null;
    	}

    	toFinalCode(): string {
    		return "";
    	}

    	clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXInstruction {
    		if(isDef(pRelationMap[this._getInstructionID()])){
    			return pRelationMap[this._getInstructionID()];
    		}

    		var pNewInstruction: IAFXInstruction = new this["constructor"]();
    		var pParent: IAFXInstruction = this.getParent() || null;

    		if(!isNull(pParent) && isDef(pRelationMap[pParent._getInstructionID()])){
    			pParent = pRelationMap[pParent._getInstructionID()];
    		}

    		pNewInstruction.setParent(pParent);
    		pRelationMap[this._getInstructionID()] = pNewInstruction;

    		if(!isNull(this._pInstructionList) && isNull(pNewInstruction.getInstructions())){
    			pNewInstruction.initEmptyInstructions();
    		}

    		for(var i:  number  = 0; i < this._nInstructions; i++){
    			pNewInstruction.push(this._pInstructionList[i].clone(pRelationMap));
    		}

    		pNewInstruction.setOperator(this.getOperator());

    		return pNewInstruction;
    	}
	}

	export class InstructionCollector extends Instruction {
		constructor(){
			super();
			this._pInstructionList = [];
			this._eInstructionType = EAFXInstructionTypes.k_InstructionCollector;
		}

		toFinalCode(): string {
    		var sCode: string = "";
    		for(var i:  number  = 0; i < this._nInstructions; i++){
    			sCode += this.getInstructions()[i].toFinalCode();
    		}

    		return sCode;
    	}
	}

	export class SimpleInstruction extends Instruction implements IAFXSimpleInstruction{
		private _sValue: string = "";

		constructor(sValue: string){
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_SimpleInstruction;

			this._sValue = sValue;
		}

		/**@inline*/  setValue(sValue: string): void {
			this._sValue = sValue;
		}

		/**@inline*/  isValue(sValue: string): bool {
			return (this._sValue === sValue);
		}

		toString(): string{
			return this._sValue;
		}

		toFinalCode(): string{
			return this._sValue;
		}

		clone(pRelationMap?: IAFXInstructionMap): SimpleInstruction {
			var pClone: SimpleInstruction = <SimpleInstruction>super.clone(pRelationMap);
			pClone.setValue(this._sValue);
			return pClone;
		}
	}



	export class TypedInstruction extends Instruction implements IAFXTypedInstruction {
		protected _pType: IAFXTypeInstruction;

		constructor(){
			super();
			this._pType = null;
			this._eInstructionType = EAFXInstructionTypes.k_TypedInstruction;
		}

		getType(): IAFXTypeInstruction {
			return this._pType;
		}

		setType(pType: IAFXTypeInstruction): void {
			this._pType = pType;
		}

		clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXTypedInstruction {
			var pClonedInstruction: IAFXTypedInstruction = <IAFXTypedInstruction>(super.clone(pRelationMap));
			if(!isNull(this.getType())) {
				pClonedInstruction.setType(this.getType().clone(pRelationMap));
			}
			return pClonedInstruction;
		}
	}



	export class DeclInstruction extends TypedInstruction implements IAFXDeclInstruction {
		protected _sSemantic: string = "";
		protected _pAnnotation: IAFXAnnotationInstruction = null;
		protected _bForPixel: bool = true;
		protected _bForVertex: bool = true;
		protected _isBuiltIn: bool = false;

		constructor(){
			super();
			this._eInstructionType = EAFXInstructionTypes.k_DeclInstruction;
		}

		setSemantic(sSemantic: string): void {
			this._sSemantic = sSemantic;
		}

		setAnnotation(pAnnotation: IAFXAnnotationInstruction): void {
			this._pAnnotation = pAnnotation;
		}

		getName(): string {
			return "";
		}

		getRealName(): string {
			return "";
		}

		getNameId(): IAFXIdInstruction {
			return null;
		}

		/**@inline*/  getSemantic(): string {
			return this._sSemantic;
		}

		isBuiltIn(): bool {
			return this._isBuiltIn;
		}

		setBuiltIn(isBuiltIn: bool): void {
			this._isBuiltIn = isBuiltIn;
		}

		/**@inline*/  _isForAll(): bool{
			return this._bForVertex && this._bForPixel;
		}
        /**@inline*/  _isForPixel(): bool{
        	return this._bForPixel;
        }
        /**@inline*/  _isForVertex(): bool{
        	return this._bForVertex;
        }

        /**@inline*/  _setForAll(canUse: bool): void{
        	this._bForVertex = canUse;
        	this._bForPixel = canUse;
        }
        /**@inline*/  _setForPixel(canUse: bool): void{
    	    this._bForPixel = canUse;
    	}
        /**@inline*/  _setForVertex(canUse: bool): void{
        	this._bForVertex = canUse;
        }

		clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXDeclInstruction {
			var pClonedInstruction: IAFXDeclInstruction = <IAFXDeclInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setSemantic(this._sSemantic);
			pClonedInstruction.setAnnotation(this._pAnnotation);
			return pClonedInstruction;
		}
	}



	export class IdInstruction extends Instruction implements IAFXIdInstruction {
		private _sName: string;
		private _sRealName: string;
		private _isForVarying: bool = false;

		/**@inline*/  isVisible(): bool {
			return this.getParent().isVisible();
		}
/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._sName = "";
			this._sRealName = "";
			this._eInstructionType = EAFXInstructionTypes.k_IdInstruction;
		}

		/**@inline*/  getName(): string{
			return this._sName;
		}

		/**@inline*/  getRealName(): string{
			if(this._isForVarying){
				return "V_"+this._sRealName;
			}
			else {
				return this._sRealName;
			}
		}

		/**@inline*/  setName(sName: string): void{
			this._sName = sName;
			this._sRealName = sName;
		}

		/**@inline*/  setRealName(sRealName: string): void{
			this._sRealName = sRealName;
		}

		/**@inline*/  _markAsVarying(bValue: bool): void{
			this._isForVarying = bValue;
		}

		toString(): string {
			return this._sRealName;
		}

		toFinalCode(): string {
			return this.getRealName();
		}

		clone(pRelationMap?: IAFXInstructionMap): IdInstruction {
			var pClonedInstruction: IdInstruction = <IdInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setName(this._sName);
			pClonedInstruction.setRealName(this._sRealName);
			return pClonedInstruction;
		}

	}

	export class KeywordInstruction extends Instruction implements IAFXKeywordInstruction {
		private _sValue: string;

/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._sValue = "";
			this._eInstructionType = EAFXInstructionTypes.k_KeywordInstruction;
		}

		/**@inline*/  setValue(sValue: string): void {
			this._sValue = sValue;
		}

		/**@inline*/  isValue(sTestValue: string): bool {
			return this._sValue === sTestValue;
		}

		toString(): string {
			return this._sValue;
		}

		toFinalCode(): string{
			return this._sValue;
		}
	}


	export class AnnotationInstruction extends Instruction implements IAFXAnnotationInstruction {
		constructor() {
			super();
			this._eInstructionType = EAFXInstructionTypes.k_AnnotationInstruction;
		}
	}

}













module akra.fx {
	export class TypeDeclInstruction extends DeclInstruction implements IAFXTypeDeclInstruction {
// EMPTY_OPERATOR VariableTypeInstruction

		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_TypeDeclInstruction;
		}

		/**@inline*/  getType(): IAFXTypeInstruction {
			return <IAFXTypeInstruction>this._pInstructionList[0];
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXTypeDeclInstruction {
        	return <IAFXTypeDeclInstruction>super.clone(pRelationMap);
        }

        toFinalCode(): string {
			return this.getType()._toDeclString() + ";";
		}

        /**@inline*/  getName(): string {
        	return this.getType().getName();
        }

        /**@inline*/  getRealName(): string {
        	return this.getType().getRealName();
        }

        blend(pDecl: IAFXTypeDeclInstruction, eBlendMode: EAFXBlendMode): IAFXTypeDeclInstruction {
        	if(pDecl !== this){
        		return null;
        	}

        	return this;
        }
	}

	export class VariableTypeInstruction extends Instruction implements IAFXVariableTypeInstruction {
		private _pSubType: IAFXTypeInstruction = null;
		private _pUsageList: string[] = null;

		private _sName: string = "";
		private _isWritable: bool = null;
		private _isReadable: bool = null;

		private _bUsedForWrite: bool = false;
		private _bUsedForRead: bool = false;

		private _sHash: string = "";
		private _sStrongHash: string = "";
		private _isArray: bool = false;
		private _isPointer: bool = false;
		private _isStrictPointer: bool = false;
		private _isPointIndex: bool = null;
		private _isUniform: bool = null;
		private _isGlobal: bool = null;
		private _isConst: bool = null;
		private _isShared: bool = null;
		private _isForeign: bool = null;
		private _iLength:  number  =  0xffffff ;
		private _isNeedToUpdateLength: bool = false;

// private $length = 0;
// inline get _iLength() {
// 	return this.$length;
// }

// inline set _iLength(n: int) {
// 	if (n === null) {
// 		LOG(__CALLSTACK__);
// 	}
// 	this.$length = n;
// }

		private _isFromVariableDecl: bool = null;
		private _isFromTypeDecl: bool = null;
		private _isField: bool = false;

		private _pArrayIndexExpr: IAFXExprInstruction = null;
		private _pArrayElementType: IAFXVariableTypeInstruction = null;

		private _pFieldDeclMap: IAFXVariableDeclMap = null;
		private _pFieldDeclBySemanticMap: IAFXVariableDeclMap = null;
		private _pFieldIdMap: IAFXIdExprMap = null;
		private _pUsedFieldMap: IAFXVarUsedModeMap = null;

		private _pVideoBuffer: IAFXVariableDeclInstruction = null;
		private _pMainPointIndex: IAFXVariableDeclInstruction = null;
		private _pUpPointIndex: IAFXVariableDeclInstruction = null;
		private _pDownPointIndex: IAFXVariableDeclInstruction = null;
		private _nPointDim:  number  = 0;
		private _pPointerList: IAFXVariableDeclInstruction[] = null;
		private _iPadding:  number  =  0xffffff ;

		private _pSubDeclList: IAFXVariableDeclInstruction[] = null;
		private _pAttrOffset: IAFXVariableDeclInstruction = null;

		private _bUnverifiable: bool = false;
		private _bCollapsed: bool = false;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_VariableTypeInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			if(!isNull(this._pUsageList)){
				if(!this.isShared()){
					for(var i:  number  = 0; i < this._pUsageList.length; i++){
						sCode += this._pUsageList[i] + " ";
					}
				}
			}

			sCode += this.getSubType().toFinalCode();

			return sCode;
		}

		_toDeclString(): string {
			return this.getSubType()._toDeclString();
		}

		isBuiltIn(): bool {
			return false;
		}

        setBuiltIn(isBuiltIn: bool): void {
        }

        /**@inline*/  _setCollapsed(bValue: bool): void {
            this._bCollapsed = bValue;
        }

        /**@inline*/  _isCollapsed(): bool {
            return this._bCollapsed;
        }

//-----------------------------------------------------------------//
//----------------------------SIMPLE TESTS-------------------------//
//-----------------------------------------------------------------//

		/**@inline*/  isBase(): bool {
			return this.getSubType().isBase() && this._isArray === false;
		}

		/**@inline*/  isArray(): bool {
			return this._isArray ||
				   (this.getSubType().isArray());
		}

		/**@inline*/  isNotBaseArray(): bool {
			return this._isArray || (this.getSubType().isNotBaseArray());
		}

		/**@inline*/  isComplex(): bool {
			return this.getSubType().isComplex();
		}

		isEqual(pType: IAFXTypeInstruction): bool {
			if(this._isUnverifiable()){
				return true;
			}

			if (this.isNotBaseArray() && pType.isNotBaseArray() &&
				(this.getLength() !== pType.getLength() ||
				 this.getLength() ===  0xffffff  ||
				 pType.getLength() ===  0xffffff )){
				return false;
			}

			if(this.getHash() !== pType.getHash()){
				return false;
			}

			return true;
		}

		isStrongEqual(pType: IAFXTypeInstruction): bool {
			if(!this.isEqual(pType) || this.getStrongHash() !== pType.getStrongHash()){
				return false;
			}

			return true;
		}

		isSampler(): bool {
			return this.getSubType().isSampler();
		}

		isSamplerCube(): bool {
			return this.getSubType().isSamplerCube();
		}

        isSampler2D(): bool {
        	return this.getSubType().isSampler2D();
        }

		isWritable(): bool {
			if(!isNull(this._isWritable)){
				return this._isWritable;
			}

			if ((this.isArray() && !this.isBase()) ||
				this.isForeign() || this.isUniform()){
				this._isWritable = false;
			}
			else {
				this._isWritable = this.getSubType().isWritable();
			}

			return this._isWritable;
		}

		isReadable(): bool {
			if(!isNull(this._isReadable)){
				return this._isReadable;
			}

			if(this.hasUsage("out")){
				this._isReadable = false;
			}
			else{
				this._isReadable = this.getSubType().isReadable();
			}

			return this._isReadable;
		}

		_containArray(): bool {
			return this.getSubType()._containArray();
		}

        _containSampler(): bool {
        	return this.getSubType()._containSampler();
        }

        _containPointer(): bool {
        	return this.getSubType()._containPointer();
        }

        _containComplexType(): bool {
        	return this.getSubType()._containComplexType();
        }

		isPointer(): bool {
			return this._isPointer ||
				   (this.getSubType()._getInstructionType() === EAFXInstructionTypes.k_VariableTypeInstruction &&
				   	(<IAFXVariableTypeInstruction>this.getSubType()).isPointer());
		}

		isStrictPointer(): bool {
			return this._isStrictPointer ||
					(this.getSubType()._getInstructionType() === EAFXInstructionTypes.k_VariableTypeInstruction &&
				   	(<IAFXVariableTypeInstruction>this.getSubType()).isStrictPointer());
		}

		isPointIndex(): bool{
			if(isNull(this._isPointIndex)){
				this._isPointIndex = this.isStrongEqual(Effect.getSystemType("ptr"));
			}

			return this._isPointIndex;
		}

		isFromVariableDecl(): bool {
			if(!isNull(this._isFromVariableDecl)){
				return this._isFromVariableDecl;
			}

			if(isNull(this.getParent())){
				this._isFromVariableDecl = false;
			}
			else {
				var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

				if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
					this._isFromVariableDecl = true;
				}
				else if(eParentType === EAFXInstructionTypes.k_VariableTypeInstruction){
					this._isFromVariableDecl = (<IAFXVariableTypeInstruction>this.getParent()).isFromVariableDecl();
				}
				else {
					this._isFromVariableDecl = false;
				}
			}

			return this._isFromVariableDecl;
		}

        isFromTypeDecl(): bool {
        	if(!isNull(this._isFromTypeDecl)){
				return this._isFromTypeDecl;
			}

        	if(isNull(this.getParent())){
				this._isFromTypeDecl = false;
			}
			else {
	        	var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

				if(eParentType === EAFXInstructionTypes.k_TypeDeclInstruction){
					this._isFromTypeDecl = true;
				}
				else if(eParentType === EAFXInstructionTypes.k_VariableTypeInstruction){
					this._isFromTypeDecl = (<IAFXVariableTypeInstruction>this.getParent()).isFromVariableDecl();
				}
				else {
					this._isFromTypeDecl = false;
				}
			}

			return this._isFromTypeDecl;
        }

        isUniform(): bool {
        	if(isNull(this._isUniform)){
				this._isUniform = this.hasUsage("uniform");
			}

			return this._isUniform;
        }

        isGlobal(): bool {
        	if(isNull(this._isGlobal)){
				this._isGlobal = this._getScope() === 0;
			}

			return this._isGlobal;
        }

        isConst(): bool {
			if(isNull(this._isConst)){
				this._isConst = this.hasUsage("const");
			}

			return this._isConst;
		}

        isShared(): bool {
        	if(isNull(this._isShared)){
				this._isShared = this.hasUsage("shared");
			}

			return this._isShared;
        }

        isForeign(): bool {
        	if(isNull(this._isForeign)){
				this._isForeign = this.hasUsage("foreign");
			}

			return this._isForeign;
        }

        _isTypeOfField(): bool {
        	if(isNull(this.getParent())){
        		return false;
        	}

        	if(this.getParent()._getInstructionType() === EAFXInstructionTypes.k_VariableDeclInstruction){
        		var pParentDecl: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getParent();
        		return pParentDecl.isField();
        	}

        	return false;
        }

        /**@inline*/  _isUnverifiable(): bool {
        	return this._bUnverifiable;
        }

//-----------------------------------------------------------------//
//----------------------------SET TYPE INFO------------------------//
//-----------------------------------------------------------------//

		setName(sName: string): void {
			this._sName = sName;
		}

		/**@inline*/  _canWrite(isWritable: bool): void {
			this._isWritable = isWritable;
		}

		/**@inline*/  _canRead(isReadable: bool): void {
			this._isReadable = isReadable;
		}

//-----------------------------------------------------------------//
//----------------------------INIT API-----------------------------//
//-----------------------------------------------------------------//
		/**@inline*/  setPadding(iPadding:  number ): void {
			this._iPadding = iPadding;
		}

		pushType(pType: IAFXTypeInstruction): void {
			var eType: EAFXInstructionTypes = pType._getInstructionType();

			if (eType === EAFXInstructionTypes.k_SystemTypeInstruction ||
				eType === EAFXInstructionTypes.k_ComplexTypeInstruction){
				this._pSubType = pType;
			}
			else {
				var pVarType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pType;
				if(!pVarType.isNotBaseArray() && !pVarType.isPointer()){
					var pUsageList: string[] = pVarType.getUsageList();
					if(!isNull(pUsageList)){
						for(var i:  number  = 0; i < pUsageList.length; i++){
							this.addUsage(pUsageList[i]);
						}
					}

					this._pSubType = pVarType.getSubType();
				}
				else{
					this._pSubType = pType;
				}
			}

		}

		addUsage(sUsage: string): void {
			if(isNull(this._pUsageList)){
				this._pUsageList = [];
			}

			if(!this.hasUsage(sUsage)){
				this._pUsageList.push(sUsage);
			}
		}

		addArrayIndex(pExpr: IAFXExprInstruction): void {
//TODO: add support for v[][10]

			this._pArrayElementType = new VariableTypeInstruction();
			this._pArrayElementType.pushType(this.getSubType());
			if(!isNull(this._pUsageList)){
				for(var i:  number  = 0; i < this._pUsageList.length; i++){
					this._pArrayElementType.addUsage(this._pUsageList[i]);
				}
			}
			this._pArrayElementType.setParent(this);

			this._pArrayIndexExpr = pExpr;

			this._iLength = this._pArrayIndexExpr.evaluate() ? this._pArrayIndexExpr.getEvalValue() :  0xffffff ;

			this._isArray = true;

			if(this._iLength ===  0xffffff ){
				this._isNeedToUpdateLength = true;
			}
		}

		addPointIndex(isStrict?: bool = true): void {
			this._nPointDim++;
			this._isPointer = true;
			if(isStrict){
				this._isStrictPointer = true;
			}
		}

		setVideoBuffer(pBuffer: IAFXVariableDeclInstruction): void {
			if(this.isPointIndex()){
				(<IAFXVariableDeclInstruction>this.getParent().getParent()).getType().setVideoBuffer(pBuffer);
				return;
			}

			this._pVideoBuffer = pBuffer;

			if(!this.isComplex()){
				return;
			}

			var pFieldNameList: string[] = this.getFieldNameList();

			for(var i:  number  = 0; i < pFieldNameList.length; i++){
				var pFieldType: IAFXVariableTypeInstruction = this.getFieldType(pFieldNameList[i]);

				if(pFieldType.isPointer()){
					pFieldType.setVideoBuffer(pBuffer);
				}
			}
		}

		initializePointers(): void {
			this._pPointerList = [];
			var pDownPointer: IAFXVariableDeclInstruction = this._getParentVarDecl();

			for(var i: number  = 0; i < this.getPointDim(); i++){
				var pPointer: IAFXVariableDeclInstruction = new VariableDeclInstruction();
				var pPointerType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
				var pPointerId: IAFXIdInstruction = new IdInstruction();

				pPointer.push(pPointerType, true);
				pPointer.push(pPointerId, true);

				pPointerType.pushType(Effect.getSystemType("ptr"));
				pPointerId.setName( "undef" );
				pPointerId.setName(this._getParentVarDecl().getName() + "_pointer_" + i.toString());

				if(i > 0) {
					(this._pPointerList[i - 1].getType())._setUpDownPointers(pPointer, pDownPointer);
					pDownPointer = this._pPointerList[i - 1];
				}
				else{
					pPointerType._setUpDownPointers(null, pDownPointer);
				}

				pPointer.setParent(this._getParentVarDecl());
				this._pPointerList.push(pPointer);
			}

			this._pPointerList[this._pPointerList.length - 1].getType()._setUpDownPointers(null, pDownPointer);
			this._pUpPointIndex = this._pPointerList[0];
			this._pMainPointIndex = this._pPointerList[this._pPointerList.length - 1];
		}

		_setPointerToStrict(): void {
			this._isStrictPointer = true;
		}

		_addPointIndexInDepth(): void {
			if(!this.isComplex()){
				return;
			}

			var pFieldNameList: string[] = this.getFieldNameList();

			for(var i:  number  = 0; i < pFieldNameList.length; i++){
				var pFieldType: IAFXVariableTypeInstruction = this.getFieldType(pFieldNameList[i]);
				if(!pFieldType.isPointer()){
					pFieldType.addPointIndex(false);
					pFieldType._setVideoBufferInDepth();
				}
			}
		}

		_setVideoBufferInDepth(): void {
			if(this.isPointer()){
				this.setVideoBuffer(Effect.createVideoBufferVariable());
			}
			else if(this.isComplex() && this._containPointer()){
				var pFieldNameList: string[] = this.getFieldNameList();

				for(var i:  number  = 0; i < pFieldNameList.length; i++){
					var pFieldType: IAFXVariableTypeInstruction = this.getFieldType(pFieldNameList[i]);

					pFieldType._setVideoBufferInDepth();
				}
			}
		}

		/**@inline*/  _markAsUnverifiable(isUnverifiable: bool): void {
        	this._bUnverifiable = true;
        }

        _addAttrOffset(pOffset: IAFXVariableDeclInstruction): void {
            this._pAttrOffset = pOffset;
        }


//-----------------------------------------------------------------//
//----------------------------GET TYPE INFO------------------------//
//-----------------------------------------------------------------//	

		getName(): string {
			return this._sName;
		}

		/**@inline*/  getRealName(): string {
			return this.getBaseType().getRealName();
		}

		getHash(): string {
			if(this._sHash === ""){
				this.calcHash();
			}

			return this._sHash;
		}

		getStrongHash(): string {
			if(this._sStrongHash === "") {
				this.calcStrongHash();
			}

			return this._sStrongHash;
		}

		getSize():  number  {
			if(this.isPointer() || this.isPointIndex()){
				return 1;
			}

			if(this._isArray){
				var iSize:  number  = this._pArrayElementType.getSize();
				if (this._iLength ===  0xffffff  ||
					iSize ===  0xffffff ){
					return  0xffffff ;
				}
				else{
					return iSize * this._iLength;
				}
			}
			else {
				return this.getSubType().getSize();
			}
		}

		getBaseType(): IAFXTypeInstruction{
 			return this.getSubType().getBaseType();
 		}

		getLength():  number  {
			if(!this.isNotBaseArray()){
				this._iLength = 0;
				return 0;
			}

			if(this.isNotBaseArray() && !this._isArray){
				this._iLength = this.getSubType().getLength();
			}
			else if(this._iLength ===  0xffffff  || this._isNeedToUpdateLength){
				var isEval: bool = this._pArrayIndexExpr.evaluate();

				if(isEval) {
					var iValue:  number  = < number >this._pArrayIndexExpr.getEvalValue();
					this._iLength = isInt(iValue) ? iValue :  0xffffff ;
				}
			}

			return this._iLength;
		}

		getPadding():  number  {
			return this.isPointIndex() ? this._getDownPointer().getType().getPadding() : this._iPadding;
		}

		getArrayElementType(): IAFXVariableTypeInstruction {
			if(this._isUnverifiable()){
				return this;
			}

			if(!this.isArray()){
				return null;
			}

			if(isNull(this._pArrayElementType)){
				this._pArrayElementType = new VariableTypeInstruction();
				this._pArrayElementType.pushType(this.getSubType().getArrayElementType());
				if(!isNull(this._pUsageList)){
					for(var i:  number  = 0; i <  this._pUsageList.length; i++){
						this._pArrayElementType.addUsage(this._pUsageList[i]);
					}
				}
				this._pArrayElementType.setParent(this);
			}

			return this._pArrayElementType;
		}

		getTypeDecl(): IAFXTypeDeclInstruction {
			if(!this.isFromTypeDecl()){
				return null;
			}

			var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

			if(eParentType === EAFXInstructionTypes.k_TypeDeclInstruction){
				return <IAFXTypeDeclInstruction>this.getParent();
			}
			else {
				return (<IAFXTypeInstruction>this.getParent()).getTypeDecl();
			}
		}

		hasField(sFieldName: string): bool {
			return this._isUnverifiable() ? true : this.getSubType().hasField(sFieldName);
		}

		hasFieldWithSematic(sSemantic: string): bool {
			if(!this.isComplex()){
				return false;
			}

			return this.getSubType().hasFieldWithSematic(sSemantic);
		}

		hasAllUniqueSemantics(): bool {
			if(!this.isComplex()){
				return false;
			}

			return this.getSubType().hasAllUniqueSemantics();
		}

		hasFieldWithoutSemantic(): bool {
			if(!this.isComplex()){
				return false;
			}

			return this.getSubType().hasFieldWithoutSemantic();
		}

		getField(sFieldName: string): IAFXVariableDeclInstruction {
			if(!this.hasField(sFieldName)){
				return null;
			}

			if(isNull(this._pFieldDeclMap)) {
				this._pFieldDeclMap = <IAFXVariableDeclMap>{};
			}

			if(isDef(this._pFieldDeclMap[sFieldName])){
				return this._pFieldDeclMap[sFieldName];
			}

			var pField: IAFXVariableDeclInstruction = new VariableDeclInstruction();

			if(!this._isUnverifiable()){
				var pSubField: IAFXVariableDeclInstruction = this.getSubType().getField(sFieldName);

				var pFieldType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
				pFieldType.pushType(pSubField.getType());
// if(!this.isBase()){
				pFieldType.setPadding(pSubField.getType().getPadding());
// }
				pField.push(pFieldType, true);
				pField.push(pSubField.getNameId(), false);
				pField.setSemantic(pSubField.getSemantic());
			}
			else {
				var pFieldName: IAFXIdInstruction = new IdInstruction();

				pFieldName.setName(sFieldName);
				pFieldName.setRealName(sFieldName);

				pField.push(this, false);
				pField.push(pFieldName, true);
			}

			pField.setParent(this);

			this._pFieldDeclMap[sFieldName] = pField;

			return pField;
		}

		/**@inline*/  getFieldBySemantic(sSemantic: string): IAFXVariableDeclInstruction {
			if(this.hasFieldWithSematic(sSemantic)){
				return null;
			}

			if(isNull(this._pFieldDeclBySemanticMap)) {
				this._pFieldDeclBySemanticMap = <IAFXVariableDeclMap>{};
			}

			if(isDef(this._pFieldDeclBySemanticMap[sSemantic])){
				return this._pFieldDeclBySemanticMap[sSemantic];
			}

			var pField: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pSubField: IAFXVariableDeclInstruction = this.getSubType().getFieldBySemantic(sSemantic);

			var pFieldType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			pFieldType.pushType(pSubField.getType());
// if(!this.isBase()){
			pFieldType.setPadding(pSubField.getType().getPadding());
// }
			pField.push(pFieldType, true);
			pField.push(pSubField.getNameId(), false);


			pField.setParent(this);

			this._pFieldDeclBySemanticMap[sSemantic] = pField;

			return pField;
		}

		getFieldType(sFieldName: string): IAFXVariableTypeInstruction {
			return <IAFXVariableTypeInstruction>this.getField(sFieldName).getType();
		}

 		getFieldNameList(): string[] {
 			return this.getSubType().getFieldNameList();
 		}


 		/**@inline*/  getUsageList(): string[] {
 			return this._pUsageList;
 		}

		/**@inline*/  getSubType(): IAFXTypeInstruction {
			return this._pSubType;
		}

		hasUsage(sUsageName: string): bool {
			if(isNull(this._pUsageList)){
				return false;
			}

			for(var i:  number  = 0; i < this._pUsageList.length; i++){
				if(this._pUsageList[i] === sUsageName){
					return true;
				}
			}

			if(!isNull(this.getSubType()) && this.getSubType()._getInstructionType() === EAFXInstructionTypes.k_VariableTypeInstruction){
				return (<IAFXVariableTypeInstruction>this.getSubType()).hasUsage(sUsageName);
			}

			return false;
		}

		hasVideoBuffer(): bool {
			return !isNull(this.getVideoBuffer());
		}

		getPointDim():  number  {
			return this._nPointDim ||
				   ((this.getSubType()._getInstructionType() === EAFXInstructionTypes.k_VariableTypeInstruction) ?
				   (<IAFXVariableTypeInstruction>this.getSubType()).getPointDim() : 0);
		}

		getPointer(): IAFXVariableDeclInstruction {
			if (!this.isFromVariableDecl() ||
				!(this.isPointer() || this.isPointIndex()) || !this.hasVideoBuffer()){
				return null;
			}

			if(!isNull(this._pUpPointIndex)){
				return this._pUpPointIndex;
			}

			if(this.isPointIndex()){
				return null;
			}

			this.initializePointers();

			return this._pUpPointIndex;
		}

		getVideoBuffer(): IAFXVariableDeclInstruction {
			if(this.isPointIndex()) {
				return (<IAFXVariableDeclInstruction>this.getParent().getParent()).getType().getVideoBuffer();
			}

			return this._pVideoBuffer;
		}

		getFieldExpr(sFieldName: string): IAFXIdExprInstruction {
			if(!this.hasField(sFieldName)){
				return null;
			}
			var pField: IAFXVariableDeclInstruction = this.getField(sFieldName);
			var pExpr: IAFXIdExprInstruction = new IdExprInstruction();
			pExpr.push(pField.getNameId(), false);
			pExpr.setType(pField.getType());

			return pExpr;
		}

		getFieldIfExist(sFieldName: string): IAFXVariableDeclInstruction {
			if(isNull(this._pFieldDeclMap) && isDef(this._pFieldDeclMap[sFieldName])){
				return this._pFieldDeclMap[sFieldName];
			}
			else {
				return null;
			}
		}

		getSubVarDecls(): IAFXVariableDeclInstruction[] {
			if(!this.canHaveSubDecls()){
				return null;
			}

			if(isNull(this._pSubDeclList)){
				this.generateSubDeclList();
			}
			return this._pSubDeclList;
		}

		_getFullName(): string {
			if(!this.isFromVariableDecl()){
				return "Not from variable decl";
			}

			var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

			if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
				return (<IAFXVariableDeclInstruction>this.getParent())._getFullName();
			}
			else{
				return (<IAFXVariableTypeInstruction>this.getParent())._getFullName();
			}
		}

        _getVarDeclName(): string {
        	if(!this.isFromVariableDecl()){
        		return "";
        	}

        	var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

			if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
				return (<IAFXVariableDeclInstruction>this.getParent()).getName();
			}
			else{
				return (<IAFXVariableTypeInstruction>this.getParent())._getVarDeclName();
			}
        }

        _getTypeDeclName(): string {
        	if(!this.isFromVariableDecl()){
        		return "";
        	}

        	var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

			if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
				return (<IAFXTypeDeclInstruction>this.getParent()).getName();
			}
			else{
				return (<IAFXVariableTypeInstruction>this.getParent())._getTypeDeclName();
			}
        }

        _getParentVarDecl(): IAFXVariableDeclInstruction {
        	if(!this.isFromVariableDecl()){
        		return null;
        	}

        	var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

        	if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
        		return <IAFXVariableDeclInstruction>this.getParent();
        	}
        	else {
        		return (<IAFXVariableTypeInstruction>this.getParent())._getParentVarDecl();
        	}
        }

        _getParentContainer(): IAFXVariableDeclInstruction {
        	if(!this.isFromVariableDecl() || !this._isTypeOfField()){
        		return null;
        	}

        	var pContainerType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>this._getParentVarDecl().getParent();
        	if(!pContainerType.isFromVariableDecl()){
        		return null;
        	}

        	return pContainerType._getParentVarDecl();
        }

        _getMainVariable(): IAFXVariableDeclInstruction{
        	if(!this.isFromVariableDecl()){
        		return null;
        	}

        	if(this._isTypeOfField()){
        		return (<IAFXVariableTypeInstruction>this.getParent().getParent())._getMainVariable();
        	}
        	else {
        		return (<IAFXVariableDeclInstruction>this._getParentVarDecl());
        	}
        }

        _getMainPointer(): IAFXVariableDeclInstruction{
        	if(isNull(this._pMainPointIndex)){
        		if(isNull(this.getPointer())){
        			this._pMainPointIndex = this._getParentVarDecl()
        		}
        		else{
        			this._pMainPointIndex = this._getUpPointer().getType()._getMainPointer();
        		}
        	}

        	return this._pMainPointIndex;
        }

        _getUpPointer(): IAFXVariableDeclInstruction {
        	return this._pUpPointIndex;
        }

        _getDownPointer(): IAFXVariableDeclInstruction {
        	return this._pDownPointIndex;
        }

        _getAttrOffset(): IAFXVariableDeclInstruction {
            return this._pAttrOffset;
        }

//-----------------------------------------------------------------//
//----------------------------SYSTEM-------------------------------//
//-----------------------------------------------------------------//		

		wrap(): IAFXVariableTypeInstruction {
			var pCloneType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			pCloneType.pushType(this);

			return pCloneType;
		}

		clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXVariableTypeInstruction {
			if(isDef(pRelationMap[this._getInstructionID()])){
    			return <IAFXVariableTypeInstruction>pRelationMap[this._getInstructionID()];
    		}

    		if(this._pParentInstruction === null ||
    		   !isDef(pRelationMap[this._pParentInstruction._getInstructionID()]) ||
    		   pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction) {
//pRelationMap[this._getInstructionID()] = this;
    			return this;
    		}

			var pClone: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>super.clone(pRelationMap);

			pClone.pushType(this._pSubType.clone(pRelationMap));
			if(!isNull(this._pUsageList)){
				for(var i:  number  = 0; i < this._pUsageList.length; i++){
					pClone.addUsage(this._pUsageList[i]);
				}
			}

			pClone._canWrite(this._isWritable);
			pClone._canRead(this._isReadable);
			pClone._setCloneHash(this._sHash, this._sStrongHash);
			pClone.setPadding(this.getPadding());

			if(this._isArray){
				this._setCloneArrayIndex(this._pArrayElementType.clone(pRelationMap),
										 this._pArrayIndexExpr.clone(pRelationMap),
										 this._iLength);
			}

			if(this._isPointer){
				var pClonePointerList: IAFXVariableDeclInstruction[] = null;
				if(!isNull(this._pPointerList)){
					pClonePointerList = new Array(this._pPointerList.length);
					var pDownPointer: IAFXVariableDeclInstruction = pClone._getParentVarDecl();

					for(var i:  number  = 0; i < this._pPointerList.length; i++){
						pClonePointerList[i] = this._pPointerList[i].clone(pRelationMap);

						if(i > 0) {
							(pClonePointerList[i - 1].getType())._setUpDownPointers(pClonePointerList[i], pDownPointer);
							pDownPointer = pClonePointerList[i - 1];
						}
						else{
							pClonePointerList[0].getType()._setUpDownPointers(null, pDownPointer);
						}
					}

					pClonePointerList[pClonePointerList.length - 1].getType()._setUpDownPointers(null, pDownPointer);
				}

				this._setClonePointeIndexes(this.getPointDim(), pClonePointerList);
			}

			if(!isNull(this._pFieldDeclMap)){
				var sFieldName: string = "";
				var pCloneFieldMap: IAFXVariableDeclMap= <IAFXVariableDeclMap>{};

				for(sFieldName in this._pFieldDeclMap){
					pCloneFieldMap[sFieldName] = this._pFieldDeclMap[sFieldName].clone(pRelationMap);
				}

				this._setCloneFields(pCloneFieldMap);
			}

			return pClone;
		}

		blend(pType: IAFXVariableTypeInstruction, eMode: EAFXBlendMode): IAFXVariableTypeInstruction {
			if(this === pType){
				return this;
			}

			if(eMode === EAFXBlendMode.k_Global){
				return null;
			}

			if (this.isComplex() !== pType.isComplex() ||
				(this.isNotBaseArray() !== pType.isNotBaseArray()) ||
				(this.isPointer() !== pType.isPointer())) {
				return null;
			}

			if (this.isNotBaseArray() || this.getLength() ===  0xffffff  ||
				this.getLength() !== pType.getLength()){
				return null;
			}

			var pBlendBaseType: IAFXTypeInstruction = this.getBaseType().blend(pType.getBaseType(), eMode);
			if(isNull(pBlendBaseType)){
				return null;
			}

			var pBlendType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			pBlendType.pushType(pBlendBaseType);

			if(this.isNotBaseArray()){
				var iLength:  number  = this.getLength();
				var pLengthExpr: IntInstruction = new IntInstruction();
				pLengthExpr.setValue(iLength);
				pBlendType.addArrayIndex(pLengthExpr);
			}

			return pBlendType;

		}

		_setCloneHash(sHash: string, sStrongHash: string): void {
			this._sHash = sHash;
			this._sStrongHash = sStrongHash;
		}

        _setCloneArrayIndex(pElementType: IAFXVariableTypeInstruction,
                            pIndexExpr: IAFXExprInstruction, iLength:  number ): void {
        	this._isArray = true;
        	this._pArrayElementType = pElementType;
        	this._pArrayIndexExpr = pIndexExpr;
        	this._iLength = iLength;
        }

        _setClonePointeIndexes(nDim:  number , pPointerList: IAFXVariableDeclInstruction[]): void {
        	this._isPointer = true;
        	this._nPointDim = nDim;
        	this._pPointerList = pPointerList;
        	if(!isNull(this._pPointerList)){
        		this._pUpPointIndex = this._pPointerList[0];
        	}
        }

        _setCloneFields(pFieldMap: IAFXVariableDeclMap): void {
        	this._pFieldDeclMap = pFieldMap;
        }

        /**@inline*/  _setUpDownPointers(pUpPointIndex: IAFXVariableDeclInstruction,
        						  pDownPointIndex: IAFXVariableDeclInstruction ): void {
			this._pUpPointIndex = pUpPointIndex;
			this._pDownPointIndex = pDownPointIndex;
		}

		private calcHash(): void {
			var sHash: string = this.getSubType().getHash();

			if(this._isArray){
				sHash += "[";

				var iLength:  number  = this.getLength();

				if(iLength ===  0xffffff ){
					sHash += "undef"
				}
				else{
					sHash += iLength.toString();
				}

				sHash += "]";
			}

			this._sHash = sHash;
		}

		private calcStrongHash(): void {
			var sStrongHash: string = this.getSubType().getStrongHash();

			if(this._isArray){
				sStrongHash += "[";

				var iLength:  number  = this.getLength();

				if(iLength ===  0xffffff ){
					sStrongHash += "undef"
				}
				else{
					sStrongHash += iLength.toString();
				}

				sStrongHash += "]";
			}
			if(this.isPointer()){
				for(var i:  number  = 0; i < this.getPointDim(); i++){
					sStrongHash = "@" + sStrongHash;
				}
			}


			this._sStrongHash = sStrongHash;
		}

		private generateSubDeclList(): void {
			if(!this.canHaveSubDecls()){
				return;
			}

			var pDeclList: IAFXVariableDeclInstruction[] = [];
			var i:  number  = 0;

			if(!isNull(this._pAttrOffset)){
				pDeclList.push(this._pAttrOffset);
			}

			if(this.isPointer()){

				if(isNull(this._getUpPointer())){
					this.initializePointers();
				}

				for(i = 0; i < this._pPointerList.length; i++){
					pDeclList.push(this._pPointerList[i]);
				}
			}

			if(this.isComplex()){
				var pFieldNameList: string[] = this.getFieldNameList();

				for(i = 0; i < pFieldNameList.length; i++){
					var pField: IAFXVariableDeclInstruction = this.getField(pFieldNameList[i]);
					var pFieldSubDeclList: IAFXVariableDeclInstruction[] = pField.getSubVarDecls();

					if(!isNull(pFieldSubDeclList)){
						for(var j:  number  = 0; j < pFieldSubDeclList.length; j++){
							pDeclList.push(pFieldSubDeclList[j]);
						}
					}
				}
			}

			this._pSubDeclList = pDeclList;
		}

		private  /**@inline*/  canHaveSubDecls(): bool {
			return this.isComplex() || this.isPointer() || !isNull(this._pAttrOffset);
		}
	}

	export class SystemTypeInstruction extends Instruction implements IAFXTypeInstruction {
		private _sName: string = "";
		private _sRealName: string = "";
		private _pElementType: IAFXTypeInstruction = null;
		private _iLength:  number  = 1;
		private _iSize:  number  = null;
		private _pFieldDeclMap: IAFXVariableDeclMap = null;
		private _isArray: bool = false;
		private _isWritable: bool = true;
		private _isReadable: bool = true;
		private _pFieldNameList: string[] = null;
		private _pWrapVariableType: IAFXVariableTypeInstruction = null;
		private _isBuiltIn: bool = true;
		private _sDeclString: string = "";

		constructor() {
			super();
			this._eInstructionType = EAFXInstructionTypes.k_SystemTypeInstruction;
			this._pWrapVariableType = new VariableTypeInstruction();
			this._pWrapVariableType.pushType(this);
		}

		_toDeclString(): string {
			return this._sDeclString;
		}

		toFinalCode(): string {
			return this._sRealName;
		}

		isBuiltIn(): bool {
			return this._isBuiltIn;
		}

        setBuiltIn(isBuiltIn: bool): void {
        	this._isBuiltIn = isBuiltIn;
        }

        setDeclString(sDecl: string): void {
        	this._sDeclString = sDecl;
        }

//-----------------------------------------------------------------//
//----------------------------SIMPLE TESTS-------------------------//
//-----------------------------------------------------------------//

		/**@inline*/  isBase(): bool {
			return true;
		}

		/**@inline*/  isArray(): bool {
			return this._isArray;
		}

		/**@inline*/  isNotBaseArray(): bool {
			return false;
		}

		/**@inline*/  isComplex(): bool {
			return false;
		}

		/**@inline*/  isEqual(pType: IAFXTypeInstruction): bool {
			return this.getHash() === pType.getHash();
		}

		/**@inline*/  isStrongEqual(pType: IAFXTypeInstruction): bool{
			return this.getStrongHash() === pType.getStrongHash();
		}

		/**@inline*/  isConst(): bool {
			return false;
		}

		isSampler(): bool{
			return this.getName() === "sampler" ||
				   this.getName() === "sampler2D" ||
				   this.getName() === "samplerCUBE";
		}

		isSamplerCube(): bool {
			return this.getName() === "samplerCUBE";
		}

        isSampler2D(): bool {
        	return this.getName() === "sampler" ||
				   this.getName() === "sampler2D";
        }


		/**@inline*/  isWritable(): bool {
			return this._isWritable;
		}

		/**@inline*/  isReadable(): bool {
			return this._isReadable;
		}

		_containArray(): bool {
			return false;
		}

        _containSampler(): bool {
        	return false;
        }

        _containPointer(): bool {
        	return false;
        }

        _containComplexType(): bool {
        	return false;
        }

//-----------------------------------------------------------------//
//----------------------------SET BASE TYPE INFO-------------------//
//-----------------------------------------------------------------//

		/**@inline*/  setName(sName: string): void {
			this._sName = sName;
		}

		/**@inline*/  setRealName(sRealName: string): void {
			this._sRealName = sRealName;
		}

		/**@inline*/  setSize(iSize:  number ): void {
			this._iSize = iSize;
		}

		/**@inline*/  _canWrite(isWritable: bool): void {
			this._isWritable = isWritable;
		}

		/**@inline*/  _canRead(isReadable: bool): void {
			this._isReadable = isReadable;
		}

//-----------------------------------------------------------------//
//---------------------------INIT API------------------------------//
//-----------------------------------------------------------------//

		addIndex(pType: IAFXTypeInstruction, iLength:  number ): void {
			this._pElementType = pType;
			this._iLength = iLength;
			this._iSize = iLength * pType.getSize();
			this._isArray = true;
		}

		addField(sFieldName: string, pType: IAFXTypeInstruction, isWrite?: bool = true,
				 sRealFieldName?: string = sFieldName): void {

			var pField: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pFieldType: VariableTypeInstruction = new VariableTypeInstruction();
			var pFieldId: IAFXIdInstruction = new IdInstruction();

			pFieldType.pushType(pType);
			pFieldType._canWrite(isWrite);

			pFieldId.setName(sFieldName);
			pFieldId.setRealName(sRealFieldName);

			pField.push(pFieldType, true);
			pField.push(pFieldId, true);

			if(isNull(this._pFieldDeclMap)){
				this._pFieldDeclMap = <IAFXVariableDeclMap>{};
			}

			this._pFieldDeclMap[sFieldName] = pField;

			if(isNull(this._pFieldNameList)){
				this._pFieldNameList = [];
			}

			this._pFieldNameList.push(sFieldName);
		}

//-----------------------------------------------------------------//
//----------------------------GET TYPE INFO------------------------//
//-----------------------------------------------------------------//

		/**@inline*/  getName(): string {
			return this._sName;
		}

		/**@inline*/  getRealName(): string {
			return this._sRealName;
		}

		/**@inline*/  getHash(): string {
			return this._sRealName;
		}

		/**@inline*/  getStrongHash(): string {
			return this._sName;
		}

		/**@inline*/  getSize():  number  {
			return this._iSize;
		}

		/**@inline*/  getBaseType(): IAFXTypeInstruction {
			return this;
		}

		/**@inline*/  getVariableType(): IAFXVariableTypeInstruction {
			return this._pWrapVariableType;
		}

		/**@inline*/  getArrayElementType(): IAFXTypeInstruction {
			return this._pElementType;
		}

		getTypeDecl(): IAFXTypeDeclInstruction {
			if(this.isBuiltIn()){
				return null;
			}

			return <IAFXTypeDeclInstruction>this.getParent();
		}


		/**@inline*/  getLength():  number  {
			return this._iLength;
		}

		/**@inline*/  hasField(sFieldName: string): bool {
			return isDef(this._pFieldDeclMap[sFieldName]);
		}

		hasFieldWithSematic(sSemantic: string): bool {
			return false;
		}

		hasAllUniqueSemantics(): bool {
			return false;
		}

		hasFieldWithoutSemantic(): bool {
			return false;
		}

		/**@inline*/  getField(sFieldName: string): IAFXVariableDeclInstruction {
			return isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName] : null;
		}

		/**@inline*/  getFieldBySemantic(sSemantic: string): IAFXVariableDeclInstruction {
			return null;
		}

		/**@inline*/  getFieldType(sFieldName: string): IAFXVariableTypeInstruction {
			return isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName].getType() : null;
		}

		/**@inline*/  getFieldNameList(): string[] {
			return this._pFieldNameList;
		}

//-----------------------------------------------------------------//
//----------------------------SYSTEM-------------------------------//
//-----------------------------------------------------------------//

		/**@inline*/  clone(pRelationMap?: IAFXInstructionMap): SystemTypeInstruction {
			return this;
		}

		/**@inline*/  blend(pType: IAFXTypeInstruction, eMode: EAFXBlendMode): IAFXTypeInstruction {
			if(this.isStrongEqual(pType)){
				return this;
			}

			return null;
		}
	}

	export class ComplexTypeInstruction extends Instruction implements IAFXTypeInstruction {
		private _sName: string = "";
		private _sRealName: string = "";

		private _sHash: string = "";
		private _sStrongHash: string = "";

		private _iSize:  number  = 0;

		private _pFieldDeclMap: IAFXVariableDeclMap = null;
		private _pFieldDeclList: IAFXVariableDeclInstruction[] = null;
		private _pFieldNameList: string[] = null;

		private _pFieldDeclBySemanticMap: IAFXVariableDeclMap = null;
		private _hasAllUniqueSemantics: bool = true;
		private _hasFieldWithoutSemantic: bool = false;

		private _isContainArray: bool = false;
		private _isContainSampler: bool = false;
		private _isContainPointer: bool = false;
		private _isContainComplexType: bool = false;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_ComplexTypeInstruction;
		}

		_toDeclString(): string {
			var sCode: string = "struct " + this._sRealName + "{";

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
				sCode += "\t" + this._pFieldDeclList[i].toFinalCode() + ";\n";
			}

			sCode += "}";

			return sCode;
		}

		toFinalCode(): string {
			return this._sRealName;
		}

		isBuiltIn(): bool {
			return false;
		}

        setBuiltIn(isBuiltIn: bool): void {
        }

//-----------------------------------------------------------------//
//----------------------------SIMPLE TESTS-------------------------//
//-----------------------------------------------------------------//

		/**@inline*/  isBase(): bool {
			return false;
		}

		/**@inline*/  isArray(): bool {
			return false;
		}

		/**@inline*/  isNotBaseArray(): bool {
			return false;
		}

		/**@inline*/  isComplex(): bool {
			return true;
		}

		/**@inline*/  isEqual(pType: IAFXTypeInstruction): bool {
			return this.getHash() === pType.getHash();
		}

		/**@inline*/  isStrongEqual(pType: IAFXTypeInstruction): bool {
			return this.getStrongHash() === pType.getStrongHash();
		}

		/**@inline*/  isConst(): bool {
			return false;
		}

		isSampler(): bool{
			return false;
		}

		isSamplerCube(): bool {
			return false;
		}

		isSampler2D(): bool {
			return false;
		}

		/**@inline*/  isWritable(): bool {
			return true;
		}

		/**@inline*/  isReadable(): bool {
			return true;
		}

		/**@inline*/  _containArray(): bool {
			return this._isContainArray;
		}

		/**@inline*/  _containSampler(): bool {
			return this._isContainSampler;
		}

		/**@inline*/  _containPointer(): bool {
			return this._isContainPointer;
		}

		/**@inline*/  _containComplexType(): bool {
			return this._isContainComplexType;
		}

//-----------------------------------------------------------------//
//----------------------------SET BASE TYPE INFO-------------------//
//-----------------------------------------------------------------//

		/**@inline*/  setName(sName: string): void {
			this._sName = sName;
			this._sRealName = sName;
		}

		/**@inline*/  setRealName(sRealName: string): void {
			this._sRealName = sRealName;
		}

		/**@inline*/  setSize(iSize:  number ): void {
			this._iSize = iSize;
		}

		/**@inline*/  _canWrite(isWritable: bool): void {
		}

		/**@inline*/  _canRead(isWritable: bool): void {
		}

//-----------------------------------------------------------------//
//----------------------------INIT API-----------------------------//
//-----------------------------------------------------------------//

		addField(pVariable: IAFXVariableDeclInstruction): void {
			if(isNull(this._pFieldDeclMap)){
				this._pFieldDeclMap = <IAFXVariableDeclMap>{};
				this._pFieldNameList = [];
			}

			if(isNull(this._pFieldDeclList)){
				this._pFieldDeclList = [];
			}

			var sVarName: string = pVariable.getName();
			this._pFieldDeclMap[sVarName] = pVariable;

			if(this._iSize !==  0xffffff ){
				var iSize:  number  = pVariable.getType().getSize();
				if(iSize !==  0xffffff ){
					this._iSize += iSize;
				}
				else{
					this._iSize =  0xffffff ;
				}
			}

			this._pFieldNameList.push(sVarName);

			if(this._pFieldDeclList.length < this._pFieldNameList.length){
				this._pFieldDeclList.push(pVariable);
			}

			var pType: IAFXVariableTypeInstruction = pVariable.getType();
//pType._markAsField();

			if(pType.isNotBaseArray() || pType._containArray()){
				this._isContainArray = true;
			}

			if(Effect.isSamplerType(pType) || pType._containSampler()){
				this._isContainSampler = true;
			}

			if(pType.isPointer() || pType._containPointer()){
				this._isContainPointer = true;
			}

			if(pType.isComplex()){
				this._isContainComplexType = true;
			}
		}

		addFields(pFieldCollector: IAFXInstruction, isSetParent?: bool = true): void {
			this._pFieldDeclList = <IAFXVariableDeclInstruction[]>(pFieldCollector.getInstructions());

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
		    	this.addField(this._pFieldDeclList[i]);
		    	this._pFieldDeclList[i].setParent(this);
		    }

		    this.calculatePaddings();
		}

//-----------------------------------------------------------------//
//----------------------------GET TYPE INFO------------------------//
//-----------------------------------------------------------------//

		/**@inline*/  getName(): string {
			return this._sName;
		}

		/**@inline*/  getRealName(): string {
			return this._sRealName;
		}

		getHash(): string {
			if(this._sHash === ""){
				this.calcHash();
			}

			return this._sHash;
		}

		getStrongHash(): string {
			if(this._sStrongHash === ""){
				this.calcStrongHash();
			}

			return this._sStrongHash;
		}

		/**@inline*/  hasField(sFieldName: string): bool {
			return isDef(this._pFieldDeclMap[sFieldName]);
		}

		hasFieldWithSematic(sSemantic: string): bool {
			if(isNull(this._pFieldDeclBySemanticMap)) {
				this.analyzeSemantics();
			}

			return isDef(this._pFieldDeclBySemanticMap[sSemantic]);
		}

		hasAllUniqueSemantics(): bool {
			if(isNull(this._pFieldDeclBySemanticMap)) {
				this.analyzeSemantics();
			}
			return this._hasAllUniqueSemantics;
		}

		hasFieldWithoutSemantic(): bool {
			if(isNull(this._pFieldDeclBySemanticMap)) {
				this.analyzeSemantics();
			}
			return this._hasFieldWithoutSemantic;
		}

		/**@inline*/  getField(sFieldName: string): IAFXVariableDeclInstruction {
			if(!this.hasField(sFieldName)){
				return null;
			}

			return this._pFieldDeclMap[sFieldName];
		}

		getFieldBySemantic(sSemantic: string): IAFXVariableDeclInstruction {
			if(!this.hasFieldWithSematic(sSemantic)){
				return null;
			}

			return this._pFieldDeclBySemanticMap[sSemantic];
		}

		/**@inline*/  getFieldType(sFieldName: string): IAFXVariableTypeInstruction {
			return isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName].getType() : null;
		}

		/**@inline*/  getFieldNameList(): string[] {
			return this._pFieldNameList;
		}

		/**@inline*/  getSize():  number  {
			if(this._iSize ===  0xffffff ){
				this._iSize = this._calcSize();
			}
			return this._iSize;
		}

		/**@inline*/  getBaseType(): IAFXTypeInstruction {
			return this;
		}

		/**@inline*/  getArrayElementType(): IAFXTypeInstruction {
			return null;
		}

		getTypeDecl(): IAFXTypeDeclInstruction {
			return <IAFXTypeDeclInstruction>this.getParent();
		}

		/**@inline*/  getLength():  number  {
			return 0;
		}

		_getFieldDeclList(): IAFXVariableDeclInstruction[] {
			return this._pFieldDeclList;
		}

//-----------------------------------------------------------------//
//----------------------------SYSTEM-------------------------------//
//-----------------------------------------------------------------//

		/**@inline*/  clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): ComplexTypeInstruction {
			if(this._pParentInstruction === null ||
    		   !isDef(pRelationMap[this._pParentInstruction._getInstructionID()]) ||
    		   pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction){
//pRelationMap[this._getInstructionID()] = this;
    			return this;
    		}

    		var pClone: ComplexTypeInstruction = <ComplexTypeInstruction>super.clone(pRelationMap);

    		pClone._setCloneName(this._sName, this._sRealName);
    		pClone._setCloneHash(this._sHash, this._sStrongHash);
    		pClone._setCloneContain(this._isContainArray, this._isContainSampler);

    		var pFieldDeclList: IAFXVariableDeclInstruction[] = new Array(this._pFieldDeclList.length);
    		var pFieldNameList: string[] = new Array(this._pFieldNameList.length);
    		var pFieldDeclMap: IAFXVariableDeclMap = <IAFXVariableDeclMap>{};

    		for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
    			var pCloneVar: IAFXVariableDeclInstruction = this._pFieldDeclList[i].clone(pRelationMap);
    			var sVarName: string = pCloneVar.getName();

    			pFieldDeclList[i] = pCloneVar;
    			pFieldNameList[i] = sVarName;
    			pFieldDeclMap[sVarName] = pCloneVar;
    		}

    		pClone._setCloneFields(pFieldDeclList, pFieldNameList,
				   				   pFieldDeclMap);
    		pClone.setSize(this._iSize);

			return pClone;
		}

		blend(pType: IAFXTypeInstruction, eMode: EAFXBlendMode): IAFXTypeInstruction {
			if(pType === this){
				return this;
			}

			if(eMode === EAFXBlendMode.k_TypeDecl){
				return null;
			}

			if(eMode === EAFXBlendMode.k_Uniform || eMode === EAFXBlendMode.k_Attribute){
				if(this.hasFieldWithoutSemantic() || pType.hasFieldWithoutSemantic()){
					return null;
				}
			}

			var pFieldList: IAFXVariableDeclInstruction[] = this._pFieldDeclList;
			var pBlendType: ComplexTypeInstruction = new ComplexTypeInstruction();
			var pRelationMap: IAFXInstructionMap = <IAFXInstructionMap>{};

			if(isNull(pFieldList)){
				{ logger.setSourceLocation( "fx/TypeInstruction.ts" , 1899 ); logger.log(this, pType); } ;
			}

			for(var i:  number  = 0; i < pFieldList.length; i++){
				var pField: IAFXVariableDeclInstruction = pFieldList[i];
				var pBlendField: IAFXVariableDeclInstruction = null;
				var sFieldName: string = pField.getName();
				var sFieldSemantic: string = pField.getSemantic();

				if(eMode === EAFXBlendMode.k_Shared){
					if(pType.hasField(sFieldName)){
						pBlendField = pField.blend(pType.getField(sFieldName), eMode);
					}
					else {
						pBlendField = pField.clone(pRelationMap);
					}
				}
				else if(eMode === EAFXBlendMode.k_Attribute ||
						eMode === EAFXBlendMode.k_Uniform ||
						eMode === EAFXBlendMode.k_VertexOut) {

					if(pType.hasFieldWithSematic(sFieldSemantic)){
						pBlendField = pField.blend(pType.getFieldBySemantic(sFieldSemantic), eMode);
					}
					else {
						pBlendField = pField.clone(pRelationMap);
					}

					if(!isNull(pBlendField)){
						pBlendField.getNameId().setName(sFieldSemantic);
						pBlendField.getNameId().setRealName(sFieldSemantic);
					}
				}

				if(isNull(pBlendField)){
					return null;
				}

				pBlendType.addField(pBlendField);
			}

			pFieldList = (<ComplexTypeInstruction>pType)._getFieldDeclList();

			for(var i:  number  = 0; i < pFieldList.length; i++){
				var pField: IAFXVariableDeclInstruction = pFieldList[i];
				var pBlendField: IAFXVariableDeclInstruction = null;
				var sFieldName: string = pField.getName();
				var sFieldSemantic: string = pField.getSemantic();

				if(eMode === EAFXBlendMode.k_Shared){
					if(!this.hasField(sFieldName)){
						pBlendField = pField.clone(pRelationMap);
					}
				}
				else if(eMode === EAFXBlendMode.k_Attribute ||
						eMode === EAFXBlendMode.k_Uniform ||
						eMode === EAFXBlendMode.k_VertexOut) {

					if(!this.hasFieldWithSematic(sFieldSemantic)){
						pBlendField = pField.clone(pRelationMap);
						pBlendField.getNameId().setName(sFieldSemantic);
						pBlendField.getNameId().setRealName(sFieldSemantic);
					}
				}

				if(!isNull(pBlendField)){
					pBlendType.addField(pBlendField);
				}
			}

			pBlendType.setName(this.getName());
			pBlendType.setRealName(this.getRealName());

			return pBlendType;
		}

		_setCloneName(sName: string, sRealName: string): void {
			this._sName = sName;
			this._sRealName = sRealName;
		}

		_setCloneHash(sHash: string, sStrongHash: string): void {
			this._sHash = sHash;
			this._sStrongHash = sStrongHash;
		}

		_setCloneContain(isContainArray: bool, isContainSampler: bool): void{
			this._isContainArray = isContainArray;
			this._isContainSampler = isContainSampler;
		}

		_setCloneFields(pFieldDeclList: IAFXVariableDeclInstruction[], pFieldNameList: string[],
				   		pFieldDeclMap: IAFXVariableDeclMap): void{
			this._pFieldDeclList = pFieldDeclList;
			this._pFieldNameList = pFieldNameList;
			this._pFieldDeclMap = pFieldDeclMap;
		}

		_calcSize():  number  {
			var iSize:  number  = 0;

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
				var iFieldSize:  number  = this._pFieldDeclList[i].getType().getSize();

				if(iFieldSize ===  0xffffff ){
					iSize =  0xffffff ;
					break;
				}
				else{
					iSize += iFieldSize;
				}
			}

			return iSize;
		}

		private calcHash(): void {
			var sHash: string = "{";

			for(var i: number  = 0; i < this._pFieldDeclList.length; i++){
				sHash += this._pFieldDeclList[i].getType().getHash() + ";";
			}

			sHash += "}";

			this._sHash = sHash;
		}

		private calcStrongHash(): void {
			var sStrongHash: string = "{";

			for(var i: number  = 0; i < this._pFieldDeclList.length; i++){
				sStrongHash += this._pFieldDeclList[i].getType().getStrongHash() + ";";
			}

			sStrongHash += "}";

			this._sStrongHash = sStrongHash;
		}

		private analyzeSemantics(): void {
			this._pFieldDeclBySemanticMap = <IAFXVariableDeclMap>{};

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
				var pVar: IAFXVariableDeclInstruction = this._pFieldDeclList[i];
				var sSemantic: string = pVar.getSemantic();

				if(sSemantic === ""){
					this._hasFieldWithoutSemantic = true;
				}

				if(isDef(this._pFieldDeclBySemanticMap[sSemantic])){
					this._hasAllUniqueSemantics = false;
				}

				this._pFieldDeclBySemanticMap[sSemantic] = pVar;

				this._hasFieldWithoutSemantic = this._hasFieldWithoutSemantic || pVar.getType().hasFieldWithoutSemantic();
				if(this._hasAllUniqueSemantics && pVar.getType().isComplex()){
					this._hasAllUniqueSemantics = pVar.getType().hasAllUniqueSemantics();
				}
			}

		}

		private calculatePaddings(): void {
			var iPadding:  number  = 0;

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
				var pVarType: IAFXVariableTypeInstruction = this._pFieldDeclList[i].getType();
				var iVarSize:  number  = pVarType.getSize();

				if(iVarSize ===  0xffffff ){
					this.setError( 2272 , {typeName: this.getName()});
					return;
				}

				pVarType.setPadding(iPadding);
				iPadding += iVarSize;
			}
		}
	}
}



























module akra.fx {
	export class ExprInstruction extends TypedInstruction implements IAFXExprInstruction {
		protected _pLastEvalResult: any = null;

/**
		 * Respresent all kind of instruction
		 */

		constructor(){
			super();
			this._eInstructionType = EAFXInstructionTypes.k_ExprInstruction;
		}

		evaluate(): bool {
			return false;
		}

		simplify(): bool {
			return false;
		}

		getEvalValue(): any {
			return this._pLastEvalResult;
		}

		isConst(): bool {
			return false;
		}

		getType(): IAFXVariableTypeInstruction{
			return <IAFXVariableTypeInstruction>super.getType();
		}

		clone(pRelationMap?:IAFXInstructionMap): IAFXExprInstruction {
			return <IAFXExprInstruction>super.clone(pRelationMap);
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pInstructionList: IAFXAnalyzedInstruction[] = <IAFXAnalyzedInstruction[]>this.getInstructions();

			if(isNull(pInstructionList)){
				return;
			}

			for(var i:  number  = 0; i < this._nInstructions; i++){
				pInstructionList[i].addUsedData(pUsedDataCollector, eUsedMode);
			}
		}
	}

	export class IntInstruction extends ExprInstruction implements IAFXLiteralInstruction {
		private _iValue:  number ;
/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._iValue = 0;
			this._pType = Effect.getSystemType("int").getVariableType();
			this._eInstructionType = EAFXInstructionTypes.k_IntInstruction;
		}

		/**@inline*/  setValue(iValue:  number ): void{
			this._iValue = iValue;
		}

		toString(): string {
			return <string><any>this._iValue;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this._iValue.toString();
			return sCode;
		}

		evaluate(): bool {
			this._pLastEvalResult = this._iValue;
			return true;
		}

		/**@inline*/  isConst(): bool {
			return true;
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction {
			var pClonedInstruction: IAFXLiteralInstruction = <IAFXLiteralInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setValue(this._iValue);
			return pClonedInstruction;
		}
	}

	export class FloatInstruction extends ExprInstruction implements IAFXLiteralInstruction {
		private _fValue:  number ;
/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._fValue = 0.0;
			this._pType = Effect.getSystemType("float").getVariableType();
			this._eInstructionType = EAFXInstructionTypes.k_FloatInstruction;
		}

		/**@inline*/  setValue(fValue:  number ): void{
			this._fValue = fValue;
		}

		toString(): string {
			return <string><any>this._fValue;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this._fValue.toString();
			if(this._fValue % 1 === 0){
				sCode += ".";
			}
			return sCode;
		}

		evaluate(): bool {
			this._pLastEvalResult = this._fValue;
			return true;
		}

		/**@inline*/  isConst(): bool {
			return true;
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction {
			var pClonedInstruction: IAFXLiteralInstruction = <IAFXLiteralInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setValue(this._fValue);
			return pClonedInstruction;
		}
	}

	export class BoolInstruction extends ExprInstruction implements IAFXLiteralInstruction {
		private _bValue: bool;
		static private _pBoolType: IAFXVariableTypeInstruction = null;
/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._bValue = true;
			this._pType = Effect.getSystemType("bool").getVariableType();
			this._eInstructionType = EAFXInstructionTypes.k_BoolInstruction;
		}

		/**@inline*/  setValue(bValue: bool): void{
			this._bValue = bValue;
		}

		toString(): string {
			return <string><any>this._bValue;
		}

		toFinalCode(): string {
			if(this._bValue){
				return "true";
			}
			else {
				return "false";
			}
		}

		evaluate(): bool {
			this._pLastEvalResult = this._bValue;
			return true;
		}

		/**@inline*/  isConst(): bool {
			return true;
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction {
			var pClonedInstruction: IAFXLiteralInstruction = <IAFXLiteralInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setValue(this._bValue);
			return pClonedInstruction;
		}
	}

	export class StringInstruction extends ExprInstruction implements IAFXLiteralInstruction {
		private _sValue: string;
		static private _pStringType: IAFXVariableTypeInstruction = null;

/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._sValue = "";
			this._pType = Effect.getSystemType("string").getVariableType();
			this._eInstructionType = EAFXInstructionTypes.k_StringInstruction;
		}

		/**@inline*/  setValue(sValue: string): void{
			this._sValue = sValue;
		}

		toString(): string {
			return this._sValue;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this._sValue;
			return sCode;
		}

		evaluate(): bool {
			this._pLastEvalResult = this._sValue;
			return true;
		}

		/**@inline*/  isConst(): bool {
			return true;
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction {
			var pClonedInstruction: IAFXLiteralInstruction = <IAFXLiteralInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setValue(this._sValue);
			return pClonedInstruction;
		}
	}

	export class IdExprInstruction extends ExprInstruction implements IAFXIdExprInstruction {
		private _pType: IAFXVariableTypeInstruction = null;
		private _bToFinalCode: bool = true;
		private _isInPassUnifoms: bool = false;
		private _isInPassForeigns: bool = false;

		/**@inline*/  isVisible(): bool {
			return this._pInstructionList[0].isVisible();
		}

		constructor(){
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_IdExprInstruction;
		}

		getType(): IAFXVariableTypeInstruction {
			if(!isNull(this._pType)){
				return this._pType;
			}
			else{
				var pVar: IdInstruction = <IdInstruction>this._pInstructionList[0];
				this._pType = (<IAFXVariableDeclInstruction>pVar.getParent()).getType();
				return this._pType;
			}
		}

		isConst(): bool {
			return this.getType().isConst();
		}

		evaluate(): bool {
			if(this.getType().isForeign()){
				var pVal = this.getType()._getParentVarDecl().getValue();
				if(!isNull(pVal)){
					this._pLastEvalResult = pVal;
					return true;
				}
			}

			return false;
		}

		prepareFor(eUsedMode: EFunctionType): void {
			if(!this.isVisible()){
				this._bToFinalCode = false;
			}

			if(eUsedMode === EFunctionType.k_PassFunction){
				var pVarDecl: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getInstructions()[0].getParent();
				if(!this.getType()._isUnverifiable() && isNull(pVarDecl.getParent())){
					if(pVarDecl.getType().isForeign()){
						this._isInPassForeigns = true;
					}
					else {
						this._isInPassUnifoms = true;
					}
				}
			}
		}

		toFinalCode(): string {
			var sCode: string = "";
			if(this._bToFinalCode){
				if(this._isInPassForeigns || this._isInPassUnifoms){
					var pVarDecl: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getInstructions()[0].getParent();
					if(this._isInPassForeigns){
						sCode += "foreigns[\"" + pVarDecl._getNameIndex() + "\"]";
					}
					else {
						sCode += "uniforms[\"" + pVarDecl._getNameIndex() + "\"]";
					}
				}
				else {
					sCode += this.getInstructions()[0].toFinalCode();
				}
			}
			return sCode;
		}

		clone(pRelationMap?:IAFXInstructionMap): IAFXIdExprInstruction {
			return <IAFXIdExprInstruction>super.clone(pRelationMap);
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			if(!this.getType().isFromVariableDecl()) {
				return;
			}

			var pInfo: IAFXTypeUseInfoContainer = null;
			pInfo = pUsedDataCollector[this.getType()._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: this.getType(),
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[this.getType()._getInstructionID()] = pInfo;
			}

			if(eUsedMode !== EVarUsedMode.k_Write && eUsedMode !== EVarUsedMode.k_Undefined){
				pInfo.isRead = true;
				pInfo.numRead++;
			}

			if(eUsedMode === EVarUsedMode.k_Write || eUsedMode === EVarUsedMode.k_ReadWrite) {
				pInfo.isWrite = true;
				pInfo.numWrite++;
			}

			pInfo.numUsed++;
		}
	}

/**
 	 * Represent someExpr + / - * % someExpr
 	 * (+|-|*|/|%) Instruction Instruction
 	 */

	export class ArithmeticExprInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_ArithmeticExprInstruction;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			super.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}

		evaluate(): bool {
			var pOperands: IAFXExprInstruction[] = <IAFXExprInstruction[]>this.getInstructions();
			var pValL: any = pOperands[0].evaluate() ? pOperands[0].getEvalValue() : null;
			var pValR: any = pOperands[1].evaluate() ? pOperands[1].getEvalValue() : null;

			if(isNull(pValL) || isNull(pValR)){
				return false;
			}

			try{
				switch(this.getOperator()){
					case "+":
						this._pLastEvalResult = pValL + pValR;
						break;
					case "-":
						this._pLastEvalResult = pValL - pValR;
						break;
					case "*":
						this._pLastEvalResult = pValL * pValR;
						break;
					case "/":
						this._pLastEvalResult = pValL / pValR;
						break;
					case "%":
						this._pLastEvalResult = pValL % pValR;
						break;
				}
				return true;
			}
			catch(e){
				return false;
			}
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();
			sCode += this.getInstructions()[1].toFinalCode();
			return sCode;
		}

		isConst(): bool {
			var pOperands: IAFXExprInstruction[] = <IAFXExprInstruction[]>this.getInstructions();
			return pOperands[0].isConst() && pOperands[1].isConst();
		}
	}
/**
 	 * Represent someExpr = += -= /= *= %= someExpr
 	 * (=|+=|-=|*=|/=|%=) Instruction Instruction
 	 */

	export class AssignmentExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_AssignmentExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();
			sCode += this.getInstructions()[1].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var sOperator: string = this.getOperator();
			var pSubExprLeft: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
			var pSubExprRight: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];

			if(eUsedMode === EVarUsedMode.k_Read || sOperator !== "="){
				pSubExprLeft.addUsedData(pUsedDataCollector, EVarUsedMode.k_ReadWrite);
			}
			else {
				pSubExprLeft.addUsedData(pUsedDataCollector, EVarUsedMode.k_Write);
			}

			pSubExprRight.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}
	}
/**
 	 * Represent someExpr == != < > <= >= someExpr
 	 * (==|!=|<|>|<=|>=) Instruction Instruction
 	 */

	export class RelationalExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_RelationalExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();
			sCode += this.getInstructions()[1].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			super.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}

		isConst(): bool {
			return  (<IAFXExprInstruction>this.getInstructions()[0]).isConst() &&
					(<IAFXExprInstruction>this.getInstructions()[1]).isConst();
		}
	}
/**
 	 * Represent boolExpr && || boolExpr
 	 * (&& | ||) Instruction Instruction
 	 */

	export class LogicalExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_LogicalExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();
			sCode += this.getInstructions()[1].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			super.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}

		isConst(): bool {
			return  (<IAFXExprInstruction>this.getInstructions()[0]).isConst() &&
					(<IAFXExprInstruction>this.getInstructions()[1]).isConst() &&
					(<IAFXExprInstruction>this.getInstructions()[2]).isConst();
		}
	}
/**
	 * Represen boolExpr ? someExpr : someExpr
	 * EMPTY_OPERATOR Instruction Instruction Instruction 
	 */

	export class ConditionalExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null, null, null];
			this._eInstructionType = EAFXInstructionTypes.k_ConditionalExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "?";
			sCode += this.getInstructions()[1].toFinalCode();
			sCode += ":";
			sCode += this.getInstructions()[2].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			super.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}

		isConst(): bool {
			return (<IAFXExprInstruction>this.getInstructions()[0]).isConst() &&
					(<IAFXExprInstruction>this.getInstructions()[1]).isConst();
		}
	}
/**
	 * Represent (type) expr
	 * EMPTY_OPERATOR VariableTypeInstruction Instruction
	 */

	export class CastExprInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_CastExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "(";
			sCode += this.getInstructions()[1].toFinalCode();
			sCode += ")";
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];
			pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);

// pUsedDataCollector[this.getType()._getInstructionID()] = this.getType();
		}

		isConst(): bool {
			return (<IAFXExprInstruction>this.getInstructions()[1]).isConst();
		}
	}

/**
	 * Represent + - ! ++ -- expr
	 * (+|-|!|++|--|) Instruction
	 */

	export class UnaryExprInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_UnaryExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getOperator();
			sCode += this.getInstructions()[0].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			if(this.getOperator() === "++" || this.getOperator() === "--"){
				(<IAFXExprInstruction>this.getInstructions()[0]).addUsedData(pUsedDataCollector, EVarUsedMode.k_ReadWrite);
			}
			else {
				(<IAFXExprInstruction>this.getInstructions()[0]).addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
			}
        }

        isConst(): bool {
        	return (<IAFXExprInstruction>this.getInstructions()[0]).isConst();
        }

        evaluate(): bool {
        	var sOperator: string = this.getOperator();
        	var pExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];

        	if(!pExpr.evaluate()){
        		return;
        	}

        	var pRes: any = null;

        	try {
        		pRes = pExpr.getEvalValue();
        		switch(sOperator){
        			case "+":
        				pRes = +pRes;
        				break;
        			case "-":
        				pRes = -pRes;
        				break;
        			case "!":
        				pRes = !pRes;
        				break;
        			case "++":
        				pRes = ++pRes;
        				break;
        			case "--":
        				pRes = --pRes;
        				break;
        		}
        	}
        	catch(e){
        		return false;
        	}

        	this._pLastEvalResult = pRes;
        	return true;
        }
	}

/**
	 * Represent someExpr[someIndex]
	 * EMPTY_OPERATOR Instruction ExprInstruction
	 */

	export class PostfixIndexInstruction extends ExprInstruction {
		private _pSamplerArrayDecl: IAFXVariableDeclInstruction = null;

		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_PostfixIndexInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

// if((<ExprInstruction>this.getInstructions()[0]).getType().getLength() === 0){
// 	return "";
// }

			if(!isNull(this._pSamplerArrayDecl) && this._pSamplerArrayDecl.isDefinedByZero()){
				sCode += this.getInstructions()[0].toFinalCode();
			}
			else {
				sCode += this.getInstructions()[0].toFinalCode();

				if(!(<IAFXExprInstruction>this.getInstructions()[0]).getType()._isCollapsed()){
					sCode += "[" + this.getInstructions()[1].toFinalCode() + "]";
				}
			}

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
			var pIndex: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];

			pSubExpr.addUsedData(pUsedDataCollector, eUsedMode);
			pIndex.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);

			if(pSubExpr.getType().isFromVariableDecl() && pSubExpr.getType().isSampler()){
				this._pSamplerArrayDecl = pSubExpr.getType()._getParentVarDecl();
			}
        }

        isConst(): bool {
        	return  (<IAFXExprInstruction>this.getInstructions()[0]).isConst() &&
        			(<IAFXExprInstruction>this.getInstructions()[1]).isConst();
        }
	}

/*
	 * Represent someExpr.id
	 * EMPTY_OPERATOR Instruction IdInstruction
	 */

	export class PostfixPointInstruction extends ExprInstruction {
		private _bToFinalFirst: bool = true;
		private _bToFinalSecond: bool = true;

		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_PostfixPointInstruction;
		}

		prepareFor(eUsedMode: EFunctionType){
			if(!this.getInstructions()[0].isVisible()){
				this._bToFinalFirst = false;
			}

			if(!this.getInstructions()[1].isVisible()){
				this._bToFinalSecond = false;
			}

			this.getInstructions()[0].prepareFor(eUsedMode);
			this.getInstructions()[1].prepareFor(eUsedMode);
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this._bToFinalFirst ? this.getInstructions()[0].toFinalCode() : "";
			sCode += this._bToFinalFirst ? "." : "";
			sCode += this._bToFinalSecond ? this.getInstructions()[1].toFinalCode(): "";

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
			var pPoint: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];

			pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Undefined);
			pPoint.addUsedData(pUsedDataCollector, eUsedMode);
        }

        isConst(): bool {
        	return (<IAFXExprInstruction>this.getInstructions()[0]).isConst();
        }
	}

/**
	 * Represent someExpr ++
	 * (-- | ++) Instruction
	 */

	export class PostfixArithmeticInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_PostfixArithmeticInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
			pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_ReadWrite);
		}

		isConst(): bool {
			return (<IAFXExprInstruction>this.getInstructions()[0]).isConst();
		}
	}

/**
	 * Represent @ Expr
	 * @ Instruction
	 */

	export class PrimaryExprInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_PrimaryExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pPointerType: IAFXVariableTypeInstruction = this.getType();
			var pInfo: IAFXTypeUseInfoContainer = pUsedDataCollector[pPointerType._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: pPointerType,
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[pPointerType._getInstructionID()] = pInfo;
			}

			if(eUsedMode === EVarUsedMode.k_Read){
				pInfo.isRead = true;
				pInfo.numRead++;
			}
			else if(eUsedMode === EVarUsedMode.k_Write){
				pInfo.isWrite = true;
				pInfo.numWrite++;
			}
			else if(eUsedMode === EVarUsedMode.k_ReadWrite){
				pInfo.isRead = true;
				pInfo.isWrite = true;
				pInfo.numRead++;
				pInfo.numWrite++;
			}

			pInfo.numUsed++;
		}
	}

/**
	 * Represent (expr)
	 * EMPTY_OPERATOR ExprInstruction
	 */

	export class ComplexExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_ComplexExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += "(" + this.getInstructions()[0].toFinalCode() + ")";

			return sCode;
		}

		isConst(): bool {
			return (<IAFXExprInstruction>this.getInstructions()[0]).isConst();
		}

		evaluate(): bool {
			if((<IAFXExprInstruction>this.getInstructions()[0]).evaluate()){
				this._pLastEvalResult = (<IAFXExprInstruction>this.getInstructions()[0]).getEvalValue();
				return true;
			}
			else {
				return false;
			}
		}

// addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
//                   eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
// 	var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
// 	pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
// }
	}

/**
	 * Respresnt func(arg1,..., argn)
	 * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction 
	 */

	export class FunctionCallInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_FunctionCallInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "(";
			for(var i:  number  = 1; i < this._nInstructions; i++){
				sCode += this.getInstructions()[i].toFinalCode();
				if(i !== this._nInstructions - 1){
					sCode +=","
				}
			}
			sCode += ")"

			return sCode;
		}

		getFunction(): IAFXFunctionDeclInstruction{
			return <IAFXFunctionDeclInstruction>(<IAFXIdExprInstruction>this._pInstructionList[0]).getType().getParent().getParent();
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pExprList: IAFXExprInstruction[] = <IAFXExprInstruction[]>this.getInstructions();
			var pFunction: IAFXFunctionDeclInstruction = this.getFunction();
			var pArguments: IAFXVariableDeclInstruction[] = <IAFXVariableDeclInstruction[]>pFunction.getArguments();

			pExprList[0].addUsedData(pUsedDataCollector, eUsedMode);

			for(var i: number  = 0; i < pArguments.length; i++){
				if (pArguments[i].getType().hasUsage("out")){
					pExprList[i+1].addUsedData(pUsedDataCollector, EVarUsedMode.k_Write);
				}
				else if(pArguments[i].getType().hasUsage("inout")){
					pExprList[i+1].addUsedData(pUsedDataCollector, EVarUsedMode.k_ReadWrite);
				}
				else {
					pExprList[i+1].addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
				}
			}
		}
	}

/**
	 * Respresnt system_func(arg1,..., argn)
	 * EMPTY_OPERATOR SimpleInstruction ... SimpleInstruction 
	 */

	export class SystemCallInstruction extends ExprInstruction {
		private _pSystemFunction: SystemFunctionInstruction = null;
		private _pSamplerDecl: IAFXVariableDeclInstruction = null;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_SystemCallInstruction;
		}

		toFinalCode(): string {
			if(!isNull(this._pSamplerDecl) && this._pSamplerDecl.isDefinedByZero()){
				return "vec4(0.)";
			}

			var sCode: string = "";

			for(var i:  number  = 0; i < this.getInstructions().length; i++){
				sCode += this.getInstructions()[i].toFinalCode();
			}

			return sCode;
		}

		setSystemCallFunction(pFunction: IAFXFunctionDeclInstruction): void{
			this._pSystemFunction = <SystemFunctionInstruction>pFunction;
			this.setType(pFunction.getType());
		}

		setInstructions(pInstructionList: IAFXInstruction[]): void {
			this._pInstructionList = pInstructionList;
			this._nInstructions = pInstructionList.length;
			for(var i:  number  = 0; i < pInstructionList.length; i++){
				pInstructionList[i].setParent(this);
			}
		}

		fillByArguments(pArguments: IAFXInstruction[]): void{
			this.setInstructions(this._pSystemFunction.closeArguments(pArguments));
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pInstructionList: IAFXAnalyzedInstruction[] = <IAFXAnalyzedInstruction[]>this.getInstructions();
			for(var i:  number  = 0; i < this._nInstructions; i++){
				if(pInstructionList[i]._getInstructionType() !== EAFXInstructionTypes.k_SimpleInstruction){
					pInstructionList[i].addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
					if((<IAFXExprInstruction>pInstructionList[i]).getType().isSampler()){
						this._pSamplerDecl = (<IAFXExprInstruction>pInstructionList[i]).getType()._getParentVarDecl();
					}
				}
			}
		}

		clone(pRelationMap?: IAFXInstructionMap): SystemCallInstruction{
			var pClone: SystemCallInstruction = <SystemCallInstruction>super.clone(pRelationMap);

			pClone.setSystemCallFunction(this._pSystemFunction);

			return pClone;
		}

	}

/**
	 * Respresnt ctor(arg1,..., argn)
	 * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction 
	 */

	export class ConstructorCallInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_ConstructorCallInstruction;
		}

// isConst
		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "(";

			for(var i:  number  = 1; i < this._nInstructions; i++){
				sCode += this.getInstructions()[i].toFinalCode();

				if(i !== this._nInstructions - 1){
					sCode += ",";
				}
			}

			sCode += ")";

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pInstructionList: IAFXAnalyzedInstruction[] = <IAFXAnalyzedInstruction[]>this.getInstructions();
			for(var i:  number  = 1; i < this._nInstructions; i++){
				pInstructionList[i].addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
			}
		}

		isConst(): bool {
			for(var i:  number  = 1; i < this._nInstructions; i++){
				if(!(<IAFXExprInstruction>this.getInstructions()[i]).isConst()){
					return false;
				}
			}

			return true;
		}

		evaluate(): bool {
			if(!this.isConst()){
				return false;
			}

			var pRes: any = null;
			var pJSTypeCtor: any = Effect.getExternalType(this.getType());
			var pArguments: any[] = new Array(this._nInstructions - 1);

			if(isNull(pJSTypeCtor)){
				return false;
			}

			try{
				if(Effect.isScalarType(this.getType())){
					var pTestedInstruction: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];
					if(this._nInstructions > 2 || !pTestedInstruction.evaluate()){
						return false;
					}

					pRes = pJSTypeCtor(pTestedInstruction.getEvalValue());
				}
				else {
					for(var i:  number  = 1; i < this._nInstructions; i++){
						var pTestedInstruction: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[i];

						if(pTestedInstruction.evaluate()){
							pArguments[i-1] = pTestedInstruction.getEvalValue();
						}
						else {
							return false;
						}
					}

					pRes = new pJSTypeCtor;
					pRes.set.apply(pRes, pArguments);
				}
			}
			catch(e){
				return false;
			}

			this._pLastEvalResult = pRes;
			return true;
		}
	}

/**
	 * Represetn compile vs_func(...args)
	 * compile IdExprInstruction ExprInstruction ... ExprInstruction
	 */

	export class CompileExprInstruction extends ExprInstruction{
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_CompileExprInstruction;
		}

		/**@inline*/  getFunction(): IAFXFunctionDeclInstruction {
			return <IAFXFunctionDeclInstruction>this._pInstructionList[0].getParent().getParent();
		}
	}

	export class MemExprInstruction extends ExprInstruction {
		private _pBuffer: IAFXVariableDeclInstruction = null;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_MemExprInstruction;
		}

		getBuffer(): IAFXVariableDeclInstruction{
			return this._pBuffer;
		}

		setBuffer(pBuffer: IAFXVariableDeclInstruction): void {
			this._pBuffer = pBuffer;
			this.setType(pBuffer.getType());
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
					eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pBufferType: IAFXVariableTypeInstruction = this.getBuffer().getType();
			var pInfo: IAFXTypeUseInfoContainer = pUsedDataCollector[pBufferType._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: pBufferType,
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[pBufferType._getInstructionID()] = pInfo;
			}
			if(eUsedMode !== EVarUsedMode.k_Undefined){
				pInfo.isRead = true;
				pInfo.numRead++;
			}

			pInfo.numUsed++;
		}
	}

	export class InitExprInstruction extends ExprInstruction implements IAFXInitExprInstruction {
		private _pConstructorType: IAFXTypeInstruction = null;
		private _isConst: bool = null;
		private _isArray: bool = false;

		constructor(){
			super();
			this._pInstructionList = [];
			this._eInstructionType = EAFXInstructionTypes.k_InitExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			if(!isNull(this._pConstructorType)) {
				sCode += this._pConstructorType.toFinalCode();
			}
			sCode += "(";

			for(var i:  number  = 0; i < this._nInstructions; i++){
				sCode += this.getInstructions()[i].toFinalCode();

				if(i !== this._nInstructions - 1){
					sCode += ",";
				}
			}

			sCode += ")";

			return sCode;
		}

		isConst(): bool {
			if(isNull(this._isConst)){
				var pInstructionList: IAFXExprInstruction[] = <IAFXExprInstruction[]>this.getInstructions();

				for(var i:  number  = 0; i < pInstructionList.length; i++){
					if(!pInstructionList[i].isConst()){
						this._isConst = false;
						break;
					}
				}

				this._isConst = isNull(this._isConst) ? true : false;
			}

			return this._isConst;
		}

		optimizeForVariableType(pType: IAFXVariableTypeInstruction): bool {
			if ((pType.isNotBaseArray() && pType._getScope() === 0) ||
				(pType.isArray() && this._nInstructions > 1)){


				if (pType.getLength() ===  0xffffff  ||
					(pType.isNotBaseArray() && this._nInstructions !== pType.getLength()) ||
					(!pType.isNotBaseArray() && this._nInstructions !== pType.getBaseType().getLength())){

					return false;
				}

				if(pType.isNotBaseArray()){
					this._isArray = true;
				}

				var pArrayElementType: IAFXVariableTypeInstruction = pType.getArrayElementType();
				var pTestedInstruction: IAFXExprInstruction = null;
				var isOk: bool = false;

				for(var i:  number  = 0; i < this._nInstructions; i++){
					pTestedInstruction = (<IAFXExprInstruction>this.getInstructions()[i]);

					if(pTestedInstruction._getInstructionType() === EAFXInstructionTypes.k_InitExprInstruction){
						isOk = (<IAFXInitExprInstruction>pTestedInstruction).optimizeForVariableType(pArrayElementType);
						if(!isOk){
							return false;
						}
					}
					else {
						if(Effect.isSamplerType(pArrayElementType)){
							if(pTestedInstruction._getInstructionType() !== EAFXInstructionTypes.k_SamplerStateBlockInstruction){
								return false;
							}
						}
						else {
							isOk = pTestedInstruction.getType().isEqual(pArrayElementType);
							if(!isOk){
								return false;
							}
						}
					}
				}

				this._pConstructorType = pType.getBaseType();
				return true;
			}
			else {
				var pFirstInstruction: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];

				if (this._nInstructions === 1 &&
					pFirstInstruction._getInstructionType() !== EAFXInstructionTypes.k_InitExprInstruction){

					if(Effect.isSamplerType(pType)){
						if(pFirstInstruction._getInstructionType() === EAFXInstructionTypes.k_SamplerStateBlockInstruction){
							return true;
						}
						else {
							return false;
						}
					}

					if(pFirstInstruction.getType().isEqual(pType)){
						return true;
					}
					else {
						return false;
					}
				}
				else if(this._nInstructions === 1){
					return false;
				}

				var pInstructionList: IAFXInitExprInstruction[] = <IAFXInitExprInstruction[]>this.getInstructions();
				var pFieldNameList: string[] = pType.getFieldNameList();

				for(var i:  number  = 0 ; i < pInstructionList.length; i++){
					var pFieldType: IAFXVariableTypeInstruction = pType.getFieldType(pFieldNameList[i]);
					if(!pInstructionList[i].optimizeForVariableType(pFieldType)) {
						return false;
					}
				}

				this._pConstructorType = pType.getBaseType();
				return true;
			}
		}

		evaluate(): bool {
			if(!this.isConst()){
				this._pLastEvalResult = null;
				return false;
			}

			var pRes: any = null;

			if(this._isArray){
				pRes = new Array(this._nInstructions);

				for(var i:  number  = 0; i < this._nInstructions; i++){
					var pEvalInstruction = (<IAFXExprInstruction>this.getInstructions()[i]);

					if(pEvalInstruction.evaluate()){
						pRes[i] = pEvalInstruction.getEvalValue();
					}
				}
			}
			else if(this._nInstructions === 1){
				var pEvalInstruction = (<IAFXExprInstruction>this.getInstructions()[0]);
				pEvalInstruction.evaluate();
				pRes = pEvalInstruction.getEvalValue();
			}
			else {
				var pJSTypeCtor: any = Effect.getExternalType(this._pConstructorType);
				var pArguments: any[] = new Array(this._nInstructions);

				if(isNull(pJSTypeCtor)){
					return false;
				}

				try{
					if(Effect.isScalarType(this._pConstructorType)){
						var pTestedInstruction: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];
						if(this._nInstructions > 2 || !pTestedInstruction.evaluate()){
							return false;
						}

						pRes = pJSTypeCtor(pTestedInstruction.getEvalValue());
					}
					else {
						for(var i:  number  = 0; i < this._nInstructions; i++){
							var pTestedInstruction: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[i];

							if(pTestedInstruction.evaluate()){
								pArguments[i] = pTestedInstruction.getEvalValue();
							}
							else {
								return false;
							}
						}

						pRes = new pJSTypeCtor;
						pRes.set.apply(pRes, pArguments);
					}
				}
				catch(e){
					return false;
				}
			}

			this._pLastEvalResult = pRes;

			return true;
		}
	}
/**
	 * Represetn sampler_state { states }
	 */

	export class SamplerStateBlockInstruction extends ExprInstruction {
		private _pTexture: IAFXVariableDeclInstruction = null;
		private _pSamplerParams: any = null;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_SamplerStateBlockInstruction;
		}

		addState(sStateType: string, sStateValue: string): void{
			if(isNull(this._pSamplerParams)){
				this._pSamplerParams = {};
			}

			this._pSamplerParams[sStateType] = sStateValue;
			return;
		}

		setTexture(pTexture: IAFXVariableDeclInstruction): void {
			this._pTexture = pTexture;
		}

		/**@inline*/  getTexture(): IAFXVariableDeclInstruction {
			return this._pTexture;
		}

		/**@inline*/  isConst(): bool {
			return true;
		}

		evaluate(): bool {
			var pSamplerState: IAFXSamplerState = {
				texture: null,
				textureName: "",

				wrap_s: 0,
				wrap_t: 0,

				mag_filter: 0,
				min_filter: 0
			};

			if(!isNull(this._pTexture)){
				pSamplerState.textureName = this._pTexture.getRealName();
			}

			if(!isNull(this._pSamplerParams)){
				if(isDef(this._pSamplerParams["ADDRESSU"])){
					pSamplerState.wrap_s = SamplerStateBlockInstruction.convertWrapMode(this._pSamplerParams["ADDRESSU"]);
				}

				if(isDef(this._pSamplerParams["ADDRESSV"])){
					pSamplerState.wrap_t = SamplerStateBlockInstruction.convertWrapMode(this._pSamplerParams["ADDRESSV"]);
				}

				if(isDef(this._pSamplerParams["MAGFILTER"])){
					pSamplerState.mag_filter = SamplerStateBlockInstruction.convertFilters(this._pSamplerParams["MAGFILTER"]);
				}

				if(isDef(this._pSamplerParams["MINFILTER"])){
					pSamplerState.min_filter = SamplerStateBlockInstruction.convertFilters(this._pSamplerParams["MINFILTER"]);
				}
			}


			this._pLastEvalResult = pSamplerState;

			return true;
		}

		static convertWrapMode(sState: string): ETextureWrapModes {
			switch (sState) {
	            case "WRAP":
	            	return ETextureWrapModes.REPEAT;
	            case "CLAMP":
	            	return ETextureWrapModes.CLAMP_TO_EDGE;
	            case "MIRROR":
	            	return ETextureWrapModes.MIRRORED_REPEAT;

	            default:
	            	return 0;
			}
		}

		static convertFilters(sState: string): ETextureFilters {
			switch (sState) {
	            case "NEAREST":
	            	return ETextureFilters.NEAREST;
                case "LINEAR":
                	return ETextureFilters.LINEAR;
                case "NEAREST_MIPMAP_NEAREST":
                	return ETextureFilters.NEAREST_MIPMAP_NEAREST;
                case "LINEAR_MIPMAP_NEAREST":
                	return ETextureFilters.LINEAR_MIPMAP_NEAREST;
                case "NEAREST_MIPMAP_LINEAR":
                	return ETextureFilters.NEAREST_MIPMAP_LINEAR;
                case "LINEAR_MIPMAP_LINEAR":
                	return ETextureFilters.LINEAR_MIPMAP_LINEAR;

	            default:
	            	return 0;
			}
		}
	}


	export class ExtractExprInstruction extends ExprInstruction {
		private _eExtractExprType: EExtractExprType = 0;
		private _pPointer: IAFXVariableDeclInstruction = null;
        private _pBuffer: IAFXVariableDeclInstruction = null;
        private _pOffsetVar: IAFXVariableDeclInstruction = null;
        private _sPaddingExpr: string = "";

        private _sExtractFunction: string = "";
        private _bNeedSecondBracket: bool = false;

		constructor(){
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_ExtractExprInstruction;
		}

		getExtractFunction(): IAFXFunctionDeclInstruction {
			var pFunction: IAFXFunctionDeclInstruction = null;

            switch(this._eExtractExprType){
				case EExtractExprType.k_Header:
					pFunction = Effect.findSystemFunction("extractHeader", null);
					break;

				case EExtractExprType.k_Float:
				case EExtractExprType.k_Int:
				case EExtractExprType.k_Bool:
					pFunction = Effect.findSystemFunction("extractFloat", null);
					break;

				case EExtractExprType.k_Float2:
				case EExtractExprType.k_Int2:
				case EExtractExprType.k_Bool2:
					pFunction = Effect.findSystemFunction("extractFloat2", null);
					break;

				case EExtractExprType.k_Float3:
				case EExtractExprType.k_Int3:
				case EExtractExprType.k_Bool3:
					pFunction = Effect.findSystemFunction("extractFloat3", null);
					break;

				case EExtractExprType.k_Float4:
				case EExtractExprType.k_Int4:
				case EExtractExprType.k_Bool4:
					pFunction = Effect.findSystemFunction("extractFloat4", null);
					break;

				case EExtractExprType.k_Float4x4:
					pFunction = Effect.findSystemFunction("extractFloat4x4", null);
					break;
            }

            return pFunction;
        }

		initExtractExpr(pExtractType: IAFXVariableTypeInstruction,
					    pPointer: IAFXVariableDeclInstruction,
					    pBuffer: IAFXVariableDeclInstruction,
					    sPaddingExpr: string, pOffsetVar: IAFXVariableDeclInstruction): void {

			this._pPointer = pPointer;
			this._pBuffer = pBuffer;
			this._sPaddingExpr = sPaddingExpr;
			this._pOffsetVar = pOffsetVar;
			this.setType(pExtractType);

            if (pExtractType.isEqual(Effect.getSystemType("float"))) {
            	this._eExtractExprType = EExtractExprType.k_Float;
                this._sExtractFunction += "A_extractFloat(";
            }
            else if(pExtractType.isEqual(Effect.getSystemType("ptr"))){
                this._eExtractExprType = EExtractExprType.k_Float;
                this._sExtractFunction += "A_extractFloat(";
            }
            else if(pExtractType.isEqual(Effect.getSystemType("video_buffer_header"))){
            	this._eExtractExprType = EExtractExprType.k_Header;
            	this._sExtractFunction += "A_extractTextureHeader(";
            }
            else if (pExtractType.isEqual(Effect.getSystemType("bool"))){
                this._eExtractExprType = EExtractExprType.k_Bool;
                this._sExtractFunction += "bool(A_extractFloat(";
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("int"))) {
            	this._eExtractExprType = EExtractExprType.k_Int;
                this._sExtractFunction += ("int(A_extractFloat(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("float2"))) {
            	this._eExtractExprType = EExtractExprType.k_Float2;
                this._sExtractFunction += ("A_extractVec2(");
            }
            else if (pExtractType.isEqual(Effect.getSystemType("float3"))) {
            	this._eExtractExprType = EExtractExprType.k_Float3;
                this._sExtractFunction += ("A_extractVec3(");
            }
            else if (pExtractType.isEqual(Effect.getSystemType("float4"))) {
            	this._eExtractExprType = EExtractExprType.k_Float4;
                this._sExtractFunction += ("A_extractVec4(");
            }
            else if (pExtractType.isEqual(Effect.getSystemType("int2"))) {
            	this._eExtractExprType = EExtractExprType.k_Int2;
                this._sExtractFunction += ("ivec2(A_extractVec2(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("int3"))) {
            	this._eExtractExprType = EExtractExprType.k_Int3;
                this._sExtractFunction += ("ivec3(A_extractVec3(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("int4"))) {
            	this._eExtractExprType = EExtractExprType.k_Int4;
                this._sExtractFunction += ("ivec4(A_extractVec4(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("bool2"))) {
            	this._eExtractExprType = EExtractExprType.k_Bool2;
                this._sExtractFunction += ("bvec2(A_extractVec2(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("bool3"))) {
            	this._eExtractExprType = EExtractExprType.k_Bool3;
                this._sExtractFunction += ("bvec3(A_extractVec3(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("bool4"))) {
            	this._eExtractExprType = EExtractExprType.k_Bool4;
                this._sExtractFunction += ("bvec4(A_extractVec4(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("float4x4"))) {
            	this._eExtractExprType = EExtractExprType.k_Float4x4;
                this._sExtractFunction += ("A_extractMat4(");
            }
            else {
                this.setError( 2273 , { typeName: pExtractType.getHash() });
            }
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pPointerType: IAFXVariableTypeInstruction = this._pPointer.getType();
			var pBufferType: IAFXVariableTypeInstruction = this._pBuffer.getType();

			var pInfo: IAFXTypeUseInfoContainer = pUsedDataCollector[pPointerType._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: pPointerType,
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[pPointerType._getInstructionID()] = pInfo;
			}

			pInfo.isRead = true;
			pInfo.numRead++;
			pInfo.numUsed++;

			pInfo = pUsedDataCollector[pBufferType._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: pBufferType,
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[pBufferType._getInstructionID()] = pInfo;
			}

			pInfo.isRead = true;
			pInfo.numRead++;
			pInfo.numUsed++;
        }

		toFinalCode(): string {
			var sCode: string = "";

			if(this._pBuffer.isDefinedByZero()){
				switch(this._eExtractExprType){
					case EExtractExprType.k_Header:
						sCode = "A_TextureHeader(0.,0.,0.,0.)";
						break;

					case EExtractExprType.k_Float:
						sCode = "0.";
						break;
					case EExtractExprType.k_Int:
						sCode = "0";
						break;
					case EExtractExprType.k_Bool:
						sCode = "false";
						break;

					case EExtractExprType.k_Float2:
						sCode = "vec2(0.)";
						break;
					case EExtractExprType.k_Int2:
						sCode = "ivec2(0)";
						break;
					case EExtractExprType.k_Bool2:
						sCode = "bvec2(false)";
						break;

					case EExtractExprType.k_Float3:
						sCode = "vec3(0.)";
						break;
					case EExtractExprType.k_Int3:
						sCode = "ivec3(0)";
						break;
					case EExtractExprType.k_Bool3:
						sCode = "bvec3(false)";
						break;

					case EExtractExprType.k_Float4:
						sCode = "vec4(0.)";
						break;
					case EExtractExprType.k_Int4:
						sCode = "ivec4(0)";
						break;
					case EExtractExprType.k_Bool4:
						sCode = "bvec4(false)";
						break;

					case EExtractExprType.k_Float4x4:
						sCode = "mat4(0.)";
						break;
				}
			}
			else {
				sCode = this._sExtractFunction;
				sCode += this._pBuffer._getVideoBufferSampler().getNameId().toFinalCode();
				sCode += "," + this._pBuffer._getVideoBufferHeader().getNameId().toFinalCode();
				if(this._eExtractExprType !== EExtractExprType.k_Header) {
					sCode += "," + this._pPointer.getNameId().toFinalCode() + this._sPaddingExpr;

					if(!isNull(this._pOffsetVar)){
						sCode += "+" + this._pOffsetVar.getNameId().toFinalCode();
					}
				}
				sCode += ")";
				if(this._bNeedSecondBracket){
					sCode += ")";
				}
			}

			return sCode;
		}

		clone(pRelationMap?: IAFXInstructionMap): ExtractExprInstruction {
			var pClone: ExtractExprInstruction = <ExtractExprInstruction>super.clone(pRelationMap);
			pClone._setCloneParams(this._pPointer.clone(pRelationMap), this._pBuffer, this._eExtractExprType,
								   this._sPaddingExpr, this._sExtractFunction, this._bNeedSecondBracket);
			return pClone;
		}

		_setCloneParams(pPointer: IAFXVariableDeclInstruction,
						pBuffer: IAFXVariableDeclInstruction,
						eExtractExprType: EExtractExprType,
						sPaddingExpr: string,
						sExtractFunction: string,
						bNeedSecondBracket: bool): void {
			this._pPointer = pPointer;
			this._pBuffer = pBuffer;
			this._eExtractExprType = eExtractExprType;
			this._sPaddingExpr = sPaddingExpr;
			this._sExtractFunction = sExtractFunction;
			this._bNeedSecondBracket = bNeedSecondBracket;
		}
	}
}










module akra {
	export interface IStringDictionary {
		add(sEntry: string):  number ;
		index(sEntry: string):  number ;
		findEntry(iIndex: string): string;
	}
}



module akra.util {
	export class StringDictionary implements IStringDictionary {
		private _pDictionary: IntMap = null;
		private _pIndexToEntryMap: StringMap = null;

		private _nEntryCount:  number  = 1;

		constructor(){
			this._pDictionary = <IntMap>{};
			this._pIndexToEntryMap = <StringMap>{};
		}

		add(sEntry: string):  number  {
			if(!isDef(this._pDictionary[sEntry])){
				this._pDictionary[sEntry] = this._nEntryCount++;
				this._pIndexToEntryMap[this._nEntryCount - 1] = sEntry;
			}

			return this._pDictionary[sEntry];

		}

		index(sEntry: string):  number  {
			return this._pDictionary[sEntry] || 0;
		}

		findEntry(iIndex: string): string {
			return this._pIndexToEntryMap[iIndex];
		}
	}
}



module akra.fx {
	export class VariableDeclInstruction extends DeclInstruction implements IAFXVariableDeclInstruction {
		private _isVideoBuffer: bool = null;
        private _pVideoBufferSampler: IAFXVariableDeclInstruction = null;
        private _pVideoBufferHeader: IAFXVariableDeclInstruction = null;
        private _pFullNameExpr: IAFXExprInstruction = null;
        private _bDefineByZero: bool = false;
        private _pSubDeclList: IAFXVariableDeclInstruction[] = null;
        private _bShaderOutput: bool = false;

        private _pAttrOffset: IAFXVariableDeclInstruction = null;
        private _pAttrExtractionBlock: IAFXInstruction = null;

        private _pValue: any = null;
        private _pDefaultValue: any = null;

        private _bLockInitializer: bool = false;

        private _iNameIndex:  number  = 0;
        static pShaderVarNamesGlobalDictionary: util.StringDictionary = new util.StringDictionary();
        static  /**@inline*/  _getIndex(sName: string):  number  {
            return VariableDeclInstruction.pShaderVarNamesGlobalDictionary.add(sName);
        }
/**
		 * Represent type var_name [= init_expr]
		 * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction
		 */

		constructor(){
			super();
			this._pInstructionList = [null, null, null];
			this._eInstructionType = EAFXInstructionTypes.k_VariableDeclInstruction;
		}

		/**@inline*/  hasInitializer(): bool {
			return this._nInstructions === 3 && !isNull(this.getInitializeExpr());
		}

		/**@inline*/  getInitializeExpr(): IAFXInitExprInstruction {
			return <IAFXInitExprInstruction>this.getInstructions()[2];
		}

        /**@inline*/  hasConstantInitializer(): bool {
            return this.hasInitializer() && this.getInitializeExpr().isConst();
        }

        /**@inline*/  lockInitializer(): void {
            this._bLockInitializer = true;
        }

        /**@inline*/  unlockInitializer(): void {
            this._bLockInitializer = false;
        }

        getDefaultValue(): any {
            return this._pDefaultValue;
        }

        prepareDefaultValue(): void {
            this.getInitializeExpr().evaluate();
            this._pDefaultValue = this.getInitializeExpr().getEvalValue();
        }

        getValue(): any {
            return this._pValue;
        }

        setValue(pValue: any): any {
            this._pValue = pValue;

            if(this.getType().isForeign()){
                this.setRealName(pValue);
            }
        }

		/**@inline*/  getType(): IAFXVariableTypeInstruction {
			return <IAFXVariableTypeInstruction>this._pInstructionList[0];
		}

        /**@inline*/  setType(pType: IAFXVariableTypeInstruction): void{
        	this._pInstructionList[0] = <IAFXVariableTypeInstruction>pType;
        	pType.setParent(this);

        	if(this._nInstructions === 0){
        		this._nInstructions = 1;
        	}
        }

        setName(sName: string):void {
        	var pName: IAFXIdInstruction = new IdInstruction();
        	pName.setName(sName);
        	pName.setParent(this);

        	this._pInstructionList[1] = <IAFXIdInstruction>pName;

        	if(this._nInstructions < 2) {
        		this._nInstructions = 2;
        	}
        }

        setRealName(sRealName: string): void {
            this.getNameId().setRealName(sRealName);
        }

        setVideoBufferRealName(sSampler: string, sHeader: string): void {
            if(!this.isVideoBuffer()){
                return;
            }

            this._getVideoBufferSampler().setRealName(sSampler);
            this._getVideoBufferHeader().setRealName(sHeader);
        }

        /**@inline*/  getName(): string {
        	return (<IAFXIdInstruction>this._pInstructionList[1]).getName();
        }

        /**@inline*/  getRealName(): string {
            return (<IAFXIdInstruction>this._pInstructionList[1]).getRealName();
        }

        /**@inline*/  getNameId(): IAFXIdInstruction {
                return <IAFXIdInstruction>this._pInstructionList[1];
        }

        /**@inline*/  isUniform(): bool {
        	return this.getType().hasUsage("uniform");
        }

        isField(): bool {
            if(isNull(this.getParent())){
                return false;
            }

            var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();
            if (eParentType === EAFXInstructionTypes.k_VariableTypeInstruction ||
                eParentType === EAFXInstructionTypes.k_ComplexTypeInstruction ||
                eParentType === EAFXInstructionTypes.k_SystemTypeInstruction){
                return true;
            }

            return false;
        }

        /**@inline*/  isPointer(): bool {
            return this.getType().isPointer();
        }

        isVideoBuffer(): bool{
            if(isNull(this._isVideoBuffer)){
                this._isVideoBuffer = this.getType().isStrongEqual(Effect.getSystemType("video_buffer"));
            }

            return this._isVideoBuffer;
        }

        /**@inline*/  isSampler(): bool {
            return this.getType().isSampler();
        }

        /**@inline*/  getSubVarDecls(): IAFXVariableDeclInstruction[] {
           return this.getType().getSubVarDecls();
        }

        /**@inline*/  isDefinedByZero(): bool{
            return this._bDefineByZero;
        }

        /**@inline*/  defineByZero(isDefine: bool): void {
            this._bDefineByZero = isDefine;
        }

        toFinalCode(): string {
            if(this._isShaderOutput()){
                return "";
            }
            var sCode: string = "";

            if(this.isVideoBuffer()){
                this._getVideoBufferHeader().lockInitializer();

                sCode = this._getVideoBufferHeader().toFinalCode();
                sCode += ";\n";
                sCode += this._getVideoBufferSampler().toFinalCode();

                this._getVideoBufferHeader().unlockInitializer();
            }
            else {
                sCode = this.getType().toFinalCode();
                sCode += " " + this.getNameId().toFinalCode();

                if(this.getType().isNotBaseArray()){
                    var iLength:  number  = this.getType().getLength();
                    if(webgl.isANGLE && iLength === 1 && this.getType().isComplex()) {
                        sCode += "[" + 2 + "]";
                    }
                    else {
                        sCode += "[" + iLength + "]";
                    }
                }

                if (this.hasInitializer() &&
                    !this.isSampler() &&
                    !this.isUniform() &&
                    !this._bLockInitializer) {
                    sCode += "=" + this.getInitializeExpr().toFinalCode();
                }
            }

            return sCode;
        }

        /**@inline*/  _markAsVarying(bValue: bool): void {
            this.getNameId()._markAsVarying(bValue);
        }

        /**@inline*/  _markAsShaderOutput(isShaderOutput: bool): void {
            this._bShaderOutput = isShaderOutput;
        }

        /**@inline*/  _isShaderOutput(): bool {
            return this._bShaderOutput;
        }

        _setAttrExtractionBlock(pCodeBlock: IAFXInstruction): void {
            this._pAttrExtractionBlock = pCodeBlock;
        }

        _getAttrExtractionBlock(): IAFXInstruction {
            return this._pAttrExtractionBlock;
        }

        _getNameIndex():  number  {
            return this._iNameIndex || (this._iNameIndex = VariableDeclInstruction.pShaderVarNamesGlobalDictionary.add(this.getRealName()));
        }

        _getFullNameExpr(): IAFXExprInstruction {
            if(!isNull(this._pFullNameExpr)){
                return this._pFullNameExpr;
            }

            if (!this.isField() ||
                !(<IAFXVariableTypeInstruction>this.getParent())._getParentVarDecl().isVisible()){
                this._pFullNameExpr = new IdExprInstruction();
                this._pFullNameExpr.push(this.getNameId(), false);
            }
            else {
                var pMainVar: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getType()._getParentContainer();

                if(isNull(pMainVar)){
                    return null;
                }

                var pMainExpr: IAFXExprInstruction = pMainVar._getFullNameExpr();
                if(isNull(pMainExpr)){
                    return null;
                }
                var pFieldExpr: IAFXExprInstruction = new IdExprInstruction();
                pFieldExpr.push(this.getNameId(), false);

                this._pFullNameExpr = new PostfixPointInstruction();
                this._pFullNameExpr.push(pMainExpr, false);
                this._pFullNameExpr.push(pFieldExpr, false);
                this._pFullNameExpr.setType(this.getType());
            }

            return this._pFullNameExpr;
        }

        _getFullName(): string {
            if (this.isField() &&
                (<IAFXVariableTypeInstruction>this.getParent())._getParentVarDecl().isVisible()){

                var sName: string = "";
                var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

                if(eParentType === EAFXInstructionTypes.k_VariableTypeInstruction){
                    sName = (<IAFXVariableTypeInstruction>this.getParent())._getFullName();
                }

                sName += "." + this.getName();

                return sName;
            }
            else {
                return this.getName();
            }
        }

        _getVideoBufferSampler(): IAFXVariableDeclInstruction {
            if(!this.isVideoBuffer()){
                return null;
            }

            if(isNull(this._pVideoBufferSampler)){
                this._pVideoBufferSampler = new VariableDeclInstruction();
                var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
                var pId: IAFXIdInstruction = new IdInstruction();

                pType.pushType(Effect.getSystemType("sampler2D"));
                pType.addUsage("uniform");
                pId.setName(this.getName() + "_sampler");

                this._pVideoBufferSampler.push(pType, true);
                this._pVideoBufferSampler.push(pId, true);
            }

            return this._pVideoBufferSampler;
        }

        _getVideoBufferHeader(): IAFXVariableDeclInstruction {
            if(!this.isVideoBuffer()){
                return null;
            }

            if(isNull(this._pVideoBufferHeader)){
                this._pVideoBufferHeader = new VariableDeclInstruction();
                var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
                var pId: IAFXIdInstruction = new IdInstruction();
                var pExtarctExpr: ExtractExprInstruction = new ExtractExprInstruction();

                pType.pushType(Effect.getSystemType("video_buffer_header"));
                pId.setName(this.getName() + "_header");

                this._pVideoBufferHeader.push(pType, true);
                this._pVideoBufferHeader.push(pId, true);
                this._pVideoBufferHeader.push(pExtarctExpr, true);

                pExtarctExpr.initExtractExpr(pType, null, this, "", null);
            }

            return this._pVideoBufferHeader;
        }

        _getVideoBufferInitExpr(): IAFXInitExprInstruction{
            if(!this.isVideoBuffer()){
                return null;
            }

            return this._getVideoBufferHeader().getInitializeExpr();
        }

        /**@inline*/  _setCollapsed(bValue: bool): void {
            this.getType()._setCollapsed(bValue);
        }

        /**@inline*/  _isCollapsed(): bool {
            return this.getType()._isCollapsed();
        }

        clone(pRelationMap?: IAFXInstructionMap): IAFXVariableDeclInstruction {
        	return <IAFXVariableDeclInstruction>super.clone(pRelationMap);
        }

        blend(pVariableDecl: IAFXVariableDeclInstruction, eMode: EAFXBlendMode): IAFXVariableDeclInstruction{
            var pBlendType: IAFXVariableTypeInstruction = this.getType().blend(pVariableDecl.getType(), eMode);

            if(isNull(pBlendType)){
                return null;
            }

            var pBlendVar: IAFXVariableDeclInstruction = new VariableDeclInstruction();
            var pId: IAFXIdInstruction = new IdInstruction();

            pId.setName(this.getNameId().getName());
            pId.setRealName(this.getNameId().getRealName());

            pBlendVar.setSemantic(this.getSemantic());
            pBlendVar.push(pBlendType, true);
            pBlendVar.push(pId, true);

            return pBlendVar;
        }

	}
}



















module akra.fx {
/**
     * Represent all kind of statements
     */

    export class StmtInstruction extends Instruction  implements IAFXStmtInstruction {
        constructor() {
            super();
            this._eInstructionType = EAFXInstructionTypes.k_StmtInstruction;
        }

        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
            var pInstructionList: IAFXAnalyzedInstruction[] = <IAFXAnalyzedInstruction[]>this.getInstructions();

            if(!isNull(pUsedDataCollector)){
                for(var i:  number  = 0; i < this._nInstructions; i++){
                    pInstructionList[i].addUsedData(pUsedDataCollector, eUsedMode);
                }
            }
        }
    }

/**
     * Represent {stmts}
     * EMPTY_OPERATOR StmtInstruction ... StmtInstruction
     */

    export class StmtBlockInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [];
            this._eInstructionType = EAFXInstructionTypes.k_StmtBlockInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "{" + "\n";

            for(var i:  number  = 0; i < this._nInstructions; i++){
                sCode += "\t" + this._pInstructionList[i].toFinalCode() + "\n";
            }

            sCode += "}";

            return sCode;
        }
    }

/**
     * Represent expr;
     * EMPTY_OPERTOR ExprInstruction 
     */

    export class ExprStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [null];
            this._eInstructionType = EAFXInstructionTypes.k_ExprStmtInstruction;
        }

        toFinalCode(): string {
            return this.getInstructions()[0].toFinalCode() + ";";
        }
    }

/**
     * Reprsernt continue; break; discard;
     * (continue || break || discard) 
     */

    export class BreakStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = null;
            this._eInstructionType = EAFXInstructionTypes.k_BreakStmtInstruction;
        }

        toFinalCode(): string {
            return this.getOperator() + ";";
        }
    }

/**
     * Represent while(expr) stmt
     * ( while || do_while) ExprInstruction StmtInstruction
     */

    export class WhileStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [null, null];
            this._eInstructionType = EAFXInstructionTypes.k_WhileStmtInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "";
            if(this.getOperator() === "while"){
                sCode += "while(";
                sCode += this.getInstructions()[0].toFinalCode();
                sCode += ")";
                sCode += this.getInstructions()[1].toFinalCode();
            }
            else{
                sCode += "do";
                sCode += this.getInstructions()[1].toFinalCode();
                sCode += "while(";
                sCode += this.getInstructions()[0].toFinalCode();
                sCode += ");";
            }
            return sCode;
        }
    }

/**
     * Represent for(forInit forCond ForStep) stmt
     * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction
     */

    export class ForStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [null, null, null, null];
            this._eInstructionType = EAFXInstructionTypes.k_ForStmtInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "for(";

            sCode += this.getInstructions()[0].toFinalCode() + ";";
            sCode += this.getInstructions()[1].toFinalCode() + ";";
            sCode += this.getInstructions()[2].toFinalCode() + ")";
            sCode += this.getInstructions()[3].toFinalCode();

            return sCode;
        }

        check(eStage: ECheckStage, pInfo: any = null): bool {
            var pInstructionList: IAFXInstruction[] = this.getInstructions();

            if(this._nInstructions !== 4){
                this.setError( 2239 );
                return false;
            }

            if(isNull(pInstructionList[0])){
                this.setError( 2232 );
                return false;
            }

            if(pInstructionList[0]._getInstructionType() !== EAFXInstructionTypes.k_VariableDeclInstruction){
                this.setError( 2231 );
                return false;
            }

            if(isNull(pInstructionList[1])){
                this.setError( 2233 );
                return false;
            }

            if(pInstructionList[1]._getInstructionType() !== EAFXInstructionTypes.k_RelationalExprInstruction){
                this.setError( 2238 );
                return false;
            }

            if(pInstructionList[2]._getInstructionType() === EAFXInstructionTypes.k_UnaryExprInstruction ||
               pInstructionList[2]._getInstructionType() === EAFXInstructionTypes.k_AssignmentExprInstruction ||
               pInstructionList[2]._getInstructionType() === EAFXInstructionTypes.k_PostfixArithmeticInstruction){

                var sOperator: string = pInstructionList[2].getOperator();
                if (sOperator !== "++" && sOperator !== "--" &&
                    sOperator !== "+=" && sOperator !== "-=") {
                    this.setError( 2240 , {operator: sOperator});
                    return false;
                }
            }
            else {
                this.setError( 2241 );
                return false;
            }

            return true;
        }

        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
            var pForInit: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getInstructions()[0];
            var pForCondition: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];
            var pForStep: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[2];
            var pForStmt: IAFXStmtInstruction = <IAFXStmtInstruction>this.getInstructions()[3];

            var pIteratorType: IAFXVariableTypeInstruction = pForInit.getType();

            pUsedDataCollector[pIteratorType._getInstructionID()] = <IAFXTypeUseInfoContainer>{
                type: pIteratorType,
                isRead: false,
                isWrite: true,
                numRead: 0,
                numWrite: 1,
                numUsed: 1
            };

            pForCondition.addUsedData(pUsedDataCollector, eUsedMode);
            pForStep.addUsedData(pUsedDataCollector, eUsedMode);
            pForStmt.addUsedData(pUsedDataCollector, eUsedMode);
        }
    }

/**
     * Represent if(expr) stmt or if(expr) stmt else stmt
     * ( if || if_else ) Expr Stmt [Stmt]
     */

    export class IfStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [null, null, null];
            this._eInstructionType = EAFXInstructionTypes.k_IfStmtInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "";
            if(this.getOperator() === "if"){
                sCode += "if(";
                sCode += this.getInstructions()[0].toFinalCode() + ")";
                sCode += this.getInstructions()[1].toFinalCode();
            }
            else {
                sCode += "if(";
                sCode += this.getInstructions()[0].toFinalCode() + ") ";
                sCode += this.getInstructions()[1].toFinalCode();
                sCode += "else ";
                sCode += this.getInstructions()[2].toFinalCode();
            }

            return sCode;
        }
    }

/**
     * Represent TypeDecl or VariableDecl or VarStructDecl
     * EMPTY DeclInstruction
     */

    export class DeclStmtInstruction extends StmtInstruction {
        constructor () {
            super();
            this._pInstructionList = [null];
            this._eInstructionType = EAFXInstructionTypes.k_DeclStmtInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "";
            var pVariableList: IAFXVariableDeclInstruction[] = <IAFXVariableDeclInstruction[]>this.getInstructions();

            for(var i:  number  = 0; i < this._nInstructions; i++){
                sCode += pVariableList[i].toFinalCode() + ";\n";
            }

            return sCode;
        }

        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
            if(isNull(this.getInstructions()) || this._nInstructions === 0) {
                return;
            }

            if(this.getInstructions()[0]._getInstructionType() === EAFXInstructionTypes.k_TypeDeclInstruction){
                return;
            }

            var pVariableList: IAFXVariableDeclInstruction[] = <IAFXVariableDeclInstruction[]>this.getInstructions();
            for(var i:  number  = 0; i < this._nInstructions; i++){
                var pVarType: IAFXVariableTypeInstruction = pVariableList[i].getType();

                pUsedDataCollector[pVarType._getInstructionID()] = <IAFXTypeUseInfoContainer>{
                    type: pVarType,
                    isRead: false,
                    isWrite: true,
                    numRead: 0,
                    numWrite: 1,
                    numUsed: 1
                };

                if(pVariableList[i].hasInitializer()){
                    pVariableList[i].getInitializeExpr().addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
                }
            }
        }

    }

/**
     * Represent return expr;
     * return ExprInstruction
     */

    export class ReturnStmtInstruction extends StmtInstruction {
        private _pPreparedCode: string = "";
        private _isPositionReturn: bool = false;
        private _isColorReturn: bool = false;
        private _isOnlyReturn: bool = false;

        constructor () {
            super();
            this._pInstructionList = [null];
            this._sOperatorName = "return";
            this._eInstructionType = EAFXInstructionTypes.k_ReturnStmtInstruction;
        }

        prepareFor(eUsedMode: EFunctionType): void {
            var pReturn: IAFXTypedInstruction = <IAFXTypedInstruction>this.getInstructions()[0];
            if(isNull(pReturn)){
                return;
            }

            if(eUsedMode === EFunctionType.k_Vertex){
                if(pReturn.getType().isBase()){
                    this._isPositionReturn = true;
                }
                else {
                    this._isOnlyReturn = true;
                }
            }
            else if(eUsedMode === EFunctionType.k_Pixel){
                this._isColorReturn = true;
            }

            for(var i:  number  = 0; i < this._nInstructions; i++){
                this._pInstructionList[i].prepareFor(eUsedMode);
            }
        }

        toFinalCode(): string {
            if(this._isPositionReturn){
                return "Out.POSITION=" + this._pInstructionList[0].toFinalCode() + "; return;";
            }
            if(this._isColorReturn){
//return "gl_FragColor=" + this._pInstructionList[0].toFinalCode() + "; return;";
                return "resultAFXColor=" + this._pInstructionList[0].toFinalCode() + "; return;";
            }
            if(this._isOnlyReturn){
                return "return;"
            }

            if(this._nInstructions > 0){
                return "return " + this._pInstructionList[0].toFinalCode() + ";";
            }
            else {
                return "return;";
            }
        }
    }

    export class ExtractStmtInstruction extends ExprInstruction {
        private _pExtractInVar: IAFXVariableDeclInstruction = null;
        private _pExtractInExpr: IAFXExprInstruction = null;
        private _pExtactExpr: ExtractExprInstruction = null;

        constructor() {
            super();
            this._pInstructionList = [];
            this._eInstructionType = EAFXInstructionTypes.k_ExtractStmtInstruction;
        }

        generateStmtForBaseType(pVarDecl: IAFXVariableDeclInstruction,
                                pPointer: IAFXVariableDeclInstruction,
                                pBuffer: IAFXVariableDeclInstruction,
                                iPadding:  number , pOffset?: IAFXVariableDeclInstruction = null): void {
            var pVarType: IAFXVariableTypeInstruction = pVarDecl.getType();
            var pVarNameExpr: IAFXExprInstruction = pVarDecl._getFullNameExpr();
            if(pVarType.isComplex() || isNull(pVarNameExpr) || pVarType.getSize() ===  0xffffff ) {
                this.setError( 2274 );
                return;
            }

// var pPointer: IAFXVariableDeclInstruction = isDef(pPointer) ? pPointer : pVarType.getPointer();
// var pBuffer: IAFXVariableDeclInstruction = isDef(pBuffer) ?  pBuffer : pVarType.getVideoBuffer();
            var pBufferSampler: IAFXVariableDeclInstruction = pBuffer._getVideoBufferSampler();
            var pBufferHeader: IAFXVariableDeclInstruction = pBuffer._getVideoBufferHeader();

            var isArray: bool = pVarType.isNotBaseArray();
            var iLength:  number  = pVarType.getLength();
            var sCodeFragment: string = "";
            var pExtractType: IAFXVariableTypeInstruction = isArray ? pVarType.getArrayElementType() : pVarType;

            if(isArray){
                if(iLength ===  0xffffff ){
                    this.setError( 2274 );
                    return;
                }

                sCodeFragment = "for(int i=0;i<" + iLength.toString() + ";i++){";
                this.push(new SimpleInstruction(sCodeFragment), true);
            }

            this.push(pVarNameExpr, false);


            if(isArray){
                sCodeFragment = "[i]=";
            }
            else {
                sCodeFragment = "=";
            }

            this.push(new SimpleInstruction(sCodeFragment), true);

            var pExtractType: IAFXVariableTypeInstruction = isArray ? pVarType.getArrayElementType() : pVarType;
            var pExtractExpr: ExtractExprInstruction = new ExtractExprInstruction();
            var sPaddingExpr: string = "";

            if(iPadding > 0){
                sPaddingExpr = "+"+ iPadding.toString() + ".0";
            }
            else{
                sPaddingExpr = "";
            }

            if(isArray){
                sPaddingExpr += "+float(i*" + pExtractType.getSize().toString() + ")";
            }

            pExtractExpr.initExtractExpr(pExtractType, pPointer, pBuffer, sPaddingExpr, pOffset);

            if(pExtractExpr.isErrorOccured()){
                this.setError(pExtractExpr.getLastError().code,pExtractExpr.getLastError().info);
                return;
            }

            this.push(pExtractExpr, true);

            sCodeFragment = ";";

            if(isArray){
                sCodeFragment += "}";
            }

            this.push(new SimpleInstruction(sCodeFragment), true);

            this._pExtactExpr = pExtractExpr;
            this._pExtractInVar = pVarDecl;
            this._pExtractInExpr = pVarNameExpr;
        }

        toFinalCode(): string {
            var sCode: string = "";

            for(var i:  number  = 0; i < this._nInstructions; i++){
                sCode += this.getInstructions()[i].toFinalCode();
            }

            return sCode;
        }

        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
            this._pExtractInExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Write);
            this._pExtactExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
        }

        getExtractFunction(): IAFXFunctionDeclInstruction {
            return this._pExtactExpr.getExtractFunction();
        }
    }

/**
     * Represent empty statement only semicolon ;
     * ;
     */

    export class SemicolonStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = null;
            this._eInstructionType = EAFXInstructionTypes.k_SemicolonStmtInstruction;
        }

        toFinalCode(): string {
            return ";";
        }
    }
}



module akra.fx {
/**
	 * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]
	 * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction
	 */

	export class FunctionDeclInstruction extends DeclInstruction implements IAFXFunctionDeclInstruction {
		protected _pFunctionDefenition: FunctionDefInstruction = null;
		protected _pImplementation: StmtBlockInstruction = null;
		protected _eFunctionType: EFunctionType = EFunctionType.k_Function;

		protected _bUsedAsFunction: bool = false;
		protected _bUsedAsVertex: bool = false;
		protected _bUsedAsPixel: bool = false;
		protected _bCanUsedAsFunction: bool = true;

		protected _bUsedInVertex: bool = false;
		protected _bUsedInPixel: bool = false;

		protected _pParseNode: IParseNode = null;
		protected _iImplementationScope:  number  =  0xffffff ;

		protected _isInBlackList: bool = false;

		protected _pOutVariable: IAFXVariableDeclInstruction = null;

//Info about used data
		protected _pUsedFunctionMap: IAFXFunctionDeclMap = null;
		protected _pUsedFunctionList: IAFXFunctionDeclInstruction[] = null;

		protected _pAttributeVariableMap: IAFXVariableDeclMap = null;
		protected _pVaryingVariableMap: IAFXVariableDeclMap = null;

		protected _pUsedVarTypeMap: IAFXTypeUseInfoMap = null;

		protected _pSharedVariableMap: IAFXVariableDeclMap = null;
		protected _pGlobalVariableMap: IAFXVariableDeclMap = null;
		protected _pUniformVariableMap: IAFXVariableDeclMap = null;
		protected _pForeignVariableMap: IAFXVariableDeclMap = null;
		protected _pTextureVariableMap: IAFXVariableDeclMap = null;

// protected _pSharedVariableTypeList: IAFXVariableTypeInstruction[] = null;
// protected _pGlobalVariableTypeList: IAFXVariableTypeInstruction[] = null;
// protected _pUniformVariableTypeList: IAFXVariableTypeInstruction[] = null;
// protected _pForeignVariableTypeList: IAFXVariableTypeInstructionnt[] = null;

		protected _pUsedComplexTypeMap: IAFXTypeMap = null;

		protected _pAttributeVariableKeys:  number [] = null;
		protected _pVaryingVariableKeys:  number [] = null;

		protected _pSharedVariableKeys:  number [] = null;
		protected _pUniformVariableKeys:  number [] = null;
		protected _pForeignVariableKeys:  number [] = null;
		protected _pGlobalVariableKeys:  number [] = null;
		protected _pTextureVariableKeys:  number [] = null;
		protected _pUsedComplexTypeKeys:  number [] = null;

		protected _pVertexShader: IAFXFunctionDeclInstruction = null;
		protected _pPixelShader: IAFXFunctionDeclInstruction = null;

		private _pExtSystemTypeList: IAFXTypeDeclInstruction[] = null;
		private _pExtSystemFunctionList: IAFXFunctionDeclInstruction[] = null;
		private _pExtSystemMacrosList: IAFXSimpleInstruction[] = null;


		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_FunctionDeclInstruction;
		}

		toFinalCode(): string {
			var sCode = "";

			sCode += this._pFunctionDefenition.toFinalCode();
			sCode += this._pImplementation.toFinalCode();

			return sCode;
		}

		toFinalDefCode(): string {
			return this._pFunctionDefenition.toFinalCode();
		}

		/**@inline*/  getType(): IAFXTypeInstruction {
			return <IAFXTypeInstruction>this.getReturnType();
		}

		/**@inline*/  getName(): string {
			return this._pFunctionDefenition.getName();
		}

		/**@inline*/  getRealName(): string {
			return this._pFunctionDefenition.getRealName();
		}

		/**@inline*/  getNameId(): IAFXIdInstruction {
			return this._pFunctionDefenition.getNameId();
		}

		getArguments(): IAFXVariableDeclInstruction[] {
			return this._pFunctionDefenition.getArguments();
		}

		/**@inline*/  getNumNeededArguments():  number  {
			return this._pFunctionDefenition.getNumNeededArguments();
		}

		/**@inline*/  hasImplementation(): bool {
			return !isNull(this._pImplementation) || !isNull(this._pParseNode);
		}

		/**@inline*/  getReturnType(): IAFXVariableTypeInstruction {
			return this._pFunctionDefenition.getReturnType();
		}

		/**@inline*/  getFunctionType(): EFunctionType {
			return this._eFunctionType;
		}

		/**@inline*/  setFunctionType(eFunctionType: EFunctionType): void {
        	this._eFunctionType = eFunctionType;
        }

		/**@inline*/  _setImplementationScope(iScope:  number ): void {
			this._iImplementationScope = iScope;
		}

		/**@inline*/  _getImplementationScope():  number  {
			return this._iImplementationScope;
		}

		/**@inline*/  _setParseNode(pNode: IParseNode): void {
			this._pParseNode = pNode;
		}

		/**@inline*/  _getParseNode(): IParseNode {
			return this._pParseNode;
		}

		setFunctionDef(pFunctionDef: IAFXDeclInstruction): void {
			this._pFunctionDefenition = <FunctionDefInstruction>pFunctionDef;
			this._pInstructionList[0] = pFunctionDef;
			pFunctionDef.setParent(this);
			this._nInstructions = this._nInstructions === 0 ? 1 : this._nInstructions;
		}

		setImplementation(pImplementation: IAFXStmtInstruction): void {
			this._pImplementation = <StmtBlockInstruction>pImplementation;
			this._pInstructionList[1] = pImplementation;
			pImplementation.setParent(pImplementation);
			this._nInstructions = 2;

			this._pParseNode = null;
		}

		clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXFunctionDeclInstruction {
			var pClone: FunctionDeclInstruction = <FunctionDeclInstruction>super.clone(pRelationMap);

			if(!isNull(this._pOutVariable)){
				pClone._setOutVariable(<IAFXVariableDeclInstruction>pRelationMap[this._pOutVariable._getInstructionID()]);
			}

			var pUsedVarTypeMap: IAFXTypeUseInfoMap = this.cloneVarTypeUsedMap(this._pUsedVarTypeMap, pRelationMap);
			var pSharedVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pSharedVariableMap, pRelationMap);
			var pGlobalVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pGlobalVariableMap, pRelationMap);
			var pUniformVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pUniformVariableMap, pRelationMap);
			var pForeignVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pForeignVariableMap, pRelationMap);
			var pTextureVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pTextureVariableMap, pRelationMap);
			var pUsedComplexTypeMap: IAFXTypeMap = this.cloneTypeMap(this._pUsedComplexTypeMap, pRelationMap);

			pClone._setUsedFunctions(this._pUsedFunctionMap, this._pUsedFunctionList);
			pClone._setUsedVariableData(pUsedVarTypeMap,
										pSharedVariableMap,
										pGlobalVariableMap,
										pUniformVariableMap,
										pForeignVariableMap,
										pTextureVariableMap,
										pUsedComplexTypeMap);
			pClone._initAfterClone();

			return pClone;
		}

		_addOutVariable(pVariable: IAFXVariableDeclInstruction): bool {
			if(!isNull(this._pOutVariable)){
				return false;
			}

			if(!pVariable.getType().isEqual(this.getReturnType())){
				return false;
			}

			this._pOutVariable = pVariable;
			return true;
		}

		_getOutVariable(): IAFXVariableDeclInstruction{
			return this._pOutVariable;
		}

		_getVertexShader(): IAFXFunctionDeclInstruction {
			return this._pVertexShader;
		}

		_getPixelShader(): IAFXFunctionDeclInstruction {
			return this._pPixelShader;
		}

		_markUsedAs(eUsedType: EFunctionType): void {
			switch(eUsedType){
				case EFunctionType.k_Vertex:
					this._bUsedInVertex = true;
					this._bUsedAsVertex = true;
					break;
				case EFunctionType.k_Pixel:
					this._bUsedInPixel = true;
					this._bUsedAsPixel = true;
					break;
				case EFunctionType.k_Function:
					this._bUsedAsFunction = true;
					break;
			}
		}

		_isUsedAs(eUsedType: EFunctionType): bool {
			switch(eUsedType){
				case EFunctionType.k_Vertex:
					return this._bUsedAsVertex;
				case EFunctionType.k_Pixel:
					return this._bUsedAsPixel;
				case EFunctionType.k_Function:
					return this._bUsedAsFunction;
			}
		}

		_isUsedAsFunction(): bool {
			return this._bUsedAsFunction;
		}

		_isUsedAsVertex(): bool {
			return this._bUsedAsVertex;
		}

		_isUsedAsPixel(): bool {
			return this._bUsedAsPixel;
		}

		_markUsedInVertex(): void {
			this._bUsedInVertex = true;
		}

		_markUsedInPixel(): void {
			this._bUsedInPixel = true;
		}

		_isUsedInVertex(): bool {
			return this._bUsedInVertex;
		}

		_isUsedInPixel(): bool {
			return this._bUsedInPixel;
		}

		_isUsed(): bool{
			return this._bUsedAsFunction || this._bUsedAsVertex || this._bUsedAsPixel;
		}

		_checkVertexUsage(): bool {
			return this._isUsedInVertex() ? this._isForVertex() : true;
		}

		_checkPixelUsage(): bool {
			return this._isUsedInPixel() ? this._isForPixel() : true;
		}

		_checkDefenitionForVertexUsage(): bool {
			return this._pFunctionDefenition._checkForVertexUsage();
		}

		_checkDefenitionForPixelUsage(): bool {
			return this._pFunctionDefenition._checkForPixelUsage();
		}

		_canUsedAsFunction(): bool {
			return this._bCanUsedAsFunction && this._pFunctionDefenition._canUsedAsFunction();
		}

		_notCanUsedAsFunction(): void {
			this._bCanUsedAsFunction = false;
		}

		_addUsedFunction(pFunction: IAFXFunctionDeclInstruction): bool {
			if (pFunction._getInstructionType() === EAFXInstructionTypes.k_SystemFunctionInstruction &&
				!pFunction.isBuiltIn()) {

				this.addExtSystemFunction(pFunction);
				return true;
			}

			if(isNull(this._pUsedFunctionMap)){
				this._pUsedFunctionMap = <IAFXFunctionDeclMap>{};
				this._pUsedFunctionList = [];
			}

			var iFuncId:  number  = pFunction._getInstructionID();

			if(!isDef(this._pUsedFunctionMap[iFuncId])){
				this._pUsedFunctionMap[iFuncId] = pFunction;
				this._pUsedFunctionList.push(pFunction);
				return true;
			}

			return false;
		}

		_addUsedVariable(pVariable: IAFXVariableDeclInstruction): void {

		}

		_getUsedFunctionList(): IAFXFunctionDeclInstruction[] {
			return this._pUsedFunctionList;
		}

		_isBlackListFunction(): bool {
			return this._isInBlackList;
		}

		_addToBlackList(): void {
			this._isInBlackList = true;
		}

		_getStringDef(): string {
			return this._pFunctionDefenition._getStringDef();
		}

		_convertToVertexShader(): IAFXFunctionDeclInstruction {
			var pShader: FunctionDeclInstruction = null;

			if((!this._canUsedAsFunction() || !this._isUsedAsFunction()) &&
			   (!this._isUsedInPixel())){
			   	pShader = this;
			}
			else {
				pShader = <FunctionDeclInstruction>this.clone();
			}

			pShader._prepareForVertex();
			this._pVertexShader = pShader;

			return pShader;
		}

        _convertToPixelShader(): IAFXFunctionDeclInstruction {
        	var pShader: FunctionDeclInstruction = null;

        	if((!this._canUsedAsFunction() || !this._isUsedAsFunction()) &&
			   (!this._isUsedInVertex())){
			   	pShader = this;
			}
			else {
				pShader = <FunctionDeclInstruction>this.clone();
			}

			pShader._prepareForPixel();
			this._pPixelShader = pShader;

			return pShader;
        }

        _prepareForVertex(): void {
        	this.setFunctionType(EFunctionType.k_Vertex);

        	var pShaderInputParamList: IAFXVariableDeclInstruction[] = this._pFunctionDefenition.getParameListForShaderInput();
        	for(var i:  number  = 0; i < pShaderInputParamList.length; i++){
        		var pParamType: IAFXVariableTypeInstruction = pShaderInputParamList[i].getType();

        		if (pParamType.isComplex() &&
        			isDef(this._pUsedVarTypeMap[pParamType._getInstructionID()]) &&
        			this._pUsedVarTypeMap[pParamType._getInstructionID()].isRead) {

        				this.setError( 2301 , { funcName: this.getName() });
        				return;
        		}
        	}

        	var pOutVariable: IAFXVariableDeclInstruction = this._getOutVariable();

        	if(!isNull(pOutVariable)){
        		if (isDef(this._pUsedVarTypeMap[pOutVariable.getType()._getInstructionID()]) &&
        			this._pUsedVarTypeMap[pOutVariable.getType()._getInstructionID()].isRead) {

        			this.setError( 2302 , { funcName: this.getName() });
        			return;
        		}

        		pOutVariable._markAsShaderOutput(true);
        	}

        	if(this._pFunctionDefenition.isComplexShaderInput()){
        		pShaderInputParamList[0].setVisible(false);
        	}

        	this._pImplementation.prepareFor(EFunctionType.k_Vertex);
        	this._pFunctionDefenition.markAsShaderDef(true);
        	this.generatesVertexAttrubutes();
        	this.generateVertexVaryings();
        }

        _prepareForPixel(): void {
        	this.setFunctionType(EFunctionType.k_Pixel);

        	var pShaderInputParamList: IAFXVariableDeclInstruction[] = this._pFunctionDefenition.getParameListForShaderInput();
        	for(var i:  number  = 0; i < pShaderInputParamList.length; i++){
        		var pParamType: IAFXVariableTypeInstruction = pShaderInputParamList[i].getType();

        		if (pParamType.isComplex() &&
        			isDef(this._pUsedVarTypeMap[pParamType._getInstructionID()]) &&
        			this._pUsedVarTypeMap[pParamType._getInstructionID()].isRead) {

        				this.setError( 2301 , { funcName: this.getName() });
        				return;
        		}
        	}

        	if(this._pFunctionDefenition.isComplexShaderInput()){
        		pShaderInputParamList[0].setVisible(false);
        	}

        	this._pImplementation.prepareFor(EFunctionType.k_Pixel);
        	this._pFunctionDefenition.markAsShaderDef(true);

        	this.generatePixelVaryings();
        }

        _setOutVariable(pVar: IAFXVariableDeclInstruction): void {
        	this._pOutVariable = pVar;
        }

        _setUsedFunctions(pUsedFunctionMap: IAFXFunctionDeclMap,
        				  pUsedFunctionList: IAFXFunctionDeclInstruction[]): void {
        	this._pUsedFunctionMap = pUsedFunctionMap;
        	this._pUsedFunctionList = pUsedFunctionList;
        }

        _setUsedVariableData(pUsedVarTypeMap: IAFXTypeUseInfoMap,
							pSharedVariableMap: IAFXVariableDeclMap,
							pGlobalVariableMap: IAFXVariableDeclMap,
							pUniformVariableMap: IAFXVariableDeclMap,
							pForeignVariableMap: IAFXVariableDeclMap,
							pTextureVariableMap: IAFXVariableDeclMap,
							pUsedComplexTypeMap: IAFXTypeMap): void {
        	this._pUsedVarTypeMap = pUsedVarTypeMap;
        	this._pSharedVariableMap = pSharedVariableMap;
        	this._pGlobalVariableMap = pGlobalVariableMap;
        	this._pUniformVariableMap = pUniformVariableMap;
        	this._pForeignVariableMap = pForeignVariableMap;
        	this._pTextureVariableMap = pTextureVariableMap;
        	this._pUsedComplexTypeMap = pUsedComplexTypeMap;
        }

        _initAfterClone(): void{
        	this._pFunctionDefenition = <FunctionDefInstruction>this._pInstructionList[0];
        	this._pImplementation = <StmtBlockInstruction>this._pInstructionList[1];
        }

        _generateInfoAboutUsedData(): void {
        	if(!isNull(this._pUsedVarTypeMap)){
        		return;
        	}

        	var pUsedData: IAFXTypeUseInfoMap = <IAFXTypeUseInfoMap>{};
        	this._pImplementation.addUsedData(pUsedData);

        	this._pUsedVarTypeMap = pUsedData;

        	if(isNull(this._pUsedComplexTypeMap)){
        		this._pSharedVariableMap = <IAFXVariableDeclMap>{};
				this._pGlobalVariableMap = <IAFXVariableDeclMap>{};
				this._pUniformVariableMap = <IAFXVariableDeclMap>{};
				this._pForeignVariableMap = <IAFXVariableDeclMap>{};
				this._pTextureVariableMap = <IAFXVariableDeclMap>{};
				this._pUsedComplexTypeMap = <IAFXTypeMap>{};
        	}

//this.addUsedComplexType(this.getReturnType().getBaseType());

        	for(var i in pUsedData) {
        		var pAnalyzedInfo: IAFXTypeUseInfoContainer = pUsedData[i];
        		var pAnalyzedType: IAFXVariableTypeInstruction = pAnalyzedInfo.type;

        		if(pAnalyzedType._isInGlobalScope()){
        			this.addGlobalVariableType(pAnalyzedType, pAnalyzedInfo.isWrite, pAnalyzedInfo.isRead);
        		}
        		else if(pAnalyzedType.isUniform()){
        			this.addUniformParameter(pAnalyzedType);
        		}
        		else if(pAnalyzedType._getScope() < this._getImplementationScope()){
        			if(!this._isUsedAsFunction()){
        				if (!isNull(this._getOutVariable()) &&
        					this._getOutVariable().getType() !== pAnalyzedType){

        					this.addUsedComplexType(pAnalyzedType.getBaseType());
        				}
        			}
        		}
        	}
        	if(!isNull(this._pUsedFunctionList)){
	        	for(var j:  number  = 0; j < this._pUsedFunctionList.length; j++){
	        		this.addUsedInfoFromFunction(this._pUsedFunctionList[j]);
	        	}
        	}
        }

        /**@inline*/  _getAttributeVariableMap(): IAFXVariableDeclMap {
        	return this._pAttributeVariableMap;
        }

        /**@inline*/  _getVaryingVariableMap(): IAFXVariableDeclMap {
        	return this._pVaryingVariableMap;
        }

        /**@inline*/  _getSharedVariableMap(): IAFXVariableDeclMap{
        	return this._pSharedVariableMap;
        }

        /**@inline*/  _getGlobalVariableMap(): IAFXVariableDeclMap{
        	return this._pGlobalVariableMap;
        }

        /**@inline*/  _getUniformVariableMap(): IAFXVariableDeclMap{
        	return this._pUniformVariableMap;
        }

        /**@inline*/  _getForeignVariableMap(): IAFXVariableDeclMap{
        	return this._pForeignVariableMap;
        }

        /**@inline*/  _getTextureVariableMap(): IAFXVariableDeclMap{
        	return this._pTextureVariableMap;
        }

        /**@inline*/  _getUsedComplexTypeMap(): IAFXTypeMap{
        	return this._pUsedComplexTypeMap;
        }

        _getAttributeVariableKeys():  number [] {
        	if(isNull(this._pAttributeVariableKeys) && !isNull(this._pAttributeVariableMap)){
        		this._pAttributeVariableKeys = < number []><any>Object.keys(this._pAttributeVariableMap);
        	}

        	return this._pAttributeVariableKeys;
        }

        _getVaryingVariableKeys():  number [] {
        	if(isNull(this._pVaryingVariableKeys) && !isNull(this._pVaryingVariableMap)){
        		this._pVaryingVariableKeys = < number []><any>Object.keys(this._pVaryingVariableMap);
        	}

        	return this._pVaryingVariableKeys;
        }


        _getSharedVariableKeys():  number [] {
        	if(isNull(this._pSharedVariableKeys) && !isNull(this._pSharedVariableMap)){
        		this._pSharedVariableKeys = < number []><any[]>Object.keys(this._pSharedVariableMap);
        	}

        	return this._pSharedVariableKeys;
        }

        _getUniformVariableKeys():  number [] {
        	if(isNull(this._pUniformVariableKeys) && !isNull(this._pUniformVariableMap)){
        		this._pUniformVariableKeys = < number []><any[]>Object.keys(this._pUniformVariableMap);
        	}

        	return this._pUniformVariableKeys;
        }

        _getForeignVariableKeys():  number [] {
        	if(isNull(this._pForeignVariableKeys) && !isNull(this._pForeignVariableMap)){
        		this._pForeignVariableKeys = < number []><any[]>Object.keys(this._pForeignVariableMap);
        	}

        	return this._pForeignVariableKeys;
        }

        _getGlobalVariableKeys():  number [] {
        	if(isNull(this._pGlobalVariableKeys) && !isNull(this._pGlobalVariableMap)){
        		this._pGlobalVariableKeys = < number []><any[]>Object.keys(this._pGlobalVariableMap);
        	}

        	return this._pGlobalVariableKeys;
        }

        _getTextureVariableKeys():  number [] {
        	if(isNull(this._pTextureVariableKeys) && !isNull(this._pTextureVariableMap)){
        		this._pTextureVariableKeys = < number []><any[]>Object.keys(this._pTextureVariableMap);
        	}

        	return this._pTextureVariableKeys;
        }

        _getUsedComplexTypeKeys():  number [] {
        	if(isNull(this._pUsedComplexTypeKeys)){
        		this._pUsedComplexTypeKeys = < number []><any[]>Object.keys(this._pUsedComplexTypeMap);
        	}

        	return this._pUsedComplexTypeKeys;
        }

        _getExtSystemFunctionList(): IAFXFunctionDeclInstruction[] {
        	return this._pExtSystemFunctionList;
        }

        _getExtSystemMacrosList(): IAFXSimpleInstruction[] {
        	return this._pExtSystemMacrosList;
        }

        _getExtSystemTypeList(): IAFXTypeDeclInstruction[] {
        	return this._pExtSystemTypeList;
        }

        private generatesVertexAttrubutes(): void {
        	var pShaderInputParamList: IAFXVariableDeclInstruction[] = this._pFunctionDefenition.getParameListForShaderInput();
        	var isComplexInput: bool = this._pFunctionDefenition.isComplexShaderInput();

        	this._pAttributeVariableMap = <IAFXVariableDeclMap>{};

        	if(isComplexInput){
        		var pContainerVariable: IAFXVariableDeclInstruction = pShaderInputParamList[0];
        		var pContainerType: IAFXVariableTypeInstruction = pContainerVariable.getType();

        		var pAttributeNames: string[] = pContainerType.getFieldNameList();

        		for(var i:  number  = 0; i < pAttributeNames.length; i++){
        			var pAttr: IAFXVariableDeclInstruction = pContainerType.getField(pAttributeNames[i]);

        			if(!this.isVariableTypeUse(pAttr.getType())){
        				continue;
        			}

        			this._pAttributeVariableMap[pAttr._getInstructionID()] = pAttr;
        			this.generateExtractBlockForAttribute(pAttr);
        		}
        	}
        	else {
        		for(var i:  number  = 0; i < pShaderInputParamList.length; i++){
        			var pAttr: IAFXVariableDeclInstruction = pShaderInputParamList[i];

        			if(!this.isVariableTypeUse(pAttr.getType())){
        				continue;
        			}

        			this._pAttributeVariableMap[pAttr._getInstructionID()] = pAttr;
        			this.generateExtractBlockForAttribute(pAttr);
        		}
        	}

        	this._pAttributeVariableKeys = this._getAttributeVariableKeys();
        }

        private generateVertexVaryings(): void {
        	if(isNull(this._getOutVariable())){
        		return;
        	}

        	this._pVaryingVariableMap = <IAFXVariableDeclMap>{};

			var pContainerVariable: IAFXVariableDeclInstruction = this._getOutVariable();
        	var pContainerType: IAFXVariableTypeInstruction = pContainerVariable.getType();


        	var pVaryingNames: string[] = pContainerType.getFieldNameList();

        	for(var i:  number  = 0; i < pVaryingNames.length; i++){
    			var pVarying: IAFXVariableDeclInstruction = pContainerType.getField(pVaryingNames[i]);

    			if(!this.isVariableTypeUse(pVarying.getType())){
    				continue;
    			}

    			this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
    		}

    		this._pVaryingVariableKeys = this._getVaryingVariableKeys();
        }

        private generatePixelVaryings(): void {
        	var pShaderInputParamList: IAFXVariableDeclInstruction[] = this._pFunctionDefenition.getParameListForShaderInput();
        	var isComplexInput: bool = this._pFunctionDefenition.isComplexShaderInput();

        	this._pVaryingVariableMap = <IAFXVariableDeclMap>{};

        	if(isComplexInput){
        		var pContainerVariable: IAFXVariableDeclInstruction = pShaderInputParamList[0];
        		var pContainerType: IAFXVariableTypeInstruction = pContainerVariable.getType();

        		var pVaryingNames: string[] = pContainerType.getFieldNameList();

        		for(var i:  number  = 0; i < pVaryingNames.length; i++){
        			var pVarying: IAFXVariableDeclInstruction = pContainerType.getField(pVaryingNames[i]);

        			if(!this.isVariableTypeUse(pVarying.getType())){
        				continue;
        			}

        			this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
        		}
        	}
        	else {
        		for(var i:  number  = 0; i < pShaderInputParamList.length; i++){
        			var pVarying: IAFXVariableDeclInstruction = pShaderInputParamList[i];

        			if(!this.isVariableTypeUse(pVarying.getType())){
        				continue;
        			}

        			this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
        		}
        	}

        	this._pVaryingVariableKeys = this._getVaryingVariableKeys();
        }

        private cloneVarTypeUsedMap(pMap: IAFXTypeUseInfoMap, pRelationMap: IAFXInstructionMap): IAFXTypeUseInfoMap{
        	var pCloneMap: IAFXTypeUseInfoMap = <IAFXTypeUseInfoMap>{};

        	for(var j in pMap){
        		var pType: IAFXVariableTypeInstruction = isDef(pRelationMap[j]) ? pRelationMap[j] : pMap[j].type;
    			var id:  number  = pType._getInstructionID();
    			pCloneMap[id] = {
    				type: pType,
    				isRead: pMap[j].isRead,
					isWrite: pMap[j].isWrite,
					numRead: pMap[j].numRead,
					numWrite: pMap[j].numWrite,
					numUsed: pMap[j].numUsed
    			}
        	}

        	return pCloneMap;
        }

        private cloneVarDeclMap(pMap: IAFXVariableDeclMap, pRelationMap: IAFXInstructionMap): IAFXVariableDeclMap {
        	var pCloneMap: IAFXVariableDeclMap = <IAFXVariableDeclMap>{};

        	for(var i in pMap){
        		var pVar: IAFXVariableDeclInstruction = isDef(pRelationMap[i]) ? pRelationMap[i] : pMap[i];

        		if(!isNull(pVar)){
        			var id:  number  = pVar._getInstructionID();
        			pCloneMap[id] = pVar;
        		}
        	}

        	return pCloneMap;
        }

        private cloneTypeMap(pMap: IAFXTypeMap, pRelationMap: IAFXInstructionMap): IAFXTypeMap {
        	var pCloneMap: IAFXTypeMap = <IAFXTypeMap>{};

        	for(var i in pMap){
        		var pVar: IAFXTypeInstruction = (isDef(pRelationMap[i]) ? pRelationMap[i] : pMap[i]);
        		var id:  number  = pVar._getInstructionID();
        		pCloneMap[id] = pVar;
        	}

        	return pCloneMap;
        }

        private addGlobalVariableType(pVariableType: IAFXVariableTypeInstruction,
        							  isWrite: bool, isRead: bool): void {
        	if(!pVariableType.isFromVariableDecl()){
        		return;
        	}

        	var pVariable: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>pVariableType._getParentVarDecl();
        	var pMainVariable: IAFXVariableDeclInstruction = pVariableType._getMainVariable();
        	var iMainVar:  number  = pMainVariable._getInstructionID();
        	var iVar:  number  = pVariable._getInstructionID();

        	if(pMainVariable.getType().isShared()){
// this._pSharedVariableMap[iVar] = pVariable;
        		this._pSharedVariableMap[iMainVar] = pMainVariable;
        	}
        	else if(pMainVariable.getType().isForeign()){
        		this._pForeignVariableMap[iMainVar] = pMainVariable;
        	}
        	else if(isWrite || pMainVariable.getType().isConst()){
        		this._pGlobalVariableMap[iMainVar] = pMainVariable;
        		if(isDefAndNotNull(this._pUniformVariableMap[iMainVar])){
        			this._pUniformVariableMap[iMainVar] = null;
        		}
        	}
        	else {
        		if(!isDef(this._pGlobalVariableMap[iMainVar])){
        			this._pUniformVariableMap[iMainVar] = pMainVariable;

        			if(!pMainVariable.getType().isComplex() && pMainVariable.hasConstantInitializer()){
		        		pMainVariable.prepareDefaultValue();
		        	}
        		}
        	}

        	if(pVariable.isSampler() && pVariable.hasInitializer()){
        		var pInitExpr: IAFXInitExprInstruction = pVariable.getInitializeExpr();
        		var pTexture: IAFXVariableDeclInstruction = null;
        		var pSamplerStates: SamplerStateBlockInstruction = null;

        		if(pVariableType.isArray()){
        			var pList: IAFXInitExprInstruction[] = <IAFXInitExprInstruction[]>pInitExpr.getInstructions();
        			for(var i:  number  = 0; i < pList.length; i++){
        				pSamplerStates = <SamplerStateBlockInstruction>pList[i].getInstructions()[0];
        				pTexture = pSamplerStates.getTexture();

        				if(!isNull(pTexture)){
        					this._pTextureVariableMap[pTexture._getInstructionID()] = pTexture;
        				}
        			}
        		}
        		else {
        			pSamplerStates = <SamplerStateBlockInstruction>pInitExpr.getInstructions()[0];
        			pTexture = pSamplerStates.getTexture();

        			if(!isNull(pTexture)){
    					this._pTextureVariableMap[pTexture._getInstructionID()] = pTexture;
    				}
        		}
        	}

// this.addUsedComplexType(pMainVariable.getType().getBaseType());
        }

        private addUniformParameter(pType: IAFXVariableTypeInstruction): void {
        	var pMainVariable: IAFXVariableDeclInstruction = pType._getMainVariable();
        	var iMainVar:  number  = pMainVariable._getInstructionID();

        	if(isDef(this._pGlobalVariableMap[iMainVar])){
        		{ logger.setSourceLocation( "fx/FunctionInstruction.ts" , 847 ); logger.error("UNEXPECTED ERROR WITH UNIFORM_PARAMETER"); } ;
        	}

        	this._pUniformVariableMap[iMainVar] = pMainVariable;
        	this.addUsedComplexType(pMainVariable.getType().getBaseType());

        	if(!pMainVariable.getType().isComplex() && pMainVariable.hasConstantInitializer()){
        		pMainVariable.prepareDefaultValue();
        	}
        }

        private addUsedComplexType(pType: IAFXTypeInstruction): void {
        	if(pType.isBase() || isDef(this._pUsedComplexTypeMap[pType._getInstructionID()])){
        		return;
        	}

        	this._pUsedComplexTypeMap[pType._getInstructionID()] = pType;

        	var pFieldNameList: string[] = pType.getFieldNameList();

        	for(var i:  number  = 0; i < pFieldNameList.length; i++){
        		this.addUsedComplexType(pType.getFieldType(pFieldNameList[i]).getBaseType());
        	}
        }

        private addUsedInfoFromFunction(pFunction: IAFXFunctionDeclInstruction): void {
        	pFunction._generateInfoAboutUsedData();

    		var pSharedVarMap: IAFXVariableDeclMap = pFunction._getSharedVariableMap();
    		var pGlobalVarMap: IAFXVariableDeclMap = pFunction._getGlobalVariableMap();
    		var pUniformVarMap: IAFXVariableDeclMap = pFunction._getUniformVariableMap();
    		var pForeignVarMap: IAFXVariableDeclMap = pFunction._getForeignVariableMap();
    		var pTextureVarMap: IAFXVariableDeclMap = pFunction._getTextureVariableMap();
    		var pUsedComplexTypeMap: IAFXTypeMap = pFunction._getUsedComplexTypeMap();

    		for(var j in pSharedVarMap){
    			this._pSharedVariableMap[pSharedVarMap[j]._getInstructionID()] = pSharedVarMap[j];
    		}

    		for(var j in pForeignVarMap){
    			this._pForeignVariableMap[pForeignVarMap[j]._getInstructionID()] = pForeignVarMap[j];
    		}

    		for(var j in pTextureVarMap){
    			this._pTextureVariableMap[pTextureVarMap[j]._getInstructionID()] = pTextureVarMap[j];
    		}

    		for(var j in pGlobalVarMap){
    			this._pGlobalVariableMap[pGlobalVarMap[j]._getInstructionID()] = pGlobalVarMap[j];

    			if(isDefAndNotNull(this._pUniformVariableMap[pGlobalVarMap[j]._getInstructionID()])){
    				this._pUniformVariableMap[pGlobalVarMap[j]._getInstructionID()] = null;
    			}
    		}

    		for(var j in pUniformVarMap){
    			if(!isDef(this._pGlobalVariableMap[pUniformVarMap[j]._getInstructionID()])){
    				this._pUniformVariableMap[pUniformVarMap[j]._getInstructionID()] = pUniformVarMap[j];
    			}
    		}

    		for(var j in pUsedComplexTypeMap){
    			this._pUsedComplexTypeMap[pUsedComplexTypeMap[j]._getInstructionID()] = pUsedComplexTypeMap[j];
    		}

    		this.addExtSystemFunction(pFunction);
        }

        private addExtSystemFunction(pFunction: IAFXFunctionDeclInstruction): void {
        	if(isNull(this._pExtSystemFunctionList)){
        		this._pExtSystemFunctionList = [];
        		this._pExtSystemTypeList = [];
        		this._pExtSystemMacrosList = [];
        	}

        	if(pFunction._getInstructionType() === EAFXInstructionTypes.k_SystemFunctionInstruction){
	        	if(this._pExtSystemFunctionList.indexOf(pFunction) !== -1){
	        		return;
	        	}

	        	this._pExtSystemFunctionList.push(pFunction);
        	}

        	var pTypes = pFunction._getExtSystemTypeList();
			var pMacroses = pFunction._getExtSystemMacrosList();
			var pFunctions = pFunction._getExtSystemFunctionList();

			if(!isNull(pTypes)){
				for(var j:  number  = 0; j < pTypes.length; j++){
					if(this._pExtSystemTypeList.indexOf(pTypes[j]) === -1){
						this._pExtSystemTypeList.push(pTypes[j]);
					}
				}
			}

			if(!isNull(pMacroses)){
				for(var j:  number  = 0; j < pMacroses.length; j++){
					if(this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1){
						this._pExtSystemMacrosList.push(pMacroses[j]);
					}
				}
			}

			if(!isNull(pFunctions)){
				for(var j:  number  = 0; j < pFunctions.length; j++){
					if(this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1){
						this._pExtSystemFunctionList.unshift(pFunctions[j]);
					}
				}
			}
        }

        private isVariableTypeUse(pVariableType: IAFXVariableTypeInstruction): bool {
        	var id:  number  = pVariableType._getInstructionID();

        	if(!isDef(this._pUsedVarTypeMap[id])){
        		return false;
        	}

        	if(this._pUsedVarTypeMap[id].numUsed === 0){
        		return false;
        	}

        	return true;
        }

        private generateExtractBlockForAttribute(pAttr: IAFXVariableDeclInstruction): IAFXInstruction {
        	if(!pAttr.getType().isPointer()){
        		return null;
        	}

        	var pExtractCollector: IAFXInstruction = new InstructionCollector();
        	var pMainPointer: IAFXVariableDeclInstruction = pAttr.getType()._getMainPointer();

        	pAttr._setAttrExtractionBlock(pExtractCollector);

        	this.generateExtractStmtFromPointer(pMainPointer, null, 0, pExtractCollector);

        	pAttr.getType().getSubVarDecls();

        	return pExtractCollector;

        }

        private generateExtractStmtFromPointer(pPointer: IAFXVariableDeclInstruction,
        									   pOffset: IAFXVariableDeclInstruction,
        									   iDepth:  number ,
        									   pCollector: IAFXInstruction): void {
        	var pPointerType: IAFXVariableTypeInstruction = pPointer.getType();
        	var pWhatExtracted: IAFXVariableDeclInstruction = pPointerType._getDownPointer();
        	var pWhatExtractedType: IAFXVariableTypeInstruction = null;

        	while(!isNull(pWhatExtracted)){
        		pWhatExtractedType = pWhatExtracted.getType();

        		if(!pWhatExtractedType.isPointIndex() && iDepth === 0){
        			pOffset = this.createOffsetForAttr(pWhatExtracted);
        		}

        		if(!pWhatExtractedType.isComplex()){
        			var pSingleExtract: ExtractStmtInstruction = new ExtractStmtInstruction();
        			pSingleExtract.generateStmtForBaseType(
        									pWhatExtracted,
        									pWhatExtractedType.getPointer(),
        									pWhatExtractedType.getVideoBuffer(), 0,
        									pWhatExtractedType.isPointIndex() ? null : pOffset);

        			this._addUsedFunction(pSingleExtract.getExtractFunction());
        			pCollector.push(pSingleExtract, true);
        		}
        		else {
        			iDepth++;
        			this.generateExtractStmtForComplexVar(
        									pWhatExtracted,
        									iDepth <= 1 ? pOffset : null,
        									iDepth, pCollector,
        									pWhatExtractedType.getPointer(),
        									pWhatExtractedType.getVideoBuffer(), 0);
        		}

        		pWhatExtracted = pWhatExtractedType._getDownPointer();
        	}
        }

        private generateExtractStmtForComplexVar(pVarDecl: IAFXVariableDeclInstruction,
        										 pOffset: IAFXVariableDeclInstruction,
        										 iDepth:  number ,
        										 pCollector: IAFXInstruction,
        										 pPointer: IAFXVariableDeclInstruction,
        										 pBuffer: IAFXVariableDeclInstruction,
        										 iPadding:  number ): void {

        	var pVarType: IAFXVariableTypeInstruction = pVarDecl.getType();
        	var pFieldNameList: string[] = pVarType.getFieldNameList();
        	var pField: IAFXVariableDeclInstruction = null;
        	var pFieldType: IAFXVariableTypeInstruction = null;
        	var pSingleExtract: ExtractStmtInstruction = null;
        	var isNeedPadding: bool = false;

        	for(var i:  number  = 0; i < pFieldNameList.length; i++){
        		pField = pVarType.getField(pFieldNameList[i]);

        		if(isNull(pField)){
        			continue;
				}

 				pFieldType = pField.getType();

 				if(iDepth <= 1){
 					pOffset = this.createOffsetForAttr(pField);
 					isNeedPadding = false;
 				}
 				else {
 					isNeedPadding = true;
 				}

 				if(pFieldType.isPointer()){
 					var pFieldPointer: IAFXVariableDeclInstruction = pFieldType._getMainPointer();
 					pSingleExtract = new ExtractStmtInstruction();
 					pSingleExtract.generateStmtForBaseType(pFieldPointer, pPointer, pFieldType.getVideoBuffer(),
 														   isNeedPadding ? (iPadding + pFieldType.getPadding()) : 0,
 														   pOffset);

 					this._addUsedFunction(pSingleExtract.getExtractFunction());

 					pCollector.push(pSingleExtract, true);
 					this.generateExtractStmtFromPointer(pFieldPointer, pOffset, iDepth, pCollector);
 				}
 				else if(pFieldType.isComplex()) {
 					iDepth++;
 					this.generateExtractStmtForComplexVar(pField, pOffset, iDepth, pCollector,
 														  pPointer, pBuffer,
 														  isNeedPadding ? (iPadding + pFieldType.getPadding()) : 0);
 				}
 				else {
 					pSingleExtract = new ExtractStmtInstruction();
        			pSingleExtract.generateStmtForBaseType(pField, pPointer, pBuffer,
        												   isNeedPadding ? (iPadding + pFieldType.getPadding()) : 0,
        												   pOffset);

        			this._addUsedFunction(pSingleExtract.getExtractFunction());

        			pCollector.push(pSingleExtract, true);
 				}
 	       	}
        }

        private createOffsetForAttr(pAttr: IAFXVariableDeclInstruction): IAFXVariableDeclInstruction {
        	var pOffset: IAFXVariableDeclInstruction = new VariableDeclInstruction();
        	var pOffsetType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
        	var pOffsetId: IAFXIdInstruction = new IdInstruction();

        	pOffsetType.pushType(Effect.getSystemType("float"));
        	pOffsetType.addUsage("uniform");

        	pOffsetId.setName("offset");
        	pOffsetId.setRealName(pAttr.getRealName() + "_o");

        	pOffset.push(pOffsetType, true);
        	pOffset.push(pOffsetId, true);

        	pOffset.setParent(pAttr);
        	pOffset.setSemantic(pAttr.getSemantic());

        	pAttr.getType()._addAttrOffset(pOffset);

        	return pOffset;
        }


	}

	export class SystemFunctionInstruction extends DeclInstruction implements IAFXFunctionDeclInstruction {
	    private _pExprTranslator: ExprTemplateTranslator = null;
	    private _pName: IAFXIdInstruction = null;
	    private _pReturnType: VariableTypeInstruction = null;
	    private	_pArguments: IAFXTypedInstruction[] = null;

	    private _sDefinition: string = "";
	    private _sImplementation: string = "";

	    private _pExtSystemTypeList: IAFXTypeDeclInstruction[] = null;
	    private _pExtSystemFunctionList: IAFXFunctionDeclInstruction[] = null;
	    private _pExtSystemMacrosList: IAFXSimpleInstruction[] = null;

		constructor(sName: string, pReturnType: IAFXTypeInstruction,
					pExprTranslator: ExprTemplateTranslator,
					pArgumentTypes: IAFXTypeInstruction[]) {
			super();

			this._eInstructionType = EAFXInstructionTypes.k_SystemFunctionInstruction;

			this._pName = new IdInstruction();
			this._pName.setName(sName);
			this._pName.setParent(this);

			this._pReturnType = new VariableTypeInstruction();
			this._pReturnType.pushType(pReturnType);
			this._pReturnType.setParent(this);

			this._pArguments = [];

			if(!isNull(pArgumentTypes)){
				for(var i:  number  = 0; i < pArgumentTypes.length; i++){
					var pArgument: TypedInstruction = new TypedInstruction();
					pArgument.setType(pArgumentTypes[i]);
					pArgument.setParent(this);

					this._pArguments.push(pArgument);
				}
			}

			this._pExprTranslator = pExprTranslator;
		}

		setDeclCode(sDefenition: string, sImplementation: string){
			this._sDefinition = sDefenition;
			this._sImplementation = sImplementation;
		}

		toFinalCode() : string {
			return this._sDefinition + this._sImplementation;
		}

		toFinalDefCode(): string {
			return this._sDefinition;
		}

		setUsedSystemData(pTypeList: IAFXTypeDeclInstruction[],
						  pFunctionList: IAFXFunctionDeclInstruction[],
						  pMacrosList: IAFXSimpleInstruction[]): void {

			this._pExtSystemTypeList = pTypeList;
			this._pExtSystemFunctionList = pFunctionList;
			this._pExtSystemMacrosList = pMacrosList;
		}

		closeSystemDataInfo(): void {
			for(var i:  number  = 0; i < this._pExtSystemFunctionList.length; i++){
				var pFunction: IAFXFunctionDeclInstruction = this._pExtSystemFunctionList[i];

				var pTypes = pFunction._getExtSystemTypeList();
				var pMacroses = pFunction._getExtSystemMacrosList();
				var pFunctions = pFunction._getExtSystemFunctionList();

				for(var j:  number  = 0; j < pTypes.length; j++){
					if(this._pExtSystemTypeList.indexOf(pTypes[j]) === -1){
						this._pExtSystemTypeList.push(pTypes[j]);
					}
				}

				for(var j:  number  = 0; j < pMacroses.length; j++){
					if(this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1){
						this._pExtSystemMacrosList.push(pMacroses[j]);
					}
				}

				for(var j:  number  = 0; j < pFunctions.length; j++){
					if(this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1){
						this._pExtSystemFunctionList.unshift(pFunctions[j]);
					}
				}
			}
		}

		setExprTranslator(pExprTranslator: ExprTemplateTranslator): void {
			this._pExprTranslator = pExprTranslator;
		}

		getNameId(): IAFXIdInstruction {
			return this._pName;
		}

		getArguments(): IAFXTypedInstruction[] {
			return this._pArguments;
		}

		/**@inline*/  getNumNeededArguments():  number  {
			return this._pArguments.length;
		}

		/**@inline*/  hasImplementation(): bool {
			return true;
		}

		/**@inline*/  getType(): IAFXVariableTypeInstruction {
			return this.getReturnType();
		}

		/**@inline*/  getReturnType(): IAFXVariableTypeInstruction {
			return this._pReturnType;
		}

		/**@inline*/  getFunctionType(): EFunctionType {
			return EFunctionType.k_Function;
		}

		/**@inline*/  setFunctionType(eFunctionType: EFunctionType): void {
        }

		closeArguments(pArguments: IAFXInstruction[]): IAFXInstruction[]{
			return this._pExprTranslator.toInstructionList(pArguments);
		}

		setFunctionDef(pFunctionDef: IAFXDeclInstruction): void {
		}

		setImplementation(pImplementation: IAFXStmtInstruction): void {
		}

		/**@inline*/  clone(pRelationMap?: IAFXInstructionMap): SystemFunctionInstruction {
			return this;
		}

		_addOutVariable(pVariable: IAFXVariableDeclInstruction): bool{
			return false;
		}

		_getOutVariable(): IAFXVariableDeclInstruction{
			return null;
		}

		_getVertexShader(): IAFXFunctionDeclInstruction{
			return null;
		}

		_getPixelShader(): IAFXFunctionDeclInstruction{
			return null;
		}

		_markUsedAs(eUsedType: EFunctionType): void {
		}

		_isUsedAs(eUsedType: EFunctionType): bool{
			return true;
		}

		_isUsedAsFunction(): bool {
			return true;
		}

		_isUsedAsVertex(): bool {
			return true;
		}

		_isUsedAsPixel(): bool {
			return true;
		}

		_markUsedInVertex(): void {
		}

		_markUsedInPixel(): void {
		}

		_isUsedInVertex(): bool {
			return null;
		}

		_isUsedInPixel(): bool {
			return null;
		}

		_isUsed(): bool{
			return null;
		}

		_checkVertexUsage(): bool {
			return this._isForVertex();
		}

		_checkPixelUsage(): bool {
			return this._isForPixel();
		}

		_checkDefenitionForVertexUsage(): bool {
			return false;
		}

		_checkDefenitionForPixelUsage(): bool {
			return false;
		}

		_canUsedAsFunction(): bool{
			return true;
		}

		_notCanUsedAsFunction(): void{}

		_addUsedFunction(pFunction: IAFXFunctionDeclInstruction): bool {
			return false;
		}

		_addUsedVariable(pVariable: IAFXVariableDeclInstruction): void {

		}

		_getUsedFunctionList(): IAFXFunctionDeclInstruction[] {
			return null;
		}

		_isBlackListFunction(): bool {
			return false;
		}

		_addToBlackList(): void {
		}

		_getStringDef(): string {
			return "system_func";
		}

		_convertToVertexShader(): IAFXFunctionDeclInstruction {
			return null;
		}

        _convertToPixelShader(): IAFXFunctionDeclInstruction {
        	return null;
        }

        _prepareForVertex(): void{}
        _prepareForPixel(): void{}

        addUsedVariableType(pType: IAFXVariableTypeInstruction, eUsedMode: EVarUsedMode): bool {
        	return false;
        }

        _generateInfoAboutUsedData(): void{

        }

        /**@inline*/  _getAttributeVariableMap(): IAFXVariableDeclMap {
        	return null;
        }

        /**@inline*/  _getVaryingVariableMap(): IAFXVariableDeclMap {
        	return null;
        }

        /**@inline*/  _getSharedVariableMap(): IAFXVariableDeclMap{
			return null;
        }

        /**@inline*/  _getGlobalVariableMap(): IAFXVariableDeclMap{
        	return null;
        }

        /**@inline*/  _getUniformVariableMap(): IAFXVariableDeclMap{
        	return null;
        }

        /**@inline*/  _getForeignVariableMap(): IAFXVariableDeclMap{
        	return null;
        }

        /**@inline*/  _getTextureVariableMap(): IAFXVariableDeclMap{
        	return null;
        }

        /**@inline*/  _getUsedComplexTypeMap(): IAFXTypeMap{
        	return null;
        }

        /**@inline*/  _getAttributeVariableKeys():  number [] {
        	return null;
        }

        /**@inline*/  _getVaryingVariableKeys():  number [] {
        	return null;
        }

        /**@inline*/  _getSharedVariableKeys():  number [] {
        	return null;
        }

        /**@inline*/  _getUniformVariableKeys():  number [] {
        	return null;
        }

        /**@inline*/  _getForeignVariableKeys():  number [] {
        	return null;
        }

        /**@inline*/  _getGlobalVariableKeys():  number [] {
        	return null;
        }

        /**@inline*/  _getTextureVariableKeys():  number [] {
        	return null;
        }

        /**@inline*/  _getUsedComplexTypeKeys():  number [] {
        	return null;
        }

        _getExtSystemFunctionList(): IAFXFunctionDeclInstruction[] {
        	return this._pExtSystemFunctionList;
        }

        _getExtSystemMacrosList(): IAFXSimpleInstruction[] {
        	return this._pExtSystemMacrosList;
        }

        _getExtSystemTypeList(): IAFXTypeDeclInstruction[] {
        	return this._pExtSystemTypeList;
        }

	}

/**
	 * Represent type func(...args)[:Semantic]
	 * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction
	 */

	export class FunctionDefInstruction extends DeclInstruction {
		private _pParameterList: IAFXVariableDeclInstruction[] = null;
		private _pParamListForShaderCompile: IAFXVariableDeclInstruction[] = null;
		private _pParamListForShaderInput: IAFXVariableDeclInstruction[] = null;
		private _isComplexShaderInput: bool = false;

		private _pReturnType: IAFXVariableTypeInstruction = null;
		private _pFunctionName: IAFXIdInstruction = null;
		private _nParamsNeeded:  number  = 0;
		private _sDefinition: string = "";
		private _isAnalyzedForVertexUsage: bool = false;
		private _isAnalyzedForPixelUsage: bool = false;
		private _bCanUsedAsFunction: bool = true;

		private _bShaderDef: bool = false;

//private _sHash: string = "";

		constructor() {
			super();
			this._pInstructionList = null;
			this._pParameterList = [];
			this._eInstructionType = EAFXInstructionTypes.k_FunctionDefInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			if(!this.isShaderDef()){

				sCode += this._pReturnType.toFinalCode();
				sCode += " " + this._pFunctionName.toFinalCode();
				sCode += "(";

				for(var i:  number  = 0; i < this._pParameterList.length; i++){
					sCode += this._pParameterList[i].toFinalCode();

					if(i !== this._pParameterList.length - 1){
						sCode += ",";
					}
				}

				sCode += ")";
			}
			else {
				sCode = "void " + this._pFunctionName.toFinalCode() + "()";
			}

			return sCode;
		}

		/**@inline*/  setType(pType: IAFXTypeInstruction): void {
			this.setReturnType(<IAFXVariableTypeInstruction>pType);
		}

		/**@inline*/  getType(): IAFXTypeInstruction {
			return <IAFXTypeInstruction>this.getReturnType();
		}

		/**@inline*/  setReturnType(pReturnType: IAFXVariableTypeInstruction): bool {
			this._pReturnType = pReturnType;
			pReturnType.setParent(this);
			return true;
		}
		/**@inline*/  getReturnType(): IAFXVariableTypeInstruction {
			return this._pReturnType;
		}

		/**@inline*/  setFunctionName(pNameId: IAFXIdInstruction): bool {
			this._pFunctionName = pNameId;
			pNameId.setParent(this);
			return true;
		}

		/**@inline*/  getName(): string {
			return this._pFunctionName.getName();
		}

		/**@inline*/  getRealName(): string {
			return this._pFunctionName.getRealName();
		}

		/**@inline*/  getNameId(): IAFXIdInstruction {
			return this._pFunctionName;
		}

		/**@inline*/  getArguments(): IAFXVariableDeclInstruction[]{
			return this._pParameterList;
		}

		/**@inline*/  getNumNeededArguments():  number {
			return this._nParamsNeeded;
		}

		/**@inline*/  markAsShaderDef(isShaderDef: bool): void {
			this._bShaderDef = isShaderDef;
		}

		/**@inline*/  isShaderDef(): bool {
			return this._bShaderDef;
		}

		addParameter(pParameter: IAFXVariableDeclInstruction, isStrictModeOn?: bool): bool {
			if (this._pParameterList.length > this._nParamsNeeded &&
				!pParameter.hasInitializer()) {

				this.setError( 2245 ,
							  { funcName: this._pFunctionName.getName(),
							  	varName: pParameter.getName() });
				return false;
			}

			var pParameterType: IAFXVariableTypeInstruction = pParameter.getType();

			if (pParameterType.isPointer() || pParameterType._containPointer()){
				if (pParameterType.hasUsage("uniform") ||
					pParameterType.hasUsage("out") ||
					pParameterType.hasUsage("inout")){

					this.setError( 2265 ,
							  	  { funcName: this._pFunctionName.getName(),
							  	varName: pParameter.getName() });
					return false;
				}

				this._isAnalyzedForVertexUsage = false;
				this._isAnalyzedForPixelUsage = true;

				this._setForPixel(false);
				this._bCanUsedAsFunction = false;
				pParameterType._setVideoBufferInDepth();
			}
			else if(!isStrictModeOn){

				if (pParameterType.isComplex() &&
				    !pParameterType.hasFieldWithoutSemantic() &&
					pParameterType.hasAllUniqueSemantics()){

					if (pParameter.getSemantic() === "" &&
						pParameterType.hasAllUniqueSemantics() &&
						!pParameterType.hasFieldWithoutSemantic()){

						pParameterType._addPointIndexInDepth();
					}
					else {
						pParameterType.addPointIndex(false);
						pParameterType._setVideoBufferInDepth();
					}
				}
				else if(pParameter.getSemantic() !== ""){
					pParameterType.addPointIndex(false);
					pParameterType._setVideoBufferInDepth();
				}
			}

			this._pParameterList.push(pParameter);
			pParameter.setParent(this);

			if(!pParameter.hasInitializer()){
				this._nParamsNeeded++;
			}

			return true;
		}

		/**@inline*/  getParameListForShaderInput(): IAFXVariableDeclInstruction[] {
			return this._pParamListForShaderInput;
		}

		/**@inline*/  isComplexShaderInput(): bool {
			return this._isComplexShaderInput;
		}

		clone(pRelationMap: IAFXInstructionMap = <IAFXInstructionMap>{}): FunctionDefInstruction {
			var pClone: FunctionDefInstruction = <FunctionDefInstruction>super.clone(pRelationMap);

			pClone.setFunctionName(<IAFXIdInstruction>this._pFunctionName.clone(pRelationMap));
			pClone.setReturnType(<IAFXVariableTypeInstruction>this.getReturnType().clone(pRelationMap));

			for(var i:  number  = 0; i < this._pParameterList.length; i++){
				pClone.addParameter(this._pParameterList[i].clone(pRelationMap));
			}

			var pShaderParams: IAFXVariableDeclInstruction[] = [];
			for(var i:  number  = 0; i < this._pParamListForShaderInput.length; i++){
				pShaderParams.push(this._pParamListForShaderInput[i].clone(pRelationMap));
			}

			pClone._setShaderParams(pShaderParams, this._isComplexShaderInput);
			pClone._setAnalyzedInfo(this._isAnalyzedForVertexUsage,
									this._isAnalyzedForPixelUsage,
									this._bCanUsedAsFunction);

			return pClone;
		}

		_setShaderParams(pParamList: IAFXVariableDeclInstruction[], isComplexInput: bool): void {
			this._pParamListForShaderInput = pParamList;
			this._isComplexShaderInput = isComplexInput;
		}

		_setAnalyzedInfo(isAnalyzedForVertexUsage: bool,
						 isAnalyzedForPixelUsage: bool,
						 bCanUsedAsFunction: bool): void {
			this._isAnalyzedForVertexUsage = isAnalyzedForVertexUsage;
			this._isAnalyzedForPixelUsage = isAnalyzedForPixelUsage;
			this._bCanUsedAsFunction = bCanUsedAsFunction;
		}

		_getStringDef(): string {
			if(this._sDefinition === ""){
				this._sDefinition = this._pReturnType.getHash() + " " + this.getName() + "(";

				for(var i:  number  = 0; i < this._pParameterList.length; i++){
					this._sDefinition += this._pParameterList[i].getType().getHash() + ",";
				}

				this._sDefinition += ")";
			}

			return this._sDefinition;
		}

		_canUsedAsFunction(): bool {
			return this._bCanUsedAsFunction;
		}

		_checkForVertexUsage(): bool {
			if(this._isAnalyzedForVertexUsage){
				return this._isForVertex();
			}

			this._isAnalyzedForVertexUsage = true;

			var isGood: bool = true;

			isGood = this.checkReturnTypeForVertexUsage();
			if(!isGood){
				this._setForVertex(false);
				return false;
			}

			isGood = this.checkArgumentsForVertexUsage();
			if(!isGood){
				this._setForVertex(false);
				return false;
			}

			this._setForVertex(true);

			return true;
		}

		_checkForPixelUsage(): bool {
			if(this._isAnalyzedForPixelUsage){
				return this._isForPixel();
			}

			this._isAnalyzedForPixelUsage = true;

			var isGood: bool = true;

			isGood = this.checkReturnTypeForPixelUsage();
			if(!isGood){
				this._setForPixel(false);
				return false;
			}

			isGood = this.checkArgumentsForPixelUsage();
			if(!isGood){
				this._setForPixel(false);
				return false;
			}

			this._setForPixel(true);

			return true;
		}

		private checkReturnTypeForVertexUsage(): bool {
			var pReturnType: IAFXVariableTypeInstruction = this._pReturnType;
			var isGood: bool = true;

			if(pReturnType.isEqual(Effect.getSystemType("void"))){
				return true;
			}

			if(pReturnType.isComplex()){
				isGood = !pReturnType.hasFieldWithoutSemantic();
				if(!isGood){
					return false;
				}

				isGood = pReturnType.hasAllUniqueSemantics();
				if(!isGood) {
					return false;
				}

// isGood = pReturnType.hasFieldWithSematic("POSITION");
// if(!isGood){
// 	return false;
// }

				isGood = !pReturnType._containSampler();
				if(!isGood){
					return false;
				}

				isGood = !pReturnType._containPointer() && !pReturnType.isPointer();
				if(!isGood){
					return false;
				}

				isGood = !pReturnType._containComplexType();
				if(!isGood){
					return false;
				}

				return true;
			}
			else {
				isGood = pReturnType.isEqual(Effect.getSystemType("float4"));
				if(!isGood){
					return false;
				}

				isGood = (this.getSemantic() === "POSITION");
				if(!isGood){
					return false;
				}

				return true;
			}
		}

		private checkReturnTypeForPixelUsage(): bool {
			var pReturnType: IAFXVariableTypeInstruction = this._pReturnType;
			var isGood: bool = true;

			if(pReturnType.isEqual(Effect.getSystemType("void"))){
				return true;
			}

			isGood = pReturnType.isBase();
			if(!isGood){
				return false;
			}

			isGood = pReturnType.isEqual(Effect.getSystemType("float4"));
			if(!isGood){
				return false;
			}

			isGood = this.getSemantic() === "COLOR";
			if(!isGood){
				return false;
			}

			return true;
		}

		private checkArgumentsForVertexUsage(): bool {
			var pArguments: IAFXVariableDeclInstruction[] = this._pParameterList;
			var isAttributeByStruct: bool = false;
			var isAttributeByParams: bool = false;
			var isStartAnalyze: bool = false;

			this._pParamListForShaderInput = [];
			this._pParamListForShaderCompile = [];

			for(var i:  number  = 0; i < pArguments.length; i++){
				var pParam: IAFXVariableDeclInstruction = pArguments[i];

				if(pParam.isUniform()){
					this._pParamListForShaderCompile.push(pParam);
					continue;
				}

				if(!isStartAnalyze){
					if(pParam.getSemantic() === ""){
						if (pParam.getType().isBase() ||
							pParam.getType().hasFieldWithoutSemantic() ||
							!pParam.getType().hasAllUniqueSemantics()){
							return false;
						}

						isAttributeByStruct = true;
					}
					else if(pParam.getSemantic() !== ""){
						if (pParam.getType().isComplex() &&
							(pParam.getType().hasFieldWithoutSemantic() ||
							!pParam.getType().hasAllUniqueSemantics())){
							return false;
						}

						isAttributeByParams = true;
					}

					isStartAnalyze = true;
				}
				else if (isAttributeByStruct){
					return false;
				}
				else if (isAttributeByParams){
					if(pParam.getSemantic() === "") {
						return false;
					}

					if (pParam.getType().isComplex() &&
						(pParam.getType().hasFieldWithoutSemantic() ||
						!pParam.getType().hasAllUniqueSemantics())){
						return false;
					}
				}

				this._pParamListForShaderInput.push(pParam);
			}

			if(isAttributeByStruct){
				this._isComplexShaderInput = true;
			}

			return true;
		}

		private checkArgumentsForPixelUsage(): bool {
			var pArguments: IAFXVariableDeclInstruction[] = this._pParameterList;
			var isVaryingsByStruct: bool = false;
			var isVaryingsByParams: bool = false;
			var isStartAnalyze: bool = false;

			this._pParamListForShaderInput = [];
			this._pParamListForShaderCompile = [];

			for(var i:  number  = 0; i < pArguments.length; i++){
				var pParam: IAFXVariableDeclInstruction = pArguments[i];

				if(pParam.isUniform()){
					this._pParamListForShaderCompile.push(pParam);
					continue;
				}

				if(!isStartAnalyze){
					if(pParam.getSemantic() === ""){
						if (pParam.getType().isBase() ||
							pParam.getType().hasFieldWithoutSemantic() ||
							!pParam.getType().hasAllUniqueSemantics() ||
							pParam.getType()._containSampler() ||
							pParam.getType()._containPointer() ||
							pParam.getType().isPointer()){
							{ logger.setSourceLocation( "fx/FunctionInstruction.ts" , 1910 ); logger.log(1); } ;
							return false;
						}

						isVaryingsByStruct = true;
					}
					else if(pParam.getSemantic() !== ""){
						if (pParam.getType().isStrictPointer() ||
						    pParam.getType()._containPointer() ||
						    pParam.getType()._containSampler() ||
						    Effect.isSamplerType(pParam.getType())){
							{ logger.setSourceLocation( "fx/FunctionInstruction.ts" , 1924 ); logger.log(2, pParam.getType().isPointer() , pParam.getType()._containPointer() , pParam.getType()._containSampler() , Effect.isSamplerType(pParam.getType())); }
                                                 ;
							return false;
						}

						if (pParam.getType().isComplex() &&
							(pParam.getType().hasFieldWithoutSemantic() ||
							!pParam.getType().hasAllUniqueSemantics())){
							{ logger.setSourceLocation( "fx/FunctionInstruction.ts" , 1931 ); logger.log(3); } ;
							return false;
						}

						isVaryingsByParams = true;
					}

					isStartAnalyze = true;
				}
				else if (isVaryingsByStruct){
					{ logger.setSourceLocation( "fx/FunctionInstruction.ts" , 1941 ); logger.log(4); } ;
					return false;
				}
				else if (isVaryingsByParams){
					if(pParam.getSemantic() === "") {
						{ logger.setSourceLocation( "fx/FunctionInstruction.ts" , 1946 ); logger.log(5); } ;
						return false;
					}

					if (pParam.getType().isStrictPointer() ||
					    pParam.getType()._containPointer() ||
					    pParam.getType()._containSampler() ||
					    Effect.isSamplerType(pParam.getType())){
						{ logger.setSourceLocation( "fx/FunctionInstruction.ts" , 1954 ); logger.log(6); } ;
						return false;
					}

					if (pParam.getType().isComplex() &&
						(pParam.getType().hasFieldWithoutSemantic() ||
						!pParam.getType().hasAllUniqueSemantics())){
						{ logger.setSourceLocation( "fx/FunctionInstruction.ts" , 1961 ); logger.log(7); } ;
						return false;
					}
				}

				this._pParamListForShaderInput.push(pParam);
			}

			if(isVaryingsByStruct){
				this._isComplexShaderInput = true;
			}

			return true;
		}
// getHash(): string {
// 	if(this._sHash === "") {
// 		this.calcHash();
// 	}

// 	return this._sHash;
// }

// private calcHash(): void {
// 	var sHash: string = "";
// 	sHash = this._pFunctionName.getName();
// 	sHash += "(";

// 	for(var i: uint = 0; i < this._pParameterList.length; i++){
// 		sHash += this._pParameterList[i]
// 	}

// }
	}

}

















module akra.fx {
	export class PassInstruction extends DeclInstruction implements IAFXPassInstruction {
		private _pTempNodeList: IParseNode[] = null;
		private _pTempFoundedFuncList: IAFXFunctionDeclInstruction[] = null;
		private _pTempFoundedFuncTypeList: EFunctionType[] = null;
		private _pParseNode: IParseNode = null;

		private _sFunctionCode: string = "";

		private _isComlexPass: bool = false;
		private _pShadersMap: IAFXFunctionDeclMap = null;
		private _fnPassFunction: {(engine: any, foreigtn: any, uniforms: any): void;} = null;

		private _pVertexShader: IAFXFunctionDeclInstruction = null;
		private _pPixelShader: IAFXFunctionDeclInstruction = null;
		private _pPassStateMap:  IRenderStateMap  = null;


		private _pSharedVariableMapV: IAFXVariableDeclMap = null;
		private _pGlobalVariableMapV: IAFXVariableDeclMap = null;
		private _pUniformVariableMapV: IAFXVariableDeclMap = null;
		private _pForeignVariableMapV: IAFXVariableDeclMap = null;
		private _pTextureVariableMapV: IAFXVariableDeclMap = null;
		private _pUsedComplexTypeMapV: IAFXTypeMap = null;

		private _pSharedVariableMapP: IAFXVariableDeclMap = null;
		private _pGlobalVariableMapP: IAFXVariableDeclMap = null;
		private _pUniformVariableMapP: IAFXVariableDeclMap = null;
		private _pForeignVariableMapP: IAFXVariableDeclMap = null;
		private _pTextureVariableMapP: IAFXVariableDeclMap = null;
		private _pUsedComplexTypeMapP: IAFXTypeMap = null;

		private _pFullUniformVariableMap: IAFXVariableDeclMap = null;
		private _pFullForeignVariableMap: IAFXVariableDeclMap = null;
		private _pFullTextureVariableMap: IAFXVariableDeclMap = null;


		constructor(){
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_PassInstruction;
		}

		_addFoundFunction(pNode: IParseNode, pShader: IAFXFunctionDeclInstruction, eType: EFunctionType): void{
			if(isNull(this._pTempNodeList)){
				this._pTempNodeList = [];
				this._pTempFoundedFuncList = [];
				this._pTempFoundedFuncTypeList = [];
			}

			this._pTempNodeList.push(pNode);
			this._pTempFoundedFuncList.push(pShader);
			this._pTempFoundedFuncTypeList.push(eType);
		}

		_getFoundedFunction(pNode: IParseNode): IAFXFunctionDeclInstruction {
			if(isNull(this._pTempNodeList)){
				return null;
			}

			for(var i:  number  = 0; i < this._pTempNodeList.length; i++){
				if(this._pTempNodeList[i] === pNode){
					return this._pTempFoundedFuncList[i];
				}
			}

			return null;
		}

		_getFoundedFunctionType(pNode: IParseNode): EFunctionType {
			if(isNull(this._pTempNodeList)){
				return null;
			}

			for(var i:  number  = 0; i < this._pTempNodeList.length; i++){
				if(this._pTempNodeList[i] === pNode){
					return this._pTempFoundedFuncTypeList[i];
				}
			}

			return null;
		}

		_setParseNode(pNode: IParseNode): void {
        	this._pParseNode = pNode;
        }

        _getParseNode(): IParseNode{
        	return this._pParseNode;
        }

        _addCodeFragment(sCode: string): void {
        	if(this.isComplexPass()){
        		this._sFunctionCode += sCode;
        	}
        }

        /**@inline*/  _markAsComplex(isComplex: bool): void{
        	this._isComlexPass = isComplex;
        }

        /**@inline*/  _getSharedVariableMapV(): IAFXVariableDeclMap{
        	return this._pSharedVariableMapV;
        }

        /**@inline*/  _getGlobalVariableMapV(): IAFXVariableDeclMap{
        	return this._pGlobalVariableMapV;
        }

        /**@inline*/  _getUniformVariableMapV(): IAFXVariableDeclMap{
        	return this._pUniformVariableMapV;
        }

        /**@inline*/  _getForeignVariableMapV(): IAFXVariableDeclMap{
        	return this._pForeignVariableMapV;
        }

        /**@inline*/  _getTextureVariableMapV(): IAFXVariableDeclMap{
        	return this._pTextureVariableMapV;
        }

        /**@inline*/  _getUsedComplexTypeMapV(): IAFXTypeMap{
        	return this._pUsedComplexTypeMapV;
        }

        /**@inline*/  _getSharedVariableMapP(): IAFXVariableDeclMap{
        	return this._pSharedVariableMapP;
        }

        /**@inline*/  _getGlobalVariableMapP(): IAFXVariableDeclMap{
        	return this._pGlobalVariableMapP;
        }

        /**@inline*/  _getUniformVariableMapP(): IAFXVariableDeclMap{
        	return this._pUniformVariableMapP;
        }

        /**@inline*/  _getForeignVariableMapP(): IAFXVariableDeclMap{
        	return this._pForeignVariableMapP;
        }

        /**@inline*/  _getTextureVariableMapP(): IAFXVariableDeclMap{
        	return this._pTextureVariableMapP;
        }

        /**@inline*/  _getUsedComplexTypeMapP(): IAFXTypeMap{
        	return this._pUsedComplexTypeMapP;
        }

        /**@inline*/  _getFullUniformMap(): IAFXVariableDeclMap {
        	return this._pFullUniformVariableMap;
        }

        /**@inline*/  _getFullForeignMap(): IAFXVariableDeclMap {
        	return this._pFullForeignVariableMap;
        }

        /**@inline*/  _getFullTextureMap(): IAFXVariableDeclMap {
        	return this._pFullTextureVariableMap;
        }


        /**@inline*/  isComplexPass(): bool {
        	return this._isComlexPass;
        }

        /**@inline*/  getVertexShader(): IAFXFunctionDeclInstruction {
			return this._pVertexShader;
		}

		/**@inline*/  getPixelShader(): IAFXFunctionDeclInstruction {
			return this._pPixelShader;
		}

        addShader(pShader: IAFXFunctionDeclInstruction): void {
        	var isVertex: bool = pShader.getFunctionType() === EFunctionType.k_Vertex;

        	if(this.isComplexPass()){
        		if(isNull(this._pShadersMap)){
        			this._pShadersMap = <IAFXFunctionDeclMap>{};
        		}
        		var iShader:  number  = pShader._getInstructionID();
        		this._pShadersMap[iShader] = pShader;

        		var sCode: string = isVertex ? "this._pVertexShader=" : "this._pPixelShader=";
        		sCode += "this._pShadersMap["+ iShader.toString() +"];"
        		this._addCodeFragment(sCode);
        	}
        	else {
        		if(isVertex){
        			this._pVertexShader = pShader;
        		}
        		else {
        			this._pPixelShader = pShader;
        		}
        	}
        }

        setState(eType:  ERenderStates , eValue:  ERenderStateValues ): void {
        	if(isNull(this._pPassStateMap)){
        		this._pPassStateMap = render.createRenderStateMap();
        	}

        	if(this.isComplexPass()){
        		this._addCodeFragment("this._pPassStateMap[" + eType + "]=" + eValue+ ";");
        	}
        	else {
        		this._pPassStateMap[eType] = eValue;
        	}
        }

        finalizePass(): void {
        	if(this.isComplexPass()){
        		this._fnPassFunction = <any>(new Function("engine", "foreigns", "uniforms", this._sFunctionCode));
        	}

        	this.generateInfoAboutUsedVaraibles();

        	this._pTempNodeList = null;
			this._pTempFoundedFuncList = null;
			this._pTempFoundedFuncTypeList = null;
			this._pParseNode= null;
			this._sFunctionCode = "";
        }

        evaluate(pEngineStates: any, pForeigns: any, pUniforms: any): bool {
        	if(this.isComplexPass()){
        		this._pVertexShader = null;
        		this._pPixelShader = null;
        		this.clearPassStates();

        		this._fnPassFunction.call(this, pEngineStates, pForeigns, pUniforms);
        	}

        	return true;
        }

        /**@inline*/  getState(eType:  ERenderStates ):  ERenderStateValues  {
        	return !isNull(this._pPassStateMap) ? this._pPassStateMap[eType] :  ERenderStateValues .UNDEF;
        }

        /**@inline*/  _getRenderStates(): IRenderStateMap {
            return this._pPassStateMap;
        }

        private clearPassStates(): void {
        	if(!isNull(this._pPassStateMap)){
        		this._pPassStateMap[ ERenderStates .BLENDENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .CULLFACEENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .ZENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .ZWRITEENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .DITHERENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .SCISSORTESTENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .STENCILTESTENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .POLYGONOFFSETFILLENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .CULLFACE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .FRONTFACE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .SRCBLEND] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .DESTBLEND] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .ZFUNC] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .ALPHABLENDENABLE] =  ERenderStateValues .UNDEF;
				this._pPassStateMap[ ERenderStates .ALPHATESTENABLE] =  ERenderStateValues .UNDEF;
        	}
		}

        private generateInfoAboutUsedVaraibles(): void {
        	if(isNull(this._pSharedVariableMapV)){
	        	this._pSharedVariableMapV = <IAFXVariableDeclMap>{};
				this._pGlobalVariableMapV = <IAFXVariableDeclMap>{};
				this._pUniformVariableMapV = <IAFXVariableDeclMap>{};
				this._pForeignVariableMapV = <IAFXVariableDeclMap>{};
				this._pTextureVariableMapV = <IAFXVariableDeclMap>{};
				this._pUsedComplexTypeMapV = <IAFXTypeMap>{};

				this._pSharedVariableMapP = <IAFXVariableDeclMap>{};
				this._pGlobalVariableMapP = <IAFXVariableDeclMap>{};
				this._pUniformVariableMapP = <IAFXVariableDeclMap>{};
				this._pForeignVariableMapP = <IAFXVariableDeclMap>{};
				this._pTextureVariableMapP = <IAFXVariableDeclMap>{};
				this._pUsedComplexTypeMapP = <IAFXTypeMap>{};

				this._pFullUniformVariableMap = <IAFXVariableDeclMap>{};
				this._pFullForeignVariableMap = <IAFXVariableDeclMap>{};
				this._pFullTextureVariableMap = <IAFXVariableDeclMap>{};
			}

        	if(this.isComplexPass()){
        		for(var i in this._pShadersMap){
        			this.addInfoAbouUsedVariablesFromFunction(this._pShadersMap[i]);
        		}
        	}
        	else {
        		if(!isNull(this._pVertexShader)){
        			this.addInfoAbouUsedVariablesFromFunction(this._pVertexShader);
        		}
        		if(!isNull(this._pPixelShader)){
        			this.addInfoAbouUsedVariablesFromFunction(this._pPixelShader);
        		}
        	}
        }

        private addInfoAbouUsedVariablesFromFunction(pFunction: IAFXFunctionDeclInstruction): void {
        	var pSharedVars: IAFXVariableDeclMap = pFunction._getSharedVariableMap();
        	var pGlobalVars: IAFXVariableDeclMap = pFunction._getGlobalVariableMap();
        	var pUniformVars: IAFXVariableDeclMap = pFunction._getUniformVariableMap();
        	var pForeignVars: IAFXVariableDeclMap = pFunction._getForeignVariableMap();
        	var pTextureVars: IAFXVariableDeclMap = pFunction._getTextureVariableMap();
        	var pTypes: IAFXTypeMap = pFunction._getUsedComplexTypeMap();


        	var pSharedVarsTo: IAFXVariableDeclMap = null;
        	var pGlobalVarsTo: IAFXVariableDeclMap = null;
        	var pUniformVarsTo: IAFXVariableDeclMap = null;
        	var pForeignVarsTo: IAFXVariableDeclMap = null;
        	var pTextureVarsTo: IAFXVariableDeclMap = null;
        	var pTypesTo: IAFXTypeMap = null;

        	if(pFunction.getFunctionType() === EFunctionType.k_Vertex){
        		pSharedVarsTo = this._pSharedVariableMapV;
	        	pGlobalVarsTo = this._pGlobalVariableMapV;
	        	pUniformVarsTo = this._pUniformVariableMapV;
	        	pForeignVarsTo = this._pForeignVariableMapV;
	        	pTextureVarsTo = this._pTextureVariableMapV;
	        	pTypesTo = this._pUsedComplexTypeMapV;
        	}
        	else {
        		pSharedVarsTo = this._pSharedVariableMapP;
	        	pGlobalVarsTo = this._pGlobalVariableMapP;
	        	pUniformVarsTo = this._pUniformVariableMapP;
	        	pForeignVarsTo = this._pForeignVariableMapP;
	        	pTextureVarsTo = this._pTextureVariableMapP;
	        	pTypesTo = this._pUsedComplexTypeMapP;
        	}

        	for(var i in pSharedVars){
        		if(!isNull(pSharedVars[i]) && !pSharedVars[i].isField()){
        			pSharedVarsTo[i] = pSharedVars[i];
        		}
        	}
        	for(var i in pGlobalVars){
        		if(!isNull(pGlobalVars[i])){
        			pGlobalVarsTo[i] = pGlobalVars[i];
        		}
        	}
        	for(var i in pUniformVars){
        		if(!isNull(pUniformVars[i])){
        			pUniformVarsTo[i] = pUniformVars[i];
        			this._pFullUniformVariableMap[i] = pUniformVars[i];
        		}
        	}
        	for(var i in pForeignVars){
        		if(!isNull(pForeignVars[i])){
        			pForeignVarsTo[i] = pForeignVars[i];
        			this._pFullForeignVariableMap[i] = pForeignVars[i];
        		}
        	}
        	for(var i in pTextureVars){
        		if(!isNull(pTextureVars[i])){
        			pTextureVarsTo[i] = pTextureVars[i];
        			this._pFullTextureVariableMap[i] = pTextureVars[i];
        		}
        	}
        	for(var i in pTypes){
        		if(!isNull(pTypes[i])){
        			pTypesTo[i] = pTypes[i];
        		}
        	}
        }
	}


	export class TechniqueInstruction extends DeclInstruction implements IAFXTechniqueInstruction {
		private _sName: string = "";
		private _hasComplexName: bool = false;
		private _pParseNode: IParseNode = null;
		private _pSharedVariableListV: IAFXVariableDeclInstruction[] = null;
		private _pSharedVariableListP: IAFXVariableDeclInstruction[] = null;
		private _pPassList: IAFXPassInstruction[] = null;

        private _bHasImportedTechniqueFromSameEffect: bool = false;
        private _pImportedTechniqueList: IAFXImportedTechniqueInfo[] = null;

		private _pFullComponentList: IAFXComponent[] = null;
		private _pFullComponentShiftList:  number [] = null;

        private _nTotalPasses:  number  = 0;
		private _isPostEffect: bool = false;
        private _isFinalize: bool = false;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_TechniqueInstruction;
		}

		setName(sName: string, isComplexName: bool): void {
			this._sName = sName;
			this._hasComplexName = isComplexName;
		}

		getName(): string {
			return this._sName;
		}

		setSemantic(sSemantic: string): void {
			super.setSemantic(sSemantic);

			if(sSemantic ===  "POST_EFFECT" ){
				this._isPostEffect = true;
			}
			else {
				this._isPostEffect = false;
			}
		}

        hasComplexName(): bool{
        	return this._hasComplexName;
        }

        isPostEffect(): bool {
        	return this._isPostEffect;
        }

        getSharedVariablesForVertex(): IAFXVariableDeclInstruction[] {
        	return this._pSharedVariableListV;
        }

        getSharedVariablesForPixel(): IAFXVariableDeclInstruction[] {
        	return this._pSharedVariableListP;
        }

		addPass(pPass: IAFXPassInstruction): void {
			if(isNull(this._pPassList)){
				this._pPassList = [];
			}

			this._pPassList.push(pPass);
		}

		getPassList(): IAFXPassInstruction[]{
			return this._pPassList;
		}

		getPass(iPass:  number ): IAFXPassInstruction{
			return iPass < this._pPassList.length ? this._pPassList[iPass] : null;
		}

		totalOwnPasses():  number {
			return this._pPassList.length;
		}

        totalPasses():  number {
        	return this._nTotalPasses;
        }

        addTechniqueFromSameEffect(pTechnique: IAFXTechniqueInstruction, iShift:  number ): void {
            if(isNull(this._pImportedTechniqueList)){
                this._pImportedTechniqueList = [];
            }

            this._pImportedTechniqueList.push({
                technique: pTechnique,
                component: null,
                shift: iShift
            });

            this._bHasImportedTechniqueFromSameEffect = true;
        }

		addComponent(pComponent: IAFXComponent, iShift:  number ): void{
			if(isNull(this._pImportedTechniqueList)){
				this._pImportedTechniqueList = [];
			}

            this._pImportedTechniqueList.push({
                technique: pComponent.getTechnique(),
                component: pComponent,
                shift: iShift
            });
		}

        getFullComponentList(): IAFXComponent[]{
        	return this._pFullComponentList;
        }

        getFullComponentShiftList():  number []{
        	return this._pFullComponentShiftList;
        }

		checkForCorrectImports(): bool {
			return true;
		}

		setGlobalParams(sProvideNameSpace: string,
                        pGlobalImportList: IAFXImportedTechniqueInfo[]): void {
			this.generateListOfSharedVariables();

			if(!this.hasComplexName() && sProvideNameSpace !== ""){
				this._sName = sProvideNameSpace + "." + this._sName;
			}

			if(!isNull(pGlobalImportList)){
				if(!isNull(this._pImportedTechniqueList)){
					this._pImportedTechniqueList = pGlobalImportList.concat(this._pImportedTechniqueList);
				}
				else {
					this._pImportedTechniqueList = pGlobalImportList.concat();
				}
			}

            if(!this._bHasImportedTechniqueFromSameEffect){
                this.generateFullListOfComponent();
                this._isFinalize = true;
            }
		}

        finalize(pComposer: IAFXComposer): void {
            if(this._isFinalize){
                return;
            }

            for(var i:  number  = 0; i < this._pImportedTechniqueList.length; i++){
                var pInfo: IAFXImportedTechniqueInfo = this._pImportedTechniqueList[i];

                if(isNull(pInfo.component)){
                    pInfo.component = pComposer.getComponentByName(pInfo.technique.getName());
                }
            }

            this.generateFullListOfComponent();
            this._isFinalize = true;
        }

		private generateListOfSharedVariables(): void {
			this._pSharedVariableListV = [];
			this._pSharedVariableListP = [];

			for(var i:  number  = 0; i < this._pPassList.length; i++){
				var pSharedV: IAFXVariableDeclMap = this._pPassList[i]._getSharedVariableMapV();
				var pSharedP: IAFXVariableDeclMap = this._pPassList[i]._getSharedVariableMapP();

				for(var j in pSharedV){
					this.addSharedVariable(pSharedV[j], EFunctionType.k_Vertex);
				}

				for(var j in pSharedP){
					this.addSharedVariable(pSharedP[j], EFunctionType.k_Pixel);
				}
			}
		}

		private addSharedVariable(pVar: IAFXVariableDeclInstruction, eType: EFunctionType): void {
			var pAddTo: IAFXVariableDeclInstruction[] = null;

			if(eType === EFunctionType.k_Vertex){
				pAddTo = this._pSharedVariableListV;
			}
			else {
				pAddTo = this._pSharedVariableListP;
			}

			for(var i:  number  = 0; i < pAddTo.length; i++) {
				if(pAddTo[i] === pVar){
					return;
				}
			}

			pAddTo.push(pVar);
		}

		private generateFullListOfComponent(): void {
			this._nTotalPasses = this.totalOwnPasses();

			if(isNull(this._pImportedTechniqueList)){
				return;
			}

			this._pFullComponentList = [];
			this._pFullComponentShiftList = [];

			for(var i:  number  = 0; i < this._pImportedTechniqueList.length; i++){
                var pInfo: IAFXImportedTechniqueInfo = this._pImportedTechniqueList[i];

				var pTechnique: IAFXTechniqueInstruction = pInfo.technique;
				var iMainShift:  number  = pInfo.shift;
				var pAddComponentList: IAFXComponent[] = pTechnique.getFullComponentList();
				var pAddComponentShiftList:  number [] = pTechnique.getFullComponentShiftList();

				if(!isNull(pAddComponentList)){
					for(var j:  number  = 0; j < pAddComponentList.length; i++){
						this._pFullComponentList.push(pAddComponentList[j]);
						this._pFullComponentShiftList.push(pAddComponentShiftList[j] + iMainShift);
					}
				}

				this._pFullComponentList.push(pInfo.component);
				this._pFullComponentShiftList.push(iMainShift);

				if(this._nTotalPasses < iMainShift + pTechnique.totalPasses()) {
					this._nTotalPasses = iMainShift + pTechnique.totalPasses();
				}
			}
		}
	}
}











module akra.fx {







	export interface SystemTypeMap {
		[sTypeName: string]: SystemTypeInstruction;
	}

	export interface SystemFunctionMap {
		[sFuncName: string]: SystemFunctionInstruction[];
	}

	export interface TechniqueMap {
		[sTechniqueName: string]: IAFXTechniqueInstruction;
	}

	export class Effect implements IAFXEffect {
		private _pComposer: IAFXComposer = null;

		private _pParseTree: IParseTree = null;
		private _pAnalyzedNode: IParseNode = null;

		private _pEffectScope: ProgramScope = null;
		private _pCurrentInstruction: IAFXInstruction = null;
		private _pCurrentFunction: IAFXFunctionDeclInstruction = null;

		private _pStatistics: IAFXEffectStats = null;

		private _sAnalyzedFileName: string = "";

		private _pSystemMacros: IAFXSimpleInstructionMap = null;
		private _pSystemTypes: SystemTypeMap = null;
		private _pSystemFunctionsMap: SystemFunctionMap = null;
		private _pSystemFunctionHashMap: BoolMap = null;
		private _pSystemVariables: IAFXVariableDeclMap = null;

		private _pPointerForExtractionList: IAFXVariableDeclInstruction[] = null;

		private _pFunctionWithImplementationList: IAFXFunctionDeclInstruction[] = null;

		private _pTechniqueList: IAFXTechniqueInstruction[] = null;
		private _pTechniqueMap: TechniqueMap = null;

		private _isAnalyzeInPass: bool = false;

		private _sProvideNameSpace: string = "";

		private _pImportedGlobalTechniqueList: IAFXImportedTechniqueInfo[] = null;

		private _pAddedTechniqueList: IAFXTechniqueInstruction[] = null;

		static pSystemMacros: IAFXSimpleInstructionMap= null;
		static pSystemTypes: SystemTypeMap = null;
		static pSystemFunctions: SystemFunctionMap = null;
		static pSystemVariables: IAFXVariableDeclMap = null;
		static pSystemVertexOut: ComplexTypeInstruction = null;

		constructor(pComposer: IAFXComposer) {
			this._pComposer = pComposer;

			this._pParseTree = null;
			this._pAnalyzedNode = null;

			this._pEffectScope = new ProgramScope();
			this._pCurrentInstruction = null;

			this._pStatistics = null;
			this._sAnalyzedFileName = "";

			this._pPointerForExtractionList = [];

			this._pFunctionWithImplementationList = [];
			this._pTechniqueList = [];
			this._pTechniqueMap = <TechniqueMap>{};

			this.initSystemMacros();
			this.initSystemTypes();
			this.initSystemFunctions();
			this.initSystemVariables();
		}

		analyze(pTree: IParseTree): bool {
			var pRootNode: IParseNode = pTree.root;
			var iParseTime:  number  = akra.now();

// LOG(this);

			this._pParseTree = pTree;
			this._pStatistics = <IAFXEffectStats>{time: 0};

			try{
				this.newScope();
// LOG("ok");
				this.analyzeGlobalUseDecls();
// LOG("ok");
				this.analyzeGlobalProvideDecls();
// LOG("ok");
				this.analyzeGlobalTypeDecls();
// LOG("ok");
				this.analyzeFunctionDefinitions();
// LOG("ok");
				this.analyzeGlobalImports();
// LOG("ok");
				this.analyzeTechniqueImports();
// LOG("ok");

				this.analyzeVariableDecls();
// LOG("ok");
				this.analyzeFunctionDecls();
// LOG("ok");
				this.analyzeTechniques();
// LOG("ok");

// this.analyzeTypes();

// this.preAnalyzeFunctions();
// this.preAnalyzeVariables();
// this.preAnalyzeTechniques();
// this.analyzeDecls();

// this.analyzeEffect();
// this.postAnalyzeEffect();
// this.checkEffect();

				this.endScope();
			}
			catch(e){
// #ifdef DEBUG
				throw e;
// #else
// return false;
// #endif
			}

//Stats
			iParseTime = akra.now() - iParseTime;
			this._pStatistics.time = iParseTime;

//LOG(this, iParseTime);

			return true;
		}

		getStats(): IAFXEffectStats {
			return this._pStatistics;
		}

		setAnalyzedFileName(sFileName: string): void {
			this._sAnalyzedFileName = sFileName;
		}

		clear(): void {
		}

		/**@inline*/  getTechniqueList(): IAFXTechniqueInstruction[]{
			return this._pTechniqueList;
		}

		static getBaseVertexOutType(): ComplexTypeInstruction {
			return Effect.pSystemVertexOut;
		}
		static getSystemType(sTypeName: string): SystemTypeInstruction {
//bool, string, float and others
        	return isDef(Effect.pSystemTypes[sTypeName]) ? Effect.pSystemTypes[sTypeName] : null;
        }

        static getSystemVariable(sName: string): IAFXVariableDeclInstruction {
        	return isDef(Effect.pSystemVariables[sName]) ? Effect.pSystemVariables[sName] : null;
        }

        static getSystemMacros(sName: string): IAFXSimpleInstruction {
        	return isDef(Effect.pSystemMacros[sName]) ? Effect.pSystemMacros[sName] : null;
        }

        static findSystemFunction(sFunctionName: string,
							 	  pArguments: IAFXTypedInstruction[]): IAFXFunctionDeclInstruction {
			var pSystemFunctions: SystemFunctionInstruction[] = Effect.pSystemFunctions[sFunctionName];

			if(!isDef(pSystemFunctions)){
				return null;
			}

			if(isNull(pArguments)) {
				for(var i:  number  = 0; i < pSystemFunctions.length; i++){
					if(pSystemFunctions[i].getNumNeededArguments() === 0){
						return pSystemFunctions[i];
					}
				}
			}

			for(var i:  number  = 0; i < pSystemFunctions.length; i++){
				if(pArguments.length !== pSystemFunctions[i].getNumNeededArguments()){
					continue;
				}

				var pTestedArguments: IAFXTypedInstruction[] = pSystemFunctions[i].getArguments();

				var isOk: bool = true;

				for(var j:  number  = 0; j < pArguments.length; j++){
					isOk = false;

					if(!pArguments[j].getType().isEqual(pTestedArguments[j].getType())){
						break;
					}

					isOk = true;
				}

				if(isOk){
					return pSystemFunctions[i];
				}
			}
		}

		static createVideoBufferVariable(): IAFXVariableDeclInstruction {
			var pBuffer: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pBufferType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			var pBufferName: IAFXIdInstruction = new IdInstruction();

			pBufferType.pushType(Effect.getSystemType("video_buffer"));

			pBuffer.push(pBufferType, true);
			pBuffer.push(pBufferName, true);

			return pBuffer;
		}

		static getExternalType(pType: IAFXTypeInstruction): any {
			if (pType.isEqual(Effect.getSystemType("int")) ||
    			pType.isEqual(Effect.getSystemType("float"))) {
    		   	return Number;
    		}
    		else if(pType.isEqual(Effect.getSystemType("bool"))){
    			return Boolean;
    		}
    		else if(pType.isEqual(Effect.getSystemType("float2")) ||
					pType.isEqual(Effect.getSystemType("bool2")) ||
					pType.isEqual(Effect.getSystemType("int2"))){
    			return Vec2;
    		}
    		else if(pType.isEqual(Effect.getSystemType("float3")) ||
					pType.isEqual(Effect.getSystemType("bool3")) ||
					pType.isEqual(Effect.getSystemType("int3"))){
    			return Vec3;
    		}
    		else if(pType.isEqual(Effect.getSystemType("float4")) ||
					pType.isEqual(Effect.getSystemType("bool4")) ||
					pType.isEqual(Effect.getSystemType("int4"))){
    			return Vec4;
    		}
// 	else if(pType.isEqual(Effect.getSystemType("float2x2")) ||
// pType.isEqual(Effect.getSystemType("bool2x2")) ||
// pType.isEqual(Effect.getSystemType("int2x2"))){
// 		return Vec2;
// 	}
    		else if(pType.isEqual(Effect.getSystemType("float3x3")) ||
					pType.isEqual(Effect.getSystemType("bool3x3")) ||
					pType.isEqual(Effect.getSystemType("int3x3"))){
    			return Mat3;
    		}
    		else if(pType.isEqual(Effect.getSystemType("float4x4")) ||
					pType.isEqual(Effect.getSystemType("bool4x4")) ||
					pType.isEqual(Effect.getSystemType("int4x4"))){
    			return Mat4;
    		}
    		else {
    			return null;
    		}
		}

		static isMatrixType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("float2x2")) ||
        		   pType.isEqual(Effect.getSystemType("float3x3")) ||
        		   pType.isEqual(Effect.getSystemType("float4x4")) ||
        		   pType.isEqual(Effect.getSystemType("int2x2")) ||
        		   pType.isEqual(Effect.getSystemType("int3x3")) ||
        		   pType.isEqual(Effect.getSystemType("int4x4")) ||
        		   pType.isEqual(Effect.getSystemType("bool2x2")) ||
        		   pType.isEqual(Effect.getSystemType("bool3x3")) ||
        		   pType.isEqual(Effect.getSystemType("bool4x4"));
        }

        static isVectorType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("float2")) ||
        		   pType.isEqual(Effect.getSystemType("float3")) ||
        		   pType.isEqual(Effect.getSystemType("float4")) ||
        		   pType.isEqual(Effect.getSystemType("bool2")) ||
        		   pType.isEqual(Effect.getSystemType("bool3")) ||
        		   pType.isEqual(Effect.getSystemType("bool4")) ||
        		   pType.isEqual(Effect.getSystemType("int2")) ||
        		   pType.isEqual(Effect.getSystemType("int3")) ||
        		   pType.isEqual(Effect.getSystemType("int4"));
        }

        static isScalarType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("bool")) ||
        		   pType.isEqual(Effect.getSystemType("int")) ||
        		   pType.isEqual(Effect.getSystemType("ptr")) ||
        		   pType.isEqual(Effect.getSystemType("float"));
        }

        static isFloatBasedType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("float")) ||
        		   pType.isEqual(Effect.getSystemType("float2")) ||
        		   pType.isEqual(Effect.getSystemType("float3")) ||
        		   pType.isEqual(Effect.getSystemType("float4")) ||
        		   pType.isEqual(Effect.getSystemType("float2x2")) ||
        		   pType.isEqual(Effect.getSystemType("float3x3")) ||
        		   pType.isEqual(Effect.getSystemType("float4x4")) ||
        		   pType.isEqual(Effect.getSystemType("ptr"));
        }

        static isIntBasedType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("int")) ||
        		   pType.isEqual(Effect.getSystemType("int2")) ||
        		   pType.isEqual(Effect.getSystemType("int3")) ||
        		   pType.isEqual(Effect.getSystemType("int4")) ||
        		   pType.isEqual(Effect.getSystemType("int2x2")) ||
        		   pType.isEqual(Effect.getSystemType("int3x3")) ||
        		   pType.isEqual(Effect.getSystemType("int4x4"));
        }

        static isBoolBasedType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("bool")) ||
        		   pType.isEqual(Effect.getSystemType("bool2")) ||
        		   pType.isEqual(Effect.getSystemType("bool3")) ||
        		   pType.isEqual(Effect.getSystemType("bool4")) ||
        		   pType.isEqual(Effect.getSystemType("bool2x2")) ||
        		   pType.isEqual(Effect.getSystemType("bool3x3")) ||
        		   pType.isEqual(Effect.getSystemType("bool4x4"));
        }

        static isSamplerType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("sampler")) ||
    		   	   pType.isEqual(Effect.getSystemType("sampler2D")) ||
    		       pType.isEqual(Effect.getSystemType("samplerCUBE")) ||
    		       pType.isEqual(Effect.getSystemType("video_buffer"));
        }

		private generateSuffixLiterals(pLiterals: string[], pOutput: BoolMap, iDepth?:  number  = 0): void {
			if(iDepth >= pLiterals.length){
				return;
			}

			if(iDepth === 0){
				for(var i: number  = 0; i < pLiterals.length; i++) {
					pOutput[pLiterals[i]] = true;
				}

				iDepth = 1;
			}

			var pOutputKeys:string[] = Object.keys(pOutput);

			for(var i: number  = 0; i < pLiterals.length; i++) {
				for(var j: number  = 0; j < pOutputKeys.length; j++) {
					if(pOutputKeys[j].indexOf(pLiterals[i]) !== -1){
						pOutput[pOutputKeys[j] + pLiterals[i]] = false;
					}
					else {
						pOutput[pOutputKeys[j] + pLiterals[i]] = (pOutput[pOutputKeys[j]] === false) ? false : true;
					}
				}
			}

			iDepth++;

			this.generateSuffixLiterals(pLiterals, pOutput, iDepth);
		}

		private initSystemMacros(): void {
			if(isNull(Effect.pSystemMacros)){
				this._pSystemMacros = Effect.pSystemMacros = <IAFXSimpleInstructionMap>{};
				this.addSystemMacros();
			}

			this._pSystemMacros = Effect.pSystemMacros;
		}

		private initSystemTypes(): void {
			if(isNull(Effect.pSystemTypes)){
				this._pSystemTypes = Effect.pSystemTypes = {};
				this.addSystemTypeScalar();
				this.addSystemTypeVector();
				this.addSystemTypeMatrix();

				this.generateBaseVertexOutput();
			}

			this._pSystemTypes = Effect.pSystemTypes;
		}

		private initSystemFunctions(): void {
			if(isNull(Effect.pSystemFunctions)){
				this._pSystemFunctionsMap = Effect.pSystemFunctions = {};
				this.addSystemFunctions();
			}

			this._pSystemFunctionsMap = Effect.pSystemFunctions;
		}

		private initSystemVariables(): void {
			if(isNull(Effect.pSystemVariables)){
				this._pSystemVariables = Effect.pSystemVariables = <IAFXVariableDeclMap>{};
				this.addSystemVariables();
			}

			this._pSystemVariables = Effect.pSystemVariables;
		}

		private addSystemMacros(): void {
			this.generateSystemMacros("ExtractMacros",
									  "\n#ifdef AKRA_FRAGMENT\n" +
									  "//#define texture2D(sampler, ) texture2D\n" +
									  "#else\n" +
									  "#define texture2D(A, B) texture2DLod(A, B, 0.)\n" +
									  "#endif\n" +
									  "#ifndef A_VB_COMPONENT3\n" +
									  "#define A_VB_COMPONENT4\n" +
									  "#endif\n" +
									  "#ifdef A_VB_COMPONENT4\n" +
									  "#define A_VB_ELEMENT_SIZE 4.\n" +
									  "#endif\n" +
									  "#ifdef A_VB_COMPONENT3\n" +
									  "#define A_VB_ELEMENT_SIZE 3.\n" +
									  "#endif\n" +
									  "#define A_tex2D(S, H, X, Y) texture2D(S, vec2(H.stepX * X , H.stepY * Y))\n" +
									  "#define A_tex2Dv(S, H, V) texture2D(S, V)\n");
		}


		private addSystemVariables(): void {
			this.generateSystemVariable("fragColor", "gl_FragColor", "float4", false, true, true);
			this.generateSystemVariable("fragCoord", "gl_FragCoord", "float4", false, true, true);
			this.generateSystemVariable("frontFacing", "gl_FrontFacing", "bool", false, true, true);
			this.generateSystemVariable("pointCoord", "gl_PointCoord", "float2", false, true, true);
			this.generateSystemVariable("resultAFXColor", "resultAFXColor", "float4", false, true, true);

//Engine variable for passes
			this.generatePassEngineVariable();
		}

		private generateSystemVariable(sName: string, sRealName: string, sTypeName: string,
									   isForVertex: bool, isForPixel: bool, isOnlyRead: bool): void {

			if(isDef(this._pSystemVariables[sName])){
				return;
			}

			var pVariableDecl: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pName: IAFXIdInstruction = new IdInstruction();
			var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

			pName.setName(sName);
			pName.setRealName(sRealName);

			pType.pushType(Effect.getSystemType(sTypeName));

			if(isOnlyRead) {
				pType._canWrite(false);
			}

			pVariableDecl._setForVertex(isForVertex);
			pVariableDecl._setForPixel(isForPixel);

			pVariableDecl.push(pType, true);
			pVariableDecl.push(pName, true);

			this._pSystemVariables[sName] = pVariableDecl;

			pVariableDecl.setBuiltIn(true);
		}

		private generatePassEngineVariable(): void {
			var pVariableDecl: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pName: IAFXIdInstruction = new IdInstruction();
			var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

			pType._canWrite(false);

			pType._markAsUnverifiable(true);
			pName.setName("engine");
			pName.setRealName("engine");

			pVariableDecl.push(pType, true);
			pVariableDecl.push(pName, true);

			this._pSystemVariables["engine"] = pVariableDecl;
		}

		private generateBaseVertexOutput(): void {
//TODO: fix defenition of this variables

			var pOutBasetype: ComplexTypeInstruction = new ComplexTypeInstruction();

			var pPosition: VariableDeclInstruction = new VariableDeclInstruction();
			var pPointSize: VariableDeclInstruction = new VariableDeclInstruction();
			var pPositionType: VariableTypeInstruction = new VariableTypeInstruction();
			var pPointSizeType: VariableTypeInstruction = new VariableTypeInstruction();
			var pPositionId: IdInstruction = new IdInstruction();
			var pPointSizeId: IdInstruction = new IdInstruction();

			pPositionType.pushType(Effect.getSystemType("float4"));
			pPointSizeType.pushType(Effect.getSystemType("float"));

			pPositionId.setName("pos");
			pPositionId.setRealName("POSITION");

			pPointSizeId.setName("psize");
			pPointSizeId.setRealName("PSIZE");

			pPosition.push(pPositionType, true);
			pPosition.push(pPositionId, true);

			pPointSize.push(pPointSizeType, true);
			pPointSize.push(pPointSizeId, true);

			pPosition.setSemantic("POSITION");
			pPointSize.setSemantic("PSIZE");

			var pFieldCollector: IAFXInstruction = new InstructionCollector();
			pFieldCollector.push(pPosition, false);
			pFieldCollector.push(pPointSize, false);

			pOutBasetype.addFields(pFieldCollector, true);

			pOutBasetype.setName("VS_OUT");
			pOutBasetype.setRealName("VS_OUT_S");

			Effect.pSystemVertexOut = pOutBasetype;
		}

		private addSystemFunctions(): void {
			this._pSystemFunctionHashMap = <BoolMap>{};

			this.generateSystemFunction("dot", "dot($1,$2)", "float", [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("mul", "$1*$2",  "template" , [ "template" ,  "template" ], ["float", "int", "float2", "float3", "float4"]);
		    this.generateSystemFunction("mod", "mod($1,$2)", "float", ["float", "float"], null);
		    this.generateSystemFunction("floor", "floor($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("ceil", "ceil($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("fract", "fract($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("abs", "abs($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("normalize", "normalize($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("length", "length($1)", "float", [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("cross", "cross($1, $2)", "float3", ["float3", "float3"], null);
		    this.generateSystemFunction("reflect", "reflect($1,$2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("max", "max($1,$2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("max", "max($1,$2)",  "template" , [ "template" , "float"], ["float2", "float3", "float4"]);

		    this.generateSystemFunction("min", "min($1,$2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("min", "min($1,$2)",  "template" , [ "template" , "float"], ["float2", "float3", "float4"]);

		    this.generateSystemFunction("mix", "mix($1,$2,$3)",  "template" , [ "template" ,  "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("mix", "mix($1,$2,$3)",  "template" , [ "template" ,  "template" , "float"], ["float2", "float3", "float4"]);

		    this.generateSystemFunction("clamp", "clamp($1,$2,$3)",  "template" , [ "template" ,  "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("clamp", "clamp($1,$2,$3)",  "template" , [ "template" , "float", "float"], ["float2", "float3", "float4"]);

		    this.generateSystemFunction("pow", "pow($1,$2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("mod", "mod($1,$2)",  "template" , [ "template" ,  "template" ], ["float2", "float3", "float4"]);
		    this.generateSystemFunction("mod", "mod($1,$2)",  "template" , [ "template" , "float"], ["float2", "float3", "float4"]);
		    this.generateSystemFunction("exp", "exp($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("exp2", "exp2($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("log", "log($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("log2", "log2($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("inversesqrt", "inversesqrt($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("sqrt", "sqrt($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);

		    this.generateSystemFunction("all", "all($1)", "bool", [ "template" ], ["bool2", "bool3", "bool4"]);
		    this.generateSystemFunction("any", "any($1)", "bool", [ "template" ], ["bool2", "bool3", "bool4"]);
		    this.generateSystemFunction("not", "not($1)",  "template" , [ "template" ], ["bool2", "bool3", "bool4"]);

		    this.generateSystemFunction("distance", "distance($1,$2)", "float", [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);

		    this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool2", [ "template" ,  "template" ], ["float2", "int2"]);
		    this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool3", [ "template" ,  "template" ], ["float3", "int3"]);
		    this.generateSystemFunction("lessThan", "lessThan($1,$2)", "bool4", [ "template" ,  "template" ], ["float4", "int4"]);

		    this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool2", [ "template" ,  "template" ], ["float2", "int2"]);
		    this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool3", [ "template" ,  "template" ], ["float3", "int3"]);
		    this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool4", [ "template" ,  "template" ], ["float4", "int4"]);

		    this.generateSystemFunction("equal", "equal($1,$2)", "bool2", [ "template" ,  "template" ], ["float2", "int2"]);
		    this.generateSystemFunction("equal", "equal($1,$2)", "bool3", [ "template" ,  "template" ], ["float3", "int3"]);
		    this.generateSystemFunction("equal", "equal($1,$2)", "bool4", [ "template" ,  "template" ], ["float4", "int4"]);
		    this.generateSystemFunction("equal", "equal($1,$2)",  "template" , [ "template" ,  "template" ], ["bool2", "bool3", "bool4"]);

		    this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool2", [ "template" ,  "template" ], ["float2", "int2"]);
		    this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool3", [ "template" ,  "template" ], ["float3", "int3"]);
		    this.generateSystemFunction("notEqual", "notEqual($1,$2)", "bool4", [ "template" ,  "template" ], ["float4", "int4"]);
		    this.generateSystemFunction("notEqual", "notEqual($1,$2)",  "template" , [ "template" ,  "template" ], ["bool2", "bool3", "bool4"]);

		    this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool2", [ "template" ,  "template" ], ["float2", "int2"]);
		    this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool3", [ "template" ,  "template" ], ["float3", "int3"]);
		    this.generateSystemFunction("greaterThan", "greaterThan($1,$2)", "bool4", [ "template" ,  "template" ], ["float4", "int4"]);

		    this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool2", [ "template" ,  "template" ], ["float2", "int2"]);
		    this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool3", [ "template" ,  "template" ], ["float3", "int3"]);
		    this.generateSystemFunction("greaterThanEqual", "greaterThanEqual($1,$2)", "bool4", [ "template" ,  "template" ], ["float4", "int4"]);


		    this.generateSystemFunction("radians", "radians($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("degrees", "degrees($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("sin", "sin($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("cos", "cos($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("tan", "tan($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("asin", "asin($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("acos", "acos($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("atan", "atan($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("atan", "atan($1, $2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);

		    this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", ["sampler", "float2"], null);
		    this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", ["sampler2D", "float2"], null);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler", "float3"], null);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler2D", "float3"], null);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler", "float4"], null);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler2D", "float4"], null);
		    this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", ["sampler", "float3"], null);
		    this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", ["samplerCUBE", "float3"], null);

		    this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", ["sampler", "float2", "float"], null, false, true);
		    this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", ["sampler2D", "float2", "float"], null, false, true);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, false, true);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler2D", "float3", "float"], null, false, true);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler", "float4", "float"], null, false, true);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler2D", "float4", "float"], null, false, true);
		    this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, false, true);
		    this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", ["samplerCUBE", "float3", "float"], null, false, true);

		    this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", ["sampler", "float2", "float"], null, true, false);
		    this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", ["sampler2D", "float2", "float"], null, true, false);
		    this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, true, false);
		    this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler2D", "float3", "float"], null, true, false);
		    this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler", "float4", "float"], null, true, false);
		    this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler2D", "float4", "float"], null, true, false);
		    this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, true, false);
		    this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", ["samplerCUBE", "float3", "float"], null, true, false);

//OES_standard_derivatives

		    this.generateSystemFunction("dFdx", "dFdx($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("dFdy", "dFdy($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("width", "width($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("fwidth", "fwidth($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("smoothstep", "smoothstep($1, $2, $3)", "float3", ["float3", "float3", "float3"], null);
// this.generateSystemFunction("smoothstep", "smoothstep($1, $2, $3)", TEMPLATE_TYPE, [TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);
// this.generateSystemFunction("smoothstep", "smoothstep($1, $2, $3)", TEMPLATE_TYPE, ["float", "float", TEMPLATE_TYPE], ["float", "float2", "float3", "float4"]);

		    this.generateSystemFunction("frac", "fract($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("lerp", "mix($1,$2,$3)",  "template" , [ "template" ,  "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("lerp", "mix($1,$2,$3)",  "template" , [ "template" ,  "template" , "float"], ["float2", "float3", "float4"]);

//Extracts

		    this.generateNotBuiltInSystemFuction("extractHeader",
												 "void A_extractTextureHeader(const sampler2D src, out A_TextureHeader texture)",
												 "{vec4 v = texture2D(src, vec2(0.00001)); " +
												 "texture = A_TextureHeader(v.r, v.g, v.b, v.a);}",
												 "void",
												 ["video_buffer_header"], null, ["ExtractMacros"]);

		    this.generateNotBuiltInSystemFuction("extractFloat",
												 "float A_extractFloat(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "float y = floor(pixelNumber / header.width) + .5; " +
												 "float x = mod(pixelNumber, header.width) + .5; " +
												 "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " +
												 "\n#ifdef A_VB_COMPONENT4\n" +
												 "if(shift == 0) return A_tex2D(sampler, header, x, y).r; " +
												 "else if(shift == 1) return A_tex2D(sampler, header, x, y).g; " +
												 "else if(shift == 2) return A_tex2D(sampler, header, x, y).b; " +
												 "else if(shift == 3) return A_tex2D(sampler, header, x, y).a; " +
												 "\n#endif\n" +
												 "return 0.;}",
												 "float",
												 ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("extractFloat2",
												 "vec2 A_extractVec2(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "float y = floor(pixelNumber / header.width) + .5; " +
												 "float x = mod(pixelNumber, header.width) + .5; " +
												 "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " +
												 "\n#ifdef A_VB_COMPONENT4\n" +
												 "if(shift == 0) return A_tex2D(sampler, header, x, y).rg; " +
												 "else if(shift == 1) return A_tex2D(sampler, header, x, y).gb; " +
												 "else if(shift == 2) return A_tex2D(sampler, header, x, y).ba; " +
												 "else if(shift == 3) { " +
												 "if(int(x) == int(header.width - 1.)) " +
												 "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " +
												 "else " +
												 "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).r); " +
												 "} " +
												 "\n#endif\n" +
												 "return vec2(0.);}",
												 "float2",
												 ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("extractFloat3",
												 "vec3 A_extractVec3(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "float y = floor(pixelNumber / header.width) + .5; " +
												 "float x = mod(pixelNumber, header.width) + .5; " +
												 "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " +
												 "\n#ifdef A_VB_COMPONENT4\n" +
												 "if(shift == 0) return A_tex2D(sampler, header, x, y).rgb; " +
												 "else if(shift == 1) return A_tex2D(sampler, header, x, y).gba; " +
												 "else if(shift == 2){ " +
												 "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " +
												 "else return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).r);} " +
												 "else if(shift == 3){ " +
												 "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " +
												 "else return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rg);} " +
												 "\n#endif\n" +
												 "\n#ifdef A_VB_COMPONENT3\n" +
												 "if(shift == 0) return A_tex2D(sampler, header,vec2(x,header.stepY*y)).rgb; " +
												 "else if(shift == 1){ " +
												 "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " +
												 "else return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, (x + 1.), y).r);} " +
												 "else if(shift == 3){ " +
												 "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " +
												 "else return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, (x + 1)., y).rg);} " +
												 "\n#endif\n" +
												 "return vec3(0.);}",
												 "float3",
												 ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("extractFloat4",
												 "vec4 A_extractVec4(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "float y = floor(pixelNumber / header.width) + .5; " +
												 "float x = mod(pixelNumber, header.width) + .5; " +
												 "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " +
												 "\n#ifdef A_VB_COMPONENT4\n" +
												 "if(shift == 0) return A_tex2D(sampler, header, x, y); " +
												 "else if(shift == 1){ " +
												 "if(int(x) == int(header.width - 1.)) " +
												 "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, 0.5, (y + 1.)).r); " +
												 "else " +
												 "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, (x + 1.), y).r);} " +
												 "else if(shift == 2){ " +
												 "if(int(x) == int(header.width - 1.)) " +
												 "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0.5, (y + 1.)).rg); " +
												 "else " +
												 "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).rg);} " +
												 "else if(shift == 3){ " +
												 "if(int(x) == int(header.width - 1.)) " +
												 "return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0.5, (y + 1.)).rgb); " +
												 "else return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rgb);} " +
												 "\n#endif\n" +
												 "\n#ifdef A_VB_COMPONENT3\n" +
												 "\n#endif\n" +
												 "return vec4(0.);}",
												 "float4",
												 ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("findPixel",
												 "vec2 A_findPixel(const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "return vec2(header.stepX * (mod(pixelNumber, header.width) + .5), header.stepY * (floor(pixelNumber / header.width) + .5));}",
												 "float2",
												 ["video_buffer_header"], ["extractHeader"], ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("extractFloat4x4",
												 "mat4 A_extractMat4(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{return mat4(A_tex2Dv(sampler, header, A_findPixel(header, offset))," +
												 "A_tex2Dv(sampler, header, A_findPixel(header, offset + 4.))," +
												 "A_tex2Dv(sampler, header, A_findPixel(header, offset + 8.))," +
												 "A_tex2Dv(sampler, header, A_findPixel(header, offset + 12.)));}",
												 "float4x4",
												 ["video_buffer_header"], ["findPixel"], ["ExtractMacros"]);
		}

		private generateSystemFunction(sName: string, sTranslationExpr: string,
									   sReturnTypeName: string,
									   pArgumentsTypes: string[],
									   pTemplateTypes: string[],
									   isForVertex?: bool = true, isForPixel?: bool = true): void {

			var pExprTranslator: ExprTemplateTranslator = new ExprTemplateTranslator(sTranslationExpr);
			var pSystemFunctions: SystemFunctionMap = this._pSystemFunctionsMap;
			var pTypes: IAFXTypeInstruction[] = null;
			var sFunctionHash: string = "";
			var pReturnType: IAFXTypeInstruction = null;
			var pFunction: SystemFunctionInstruction = null;

			if(!isNull(pTemplateTypes)){
				for(var i:  number  = 0; i < pTemplateTypes.length; i++) {
					pTypes = [];
					sFunctionHash = sName + "(";
					pReturnType = (sReturnTypeName ===  "template" ) ?
																Effect.getSystemType(pTemplateTypes[i]) :
																Effect.getSystemType(sReturnTypeName);


					for(var j:  number  = 0; j < pArgumentsTypes.length; j++) {
						if(pArgumentsTypes[j] ===  "template" ){
							pTypes.push(Effect.getSystemType(pTemplateTypes[i]));
							sFunctionHash += pTemplateTypes[i] + ",";
						}
						else{
							pTypes.push(Effect.getSystemType(pArgumentsTypes[j]));
							sFunctionHash += pArgumentsTypes[j] + ","
						}
					}

					sFunctionHash += ")";

					if(this._pSystemFunctionHashMap[sFunctionHash]){
						this._error( 2248 , {funcName: sFunctionHash});
					}

					pFunction = new SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);

					if(!isDef(pSystemFunctions[sName])){
						pSystemFunctions[sName] = [];
					}

					pFunction._setForVertex(isForVertex);
					pFunction._setForPixel(isForPixel);

					pSystemFunctions[sName].push(pFunction);
					pFunction.setBuiltIn(true);
				}
			}
			else {

				if(sReturnTypeName ===  "template" ){
					akra.logger.criticalError("Bad return type(TEMPLATE_TYPE) for system function '" + sName +  "'.");
				}

				pReturnType = Effect.getSystemType(sReturnTypeName);
				pTypes = [];
				sFunctionHash = sName + "(";

				for(var i:  number  = 0; i < pArgumentsTypes.length; i++){
					if(pArgumentsTypes[i] ===  "template" ){
						akra.logger.criticalError("Bad argument type(TEMPLATE_TYPE) for system function '" + sName +  "'.");
					}
					else{
						pTypes.push(Effect.getSystemType(pArgumentsTypes[i]));
						sFunctionHash += pArgumentsTypes[i] + ",";
					}
				}

				sFunctionHash += ")";

				if(this._pSystemFunctionHashMap[sFunctionHash]){
					this._error( 2248 , {funcName: sFunctionHash});
				}

				pFunction = new SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);

				pFunction._setForVertex(isForVertex);
				pFunction._setForPixel(isForPixel);

				if(!isDef(pSystemFunctions[sName])){
					pSystemFunctions[sName] = [];
				}

				pSystemFunctions[sName].push(pFunction);
				pFunction.setBuiltIn(true);
			}

	}

		private generateSystemMacros(sMacrosName: string, sMacrosCode: string): void {
			if(isDef(this._pSystemMacros[sMacrosName])){
				return;
			}

			var pMacros: IAFXSimpleInstruction = new SimpleInstruction(sMacrosCode);

			this._pSystemMacros[sMacrosName] = pMacros;
		}

		private generateNotBuiltInSystemFuction(sName: string, sDefenition: string, sImplementation: string,
												sReturnType: string,
												pUsedTypes: string[],
												pUsedFunctions: string[],
												pUsedMacros: string[]): void {

			if(isDef(this._pSystemFunctionsMap[sName])){
				return;
			}

			var pReturnType: IAFXTypeInstruction = Effect.getSystemType(sReturnType);
			var pFunction: SystemFunctionInstruction = new SystemFunctionInstruction(sName, pReturnType, null, null);

			pFunction.setDeclCode(sDefenition, sImplementation);

			var pUsedExtSystemTypes: IAFXTypeDeclInstruction[] = [];
			var pUsedExtSystemFunctions: IAFXFunctionDeclInstruction[] = [];
			var pUsedExtSystemMacros: IAFXSimpleInstruction[] = [];

			if(!isNull(pUsedTypes)){
				for(var i:  number  = 0; i < pUsedTypes.length; i++){
					var pTypeDecl: IAFXTypeDeclInstruction = <IAFXTypeDeclInstruction>Effect.getSystemType(pUsedTypes[i]).getParent();
					if(!isNull(pTypeDecl)){
						pUsedExtSystemTypes.push(pTypeDecl);
					}
				}
			}

			if(!isNull(pUsedMacros)){
				for(var i:  number  = 0; i < pUsedMacros.length; i++) {
					pUsedExtSystemMacros.push(Effect.getSystemMacros(pUsedMacros[i]));
				}
			}

			if(!isNull(pUsedFunctions)){
				for(var i:  number  = 0; i < pUsedFunctions.length; i++) {
					var pFindFunction: IAFXFunctionDeclInstruction = Effect.findSystemFunction(pUsedFunctions[i], null);
					pUsedExtSystemFunctions.push(pFindFunction);
				}
			}

			pFunction.setUsedSystemData(pUsedExtSystemTypes, pUsedExtSystemFunctions, pUsedExtSystemMacros);
			pFunction.closeSystemDataInfo();
			pFunction.setBuiltIn(false);

			this._pSystemFunctionsMap[sName] = [pFunction];
		}

		private generateSystemType(sName: string, sRealName: string,
								   iSize:  number  = 1, isArray: bool = false,
								   pElementType: IAFXTypeInstruction = null, iLength:  number  = 1
								  ): IAFXTypeInstruction {

			if(isDef(this._pSystemTypes[sName])){
				return null;
			}

			var pSystemType: SystemTypeInstruction = new SystemTypeInstruction();

			pSystemType.setName(sName);
			pSystemType.setRealName(sRealName);
			pSystemType.setSize(iSize);
			if(isArray){
				pSystemType.addIndex(pElementType, iLength);
			}

			this._pSystemTypes[sName] = pSystemType;
			pSystemType.setBuiltIn(true);

			return pSystemType;
		}

		private generateNotBuildtInSystemType(sName: string, sRealName: string, sDeclString: string,
											  iSize:  number  = 1, isArray: bool = false,
								  			  pElementType: IAFXTypeInstruction = null, iLength:  number  = 1
								  			 ): IAFXTypeInstruction {

			if(isDef(this._pSystemTypes[sName])){
				return null;
			}

			var pSystemType: SystemTypeInstruction = new SystemTypeInstruction();
			pSystemType.setName(sName);
			pSystemType.setRealName(sRealName);
			pSystemType.setSize(iSize);
			pSystemType.setDeclString(sDeclString);

			if(isArray){
				pSystemType.addIndex(pElementType, iLength);
			}

			this._pSystemTypes[sName] = pSystemType;
			pSystemType.setBuiltIn(false);

			var pSystemTypeDecl: IAFXTypeDeclInstruction = new TypeDeclInstruction();
			pSystemTypeDecl.push(pSystemType, true);
			pSystemTypeDecl.setBuiltIn(false);

			return pSystemType;
		}

		private addSystemTypeScalar(): void {
			this.generateSystemType("void", "void", 0);
			this.generateSystemType("int", "int", 1);
			this.generateSystemType("bool", "bool", 1);
			this.generateSystemType("float", "float", 1);
			this.generateSystemType("ptr", "float", 1);
			this.generateSystemType("string", "", 0);
			this.generateSystemType("texture", "", 0);
			this.generateSystemType("sampler", "sampler2D", 1);
			this.generateSystemType("sampler2D", "sampler2D", 1);
			this.generateSystemType("samplerCUBE", "samplerCube", 1);
			this.generateSystemType("video_buffer", "sampler2D", 1);


			this.generateNotBuildtInSystemType("video_buffer_header", "A_TextureHeader",
				"struct A_TextureHeader { float width; float height; float stepX; float stepY; }");
		}

		private addSystemTypeVector(): void {
			var pXYSuffix: BoolMap = <BoolMap>{};
			var pXYZSuffix: BoolMap = <BoolMap>{};
			var pXYZWSuffix: BoolMap = <BoolMap>{};

			var pRGSuffix: BoolMap = <BoolMap>{};
			var pRGBSuffix: BoolMap = <BoolMap>{};
			var pRGBASuffix: BoolMap = <BoolMap>{};

			var pSTSuffix: BoolMap = <BoolMap>{};
			var pSTPSuffix: BoolMap = <BoolMap>{};
			var pSTPQSuffix: BoolMap = <BoolMap>{};

			this.generateSuffixLiterals(["x", "y"], pXYSuffix);
			this.generateSuffixLiterals(["x", "y", "z"], pXYZSuffix);
			this.generateSuffixLiterals(["x", "y", "z", "w"], pXYZWSuffix);

			this.generateSuffixLiterals(["r", "g"], pRGSuffix);
			this.generateSuffixLiterals(["r", "g", "b"], pRGBSuffix);
			this.generateSuffixLiterals(["r", "g", "b", "a"], pRGBASuffix);

			this.generateSuffixLiterals(["s", "t"], pSTSuffix);
			this.generateSuffixLiterals(["s", "t", "p"], pSTPSuffix);
			this.generateSuffixLiterals(["s", "t", "p", "q"], pSTPQSuffix);

			var pFloat: IAFXTypeInstruction = Effect.getSystemType("float");
			var pInt: IAFXTypeInstruction = Effect.getSystemType("int");
			var pBool: IAFXTypeInstruction = Effect.getSystemType("bool");

			var pFloat2: IAFXTypeInstruction = this.generateSystemType("float2", "vec2", 0, true, pFloat, 2);
			var pFloat3: IAFXTypeInstruction = this.generateSystemType("float3", "vec3", 0, true, pFloat, 3);
			var pFloat4: IAFXTypeInstruction = this.generateSystemType("float4", "vec4", 0, true, pFloat, 4);

			var pInt2: IAFXTypeInstruction = this.generateSystemType("int2", "ivec2", 0, true, pInt, 2);
			var pInt3: IAFXTypeInstruction = this.generateSystemType("int3", "ivec3", 0, true, pInt, 3);
			var pInt4: IAFXTypeInstruction = this.generateSystemType("int4", "ivec4", 0, true, pInt, 4);

			var pBool2: IAFXTypeInstruction = this.generateSystemType("bool2", "bvec2", 0, true, pBool, 2);
			var pBool3: IAFXTypeInstruction = this.generateSystemType("bool3", "bvec3", 0, true, pBool, 3);
			var pBool4: IAFXTypeInstruction = this.generateSystemType("bool4", "bvec4", 0, true, pBool, 4);

			this.addFieldsToVectorFromSuffixObject(pXYSuffix, pFloat2, "float");
			this.addFieldsToVectorFromSuffixObject(pRGSuffix, pFloat2, "float");
			this.addFieldsToVectorFromSuffixObject(pSTSuffix, pFloat2, "float");

			this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pFloat3, "float");
			this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pFloat3, "float");
			this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pFloat3, "float");

			this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pFloat4, "float");
			this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pFloat4, "float");
			this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pFloat4, "float");

			this.addFieldsToVectorFromSuffixObject(pXYSuffix, pInt2, "int");
			this.addFieldsToVectorFromSuffixObject(pRGSuffix, pInt2, "int");
			this.addFieldsToVectorFromSuffixObject(pSTSuffix, pInt2, "int");

			this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pInt3, "int");
			this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pInt3, "int");
			this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pInt3, "int");

			this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pInt4, "int");
			this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pInt4, "int");
			this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pInt4, "int");

			this.addFieldsToVectorFromSuffixObject(pXYSuffix, pBool2, "bool");
			this.addFieldsToVectorFromSuffixObject(pRGSuffix, pBool2, "bool");
			this.addFieldsToVectorFromSuffixObject(pSTSuffix, pBool2, "bool");

			this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pBool3, "bool");
			this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pBool3, "bool");
			this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pBool3, "bool");

			this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pBool4, "bool");
			this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pBool4, "bool");
			this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pBool4, "bool");
		}

		private addSystemTypeMatrix(): void {
			var pFloat2: IAFXTypeInstruction = Effect.getSystemType("float2");
			var pFloat3: IAFXTypeInstruction = Effect.getSystemType("float3");
			var pFloat4: IAFXTypeInstruction = Effect.getSystemType("float4");

			var pInt2: IAFXTypeInstruction = Effect.getSystemType("int2");
			var pInt3: IAFXTypeInstruction = Effect.getSystemType("int3");
			var pInt4: IAFXTypeInstruction = Effect.getSystemType("int4");

			var pBool2: IAFXTypeInstruction = Effect.getSystemType("bool2");
			var pBool3: IAFXTypeInstruction = Effect.getSystemType("bool3");
			var pBool4: IAFXTypeInstruction = Effect.getSystemType("bool4");

			this.generateSystemType("float2x2", "mat2",   0, true, pFloat2, 2);
			this.generateSystemType("float2x3", "mat2x3", 0, true, pFloat2, 3);
			this.generateSystemType("float2x4", "mat2x4", 0, true, pFloat2, 4);

			this.generateSystemType("float3x2", "mat3x2", 0, true, pFloat3, 2);
			this.generateSystemType("float3x3", "mat3",   0, true, pFloat3, 3);
			this.generateSystemType("float3x4", "mat3x4", 0, true, pFloat3, 4);

			this.generateSystemType("float4x2", "mat4x2", 0, true, pFloat4, 2);
			this.generateSystemType("float4x3", "mat4x3", 0, true, pFloat4, 3);
			this.generateSystemType("float4x4", "mat4",   0, true, pFloat4, 4);

			this.generateSystemType("int2x2", "imat2",   0, true, pInt2, 2);
			this.generateSystemType("int2x3", "imat2x3", 0, true, pInt2, 3);
			this.generateSystemType("int2x4", "imat2x4", 0, true, pInt2, 4);

			this.generateSystemType("int3x2", "imat3x2", 0, true, pInt3, 2);
			this.generateSystemType("int3x3", "imat3",   0, true, pInt3, 3);
			this.generateSystemType("int3x4", "imat3x4", 0, true, pInt3, 4);

			this.generateSystemType("int4x2", "imat4x2", 0, true, pInt4, 2);
			this.generateSystemType("int4x3", "imat4x3", 0, true, pInt4, 3);
			this.generateSystemType("int4x4", "imat4",   0, true, pInt4, 4);

			this.generateSystemType("bool2x2", "bmat2",   0, true, pBool2, 2);
			this.generateSystemType("bool2x3", "bmat2x3", 0, true, pBool2, 3);
			this.generateSystemType("bool2x4", "bmat2x4", 0, true, pBool2, 4);

			this.generateSystemType("bool3x2", "bmat3x2", 0, true, pBool3, 2);
			this.generateSystemType("bool3x3", "bmat3",   0, true, pBool3, 3);
			this.generateSystemType("bool3x4", "bmat3x4", 0, true, pBool3, 4);

			this.generateSystemType("bool4x2", "bmat4x2", 0, true, pBool4, 2);
			this.generateSystemType("bool4x3", "bmat4x3", 0, true, pBool4, 3);
			this.generateSystemType("bool4x4", "bmat4",   0, true, pBool4, 4);
		}

		private addFieldsToVectorFromSuffixObject(pSuffixMap: BoolMap, pType: IAFXTypeInstruction, sBaseType: string) {
			var sSuffix: string = null;

			for(sSuffix in pSuffixMap){
				var sFieldTypeName: string = sBaseType + ((sSuffix.length > 1) ? sSuffix.length.toString() : "");
				var pFieldType: IAFXTypeInstruction = Effect.getSystemType(sFieldTypeName);

				(<SystemTypeInstruction>pType).addField(sSuffix, pFieldType, pSuffixMap[sSuffix]);
			}
		}

		private  /**@inline*/  getVariable(sName: string): IAFXVariableDeclInstruction {
			return Effect.getSystemVariable(sName) || this._pEffectScope.getVariable(sName);
		}

		private  /**@inline*/  hasVariable(sName: string): bool {
			return this._pEffectScope.hasVariable(sName);
		}

		private getType(sTypeName: string): IAFXTypeInstruction {
			return Effect.getSystemType(sTypeName) || this._pEffectScope.getType(sTypeName);
		}

		private isSystemFunction(pFunction: IAFXFunctionDeclInstruction): bool {
			return false;
		}

		private isSystemVariable(pVariable: IAFXVariableDeclInstruction): bool {
			return false;
		}

		private isSystemType(pType: IAFXTypeDeclInstruction): bool {
			return false;
		}

		private  /**@inline*/  _errorFromInstruction(pError: IAFXInstructionError): void {
			this._error(pError.code, isNull(pError.info) ? {} : pError.info);
		}

		private _error(eCode:  number , pInfo: IEffectErrorInfo = {}): void {
			var sFileName: string = this._sAnalyzedFileName;

			var pLocation: ISourceLocation = <ISourceLocation>{file: this._sAnalyzedFileName, line: 0};
			var pLineColumn: {line:  number ; column:  number ;} = this.getNodeSourceLocation(this.getAnalyzedNode());

			switch(eCode){
				default:
					pInfo.line = pLineColumn.line + 1;
					pInfo.column = pLineColumn.column + 1;

					pLocation.line = pLineColumn.line + 1;

					break;
			}

			var pLogEntity: ILoggerEntity = <ILoggerEntity>{code: eCode, info: pInfo, location: pLocation};

			akra.logger["error"](pLogEntity);
			throw new Error(eCode.toString());
		}

		private  /**@inline*/  setAnalyzedNode(pNode: IParseNode): void {
// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode); 
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
			this._pAnalyzedNode = pNode;
		}

		private  /**@inline*/  getAnalyzedNode(): IParseNode {
			return this._pAnalyzedNode;
		}

		private  /**@inline*/  isStrictMode(): bool {
			return this._pEffectScope.isStrictMode();
		}

		private  /**@inline*/  setStrictModeOn(): void {
			return this._pEffectScope.setStrictModeOn();
		}

		private  /**@inline*/  newScope(eScopeType?: EScopeType = EScopeType.k_Default): void {
			this._pEffectScope.newScope(eScopeType);
		}

		private  /**@inline*/  resumeScope(): void {
			this._pEffectScope.resumeScope();
		}

		private  /**@inline*/  getScope():  number  {
			return this._pEffectScope.getScope();
		}

		private  /**@inline*/  setScope(iScope:  number ): void {
			this._pEffectScope.setScope(iScope);
		}

		private  /**@inline*/  endScope(): void {
			this._pEffectScope.endScope();
		}

		private  /**@inline*/  getScopeType(): EScopeType {
			return this._pEffectScope.getScopeType();
		}

		private  /**@inline*/  setCurrentAnalyzedFunction(pFunction: IAFXFunctionDeclInstruction): void {
			this._pCurrentFunction = pFunction;
		}

		private  /**@inline*/  getCurrentAnalyzedFunction(): IAFXFunctionDeclInstruction {
			return this._pCurrentFunction;
		}

		private  /**@inline*/  isAnalzeInPass(): bool {
			return this._isAnalyzeInPass;
		}

		private  /**@inline*/  setAnalyzeInPass(isInPass: bool): void {
			this._isAnalyzeInPass = isInPass;
		}

		private  /**@inline*/  setOperator(sOperator: string): void {
			if(!isNull(this._pCurrentInstruction)){
				this._pCurrentInstruction.setOperator(sOperator);
			}
		}

		private  /**@inline*/  clearPointersForExtract(): void {
			this._pPointerForExtractionList.length = 0;
		}

		private  /**@inline*/  addPointerForExtract(pPointer: IAFXVariableDeclInstruction): void {
			this._pPointerForExtractionList.push(pPointer);
		}

		private  /**@inline*/  getPointerForExtractList(): IAFXVariableDeclInstruction[] {
			return this._pPointerForExtractionList;
		}

		private findFunction(sFunctionName: string,
							 pArguments: IAFXExprInstruction[]): IAFXFunctionDeclInstruction;
		private findFunction(sFunctionName: string,
							 pArguments: IAFXVariableDeclInstruction[]): IAFXFunctionDeclInstruction;
		private findFunction(sFunctionName: string,
							 pArguments: IAFXTypedInstruction[]): IAFXFunctionDeclInstruction {
			return Effect.findSystemFunction(sFunctionName, pArguments) ||
				   this._pEffectScope.getFunction(sFunctionName, pArguments);
		}

		private findConstructor(pType: IAFXTypeInstruction,
							    pArguments: IAFXExprInstruction[]): IAFXVariableTypeInstruction {

			var pVariableType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			pVariableType.pushType(pType);

			return pVariableType;
		}

		private findShaderFunction(sFunctionName: string,
							 	   pArguments: IAFXExprInstruction[]): IAFXFunctionDeclInstruction {
			return this._pEffectScope.getShaderFunction(sFunctionName, pArguments);
		}

		private findFunctionByDef(pDef: FunctionDefInstruction): IAFXFunctionDeclInstruction {
			return this.findFunction(pDef.getName(), pDef.getArguments());
		}

// private addVariable(pVariable: IAFXVariable): void {
// }

		private addVariableDecl(pVariable: IAFXVariableDeclInstruction): void {
			if(this.isSystemVariable(pVariable)){
        		this._error( 2235 , {varName: pVariable.getName()});
        	}

        	var isVarAdded: bool = this._pEffectScope.addVariable(pVariable);

        	if(!isVarAdded) {
        		var eScopeType: EScopeType = this.getScopeType();

        		switch(eScopeType){
        			case EScopeType.k_Default:
        				this._error( 2234 , {varName: pVariable.getName()});
        				break;
        			case EScopeType.k_Struct:
        				this._error( 2242 , {fieldName: pVariable.getName()});
        				break;
        			case EScopeType.k_Annotation:
        				this._error( 2244 , {varName: pVariable.getName()});
        				break;
        		}
			}

			if(pVariable.getName() === "Out" && !isNull(this.getCurrentAnalyzedFunction())){
        		var isOk: bool = this.getCurrentAnalyzedFunction()._addOutVariable(pVariable);
        		if(!isOk){
        			this._error( 2266 );
        		}
        	}
        }

        private addTypeDecl(pType: IAFXTypeDeclInstruction): void {
        	if(this.isSystemType(pType)){
        		this._error( 2201 , {typeName: pType.getName()});
        	}

        	var isTypeAdded: bool = this._pEffectScope.addType(pType);

        	if(!isTypeAdded) {
				this._error( 2202 , {typeName: pType.getName()});
			}
        }

        private addFunctionDecl(pFunction: IAFXFunctionDeclInstruction): void {
        	if(this.isSystemFunction(pFunction)){
        		this._error( 2237 , {funcName: pFunction.getName()});
        	}

        	var isFunctionAdded: bool = this._pEffectScope.addFunction(pFunction);

        	if(!isFunctionAdded) {
				this._error( 2236 , {funcName: pFunction.getName()});
			}
        }

        private addTechnique(pTechnique: IAFXTechniqueInstruction): void {
        	var sName: string = pTechnique.getName();

        	if(isDef(this._pTechniqueMap[sName])){
        		this._error( 2252 , { techName: sName });
        		return;
        	}

        	this._pTechniqueMap[sName] = pTechnique;
        	this._pTechniqueList.push(pTechnique);
        }

        private addExternalSharedVariable(pVariable: IAFXVariableDeclInstruction, eShaderType: EFunctionType): void {
        	var isVarAdded: bool = this._pEffectScope.addVariable(pVariable);

        	if(!isVarAdded) {
   				this._error( 2278 , {varName: pVariable.getName()});
   				return;
			}
        }


        private analyzeGlobalUseDecls(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "UseDecl") {
					this.analyzeUseDecl(pChildren[i]);
				}
			}
        }

        private analyzeGlobalProvideDecls(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "ProvideDecl") {
					this.analyzeProvideDecl(pChildren[i]);
				}
			}
        }

        private analyzeGlobalTypeDecls(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "TypeDecl") {
					this.analyzeTypeDecl(pChildren[i]);
				}
			}
        }

        private analyzeFunctionDefinitions(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "FunctionDecl") {
					this.analyzeFunctionDeclOnlyDefinition(pChildren[i]);
				}
			}
        }

        private analyzeGlobalImports(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "ImportDecl") {
					this.analyzeImportDecl(pChildren[i], null);
				}
			}
        }

        private analyzeTechniqueImports(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "TechniqueDecl") {
					this.analyzeTechniqueForImport(pChildren[i]);
				}
			}
        }

        private analyzeVariableDecls() : void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "VariableDecl") {
					this.analyzeVariableDecl(pChildren[i]);
				}
				else if(pChildren[i].name === "VarStructDecl"){
					this.analyzeVarStructDecl(pChildren[i]);
				}
			}
        }

        private analyzeFunctionDecls(): void {
        	for(var i:  number  = 0; i < this._pFunctionWithImplementationList.length; i++) {
        		this.resumeFunctionAnalysis(this._pFunctionWithImplementationList[i]);
        	}

        	this.checkFunctionsForRecursion();
        	this.checkFunctionForCorrectUsage();
        	this.generateInfoAboutUsedData();
        	this.generateShadersFromFunctions();
        }

        private analyzeTechniques(): void {
        	for(var i:  number  = 0; i < this._pTechniqueList.length; i++) {
        		this.resumeTechniqueAnalysis(this._pTechniqueList[i]);
        	}
        }

        private checkFunctionsForRecursion(): void {
        	var pFunctionList: IAFXFunctionDeclInstruction[] = this._pFunctionWithImplementationList;
        	var isNewAdd: bool = true;
        	var isNewDelete: bool = true;

        	while(isNewAdd || isNewDelete) {
        		isNewAdd = false;
        		isNewDelete = false;

        		mainFor:
        		for(var i:  number  = 0; i < pFunctionList.length; i++){
        			var pTestedFunction: IAFXFunctionDeclInstruction = pFunctionList[i];
        			var pUsedFunctionList: IAFXFunctionDeclInstruction[] = pTestedFunction._getUsedFunctionList();

        			if(!pTestedFunction._isUsed()){
//WARNING("Unused function '" + pTestedFunction._getStringDef() + "'.");
        				continue mainFor;
        			}
        			if(pTestedFunction._isBlackListFunction()){
        				continue mainFor;
        			}

        			if(isNull(pUsedFunctionList)){
        				continue mainFor;
        			}

        			for(var j:  number  = 0; j < pUsedFunctionList.length; j++) {
        				var pAddedUsedFunctionList: IAFXFunctionDeclInstruction[] = pUsedFunctionList[j]._getUsedFunctionList();

        				if(isNull(pAddedUsedFunctionList)){
        					continue;
        				}

        				for(var k:  number  = 0; k < pAddedUsedFunctionList.length; k++) {
        					var pAddedFunction: IAFXFunctionDeclInstruction = pAddedUsedFunctionList[k];

        					if(pTestedFunction === pAddedFunction){
        						pTestedFunction._addToBlackList();
        						isNewDelete = true;
        						this._error( 2255 , { funcDef: pTestedFunction._getStringDef() });
        						continue mainFor;
        					}

        					if (pAddedFunction._isBlackListFunction() ||
        						!pAddedFunction._canUsedAsFunction()){
        						pTestedFunction._addToBlackList();
        						this._error( 2256 , { funcDef: pTestedFunction._getStringDef() });
        						isNewDelete = true;
        						continue mainFor;
        					}

        					if(pTestedFunction._addUsedFunction(pAddedFunction)){
        						isNewAdd = true;
        					}
        				}
        			}
        		}
        	}
        }

        private checkFunctionForCorrectUsage(): void {
        	var pFunctionList: IAFXFunctionDeclInstruction[] = this._pFunctionWithImplementationList;
        	var isNewUsageSet: bool = true;
        	var isNewDelete: bool = true;

        	while(isNewUsageSet || isNewDelete){
        		isNewUsageSet = false;
        		isNewDelete = false;

        		mainFor:
        		for(var i:  number  = 0; i < pFunctionList.length; i++) {
        			var pTestedFunction: IAFXFunctionDeclInstruction = pFunctionList[i];
        			var pUsedFunctionList: IAFXFunctionDeclInstruction[] = pTestedFunction._getUsedFunctionList();

        			if(!pTestedFunction._isUsed()){
//WARNING("Unused function '" + pTestedFunction._getStringDef() + "'.");
        				continue mainFor;
        			}
        			if(pTestedFunction._isBlackListFunction()){
        				continue mainFor;
        			}

        			if(!pTestedFunction._checkVertexUsage()){
        				this._error( 2257 , { funcDef: pTestedFunction._getStringDef() });
        				pTestedFunction._addToBlackList();
        				isNewDelete = true;
        				continue mainFor;
        			}

        			if(!pTestedFunction._checkPixelUsage()){
        				this._error( 2258 , { funcDef: pTestedFunction._getStringDef() });
        				pTestedFunction._addToBlackList();
        				isNewDelete = true;
        				continue mainFor;
        			}

        			if(isNull(pUsedFunctionList)){
        				continue mainFor;
        			}

        			for(var j:  number  = 0; j < pUsedFunctionList.length; j++) {
        				var pUsedFunction: IAFXFunctionDeclInstruction = pUsedFunctionList[j];

        				if(pTestedFunction._isUsedInVertex()){
        					if(!pUsedFunction._isForVertex()){
        						this._error( 2257 , { funcDef: pTestedFunction._getStringDef() });
		        				pTestedFunction._addToBlackList();
		        				isNewDelete = true;
		        				continue mainFor;
        					}

        					if(!pUsedFunction._isUsedInVertex()){
	        					pUsedFunction._markUsedInVertex();
        						isNewUsageSet = true;
        					}

        				}

        				if(pTestedFunction._isUsedInPixel()){
        					if(!pUsedFunction._isForPixel()){
        						this._error( 2258 , { funcDef: pTestedFunction._getStringDef() });
		        				pTestedFunction._addToBlackList();
		        				isNewDelete = true;
		        				continue mainFor;
        					}

        					if(!pUsedFunction._isUsedInPixel()){
	        					pUsedFunction._markUsedInPixel();
	        					isNewUsageSet = true;
        					}
        				}

        			}
        		}

        	}

        	return;
        }

        private generateInfoAboutUsedData(): void {
        	var pFunctionList: IAFXFunctionDeclInstruction[] = this._pFunctionWithImplementationList;

        	for(var i:  number  = 0; i < pFunctionList.length; i++){
        		pFunctionList[i]._generateInfoAboutUsedData();
        	}
        }

        private generateShadersFromFunctions(): void {
        	var pFunctionList: IAFXFunctionDeclInstruction[] = this._pFunctionWithImplementationList;

        	for(var i:  number  = 0; i < pFunctionList.length; i++){
        		var pShader: IAFXFunctionDeclInstruction = null;

        		if(pFunctionList[i]._isUsedAsVertex()){
        			pShader = pFunctionList[i]._convertToVertexShader();
        		}
        		if(pFunctionList[i]._isUsedAsPixel()){
        			pShader = pFunctionList[i]._convertToPixelShader();
        		}
        	}
        }

		private analyzeVariableDecl(pNode: IParseNode, pInstruction?: IAFXInstruction = null): void {
			this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pGeneralType: IAFXVariableTypeInstruction = null;
        	var pVariable: IAFXVariableDeclInstruction = null;
        	var i:  number  = 0;

        	pGeneralType = this.analyzeUsageType(pChildren[pChildren.length - 1]);

        	for(i = pChildren.length - 2; i >= 1; i--){
        		if(pChildren[i].name === "Variable") {
        			pVariable = this.analyzeVariable(pChildren[i], pGeneralType);

        			if(!isNull(pInstruction)){
        				pInstruction.push(pVariable, true);
        				if(pInstruction._getInstructionType() === EAFXInstructionTypes.k_DeclStmtInstruction) {
	        				var pVariableSubDecls: IAFXVariableDeclInstruction[] = pVariable.getSubVarDecls();
	        				if(!isNull(pVariableSubDecls)){
		        				for(var j:  number  = 0; j < pVariableSubDecls.length; j++) {
		        					pInstruction.push(pVariableSubDecls[j], false);
		        				}
	        				}
	        			}
        			}
        		}
        	}
        }

      	private analyzeUsageType(pNode: IParseNode): IAFXVariableTypeInstruction {
      		this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
		    var i:  number  = 0;
		    var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

		    for (i = pChildren.length - 1; i >= 0; i--) {
		        if (pChildren[i].name === "Type") {
		        	var pMainType: IAFXTypeInstruction = this.analyzeType(pChildren[i]);
		        	pType.pushType(pMainType);
		        }
		        else if (pChildren[i].name === "Usage") {
		        	var sUsage: string = this.analyzeUsage(pChildren[i]);
		        	pType.addUsage(sUsage);
		        }
		    }

		    if(!pType.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pType.getLastError()); } ;

		    return pType;
        }

        private analyzeType(pNode: IParseNode): IAFXTypeInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pType: IAFXTypeInstruction = null;

        	switch(pNode.name){
        		case "T_TYPE_ID":
        			pType = this.getType(pNode.value);

			        if (isNull(pType)) {
			            this._error( 2250 , { typeName: pNode.value });
			        }
			        break;

			    case "Struct":
			    	pType = this.analyzeStruct(pNode);
			    	break;

			   	case "T_KW_VOID":
			   		pType = Effect.getSystemType("void");
			   		break;

			   	case "ScalarType":
			   	case "ObjectType":
			   		pType = this.getType(pChildren[pChildren.length - 1].value);

			   		if (isNull(pType)) {
			            this._error( 2250 , { typeName: pChildren[pChildren.length - 1].value });
			        }

			       	break;

			    case "VectorType":
			    case "MatrixType":
			    	this._error( 2251 );
			    	break;

			   	case "BaseType":
			   	case "Type":
			   		return this.analyzeType(pChildren[0]);
        	}

        	return pType;
        }

        private analyzeUsage(pNode: IParseNode): string {
        	this.setAnalyzedNode(pNode);

        	pNode = pNode.children[0];
        	return pNode.value;
        }

        private analyzeVariable(pNode: IParseNode, pGeneralType: IAFXVariableTypeInstruction): IAFXVariableDeclInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var pVarDecl: IAFXVariableDeclInstruction = new VariableDeclInstruction();
        	var pVariableType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
        	var pAnnotation: IAFXAnnotationInstruction = null;
        	var sSemantic: string = "";
        	var pInitExpr: IAFXInitExprInstruction = null;

        	pVarDecl.push(pVariableType, true);
        	pVariableType.pushType(pGeneralType);
        	pVarDecl._setScope(this.getScope());

        	this.analyzeVariableDim(pChildren[pChildren.length - 1], pVarDecl);

        	var i:  number  = 0;
        	for(i = pChildren.length - 2; i >= 0; i--){
        		if(pChildren[i].name === "Annotation"){
        			pAnnotation = this.analyzeAnnotation(pChildren[i]);
        			pVarDecl.setAnnotation(pAnnotation);
        		}
        		else if(pChildren[i].name === "Semantic"){
        			sSemantic = this.analyzeSemantic(pChildren[i]);
        			pVarDecl.setSemantic(sSemantic);
        			pVarDecl.getNameId().setRealName(sSemantic);
        		}
        		else if(pChildren[i].name === "Initializer"){
        			pInitExpr = this.analyzeInitializer(pChildren[i]);
        			if(!pInitExpr.optimizeForVariableType(pVariableType)){
        				this._error( 2269 , { varName: pVarDecl.getName() });
        				return null;
        			}
        			pVarDecl.push(pInitExpr, true);
        		}
        	}

        	if(!pVarDecl.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pVarDecl.getLastError()); } ;

        	this.addVariableDecl(pVarDecl);
        	pVarDecl._getNameIndex();

        	return pVarDecl;
        }

        private analyzeVariableDim(pNode: IParseNode, pVariableDecl: IAFXVariableDeclInstruction): void {
			this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;
			var pVariableType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pVariableDecl.getType();

			if(pChildren.length === 1) {
				var pName: IAFXIdInstruction = new IdInstruction();
				pName.setName(pChildren[0].value);
				pVariableDecl.push(pName, true);
				return;
			}

			this.analyzeVariableDim(pChildren[pChildren.length - 1], pVariableDecl);

			if(pChildren.length === 3) {
				pVariableType.addPointIndex(true);
			}
			else if(pChildren.length === 4 && pChildren[0].name === "FromExpr"){

				var pBuffer: IAFXVariableDeclInstruction = this.analyzeFromExpr(pChildren[0]);
				pVariableType.addPointIndex(true);
				pVariableType.setVideoBuffer(pBuffer);
			}
			else {
				if(pVariableType.isPointer()){
//TODO: add support for v[][10]
					this._error( 2300 );
				}

				var pIndexExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 3]);
				pVariableType.addArrayIndex(pIndexExpr);
			}
        }

        private analyzeAnnotation(pNode:IParseNode): IAFXAnnotationInstruction {
        	this.setAnalyzedNode(pNode);

        	return null;
        }

        private analyzeSemantic(pNode:IParseNode): string {
        	this.setAnalyzedNode(pNode);

        	var sSemantic: string = pNode.children[0].value;
// var pDecl: IAFXDeclInstruction = <IAFXDeclInstruction>this._pCurrentInstruction;
// pDecl.setSemantic(sSemantic);	
			return sSemantic;
        }

        private analyzeInitializer(pNode:IParseNode): IAFXInitExprInstruction {
        	this.setAnalyzedNode(pNode);

      		var pChildren: IParseNode[] = pNode.children;
      		var pInitExpr: IAFXInitExprInstruction = new InitExprInstruction();

      		if(pChildren.length === 2){
      			pInitExpr.push(this.analyzeExpr(pChildren[0]), true);
      		}
      		else {
	      		for(var i:  number  = pChildren.length - 3; i >=1; i--){
	      			if(pChildren[i].name === "InitExpr"){
	      				pInitExpr.push(this.analyzeInitExpr(pChildren[i]), true);
	      			}
	      		}
	      	}

      		return pInitExpr;
        }

        private analyzeFromExpr(pNode: IParseNode): IAFXVariableDeclInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pBuffer: IAFXVariableDeclInstruction = null;

        	if(pChildren[1].name === "T_NON_TYPE_ID"){
        		pBuffer = this.getVariable(pChildren[1].value);
        	}
        	else {
        		pBuffer = (<MemExprInstruction>this.analyzeMemExpr(pChildren[1])).getBuffer();
        	}

        	return pBuffer;
        }

        private analyzeInitExpr(pNode:IParseNode): IAFXInitExprInstruction {
        	this.setAnalyzedNode(pNode);

      		var pChildren: IParseNode[] = pNode.children;
      		var pInitExpr: IAFXInitExprInstruction = new InitExprInstruction();

      		if(pChildren.length === 1){
      			pInitExpr.push(this.analyzeExpr(pChildren[0]), true);
      		}
      		else{
      			for(var i:  number  = 0; i < pChildren.length; i++){
      				if(pChildren[i].name === "InitExpr"){
      					pInitExpr.push(this.analyzeInitExpr(pChildren[i]), true);
      				}
      			}
      		}

      		return pInitExpr;
      	}

        private analyzeExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);
        	var sName: string = pNode.name;

        	switch(sName){
        		case "ObjectExpr":
        			return this.analyzeObjectExpr(pNode);
        		case "ComplexExpr":
        			return this.analyzeComplexExpr(pNode);
        		case "PrimaryExpr":
        			return this.analyzePrimaryExpr(pNode);
        		case "PostfixExpr":
        			return this.analyzePostfixExpr(pNode);
        		case "UnaryExpr":
        			return this.analyzeUnaryExpr(pNode);
        		case "CastExpr":
        			return this.analyzeCastExpr(pNode);
        		case "ConditionalExpr":
        			return this.analyzeConditionalExpr(pNode);
        		case "MulExpr":
		        case "AddExpr":
		        	return this.analyzeArithmeticExpr(pNode);
		        case "RelationalExpr":
		        case "EqualityExpr":
		        	return this.analyzeRelationExpr(pNode);
		        case "AndExpr":
		        case "OrExpr":
		        	return this.analyzeLogicalExpr(pNode);
		        case "AssignmentExpr":
		        	return this.analyzeAssignmentExpr(pNode);
		        case "T_NON_TYPE_ID":
		        	return this.analyzeIdExpr(pNode);
		        case "T_STRING":
		        case "T_UINT":
		        case "T_FLOAT":
		        case "T_KW_TRUE":
		        case "T_KW_FALSE":
		        	return this.analyzeSimpleExpr(pNode);
		       	case "MemExpr":
		       		return this.analyzeMemExpr(pNode);
		       	default:
		       		this._error( 2204 , { exprName: sName });
		       		break;
        	}

       		return null;
        }

        private analyzeObjectExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var sName: string = pNode.children[pNode.children.length - 1].name;

        	switch(sName){
        		case "T_KW_COMPILE":
        			return this.analyzeCompileExpr(pNode);
        		case "T_KW_SAMPLER_STATE":
        			return this.analyzeSamplerStateBlock(pNode);
        	}
        }

        private analyzeCompileExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: CompileExprInstruction = new CompileExprInstruction();
        	var pExprType: IAFXVariableTypeInstruction;
        	var pArguments: IAFXExprInstruction[] = null;
        	var sShaderFuncName: string = pChildren[pChildren.length - 2].value;
        	var pShaderFunc: IAFXFunctionDeclInstruction = null;
        	var i:  number  = 0;

        	pArguments = [];

        	if(pChildren.length > 4){
        		var pArgumentExpr: IAFXExprInstruction;

        		for(i = pChildren.length - 3; i > 0; i--) {
        			if(pChildren[i].value !== ","){
        				pArgumentExpr = this.analyzeExpr(pChildren[i]);
        				pArguments.push(pArgumentExpr);
        			}
        		}
        	}

        	pShaderFunc = this.findShaderFunction(sShaderFuncName, pArguments);

        	if(isNull(pShaderFunc)){
        		this._error( 2226 , { funcName: sShaderFuncName });
        		return null;
        	}

        	pExprType = (<IAFXVariableTypeInstruction>pShaderFunc.getType()).wrap();

        	pExpr.setType(pExprType);
        	pExpr.setOperator("complile");
        	pExpr.push(pShaderFunc.getNameId(), false);

        	if(!isNull(pArguments)){
        		for(i = 0; i < pArguments.length; i++) {
        			pExpr.push(pArguments[i], true);
        		}
        	}

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeSamplerStateBlock(pNode: IParseNode): IAFXExprInstruction {
        	pNode = pNode.children[0];
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: SamplerStateBlockInstruction = new SamplerStateBlockInstruction();
        	var i:  number  = 0;

        	pExpr.setOperator("sample_state");

        	for(i = pChildren.length - 2; i >= 1; i--){
        		this.analyzeSamplerState(pChildren[i], pExpr);
        	}

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeSamplerState(pNode: IParseNode, pSamplerStates: SamplerStateBlockInstruction): void {
        	this.setAnalyzedNode(pNode);

      		var pChildren: IParseNode[] = pNode.children;
      		if(pChildren[pChildren.length - 2].name === "StateIndex"){
      			this._error( 2270 );
      			return;
      		}

      		var pStateExprNode: IParseNode = pChildren[pChildren.length - 3];
      		var pSubStateExprNode: IParseNode = pStateExprNode.children[pStateExprNode.children.length - 1];
      		var sStateType: string = pChildren[pChildren.length - 1].value.toUpperCase();
      		var sStateValue: string = "";
      		var isTexture: bool = false;

      		if(isNull(pSubStateExprNode.value)){
        		this._error( 2271 );
  				return;
        	}
        	var pTexture: IAFXVariableDeclInstruction = null;

      		switch (sStateType) {
		        case "TEXTURE":
		            var pTexture: IAFXVariableDeclInstruction = null;
	      			if(pStateExprNode.children.length !== 3 || pSubStateExprNode.value === "{"){
	      				this._error( 2271 );
	      				return;
	      			}
	      			var sTextureName: string = pStateExprNode.children[1].value;
	      			if(isNull(sTextureName) || !this.hasVariable(sTextureName)){
	      				this._error( 2271 );
	      				return;
	      			}

	      			pTexture = this.getVariable(sTextureName);
	      			sStateValue = sTextureName;
		            break;

/* WRAP_S */
		        case "ADDRESSU":
/* WRAP_T */
		        case "ADDRESSV":
		        	sStateValue = pSubStateExprNode.value.toUpperCase();
		        	switch (sStateValue) {
		                case "WRAP":
		                case "CLAMP":
		                case "MIRROR":
		                	break;
		                default:
		                    { logger.setSourceLocation( "fx/Effect.ts" , 2088 ); logger.warning("Webgl don`t support this wrapmode: " + sStateValue); } ;
		                    return;
		            }
		            break;

		        case "MAGFILTER":
		        case "MINFILTER":
		        	sStateValue = pSubStateExprNode.value.toUpperCase();
		        	switch (sStateValue) {
		        		case "POINT":
		        			sStateValue = "NEAREST";
		        			break;
		        		case "POINT_MIPMAP_POINT":
		        			sStateValue = "NEAREST_MIPMAP_NEAREST";
		        			break;
		                case "LINEAR_MIPMAP_POINT":
		                	sStateValue = "LINEAR_MIPMAP_NEAREST";
		                	break;
		                case "POINT_MIPMAP_LINEAR":
		                	sStateValue = "NEAREST_MIPMAP_LINEAR";
		                	break;

		                case "NEAREST":
		                case "LINEAR":
		                case "NEAREST_MIPMAP_NEAREST":
		                case "LINEAR_MIPMAP_NEAREST":
		                case "NEAREST_MIPMAP_LINEAR":
		                case "LINEAR_MIPMAP_LINEAR":
		                    break;
		                default:
		                    { logger.setSourceLocation( "fx/Effect.ts" , 2118 ); logger.warning("Webgl don`t support this texture filter: " + sStateValue); } ;
		                    return;
		            }
            		break;

		        default:
		            { logger.setSourceLocation( "fx/Effect.ts" , 2124 ); logger.warning("Don`t support this texture param: " + sStateType); } ;
		            return;
		    }

		    if(sStateType !== "TEXTURE") {
		    	pSamplerStates.addState(sStateType, sStateValue);
		    }
		    else {
		    	pSamplerStates.setTexture(pTexture);
		    }
        }

        private analyzeComplexExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

        	switch(sFirstNodeName){
        		case "T_NON_TYPE_ID":
        			return this.analyzeFunctionCallExpr(pNode);
        		case "BaseType":
        		case "T_TYPE_ID":
        			return this.analyzeConstructorCallExpr(pNode);
        		default:
        			return this.analyzeSimpleComplexExpr(pNode);
        	}
        }

        private analyzeFunctionCallExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: IAFXExprInstruction = null;
        	var pExprType: IAFXVariableTypeInstruction = null;
        	var pArguments: IAFXExprInstruction[] = null;
        	var sFuncName: string = pChildren[pChildren.length - 1].value;
        	var pFunction: IAFXFunctionDeclInstruction = null;
        	var pFunctionId: IAFXIdExprInstruction = null;
        	var i:  number  = 0;
        	var pCurrentAnalyzedFunction: IAFXFunctionDeclInstruction = this.getCurrentAnalyzedFunction();

        	if(pChildren.length > 3){
        		var pArgumentExpr: IAFXExprInstruction;

        		pArguments = [];

        		for(i = pChildren.length - 3; i > 0; i--) {
        			if(pChildren[i].value !== ","){
        				pArgumentExpr = this.analyzeExpr(pChildren[i]);
        				pArguments.push(pArgumentExpr);
        			}
        		}
        	}

        	pFunction = this.findFunction(sFuncName, pArguments);

        	if(isNull(pFunction)){
        		this._error( 2223 , { funcName: sFuncName });
        		return null;
        	}

        	if(!isDef(pFunction)){
        		this._error( 2246 , {funcName: sFuncName });
        		return null;
        	}

        	if(!isNull(pCurrentAnalyzedFunction)){
        		if(!pFunction._isForPixel()) {
        			pCurrentAnalyzedFunction._setForPixel(false);
        		}

        		if(!pFunction._isForVertex()) {
        			pCurrentAnalyzedFunction._setForVertex(false);
        		}
        	}

        	if(pFunction._getInstructionType() === EAFXInstructionTypes.k_FunctionDeclInstruction){
        		var pFunctionCallExpr: FunctionCallInstruction = new FunctionCallInstruction();

	        	pFunctionId = new IdExprInstruction();
	        	pFunctionId.push(pFunction.getNameId(), false);

	        	pExprType = (<IAFXVariableTypeInstruction>pFunction.getType()).wrap();

	        	pFunctionCallExpr.setType(pExprType);
	        	pFunctionCallExpr.push(pFunctionId, true);

	        	if(!isNull(pArguments)){
	        		for(i = 0; i < pArguments.length; i++) {
	        			pFunctionCallExpr.push(pArguments[i], true);
	        		}

	        		var pFunctionArguments: IAFXVariableDeclInstruction[] = (<FunctionDeclInstruction>pFunction).getArguments();
		        	for(i = 0; i < pArguments.length; i++){
	        			if(pFunctionArguments[i].getType().hasUsage("out")){
	        				if(!pArguments[i].getType().isWritable()){
	        					this._error( 2267 );
	        					return null;
	        				}

	        				if(pArguments[i].getType().isStrongEqual(Effect.getSystemType("ptr"))){
	        					this.addPointerForExtract(pArguments[i].getType()._getParentVarDecl());
	        				}
	        			}
	        			else if(pFunctionArguments[i].getType().hasUsage("inout")){
	        				if(!pArguments[i].getType().isWritable()){
	        					this._error( 2267 );
	        					return null;
	        				}

							if(!pArguments[i].getType().isReadable()){
	        					this._error( 2268 );
	        					return null;
	        				}

	        				if(pArguments[i].getType().isStrongEqual(Effect.getSystemType("ptr"))){
	        					this.addPointerForExtract(pArguments[i].getType()._getParentVarDecl());
	        				}
	        			}
	        			else {
	        				if(!pArguments[i].getType().isReadable()){
	        					this._error( 2268 );
	        					return null;
	        				}
	        			}
	        		}

	        		for(i = pArguments.length; i < pFunctionArguments.length; i++){
	        			pFunctionCallExpr.push(pFunctionArguments[i].getInitializeExpr(), false);
	        		}

	        	}

	        	if(!isNull(pCurrentAnalyzedFunction)){
	        		pCurrentAnalyzedFunction._addUsedFunction(pFunction);
	        	}

	        	pFunction._markUsedAs(EFunctionType.k_Function);

	        	pExpr = pFunctionCallExpr;
        	}
        	else {
        		var pSystemCallExpr: SystemCallInstruction = new SystemCallInstruction();

        		pSystemCallExpr.setSystemCallFunction(pFunction);
        		pSystemCallExpr.fillByArguments(pArguments);

        		if(!isNull(pCurrentAnalyzedFunction)){
        			for(i = 0; i < pArguments.length; i++){
        				if(!pArguments[i].getType().isReadable()) {
        					this._error( 2268 );
        					return null;
        				}
        			}
        		}

        		pExpr = pSystemCallExpr;

        		if(!pFunction.isBuiltIn() && !isNull(pCurrentAnalyzedFunction)){
        			pCurrentAnalyzedFunction._addUsedFunction(pFunction);
        		}
        	}

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeConstructorCallExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: ConstructorCallInstruction = new ConstructorCallInstruction();
        	var pExprType: IAFXVariableTypeInstruction = null;
        	var pArguments: IAFXExprInstruction[] = null;
        	var pConstructorType: IAFXTypeInstruction = null;
        	var i:  number  = 0;

        	pConstructorType = this.analyzeType(pChildren[pChildren.length - 1]);

        	if(isNull(pConstructorType)){
        		this._error( 2224 );
        		return null;
        	}

        	if(pChildren.length > 3){
        		var pArgumentExpr: IAFXExprInstruction = null;

        		pArguments = [];

        		for(i = pChildren.length - 3; i > 0; i--) {
        			if(pChildren[i].value !== ","){
        				pArgumentExpr = this.analyzeExpr(pChildren[i]);
        				pArguments.push(pArgumentExpr);
        			}
        		}
        	}

        	pExprType = this.findConstructor(pConstructorType, pArguments);

        	if(isNull(pExprType)){
        		this._error( 2225 , { typeName: pConstructorType.toString() });
        		return null;
        	}

        	pExpr.setType(pExprType);
        	pExpr.push(pConstructorType, false);

        	if(!isNull(pArguments)){
        		for(i = 0; i < pArguments.length; i++) {
        			if(!pArguments[i].getType().isReadable()){
        				this._error( 2268 );
        				return null;
        			}

        			pExpr.push(pArguments[i], true);
        		}
        	}

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeSimpleComplexExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: ComplexExprInstruction = new ComplexExprInstruction();
        	var pComplexExpr: IAFXExprInstruction;
        	var pExprType: IAFXVariableTypeInstruction;

        	pComplexExpr = this.analyzeExpr(pChildren[1]);
        	pExprType = <IAFXVariableTypeInstruction>pComplexExpr.getType();

        	pExpr.setType(pExprType);
        	pExpr.push(pComplexExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzePrimaryExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: PrimaryExprInstruction = new PrimaryExprInstruction();
        	var pPrimaryExpr: IAFXExprInstruction;
        	var pPointer: IAFXVariableDeclInstruction = null;
        	var pPrimaryExprType: IAFXVariableTypeInstruction;

        	pPrimaryExpr = this.analyzeExpr(pChildren[0]);
        	pPrimaryExprType = <IAFXVariableTypeInstruction>pPrimaryExpr.getType();

        	pPointer = pPrimaryExprType.getPointer();

        	if(isNull(pPointer)){
        		this._error( 2222 , { typeName: pPrimaryExprType.getHash() });
        		return null;
        	}

        	var pPointerVarType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pPrimaryExprType.getParent();
        	if(!pPrimaryExprType.isStrictPointer()){
        		this.getCurrentAnalyzedFunction()._setForPixel(false);
        		this.getCurrentAnalyzedFunction()._notCanUsedAsFunction();
        		pPrimaryExprType._setPointerToStrict();
        	}

        	pExpr.setType(pPointer.getType());
        	pExpr.setOperator("@");
        	pExpr.push(pPointer.getNameId(), false);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzePostfixExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sSymbol: string = pChildren[pChildren.length - 2].value;

        	switch(sSymbol){
        		case "[":
        			return this.analyzePostfixIndex(pNode);
        		case ".":
        			return this.analyzePostfixPoint(pNode);
        		case "++":
        		case "--":
        			return this.analyzePostfixArithmetic(pNode);
        	}
        }

        private analyzePostfixIndex(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: PostfixIndexInstruction = new PostfixIndexInstruction();
        	var pPostfixExpr: IAFXExprInstruction = null;
        	var pIndexExpr:IAFXExprInstruction = null;
        	var pExprType: IAFXVariableTypeInstruction = null;
        	var pPostfixExprType: IAFXVariableTypeInstruction = null;
        	var pIndexExprType: IAFXVariableTypeInstruction = null;
        	var pIntType: IAFXTypeInstruction = null;

        	pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pPostfixExprType = <IAFXVariableTypeInstruction>pPostfixExpr.getType();

        	if(!pPostfixExprType.isArray()){
        		this._error( 2217 , { typeName: pPostfixExprType.toString() });
        		return null;
        	}

        	pIndexExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	pIndexExprType = <IAFXVariableTypeInstruction>pIndexExpr.getType();

        	pIntType = Effect.getSystemType("int");

        	if(!pIndexExprType.isEqual(pIntType)){
        		this._error( 2218 , { typeName: pIndexExprType.toString() });
        		return null;
        	}

        	pExprType = <IAFXVariableTypeInstruction>(pPostfixExprType.getArrayElementType());

        	pExpr.setType(pExprType);
        	pExpr.push(pPostfixExpr, true);
        	pExpr.push(pIndexExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzePostfixPoint(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: PostfixPointInstruction = new PostfixPointInstruction();
        	var pPostfixExpr: IAFXExprInstruction = null;
        	var sFieldName: string = "";
        	var pFieldNameExpr: IAFXIdExprInstruction = null;
        	var pExprType: IAFXVariableTypeInstruction = null;
        	var pPostfixExprType: IAFXVariableTypeInstruction = null;

        	pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pPostfixExprType = <IAFXVariableTypeInstruction>pPostfixExpr.getType();

        	sFieldName = pChildren[pChildren.length - 3].value;

        	pFieldNameExpr = pPostfixExprType.getFieldExpr(sFieldName);

        	if(isNull(pFieldNameExpr)){
        		this._error( 2219 , { typeName: pPostfixExprType.toString(),
        												   fieldName: sFieldName });
        		return null;
        	}

        	pExprType = <IAFXVariableTypeInstruction>pFieldNameExpr.getType();

        	if(pChildren.length === 4){
        		if(!pExprType.isPointer()){
        			this._error( 2220 , { typeName: pExprType.toString() });
        			return null;
        		}

        		var pBuffer: IAFXVariableDeclInstruction = this.analyzeFromExpr(pChildren[0]);
        		pExprType.setVideoBuffer(pBuffer);
        	}

        	pExpr.setType(pExprType);
        	pExpr.push(pPostfixExpr, true);
        	pExpr.push(pFieldNameExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzePostfixArithmetic(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pChildren[0].value;
        	var pExpr: PostfixArithmeticInstruction = new PostfixArithmeticInstruction();
        	var pPostfixExpr: IAFXExprInstruction;
        	var pExprType: IAFXVariableTypeInstruction;
        	var pPostfixExprType: IAFXVariableTypeInstruction;

        	pPostfixExpr = this.analyzeExpr(pChildren[1]);
        	pPostfixExprType = <IAFXVariableTypeInstruction>pPostfixExpr.getType();

        	pExprType = this.checkOneOperandExprType(sOperator, pPostfixExprType);

        	if(isNull(pExprType)){
        		this._error( 2221 , { operator: sOperator,
        													typeName: pPostfixExprType.toString()});
        		return null;
        	}

        	pExpr.setType(pExprType);
        	pExpr.setOperator(sOperator);
        	pExpr.push(pPostfixExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeUnaryExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pChildren[1].value;
        	var pExpr: UnaryExprInstruction = new UnaryExprInstruction();
        	var pUnaryExpr: IAFXExprInstruction;
        	var pExprType: IAFXVariableTypeInstruction;
        	var pUnaryExprType: IAFXVariableTypeInstruction;

        	pUnaryExpr = this.analyzeExpr(pChildren[0]);
        	pUnaryExprType = <IAFXVariableTypeInstruction>pUnaryExpr.getType();

        	pExprType = this.checkOneOperandExprType(sOperator, pUnaryExprType);

        	if(isNull(pExprType)){
        		this._error( 2216 , { operator: sOperator,
        												  tyepName: pUnaryExprType.toString()});
        		return null;
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pExprType);
        	pExpr.push(pUnaryExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeCastExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: CastExprInstruction = new CastExprInstruction();
        	var pExprType: IAFXVariableTypeInstruction;
        	var pCastedExpr: IAFXExprInstruction;

        	pExprType = this.analyzeConstTypeDim(pChildren[2]);
        	pCastedExpr = this.analyzeExpr(pChildren[0]);

        	if(!(<IAFXVariableTypeInstruction>pCastedExpr.getType()).isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	pExpr.setType(pExprType);
        	pExpr.push(pExprType, true);
        	pExpr.push(pCastedExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeConditionalExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: ConditionalExprInstruction = new ConditionalExprInstruction();
        	var pConditionExpr: IAFXExprInstruction;
        	var pTrueExpr: IAFXExprInstruction;
        	var pFalseExpr: IAFXExprInstruction;
        	var pConditionType: IAFXVariableTypeInstruction;
			var pTrueExprType: IAFXVariableTypeInstruction;
        	var pFalseExprType: IAFXVariableTypeInstruction;
        	var pExprType: IAFXVariableTypeInstruction;
        	var pBoolType: IAFXTypeInstruction;

        	pConditionExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pTrueExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	pFalseExpr = this.analyzeExpr(pChildren[0]);

        	pConditionType = <IAFXVariableTypeInstruction>pConditionExpr.getType();
        	pTrueExprType = <IAFXVariableTypeInstruction>pTrueExpr.getType();
        	pFalseExprType = <IAFXVariableTypeInstruction>pFalseExpr.getType();

        	pBoolType = Effect.getSystemType("bool");

        	if(!pConditionType.isEqual(pBoolType)){
        		this._error( 2211 , { typeName: pConditionType.toString()});
        		return null;
        	}

        	if(!pTrueExprType.isEqual(pFalseExprType)){
        		this._error( 2212 , { leftTypeName: pTrueExprType.toString(),
        														rightTypeName: pFalseExprType.toString()});
        		return null;
        	}

        	if(!pConditionType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	if(!pTrueExprType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	if(!pFalseExprType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	pExpr.setType(pTrueExprType);
        	pExpr.push(pConditionExpr, true);
        	pExpr.push(pTrueExpr, true);
        	pExpr.push(pFalseExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeArithmeticExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pNode.children[1].value;
        	var pExpr: ArithmeticExprInstruction = new ArithmeticExprInstruction();
        	var pLeftExpr: IAFXExprInstruction = null;
        	var pRightExpr: IAFXExprInstruction = null;
			var pLeftType: IAFXVariableTypeInstruction = null;
        	var pRightType: IAFXVariableTypeInstruction = null;
        	var pExprType: IAFXVariableTypeInstruction = null;

        	pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pRightExpr = this.analyzeExpr(pChildren[0]);

        	pLeftType = <IAFXVariableTypeInstruction>pLeftExpr.getType();
        	pRightType = <IAFXVariableTypeInstruction>pRightExpr.getType();

        	pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);

        	if(isNull(pExprType)){
        		this._error( 2206 , { operator: sOperator,
        													   leftTypeName: pLeftType.toString(),
        													   rightTypeName: pRightType.toString()});
        		return null;
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pExprType);
        	pExpr.push(pLeftExpr, true);
        	pExpr.push(pRightExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeRelationExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pNode.children[1].value;
        	var pExpr: RelationalExprInstruction = new RelationalExprInstruction();
        	var pLeftExpr: IAFXExprInstruction;
        	var pRightExpr: IAFXExprInstruction;
			var pLeftType: IAFXVariableTypeInstruction;
        	var pRightType: IAFXVariableTypeInstruction;
        	var pExprType: IAFXVariableTypeInstruction;

        	pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pRightExpr = this.analyzeExpr(pChildren[0]);

        	pLeftType = <IAFXVariableTypeInstruction>pLeftExpr.getType();
        	pRightType = <IAFXVariableTypeInstruction>pRightExpr.getType();

        	pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);

        	if(isNull(pExprType)){
        		this._error( 2209 , { operator: sOperator,
        													   leftTypeName: pLeftType.getHash(),
        													   rightTypeName: pRightType.getHash() });
        		return null;
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pExprType);
        	pExpr.push(pLeftExpr, true);
        	pExpr.push(pRightExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeLogicalExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pNode.children[1].value;
        	var pExpr: LogicalExprInstruction = new LogicalExprInstruction();
        	var pLeftExpr: IAFXExprInstruction;
        	var pRightExpr: IAFXExprInstruction;
			var pLeftType: IAFXVariableTypeInstruction;
        	var pRightType: IAFXVariableTypeInstruction;
			var pBoolType: IAFXTypeInstruction;

        	pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pRightExpr = this.analyzeExpr(pChildren[0]);

        	pLeftType = <IAFXVariableTypeInstruction>pLeftExpr.getType();
        	pRightType = <IAFXVariableTypeInstruction>pRightExpr.getType();

        	pBoolType = Effect.getSystemType("bool");

        	if(!pLeftType.isEqual(pBoolType)){
        		this._error( 2210 , { operator: sOperator,
    													    typeName: pLeftType.toString()});
        		return null;
        	}
        	if(!pRightType.isEqual(pBoolType)){
        		this._error( 2210 , { operator: sOperator,
    													    typeName: pRightType.toString()});
        		return null;
        	}

        	if(!pLeftType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	if(!pRightType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType((<SystemTypeInstruction>pBoolType).getVariableType());
        	pExpr.push(pLeftExpr, true);
        	pExpr.push(pRightExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeAssignmentExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pChildren[1].value;
        	var pExpr: AssignmentExprInstruction = new AssignmentExprInstruction();
        	var pLeftExpr: IAFXExprInstruction;
        	var pRightExpr: IAFXExprInstruction;
			var pLeftType: IAFXVariableTypeInstruction;
        	var pRightType: IAFXVariableTypeInstruction;
        	var pExprType: IAFXVariableTypeInstruction;

        	pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pRightExpr = this.analyzeExpr(pChildren[0]);

        	pLeftType = <IAFXVariableTypeInstruction>pLeftExpr.getType();
        	pRightType = <IAFXVariableTypeInstruction>pRightExpr.getType();

        	if(sOperator !== "="){
        		pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
        	  	if(isNull(pExprType)){
        			this._error( 2207 , { operator: sOperator,
        													  			  	  leftTypeName: pLeftType.getHash(),
        													  			  	  rightTypeName: pRightType.getHash()});
        		}
        	}
        	else {
        		pExprType = pRightType;
        	}

        	pExprType = this.checkTwoOperandExprTypes("=", pLeftType, pExprType);

        	if(isNull(pExprType)){
        		this._error( 2208 , { leftTypeName: pLeftType.getHash(),
        													   rightTypeName: pRightType.getHash()});
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pExprType);
        	pExpr.push(pLeftExpr, true);
        	pExpr.push(pRightExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeIdExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var sName: string = pNode.value;
        	var pVariable: IAFXVariableDeclInstruction = this.getVariable(sName);

        	if(isNull(pVariable)){
        		this._error( 2205 , {varName: sName});
        		return null;
        	}

        	if(pVariable.getType()._isUnverifiable() && !this.isAnalzeInPass()){
        		this._error( 2276 );
        		return null;
        	}

        	if(!isNull(this.getCurrentAnalyzedFunction())){
        		if(!pVariable._isForPixel()){
        			this.getCurrentAnalyzedFunction()._setForPixel(false);
        		}
        		if(!pVariable._isForVertex()){
        			this.getCurrentAnalyzedFunction()._setForVertex(false);
        		}
        	}

        	var pVarId: IdExprInstruction = new IdExprInstruction();
        	pVarId.push(pVariable.getNameId(), false);

        	if(!pVarId.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pVarId.getLastError()); } ;

        	return pVarId;
        }

        private analyzeSimpleExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pInstruction: IAFXLiteralInstruction = null;
        	var sName: string = pNode.name;
        	var sValue: string = pNode.value;

        	switch(sName) {
        	 	case "T_UINT":
    	 		pInstruction = new IntInstruction();
        	 		pInstruction.setValue((< number ><any>sValue) * 1);
        	 		break;
        	 	case "T_FLOAT":
        	 		pInstruction = new FloatInstruction();
        	 		pInstruction.setValue((< number ><any>sValue) * 1.0);
        	 		break;
        	 	case "T_STRING":
        	 		pInstruction = new StringInstruction();
        	 		pInstruction.setValue(sValue);
        	 		break;
        	 	case "T_KW_TRUE":
        	 		pInstruction = new BoolInstruction();
        	 		pInstruction.setValue(true);
        	 		break;
        	 	case "T_KW_FALSE":
        	 		pInstruction = new BoolInstruction();
        	 		pInstruction.setValue(false);
        	 		break;
			}

        	return pInstruction;
        }

        private analyzeMemExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pMemExpr: MemExprInstruction = new MemExprInstruction();

        	var pPostfixExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[0]);
        	var pPostfixExprType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pPostfixExpr.getType();

        	if(!pPostfixExprType.isFromVariableDecl()){
        		this._error( 2253 );
        		return null;
        	}

        	var pBuffer: IAFXVariableDeclInstruction = pPostfixExprType.getVideoBuffer();

        	if(isNull(pBuffer)){
        		this._error( 2254 );
        	}

        	if(!pPostfixExprType.isStrictPointer() && !isNull(this.getCurrentAnalyzedFunction())){
        		this.getCurrentAnalyzedFunction()._setForPixel(false);
        		this.getCurrentAnalyzedFunction()._notCanUsedAsFunction();
        		pPostfixExprType._setPointerToStrict();
        	}

        	pMemExpr.setBuffer(pBuffer);

        	return pMemExpr;
        }

        private analyzeConstTypeDim(pNode: IParseNode): IAFXVariableTypeInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if(pChildren.length > 1) {
        		this._error( 2213 );
        		return null;
        	}

        	var pType: IAFXVariableTypeInstruction;

        	pType = <IAFXVariableTypeInstruction>(this.analyzeType(pChildren[0]));

        	if(!pType.isBase()){
        		this._error( 2214 , { typeName: pType.toString()});
        	}

        	if(!pType.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pType.getLastError()); } ;

        	return pType;
        }

        private analyzeVarStructDecl(pNode: IParseNode, pInstruction?: IAFXInstruction = null): void {
			this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pUsageType: IAFXVariableTypeInstruction = null;
        	var pVariable: IAFXVariableDeclInstruction = null;
        	var i:  number  = 0;

        	pUsageType = this.analyzeUsageStructDecl(pChildren[pChildren.length - 1]);

        	for(i = pChildren.length - 2; i >= 1; i--){
        		if(pChildren[i].name === "Variable") {
        			pVariable = this.analyzeVariable(pChildren[i], pUsageType);

        			if(!isNull(pInstruction)){
        				pInstruction.push(pVariable, true);
        			}
        		}
        	}
        }

        private analyzeUsageStructDecl(pNode: IParseNode): IAFXVariableTypeInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
		    var i:  number  = 0;
		    var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

		    for (i = pChildren.length - 1; i >= 0; i--) {
		        if (pChildren[i].name === "StructDecl") {
		        	var pMainType: IAFXTypeInstruction = this.analyzeStructDecl(pChildren[i]);
		        	pType.pushType(pMainType);

		        	var pTypeDecl: IAFXTypeDeclInstruction = new TypeDeclInstruction();
		        	pTypeDecl.push(pMainType, true);

		        	this.addTypeDecl(pTypeDecl);
		        }
		        else if (pChildren[i].name === "Usage") {
		        	var sUsage: string = this.analyzeUsage(pChildren[i]);
		        	pType.addUsage(sUsage);
		        }
		    }

		    if(!pType.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pType.getLastError()); } ;

		    return pType;
        }

		private analyzeTypeDecl(pNode: IParseNode, pParentInstruction: IAFXInstruction = null): IAFXTypeDeclInstruction {
			this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;

			var pTypeDeclInstruction: IAFXTypeDeclInstruction = new TypeDeclInstruction();

 			if(pChildren.length === 2) {
				var pStructInstruction: ComplexTypeInstruction = <ComplexTypeInstruction>this.analyzeStructDecl(pChildren[1]);
				pTypeDeclInstruction.push(pStructInstruction, true);
			}
			else {
				this._error( 2203 );
			}

			if(!pTypeDeclInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pTypeDeclInstruction.getLastError()); } ;

			this.addTypeDecl(pTypeDeclInstruction);

			pNode.isAnalyzed = true;

			if(!isNull(pParentInstruction)){
				pParentInstruction.push(pTypeDeclInstruction, true);
			}

			return pTypeDeclInstruction;
		}

        private analyzeStructDecl(pNode: IParseNode): IAFXTypeInstruction {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;

        	var pStruct: ComplexTypeInstruction = new ComplexTypeInstruction();
        	var pFieldCollector: IAFXInstruction = new InstructionCollector();

        	var sName: string = pChildren[pChildren.length - 2].value;

        	pStruct.setName(sName);

        	this.newScope(EScopeType.k_Struct);

        	var i:  number  = 0;
        	for (i = pChildren.length - 4; i >= 1; i--) {
		        if (pChildren[i].name === "VariableDecl") {
		            this.analyzeVariableDecl(pChildren[i], pFieldCollector);
		        }
		    }

		    this.endScope();

		    pStruct.addFields(pFieldCollector, true);

		    if(!pStruct.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pStruct.getLastError()); } ;

        	return pStruct;
        }

        private analyzeStruct(pNode: IParseNode): IAFXTypeInstruction {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;

        	var pStruct: ComplexTypeInstruction = new ComplexTypeInstruction();
        	var pFieldCollector: IAFXInstruction = new InstructionCollector();

        	this.newScope(EScopeType.k_Struct);

        	var i:  number  = 0;
        	for (i = pChildren.length - 4; i >= 1; i--) {
		        if (pChildren[i].name === "VariableDecl") {
		            this.analyzeVariableDecl(pChildren[i], pFieldCollector);
		        }
		    }

		    this.endScope();

		    pStruct.addFields(pFieldCollector, true);

		    if(!pStruct.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pStruct.getLastError()); } ;

        	return pStruct;
        }

        private analyzeFunctionDeclOnlyDefinition(pNode: IParseNode): IAFXFunctionDeclInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pFunction: FunctionDeclInstruction = null;
        	var pFunctionDef: FunctionDefInstruction = null;
        	var pStmtBlock: StmtBlockInstruction = null;
        	var pAnnotation: IAFXAnnotationInstruction = null;
        	var sLastNodeValue: string = pChildren[0].value;
        	var bNeedAddFunction: bool = false;

        	pFunctionDef = this.analyzeFunctionDef(pChildren[pChildren.length - 1]);

        	pFunction = <FunctionDeclInstruction>this.findFunctionByDef(pFunctionDef);

        	if(!isDef(pFunction)){
        		this._error( 2246 , {funcName: pFunction.getNameId().toString() });
        		return null;
        	}

        	if(!isNull(pFunction) && pFunction.hasImplementation()){
        		this._error( 2227 , { funcName: pFunction.getNameId().toString() });
        		return null;
        	}

        	if(isNull(pFunction)){
        		pFunction = new FunctionDeclInstruction();
        		bNeedAddFunction = true;
        	}
        	else {
        		if(!pFunction.getReturnType().isEqual(pFunctionDef.getReturnType())){
        			this._error( 2247 , {funcName: pFunction.getNameId().toString() });
        			return null;
        		}

        		bNeedAddFunction = false;
        	}

    		pFunction.setFunctionDef(<IAFXDeclInstruction>pFunctionDef);

    		this.resumeScope();

    		if(pChildren.length === 3) {
        		pAnnotation = this.analyzeAnnotation(pChildren[1]);
        		pFunction.setAnnotation(pAnnotation);
        	}

        	if(sLastNodeValue !== ";") {
        		pFunction._setParseNode(pNode);
        		pFunction._setImplementationScope(this.getScope());
        		this._pFunctionWithImplementationList.push(pFunction);
        	}

        	this.endScope();

        	if(bNeedAddFunction){
        		this.addFunctionDecl(pFunction);
       	 	}

        }

        private resumeFunctionAnalysis(pAnalzedFunction: IAFXFunctionDeclInstruction): void {
        	var pFunction: FunctionDeclInstruction = <FunctionDeclInstruction>pAnalzedFunction;
        	var pNode: IParseNode = pFunction._getParseNode();

        	this.setAnalyzedNode(pNode);
        	this.setScope(pFunction._getImplementationScope());

        	var pChildren: IParseNode[] = pNode.children;
        	var pStmtBlock: StmtBlockInstruction = null;

        	this.setCurrentAnalyzedFunction(pFunction);

// LOG("-----Analyze function '" + pFunction.getName() + "'------");

        	pStmtBlock = <StmtBlockInstruction>this.analyzeStmtBlock(pChildren[0]);
 			pFunction.setImplementation(<IAFXStmtInstruction>pStmtBlock);

 			this.setCurrentAnalyzedFunction(null);

 			this.endScope();

 			if(!pFunction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pFunction.getLastError()); } ;
        }

        private analyzeFunctionDef(pNode: IParseNode): FunctionDefInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pFunctionDef: FunctionDefInstruction = new FunctionDefInstruction();
        	var pReturnType: IAFXVariableTypeInstruction = null;
        	var pFuncName: IAFXIdInstruction = null;
        	var pArguments: IAFXVariableDeclInstruction[] = null;
        	var sFuncName: string = pChildren[pChildren.length - 2].value;

        	pReturnType = this.analyzeUsageType(pChildren[pChildren.length - 1]);

        	if(pReturnType.isPointer() || pReturnType._containSampler() || pReturnType._containPointer()){
        		this._error( 2264 , { funcName: sFuncName });
        		return null;
        	}

        	pFuncName = new IdInstruction();
        	pFuncName.setName(sFuncName);

        	pFunctionDef.setReturnType(pReturnType);
        	pFunctionDef.setFunctionName(pFuncName);

        	if(pChildren.length === 4){
        		var sSemantic: string = this.analyzeSemantic(pChildren[0]);
        		pFunctionDef.setSemantic(sSemantic);
        	}

        	this.newScope();

        	this.analyzeParamList(pChildren[pChildren.length - 3], pFunctionDef);

        	this.endScope();

        	if(!pFunctionDef.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pFunctionDef.getLastError()); } ;

        	return pFunctionDef;
        }

        private analyzeParamList(pNode:IParseNode, pFunctionDef: FunctionDefInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pParameter: IAFXVariableDeclInstruction;

        	var i:  number  = 0;

        	for (i = pChildren.length - 2; i >= 1; i--) {
        		if (pChildren[i].name === "ParameterDecl") {
		            pParameter = this.analyzeParameterDecl(pChildren[i]);
		            pParameter._setScope(this.getScope());
		            pFunctionDef.addParameter(pParameter, this.isStrictMode());
		        }
        	}
        }

        private analyzeParameterDecl(pNode: IParseNode): IAFXVariableDeclInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pType: IAFXVariableTypeInstruction = null;
        	var pParameter: IAFXVariableDeclInstruction = null;

        	pType = this.analyzeParamUsageType(pChildren[1]);
        	pParameter = this.analyzeVariable(pChildren[0], pType);

        	return pParameter;
        }

        private analyzeParamUsageType(pNode: IParseNode): IAFXVariableTypeInstruction {
        	var pChildren: IParseNode[] = pNode.children;
		    var i:  number  = 0;
		    var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

		    for (i = pChildren.length - 1; i >= 0; i--) {
		        if (pChildren[i].name === "Type") {
		        	var pMainType: IAFXTypeInstruction = this.analyzeType(pChildren[i]);
		        	pType.pushType(pMainType);
		        }
		        else if (pChildren[i].name === "ParamUsage") {
		        	var sUsage: string = this.analyzeUsage(pChildren[i]);
		        	pType.addUsage(sUsage);
		        }
		    }

		    if(!pType.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pType.getLastError()); } ;

		    return pType;
        }

        private analyzeStmtBlock(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pStmtBlock: StmtBlockInstruction = new StmtBlockInstruction();
        	var pStmt: IAFXStmtInstruction;
        	var i:  number  = 0;

        	pStmtBlock._setScope(this.getScope());

        	this.newScope();

        	for(i = pChildren.length - 2; i > 0; i--){
        		pStmt = this.analyzeStmt(pChildren[i]);
        		if(!isNull(pStmt)){
        			pStmtBlock.push(pStmt);
        		}

        		this.addExtactionStmts(pStmtBlock);
        	}

        	this.endScope();

        	if(!pStmtBlock.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pStmtBlock.getLastError()); } ;

        	return pStmtBlock;
        }

        private analyzeStmt(pNode:IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

        	switch(sFirstNodeName){
        		case "SimpleStmt":
        			return this.analyzeSimpleStmt(pChildren[0]);
        		case "UseDecl":
        			this.analyzeUseDecl(pChildren[0]);
        			return null;
        		case "T_KW_WHILE":
        			return this.analyzeWhileStmt(pNode);
        		case "T_KW_FOR":
        			return this.analyzeForStmt(pNode);
        		case "T_KW_IF":
        			return this.analyzeIfStmt(pNode);
        	}
        }

        private analyzeSimpleStmt(pNode: IParseNode): IAFXStmtInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

        	switch(sFirstNodeName){
        		case "T_KW_RETURN":
        			return this.analyzeReturnStmt(pNode);

        		case "T_KW_DO":
        			return this.analyzeWhileStmt(pNode);

        		case "StmtBlock":
        			return this.analyzeStmtBlock(pChildren[0]);

        		case "T_KW_DISCARD":
        		case "T_KW_BREAK":
        		case "T_KW_CONTINUE":
        			return this.analyzeBreakStmt(pNode);

        		case "TypeDecl":
        		case "VariableDecl":
        		case "VarStructDecl":
        			return this.analyzeDeclStmt(pChildren[0]);

        		default:
        			if(pChildren.length === 2) {
        				return this.analyzeExprStmt(pNode);
        			}
        			else {
        				return (new SemicolonStmtInstruction());
        			}
        	}
        }

        private analyzeReturnStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pReturnStmtInstruction: ReturnStmtInstruction = new ReturnStmtInstruction();

        	var pFunctionReturnType: IAFXVariableTypeInstruction = this.getCurrentAnalyzedFunction().getReturnType();

        	if(pFunctionReturnType.isEqual(Effect.getSystemType("void")) && pChildren.length === 3){
        		this._error( 2261 );
        		return null;
        	}
        	else if(!pFunctionReturnType.isEqual(Effect.getSystemType("void")) && pChildren.length === 2){
        		this._error( 2262 );
        		return null;
        	}

        	if(pChildren.length === 3) {
        		var pExprInstruction: IAFXExprInstruction = this.analyzeExpr(pChildren[1]);
        		var pOutVar: IAFXVariableDeclInstruction = this.getCurrentAnalyzedFunction()._getOutVariable();

        		if(!isNull(pOutVar) && pOutVar.getType() !== pExprInstruction.getType()){
        			this._error( 2263 );
        			return null;
        		}

        		if(!pFunctionReturnType.isEqual(pExprInstruction.getType())){
        			this._error( 2263 );
        			return null;
        		}
        		pReturnStmtInstruction.push(pExprInstruction, true);
        	}

        	if(!pReturnStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pReturnStmtInstruction.getLastError()); } ;

        	return pReturnStmtInstruction;
        }

        private analyzeBreakStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pBreakStmtInstruction: BreakStmtInstruction = new BreakStmtInstruction();
        	var sOperatorName: string = pChildren[1].value;

        	pBreakStmtInstruction.setOperator(sOperatorName);

        	if(sOperatorName === "discard" && !isNull(this.getCurrentAnalyzedFunction())){
        		this.getCurrentAnalyzedFunction()._setForVertex(false);
        	}

        	if(!pBreakStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pBreakStmtInstruction.getLastError()); } ;

        	return pBreakStmtInstruction;
        }

        private analyzeDeclStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sNodeName: string = pNode.name;
        	var pDeclStmtInstruction: DeclStmtInstruction = new DeclStmtInstruction();

        	switch(sNodeName){
        		case "TypeDecl":
        			this.analyzeTypeDecl(pNode, pDeclStmtInstruction);
        			break;
        		case "VariableDecl":
        			this.analyzeVariableDecl(pNode, pDeclStmtInstruction);
        			break;
    			case "VarStructDecl":
    				this.analyzeVarStructDecl(pNode,  pDeclStmtInstruction);
    				break;
        	}

        	if(!pDeclStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pDeclStmtInstruction.getLastError()); } ;

        	return pDeclStmtInstruction;
        }

       	private analyzeExprStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExprStmtInstruction: ExprStmtInstruction = new ExprStmtInstruction();
        	var pExprInstruction: IAFXExprInstruction = this.analyzeExpr(pChildren[1]);

        	pExprStmtInstruction.push(pExprInstruction, true);

        	if(!pExprStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExprStmtInstruction.getLastError()); } ;

        	return pExprStmtInstruction;
        }

        private analyzeWhileStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var isDoWhile: bool = (pChildren[pChildren.length - 1].value === "do");
        	var isNonIfStmt: bool = (pNode.name === "NonIfStmt") ? true : false;

        	var pWhileStmt: WhileStmtInstruction = new WhileStmtInstruction();
        	var pCondition: IAFXExprInstruction = null;
        	var pConditionType: IAFXVariableTypeInstruction = null;
        	var pBoolType: IAFXTypeInstruction = Effect.getSystemType("bool");
        	var pStmt: IAFXStmtInstruction = null;

        	if(isDoWhile) {
        		pWhileStmt.setOperator("do_while");
        		pCondition = this.analyzeExpr(pChildren[2]);
        		pConditionType = <IAFXVariableTypeInstruction>pCondition.getType();

        		if(!pConditionType.isEqual(pBoolType)){
	        		this._error( 2229 , { typeName: pConditionType.toString() });
	        		return null;
	        	}

	        	pStmt = this.analyzeStmt(pChildren[0]);
        	}
        	else {
        		pWhileStmt.setOperator("while");
        		pCondition = this.analyzeExpr(pChildren[2]);
        		pConditionType = <IAFXVariableTypeInstruction>pCondition.getType();

        		if(!pConditionType.isEqual(pBoolType)){
	        		this._error( 2228 , { typeName: pConditionType.toString() });
	        		return null;
	        	}

	        	if(isNonIfStmt){
	        		pStmt = this.analyzeNonIfStmt(pChildren[0]);
	        	}
	        	else {
	        		pStmt = this.analyzeStmt(pChildren[0]);
	        	}

	        	pWhileStmt.push(pCondition, true);
	        	pWhileStmt.push(pStmt, true);
	        }

	        if(!pWhileStmt.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pWhileStmt.getLastError()); } ;

        	return pWhileStmt;
        }

        private analyzeIfStmt(pNode: IParseNode): IAFXStmtInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var isIfElse: bool = (pChildren.length === 7);

        	var pIfStmtInstruction: IfStmtInstruction = new IfStmtInstruction();
        	var pCondition: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	var pConditionType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pCondition.getType();
        	var pBoolType: IAFXTypeInstruction = Effect.getSystemType("bool");

        	var pIfStmt: IAFXStmtInstruction = null;
        	var pElseStmt: IAFXStmtInstruction = null;

        	if(!pConditionType.isEqual(pBoolType)){
        		this._error( 2230 , { typeName: pConditionType.toString() });
        		return null;
        	}

        	pIfStmtInstruction.push(pCondition, true);

        	if(isIfElse){
        		pIfStmtInstruction.setOperator("if_else");
        		pIfStmt = this.analyzeNonIfStmt(pChildren[2]);
        		pElseStmt = this.analyzeStmt(pChildren[0]);

        		pIfStmtInstruction.push(pIfStmt, true);
        		pIfStmtInstruction.push(pElseStmt, true);
        	}
        	else {
        		pIfStmtInstruction.setOperator("if");
        		pIfStmt = this.analyzeNonIfStmt(pChildren[0]);

        		pIfStmtInstruction.push(pIfStmt, true);
        	}

        	if(!pIfStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pIfStmtInstruction.getLastError()); } ;

        	return pIfStmtInstruction;
        }

        private analyzeNonIfStmt(pNode: IParseNode): IAFXStmtInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

        	switch(sFirstNodeName){
        		case "SimpleStmt":
        			return this.analyzeSimpleStmt(pChildren[0]);
        		case "T_KW_WHILE":
        			return this.analyzeWhileStmt(pNode);
        		case "T_KW_FOR":
        			return this.analyzeForStmt(pNode);
        	}
        }

        private analyzeForStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;
        	var isNonIfStmt: bool = (pNode.name === "NonIfStmt");
        	var pForStmtInstruction: ForStmtInstruction = new ForStmtInstruction();
        	var pStmt: IAFXStmtInstruction = null;

        	this.newScope();

        	this.analyzeForInit(pChildren[pChildren.length - 3], pForStmtInstruction);
        	this.analyzeForCond(pChildren[pChildren.length - 4], pForStmtInstruction);

        	if(pChildren.length === 7) {
        		this.analyzeForStep(pChildren[2], pForStmtInstruction);
        	}
        	else {
        		pForStmtInstruction.push(null);
        	}


        	if(isNonIfStmt) {
        		pStmt = this.analyzeNonIfStmt(pChildren[0]);
        	}
        	else {
        		pStmt = this.analyzeStmt(pChildren[0]);
        	}

        	pForStmtInstruction.push(pStmt, true);

        	this.endScope();

        	if(!pForStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pForStmtInstruction.getLastError()); } ;

        	return pForStmtInstruction;
        }

        private analyzeForInit(pNode: IParseNode, pForStmtInstruction: ForStmtInstruction): void {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;
			var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

			switch(sFirstNodeName){
				case "VariableDecl":
					this.analyzeVariableDecl(pChildren[0], pForStmtInstruction);
					break;
				case "Expr":
					var pExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[0]);
					pForStmtInstruction.push(pExpr, true);
					break;
				default:
// ForInit : ';'
					pForStmtInstruction.push(null);
					break;
			}

        	return;
        }

        private analyzeForCond(pNode: IParseNode, pForStmtInstruction: ForStmtInstruction): void {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;

			if(pChildren.length === 1){
				pForStmtInstruction.push(null);
				return;
			}

			var pConditionExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[1]);

			pForStmtInstruction.push(pConditionExpr, true);
			return;
        }

        private analyzeForStep(pNode: IParseNode, pForStmtInstruction: ForStmtInstruction): void {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;
			var pStepExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[0]);

			pForStmtInstruction.push(pStepExpr, true);

        	return;
        }


        private analyzeUseDecl(pNode: IParseNode): void {
        	this.setAnalyzedNode(pNode);
        	this.setStrictModeOn();
        }

        private analyzeTechniqueForImport(pNode: IParseNode): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pTechnique: IAFXTechniqueInstruction = new TechniqueInstruction();
        	var sTechniqueName: string = this.analyzeComplexName(pChildren[pChildren.length - 2]);
        	var isComplexName: bool = pChildren[pChildren.length - 2].children.length !== 1;

        	pTechnique.setName(sTechniqueName, isComplexName);

        	for (var i:  number  = pChildren.length - 3; i >= 0; i--) {
		        if (pChildren[i].name === "Annotation") {
		            var pAnnotation: IAFXAnnotationInstruction = this.analyzeAnnotation(pChildren[i]);
		            pTechnique.setAnnotation(pAnnotation);
		        }
		        else if (pChildren[i].name === "Semantic") {
		            var sSemantic: string = this.analyzeSemantic(pChildren[i]);
		            pTechnique.setSemantic(sSemantic);
		        }
		        else {
	            	this.analyzeTechniqueBodyForImports(pChildren[i], pTechnique);
	       		}
	    	}

	    	this.addTechnique(pTechnique);
        }

        private analyzeComplexName(pNode: IParseNode): string {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sName: string = "";

        	for(var i:  number  = pChildren.length - 1; i >= 0; i--){
        		sName += pChildren[i].value;
        	}

        	return sName;
        }

        private analyzeTechniqueBodyForImports(pNode: IParseNode, pTechnique: IAFXTechniqueInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for (var i:  number  = pChildren.length - 2; i >= 1; i--) {
        		this.analyzePassDeclForImports(pChildren[i], pTechnique);
        	}
        }

        private analyzePassDeclForImports(pNode: IParseNode, pTechnique: IAFXTechniqueInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if(pChildren[0].name === "ImportDecl"){
        		this.analyzeImportDecl(pChildren[0], pTechnique);
        	}
        	else if(pChildren.length > 1) {
        		var pPass: IAFXPassInstruction = new PassInstruction();
//TODO: add annotation and id
        		this.analyzePassStateBlockForShaders(pChildren[0], pPass);

        		pPass._setParseNode(pNode);

        		pTechnique.addPass(pPass);
        	}
        }

        private analyzePassStateBlockForShaders(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for (var i:  number  = pChildren.length - 2; i >= 1; i--) {
		        this.analyzePassStateForShader(pChildren[i], pPass);
		    }
        }

        private analyzePassStateForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if(pChildren.length === 1){
        		pPass._markAsComplex(true);

        		if(pChildren[0].name === "StateIf"){
        			this.analyzePassStateIfForShader(pChildren[0], pPass);
        		}
        		else if(pChildren[0].name === "StateSwitch"){
        			this.analyzePassStateSwitchForShader(pChildren[0], pPass);
        		}

        		return;
        	}

        	var sType: string = pChildren[pChildren.length - 1].value.toUpperCase();
        	var eShaderType: EFunctionType = EFunctionType.k_Vertex;

        	if(sType === "VERTEXSHADER"){
        		eShaderType = EFunctionType.k_Vertex
        	}
        	else if(sType === "PIXELSHADER"){
        		eShaderType = EFunctionType.k_Pixel;
        	}
        	else {
        		return;
        	}

        	pNode.isAnalyzed = true;

        	var pStateExprNode: IParseNode = pChildren[pChildren.length - 3];
        	var pExprNode: IParseNode = pStateExprNode.children[pStateExprNode.children.length - 1];
        	var pCompileExpr: CompileExprInstruction = <CompileExprInstruction>this.analyzeExpr(pExprNode);
        	var pShaderFunc: IAFXFunctionDeclInstruction = pCompileExpr.getFunction();

        	if(eShaderType === EFunctionType.k_Vertex){
        		if(!pShaderFunc._checkDefenitionForVertexUsage()){
        			this._error( 2259 , {funcDef: pShaderFunc._getStringDef()});
        		}
        	}
        	else{
        		if(!pShaderFunc._checkDefenitionForPixelUsage()){
        			this._error( 2260 , {funcDef: pShaderFunc._getStringDef()});
        		}
        	}

        	pShaderFunc._markUsedAs(eShaderType);

        	pPass._addFoundFunction(pNode, pShaderFunc, eShaderType);
        }

        private analyzePassStateIfForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if (pChildren.length === 5){
        		this.analyzePassStateBlockForShaders(pChildren[0], pPass);
        	}
        	else if(pChildren.length === 7 && pChildren[0].name === "PassStateBlock"){
        		this.analyzePassStateBlockForShaders(pChildren[2], pPass);
        		this.analyzePassStateBlockForShaders(pChildren[0], pPass);
        	}
        	else {
        		this.analyzePassStateBlockForShaders(pChildren[2], pPass);
        		this.analyzePassStateIfForShader(pChildren[0], pPass);
        	}
        }

        private analyzePassStateSwitchForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	this.analyzePassCaseBlockForShader(pChildren[0], pPass);
        }

        private analyzePassCaseBlockForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for(var i:  number  = pChildren.length - 2; i >= 1; i--){
        		if(pChildren[i].name === "CaseState"){
        			this.analyzePassCaseStateForShader(pChildren[i], pPass);
        		}
        		else if(pChildren[i].name === "DefaultState"){
        			this.analyzePassDefaultStateForShader(pChildren[i], pPass);
        		}
        	}
        }

        private analyzePassCaseStateForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for(var i:  number  = pChildren.length - 4; i >= 0; i--){
        		if(pChildren[i].name === "PassState"){
        			this.analyzePassStateForShader(pChildren[i], pPass);
        		}
        	}
        }

        private analyzePassDefaultStateForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for(var i:  number  = pChildren.length - 3; i >= 0; i--){
        		if(pChildren[i].name === "PassState"){
        			this.analyzePassStateForShader(pChildren[i], pPass);
        		}
        	}
        }

        private resumeTechniqueAnalysis(pTechnique: IAFXTechniqueInstruction): void {
        	var pPassList: IAFXPassInstruction[] = pTechnique.getPassList();

        	for(var i:  number  = 0; i < pPassList.length; i++){
        		this.resumePassAnalysis(pPassList[i]);
        	}

			if(!pTechnique.checkForCorrectImports()){
				this._error( 2275 , { techniqueName: pTechnique.getName() });
				return;
			}

			pTechnique.setGlobalParams(this._sProvideNameSpace, this._pImportedGlobalTechniqueList);
        }

        private resumePassAnalysis(pPass: IAFXPassInstruction): void {
         	var pNode: IParseNode = pPass._getParseNode();

        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	this.setAnalyzeInPass(true);
        	this.analyzePassStateBlock(pChildren[0], pPass);
        	this.setAnalyzeInPass(false);

        	pPass.finalizePass();
        }

        private analyzePassStateBlock(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	pPass._addCodeFragment("{");

        	for (var i:  number  = pChildren.length - 2; i >= 1; i--) {
		        this.analyzePassState(pChildren[i], pPass);
		    }

		    pPass._addCodeFragment("}");
        }

        private analyzePassState(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if(pChildren.length === 1){
        		if(pChildren[0].name === "StateIf"){
        			this.analyzePassStateIf(pChildren[0], pPass);
        		}
        		else if(pChildren[0].name === "StateSwitch"){
        			this.analyzePassStateSwitch(pChildren[0], pPass);
        		}

        		return;
        	}

        	if(pNode.isAnalyzed) {
        		var pFunc: IAFXFunctionDeclInstruction = pPass._getFoundedFunction(pNode);
        		var eShaderType: EFunctionType = pPass._getFoundedFunctionType(pNode);
        		var pShader: IAFXFunctionDeclInstruction = null;

	        	if(eShaderType === EFunctionType.k_Vertex){
	        		pShader = pFunc._getVertexShader();
	        	}
	        	else {
	        		pShader = pFunc._getPixelShader();
	        	}

	        	pPass.addShader(pShader);
        	}
        	else {
        		var sType: string = pChildren[pChildren.length - 1].value.toUpperCase();
        		var eType:  ERenderStates  = null;
        		var pStateExprNode: IParseNode = pChildren[pChildren.length - 3];
        		var pExprNode: IParseNode = pStateExprNode.children[pStateExprNode.children.length - 1];

        		switch (sType) {
        			case "BLENDENABLE":
        				eType =  ERenderStates .BLENDENABLE;
        				break;
        			case "CULLFACEENABLE":
        				eType =  ERenderStates .CULLFACEENABLE;
        				break;
        			case "ZENABLE":
        				eType =  ERenderStates .ZENABLE;
        				break;
        			case "ZWRITEENABLE":
        				eType =  ERenderStates .ZWRITEENABLE;
        				break;
        			case "DITHERENABLE":
        				eType =  ERenderStates .DITHERENABLE;
        				break;
        			case "SCISSORTESTENABLE":
        				eType =  ERenderStates .SCISSORTESTENABLE;
        				break;
        			case "STENCILTESTENABLE":
        				eType =  ERenderStates .STENCILTESTENABLE;
        				break;
        			case "POLYGONOFFSETFILLENABLE":
        				eType =  ERenderStates .POLYGONOFFSETFILLENABLE;
        				break;
        			case "CULLFACE":
        				eType =  ERenderStates .CULLFACE;
        				break;
        			case "FRONTFACE":
        				eType =  ERenderStates .FRONTFACE;
        				break;
        			case "SRCBLEND":
        				eType =  ERenderStates .SRCBLEND;
        				break;
        			case "DESTBLEND":
        				eType =  ERenderStates .DESTBLEND;
        				break;
        			case "ZFUNC":
        				eType =  ERenderStates .ZFUNC;
        				break;
        			case "ALPHABLENDENABLE":
        				eType =  ERenderStates .ALPHABLENDENABLE;
        				break;
        			case "ALPHATESTENABLE":
        				eType =  ERenderStates .ALPHATESTENABLE;
        				break;

			        default:
			            { logger.setSourceLocation( "fx/Effect.ts" , 3956 ); logger.warning("Unsupported render state type used: " + sType + ". WebGl..."); } ;
			            return;
			    }

			    if (pExprNode.value === "{" || pExprNode.value === "<" ||
			        isNull(pExprNode.value)) {
			        { logger.setSourceLocation( "fx/Effect.ts" , 3962 ); logger.warning("So pass state are incorrect"); } ;
			        return;
			    }

			    var sValue: string = pExprNode.value.toUpperCase();
			    var eValue:  ERenderStateValues  = null;

			    switch (eType) {
			        case  ERenderStates .ALPHABLENDENABLE:
			        case  ERenderStates .ALPHATESTENABLE:
			            { logger.setSourceLocation( "fx/Effect.ts" , 3972 ); logger.warning("ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL."); } ;
			            return;

			        case  ERenderStates .BLENDENABLE:
			        case  ERenderStates .CULLFACEENABLE:
			        case  ERenderStates .ZENABLE:
			        case  ERenderStates .ZWRITEENABLE:
			        case  ERenderStates .DITHERENABLE:
			        case  ERenderStates .SCISSORTESTENABLE:
			        case  ERenderStates .STENCILTESTENABLE:
			        case  ERenderStates .POLYGONOFFSETFILLENABLE:
			            switch (sValue) {
			                case "TRUE":
			                	eValue =  ERenderStateValues .TRUE;
			                	break;
			                case "FALSE":
			                	eValue =  ERenderStateValues .FALSE;
			                	break;

			                default:
			                    { logger.setSourceLocation( "fx/Effect.ts" , 3993 ); logger.warning("Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: " + sValue + "."); }
                                                ;
								return;
			            }
			            break;

			        case  ERenderStates .CULLFACE:
			        	switch(sValue){
			        		case "FRONT":
			                	eValue =  ERenderStateValues .FRONT;
			                	break;
			                case "BACK":
			                	eValue =  ERenderStateValues .BACK;
			                	break
			        		case "FRONT_AND_BACK":
			                	eValue =  ERenderStateValues .FRONT_AND_BACK;
			                	break;

			               	default:
			                    { logger.setSourceLocation( "fx/Effect.ts" , 4011 ); logger.warning("Unsupported render state CULLFACE value used: " + sValue + "."); } ;
			                    return;
			        	}
			        	break;

			       	case  ERenderStates .FRONTFACE:
			            switch (sValue) {
			                case "CW":
			                	eValue =  ERenderStateValues .CW;
			                	break;
			                case "CCW":
			                	eValue =  ERenderStateValues .CCW;
			                	break;

			                default:
			                    { logger.setSourceLocation( "fx/Effect.ts" , 4026 ); logger.warning("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue + "."); } ;
			                    return;
			            }
			            break;

			        case  ERenderStates .SRCBLEND:
			        case  ERenderStates .DESTBLEND:
			            switch (sValue) {
			                case "ZERO":
			                	eValue =  ERenderStateValues .ZERO;
			                	break;
			                case "ONE":
			                	eValue =  ERenderStateValues .ONE;
			                	break;
			                case "SRCCOLOR":
			                	eValue =  ERenderStateValues .SRCCOLOR;
			                	break;
			                case "INVSRCCOLOR":
			                	eValue =  ERenderStateValues .INVSRCCOLOR;
			                	break;
			                case "SRCALPHA":
			                	eValue =  ERenderStateValues .SRCALPHA;
			                	break;
			                case "INVSRCALPHA":
			                	eValue =  ERenderStateValues .INVSRCALPHA;
			                	break;
			                case "DESTALPHA":
			                	eValue =  ERenderStateValues .DESTALPHA;
			                	break;
			                case "INVDESTALPHA":
			                	eValue =  ERenderStateValues .INVDESTALPHA;
			                	break;
			                case "DESTCOLOR":
			                	eValue =  ERenderStateValues .DESTCOLOR;
			                	break;
			                case "INVDESTCOLOR":
			                	eValue =  ERenderStateValues .INVDESTCOLOR;
			                	break;
			                case "SRCALPHASAT":
			                	eValue =  ERenderStateValues .SRCALPHASAT;
			                	break;

			                default:
			                    { logger.setSourceLocation( "fx/Effect.ts" , 4069 ); logger.warning("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue + "."); } ;
			                    return;
			            }
			            break;



			        case  ERenderStates .ZFUNC:
			            switch (sValue) {
			                case "NEVER":
			                	eValue =  ERenderStateValues .NEVER;
			                	break;
			                case "LESS":
			                	eValue =  ERenderStateValues .LESS;
			                	break;
			                case "EQUAL":
			                	eValue =  ERenderStateValues .EQUAL;
			                	break;
			                case "LESSEQUAL":
			                	eValue =  ERenderStateValues .LESSEQUAL;
			                	break;
			                case "GREATER":
			                	eValue =  ERenderStateValues .GREATER;
			                	break;
			                case "NOTEQUAL":
			                	eValue =  ERenderStateValues .NOTEQUAL;
			                	break;
			                case "GREATEREQUAL":
			                	eValue =  ERenderStateValues .GREATEREQUAL;
			                	break;
			                case "ALWAYS":
			                	eValue =  ERenderStateValues .ALWAYS;
			                	break;

			                default:
			                    { logger.setSourceLocation( "fx/Effect.ts" , 4105 ); logger.warning("Unsupported render state ZFUNC value used: " + sValue + "."); }
                                          ;
			                   return;
			            }
			            break;
			    }

			    pPass.setState(eType, eValue);
        	}

        }

        private analyzePassStateIf(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var pIfExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	pIfExpr.prepareFor(EFunctionType.k_PassFunction);

        	pPass._addCodeFragment("if("+ pIfExpr.toFinalCode() + ")");

        	this.analyzePassStateBlock(pChildren[pChildren.length - 5], pPass);

        	if(pChildren.length > 5){
        		pPass._addCodeFragment("else");

        		if(pChildren[0].name === "PassStateBlock"){
        			this.analyzePassStateBlock(pChildren[0], pPass);
        		}
        		else {
        			pPass._addCodeFragment(" ");
        			this.analyzePassStateIf(pChildren[0], pPass);
        		}
        	}
        }

        private analyzePassStateSwitch(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var sCodeFragment: string = "switch";
        	var pSwitchExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	pSwitchExpr.prepareFor(EFunctionType.k_PassFunction);

        	pPass._addCodeFragment("(" + pSwitchExpr.toFinalCode() + ")");

        	this.analyzePassCaseBlock(pChildren[0], pPass);
        }

        private analyzePassCaseBlock(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	pPass._addCodeFragment("{");

        	for(var i:  number  = pChildren.length - 2; i >= 1; i--){
        		if(pChildren[i].name === "CaseState"){
        			this.analyzePassCaseState(pChildren[i], pPass);
        		}
        		else if(pChildren[i].name === "DefaultState"){
        			this.analyzePassDefault(pChildren[i], pPass);
        		}
        	}

        	pPass._addCodeFragment("}");
        }

        private analyzePassCaseState(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var pCaseStateExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 2]);
        	pCaseStateExpr.prepareFor(EFunctionType.k_PassFunction);

        	pPass._addCodeFragment("case " + pCaseStateExpr.toFinalCode() + ": ");

        	for(var i:  number  = pChildren.length - 4; i >= 0; i--){
        		if(pChildren[i].name === "PassState"){
        			this.analyzePassStateForShader(pChildren[i], pPass);
        		}
        		else{
        			pPass._addCodeFragment(pChildren[i].value);
        		}
        	}
        }

        private analyzePassDefault(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	pPass._addCodeFragment("default: ");

        	for(var i:  number  = pChildren.length - 3; i >= 0; i--){
        		if(pChildren[i].name === "PassState"){
        			this.analyzePassStateForShader(pChildren[i], pPass);
        		}
        		else {
        			pPass._addCodeFragment(pChildren[i].value);
        		}
        	}
        }

        private analyzeImportDecl(pNode: IParseNode, pTechnique?: IAFXTechniqueInstruction = null): void {
      		this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
		    var sComponentName: string = this.analyzeComplexName(pChildren[pChildren.length - 2]);
		    var iShift:  number  = 0;

		    if(pChildren[0].name === "ExtOpt"){
		    	{ logger.setSourceLocation( "fx/Effect.ts" , 4219 ); logger.warning("We don`t suppor ext-commands for import"); } ;
		    }
		    if (pChildren.length !== 2) {
		        iShift = this.analyzeShiftOpt(pChildren[0]);
		    }

		    if(!isNull(pTechnique)){
//We can import techniques from the same file, but on this stage they don`t have component yet.
//So we need special mehanism to add them on more belated stage
		    	var sShortedComponentName: string = sComponentName;
		    	if(this._sProvideNameSpace !== ""){
		    		sShortedComponentName = sComponentName.replace(this._sProvideNameSpace + ".", "");
		    	}

		    	var pTechniqueFromSameEffect: IAFXTechniqueInstruction = this._pTechniqueMap[sComponentName] || this._pTechniqueMap[sShortedComponentName];
		    	if(isDefAndNotNull(pTechniqueFromSameEffect)){
		    		pTechnique.addTechniqueFromSameEffect(pTechniqueFromSameEffect, iShift);
		    		return;
		    	}
		    }

		    var pComponent: IAFXComponent = this._pComposer.getComponentByName(sComponentName);
		    if (!pComponent) {
		        this._error( 2277 , { componentName: sComponentName });
		        return;
		    }

		    this.addComponent(pComponent, iShift, pTechnique);
        }

        private analyzeProvideDecl(pNode: IParseNode): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if (pChildren.length === 2) {
		        this._sProvideNameSpace = this.analyzeComplexName(pChildren[0]);
		    }
		    else {
		        this._error( 2303 );
		        return;
		    }
        }

        private analyzeShiftOpt(pNode: IParseNode):  number  {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var iShift:  number  = < number ><any>(pChildren[0].value);

		    if (pChildren.length === 2) {
		        iShift *= 1;
		    }
		    else {
		        iShift *= -1;
		    }

		    return iShift;
        }

        private addComponent(pComponent: IAFXComponent, iShift:  number , pTechnique: IAFXTechniqueInstruction): void {
        	if(!isNull(pTechnique)){
        		pTechnique.addComponent(pComponent, iShift);
        	}
        	else {
        		if(isNull(this._pImportedGlobalTechniqueList)){
        			this._pImportedGlobalTechniqueList = [];
        		}

        		this._pImportedGlobalTechniqueList.push({
        			technique: pComponent.getTechnique(),
        			component: pComponent,
        			shift: iShift
        		});
        	}

//TODO: add correct add of compnent, not global

        	var pComponentTechnique: IAFXTechniqueInstruction = pComponent.getTechnique();
        	if(this.isAddedTechnique(pComponentTechnique)){
        		return;
        	}

        	var pSharedListV: IAFXVariableDeclInstruction[] = pComponentTechnique.getSharedVariablesForVertex();
        	var pSharedListP: IAFXVariableDeclInstruction[] = pComponentTechnique.getSharedVariablesForPixel();

        	for(var i:  number  = 0; i < pSharedListV.length; i++){
        		this.addExternalSharedVariable(pSharedListV[i], EFunctionType.k_Vertex);
        	}

        	for(var i:  number  = 0; i < pSharedListP.length; i++){
        		this.addExternalSharedVariable(pSharedListP[i], EFunctionType.k_Pixel);
        	}

        	if(isNull(this._pAddedTechniqueList)){
        		this._pAddedTechniqueList = [];
        	}

        	this._pAddedTechniqueList.push(pTechnique);
        }

        private isAddedTechnique(pTechnique: IAFXTechniqueInstruction): bool {
        	if(isNull(this._pAddedTechniqueList)){
        		return false;
        	}

        	for(var i:  number  = 0; i < this._pAddedTechniqueList.length; i++){
        		if(this._pAddedTechniqueList[i] === pTechnique){
        			return true;
        		}
        	}

        	return false;
        }



/**
         * Проверят возможность использования оператора между двумя типами.
         * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
         * 
         * @sOperator {string} Один из операторов: + - * / % += -= *= /= %= = < > <= >= == != =
         * @pLeftType {IAFXVariableTypeInstruction} Тип левой части выражения
         * @pRightType {IAFXVariableTypeInstruction} Тип правой части выражения
         */

        private checkTwoOperandExprTypes(sOperator: string,
        								 pLeftType: IAFXVariableTypeInstruction,
        								 pRightType: IAFXVariableTypeInstruction): IAFXVariableTypeInstruction {
        	if(pLeftType._isUnverifiable()){
        		return pLeftType;
        	}

        	if(pRightType._isUnverifiable()){
        		return pRightType;
        	}

        	var isComplex: bool = pLeftType.isComplex() || pRightType.isComplex();
			var isArray: bool = pLeftType.isNotBaseArray() || pRightType.isNotBaseArray();
			var isSampler: bool = Effect.isSamplerType(pLeftType) || Effect.isSamplerType(pRightType);
        	var pBoolType: IAFXVariableTypeInstruction = Effect.getSystemType("bool").getVariableType();

        	if(isArray || isSampler) {
        		return null;
        	}

        	if(sOperator === "%" || sOperator === "%=") {
        		return null;
        	}

        	if(this.isAssignmentOperator(sOperator)){
        		if(!pLeftType.isWritable()){
        			this._error( 2267 );
        			return null;
        		}

        		if(pLeftType.isStrongEqual(Effect.getSystemType("ptr"))){
					this.addPointerForExtract(pLeftType._getParentVarDecl());
				}

        		if(!pRightType.isReadable()){
        			this._error( 2268 );
        			return null;
        		}

        		if(sOperator !== "=" && !pLeftType.isReadable()){
        			this._error( 2268 )
        		}
        	}
        	else {
        		if(!pLeftType.isReadable()){
        			this._error( 2268 );
        			return null;
        		}

        		if(!pRightType.isReadable()){
        			this._error( 2268 );
        			return null;
        		}
        	}

        	if(isComplex){
        		if(sOperator === "=" && pLeftType.isEqual(pRightType)){
        			return <IAFXVariableTypeInstruction>pLeftType;
        		}
        		else if(this.isEqualOperator(sOperator) && !pLeftType._containArray() && !pLeftType._containSampler()) {
        			return pBoolType;
        		}
        		else {
        			return null;
        		}
        	}

        	var pReturnType: IAFXVariableTypeInstruction = null;
        	var pLeftBaseType: IAFXVariableTypeInstruction = (<SystemTypeInstruction>pLeftType.getBaseType()).getVariableType();
        	var pRightBaseType: IAFXVariableTypeInstruction = (<SystemTypeInstruction>pRightType.getBaseType()).getVariableType();


        	if(pLeftType.isConst() && this.isAssignmentOperator(sOperator)){
        		return null;
        	}

        	if(pLeftType.isEqual(pRightType)){
        		if(this.isArithmeticalOperator(sOperator)){
        			if(!Effect.isMatrixType(pLeftType) || (sOperator !== "/" && sOperator !== "/=")){
        				return pLeftBaseType;
        			}
        			else {
        				return null;
        			}
        		}
        		else if(this.isRelationalOperator(sOperator)){
        			if(Effect.isScalarType(pLeftType)){
        				return pBoolType;
        			}
        			else {
        				return null;
        			}
        		}
        		else if(this.isEqualOperator(sOperator)){
        			return pBoolType;
        		}
        		else if(sOperator === "="){
        			return pLeftBaseType;
        		}
        		else {
        			return null;
        		}

        	}

        	if(this.isArithmeticalOperator(sOperator)){
        		if (Effect.isBoolBasedType(pLeftType) || Effect.isBoolBasedType(pRightType) ||
        		    Effect.isFloatBasedType(pLeftType) !== Effect.isFloatBasedType(pRightType) ||
        		    Effect.isIntBasedType(pLeftType) !== Effect.isIntBasedType(pRightType)) {
        			return null;
        		}

        		if(Effect.isScalarType(pLeftType)){
        			return pRightBaseType;
        		}

        		if(Effect.isScalarType(pRightType)){
        			return pLeftBaseType;
        		}

        		if(sOperator === "*" || sOperator === "*="){
        			if(Effect.isMatrixType(pLeftType) && Effect.isVectorType(pRightType) &&
        			   pLeftType.getLength() === pRightType.getLength()){
        				return pRightBaseType;
        			}
        			else if(Effect.isMatrixType(pRightType) && Effect.isVectorType(pLeftType) &&
        			   pLeftType.getLength() === pRightType.getLength()){
        				return pLeftBaseType;
        			}
        			else {
        				return null;
        			}
        		}
        	}

        	return null;
        }

/**
         * Проверят возможность использования оператора к типу данных.
         * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
         * 
         * @sOperator {string} Один из операторов: + - ! ++ --
         * @pLeftType {IAFXVariableTypeInstruction} Тип операнда
         */

        private checkOneOperandExprType(sOperator: string,
        								pType: IAFXVariableTypeInstruction): IAFXVariableTypeInstruction {

 			if(pType._isUnverifiable === undefined){
 				{ logger.setSourceLocation( "fx/Effect.ts" , 4494 ); logger.log(pType); } ;
 			}
        	if(pType._isUnverifiable()){
        		return pType;
        	}

        	var isComplex: bool = pType.isComplex();
			var isArray: bool = pType.isNotBaseArray();
			var isSampler: bool = Effect.isSamplerType(pType);

			if(isComplex || isArray || isSampler){
				return null;
			}

			if(!pType.isReadable()){
       			this._error( 2268 );
       			return null;
       		}


			if(sOperator === "++" || sOperator === "--"){
				if(!pType.isWritable()){
					this._error( 2267 );
					return null;
				}

				if(pType.isStrongEqual(Effect.getSystemType("ptr"))){
					this.addPointerForExtract(pType._getParentVarDecl());
				}

				return pType;
			}

        	if(sOperator === "!"){
        		var pBoolType: IAFXVariableTypeInstruction = Effect.getSystemType("bool").getVariableType();

        		if(pType.isEqual(pBoolType)){
        			return pBoolType;
        		}
        		else{
        			return null;
        		}
        	}
        	else {
        		if(Effect.isBoolBasedType(pType)){
        			return null;
        		}
        		else{
        			return (<SystemTypeInstruction>pType.getBaseType()).getVariableType();
        		}
        	}

//return null;
        }

        private isAssignmentOperator(sOperator: string): bool {
        	return sOperator === "+=" || sOperator === "-=" ||
        		   sOperator === "*=" || sOperator === "/=" ||
        		   sOperator === "%=" || sOperator === "=";
        }

        private isArithmeticalOperator(sOperator: string): bool{
        	return sOperator === "+" || sOperator === "+=" ||
        		   sOperator === "-" || sOperator === "-=" ||
        		   sOperator === "*" || sOperator === "*=" ||
        		   sOperator === "/" || sOperator === "/=";
        }

        private isRelationalOperator(sOperator: string): bool {
        	return sOperator === ">" || sOperator === ">=" ||
        		   sOperator === "<" || sOperator === "<=";
        }

        private isEqualOperator(sOperator: string): bool {
        	return sOperator === "==" || sOperator === "!=";
        }

        private addExtactionStmts(pStmt: IAFXStmtInstruction): void {
        	var pPointerList: IAFXVariableDeclInstruction[] = this.getPointerForExtractList();

        	for(var i:  number  = 0; i < pPointerList.length; i++) {
        		this.generateExtractStmtFromPointer(pPointerList[i], pStmt);
        	}

        	this.clearPointersForExtract();
        }

        private generateExtractStmtFromPointer(pPointer: IAFXVariableDeclInstruction, pParentStmt: IAFXStmtInstruction): IAFXStmtInstruction {
        	var pPointerType: IAFXVariableTypeInstruction = pPointer.getType();
        	var pWhatExtracted: IAFXVariableDeclInstruction = pPointerType._getDownPointer();
        	var pWhatExtractedType: IAFXVariableTypeInstruction = null;

        	var pFunction: IAFXFunctionDeclInstruction = this.getCurrentAnalyzedFunction();

        	while(!isNull(pWhatExtracted)){
        		pWhatExtractedType = pWhatExtracted.getType();

        		if(!pWhatExtractedType.isComplex()){
        			var pSingleExtract: ExtractStmtInstruction = new ExtractStmtInstruction();
        			pSingleExtract.generateStmtForBaseType(
        									pWhatExtracted,
        									pWhatExtractedType.getPointer(),
        									pWhatExtractedType.getVideoBuffer(), 0, null);

        			if(!pSingleExtract.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pSingleExtract.getLastError()); } ;

        			pParentStmt.push(pSingleExtract, true);

        			if(!isNull(pFunction)){
        				pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
        			}
        		}
        		else {
        			this.generateExtractStmtForComplexVar(
        									pWhatExtracted, pParentStmt,
        									pWhatExtractedType.getPointer(),
        									pWhatExtractedType.getVideoBuffer(), 0);
        		}

        		pWhatExtracted = pWhatExtractedType._getDownPointer();
        	}

        	return pParentStmt;
        }

        private generateExtractStmtForComplexVar(pVarDecl: IAFXVariableDeclInstruction,
        										 pParentStmt: IAFXStmtInstruction,
        										 pPointer: IAFXVariableDeclInstruction,
        										 pBuffer: IAFXVariableDeclInstruction,
        										 iPadding:  number ): void {
        	var pVarType: IAFXVariableTypeInstruction = pVarDecl.getType();
        	var pFieldNameList: string[] = pVarType.getFieldNameList();
        	var pField: IAFXVariableDeclInstruction = null;
        	var pFieldType: IAFXVariableTypeInstruction = null;
        	var pSingleExtract: ExtractStmtInstruction = null;

        	var pFunction: IAFXFunctionDeclInstruction = this.getCurrentAnalyzedFunction();

        	for(var i:  number  = 0; i < pFieldNameList.length; i++){
        		pField = pVarType.getField(pFieldNameList[i]);

        		if(isNull(pField)){
        			continue;
				}

 				pFieldType = pField.getType();

 				if(pFieldType.isPointer()){
 					var pFieldPointer: IAFXVariableDeclInstruction = pFieldType._getMainPointer();
 					pSingleExtract = new ExtractStmtInstruction();
 					pSingleExtract.generateStmtForBaseType(pFieldPointer, pPointer, pFieldType.getVideoBuffer(), iPadding + pFieldType.getPadding(), null);

 					if(!pSingleExtract.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pSingleExtract.getLastError()); } ;

 					pParentStmt.push(pSingleExtract, true);
 					this.generateExtractStmtFromPointer(pFieldPointer, pParentStmt);

 					if(!isNull(pFunction)){
        				pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
        			}
 				}
 				else if(pFieldType.isComplex()) {
 					this.generateExtractStmtForComplexVar(pField, pParentStmt, pPointer, pBuffer, iPadding + pFieldType.getPadding());
 				}
 				else {
 					pSingleExtract = new ExtractStmtInstruction();
        			pSingleExtract.generateStmtForBaseType(pField, pPointer, pBuffer, iPadding + pFieldType.getPadding(), null);

        			if(!pSingleExtract.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pSingleExtract.getLastError()); } ;

        			pParentStmt.push(pSingleExtract, true);

        			if(!isNull(pFunction)){
        				pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
        			}
 				}
 	       	}
        }


		private getNodeSourceLocation(pNode: IParseNode): {line:  number ; column:  number ;} {
			if(isDef(pNode.line)){
				return {line: pNode.line, column: pNode.start};
			}
			else{
				return this.getNodeSourceLocation(pNode.children[pNode.children.length - 1]);
			}
		}
	}
}

































module akra {
	export interface IAFXBlender {

//Component and component blend
		addComponentToBlend(pComponentBlend: IAFXComponentBlend,
						    pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentBlend;

		removeComponentFromBlend(pComponentBlend: IAFXComponentBlend,
								 pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentBlend;

		addBlendToBlend(pComponentBlend: IAFXComponentBlend,
						pAddBlend: IAFXComponentBlend, iShift:  number ): IAFXComponentBlend;

//Pass blend

		generatePassBlend(pPassList: IAFXPassInstruction[],
						  pStates: any, pForeigns: any, pUniforms: any): IAFXPassBlend;

		getPassBlendById(id:  number ): IAFXPassBlend;
	}
}





























module akra.fx {
	export class TexcoordSwapper {
		protected _pTmpToTex: string[] = null;
		protected _pTexToTmp: string[]= null;
		protected _pTexcoords:  number [] = null;

		protected _sTmpToTexCode: string = "";
		protected _sTexToTmpCode: string = "";

		protected _iMaxTexcoords:  number  = 0;

		constructor() {
			this._iMaxTexcoords = core.pool.resources.SurfaceMaterial.MAX_TEXTURES_PER_SURFACE;
			this._pTmpToTex = new Array(this._iMaxTexcoords);
			this._pTexToTmp = new Array(this._iMaxTexcoords);
			this._pTexcoords = new Array(this._iMaxTexcoords);
		}

		/**@inline*/  getTmpDeclCode(): string {
			return this._sTexToTmpCode;
		}

		/**@inline*/  getTecoordSwapCode(): string {
			return this._sTmpToTexCode;
		}

		clear(): void {
			for(var i:  number  = 0; i < this._iMaxTexcoords; i++){
				this._pTmpToTex[i] = "";
				this._pTexToTmp[i] = "";
				this._pTexcoords[i] = 0;
			}

			this._sTmpToTexCode = "";
			this._sTexToTmpCode = "";
		}

		generateSwapCode(pMaterial: core.pool.resources.SurfaceMaterial, pAttrConatiner: AttributeBlendContainer): void {
			this.clear();

			if(isNull(pMaterial)){
				return;
			}
//TODO: do it faster in one for
			var pTexcoords:  number [] = this._pTexcoords;

			for(var i:  number  = 0; i < this._iMaxTexcoords; i++){
				var iTexcoord:  number  = pMaterial.texcoord(i);

				if(iTexcoord !== i && pAttrConatiner.hasTexcoord(i)) {
					var pAttr = pAttrConatiner.getTexcoordVar(i);

					this._pTexToTmp[i] = pAttr.getType().getBaseType().getRealName() + " " +
										 "T" + i.toString() + "=" + pAttr.getRealName() + ";";

					this._sTexToTmpCode += this._pTexToTmp[i] + "\n";
				}

				if(!pAttrConatiner.hasTexcoord(iTexcoord)){
					pTexcoords[iTexcoord] = 0;
				}
				else {
					pTexcoords[iTexcoord] = iTexcoord;
				}
			}

			for(var i:  number  = 0; i < this._iMaxTexcoords; i++){
				if(pTexcoords[i] !== i && pAttrConatiner.hasTexcoord(i)){
					var pAttr = pAttrConatiner.getTexcoordVar(i);

					if(this._pTexToTmp[pTexcoords[i]] !== ""){
						this._pTmpToTex[i] = pAttr.getRealName() + "=" + this._pTexToTmp[pTexcoords[i]] + ";";
					}
					else {
						this._pTmpToTex[i] = pAttr.getRealName() + "=" +
											 pAttrConatiner.getTexcoordVar(pTexcoords[i]).getRealName() + ";";
					}

					this._sTmpToTexCode += this._pTmpToTex[i] + "\n";
				}
			}
		}
	}
}





























// #define PROFILE_MAKE 1

module akra.fx {

	export interface IUniformTypeMap {
		[name: string]: EAFXShaderVariableType;
	}

// export interface IUniformStructInfo {
// 	name: string;
// 	shaderName: string;
// 	type: EAFXShaderVariableType;
// 	length: uint;
// }

	export interface IUniformStructInfo {
		name: string;
		isComplex: bool;
		isArray: bool;
		index:  number ;

		fields: IUniformStructInfo[];
		shaderVarInfo: IShaderUniformInfo;
	}

	export interface IShaderUniformInfo {
		name: string;
		location:  number ;

		webGLLocation: WebGLUniformLocation;

		type: EAFXShaderVariableType;
		length:  number ;
		applyFunction: Function;
		defaultValue: any;
	}

	export interface IShaderAttrOffsetInfo {
		semantic: string;
		shaderVarInfo: IShaderUniformInfo;
		defaultValue:  number ;
	}

	export interface IShaderAttrInfo extends IAFXBaseAttrInfo {
		name: string;
		location:  number ;
		semantic: string;
		isMappable: bool;
		isComplex: bool;
		vertexTextureInfo: IShaderUniformInfo;
		offsets: IShaderAttrOffsetInfo[];
	}

	export interface IShaderUniformInfoMap {
		[name: string]: IShaderUniformInfo;
	}

	export interface IShaderAttrInfoMap {
		[name: string]: IShaderAttrInfo;
	}

	export interface IUniformStructInfoMap {
		[name: string]: IUniformStructInfo;
	}


	export interface IInputUniformInfo {
		name: string;
		nameIndex:  number ;
		isComplex: bool;
		isCollapsedArray: bool;
		shaderVarInfo: IShaderUniformInfo;
		structVarInfo: IUniformStructInfo;
	}


	function createShaderUniformInfo(sName: string, iLocation:  number , pWebGLLocation: WebGLUniformLocation): IShaderUniformInfo {
		return <IShaderUniformInfo>{
			name: sName,
			location: iLocation,
			webGLLocation: pWebGLLocation,
			type: EAFXShaderVariableType.k_NotVar,
			length: 0,

			applyFunction: null,
			defaultValue: null
		};
	}


	function createShaderAttrInfo(sName: string, iLocation:  number ): IShaderAttrInfo {
		return <IShaderAttrInfo>{
			name: sName,
			location: iLocation,
			semantic: "",
			isMappable: false,
			isComplex: false,
			vertexTextureInfo: null,
			offsets: null
		};
	}

	function createShaderAttrOffsetInfo(sSemantic: string,  pShaderUniformInfo: IShaderUniformInfo, fDefault:  number ): IShaderAttrOffsetInfo {
		return <IShaderAttrOffsetInfo>{
			semantic: sSemantic,
			shaderVarInfo: pShaderUniformInfo,
			defaultValue: fDefault
		};
	}

	function createInputUniformInfo(sName: string, iNameIndex:  number , pShaderUniformInfo: IShaderUniformInfo, isComplex: bool): IInputUniformInfo {
		return <IInputUniformInfo>{
			name: sName,
			nameIndex: iNameIndex,
			isComplex: isComplex,
			isCollapsedArray: false,
			shaderVarInfo: pShaderUniformInfo,
			structVarInfo: null
		};
	}

// function createUniformStructFieldInfo(sName: string, sShaderName: string, 
// 							  eType: EAFXShaderVariableType, iLength: uint): IUniformStructInfo {
// 	return <IUniformStructInfo>{
// 		name: sName,
// 		shaderName: sShaderName,
// 		type: eType,
// 		length: iLength
// 	};
// }

	function createUniformStructFieldInfo(sName: string, isComplex: bool, isArray: bool): IUniformStructInfo {
		return <IUniformStructInfo>{
			name: sName,
			isComplex: isComplex,
			isArray: isArray,
			index: -1,

			fields: null,
			shaderVarInfo: null
		};
	}


	export class Maker implements IAFXMaker {
		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } ;

		private _pComposer: IAFXComposer = null;
		private _pPassBlend: IAFXPassBlend = null;


		private _pShaderProgram: webgl.WebGLShaderProgram = null;

		private _pRealUniformNameList: string[] = null;
		private _pRealAttrNameList: string[] = null;

// is really exists uniform & attr?
		private _pUniformExistMap: BoolMap = <BoolMap>{};
		private _pAttrExistMap: BoolMap = <BoolMap>{};

		private _isUsedZero2D: bool = false;
		private _isUsedZeroCube: bool = false;

// private _pAttrContainer: AttributeBlendContainer = null;
//стек объектов храняих все юниформы и аттрибуты
		private _pDataPoolArray: util.ObjectArray = new util.ObjectArray();


		private _pShaderUniformInfoMap: IShaderUniformInfoMap = null;
		private _pShaderAttrInfoMap: IShaderAttrInfoMap = null;

		private _pShaderUniformInfoList: IShaderUniformInfo[] = null;
		private _pShaderAttrInfoList: IShaderAttrInfo[] = null;

		private _pInputUniformInfoList: IInputUniformInfo[] = null;
		private _pInputSamplerInfoList: IInputUniformInfo[] = null;
		private _pInputSamplerArrayInfoList: IInputUniformInfo[] = null;

		private _pUnifromInfoForStructFieldMap: IUniformStructInfoMap = null;

		/**@inline*/  isArray(sName: string) {
			return this.getLength(sName) > 0;
		}

		/**@inline*/  getType(sName: string): EAFXShaderVariableType {
			return this._pShaderUniformInfoMap[sName].type;
		}

		/**@inline*/  getLength(sName: string):  number  {
			return this._pShaderUniformInfoMap[sName].length;
		}

		/**@inline*/  get shaderProgram(): IShaderProgram {
			return this._pShaderProgram;
		}

		/**@inline*/  get attributeInfo(): IAFXBaseAttrInfo[] {
			return <IAFXBaseAttrInfo[]>this._pShaderAttrInfoList;
		}

		/**@inline*/  get uniformNames(): string[] {
			return this._pRealUniformNameList;
		}


		constructor(pComposer: IAFXComposer, pPassBlend: IAFXPassBlend){
			this._pComposer = pComposer;
			this._pPassBlend = pPassBlend;
		}

		_create(sVertex: string, sPixel: string): bool {
			var pRmgr: IResourcePoolManager = this._pComposer.getEngine().getResourceManager();
// LOG(this, sVertex, sPixel);

			var pProgram: webgl.WebGLShaderProgram = <webgl.WebGLShaderProgram>pRmgr.createShaderProgram(".shader-prorgam-" + this.getGuid().toString());

			if(!pProgram.create(sVertex, sPixel)){
				return false;
			}

			this._pRealUniformNameList = pProgram._getActiveUniformNames();
        	this._pRealAttrNameList = pProgram._getActiveAttributeNames();

			this._pShaderUniformInfoList = new Array(this._pRealUniformNameList.length);
			this._pShaderAttrInfoList = new Array(this._pRealAttrNameList.length);

			this._pShaderUniformInfoMap = <IShaderUniformInfoMap>{};
			this._pShaderAttrInfoMap = <IShaderAttrInfoMap>{};

			this._pShaderProgram = pProgram;

			for (var i:  number  = 0; i < this._pRealUniformNameList.length; i++) {
				var sUniformName: string = this._pRealUniformNameList[i];

				var pUniformInfo: IShaderUniformInfo = createShaderUniformInfo(sUniformName, i, pProgram.getWebGLUniformLocation(sUniformName));

				this._pUniformExistMap[sUniformName] = true;
				this._pShaderUniformInfoList[i] = pUniformInfo;
				this._pShaderUniformInfoMap[sUniformName] = pUniformInfo;
			}



			for (var i:  number  = 0; i < this._pRealAttrNameList.length; i++) {
				var sAttrName: string = this._pRealAttrNameList[i];
				var pAttrInfo: IShaderAttrInfo = createShaderAttrInfo(sAttrName, i);

				this._pAttrExistMap[sAttrName] = true;
				this._pShaderAttrInfoList[i] = pAttrInfo;
				this._pShaderAttrInfoMap[sAttrName] = pAttrInfo;
			}

			this._pUnifromInfoForStructFieldMap = <IUniformStructInfoMap>{};

			this["sVertex"] = sVertex;
			this["sPixel"] = sPixel;

// LOG(sVertex, sPixel);

			return true;
		}

		/**@inline*/  _getShaderInput(): IShaderInput {
			return this._pDataPoolArray.length > 0? this._pDataPoolArray.pop(): this._createDataPool();
		}

		/**@inline*/  _releaseShaderInput(pPool: IShaderInput): void {
			this._pDataPoolArray.push(pPool);
		}

		/**@inline*/  isUniformExists(sName: string): bool {
			return this._pUniformExistMap[sName] ? true : this._pUniformExistMap[sName] = false;
		}

		/**@inline*/  isAttrExists(sName: string): bool {
			return this._pAttrExistMap[sName] ? true : this._pAttrExistMap[sName]  = false;
		}


		_createDataPool(): IShaderInput {
			var pInput: IShaderInput = {
				uniforms: <{[index:  number ]: any;}>{},
				attrs: <{[index:  number ]: any;}>{},
				renderStates: render.createRenderStateMap()
			};

//assume, that attr & uniform never have same names!!!

			for (var i:  number  = 0; i < this._pShaderUniformInfoList.length; i++) {
				var pUniformInfo: IShaderUniformInfo = this._pShaderUniformInfoList[i];

				pInput.uniforms[i] = null;

				if ((pUniformInfo.type === EAFXShaderVariableType.k_Sampler2D ||
					 pUniformInfo.type === EAFXShaderVariableType.k_SamplerCUBE)){

					if(pUniformInfo.length > 0){
						pInput.uniforms[i] = new Array(pUniformInfo.length);

						for(var j:  number  = 0; j < pUniformInfo.length; j++){
							pInput.uniforms[i][j] = createSamplerState();
						}
					}
					else {
						pInput.uniforms[i] = createSamplerState();
					}

				}
			}

			for (var i:  number  = 0; i < this._pShaderAttrInfoList.length; i++) {
				pInput.attrs[i] = null;
			}

			return pInput;
		}

		setUniform(iLocation:  number , pValue: any): void {
			if(this._pShaderUniformInfoList[iLocation].type !== EAFXShaderVariableType.k_NotVar){

				this._pShaderUniformInfoList[iLocation].applyFunction.call(this._pShaderProgram,
																   this._pShaderUniformInfoList[iLocation].webGLLocation,
																   pValue || this._pShaderUniformInfoList[iLocation].defaultValue);

			}
		}

		_initInput(pPassInput: IAFXPassInputBlend, pBlend: SamplerBlender, pAttrs: AttributeBlendContainer): bool {
/* Initialize info about uniform variables(not samplers and video buffers) */

			var pUniformKeys:  number [] = pPassInput.uniformKeys;
			this._pInputUniformInfoList = [];

			for(var i:  number  = 0; i < pUniformKeys.length; i++) {
				var iNameIndex:  number  = pUniformKeys[i];
				var sName: string = pPassInput._getUniformVarNameByIndex(iNameIndex);
				var eType: EAFXShaderVariableType = pPassInput._getUniformType(iNameIndex);
				var iLength:  number  = pPassInput._getUniformLength(iNameIndex);
				var isArray: bool = (iLength > 0);

				var pInputUniformInfo: IInputUniformInfo = null;

				if(eType === EAFXShaderVariableType.k_Complex){
					var pStructInfo: IUniformStructInfo = this.expandStructUniforms(pPassInput._getUniformVar(iNameIndex));
					if(!isNull(pStructInfo)){
						pInputUniformInfo = createInputUniformInfo(sName, iNameIndex, null, true);
						pInputUniformInfo.structVarInfo = pStructInfo;
						this._pInputUniformInfoList.push(pInputUniformInfo);
					}
				}
				else {
					var sShaderName: string = isArray ? (sName + "[0]") : sName;

					if(!this.isUniformExists(sShaderName)){
						continue;
					}

					var pShaderUniformInfo: IShaderUniformInfo = this._pShaderUniformInfoMap[sShaderName];

					pShaderUniformInfo.type = eType;
					pShaderUniformInfo.length = iLength;

					pInputUniformInfo = createInputUniformInfo(sName, iNameIndex, pShaderUniformInfo, false);
					this._pInputUniformInfoList.push(pInputUniformInfo);
				}
			}

/* Initialize info about samplers*/

			var iTotalSamplerSlots:  number  = pBlend.totalActiveSlots;
			this._pInputSamplerInfoList = [];

			for(var i:  number  = 0; i < iTotalSamplerSlots; i++){
				var pShaderUniformInfo: IShaderUniformInfo = null;
				var pInputUniformInfo: IInputUniformInfo = null;

				if(i ===  0 ) {
					this._isUsedZero2D = this.isUniformExists("as0");
					this._isUsedZeroCube = this.isUniformExists("asc0");

					if(this._isUsedZero2D){
						pShaderUniformInfo = this._pShaderUniformInfoMap["as0"];

						pShaderUniformInfo.type = EAFXShaderVariableType.k_Int;
						pShaderUniformInfo.length = 0;
					}

					if(this._isUsedZeroCube){
						pShaderUniformInfo = this._pShaderUniformInfoMap["asc0"];

						pShaderUniformInfo.type = EAFXShaderVariableType.k_Int;
						pShaderUniformInfo.length = 0;
					}

					continue;
				}

				var sRealSamplerName: string = "as" + i.toString();

				if(!this.isUniformExists(sRealSamplerName)){
					continue;
				}

				var pSampler: IAFXVariableDeclInstruction = pBlend.getSamplersBySlot(i).value(0);
				var sSampler: string = pSampler.getSemantic() || pSampler.getName();
				var iNameIndex:  number  = pPassInput._getUniformVarNameIndex(sSampler);
				var eType: EAFXShaderVariableType = pSampler.getType().isSampler2D() ?
									 					EAFXShaderVariableType.k_Sampler2D :
									 					EAFXShaderVariableType.k_SamplerCUBE;

				pShaderUniformInfo = this._pShaderUniformInfoMap[sRealSamplerName];

				pShaderUniformInfo.type = eType;
				pShaderUniformInfo.length = 0;

				pInputUniformInfo = createInputUniformInfo(sSampler, iNameIndex, pShaderUniformInfo, false);
				pInputUniformInfo.isCollapsedArray = (pSampler.getType().getLength() > 0);

				this._pInputSamplerInfoList.push(pInputUniformInfo);
			}


/* Initialize info about array of samplers */

			var pSamplerArrayKeys:  number [] = pPassInput.samplerArrayKeys;
			this._pInputSamplerArrayInfoList = [];

			for(var i:  number  = 0; i < pSamplerArrayKeys.length; i++) {
				var iNameIndex:  number  = pSamplerArrayKeys[i];
				var sName: string = pPassInput._getUniformVarNameByIndex(iNameIndex);
				var eType: EAFXShaderVariableType =  pPassInput._getUniformType(iNameIndex);
				var iLength:  number  = pPassInput._getUniformLength(iNameIndex);
				var sShaderName: string = sName + "[0]";
				var pInputUniformInfo: IInputUniformInfo = null;

				if(!this.isUniformExists(sShaderName)){
					continue;
				}

				var pShaderUniformInfo: IShaderUniformInfo = this._pShaderUniformInfoMap[sShaderName];

				pShaderUniformInfo.type = eType;
				pShaderUniformInfo.length = iLength;

				pInputUniformInfo = createInputUniformInfo(sName, iNameIndex, pShaderUniformInfo, false);

				this._pInputSamplerArrayInfoList.push(pInputUniformInfo);
			}

			var pAttrInfoList: fx.IVariableBlendInfo[] = pAttrs.attrsInfo;

			var nPreparedAttrs:  number  = -1;
			var nPreparedBuffers:  number  = -1;

			for(var i:  number  = 0; i < pAttrInfoList.length; i++){
				var iSemanticIndex:  number  = i;
				var pAttrInfo: fx.IVariableBlendInfo = pAttrInfoList[iSemanticIndex];
				var sSemantic: string = pAttrInfo.name;
				var iSlot:  number  = pAttrs.getSlotBySemanticIndex(iSemanticIndex);

				if(iSlot === -1) {
					continue;
				}

				var iBufferSlot:  number  = pAttrs.getBufferSlotBySemanticIndex(iSemanticIndex);

// is it not initied attr?
				if(iSlot > nPreparedAttrs) {
					var sAttrName: string = "aa" + iSlot.toString();
					var sBufferName: string = "abs" + iBufferSlot.toString();

					if(!this.isAttrExists(sAttrName)){
						continue;
					}

					var pShaderAttrInfo: IShaderAttrInfo = this._pShaderAttrInfoMap[sAttrName];
					var isMappable: bool = iBufferSlot >= 0;
					var pVertexTextureInfo: IShaderUniformInfo = isMappable ? this._pShaderUniformInfoMap[sBufferName] : null;
					var isComplex: bool = pAttrs.getTypeBySemanticIndex(iSemanticIndex).isComplex();

// need to init buffer
					if(iBufferSlot > nPreparedBuffers){
						if(!this.isUniformExists(sBufferName)){
							{ logger.setSourceLocation( "fx/Maker.ts" , 521 ); logger.error("This erroer must not be happen"); } ;
							continue;
						}

						pVertexTextureInfo.type = EAFXShaderVariableType.k_SamplerVertexTexture;
						pVertexTextureInfo.length = 0;
					}

					pShaderAttrInfo.semantic = sSemantic;
					pShaderAttrInfo.isMappable = isMappable;
					pShaderAttrInfo.isComplex = isComplex;
					pShaderAttrInfo.vertexTextureInfo = pVertexTextureInfo;

					nPreparedAttrs++;
				}

//add offset uniforms
				var pOffsetVars: IAFXVariableDeclInstruction[] = pAttrs.getOffsetVarsBySemantic(sSemantic);

				if(!isNull(pOffsetVars)) {
					var pShaderAttrInfo: IShaderAttrInfo = this._pShaderAttrInfoList[iSlot];
					var pOffsetInfoList: IShaderAttrOffsetInfo[] = pShaderAttrInfo.offsets || new Array();

					for(var j:  number  = 0; j < pOffsetVars.length; j++){
						var sOffsetSemantic: string = pOffsetVars[j].getSemantic();
						var sOffsetName: string = pOffsetVars[j].getRealName();

						if(this.isUniformExists(sOffsetName)){
							var pOffsetUniformInfo: IShaderUniformInfo = this._pShaderUniformInfoMap[sOffsetName];
							var fDefaultValue:  number  = pAttrs.getOffsetDefault(sOffsetName);

							pOffsetUniformInfo.type = EAFXShaderVariableType.k_Float;
							pOffsetUniformInfo.length = 0;

							pOffsetInfoList.push(createShaderAttrOffsetInfo(sOffsetSemantic, pOffsetUniformInfo, fDefaultValue));
						}
					}

					pShaderAttrInfo.offsets = pOffsetInfoList;
				}

			}

/* Prepare funtions to set uniform value in real shader progrham */

			for(var i:  number  = 0; i < this._pShaderUniformInfoList.length; i++){
				this.prepareApplyFunctionForUniform(this._pShaderUniformInfoList[i]);
			}

			return true;
		}



		_make(pPassInput: IAFXPassInputBlend, pBufferMap: util.BufferMap): IShaderInput {


			var pUniforms: any = pPassInput.uniforms;
			var pTextures: any = pPassInput.textures
			var pSamplers: IAFXSamplerStateMap = pPassInput.samplers;
			var pPassInputRenderStates: IRenderStateMap = pPassInput.renderStates;
			var pSamplerArrays: IAFXSamplerStateListMap = pPassInput.samplerArrays;

			var pInput: IShaderInput = this._getShaderInput();

			for(var i:  number  = 0; i < this._pInputUniformInfoList.length; i++){
				var pInfo: IInputUniformInfo = this._pInputUniformInfoList[i];

				if(pInfo.isComplex) {
					this.applyStructUniform(pInfo.structVarInfo, pUniforms[pInfo.nameIndex], pInput);
				}
				else {
					pInput.uniforms[pInfo.shaderVarInfo.location] = pUniforms[pInfo.nameIndex];
				}
			}



			for(var i:  number  = 0; i < this._pInputSamplerInfoList.length; i++){
				var pInfo: IInputUniformInfo = this._pInputSamplerInfoList[i];

				var pState: IAFXSamplerState = null;
				var pTexture: ITexture = null;

				if(pInfo.isCollapsedArray){
					pState = pSamplerArrays[pInfo.nameIndex][0];
				}
				else {
					pState = pPassInput._getSamplerState(pInfo.nameIndex);
				}

				pTexture = pPassInput._getTextureForSamplerState(pState);

				this.setSamplerState(pInput.uniforms[pInfo.shaderVarInfo.location], pTexture, pState);
			}



			for(var i:  number  = 0; i < this._pInputSamplerArrayInfoList.length; i++){
				var pInfo: IInputUniformInfo = this._pInputSamplerArrayInfoList[i];

				var pSamplerStates: IAFXSamplerState[] = pSamplerArrays[pInfo.nameIndex];
				var pInputStates: IAFXSamplerState[] = pInput.uniforms[pInfo.shaderVarInfo.location];

				for(var j:  number  = 0; j < pInfo.shaderVarInfo.length; j++) {
					var pTexture: ITexture = pPassInput._getTextureForSamplerState(pSamplerStates[j]);
					this.setSamplerState(pInputStates[j], pTexture, pSamplerStates[j]);
				}
			}



			for(var i:  number  = 0; i < this._pShaderAttrInfoList.length; i++) {
				var pAttrInfo: IShaderAttrInfo = this._pShaderAttrInfoList[i];
				var pFlow: IDataFlow = pAttrInfo.isComplex ?
										pBufferMap.findFlow(pAttrInfo.semantic) || pBufferMap.getFlowBySemantic(pAttrInfo.semantic):
										pBufferMap.getFlowBySemantic(pAttrInfo.semantic);
// pBufferMap.findFlow(pAttrInfo.semantic) || pBufferMap.getFlow(pAttrInfo.semantic, true): 
// pBufferMap.getFlow(pAttrInfo.semantic, true);

				pInput.attrs[pAttrInfo.location] = pFlow;

				if(pAttrInfo.isMappable){
					pInput.uniforms[pAttrInfo.vertexTextureInfo.location] = pFlow.data.buffer;

					if(!isNull(pAttrInfo.offsets)){
						var pVertexDecl: IVertexDeclaration = pFlow.data.getVertexDeclaration();

						for(var j:  number  = 0; j < pAttrInfo.offsets.length; j++){
							var pOffsetInfo: IShaderAttrOffsetInfo = pAttrInfo.offsets[j];
							var pElement: IVertexElement = pVertexDecl.findElement(pOffsetInfo.semantic);

							if(isNull(pElement)) {
								pInput.uniforms[pOffsetInfo.shaderVarInfo.location] = pOffsetInfo.defaultValue;
							}
							else {
/* offset in float */
								pInput.uniforms[pOffsetInfo.shaderVarInfo.location] = pElement.offset / 4.;
							}
						}
					}
				}

			}



			if(this._isUsedZero2D){
				pInput.uniforms[this._pShaderUniformInfoMap["as0"].location] = 19;
			}

			if(this._isUsedZeroCube){
				pInput.uniforms[this._pShaderUniformInfoMap["asc0"].location] = 19;
			}

			render.mergeRenderStateMap(pPassInputRenderStates, this._pPassBlend._getRenderStates(), pInput.renderStates);


			return pInput;
		}

		private prepareApplyFunctionForUniform(pUniform: IShaderUniformInfo): void {
			if(pUniform.type !== EAFXShaderVariableType.k_NotVar) {
				pUniform.applyFunction = this.getUniformApplyFunction(pUniform.type, (pUniform.length > 0));
				pUniform.defaultValue = this.getUnifromDefaultValue(pUniform.type, (pUniform.length > 0));
			}
		}

		private getUniformApplyFunction(eType: EAFXShaderVariableType, isArray: bool): Function {

			if(isArray){
				switch (eType) {
			        case EAFXShaderVariableType.k_Float:
			        	return this._pShaderProgram._setFloat32Array;
			        case EAFXShaderVariableType.k_Int:
			        	return this._pShaderProgram._setInt32Array;
			        case EAFXShaderVariableType.k_Bool:
			        	return this._pShaderProgram._setInt32Array;

			        case EAFXShaderVariableType.k_Float2:
			        	return this._pShaderProgram._setVec2Array;
			        case EAFXShaderVariableType.k_Int2:
			        	return this._pShaderProgram._setVec2iArray;
// case EAFXShaderVariableType.k_Bool2:
// 	return this._pShaderProgram._setBool2Array;

			        case EAFXShaderVariableType.k_Float3:
			        	return this._pShaderProgram._setVec3Array;
			        case EAFXShaderVariableType.k_Int3:
			        	return this._pShaderProgram._setVec3iArray;
// case EAFXShaderVariableType.k_Bool3:
// 	return this._pShaderProgram._setBool3Array;

			        case EAFXShaderVariableType.k_Float4:
			        	return this._pShaderProgram._setVec4Array;
			        case EAFXShaderVariableType.k_Int4:
			        	return this._pShaderProgram._setVec4iArray;
// case EAFXShaderVariableType.k_Bool4:
// 	return this._pShaderProgram._setBool4Array;

// case EAFXShaderVariableType.k_Float2x2:
// 	return this._pShaderProgram._setMat2Array;
			        case EAFXShaderVariableType.k_Float3x3:
			        	return this._pShaderProgram._setMat3Array;
			        case EAFXShaderVariableType.k_Float4x4:
			        	return this._pShaderProgram._setMat4Array;

			        case EAFXShaderVariableType.k_Sampler2D:
			        	return this._pShaderProgram._setSamplerArray;
			        case EAFXShaderVariableType.k_SamplerCUBE:
			        	return this._pShaderProgram._setSamplerArray;
			        default:
			        	{ logger.setSourceLocation( "fx/Maker.ts" , 775 ); logger.criticalError("Wrong uniform array type (" + eType + ")"); } ;
		        }
			}
			else {
				switch (eType) {
			        case EAFXShaderVariableType.k_Float:
			        	return this._pShaderProgram._setFloat;
			        case EAFXShaderVariableType.k_Int:
			        	return this._pShaderProgram._setInt;
			        case EAFXShaderVariableType.k_Bool:
			        	return this._pShaderProgram._setInt;

			        case EAFXShaderVariableType.k_Float2:
			        	return this._pShaderProgram._setVec2;
			        case EAFXShaderVariableType.k_Int2:
			        	return this._pShaderProgram._setVec2i;
// case EAFXShaderVariableType.k_Bool2:
// 	return this._pShaderProgram._setBool2

			        case EAFXShaderVariableType.k_Float3:
			        	return this._pShaderProgram._setVec3;
			        case EAFXShaderVariableType.k_Int3:
			        	return this._pShaderProgram._setVec3i;
// case EAFXShaderVariableType.k_Bool3:
// 	return this._pShaderProgram._setBool3

			        case EAFXShaderVariableType.k_Float4:
			        	return this._pShaderProgram._setVec4;
			        case EAFXShaderVariableType.k_Int4:
			        	return this._pShaderProgram._setVec4i;
// case EAFXShaderVariableType.k_Bool4:
// 	return this._pShaderProgram._setBool4

// case EAFXShaderVariableType.k_Float2x2:
// 	return this._pShaderProgram._setMat2
			        case EAFXShaderVariableType.k_Float3x3:
			        	return this._pShaderProgram._setMat3;
			        case EAFXShaderVariableType.k_Float4x4:
			        	return this._pShaderProgram._setMat4;

			        case EAFXShaderVariableType.k_Sampler2D:
			        	return this._pShaderProgram._setSampler;
			        case EAFXShaderVariableType.k_SamplerCUBE:
			        	return this._pShaderProgram._setSampler;
			        case EAFXShaderVariableType.k_SamplerVertexTexture:
			        	return this._pShaderProgram._setVertexBuffer;
			        default:
			        	{ logger.setSourceLocation( "fx/Maker.ts" , 822 ); logger.criticalError("Wrong uniform type (" + eType + ")"); } ;
		        }
			}


		}

		private getUnifromDefaultValue(eType: EAFXShaderVariableType, isArray: bool): any {
			if(isArray){
				return null;
			}
			else {
				switch (eType) {
			        case EAFXShaderVariableType.k_Float:
			        	return 0.;
			        case EAFXShaderVariableType.k_Int:
			        	return 0;
			        case EAFXShaderVariableType.k_Bool:
			        	return 0;

			        case EAFXShaderVariableType.k_Float2:
			        	return new Vec2(0);
			        case EAFXShaderVariableType.k_Int2:
			        	return new Vec2(0);
			        case EAFXShaderVariableType.k_Bool2:
			        	return new Vec2(0);

			        case EAFXShaderVariableType.k_Float3:
			        	return new Vec3(0);
			        case EAFXShaderVariableType.k_Int3:
			        	return new Vec3(0);
			        case EAFXShaderVariableType.k_Bool3:
			        	return new Vec3(0);

			        case EAFXShaderVariableType.k_Float4:
			        	return new Vec4(0);
			        case EAFXShaderVariableType.k_Int4:
			        	return new Vec4(0);
			        case EAFXShaderVariableType.k_Bool4:
			        	return new Vec4(0);

// case EAFXShaderVariableType.k_Float2x2:
// 	return new Mat2(0);
			        case EAFXShaderVariableType.k_Float3x3:
			        	return new Mat3(0);
			        case EAFXShaderVariableType.k_Float4x4:
			        	return new Mat4(0);

			        case EAFXShaderVariableType.k_Sampler2D:
			        	return null;
			        case EAFXShaderVariableType.k_SamplerCUBE:
			        	return null;
			        case EAFXShaderVariableType.k_SamplerVertexTexture:
			        	return null;
			        default:
			        	{ logger.setSourceLocation( "fx/Maker.ts" , 970 ); logger.criticalError("Wrong uniform type (" + eType + ")"); } ;
		        }
			}
		}

		private setSamplerState(pOut: IAFXSamplerState, pTexture: ITexture, pFrom: IAFXSamplerState): void {
			pOut.texture = pTexture;
			pOut.wrap_s = pFrom.wrap_s;
			pOut.wrap_t = pFrom.wrap_t;
			pOut.mag_filter = pFrom.mag_filter;
			pOut.min_filter = pFrom.min_filter;
		}

		private expandStructUniforms(pVariable: IAFXVariableDeclInstruction, sPrevName?: string = ""): IUniformStructInfo {
			var sRealName: string = pVariable.getRealName();

			if(sPrevName !== ""){
				sPrevName += "." + sRealName;
			}
			else {
				if(!this._pPassBlend._hasUniformWithName(sRealName)){
					return null;
				}

				sPrevName = sRealName;
			}

			var pVarType: IAFXVariableTypeInstruction = pVariable.getType();
			var pFieldNameList: string[] = pVarType.getFieldNameList();
			var isArray: bool = pVarType.isNotBaseArray();
			var iLength:  number  = isArray ? pVarType.getLength() : 1;

			if(isArray && (iLength ===  0xffffff  || iLength === 0)){
				{ logger.setSourceLocation( "fx/Maker.ts" , 1003 ); logger.warning("Length of struct '" + sRealName + "' can not be undefined"); } ;
				return null;
			}

			var pStructInfo: IUniformStructInfo = createUniformStructFieldInfo(sRealName, true, isArray);
			pStructInfo.fields = new Array();

			var sFieldPrevName: string = "";
			var pFieldInfoList: IUniformStructInfo[] = null;

			for(var i:  number  = 0; i < iLength; i++){
				if(isArray){
					pFieldInfoList =  new Array();
					sFieldPrevName = sPrevName + "[" + i + "]";
				}
				else {
					pFieldInfoList = pStructInfo.fields;
					sFieldPrevName = sPrevName;
				}

				for(var j:  number  = 0; j < pFieldNameList.length; j++){
					var sFieldName: string = pFieldNameList[j];
					var pField: IAFXVariableDeclInstruction = pVarType.getField(sFieldName);
					var pFieldInfo: IUniformStructInfo = null;

					if(pField.getType().isComplex()){
						pFieldInfo = this.expandStructUniforms(pField, sFieldPrevName);
					}
					else {
						var sFieldRealName: string = sFieldPrevName + "." + pField.getRealName();
						var eFieldType: EAFXShaderVariableType = VariableContainer.getVariableType(pField);
						var iFieldLength:  number  = pField.getType().getLength();
						var isFieldArray: bool = pField.getType().isNotBaseArray();
						var sFieldShaderName: string = sFieldRealName;

						if(isFieldArray){
							sFieldShaderName += "[0]";
						}

						if(!this.isUniformExists(sFieldShaderName)){
							continue;
						}

						var pShaderUniformInfo: IShaderUniformInfo = this._pShaderUniformInfoMap[sFieldShaderName];
						pShaderUniformInfo.type = eFieldType;
						pShaderUniformInfo.length = iFieldLength;

						pFieldInfo = createUniformStructFieldInfo(pField.getRealName(), false, isFieldArray);
						pFieldInfo.shaderVarInfo = pShaderUniformInfo;
					}

					if(!isNull(pFieldInfo)){
						pFieldInfoList.push(pFieldInfo);
					}
				}

				if(isArray && pFieldInfoList.length > 0){
					var pArrayElementInfo: IUniformStructInfo = createUniformStructFieldInfo(sRealName, true, false);
					pArrayElementInfo.index = i;
					pArrayElementInfo.fields = pFieldInfoList;

					pStructInfo.fields.push(pArrayElementInfo);
				}
			}

			if(pStructInfo.fields.length > 0){
				return pStructInfo;
			}
			else {
				return null;
			}
		}

		private applyStructUniform(pStructInfo: IUniformStructInfo, pValue: any, pInput: IShaderInput): void {
			if(!isDefAndNotNull(pValue)){
				return;
			}

			if(pStructInfo.isArray){
				for(var i:  number  = 0; i < pStructInfo.fields.length; i++){
					var pFieldInfo: IUniformStructInfo = pStructInfo.fields[i];
					if(isDef(pValue[pFieldInfo.index])){
						this.applyStructUniform(pFieldInfo, pValue[pFieldInfo.index], pInput);
					}
				}
			}
			else {
				for(var i:  number  = 0; i < pStructInfo.fields.length; i++){
					var pFieldInfo: IUniformStructInfo = pStructInfo.fields[i];
					var pFieldValue: any = pValue[pFieldInfo.name];

					if(isDef(pFieldValue)){
						if(pFieldInfo.isComplex){
							this.applyStructUniform(pFieldInfo, pFieldValue, pInput);
						}
						else {
							pInput.uniforms[pFieldInfo.shaderVarInfo.location] = pFieldValue;
						}
					}
				}
			}
		}

		private applyUnifromArray(sName: string, eType: EAFXShaderVariableType, pValue: any): void {
			switch (eType) {
		        case EAFXShaderVariableType.k_Float:
		        	this._pShaderProgram.setFloat32Array(sName, pValue);
		        	break;
		        case EAFXShaderVariableType.k_Int:
		        	this._pShaderProgram.setInt32Array(sName, pValue);
		        	break;
// case EAFXShaderVariableType.k_Bool:
// 	this._pShaderProgram.setBoolArray(sName, pValue);
// 	break;

		        case EAFXShaderVariableType.k_Float2:
		        	this._pShaderProgram.setVec2Array(sName, pValue);
		        	break;
		        case EAFXShaderVariableType.k_Int2:
		        	this._pShaderProgram.setVec2iArray(sName, pValue);
		        	break;
// case EAFXShaderVariableType.k_Bool2:
// 	this._pShaderProgram.setBool2Array(sName, pValue);
// 	break;

		        case EAFXShaderVariableType.k_Float3:
		        	this._pShaderProgram.setVec3Array(sName, pValue);
		        	break;
		        case EAFXShaderVariableType.k_Int3:
		        	this._pShaderProgram.setVec3iArray(sName, pValue);
		        	break;
// case EAFXShaderVariableType.k_Bool3:
// 	this._pShaderProgram.setBool3Array(sName, pValue);
// 	break;

		        case EAFXShaderVariableType.k_Float4:
		        	this._pShaderProgram.setVec4Array(sName, pValue);
		        	break;
		        case EAFXShaderVariableType.k_Int4:
		        	this._pShaderProgram.setVec4iArray(sName, pValue);
		        	break;
// case EAFXShaderVariableType.k_Bool4:
// 	this._pShaderProgram.setBool4Array(sName, pValue);
// 	break;

// case EAFXShaderVariableType.k_Float2x2:
// 	this._pShaderProgram.setMat2Array(sName, pValue);
// 	break;
		        case EAFXShaderVariableType.k_Float3x3:
		        	this._pShaderProgram.setMat3Array(sName, pValue);
		        	break;
		        case EAFXShaderVariableType.k_Float4x4:
		        	this._pShaderProgram.setMat4Array(sName, pValue);
		        	break;

		        case EAFXShaderVariableType.k_Sampler2D:
		        	this._pShaderProgram.setSamplerArray(sName, pValue);
		        	break;
		        case EAFXShaderVariableType.k_SamplerCUBE:
		        	this._pShaderProgram.setSamplerArray(sName, pValue);
		        	break;

		        default:
		        	{ logger.setSourceLocation( "fx/Maker.ts" , 1166 ); logger.criticalError("Wrong uniform array type (" + eType + ") with name " + sName); } ;
			}
		}

		private applyUniform(sName: string, eType: EAFXShaderVariableType, pValue: any): void {
			switch (eType) {
		        case EAFXShaderVariableType.k_Float:
		        	this._pShaderProgram.setFloat(sName, pValue || 0.);
		        	break;
		        case EAFXShaderVariableType.k_Int:
		        	this._pShaderProgram.setInt(sName, pValue || 0);
		        	break;
		        case EAFXShaderVariableType.k_Bool:
		        	this._pShaderProgram.setInt(sName, pValue ? 1 : 0);
		        	break;

		        case EAFXShaderVariableType.k_Float2:
		        	this._pShaderProgram.setVec2(sName, pValue ||  Vec2.stackCeil.set(0) );
		        	break;
		        case EAFXShaderVariableType.k_Int2:
		        	this._pShaderProgram.setVec2i(sName, pValue ||  Vec2.stackCeil.set(0) );
		        	break;
// case EAFXShaderVariableType.k_Bool2:
// 	this._pShaderProgram.setBool2(sName, pValue);
// 	break;

		        case EAFXShaderVariableType.k_Float3:
		        	this._pShaderProgram.setVec3(sName, pValue ||  Vec3.stackCeil.set(0) );
		        	break;
		        case EAFXShaderVariableType.k_Int3:
		        	this._pShaderProgram.setVec3i(sName, pValue ||  Vec3.stackCeil.set(0) );
		        	break;
// case EAFXShaderVariableType.k_Bool3:
// 	this._pShaderProgram.setBool3(sName, pValue);
// 	break;

		        case EAFXShaderVariableType.k_Float4:
		        	this._pShaderProgram.setVec4(sName, pValue ||  Vec4.stackCeil.set(0) );
		        	break;
		        case EAFXShaderVariableType.k_Int4:
		        	this._pShaderProgram.setVec4i(sName, pValue ||  Vec4.stackCeil.set(0) );
		        	break;
// case EAFXShaderVariableType.k_Bool4:
// 	this._pShaderProgram.setBool4(sName, pValue);
// 	break;

// case EAFXShaderVariableType.k_Float2x2:
// 	this._pShaderProgram.setMat2(sName, pValue);
// 	break;
		        case EAFXShaderVariableType.k_Float3x3:
		        	this._pShaderProgram.setMat3(sName, pValue ||  Mat3.stackCeil.set(0) );
		        	break;
		        case EAFXShaderVariableType.k_Float4x4:
		        	this._pShaderProgram.setMat4(sName, pValue ||  Mat4.stackCeil.set(0) );
		        	break;

		        case EAFXShaderVariableType.k_Sampler2D:
		        	this._pShaderProgram.setSampler(sName, pValue);
		        	break;
		        case EAFXShaderVariableType.k_SamplerCUBE:
		        	this._pShaderProgram.setSampler(sName, pValue);
		        	break;
		        case EAFXShaderVariableType.k_SamplerVertexTexture:
		        	this._pShaderProgram.setVertexBuffer(sName, pValue);
		        	break;
		        default:
		        	{ logger.setSourceLocation( "fx/Maker.ts" , 1232 ); logger.criticalError("Wrong uniform type (" + eType + ") with name " + sName); } ;
			}
		}


	}
}











module akra.util {
	export class StringMinifier {
		private _pMinMap: IntMap = <IntMap>{};
		private _nCount:  number  = 1;

		/**@inline*/  minify(sValue: string):  number  {
			return this._pMinMap[sValue] || (this._pMinMap[sValue] = this._nCount++);
		}
	}
}






module akra.util {
	export class IHashTreeEntry {
		parent: IHashTreeEntry;
		children: IHashTreeEntry[];
		value:  number ;
		content: any;
	}

	export class HashTree {
		private _pRoot: IHashTreeEntry = null;
		private _pCurrent: IHashTreeEntry = null;
		private _fnSort: Function = null;

		constructor(){
			this._pRoot = this._pCurrent = <IHashTreeEntry>{
				parent: <IHashTreeEntry>null,
				children: [],
				value: 0,
				content: null
			};

			this._fnSort = function(a: IHashTreeEntry, b: IHashTreeEntry):  number  {
				return a.value - b.value;
			};
		}

		has(iValue:  number ): bool {
			var iIndex:  number  = this.binarySearchInSortArray(this._pCurrent.children, iValue);

			if(iIndex !== -1){
				this._pCurrent = this._pCurrent.children[iIndex];
				return true;
			}

			var pNewEntry: IHashTreeEntry = <IHashTreeEntry>{
				parent: this._pCurrent,
				children: [],
				value: iValue,
				content: null
			};

			this._pCurrent.children.push(pNewEntry);
			this._pCurrent.children.sort(<any>this._fnSort);

			this._pCurrent = pNewEntry;
			return false;
		}

		next(iValue:  number ): HashTree {
			var iIndex:  number  = this.binarySearchInSortArray(this._pCurrent.children, iValue);

			if(iIndex !== -1){
				this._pCurrent = this._pCurrent.children[iIndex];
				return this;
			}

			var pNewEntry: IHashTreeEntry = <IHashTreeEntry>{
				parent: this._pCurrent,
				children: [],
				value: iValue,
				content: null
			};

			this._pCurrent.children.push(pNewEntry);
			this._pCurrent.children.sort(<any>this._fnSort);

			this._pCurrent = pNewEntry;
			return this;
		}

		release(): void {
			this._pCurrent = this._pRoot;
		}

		addContent(pContent: any): void {
			this._pCurrent.content = pContent;
		}

		getContent(): any {
			return this._pCurrent.content;
		}

		binarySearchInSortArray(pArray: IHashTreeEntry[], iValue:  number ):  number  {
			if(pArray.length === 0){
				return -1;
			}

            if(iValue < pArray[0].value || iValue > pArray[pArray.length - 1].value){
                return -1;
            }

            if(iValue === pArray[0].value){
                return 0;
            }

            if(iValue === pArray[pArray.length - 1].value){
                return pArray.length - 1;
            }

            var p:  number  = 0;
            var q:  number  = pArray.length - 1;

            while(p < q){
                var s:  number  = (p + q) >> 1;

                if(iValue === pArray[s].value){
                    return s;
                }
                else if(iValue > pArray[s].value){
                    p = s + 1;
                }
                else {
                    q = s;
                }
            }

            return -1;
        }
	}
}





module akra.fx {
	export interface IHashEntry {
		hash:  number ;
		modifyMark:  number ;
	}

	export interface IHashEntryMap {
		[index:  number ]: IHashEntry;
	}

	export class PassBlend implements IAFXPassBlend {
		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } ;

		private _pComposer: IAFXComposer = null;
		private _pFXMakerHashTree: util.HashTree = null;

		private _pExtSystemDataV: ExtSystemDataContainer = null;
		private _pComplexTypeContainerV: ComplexTypeBlendContainer = null;
		private _pForeignContainerV: VariableBlendContainer = null;
		private _pUniformContainerV: VariableBlendContainer = null;
		private _pSharedContainerV: VariableBlendContainer = null;
		private _pGlobalContainerV: VariableBlendContainer = null;
		private _pAttributeContainerV: AttributeBlendContainer = null;
		private _pVaryingContainerV: VariableBlendContainer = null;
		private _pVertexOutType: IAFXTypeInstruction = null;
		private _pUsedFunctionListV: IAFXFunctionDeclInstruction[] = null;

		private _pPassFunctionListV: IAFXFunctionDeclInstruction[] = null;
		private _pTextureMapV: BoolMap = null;

		private _pExtSystemDataP: ExtSystemDataContainer = null;
		private _pComplexTypeContainerP: ComplexTypeBlendContainer = null;
		private _pForeignContainerP: VariableBlendContainer = null;
		private _pUniformContainerP: VariableBlendContainer = null;
		private _pSharedContainerP: VariableBlendContainer = null;
		private _pGlobalContainerP: VariableBlendContainer = null;
		private _pVaryingContainerP: VariableBlendContainer = null;
		private _pUsedFunctionListP: IAFXFunctionDeclInstruction[] = null;
		private _pPassFunctionListP: IAFXFunctionDeclInstruction[] = null;
		private _pTextureMapP: BoolMap = null;

		private _hasEmptyVertex: bool = true;
		private _hasEmptyPixel: bool = true;

		private _pPassStateMap:  IRenderStateMap  = null;

//Code fragments
// private _isZeroSampler2dV: bool = false;
// private _isZeroSamplerCubeV: bool = false;
		private _sUniformSamplerCodeV: string = "";

		private _sAttrBufferDeclCode: string = "";
		private _sAttrDeclCode: string = "";
		private _sAFXAttrDeclCode: string = "";
		private _sAttrBufferInitCode: string = "";
		private _sAFXAttrInitCode: string = "";

		private _sSystemExtBlockCodeV: string = "";
		private _sFunctionDefCodeV: string = "";
		private _sSharedVarCodeV: string = "";
		private _sVaryingDeclCodeV: string = "";
		private _sVertexOutDeclCode: string = "";
		private _sVertexOutToVaryingCode: string = "";
		private _sPassFunctionCallCodeV: string = "";


// private _isZeroSampler2dP: bool = false;
// private _isZeroSamplerCubeP: bool = false;
		private _sUniformSamplerCodeP: string = "";

		private _sSystemExtBlockCodeP: string = "";
		private _sFunctionDefCodeP: string = "";
		private _sSharedVarCodeP: string = "";
		private _sVaryingDeclCodeP: string = "";
		private _sPassFunctionCallCodeP: string = "";


		private _sVertexCode: string = "";
		private _sPixelCode: string = "";

		private _pDefaultSamplerBlender: SamplerBlender = null;
		private _pTexcoordSwapper: TexcoordSwapper = null;

//For speed-up
		private _pSamplerByIdMap: IAFXVariableDeclMap = null;
		private _pSamplerIdList:  number [] = null;

		private _pSamplerArrayByIdMap: IAFXVariableDeclMap = null;
		private _pSamplerArrayIdList:  number [] = null;

		private _pPassInputForeignsHashMap: IHashEntryMap = null;
		private _pPassInputSamplersHashMap: IHashEntryMap = null;
		private _pBufferMapHashMap: IHashEntryMap = null;
		private _pSurfaceMaterialHashMap: IHashEntryMap = null;

		private _isSamplersPrepared: bool = false;
		private _isBufferMapPrepared: bool = false;
		private _isSurfaceMaterialPrepared: bool = false;

		static private texcoordSwapper: TexcoordSwapper = null;
		static private hashMinifier: util.StringMinifier = null;

		constructor(pComposer: IAFXComposer){
			this._pComposer = pComposer;

			this._pFXMakerHashTree = new util.HashTree();

			this._pExtSystemDataV = new ExtSystemDataContainer();
			this._pComplexTypeContainerV = new ComplexTypeBlendContainer();
			this._pForeignContainerV = new VariableBlendContainer();
			this._pUniformContainerV = new VariableBlendContainer();
			this._pSharedContainerV = new VariableBlendContainer();
			this._pGlobalContainerV = new VariableBlendContainer();
			this._pAttributeContainerV = new AttributeBlendContainer();
			this._pVaryingContainerV = new VariableBlendContainer();
			this._pVertexOutType = Effect.getBaseVertexOutType();
			this._pUsedFunctionListV = [];
			this._pPassFunctionListV = [];
			this._pTextureMapV = <BoolMap>{};

			this._pExtSystemDataP = new ExtSystemDataContainer();
			this._pComplexTypeContainerP = new ComplexTypeBlendContainer();
			this._pForeignContainerP = new VariableBlendContainer();
			this._pUniformContainerP = new VariableBlendContainer();
			this._pSharedContainerP = new VariableBlendContainer();
			this._pGlobalContainerP = new VariableBlendContainer();
			this._pVaryingContainerP = new VariableBlendContainer();
			this._pUsedFunctionListP = [];
			this._pPassFunctionListP = [];
			this._pTextureMapP = <BoolMap>{};

			this._pDefaultSamplerBlender = Composer.pDefaultSamplerBlender;

			if(isNull(PassBlend.texcoordSwapper)){
				PassBlend.texcoordSwapper = new TexcoordSwapper();
			}

			if(isNull(PassBlend.hashMinifier)){
				PassBlend.hashMinifier = new util.StringMinifier();
			}

			this._pTexcoordSwapper = PassBlend.texcoordSwapper;

			this._pPassStateMap = render.createRenderStateMap();

			this._pPassInputForeignsHashMap = <IHashEntryMap>{};
			this._pPassInputSamplersHashMap = <IHashEntryMap>{};
			this._pBufferMapHashMap = <IHashEntryMap>{};
			this._pSurfaceMaterialHashMap = <IHashEntryMap>{};
		}

		initFromPassList(pPassList: IAFXPassInstruction[]): bool {
			for(var i:  number  = 0; i < pPassList.length; i++){
				if(!this.addPass(pPassList[i])) {
					return false;
				}
			}

			if(!this.finalizeBlend()){
				return false;
			}

			return true;
		}

		generateFXMaker(pPassInput: IAFXPassInputBlend,
					    pSurfaceMaterial: ISurfaceMaterial,
					    pBuffer: IBufferMap): IAFXMaker {
			pPassInput.setSurfaceMaterial(pSurfaceMaterial);

			var iForeignPartHash:  number  = this.prepareForeigns(pPassInput);
			var iSamplerPartHash:  number  = this.prepareSamplers(pPassInput, false);
			var iMaterialPartHash:  number  = this.prepareSurfaceMaterial(pSurfaceMaterial, false);
			var iBufferPartHash:  number  = this.prepareBufferMap(pBuffer, false);

			this._pFXMakerHashTree.release();
			var pMaker: IAFXMaker = this._pFXMakerHashTree.next(iForeignPartHash)
														  .next(iSamplerPartHash)
														  .next(iMaterialPartHash)
														  .next(iBufferPartHash)
														  .getContent();

			if(isNull(pMaker)) {
				if(!this._isBufferMapPrepared){
					this.prepareBufferMap(pBuffer, true);
				}

				if(!this._isSamplersPrepared){
					this.prepareSamplers(pPassInput, true);
				}

				this.applyForeigns(pPassInput);
				this.swapTexcoords(pSurfaceMaterial);
				this.generateShaderCode();
				this.resetForeigns();

				pMaker = new Maker(this._pComposer, this);
				var isCreate: bool = pMaker._create(this._sVertexCode, this._sPixelCode);

				if(!isCreate){
					{ logger.setSourceLocation( "fx/PassBlend.ts" , 217 ); logger.criticalError("Can not create fx.Maker"); } ;
					return null;
				}

				pMaker._initInput(pPassInput, this._pDefaultSamplerBlender, this._pAttributeContainerV);

				this._pFXMakerHashTree.addContent(pMaker);
				this._pDefaultSamplerBlender.clear();
			}

			return pMaker;
		}

		/**@inline*/  _hasUniformWithName(sName: string): bool {
			return this.hasUniformWithName(sName);
		}

		/**@inline*/  _hasUniformWithNameIndex(iNameIndex:  number ): bool {
			return this.hasUniformWithNameIndex(iNameIndex);
		}

		/**@inline*/  _getRenderStates(): IRenderStateMap {
			return this._pPassStateMap;
		}

		private finalizeBlend(): bool {
			if(!this.finalizeBlendForVertex()) {
				return false;
			}

			if(!this.finalizeBlendForPixel()) {
				return false;
			}

			this.prepareFastObjects();

			return true;
		}

		private addPass(pPass: IAFXPassInstruction): bool {
			var pVertex: IAFXFunctionDeclInstruction = pPass.getVertexShader();
			var pPixel: IAFXFunctionDeclInstruction = pPass.getPixelShader();

			var pForeignMap: IAFXVariableDeclMap = null;
			var pGlobalMap: IAFXVariableDeclMap = null;
			var pSharedMap: IAFXVariableDeclMap = null;
			var pUniformMap: IAFXVariableDeclMap = null;
			var pTextureMap: IAFXVariableDeclMap = null;
			var pAttributeMap: IAFXVariableDeclMap = null;
			var pVaryingMap: IAFXVariableDeclMap = null;
			var pComplexTypeMap: IAFXTypeMap = null;


			var pForeignKeys:  number [] = null;
			var pGlobalKeys:  number [] = null;
			var pSharedKeys:  number [] = null;
			var pUniformKeys:  number [] = null;
			var pTextureKeys:  number [] = null;
			var pAttributeKeys:  number [] = null;
			var pVaryingKeys:  number [] = null;
			var pComplexTypeKeys:  number [] = null;

			var pForeign: IAFXVariableDeclInstruction = null;
			var pGlobal: IAFXVariableDeclInstruction = null;
			var pShared: IAFXVariableDeclInstruction = null;
			var pUniform: IAFXVariableDeclInstruction = null;
			var pTexture: IAFXVariableDeclInstruction = null;
			var pAttribute: IAFXVariableDeclInstruction = null;
			var pVarying: IAFXVariableDeclInstruction = null;
			var pComplexType: IAFXTypeInstruction = null;

			var pUsedFunctionList: IAFXFunctionDeclInstruction[] = null;
			var pUsedFunction: IAFXFunctionDeclInstruction = null;

			if(!isNull(pVertex)) {
				this._hasEmptyVertex = false;

//blend system data
				this._pExtSystemDataV.addFromFunction(pVertex);

//blend foreigns
				pForeignMap = pVertex._getForeignVariableMap();
				pForeignKeys = pVertex._getForeignVariableKeys();

				if(!isNull(pForeignKeys)){
					for(var i:  number  = 0; i < pForeignKeys.length; i++){
						pForeign = pForeignMap[pForeignKeys[i]];

						if(!this._pForeignContainerV.addVariable(pForeign, EAFXBlendMode.k_Foreign)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 306 ); logger.error("Could not add foreign variable"); } ;
							return false;
						}
					}
				}

//blend globals
				pGlobalMap = pVertex._getGlobalVariableMap();
				pGlobalKeys = pVertex._getGlobalVariableKeys();

				if(!isNull(pGlobalKeys)){
					for(var i:  number  = 0; i < pGlobalKeys.length; i++){
						pGlobal = pGlobalMap[pGlobalKeys[i]];

						if(!this._pGlobalContainerV.addVariable(pGlobal, EAFXBlendMode.k_Global)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 321 ); logger.error("Could not add global variable"); } ;
							return false;
						}
					}
				}

//blend shareds
				pSharedMap = pVertex._getSharedVariableMap();
				pSharedKeys = pVertex._getSharedVariableKeys();

				if(!isNull(pSharedKeys)){
					for(var i:  number  = 0; i < pSharedKeys.length; i++){
						pShared = pSharedMap[pSharedKeys[i]];

						if(!this._pSharedContainerV.addVariable(pShared, EAFXBlendMode.k_Shared)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 336 ); logger.error("Could not add shared variable"); } ;
							return false;
						}
					}
				}

//TODO: blend uniforms
				pUniformMap = pVertex._getUniformVariableMap();
				pUniformKeys = pVertex._getUniformVariableKeys();

				if(!isNull(pUniformKeys)){
					for(var i:  number  = 0; i < pUniformKeys.length; i++){
						pUniform = pUniformMap[pUniformKeys[i]];

						if(isNull(pUniform)){
							continue;
						}

						if(!this._pUniformContainerV.addVariable(pUniform, EAFXBlendMode.k_Uniform)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 355 ); logger.error("Could not add uniform variable"); } ;
							return false;
						}
					}
				}

//TODO: blend textures
				pTextureMap = pVertex._getTextureVariableMap();
				pTextureKeys = pVertex._getTextureVariableKeys();

				if(!isNull(pTextureKeys)){
					for(var i:  number  = 0; i < pTextureKeys.length; i++){
						pTexture = pTextureMap[pTextureKeys[i]];

						if(isNull(pTexture)){
							continue;
						}

						this._pTextureMapV[pTexture.getRealName()] = true;
					}
				}


//TODO: blend attributes
				pAttributeMap = pVertex._getAttributeVariableMap();
				pAttributeKeys = pVertex._getAttributeVariableKeys();

				if(!isNull(pAttributeKeys)){
					for(var i:  number  = 0; i < pAttributeKeys.length; i++){
						pAttribute = pAttributeMap[pAttributeKeys[i]];

						if(!this._pAttributeContainerV.addAttribute(pAttribute)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 387 ); logger.error("Could not add attribute variable"); } ;
							return false;
						}
					}
				}

//TODO: blend varyings
				pVaryingMap = pVertex._getVaryingVariableMap();
				pVaryingKeys = pVertex._getVaryingVariableKeys();

				if(!isNull(pVaryingKeys)){
					for(var i:  number  = 0; i < pVaryingKeys.length; i++){
						pVarying = pVaryingMap[pVaryingKeys[i]];

						if(!this._pVaryingContainerV.addVariable(pVarying, EAFXBlendMode.k_Varying)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 402 ); logger.error("Could not add varying variable"); } ;
							return false;
						}
					}
				}

//blend used type
				pComplexTypeMap = pVertex._getUsedComplexTypeMap();
				pComplexTypeKeys = pVertex._getUsedComplexTypeKeys();

				if(!isNull(pComplexTypeKeys)){
					for(var i:  number  = 0; i < pComplexTypeKeys.length; i++){
						pComplexType = pComplexTypeMap[pComplexTypeKeys[i]];

						if(!this._pComplexTypeContainerV.addComplexType(pComplexType)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 417 ); logger.error("Could not add type declaration"); } ;
							return false;
						}
					}
				}

//blend used functions
				pUsedFunctionList = pVertex._getUsedFunctionList();

				if(!isNull(pUsedFunctionList)){
					for(var i:  number  = 0; i < pUsedFunctionList.length; i++) {
						pUsedFunction = pUsedFunctionList[i];

						if(this._pUsedFunctionListV.indexOf(pUsedFunction) === -1){
							this._pUsedFunctionListV.push(pUsedFunction);
						}
					}
				}

				var pVertexOut: IAFXTypeInstruction = pVertex.getReturnType().getBaseType();

				if(pVertexOut.isComplex()){
					this._pVertexOutType = this._pVertexOutType.blend(pVertexOut, EAFXBlendMode.k_VertexOut);
				}
				this._pPassFunctionListV.push(pVertex);
			}

			if(!isNull(pPixel)) {
				this._hasEmptyPixel = false;
//blend system data
				this._pExtSystemDataP.addFromFunction(pPixel);

//blend foreigns
				pForeignMap = pPixel._getForeignVariableMap();
				pForeignKeys = pPixel._getForeignVariableKeys();

				if(!isNull(pForeignKeys)){
					for(var i:  number  = 0; i < pForeignKeys.length; i++){
						pForeign = pForeignMap[pForeignKeys[i]];

						if(!this._pForeignContainerP.addVariable(pForeign, EAFXBlendMode.k_Foreign)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 458 ); logger.error("Could not add foreign variable"); } ;
							return false;
						}
					}
				}

//blend globals
				pGlobalMap = pPixel._getGlobalVariableMap();
				pGlobalKeys = pPixel._getGlobalVariableKeys();

				if(!isNull(pGlobalKeys)){
					for(var i:  number  = 0; i < pGlobalKeys.length; i++){
						pGlobal = pGlobalMap[pGlobalKeys[i]];

						if(!this._pGlobalContainerP.addVariable(pGlobal, EAFXBlendMode.k_Global)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 473 ); logger.error("Could not add global variable"); } ;
							return false;
						}
					}
				}

//blend shareds
				pSharedMap = pPixel._getSharedVariableMap();
				pSharedKeys = pPixel._getSharedVariableKeys();

				if(!isNull(pSharedKeys)){
					for(var i:  number  = 0; i < pSharedKeys.length; i++){
						pShared = pSharedMap[pSharedKeys[i]];

						if(!this._pSharedContainerP.addVariable(pShared, EAFXBlendMode.k_Shared)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 488 ); logger.error("Could not add shared variable"); } ;
							return false;
						}
					}
				}

//TODO: blend uniforms
				pUniformMap = pPixel._getUniformVariableMap();
				pUniformKeys = pPixel._getUniformVariableKeys();

				if(!isNull(pUniformKeys)){
					for(var i:  number  = 0; i < pUniformKeys.length; i++){
						pUniform = pUniformMap[pUniformKeys[i]];

						if(isNull(pUniform)){
							continue;
						}

						if(!this._pUniformContainerP.addVariable(pUniform, EAFXBlendMode.k_Uniform)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 507 ); logger.error("Could not add uniform variable"); } ;
							return false;
						}
					}
				}

//TODO: blend textures
				pTextureMap = pPixel._getTextureVariableMap();
				pTextureKeys = pPixel._getTextureVariableKeys();

				if(!isNull(pTextureKeys)){
					for(var i:  number  = 0; i < pTextureKeys.length; i++){
						pTexture = pTextureMap[pTextureKeys[i]];

						if(isNull(pTexture)){
							continue;
						}

						this._pTextureMapP[pTexture.getRealName()] = true;
					}
				}

//TODO: blend varyings
				pVaryingMap = pPixel._getVaryingVariableMap();
				pVaryingKeys = pPixel._getVaryingVariableKeys();

				if(!isNull(pVaryingKeys)){
					for(var i:  number  = 0; i < pVaryingKeys.length; i++){
						pVarying = pVaryingMap[pVaryingKeys[i]];

						if(!this._pVaryingContainerP.addVariable(pVarying, EAFXBlendMode.k_Varying)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 538 ); logger.error("Could not add varying variable"); } ;
							return false;
						}
					}
				}

//blend used type
				pComplexTypeMap = pPixel._getUsedComplexTypeMap();
				pComplexTypeKeys = pPixel._getUsedComplexTypeKeys();

				if(!isNull(pComplexTypeKeys)){
					for(var i:  number  = 0; i < pComplexTypeKeys.length; i++){
						pComplexType = pComplexTypeMap[pComplexTypeKeys[i]];

						if(!this._pComplexTypeContainerP.addComplexType(pComplexType)){
							{ logger.setSourceLocation( "fx/PassBlend.ts" , 553 ); logger.error("Could not add type declaration"); } ;
							return false;
						}
					}
				}

//blend used functions
				pUsedFunctionList = pPixel._getUsedFunctionList();

				if(!isNull(pUsedFunctionList)){
					for(var i:  number  = 0; i < pUsedFunctionList.length; i++) {
						pUsedFunction = pUsedFunctionList[i];

						if(this._pUsedFunctionListP.indexOf(pUsedFunction) === -1){
							this._pUsedFunctionListP.push(pUsedFunction);
						}
					}
				}

				this._pPassFunctionListP.push(pPixel);
			}

			render.copyRenderStateMap(pPass._getRenderStates(), this._pPassStateMap);

			return true;
		}

		private finalizeBlendForVertex(): bool {
			if(this._hasEmptyVertex){
				return true;
			}

			if(!this.finalizeComplexTypeForShader(EFunctionType.k_Vertex)){
				return false;
			}

			this._pAttributeContainerV.finalize();
			this._pAttributeContainerV.generateOffsetMap();

			return true;
		}

		private finalizeBlendForPixel(): bool {
			if(this._hasEmptyPixel){
				return true;
			}

			if(!this.finalizeComplexTypeForShader(EFunctionType.k_Pixel)){
				return false;
			}

			return true;
		}

		private enableVaringPrefixes(eType: EFunctionType, bEnabled: bool): void {
			var pVars: VariableBlendContainer = null;

			if(eType === EFunctionType.k_Vertex){
				pVars = this._pVaryingContainerV;
			}
			else {
				pVars = this._pVaryingContainerP;
			}

			var pVarInfoList: fx.IVariableBlendInfo[] = pVars.varsInfo;

			for(var i:  number  = 0; i < pVarInfoList.length; i++){
				var pVarList: IAFXVariableDeclInstruction[] = pVarInfoList[i].varList;

				for(var j:  number  = 0; j < pVarList.length; j++) {
					pVarList[j]._markAsVarying(bEnabled);
				}
			}
		}

		private finalizeComplexTypeForShader(eType: EFunctionType): bool {
			var pTypeContainer: ComplexTypeBlendContainer = null;

			var pUniformContainer: VariableBlendContainer = null;
			var pGlobalContainer: VariableBlendContainer = null;
			var pSharedContainer: VariableBlendContainer = null;
			var pUsedFunctions: IAFXFunctionDeclInstruction[] = null;

			var pAttributeContainer: AttributeBlendContainer = null;


			if(eType === EFunctionType.k_Vertex){
				pTypeContainer = this._pComplexTypeContainerV;
				pUniformContainer = this._pUniformContainerV;
				pGlobalContainer = this._pGlobalContainerV;
				pSharedContainer = this._pSharedContainerV;
				pUsedFunctions = this._pUsedFunctionListV;
				pAttributeContainer = this._pAttributeContainerV;
			}
			else if(eType === EFunctionType.k_Pixel){
				pTypeContainer = this._pComplexTypeContainerP;
				pUniformContainer = this._pUniformContainerP;
				pGlobalContainer = this._pGlobalContainerP;
				pSharedContainer = this._pSharedContainerP;
				pUsedFunctions = this._pUsedFunctionListP;
			}

			if (!pTypeContainer.addFromVarConatiner(pUniformContainer) ||
				!pTypeContainer.addFromVarConatiner(pGlobalContainer) ||
				!pTypeContainer.addFromVarConatiner(pSharedContainer) ||
				!pTypeContainer.addFromVarConatiner(pAttributeContainer)){
				return false;
			}

// if(eType === EFunctionType.k_Vertex){
// 	pTypeContainer.addComplexType(this._pVertexOutType);
// }

			for(var i:  number  = 0; i < pUsedFunctions.length; i++){
				var pReturnBaseType: IAFXTypeInstruction = pUsedFunctions[i].getReturnType().getBaseType();
				if(pReturnBaseType.isComplex()){
					if(!pTypeContainer.addComplexType(pReturnBaseType)){
						return false;
					}
				}
			}

			return true;
		}

		private  /**@inline*/  hasUniformWithName(sName: string): bool {
			return this._pUniformContainerV.hasVariableWithName(sName) ||
				   this._pUniformContainerP.hasVariableWithName(sName);
		}

		private  /**@inline*/  hasUniformWithNameIndex(iNameIndex:  number ): bool {
			return this._pUniformContainerV.hasVariableWithNameIndex(iNameIndex) ||
				   this._pUniformContainerP.hasVariableWithNameIndex(iNameIndex);
		}

// private inline hasUniform(pVar: IAFXVariableDeclInstruction): bool {
// 	return this.hasUniformWithName(pVar.getRealName());
// }

// private inline getUniformByName(sName: string): IAFXVariableDeclInstruction {
// 	return this._pUniformContainerV.getVariableByName(sName) ||
// 		   this._pUniformContainerP.getVariableByName(sName);
// }

		private prepareForeigns(pPassInput: IAFXPassInputBlend):  number  {
			var iPassInputId:  number  = pPassInput.getGuid();
			var pForignsHashEntry: IHashEntry = this._pPassInputForeignsHashMap[iPassInputId];

			if(isDef(pForignsHashEntry) && pForignsHashEntry.modifyMark === pPassInput.statesInfo.foreignKey){
				return pForignsHashEntry.hash;
			}
			else {
				var pForeignValues: any = pPassInput.foreigns;
				var sHash: string = "";
				var pVarInfoList: fx.IVariableBlendInfo[] = this._pForeignContainerV.varsInfo;

				for(var i:  number  = 0; i < pVarInfoList.length; i++){
					sHash += pForeignValues[pVarInfoList[i].nameIndex].toString() + "%";
				}

				pVarInfoList = this._pForeignContainerP.varsInfo;

				for(var i:  number  = 0; i < pVarInfoList.length; i++){
					sHash += pForeignValues[pVarInfoList[i].nameIndex].toString() + "%";
				}

				if(!isDef(pForignsHashEntry)){
					pForignsHashEntry = <IHashEntry>{
						hash: 0,
						modifyMark: 0
					};

					this._pPassInputForeignsHashMap[iPassInputId] = pForignsHashEntry;
				}

				pForignsHashEntry.hash = PassBlend.hashMinifier.minify(sHash);
				pForignsHashEntry.modifyMark = pPassInput.statesInfo.foreignKey;

				return pForignsHashEntry.hash;
			}
		}

		private prepareSamplers(pPassInput: IAFXPassInputBlend, isForce: bool):  number  {
			this._isSamplersPrepared = false;

			var iPassInputId:  number  = pPassInput.getGuid();
			var pSamplersHashEntry: IHashEntry = this._pPassInputSamplersHashMap[iPassInputId];

			if (!isForce &&
				isDef(pSamplersHashEntry) && pSamplersHashEntry.modifyMark === pPassInput.statesInfo.samplerKey) {
				return pSamplersHashEntry.hash;
			}

			var pBlender: SamplerBlender = this._pDefaultSamplerBlender;
			pBlender.clear();
//Gum samplers

			var pSamplers: IAFXSamplerStateMap = pPassInput.samplers;
			var pSamplersId:  number [] = this._pSamplerIdList;

			for(var i:  number  = 0; i < pSamplersId.length; i++){
				var pSampler: IAFXVariableDeclInstruction = this._pSamplerByIdMap[pSamplersId[i]];
				var iNameIndex:  number  = pSampler._getNameIndex();

				var pSamplerState: IAFXSamplerState = pSamplers[iNameIndex];
				var pTexture: ITexture = pPassInput._getTextureForSamplerState(pSamplerState);

				if(isNull(pTexture)){
					pBlender.addObjectToSlotById(pSampler,  0 );
				}
				else {
					pBlender.addTextureSlot(pTexture.getGuid());
					pBlender.addObjectToSlotById(pSampler, pTexture.getGuid());
				}
			}

//Gum sampler arrays
			var pSamplerArrays: IAFXSamplerStateListMap = pPassInput.samplerArrays;
			var pSamplerArraysId:  number [] = this._pSamplerArrayIdList;

			for(var i:  number  = 0; i < pSamplerArraysId.length; i++){
				var pSamplerArray: IAFXVariableDeclInstruction = this._pSamplerArrayByIdMap[pSamplerArraysId[i]];
				var iNameIndex:  number  = pSamplerArray._getNameIndex();

				var pSamplerStateList: IAFXSamplerState[] = pSamplerArrays[iNameIndex];
				var isNeedToCollapse: bool = true;
				var pTexture: ITexture = null;
				var iLength:  number  = pPassInput.samplerArrayLength[iNameIndex];

				for(var j:  number  = 0; j < iLength; j++) {
					if(j === 0) {
						pTexture = pPassInput._getTextureForSamplerState(pSamplerStateList[j]);
					}
					else {
						if(pTexture !== pPassInput._getTextureForSamplerState(pSamplerStateList[j])){
							isNeedToCollapse = false;
						}
					}
				}

				if(isNeedToCollapse){
					pSamplerArray._setCollapsed(true);

					if(isNull(pTexture)){
						pBlender.addObjectToSlotById(pSamplerArray,  0 );
					}
					else {
						pBlender.addTextureSlot(pTexture.getGuid());
						pBlender.addObjectToSlotById(pSamplerArray, pTexture.getGuid());
					}
				}
				else {
					pSamplerArray._setCollapsed(false);
				}
			}

			this._isSamplersPrepared = true;

			if(!isDef(pSamplersHashEntry)){
				pSamplersHashEntry = <IHashEntry>{
					hash: 0,
					modifyMark: 0
				};

				this._pPassInputSamplersHashMap[iPassInputId] = pSamplersHashEntry;
			}

			pSamplersHashEntry.hash =  PassBlend.hashMinifier.minify(pBlender.getHash());
			pSamplersHashEntry.modifyMark = pPassInput.statesInfo.samplerKey;

			return pSamplersHashEntry.hash;
		}

		private  /**@inline*/  prepareSurfaceMaterial(pMaterial: ISurfaceMaterial, isForce: bool):  number  {
			this._isSurfaceMaterialPrepared = false;

			if(isNull(pMaterial)){
				return 0;
			}

			var iMaterialId:  number  = pMaterial.getGuid();
			var pMaterialHashEntry: IHashEntry = this._pSurfaceMaterialHashMap[iMaterialId];
			if(isDef(pMaterialHashEntry) && pMaterialHashEntry.modifyMark === pMaterial.totalUpdatesOfTexcoords){
				return pMaterialHashEntry.hash;
			}
			else {
				var sMaterailHash: string = "";
				for(var i:  number  = 0; i < core.pool.resources.SurfaceMaterial.MAX_TEXTURES_PER_SURFACE; i++){
					var iTexcoord:  number  = pMaterial.texcoord(i);

					if(i !== iTexcoord){
						sMaterailHash += i.toString() + "<" + iTexcoord.toString() + ".";
					}
				}

				var iMaterialHash:  number  = PassBlend.hashMinifier.minify(sMaterailHash);

				if(!isDef(pMaterialHashEntry)){
					pMaterialHashEntry = <IHashEntry>{
						hash: 0,
						modifyMark: 0
					};

					this._pSurfaceMaterialHashMap[iMaterialId] = pMaterialHashEntry;
				}

				pMaterialHashEntry.hash = iMaterialHash;
				pMaterialHashEntry.modifyMark = pMaterial.totalUpdatesOfTexcoords;

				return iMaterialHash;
			}
		}

		private prepareBufferMap(pMap: IBufferMap, isForce: bool):  number  {
			this._isBufferMapPrepared = false;

			var iBufferMapHash:  number  = 0;

			var iBufferMapId:  number  = pMap.getGuid();
			var pBufferMapHashEntry: IHashEntry = this._pBufferMapHashMap[iBufferMapId];

			if (!isForce &&
				isDef(pBufferMapHashEntry) && pBufferMapHashEntry.modifyMark === pMap.totalUpdates) {
				iBufferMapHash = pBufferMapHashEntry.hash;
			}
			else {
				this._pAttributeContainerV.initFromBufferMap(<util.BufferMap>pMap);
				iBufferMapHash = PassBlend.hashMinifier.minify(this._pAttributeContainerV.getHash());

				this._isBufferMapPrepared = true;

				if(!isDef(pBufferMapHashEntry)){
					pBufferMapHashEntry = <IHashEntry>{
						hash: 0,
						modifyMark: 0
					};

					this._pBufferMapHashMap[iBufferMapId] = pBufferMapHashEntry;
				}

				pBufferMapHashEntry.modifyMark = pMap.totalUpdates;
				pBufferMapHashEntry.hash = iBufferMapHash;
			}

			return iBufferMapHash;
		}

		private  /**@inline*/  swapTexcoords(pMaterial: ISurfaceMaterial): void {
			this._pTexcoordSwapper.generateSwapCode(<core.pool.resources.SurfaceMaterial>pMaterial,
													this._pAttributeContainerV);
		}

		private isSamplerUsedInShader(pSampler: IAFXVariableDeclInstruction, eType: EFunctionType): bool{
			return (eType === EFunctionType.k_Vertex && this._pUniformContainerV.hasVariable(pSampler)) ||
				   (eType === EFunctionType.k_Pixel && this._pUniformContainerP.hasVariable(pSampler));
		}

		private applyForeigns(pPassInput: IAFXPassInputBlend): void {
			var pForeignValues: any = pPassInput.foreigns;
			var pKeys:  number [] = pPassInput.foreignKeys;

			var pForeignsV = this._pForeignContainerV;
			var pForeignsP = this._pForeignContainerP;

			for(var i:  number  = 0; i < pKeys.length; i++){
				var iNameIndex:  number  = pKeys[i];
				var pVarList: IAFXVariableDeclInstruction[] = null;
				var iVarBlendIndex:  number  = 0;

				iVarBlendIndex = pForeignsV.getKeyIndexByNameIndex(iNameIndex);
				if(iVarBlendIndex !== -1){
					pVarList = pForeignsV.getVarList(iVarBlendIndex);

					for(var j:  number  = 0; j < pVarList.length; j++){
						pVarList[j].setValue(pForeignValues[iNameIndex] || 1);
					}
				}

				iVarBlendIndex = pForeignsP.getKeyIndexByNameIndex(iNameIndex);
				if(iVarBlendIndex !== -1){
					pVarList = pForeignsP.getVarList(iVarBlendIndex);

					for(var j:  number  = 0; j < pVarList.length; j++){
						pVarList[j].setValue(pForeignValues[iNameIndex] || 1);
					}
				}
			}
		}

		private resetForeigns(): void {
			var pForeignsV = this._pForeignContainerV;
			var pForeignsP = this._pForeignContainerP;

			var pVarInfoList: fx.IVariableBlendInfo[] = pForeignsV.varsInfo;

			for(var i:  number  = 0; i < pVarInfoList.length; i++){
				var pVarInfo: fx.IVariableBlendInfo = pVarInfoList[i];
				var pVarList: IAFXVariableDeclInstruction[] = pVarInfo.varList;

				for(var j:  number  = 0; j < pVarList.length; j++){
					pVarList[j].setRealName(pVarInfo.name);
				}
			}

			var pVarInfoList: fx.IVariableBlendInfo[] = pForeignsP.varsInfo;

			for(var i:  number  = 0; i < pVarInfoList.length; i++){
				var pVarInfo: fx.IVariableBlendInfo = pVarInfoList[i];
				var pVarList: IAFXVariableDeclInstruction[] = pVarInfo.varList;

				for(var j:  number  = 0; j < pVarList.length; j++){
					pVarList[j].setRealName(pVarInfo.name);
				}
			}
		}

		private  /**@inline*/  generateShaderCode(): void {
			this.clearCodeFragments();
			this.reduceSamplers();
			this.reduceAttributes();

			this._sVertexCode = this.generateCodeForVertex();
			this._sPixelCode = this.generateCodeForPixel();

			this.resetSamplerVarsToDefault();
		}

		private generateCodeForVertex(): string {
			var sCode: string = "";
			var eType: EFunctionType = EFunctionType.k_Vertex;


			sCode = this.generateSystemExtBlock(eType) + "\n" +

					this.generateTypeDels(eType) + "\n" +
					this.generateFunctionDefenitions(eType) + "\n" +

					this.generateSharedVars(eType) + "\n" +

					this.generateVertexOut() + "\n";

			this.enableVaringPrefixes(eType, true);
			sCode += this.generateVaryings(eType) + "\n";
			this.enableVaringPrefixes(eType, false);

			sCode += this.generateUniformSamplers(eType) + "\n" +
					this.generateUniformVars(eType) + "\n" +
					this.generateAttrBuffers() + "\n" +

					this.generateGlobalVars(eType) + "\n" +
					this.generateFunctions(eType) + "\n" +

					this.generateRealAttrs() + "\n" +
					this.generateAFXAttrs() + "\n" +

					this.generatePassFunctions(eType) + "\n" +

					"void main() {\n" +

					this.generateAttrBufferInit() + "\n" +
					this.generateAFXAttrInit() + "\n" +

					this.generateTexcoordSwap() + "\n" +

					this.generatePassFunctionCall(eType) + "\n" +

					this.generateVertexOutToVaryings() + "\n" +

					"}";

			return sCode;
		}

		private generateCodeForPixel(): string {
			if(this._hasEmptyPixel){
				return "void main(){}";
			}

			var sCode: string = "";
			var eType: EFunctionType = EFunctionType.k_Pixel;


			this.enableVaringPrefixes(eType, true);

			sCode = this.generateSystemExtBlock(eType) + "\n" +

					"vec4 resultAFXColor;" + "\n" +

					this.generateTypeDels(eType) + "\n" +
					this.generateFunctionDefenitions(eType) + "\n" +

					this.generateSharedVars(eType) + "\n" +

					this.generateVaryings(eType) + "\n" +

					this.generateUniformSamplers(eType) + "\n" +
					this.generateUniformVars(eType) + "\n" +

					this.generateGlobalVars(eType) + "\n" +
					this.generateFunctions(eType) + "\n" +

					this.generatePassFunctions(eType) + "\n" +

					"void main() {\n" +

					this.generatePassFunctionCall(eType) + "\n" +

					"gl_FragColor = resultAFXColor;" + "\n" +
					"}";
			this.enableVaringPrefixes(eType, false);

			return sCode;
		}

		private clearCodeFragments(): void {
			this._sUniformSamplerCodeV = "";

			this._sAttrBufferDeclCode = "";
			this._sAttrDeclCode = "";
			this._sAFXAttrDeclCode = "";
			this._sAttrBufferInitCode = "";
			this._sAFXAttrInitCode = "";

			this._sUniformSamplerCodeP = "";
		}

		private reduceSamplers(): void {
			var pSamplerBlender: SamplerBlender = this._pDefaultSamplerBlender;
			var iTotalSlots:  number  = pSamplerBlender.totalActiveSlots;

			var sUniformSamplerCodeV: string = "";
			var sUniformSamplerCodeP: string = "";

			var isZeroSampler2DV: bool = false;
			var isZeroSamplerCubeV: bool = false;
			var isZeroSampler2DP: bool = false;
			var isZeroSamplerCubeP: bool = false;

			var isInVertex: bool = false;
			var isInPixel: bool = false;

			var sSamplerName: string = "";

			for(var i:  number  = 0; i < iTotalSlots; i++){
				var pSamplers: util.ObjectArray = pSamplerBlender.getSamplersBySlot(i);

				isInVertex = false;
				isInPixel = false;

				sSamplerName = "as" + i.toString();

				for (var j:  number  = 0; j < pSamplers.length; j++) {
					var pSampler: IAFXVariableDeclInstruction = pSamplers.value(j);
					var iNameIndex:  number  = pSampler._getNameIndex();
					var iIndexForSamplerV:  number  = this._pUniformContainerV.getKeyIndexByNameIndex(iNameIndex);
					var iIndexForSamplerP:  number  = this._pUniformContainerP.getKeyIndexByNameIndex(iNameIndex);

					if(i ===  0 ){
						if(iIndexForSamplerV !== -1){
							this._pUniformContainerV.forEach(iIndexForSamplerV, PassBlend.fnSamplerReducer);

							if(pSampler.getType().isSampler2D()) {
								isZeroSampler2DV = true;
							}
							else {
								isZeroSamplerCubeV = true;
								sSamplerName = "asc0";
							}
						}

						if(iIndexForSamplerP !== -1){
							this._pUniformContainerP.forEach(iIndexForSamplerP, PassBlend.fnSamplerReducer);

							if(pSampler.getType().isSampler2D()) {
								isZeroSampler2DP = true;
							}
							else {
								isZeroSamplerCubeP = true;
								sSamplerName = "asc0";
							}
						}
					}
					else{
						if(iIndexForSamplerV !== -1){
							isInVertex = true;
						}
						if(iIndexForSamplerP !== -1){
							isInPixel = true;
						}
					}

					this._pUniformContainerV.setNameForEach(iIndexForSamplerV, sSamplerName);
					this._pUniformContainerP.setNameForEach(iIndexForSamplerP, sSamplerName);
				}


				if(i ===  0 ){
					if(isZeroSampler2DV){
						sUniformSamplerCodeV += "uniform sampler2D as0;";
					}
					if(isZeroSamplerCubeV){
						sUniformSamplerCodeV += "uniform samplerCube asc0;"
					}
					if(isZeroSampler2DP){
						sUniformSamplerCodeP += "uniform sampler2D as0;";
					}
					if(isZeroSamplerCubeP){
						sUniformSamplerCodeP += "uniform samplerCube asc0;"
					}
				}
				else {
					if(isInVertex){
						sUniformSamplerCodeV += "uniform " + pSamplers.value(0).getType().getBaseType().getRealName() + " " + sSamplerName + ";";
					}

					if(isInPixel){
						sUniformSamplerCodeP += "uniform " + pSamplers.value(0).getType().getBaseType().getRealName() + " " + sSamplerName + ";";
					}
				}
			}


			this._sUniformSamplerCodeV = sUniformSamplerCodeV;
			this._sUniformSamplerCodeP = sUniformSamplerCodeP;
		}

		private resetSamplerVarsToDefault(): void {
			var pSamplerBlender: SamplerBlender = this._pDefaultSamplerBlender;
			var iTotalSlots:  number  = pSamplerBlender.totalActiveSlots;

			pSamplerBlender.clearSamplerNames();
// for(var i: uint = 0; i < iTotalSlots; i++){
// 	var pSamplers: util.ObjectArray = pSamplerBlender.getSamplersBySlot(i);

// 	for (var j: int = 0; j < pSamplers.length; j++) {
// 		var pSampler: IAFXVariableDeclInstruction = pSamplers.value(j);
// 		var iNameIndex: uint = pSampler._getNameIndex();

// 		var iIndexForSamplerV: int = this._pUniformContainerV.getKeyIndexByNameIndex(iNameIndex);
// 		var iIndexForSamplerP: int = this._pUniformContainerP.getKeyIndexByNameIndex(iNameIndex);

// 		this._pUniformContainerV.forEach(iIndexForSamplerV, PassBlend.fnResetDefaultSamplerParams);
// 		this._pUniformContainerV.forEach(iIndexForSamplerP, PassBlend.fnResetDefaultSamplerParams);
// 	}
// }
		}

		static private fnSamplerReducer(pSamplerVar: IAFXVariableDeclInstruction): void {
			pSamplerVar.defineByZero(true);
		}

// static private fnResetDefaultSamplerParams(pSamplerVar: IAFXVariableDeclInstruction): void {
// 	pSamplerVar.defineByZero(false);
// 	pSamplerVar.setRealName(pSamplerVar.getSemantic() || pSamplerVar.getName());
// }

		private reduceAttributes(): void {
			var pAttributeContainer: AttributeBlendContainer = this._pAttributeContainerV;
			var pAttrInfoList: fx.IVariableBlendInfo[] = pAttributeContainer.attrsInfo;

			var nPreparedBufferSlots:  number  = -1;
			var nPreparedAttributeSlots:  number  = -1;

			for(var i:  number  = 0; i < pAttrInfoList.length; i++) {
				var iSemanticIndex:  number  = i;
				var pAttrInfo: fx.IVariableBlendInfo = pAttrInfoList[iSemanticIndex];
				var pAttributes: IAFXVariableDeclInstruction[] = pAttributeContainer.getAttributeListBySemanticIndex(iSemanticIndex);
				var iSlot:  number  = pAttributeContainer.getSlotBySemanticIndex(iSemanticIndex);
				var iBufferSlot:  number  = -1;
				var sAttrName: string = "";

//1) set buffer maps for shader attribures
				if(iSlot === -1) {
					for(var j:  number  = 0; j < pAttributes.length; j++){
						if(pAttributes[j].getType().isStrictPointer()){
							pAttributes[j].getType().getVideoBuffer().defineByZero(true);
						}
					}
				}
				else {
					iBufferSlot = pAttributeContainer.getBufferSlotBySemanticIndex(iSemanticIndex);

					sAttrName = "aa" + iSlot.toString();

					if(iBufferSlot >= 0){
						var sSamplerBufferName: string = "abs" + iBufferSlot.toString();
						var sHeaderBufferName: string = "abh" + iBufferSlot.toString();

						var pBufferVar: IAFXVariableDeclInstruction = null;

						for(var j:  number  = 0; j < pAttributes.length; j++){
							pBufferVar = pAttributes[j].getType().getVideoBuffer();
							pBufferVar.setVideoBufferRealName(sSamplerBufferName, sHeaderBufferName);
						}

						if(iBufferSlot > nPreparedBufferSlots) {
							var pBufferVar: IAFXVariableDeclInstruction =  pAttributes[0].getType().getVideoBuffer();
							this._sAttrBufferDeclCode = pBufferVar.toFinalCode() + ";\n";
							this._sAttrBufferInitCode = pBufferVar._getVideoBufferInitExpr().toFinalCode() + ";\n";
							nPreparedBufferSlots++;
						}
					}

//2) gnerate real attrs
					if(iSlot > nPreparedAttributeSlots){
						this._sAttrDeclCode += "attribute " +
							pAttributeContainer.getTypeForShaderAttributeBySemanticIndex(iSemanticIndex).toFinalCode() + " " +
							sAttrName + ";\n";
						nPreparedAttributeSlots++;
					}
				}

// 3) add afx attributes 
				var pAttribute: IAFXVariableDeclInstruction = pAttributeContainer.getAttributeBySemanticIndex(iSemanticIndex);
				var pAttributeType: IAFXVariableTypeInstruction = pAttribute.getType();

				this._sAFXAttrDeclCode += pAttribute.toFinalCode() + ";\n";

				if (pAttributeType.isStrictPointer() ||
					(pAttributeType.isPointer() && iBufferSlot >= 0)){

					var pAttrSubDecls: IAFXVariableDeclInstruction[] = pAttribute.getSubVarDecls();

					for(var j:  number  = 0; j < pAttrSubDecls.length; j++){
						this._sAFXAttrDeclCode += pAttrSubDecls[j].toFinalCode() + ";\n";
					}
				}

				if(iSlot >= 0){
					if(iBufferSlot >= 0){
						this._sAFXAttrInitCode += pAttributeType._getMainPointer().getRealName() + "=" + sAttrName + ";";
						this._sAFXAttrInitCode += pAttribute._getAttrExtractionBlock().toFinalCode();
					}
					else {
						this._sAFXAttrInitCode += pAttribute.getRealName() + "=" + sAttrName + ";";
					}
				}
			}
		}

		private generateSystemExtBlock(eType: EFunctionType): string {
			var pExtBlock: ExtSystemDataContainer = null;

			if(eType === EFunctionType.k_Vertex){
				pExtBlock = this._pExtSystemDataV;
				if(this._sSystemExtBlockCodeV !== ""){
					return this._sSystemExtBlockCodeV;
				}
			}
			else {
				pExtBlock = this._pExtSystemDataP;
				if(this._sSystemExtBlockCodeP !== ""){
					return this._sSystemExtBlockCodeP;
				}
			}

			var sCode: string = "";

			var pMacroses = pExtBlock.macroses;
			var pTypes = pExtBlock.types;
			var pFunctions = pExtBlock.functions;

			for(var i:  number  = 0; i < pMacroses.length; i++){
				sCode += pMacroses[i].toFinalCode() + "\n";
			}

			for(var i:  number  = 0; i < pTypes.length; i++){
				sCode += pTypes[i].toFinalCode() + "\n";
			}

			for(var i:  number  = 0; i < pFunctions.length; i++){
				sCode += pFunctions[i].toFinalCode() + "\n";
			}


			if(eType === EFunctionType.k_Vertex){
				this._sSystemExtBlockCodeV = sCode;
			}
			else {
				sCode = "#define AKRA_FRAGMENT 1\n" +
						"#ifdef GL_ES\nprecision highp float;\n#endif\n" +
						"#extension GL_OES_standard_derivatives : enable\n"
						sCode;
				this._sSystemExtBlockCodeP = sCode;
			}

			return sCode;
		}

		private generateTypeDels(eType: EFunctionType): string {
			var pTypeBlock: ComplexTypeBlendContainer = null;

			if(eType === EFunctionType.k_Vertex){
				pTypeBlock = this._pComplexTypeContainerV;
			}
			else {
				pTypeBlock = this._pComplexTypeContainerP;
			}

			var sCode: string = "";

			var pKeys = pTypeBlock.keys;
			var pTypes = pTypeBlock.types;

			for(var i:  number  = 0; i < pKeys.length; i++){
				sCode += pTypes[pKeys[i]]._toDeclString() + ";\n";
			}

			return sCode;
		}

		private generateFunctionDefenitions(eType: EFunctionType): string {
			var pFunctions: IAFXFunctionDeclInstruction[] = null;

			if(eType === EFunctionType.k_Vertex){
				pFunctions = this._pUsedFunctionListV;
				if(this._sFunctionDefCodeV !== ""){
					return this._sFunctionDefCodeV;
				}
			}
			else {
				pFunctions = this._pUsedFunctionListP;
				if(this._sFunctionDefCodeP !== ""){
					return this._sFunctionDefCodeP;
				}
			}

			var sCode: string = "";

			for(var i:  number  = 0; i < pFunctions.length; i++){
				sCode += pFunctions[i].toFinalDefCode() + ";\n";
			}

			if(eType === EFunctionType.k_Vertex){
				this._sFunctionDefCodeV = sCode;
			}
			else {
				this._sFunctionDefCodeP = sCode;
			}

			return sCode;
		}

		private generateSharedVars(eType: EFunctionType): string {
			var pVars: VariableBlendContainer = null;

			if(eType === EFunctionType.k_Vertex){
				pVars = this._pSharedContainerV;
				if(this._sSharedVarCodeV !== ""){
					return this._sSharedVarCodeV;
				}
			}
			else {
				pVars = this._pSharedContainerP;
				if(this._sSharedVarCodeP !== ""){
					return this._sSharedVarCodeP;
				}
			}

			var sCode: string = "";
			var pVarInfoList: fx.IVariableBlendInfo[] = pVars.varsInfo;

			for(var i:  number  = 0; i < pVarInfoList.length; i++){
				sCode += pVars.getDeclCodeForVar(i, true) + ";\n";
			}

			if(eType === EFunctionType.k_Vertex){
				this._sSharedVarCodeV = sCode;
			}
			else {
				this._sSharedVarCodeP = sCode;
			}

			return sCode;
		}

		private generateVertexOut(): string {
			if(this._sVertexOutDeclCode === ""){
				this._sVertexOutDeclCode = this._pVertexOutType._toDeclString() + " Out;\n";
			}

			return this._sVertexOutDeclCode;
		}

		private generateVaryings(eType: EFunctionType): string {
			var pVars: VariableBlendContainer = null;

			if(eType === EFunctionType.k_Vertex){
				pVars = this._pVaryingContainerV;

				if(this._sVaryingDeclCodeV !== ""){
					return this._sVaryingDeclCodeV;
				}
			}
			else {
				pVars = this._pVaryingContainerP;
				if(this._sVaryingDeclCodeP !== ""){
					return this._sVaryingDeclCodeP;
				}
			}

			var sCode: string = "";
			var pVarInfoList: fx.IVariableBlendInfo[] = pVars.varsInfo;

			for (var i:  number  = 0; i < pVarInfoList.length; i++) {
				sCode += "varying " + pVars.getDeclCodeForVar(i, false) + ";\n";
			}

			if(eType === EFunctionType.k_Vertex){
				this._sVaryingDeclCodeV = sCode;
			}
			else {
				this._sVaryingDeclCodeP = sCode;
			}

			return sCode;
		}

		private generateUniformSamplers(eType: EFunctionType): string {
			if(eType === EFunctionType.k_Vertex){
				return this._sUniformSamplerCodeV;
			}
			else {
				return this._sUniformSamplerCodeP;
			}
		}

		private generateUniformVars(eType: EFunctionType): string {
			var pVars: VariableBlendContainer = null;

			if(eType === EFunctionType.k_Vertex){
				pVars = this._pUniformContainerV;
			}
			else {
				pVars = this._pUniformContainerP;
			}

			var sCode: string = "";
			var pVarInfoList: fx.IVariableBlendInfo[] = pVars.varsInfo;

			for(var i:  number  = 0; i < pVarInfoList.length; i++){
				var pVar: IAFXVariableDeclInstruction = pVars.getVariable(i);
				var pType: IAFXVariableTypeInstruction = pVars.getBlendType(i);

				if (pType.isSampler() &&
					(!pType.isArray() || pVar.isDefinedByZero() || pVar._isCollapsed())){
					continue;
				}

				sCode += "uniform " + pVars.getDeclCodeForVar(i, false) + ";\n";
			}

			return sCode;
		}

		private  /**@inline*/  generateAttrBuffers(): string {
			return this._sAttrBufferDeclCode;
		}

		private generateGlobalVars(eType: EFunctionType): string {
			var pVars: VariableBlendContainer = null;

			if(eType === EFunctionType.k_Vertex){
				pVars = this._pGlobalContainerV;
			}
			else {
				pVars = this._pGlobalContainerP;
			}

			var sCode: string = "";
			var pVarInfoList: fx.IVariableBlendInfo[] = pVars.varsInfo;

			for(var i:  number  = 0; i < pVarInfoList.length; i++){
				sCode += pVars.getDeclCodeForVar(i, true) + ";\n";
			}

			return sCode;
		}

		private generateFunctions(eType: EFunctionType): string {
			var pFunctions: IAFXFunctionDeclInstruction[] = null;

			if(eType === EFunctionType.k_Vertex){
				pFunctions = this._pUsedFunctionListV;
			}
			else {
				pFunctions = this._pUsedFunctionListP;
			}

			var sCode: string = "";

			for(var i:  number  = 0; i < pFunctions.length; i++){
				sCode += pFunctions[i].toFinalCode() + "\n";
			}

			return sCode;
		}

		private generatePassFunctions(eType: EFunctionType): string {
			var pFunctions: IAFXFunctionDeclInstruction[] = null;

			if(eType === EFunctionType.k_Vertex){
				pFunctions = this._pPassFunctionListV;
			}
			else {
				pFunctions = this._pPassFunctionListP;
			}

			var sCode: string = "";

			for(var i:  number  = 0; i < pFunctions.length; i++){
				sCode += pFunctions[i].toFinalCode() + "\n";
			}

			return sCode;
		}

		private  /**@inline*/  generateRealAttrs(): string {
			return this._sAttrDeclCode;
		}


		private  /**@inline*/  generateAFXAttrs(): string {
			return this._sAFXAttrDeclCode;
		}

		private  /**@inline*/  generateAttrBufferInit(): string {
			return this._sAttrBufferInitCode;
		}

		private  /**@inline*/  generateAFXAttrInit(): string {
			return this._sAFXAttrInitCode;
		}

		private  /**@inline*/  generateTexcoordSwap(): string {
			return this._pTexcoordSwapper.getTmpDeclCode() + "\n" +
				   this._pTexcoordSwapper.getTecoordSwapCode();
		}

		private  /**@inline*/  generatePassFunctionCall(eType: EFunctionType): string {
			var pFunctions: IAFXFunctionDeclInstruction[] = null;

			if(eType === EFunctionType.k_Vertex){
				pFunctions = this._pPassFunctionListV;
				if(this._sPassFunctionCallCodeV !== ""){
					return this._sPassFunctionCallCodeV;
				}
			}
			else {
				pFunctions = this._pPassFunctionListP;
				if(this._sPassFunctionCallCodeP !== ""){
					return this._sPassFunctionCallCodeP;
				}
			}

			var sCode = "";

			for(var i:  number  = 0; i < pFunctions.length; i++){
				sCode += pFunctions[i].getRealName() + "();\n";
			}

			if(eType === EFunctionType.k_Vertex){
				this._sPassFunctionCallCodeV = sCode;
			}
			else {
				this._sPassFunctionCallCodeP = sCode;
			}

			return sCode;
		}


		private generateVertexOutToVaryings(): string {
			if(this._sVertexOutToVaryingCode !== ""){
				return this._sVertexOutToVaryingCode;
			}

			var pVars: VariableBlendContainer = this._pVaryingContainerV;
			var pVarInfoList: fx.IVariableBlendInfo[] = pVars.varsInfo;
			var sCode: string = "";

			sCode += "gl_Position=Out.POSITION;\ngl_PointSize=Out.PSIZE;\n";
			for(var i:  number  = 0; i < pVarInfoList.length; i++) {
				var sName: string = pVarInfoList[i].name;
				if(sName !== "POSITION" && sName !== "PSIZE"){
					sCode += "V_"+sName + "=" + "Out." + sName + ";\n";
				}
			}

			this._sVertexOutToVaryingCode = sCode;
			return this._sVertexOutToVaryingCode;
		}


		private prepareFastObjects(): void {
			this.prepareFastSamplers(EFunctionType.k_Vertex);
			this.prepareFastSamplers(EFunctionType.k_Pixel);
		}

		private prepareFastSamplers(eType: EFunctionType): void {
			if(isNull(this._pSamplerByIdMap)){
				this._pSamplerByIdMap = <IAFXVariableDeclMap>{};
				this._pSamplerIdList = [];

				this._pSamplerArrayByIdMap = <IAFXVariableDeclMap>{};
				this._pSamplerArrayIdList = [];
			}

			var pContainer: VariableBlendContainer = eType === EFunctionType.k_Vertex ?
														this._pUniformContainerV : this._pUniformContainerP;
			var pVarInfoList: fx.IVariableBlendInfo[] = pContainer.varsInfo;

			for(var i:  number  = 0; i < pVarInfoList.length; i++) {
				var pVar: IAFXVariableDeclInstruction = pContainer.getVariable(i);

				if(pVar.getType().isSampler()) {
					var id:  number  = pVar._getInstructionID();

					if(!pVar.getType().isArray() && !isDef(this._pSamplerByIdMap[id])){
						this._pSamplerByIdMap[id] = pVar;
						this._pSamplerIdList.push(id);
					}
					else if(pVar.getType().isArray() && !isDef(this._pSamplerArrayByIdMap[id])) {
						this._pSamplerArrayByIdMap[id] = pVar;
						this._pSamplerArrayIdList.push(id);
					}
				}
			}

		}
	}
}



























module akra.fx {

	export interface IVariableInfoMap {
		[index:  number ]: IAFXVariableInfo;
	}

	export class VariableContainer implements IAFXVariableContainer {
		private _pNameToIndexMap: IntMap = null;
		private _pRealNameToIndexMap: IntMap = null;
		private _pIndexList:  number [] = null;
		private _pVariableInfoMap: IVariableInfoMap = null;

		private _bLock: bool = false;

		constructor(){
			this._pNameToIndexMap = <IntMap>{};
			this._pRealNameToIndexMap = <IntMap>{};
			this._pVariableInfoMap = <IVariableInfoMap>{};
		}

		/**@inline*/  get indices():  number [] {
			return this._pIndexList;
		}

		add(pVar: IAFXVariableDeclInstruction): void {
			if(this._bLock){
				return;
			}

			var iIndex:  number  = pVar._getNameIndex();
			var sName: string = pVar.getName();
			var sRealName: string = pVar.getRealName();

			this._pNameToIndexMap[sName] = iIndex;
			this._pRealNameToIndexMap[sRealName] = iIndex;
			this._pVariableInfoMap[iIndex] = <IAFXVariableInfo>{
				variable: pVar,
				type: VariableContainer.getVariableType(pVar),
				name: sName,
				realName: sRealName,
				isArray: pVar.getType().isNotBaseArray(),
			};
		}

		addSystemEntry(sName: string, eType: EAFXShaderVariableType): void {
			var iIndex:  number  = fx.VariableDeclInstruction.pShaderVarNamesGlobalDictionary.add(sName);

			this._pNameToIndexMap[sName] = iIndex;
			this._pRealNameToIndexMap[sName] = iIndex;
			this._pVariableInfoMap[iIndex] = <IAFXVariableInfo>{
				variable: null,
				type: eType,
				name: sName,
				realName: sName,
				isArray: false
			};
		}

		finalize(): void {
			var pTmpKeys: string[] = Object.keys(this._pVariableInfoMap);
			this._pIndexList = new Array(pTmpKeys.length);

			for(var i:  number  = 0; i < pTmpKeys.length; i++){
				this._pIndexList[i] = +pTmpKeys[i];
			}
			this._pIndexList.sort(fnSortMinMax);
			this._bLock = true;
		}

		/**@inline*/  getVarInfoByIndex(iIndex:  number ): IAFXVariableInfo {
			return this._pVariableInfoMap[iIndex];
		}

		/**@inline*/  getVarByIndex(iIndex:  number ): IAFXVariableDeclInstruction {
			return this.getVarInfoByIndex(iIndex).variable;
		}

		/**@inline*/  getTypeByIndex(iIndex:  number ): EAFXShaderVariableType {
			return this.getVarInfoByIndex(iIndex).type;
		}

		/**@inline*/  isArrayVariable(iIndex:  number ): bool {
			return this.getVarInfoByIndex(iIndex).isArray;
		}

		/**@inline*/  getIndexByName(sName: string):  number  {
			return this._pNameToIndexMap[sName] || (this._pNameToIndexMap[sName] = 0);
		}

		/**@inline*/  getIndexByRealName(sName: string):  number  {
			return this._pRealNameToIndexMap[sName] || (this._pRealNameToIndexMap[sName] = 0);
		}

		/**@inline*/  hasVariableWithName(sName: string): bool {
			return !!(this.getIndexByName(sName));
		}

		/**@inline*/  hasVariableWithRealName(sName: string): bool {
			return !!(this.getIndexByRealName(sName));
		}

		getVarByName(sName: string): IAFXVariableDeclInstruction {
			var iIndex:  number  = this.getIndexByName(sName);

			if(iIndex === 0) {
				return null;
			}
			else {
				return this.getVarByIndex(iIndex);
			}
		}

		getVarByRealName(sName: string): IAFXVariableDeclInstruction {
			var iIndex:  number  = this.getIndexByRealName(sName);

			if(iIndex === 0) {
				return null;
			}
			else {
				return this.getVarByIndex(iIndex);
			}
		}

		static getVariableType(pVar: IAFXVariableDeclInstruction): EAFXShaderVariableType {
			var sBaseType: string = pVar.getType().getBaseType().getName();

			switch(sBaseType){
				case "texture":
					return EAFXShaderVariableType.k_Texture;

		        case "float":
		        	return EAFXShaderVariableType.k_Float;
		        case "int":
		        	return EAFXShaderVariableType.k_Int;
		        case "bool":
		        	return EAFXShaderVariableType.k_Bool;

		        case "float2":
		        	return EAFXShaderVariableType.k_Float2;
		        case "int2":
		        	return EAFXShaderVariableType.k_Int2;
		        case "bool2":
		        	return EAFXShaderVariableType.k_Bool2;

		        case "float3":
		        	return EAFXShaderVariableType.k_Float3;
		        case "int3":
		        	return EAFXShaderVariableType.k_Int3;
		        case "bool3":
		        	return EAFXShaderVariableType.k_Bool3;

		        case "float4":
		        	return EAFXShaderVariableType.k_Float4;
		        case "int4":
		        	return EAFXShaderVariableType.k_Int4;
		        case "bool4":
		        	return EAFXShaderVariableType.k_Bool4;

		        case "float2x2":
		        	return EAFXShaderVariableType.k_Float2x2;
		        case "float3x3":
		        	return EAFXShaderVariableType.k_Float3x3;
		        case "float4x4":
		        	return EAFXShaderVariableType.k_Float4x4;

		        case "sampler":
		        case "sampler2D":
		        	return EAFXShaderVariableType.k_Sampler2D;
		        case "samplerCUBE":
		        	return EAFXShaderVariableType.k_SamplerCUBE;

		       	default:
		       		if(pVar.getType().isComplex()){
		       			return EAFXShaderVariableType.k_Complex;
		       		}
		       		else {
		       			return EAFXShaderVariableType.k_NotVar;
		       		}
			}
		}

	}
}



module akra.fx {

	export class ComponentBlend implements IAFXComponentBlend {
		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } ;
		private _pComposer: IAFXComposer = null;

		private _isReady: bool = false;
		private _sHash: string = "";
		private _bNeedToUpdateHash: bool = false;

		private _pComponentHashMap: BoolMap = null;

		private _pAddedComponentInfoList: IAFXComponentInfo[] = null;

		private _iShiftMin:  number  = 0;
		private _iShiftMax:  number  = 0;
		private _nTotalPasses:  number  = 0;
		private _iPostEffectsStart:  number  = 0;

		private _pPassesDList: IAFXPassInstruction[][] = null;
		private _pComponentInputVarBlend: ComponentPassInputBlend[] = null;

		constructor(pComposer: IAFXComposer){
			this._pComposer = pComposer;

			this._pComponentHashMap = <BoolMap>{};

			this._pAddedComponentInfoList = [];
		}

		/**@inline*/  _getMinShift():  number  {
			return this._iShiftMin;
		}

		/**@inline*/  _getMaxShift():  number  {
			return this._iShiftMax;
		}

		/**@inline*/  isReadyToUse(): bool {
			return this._isReady;
		}

		/**@inline*/  isEmpty(): bool {
			return this._pAddedComponentInfoList.length === 0;
		}

		/**@inline*/  getComponentCount():  number  {
			return this._pAddedComponentInfoList.length;
		}

		/**@inline*/  getTotalPasses():  number  {
			return !isNull(this._pPassesDList) ? this._pPassesDList.length : (this._iShiftMax - this._iShiftMin + 1);
		}

		/**@inline*/  hasPostEffect(): bool {
			return this._iPostEffectsStart > 0;
		}

		/**@inline*/  getPostEffectStartPass():  number  {
			return this._iPostEffectsStart;
		}

		getHash(): string {
			if(this._bNeedToUpdateHash){
				this._sHash = this.calcHash();
				this._bNeedToUpdateHash = false;
			}

			return this._sHash;
		}

		containComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var iCorrectShift:  number  = iShift;
			var iCorrectPass:  number  = iPass;

			if(iShift ===  0xfffffc ){
				if(pComponent.isPostEffect()){
					iCorrectShift =  0xfffffa ;
				}
				else {
					iCorrectShift = 0;
				}
			}

			if(iCorrectShift !==  0xfffffb  && iCorrectPass !==  0xfffffa ){
				return this.containComponentHash(pComponent.getHash(iCorrectShift, iCorrectPass));
			}
			else {
				for(var i:  number  = 0; i < this._pAddedComponentInfoList.length; i++) {
					var pInfo: IAFXComponentInfo = this._pAddedComponentInfoList[i];

					if(pInfo.component === pComponent){
						if (iCorrectShift ===  0xfffffb  && iCorrectPass ===  0xfffffa ) {
							return true;
						}
						else if(iCorrectShift ===  0xfffffb  && pInfo.pass === iCorrectPass){
							return true;
						}
						else if(iCorrectPass ===  0xfffffa  && pInfo.shift === iCorrectShift){
							return true;
						}
					}
				}

				return false;
			}
		}

		/**@inline*/  containComponentHash(sComponentHash: string): bool {
			return (this._pComponentHashMap[sComponentHash]);
		}

		findAddedComponentInfo(pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentInfo {
			var iCorrectShift:  number  = iShift;
			var iCorrectPass:  number  = iPass;

			if(iShift ===  0xfffffc ){
				if(pComponent.isPostEffect()){
					iCorrectShift =  0xfffffa ;
				}
				else {
					iCorrectShift = 0;
				}
			}

			if (iCorrectShift !==  0xfffffb  && iCorrectPass !==  0xfffffa  &&
				!this.containComponentHash(pComponent.getHash(iCorrectShift, iCorrectPass))){

				return null;
			}
			else {
				for(var i:  number  = 0; i < this._pAddedComponentInfoList.length; i++) {
					var pInfo: IAFXComponentInfo = this._pAddedComponentInfoList[i];

					if(pInfo.component === pComponent){
						if (iCorrectShift ===  0xfffffb  && iCorrectPass ===  0xfffffa ) {
							return pInfo;
						}
						else if(iCorrectShift ===  0xfffffb  && pInfo.pass === iCorrectPass){
							return pInfo;
						}
						else if(iCorrectPass ===  0xfffffa  && pInfo.shift === iCorrectShift){
							return pInfo;
						}
						else if(pInfo.pass === iCorrectPass && pInfo.shift === iCorrectShift) {
							return pInfo;
						}
					}
				}

				return null;
			}
		}

		addComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): void {
			var iPassCount:  number  = pComponent.getTotalPasses();

			if(iPass ===  0xffffff ) {

				for(var i:  number  = 0; i < iPassCount; i++){
					this.addComponent(pComponent, iShift + i, i);
				}

				return;
			}
			else if(iPass < 0 || iPass >= iPassCount){
				return;
			}

			var sComponentHash: string = pComponent.getHash(iShift, iPass);
			if(this.containComponentHash(sComponentHash)){
				{ logger.setSourceLocation( "fx/ComponentBlend.ts" , 183 ); logger.warning("You try to add already used component '" + pComponent.findResourceName() + "' in blend."); } ;
				return;
			}

			if(iShift < this._iShiftMin){
				this._iShiftMin = iShift;
			}

			if(iShift > this._iShiftMax){
				this._iShiftMax = iShift;
			}

			var pInfo: IAFXComponentInfo = <IAFXComponentInfo>{
				component: pComponent,
				shift: iShift,
				pass: iPass,
				hash: sComponentHash
			};

			this._pComponentHashMap[sComponentHash] = true;
			this._pAddedComponentInfoList.push(pInfo);

			this._isReady = false;
			this._iPostEffectsStart = 0;
			this._bNeedToUpdateHash = true;

		}

		removeComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): void {
			var sComponentHash: string = pComponent.getHash(iShift, iPass);
			var iPassCount:  number  = pComponent.getTotalPasses();

			if(!this.containComponentHash(sComponentHash)){
				{ logger.setSourceLocation( "fx/ComponentBlend.ts" , 216 ); logger.warning("You try to remove not used component '" + sComponentHash + "' from blend."); } ;
				return;
			}

			if(iPass ===  0xffffff ) {
				for(var i:  number  = 0; i < iPassCount; i++){
					this.removeComponent(pComponent, iShift + i, i);
				}

				return;
			}
			else if(iPass < 0 || iPass >= iPassCount){
				return;
			}

			this._pComponentHashMap[sComponentHash] = false;

			for(var i:  number  = 0; i < this._pAddedComponentInfoList.length; i++){
				var pInfo: IAFXComponentInfo = this._pAddedComponentInfoList[i];

				if (pInfo.component === pComponent &&
					pInfo.shift === iShift &&
					pInfo.pass === iPass) {

					this._pAddedComponentInfoList.splice(i, 1);
					break;
				}
			}

			if(this._iShiftMin === iShift || this._iShiftMax === iShift){
				this._iShiftMax = 0;
				this._iShiftMin = 0;

				for(var i:  number  = 0; i < this._pAddedComponentInfoList.length; i++){
					var iTestShift:  number  = this._pAddedComponentInfoList[i].shift;

					if(iTestShift < this._iShiftMin){
						this._iShiftMin = iTestShift;
					}

					if(iTestShift > this._iShiftMax){
						this._iShiftMax = iTestShift;
					}
				}
			}

			this._isReady = false;
			this._iPostEffectsStart = 0;
			this._bNeedToUpdateHash = true;
		}

		finalizeBlend(): bool {
			if(this._isReady){
				return true;
			}

			this._pPassesDList = [];
			this._pComponentInputVarBlend = [];

			for(var i:  number  = 0; i < this._pAddedComponentInfoList.length; i++){
				var pInfo: IAFXComponentInfo = this._pAddedComponentInfoList[i];

				var pComponentTechnique: IAFXTechniqueInstruction = pInfo.component.getTechnique();
				var iShift:  number  = pInfo.shift - this._iShiftMin;
				var iPass:  number  = pInfo.pass;

				var pPass: IAFXPassInstruction = pComponentTechnique.getPass(iPass);

				if(!isDef(this._pPassesDList[iShift])) {
					this._pPassesDList[iShift] = [];
					this._pComponentInputVarBlend[iShift] = new ComponentPassInputBlend();
				}

				this._pPassesDList[iShift].push(pPass);
				this._pComponentInputVarBlend[iShift].addDataFromPass(pPass);

				if (pInfo.component.isPostEffect()){
					if(this._iPostEffectsStart === 0 || iShift < this._iPostEffectsStart){
						this._iPostEffectsStart = iShift;
					}
				}
			}

			for(var i:  number  = 0; i < this._pComponentInputVarBlend.length; i++){
				if(isDef(this._pComponentInputVarBlend[i])){
					this._pComponentInputVarBlend[i].finalizeInput();
				}
				else {
					this._pComponentInputVarBlend[i] = null;
					this._pPassesDList[i] = null;
				}
			}

			this._isReady = true;

			return true;
		}

		getPassInputForPass(iPass:  number ): IAFXPassInputBlend {
			if(!this._isReady){
				return null;
			}

			if (iPass < 0 || iPass > this.getTotalPasses() ||
				isNull(this._pComponentInputVarBlend[iPass])){
				return null;
			}

			return this._pComponentInputVarBlend[iPass].getPassInput();
		}

		getPassListAtPass(iPass:  number ): IAFXPassInstruction[] {
			if(!this._isReady){
				return null;
			}

			if(iPass < 0 || iPass > this.getTotalPasses()){
				return null;
			}

			return this._pPassesDList[iPass];
		}

		clone(): IAFXComponentBlend {
			var pClone: IAFXComponentBlend = new ComponentBlend(this._pComposer);

			pClone._setDataForClone(this._pAddedComponentInfoList,
									this._pComponentHashMap,
									this._iShiftMin, this._iShiftMax);
			return pClone;
		}

		/**@inline*/  _getComponentInfoList(): IAFXComponentInfo[] {
			return this._pAddedComponentInfoList;
		}

		_setDataForClone(pComponentInfoList: IAFXComponentInfo[],
						 pComponentHashMap: BoolMap,
						 iShiftMin:  number , iShiftMax:  number ): void {

			for(var i:  number  = 0; i < pComponentInfoList.length; i++){
				this._pAddedComponentInfoList.push({
					component: pComponentInfoList[i].component,
					shift: pComponentInfoList[i].shift,
					pass: pComponentInfoList[i].pass,
					hash: pComponentInfoList[i].hash
				});

				this._pComponentHashMap[pComponentInfoList[i].hash] = pComponentHashMap[pComponentInfoList[i].hash];
			}

			this._iShiftMin = iShiftMin;
			this._iShiftMax = iShiftMax;
			this._bNeedToUpdateHash = true;
		}

		private calcHash(): string {
			var sHash: string = "";

			if(this.isEmpty()) {
				return  "EMPTY_BLEND" ;
			}

			for(var i:  number  = 0; i < this._pAddedComponentInfoList.length; i++){
				sHash += this._pAddedComponentInfoList[i].hash + ":";
			}

			return sHash;
		}
	}


	export class ComponentPassInputBlend implements IAFXComponentPassInputBlend {
		private _pUniformsContainer: VariableContainer = null;
		private _pForeignsContainer: VariableContainer = null;
		private _pTexturesContainer: VariableContainer = null;

		private _pFreePassInputBlendList: IAFXPassInputBlend[] = null;

		/**@inline*/  get uniforms(): IAFXVariableContainer {
			return this._pUniformsContainer;
		}

		/**@inline*/  get textures(): IAFXVariableContainer {
			return this._pTexturesContainer;
		}

		/**@inline*/  get foreigns(): IAFXVariableContainer {
			return this._pForeignsContainer;
		}

		constructor() {
			this._pUniformsContainer = new VariableContainer();
			this._pForeignsContainer = new VariableContainer();
			this._pTexturesContainer = new VariableContainer();

			for(var i:  number  = 0; i < 16; i++){
				this._pTexturesContainer.addSystemEntry("TEXTURE" + i.toString(), EAFXShaderVariableType.k_Texture);
			}
		}

		addDataFromPass(pPass: IAFXPassInstruction): void {
			var pUniformMap: IAFXVariableDeclMap = pPass._getFullUniformMap();
			var pForeignMap: IAFXVariableDeclMap = pPass._getFullForeignMap();
			var pTextureMap: IAFXVariableDeclMap = pPass._getFullTextureMap();

			for(var i in pForeignMap){
				this._pForeignsContainer.add(pForeignMap[i]);
			}

			for(var i in pTextureMap){
				this._pTexturesContainer.add(pTextureMap[i]);
			}

			for(var i in pUniformMap){
				this.addUniformVariable(pUniformMap[i], "", "");
			}

		}

		finalizeInput(): void {
			this._pUniformsContainer.finalize();
			this._pForeignsContainer.finalize();
			this._pTexturesContainer.finalize();

			this._pFreePassInputBlendList = [];

			this.generateNewPassInputs();
		}

		getPassInput(): IAFXPassInputBlend {
			if(this._pFreePassInputBlendList.length === 0){
				this.generateNewPassInputs();
			}

			return this._pFreePassInputBlendList.pop();
		}

		releasePassInput(pInput: IAFXPassInputBlend) : void {
			this._pFreePassInputBlendList.push(pInput);
		}

		private addUniformVariable(pVariable: IAFXVariableDeclInstruction,
								   sPrevName: string, sPrevRealName: string): void {
			var sName: string = pVariable.getName();
			var sRealName: string = pVariable.getRealName();

			var pHasVar: IAFXVariableDeclInstruction = this._pUniformsContainer.getVarByRealName(sRealName);

			if(isDefAndNotNull(pHasVar) && !pHasVar.getType().isEqual(pVariable.getType())){
				{ logger.setSourceLocation( "fx/ComponentBlend.ts" , 466 ); logger.warning("You used uniforms with the same real-names. Now we don`t work very well with that."); } ;
				return;
			}

			this._pUniformsContainer.add(pVariable);
		}

		private generateNewPassInputs(nCount?:  number  = 5): void {
			for(var i:  number  = 0; i < nCount; i++) {
				var pPassInput: IAFXPassInputBlend = new PassInputBlend(this);
				this._pFreePassInputBlendList.push(pPassInput);
			}
		}
	}

}






module akra.fx {
	export class Blender implements IAFXBlender {
		private _pComposer: IAFXComposer = null;


		private _pComponentBlendByHashMap: IAFXComponentBlendMap = null;

		private _pBlendWithComponentMap: IAFXComponentBlendMap = null;
		private _pBlendWithBlendMap: IAFXComponentBlendMap = null;

		private _pPassBlendByHashMap: IAFXPassBlendMap = null;
		private _pPassBlendByIdMap: IAFXPassBlendMap = null;

		private _pPassBlendHashTree: util.HashTree = null;

		constructor(pComposer: IAFXComposer) {
			this._pComposer = pComposer;

			this._pComponentBlendByHashMap = <IAFXComponentBlendMap>{};

			this._pBlendWithComponentMap = <IAFXComponentBlendMap>{};
			this._pBlendWithBlendMap = <IAFXComponentBlendMap>{};

			this._pPassBlendByHashMap = <IAFXPassBlendMap>{};
			this._pPassBlendByIdMap = <IAFXPassBlendMap>{};

			this._pPassBlendHashTree = new util.HashTree();
		}

		addComponentToBlend(pComponentBlend: IAFXComponentBlend,
						    pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentBlend {

			if(!isNull(pComponentBlend) && pComponentBlend.containComponent(pComponent, iShift, iPass)){
				{ logger.setSourceLocation( "fx/Blender.ts" , 44 ); logger.warning("You try to add already used component '" + pComponent.findResourceName() + "' in blend."); } ;
				return pComponentBlend;
			}

			if(iShift ===  0xfffffc ){
				if(pComponent.isPostEffect()){
					iShift = pComponentBlend.getTotalPasses();
				}
				else {
					iShift = 0;
				}
			}

			var sBlendPartHash: string = isDefAndNotNull(pComponentBlend) ? pComponentBlend.getGuid().toString() : "";
			var sComponentPartHash: string = pComponent.getHash(iShift, iPass);
			var sShortHash: string = sBlendPartHash + "+" + sComponentPartHash;

			if(isDef(this._pBlendWithComponentMap[sShortHash])){
				return this._pBlendWithComponentMap[sShortHash];
			}

			var pNewBlend: IAFXComponentBlend = null;

			if(isNull(pComponentBlend)){
				pNewBlend = new ComponentBlend(this._pComposer);
			}
			else {
				pNewBlend = pComponentBlend.clone();
			}

			var pTechnique: IAFXTechniqueInstruction = pComponent.getTechnique();
			var pTechComponentList: IAFXComponent[] = pTechnique.getFullComponentList();
			var pTechComponentShiftList:  number [] = pTechnique.getFullComponentShiftList();

			if(iPass ===  0xffffff ) {
				if(!isNull(pTechComponentList)){
					for(var i:  number  = 0; i < pTechComponentList.length; i++){
						pNewBlend.addComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift,  0xffffff );
					}
				}

				pNewBlend.addComponent(pComponent, iShift,  0xffffff );
			}
			else {
				if(!isNull(pTechComponentList)){
					for(var i:  number  = 0; i < pTechComponentList.length; i++){
						pNewBlend.addComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, iPass - pTechComponentShiftList[i]);
					}
				}

				pNewBlend.addComponent(pComponent, iShift, iPass);
			}

			this._pBlendWithComponentMap[sShortHash] = pNewBlend;

			var sNewBlendHash: string = pNewBlend.getHash();

			if(isDef(this._pComponentBlendByHashMap[sNewBlendHash])){
				return this._pComponentBlendByHashMap[sNewBlendHash];
			}
			else {
				this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
			}

			return pNewBlend;
		}

		removeComponentFromBlend(pComponentBlend: IAFXComponentBlend,
								 pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentBlend {
			if(isNull(pComponentBlend)){
				{ logger.setSourceLocation( "fx/Blender.ts" , 115 ); logger.warning("You try to remove component '" + pComponent.getName() + "' with shift " + iShift.toString() + " from empty blend."); }
                                                                 ;
				return null;
			}

			var pComponentInfo: IAFXComponentInfo = pComponentBlend.findAddedComponentInfo(pComponent, iShift, iPass);
			if(isNull(pComponentInfo)){
				{ logger.setSourceLocation( "fx/Blender.ts" , 122 ); logger.warning("You try to remove component '" + pComponent.getName() + "' with shift " + iShift.toString() + " from blend that not contain it."); }
                                                                               ;
				return null;
			}

			if(iShift ===  0xfffffc ){
				if(pComponent.isPostEffect()){
					iShift = pComponentInfo.shift;
				}
				else {
					iShift = 0;
				}
			}

			var sBlendPartHash: string = isDefAndNotNull(pComponentBlend) ? pComponentBlend.getGuid().toString() : "";
			var sComponentPartHash: string = pComponent.getHash(iShift, iPass);
			var sShortHash: string = sBlendPartHash + "-" + sComponentPartHash;

			if(isDef(this._pBlendWithComponentMap[sShortHash])){
				return this._pBlendWithComponentMap[sShortHash];
			}

			var pNewBlend: IAFXComponentBlend = pComponentBlend.clone();

			var pTechnique: IAFXTechniqueInstruction = pComponent.getTechnique();
			var pTechComponentList: IAFXComponent[] = pTechnique.getFullComponentList();
			var pTechComponentShiftList:  number [] = pTechnique.getFullComponentShiftList();

			if(iPass ===  0xffffff ) {
				if(!isNull(pTechComponentList)){
					for(var i:  number  = 0; i < pTechComponentList.length; i++){
						pNewBlend.removeComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift,  0xffffff );
					}
				}

				pNewBlend.removeComponent(pComponent, iShift,  0xffffff );
			}
			else {
				if(!isNull(pTechComponentList)){
					for(var i:  number  = 0; i < pTechComponentList.length; i++){
						pNewBlend.removeComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, iPass - pTechComponentShiftList[i]);
					}
				}

				pNewBlend.removeComponent(pComponent, iShift, iPass);
			}

			this._pBlendWithComponentMap[sShortHash] = pNewBlend;

			var sNewBlendHash: string = pNewBlend.getHash();

			if(isDef(this._pComponentBlendByHashMap[sNewBlendHash])){
				return this._pComponentBlendByHashMap[sNewBlendHash];
			}
			else {
				this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
			}

			return pNewBlend;
		}

		addBlendToBlend(pComponentBlend: IAFXComponentBlend,
						pAddBlend: IAFXComponentBlend, iShift:  number ): IAFXComponentBlend {

//TODO: ADD CORRECT BLENDING FOR POSTEFFECTS
			if(isNull(pComponentBlend)){
				return pAddBlend;
			}

			if(isNull(pAddBlend)){
				return pComponentBlend;
			}

			var sShortHash: string = pComponentBlend.getGuid().toString() + "+" + pAddBlend.getGuid().toString();
			if(isDef(this._pBlendWithBlendMap[sShortHash])){
				return this._pBlendWithBlendMap[sShortHash];
			}

			var pNewBlend: IAFXComponentBlend = pComponentBlend.clone();

			var pAddComponentInfoList: IAFXComponentInfo[] = pAddBlend._getComponentInfoList();

			for(var i:  number  = 0; i < pAddComponentInfoList.length; i++){
				pNewBlend.addComponent(pAddComponentInfoList[i].component,
									   pAddComponentInfoList[i].shift + iShift,
									   pAddComponentInfoList[i].pass);
			}

			this._pBlendWithBlendMap[sShortHash] = pNewBlend;

			var sNewBlendHash: string = pNewBlend.getHash();

			if(isDef(this._pComponentBlendByHashMap[sNewBlendHash])){
				return this._pComponentBlendByHashMap[sNewBlendHash];
			}
			else {
				this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
			}

			return pNewBlend;
		}

		generatePassBlend(pPassList: IAFXPassInstruction[],
						  pStates: any, pForeigns: any, pUniforms: any): IAFXPassBlend {

			this._pPassBlendHashTree.release();

			for(var i:  number  = 0; i < pPassList.length; i++) {
				var pPass: IAFXPassInstruction = pPassList[i];

				pPass.evaluate(pStates, pForeigns, pUniforms);

				var pVertexShader: IAFXFunctionDeclInstruction = pPass.getVertexShader();
				var pPixelShader: IAFXFunctionDeclInstruction = pPass.getPixelShader();

				this._pPassBlendHashTree.has(isNull(pVertexShader) ? 0 : pVertexShader.getGuid());
				this._pPassBlendHashTree.has(isNull(pPixelShader) ? 0 : pPixelShader.getGuid());
			}

			var pBlend: IAFXPassBlend = this._pPassBlendHashTree.getContent();
			if(!pBlend){
				var pNewPassBlend: IAFXPassBlend = new PassBlend(this._pComposer);
				var isOk: bool = pNewPassBlend.initFromPassList(pPassList);

				if(!isOk){
					return null;
				}

				this._pPassBlendHashTree.addContent(pNewPassBlend);
				this._pPassBlendByIdMap[pNewPassBlend.getGuid()] = pNewPassBlend;
				return pNewPassBlend;
			}
			else {
				return pBlend;
			}
		}

		/**@inline*/  getPassBlendById(id:  number ): IAFXPassBlend {
			return this._pPassBlendByIdMap[id] || null;
		}
	}
}




































module akra.util {
	export interface IBuffersCompatibleMap {
		[handle:  number ]: IVertexData;
	}

	export interface ISemanticsMap {
		[semantics: string]: IDataFlow;
	}

	export class BufferMap implements IBufferMap extends ReferenceCounter {
		private _pFlows: IDataFlow[] = null;
		private _pMappers: IDataMapper[] = null;
		private _pIndex: IIndexData = null;
		private _nLength:  number  = 0;
		private _ePrimitiveType: EPrimitiveTypes;
		private _pCompleteFlows: IDataFlow[] = null;
		private _nCompleteFlows:  number  = 0;
		private _nCompleteVideoBuffers:  number  = 0;
		private _pCompleteVideoBuffers: IVertexBuffer[] = null;
		private _nUsedFlows:  number  = 0;
		private _pEngine: IEngine = null;
		private _nStartIndex:  number  = 0;
		private _pBuffersCompatibleMap: IBuffersCompatibleMap = null;
		private _pSemanticsMap: ISemanticsMap = null;
		private _nUpdates:  number  = 0;

		constructor(pEngine: IEngine){
			super();
			this._pEngine = pEngine;
			this.reset();
		};

		/**@inline*/  get totalUpdates():  number  {
			return this._nUpdates;
		}

		/**@inline*/  get primType(): EPrimitiveTypes{
			return this._pIndex ? this._pIndex.getPrimitiveType() : this._ePrimitiveType;
		};

		/**@inline*/  set primType(eType: EPrimitiveTypes){
			this._ePrimitiveType = eType;
			this.modified();
		};

		/**@inline*/  get primCount():  number  {
			return data.IndexData.getPrimitiveCount(this.primType, this.length);
		};

		/**@inline*/  get index(): IIndexData {
			return this._pIndex;
		};

		/**@inline*/  set index(pIndexData: IIndexData) {
			if (this._pIndex === pIndexData) {
	            return;
	        }

	        this._pIndex = pIndexData;
	        this.update();
		};

		/**@inline*/  get limit():  number  {
			return this._pFlows.length;
		};

		/**@inline*/  get length():  number  {
			return (this._pIndex ? this._pIndex.length : this._nLength);
		}

		/**@inline*/  set length(nLength:  number ) {
			this._nLength = Math.min(this._nLength, nLength);
			this.modified();
		}

		/**@inline*/  set _length(nLength:  number ) {
			this._nLength = nLength;
			this.modified();
		}

		/**@inline*/  get startIndex():  number  {
			return this._nStartIndex;
		}

		/**@inline*/  get size():  number {
			return this._nCompleteFlows;
		}

		/**@inline*/  get flows(): IDataFlow[] {
			return this._pCompleteFlows;
		}

		/**@inline*/  get mappers(): IDataMapper[] {
			return this._pMappers;
		}

		/**@inline*/  get offset():  number  {
			return (this._pIndex? this._pIndex.byteOffset: 0);
		}

		_draw(): void {
// this._pEngine.getComposer().applyBufferMap(this);
// this._pEngine.getRenderer().getActiveProgram().applyBufferMap(this);
			isNull(this._pIndex)? this.drawArrays(): this.drawElements();
		}

		private  /**@inline*/  drawArrays(): void {



			(<webgl.WebGLRenderer>this._pEngine.getRenderer()).getWebGLContext().drawArrays(
				webgl.getWebGLPrimitiveType(this._ePrimitiveType),
// GL_POINTS,
				this._nStartIndex,
				this._nLength);



		}

		private  /**@inline*/  drawElements(): void {

			(<webgl.WebGLRenderer>this._pEngine.getRenderer()).getWebGLContext().drawElements(
				webgl.getWebGLPrimitiveType(this._ePrimitiveType),
				this._pIndex.getPrimitiveCount(),
				webgl.getWebGLPrimitiveType(this._pIndex.getPrimitiveType()),
				this._pIndex.byteOffset / 4);
//FIXME: offset of drawElement() in Glintptr = long long = 32 byte???

		}

		getFlow(sSemantics: string, bComplete: bool = true): IDataFlow;
		getFlow(iFlow:  number , bComplete: bool = true): IDataFlow;
		getFlow(iFlow: any, bComplete: bool = true): IDataFlow {

		    if (isString(arguments[0])) {
		        var nTotal:  number ;
		        var pFlows: IDataFlow[];

		        if (bComplete) {
		            pFlows = this._pCompleteFlows;
		            nTotal = this._nCompleteFlows;
		        }
		        else {
		            pFlows = this._pFlows;
		            nTotal = this._pFlows.length;
		        }

		        for (var i:  number  = 0; i < nTotal; ++ i) {
		            if (!pFlows[i].data) {
		                continue;
		            }
		            if (pFlows[i].data.hasSemantics(arguments[0])) {
		                return pFlows[i];
		            }
		        }

		        return null;
		    }

		    if (bComplete) {

		        for (var i:  number  = 0, pFlows = this._pCompleteFlows; i < this._nCompleteFlows; ++ i) {
		            if (pFlows[i].flow == iFlow) {
		                return pFlows[i];
		            }
		        }

		        return null;
		    }

		    return this._pFlows[iFlow];
		}

//TODO: It is temp method for test deoptimozation of code
		getFlowBySemantic(sSemantics: string): IDataFlow {
			for (var i:  number  = 0; i < this._nCompleteFlows; ++ i) {
				if (this._pCompleteFlows[i].data.hasSemantics(sSemantics)) {
		            return  this._pCompleteFlows[i];
		        }
			}

			return null;
		}

		reset(): void {
			this._pIndex = null
		    this._ePrimitiveType = EPrimitiveTypes.TRIANGLELIST;


		    var nFlowLimit:  number  = 16;

/*webgl.maxVertexTextureImageUnits*/
			nFlowLimit = Math.min(16                                    , webgl.maxVertexAttributes);


		    this._pMappers = [];
		    this._pFlows = new Array(nFlowLimit);
		    for (var i = 0; i < nFlowLimit; i++) {
		        this._pFlows[i] = {
		            flow: i,
		            data:  null,
		            type:  EDataFlowTypes.UNMAPPABLE,
		            mapper:null
		        };
		    }

		    this._nLength = MAX_INT32;
		    this._pCompleteFlows = new Array(nFlowLimit);
		    this._nCompleteFlows = 0;
		    this._nStartIndex = MAX_INT32;
		    this._pBuffersCompatibleMap = <IBuffersCompatibleMap>{};

		    this._pCompleteVideoBuffers = new Array(nFlowLimit);
		    this._nCompleteVideoBuffers = 0;
		    this._nUsedFlows = 0;

		    this._pSemanticsMap = {};
		    this._nUpdates = 0;

		    this.modified();
		}

		flow(pVertexData: IVertexData):  number ;
		flow(iFlow:  number , pVertexData: IVertexData):  number ;
		flow(iFlow, pData?):  number  {
			var pFlow: IDataFlow = null;
			var pVertexData: IVertexData = null;
			var isOk: bool;

		    if (arguments.length < 2) {
		        pVertexData = <IVertexData>arguments[0];
		        iFlow = (this._nUsedFlows ++);
		    }
		   	else {
		   		iFlow = arguments[0];
		   		pVertexData = arguments[1];
		   	}

		    pFlow = this._pFlows[iFlow];

		    { logger.setSourceLocation( "util/BufferMap.ts" , 264 ); logger.assert(iFlow < this.limit, 'Invalid strem. Maximum allowable number of stream ' + this.limit + '.'); }
                                                                                  ;

		    if (!pVertexData || pFlow.data === pVertexData) {
		    	{ logger.setSourceLocation( "util/BufferMap.ts" , 268 ); logger.warning("BufferMap::flow(", iFlow, pVertexData, ") failed.", isNull(pVertexData)? "vertex data is null": "flow.data alreay has same vertex data"); }
                                                                                            ;
		        return -1;
		    }

		    if (core.pool.resources.isVBO(<IVertexBuffer>pVertexData.buffer)) {
		        pFlow.type = EDataFlowTypes.UNMAPPABLE;
		        this.length = pVertexData.length;
//this.startIndex = pVertexData.getStartIndex();
		        isOk = this.checkData(pVertexData);
		        { logger.setSourceLocation( "util/BufferMap.ts" , 277 ); logger.assert(isOk, 'You can use several unmappable data flows from one buffer.'); } ;

		        this.trackData(pVertexData);
		    }
		    else {
		        pFlow.type = EDataFlowTypes.MAPPABLE;
		    }

		    if (isDefAndNotNull(pFlow.data)) {
		    	this.untrackData(pVertexData);
		    }

		    pFlow.data = pVertexData;

		    return this.update() ? iFlow : -1;
		}

		private clearLinks(): void {
			for (var sSemantics in this._pSemanticsMap) {
				this._pSemanticsMap[sSemantics] = null;
			}
		}

		private linkFlow(pFlow: IDataFlow): void {
			var pDecl: data.VertexDeclaration = pFlow.data.getVertexDeclaration();

			for (var i:  number  = 0; i < pDecl.length; ++ i) {
				var pElement: data.VertexElement = <data.VertexElement>pDecl.element(i);
				var sSemantics: string = pElement.semantics;

				if (pElement.isEnd()) {
					continue;
				}

				var isSemanticsExists: bool = isDefAndNotNull(this._pSemanticsMap[sSemantics]);

				{ logger.setSourceLocation( "util/BufferMap.ts" , 313 ); logger.assert(!isSemanticsExists, "overwrited semantics: " + sSemantics); } ;

				if (!isSemanticsExists) {
					this._pSemanticsMap[sSemantics] = pFlow;
				}
			}

			if (pFlow.type === EDataFlowTypes.MAPPABLE) {
				var sSemantics: string = pFlow.mapper.semantics;
				var isSemanticsExists: bool = isDefAndNotNull(this._pSemanticsMap[sSemantics]);

				{ logger.setSourceLocation( "util/BufferMap.ts" , 324 ); logger.assert(!isSemanticsExists, "overwrited semantics(MAPPER!): " + sSemantics); } ;

				if (!isSemanticsExists) {
					this._pSemanticsMap[sSemantics] = pFlow;
				}
			}
		}

		checkData(pData: IVertexData): bool {
			var pEtalon = this._pBuffersCompatibleMap[pData.getBufferHandle()];

		    if (!pEtalon || pEtalon.byteOffset === pData.byteOffset) {
		        return true;
		    }

		    return false;
		}

		protected findMapping(pMap, eSemantics, iAddition): IDataMapper {
			var isOk: bool = this.checkData(pMap);
		    { logger.setSourceLocation( "util/BufferMap.ts" , 344 ); logger.assert(isOk, 'You can use several different maps from one buffer.'); } ;

		    for (var i:  number  = 0, pMappers: IDataMapper[] = this._pMappers, pExistsMap; i < pMappers.length; i++) {
		        pExistsMap = pMappers[i].data;
		        if (pExistsMap === pMap) {
//если уже заданные маппинг менял свой стартовый индекс(например при расширении)
//то необходимо сменить стартовый индекс на новый
		            if (pMappers[i].semantics === eSemantics && pMappers[i].addition == iAddition) {
		                return pMappers[i];
		            }
		        }
		        else {
		            { logger.setSourceLocation( "util/BufferMap.ts" , 357 ); logger.assert(pExistsMap.getStartIndex() === pMap.getStartIndex(), 'You can not use maps with different indexing'); }
                                                                 ;
		        }
		    }
		    return null;
		};


		mapping(iFlow:  number , pMap: IVertexData, eSemantics: string, iAddition:  number  = 0): bool {
		    var pMapper: IDataMapper = this.findMapping(pMap, eSemantics, iAddition);
		    var pFlow: IDataFlow     = this._pFlows[iFlow];

		    { logger.setSourceLocation( "util/BufferMap.ts" , 369 ); logger.assert(isDefAndNotNull(pFlow.data) && (pFlow.type === EDataFlowTypes.MAPPABLE), 'Cannot mapping empty/unmappable flow.'); }
                                                  ;
		    { logger.setSourceLocation( "util/BufferMap.ts" , 370 ); logger.assert(isDef(pMap), 'Passed empty mapper.'); } ;

		    if (!eSemantics) {
		        eSemantics = pMap.getVertexDeclaration()[0].eUsage;
		    }
		    else if (pMap.hasSemantics(eSemantics) === false) {
		        { logger.setSourceLocation( "util/BufferMap.ts" , 376 ); logger.error('Passed mapper does not have semantics: ' + eSemantics + '.'); } ;
		        return false;
		    }

		    if (pMapper) {
		        if (pFlow.mapper === pMapper) {
		            return pMapper.semantics === eSemantics &&
		                pMapper.addition === iAddition? true: false;
		        }
		    }
		    else {
		        pMapper = <IDataMapper>{
		        	data: pMap,
		        	semantics: eSemantics,
		        	addition: iAddition
		        };

		        this._pMappers.push(pMapper);
		        this.length = pMap.length;
		        this.trackData(pMap);
		    }

		    pFlow.mapper = pMapper;

		    return this.update();
		}

		private trackData(pData: IVertexData): void {
//only one vertex data may be used in one veetex buffer
//случаи, когда выделяются 2 vertex data'ы в одной области памяти не рассматриваются
			this._pBuffersCompatibleMap[pData.getBufferHandle()] = pData;

//this.connect(pData, SIGNAL(relocated), SLOT(modified));
//this.connect(pData, SIGNAL(resized), SLOT(modified));
//this.connect(pData, SIGNAL(updated), SLOT(modified));
		    this.connect(pData,  "declarationChanged" ,  "modified" );
		}

		private untrackData(pData: IVertexData): void {
			delete this._pBuffersCompatibleMap[pData.getBufferHandle()];

//this.disconnect(pData, SIGNAL(relocated), SLOT(modified));
//this.disconnect(pData, SIGNAL(resized), SLOT(modified));
//this.disconnect(pData, SIGNAL(updated), SLOT(modified));
		    this.disconnect(pData,  "declarationChanged" ,  "modified" );
		}

		update(): bool {
			var pFlows: IDataFlow[] = this._pFlows;
		    var pFlow: IDataFlow;
		    var pMapper: IDataMapper;
		    var isMappable: bool = false;
		    var pCompleteFlows: IDataFlow[] = this._pCompleteFlows;
		    var nCompleteFlows:  number  = 0;
		    var pCompleteVideoBuffers: IVertexBuffer[] = this._pCompleteVideoBuffers;
		    var nCompleteVideoBuffers:  number  = 0;
		    var nUsedFlows:  number  = 0;
		    var pVideoBuffer: IVertexBuffer;
		    var isVideoBufferAdded: bool = false;
		    var nStartIndex:  number  = MAX_INT32, nCurStartIndex:  number ;

		    this.clearLinks();

		    for (var i:  number  = 0; i < pFlows.length; i++) {
		        pFlow = pFlows[i];
		        pMapper = pFlow.mapper;
		        isMappable = (pFlow.type === EDataFlowTypes.MAPPABLE);

		        if (pFlow.data) {
		            nUsedFlows ++;
		        }

		        if (pFlow.data === null || (isMappable && pMapper === null)) {
		            continue;
		        }

		        pCompleteFlows[nCompleteFlows ++] = pFlow;
		        this.linkFlow(pFlow);

		        if (isMappable) {
		            nCurStartIndex = pMapper.data.startIndex;
		            pVideoBuffer = <IVertexBuffer>pFlow.data.buffer;
		            for (var j = 0; j < nCompleteVideoBuffers; j++) {
		                if (pCompleteVideoBuffers[j] === pVideoBuffer) {
		                    isVideoBufferAdded = true;
		                    break;
		                }
		            }
		            if (!isVideoBufferAdded) {
		                pCompleteVideoBuffers[nCompleteVideoBuffers ++] = pVideoBuffer;
		            }
		        }
		        else {
		            nCurStartIndex = pFlow.data.startIndex;
		        }

		        if (nStartIndex === MAX_INT32) {
		            nStartIndex = nCurStartIndex;
		            continue;
		        }

		        { logger.setSourceLocation( "util/BufferMap.ts" , 478 ); logger.assert(nStartIndex == nCurStartIndex, 'You can not use a maps or unmappable buffers having different starting index.'); }
                                                                                              ;
		    }

		    this._nStartIndex = nStartIndex;
		    this._nCompleteFlows = nCompleteFlows;
		    this._nCompleteVideoBuffers = nCompleteVideoBuffers;
		    this._nUsedFlows = nUsedFlows;

		    this.modified();

		    return true;
		}

		findFlow(sSemantics: string) {
			return !isDef(this._pSemanticsMap[sSemantics]) ? (this._pSemanticsMap[sSemantics] = null) : this._pSemanticsMap[sSemantics];
		}

		clone(bWithMapping: bool = true): IBufferMap {

		    var pMap: IBufferMap = this._pEngine.createBufferMap();

		    for (var i = 0, pFlows = this._pFlows; i < pFlows.length; ++ i) {
		        if (pFlows[i].data === null) {
		            continue;
		        }

		        if (pMap.flow(pFlows[i].flow, pFlows[i].data) < 0) {
		            pMap = null;
		            { logger.setSourceLocation( "util/BufferMap.ts" , 506 ); logger.log("BufferMap::clone() failed on", pFlows[i].flow, pFlows[i].data); } ;
		            return null;
		        }

		        if (!bWithMapping) {
		            continue;
		        }

		        if (pFlows[i].mapper) {
	                pMap.mapping(pFlows[i].flow,
	                pFlows[i].mapper.data,
	                pFlows[i].mapper.semantics,
	                pFlows[i].mapper.addition);
		        }
		    }

		    return pMap;
		}

		toString(bListAll: bool = false): string {

			function _an(sValue, n:  number , bBackward?: bool) {
		        sValue = String(sValue);
		        bBackward = bBackward || false;

		        if (sValue.length < n) {
		            for (var i = 0, l = sValue.length; i < n - l; ++ i) {
		                if (!bBackward) {
		                    sValue += ' ';
		                }
		                else {
		                    sValue = ' ' + sValue;
		                }
		            }
		        }

		        return sValue;
		    }

		    var s = '\n\n', t;
		    s += '      $1 Flows     : OFFSET / SIZE   |   BUFFER / OFFSET   :      Mapping  / Shift    : OFFSET |    Additional    \n';
		    s = s.replace("$1", bListAll? "   Total": "Complete");
		    t  = '-------------------------:-----------------+---------------------:--------------------------:--------+------------------\n';
// = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
// = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
		    s += t;

		    var pFlows: IDataFlow[] = bListAll? this._pFlows: this._pCompleteFlows;
		    var nFlows:  number  = bListAll? this._nUsedFlows: this._nCompleteFlows;
		    for (var i:  number  = 0; i < nFlows; ++ i) {
		        var pFlow: IDataFlow = pFlows[i];
		        var pMapper: IDataMapper = pFlow.mapper;
		        var pVertexData: IVertexData = pFlow.data;
		        var pDecl: data.VertexDeclaration = pVertexData.getVertexDeclaration();
//trace(pMapper); window['pMapper'] = pMapper;
		        s += '#' + _an(pFlow.flow, 2) + ' ' +
		            _an('[ ' + (pDecl.element(0).usage !== DeclUsages.END? pDecl.element(0).usage: '<end>') + ' ]', 20) +
		            ' : ' + _an(pDecl.element(0).offset, 6, true) + ' / ' + _an(pDecl.element(0).size, 6) +
		            ' | ' +
		            _an(pVertexData.getBufferHandle(), 8, true) + ' / ' + _an(pVertexData.byteOffset, 8) +
		            ' : ' +
		            (pMapper? _an(pMapper.semantics, 15, true) + ' / ' + _an(pMapper.addition, 7) + ': ' +
		                _an(pMapper.data.getVertexDeclaration().findElement(pMapper.semantics).offset, 6) :
		            _an('-----', 25) + ': ' + _an('-----', 6)) + ' |                  \n';


		        for (var j = 1; j < pDecl.length; ++ j) {
		            s += '    ' +
		            _an('[ ' + (pDecl.element(j).usage !== DeclUsages.END? pDecl.element(j).usage: '<end>') + ' ]', 20) + ' : ' + _an(pDecl.element(j).offset, 6, true) + ' / ' + _an(pDecl.element(j).size, 6) +
		                  ' |                     :                          :        |                  \n';
		        }
		        s += t;
		    };
		    s += '=================================================================\n';
		    s += '      PRIMITIVE TYPE : ' + '0x' + Number(this.primType).toString(16) + '\n';
		    s += '     PRIMITIVE COUNT : ' + this.primCount + '\n';
		    s += '         START INDEX : ' + this.startIndex + '\n';
		    s += '              LENGTH : ' + this.length + '\n';
		    s += '  USING INDEX BUFFER : ' + (this.index? 'TRUE': 'FALSE') + '\n';
		    s += '=================================================================\n';

		    return s + '\n\n';

		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return BufferMap._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;

		modified(): void {
			this._nUpdates ++;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).modified; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } ;
		}
	}

	export function createBufferMap(pEngine: IEngine): IBufferMap {
		return new BufferMap(pEngine);
	}
}












// #define FAST_SET_UNIFORM(pInput, sName, pValue) pInput.setUniform(sName, pValue);
// iIndex = pInput._getUniformVarNameIndex(sName); if(iIndex > 0) pInput.uniforms[iIndex] = pValue;
//if(pInput.hasUniform(sName)) pInput.uniforms[pInput._getUniformVarNameIndex(sName)] = pValue;

module akra.fx {

	export interface IPreRenderState {
		isClear: bool;

		primType: EPrimitiveTypes;
		offset:  number ;
		length:  number ;
		index: IIndexData;
//flows: IDataFlow[];
		flows: util.ObjectArray;
	}

	export enum ESystemUniformsIndices{
		k_ModelMatrix,
		k_FramebufferSize,
		k_ViewportSize,
		k_ViewMatrix,
		k_ProjMatrix,
		k_InvViewCameraMat,
		k_CameraPosition,
		k_WorldPosition,
		k_WorldScale,
		k_WorldOrientation,
		k_LocalPosition,
		k_LocalScale,
		k_LocalOrientation,
		k_LocalMatrix,
		k_OptimizedProjMatrix,
		k_BindShapeMatrix,
		k_RenderObjectId,
		k_WireframeOverlay,
// k_InputTexture,
// k_InputSampler,
		k_InputTextureSize,
		k_InputTextureRatio,

		k_useNormal,
		k_isDebug,
		k_isRealNormal,
		k_normalFix,
		k_isWithBalckSectors,
		k_showTriangles,
		k_u1,
		k_kFixNormal,
		k_fSunAmbient,
		k_fSunSpecular,
		k_cHeightFalloff,
		k_cGlobalDensity
	}

	export class Composer implements IAFXComposer {
		private _pEngine: IEngine = null;

		private _pTechniqueToBlendMap: IAFXComponentBlendMap = null;
		private _pTechniqueToOwnBlendMap: IAFXComponentBlendMap = null;
		private _pTechniqueLastGlobalBlendMap: IAFXComponentBlendMap = null;
		private _pTechniqueNeedUpdateMap: BoolMap = null;

		private _pEffectResourceToComponentBlendMap: IAFXComponentBlendMap = null;
		private _pBlender: IAFXBlender = null;

		private _pGlobalEffectResorceIdStack:  number [] = null;
// private _pGlobalEffectResorceShiftStack: int[] = null;
		private _pGlobalComponentBlendStack: IAFXComponentBlend[] = null;
		private _pGlobalComponentBlend: IAFXComponentBlend = null;

//Data for render
		private _pCurrentSceneObject: ISceneObject = null;
		private _pCurrentViewport: IViewport = null;
		private _pCurrentRenderable: IRenderableObject = null;

		private _pCurrentBufferMap: IBufferMap = null;
		private _pCurrentSurfaceMaterial: ISurfaceMaterial = null;

		private _pComposerState: any = {
			mesh : {
				isSkinned : false,
				isOptimizedSkinned : false
			},
			object: {
				isBillboard: false
			},
			terrain : {
				isROAM : false
			},
			renderable: {
				isAdvancedIndex: false
			}
		};

/** Render targets for global-post effects */

		private _pRenderTargetA: IRenderTarget = null;
		private _pRenderTargetB: IRenderTarget = null;
		private _pLastRenderTarget: IRenderTarget = null;
		private _pPostEffectViewport: IViewport = null;

		private _pPostEffectTextureA: ITexture = null;
		private _pPostEffectTextureB: ITexture = null;
		private _pPostEffectDepthBuffer: IPixelBuffer = null;

//Temporary objects for fast work
		static pDefaultSamplerBlender: SamplerBlender = null;

//render id data
		private _pRidTable: IRIDTable = <any>{};
		private _pRidMap: IRIDMap = <any>{};
		private _nRidSO:  number  = 0;
		private _nRidRE:  number  = 0;

//For fast set system uniforms
		private _pSystemUniformsNameIndexList:  number [] = new Array();
		private _bIsFirstApplySystemUnifoms: bool = true;

		constructor(pEngine: IEngine){
			this._pEngine = pEngine;

			this._pBlender = new Blender(this);

			this._pTechniqueToBlendMap = <IAFXComponentBlendMap>{};
			this._pTechniqueToOwnBlendMap = <IAFXComponentBlendMap>{};
			this._pTechniqueLastGlobalBlendMap = <IAFXComponentBlendMap>{};
			this._pTechniqueNeedUpdateMap = <BoolMap>{};

			this._pEffectResourceToComponentBlendMap = <IAFXComponentBlendMap>{};

			this._pGlobalEffectResorceIdStack = [];
			this._pGlobalComponentBlendStack = [];
			this._pGlobalComponentBlend = null;

			this.initPostEffectTextures();


			if(isNull(Composer.pDefaultSamplerBlender)){
				Composer.pDefaultSamplerBlender = new SamplerBlender();
			}
		}

		getComponentByName(sComponentName: string): IAFXComponent {
			return <IAFXComponent>this._pEngine.getResourceManager().componentPool.findResource(sComponentName);
		}

		/**@inline*/  getEngine(): IEngine {
			return this._pEngine;
		}

//-----------------------------------------------------------------------------//
//-----------------------------API for Effect-resource-------------------------//
//-----------------------------------------------------------------------------//

		getComponentCountForEffect(pEffectResource: IEffect):  number  {
			var id:  number  = pEffectResource.resourceHandle;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])) {
				return this._pEffectResourceToComponentBlendMap[id].getComponentCount();
			}
			else {
				return 0;
			}
		}

		getTotalPassesForEffect(pEffectResource: IEffect):  number  {
			var id:  number  = pEffectResource.resourceHandle;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])) {
				return this._pEffectResourceToComponentBlendMap[id].getTotalPasses();
			}
			else {
				return 0;
			}
		}

		addComponentToEffect(pEffectResource: IEffect, pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])){
				pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
			}

			var pNewBlend: IAFXComponentBlend = this._pBlender.addComponentToBlend(pCurrentBlend, pComponent, iShift, iPass);
			if(isNull(pNewBlend)){
				return false;
			}

			this._pEffectResourceToComponentBlendMap[id] = pNewBlend;
			return true;
		}

		removeComponentFromEffect(pEffectResource: IEffect, pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])){
				pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
			}

			var pNewBlend: IAFXComponentBlend = this._pBlender.removeComponentFromBlend(pCurrentBlend, pComponent, iShift, iPass);
			if(isNull(pNewBlend)){
				return false;
			}

			this._pEffectResourceToComponentBlendMap[id] = pNewBlend;
			return true;
		}

		hasComponentForEffect(pEffectResource:IEffect,
							  pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])){
				pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
			}

			if(isNull(pCurrentBlend)){
				return false;
			}

			return pCurrentBlend.containComponent(pComponent, iShift, iPass);
		}

		activateEffectResource(pEffectResource: IEffect, iShift:  number ): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var pComponentBlend: IAFXComponentBlend = this._pEffectResourceToComponentBlendMap[id];

			if(!isDef(pComponentBlend)){
				return false
			}

			var pNewGlobalBlend: IAFXComponentBlend = null;

			if(isNull(this._pGlobalComponentBlend)){
				pNewGlobalBlend = pComponentBlend;
			}
			else {
				pNewGlobalBlend = this._pBlender.addBlendToBlend(this._pGlobalComponentBlend, pComponentBlend, iShift);
			}

			if(isNull(pNewGlobalBlend)){
				return false;
			}

			this._pGlobalEffectResorceIdStack.push(id);
			this._pGlobalComponentBlendStack.push(pNewGlobalBlend);

			this._pGlobalComponentBlend = pNewGlobalBlend;

			return true;
		}

		deactivateEffectResource(pEffectResource: IEffect): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var iStackLength:  number  = this._pGlobalEffectResorceIdStack.length;

			if(iStackLength === 0){
				return false;
			}

			var iLastId:  number  = this._pGlobalEffectResorceIdStack[iStackLength - 1];

			if(iLastId !== id){
				return false;
			}

			this._pGlobalEffectResorceIdStack.splice(iStackLength - 1, 1);
			this._pGlobalComponentBlendStack.splice(iStackLength - 1, 1);

			if(iStackLength > 1){
				this._pGlobalComponentBlend = this._pGlobalComponentBlendStack[iStackLength - 2];
			}
			else {
				this._pGlobalComponentBlend = null;
			}

			return true;
		}

		getPassInputBlendForEffect(pEffectResource: IEffect, iPass:  number ): IAFXPassInputBlend {
			var id:  number  = pEffectResource.resourceHandle;
			var pBlend: IAFXComponentBlend = this._pEffectResourceToComponentBlendMap[id];

			if(!isDef(this._pEffectResourceToComponentBlendMap[id])){
				return null;
			}

			if(!pBlend.isReadyToUse()) {
				pBlend.finalizeBlend();
			}

			return pBlend.getPassInputForPass(iPass);
		}

//-----------------------------------------------------------------------------//
//----------------------------API for RenderTechnique--------------------------//
//-----------------------------------------------------------------------------//

		getMinShiftForOwnTechniqueBlend(pRenderTechnique: IRenderTechnique):  number  {
			var id:  number  = pRenderTechnique.getGuid();
			var pBlend: IAFXComponentBlend = this._pTechniqueToOwnBlendMap[id];

			if(isDefAndNotNull(this._pTechniqueToOwnBlendMap[id])){
				return pBlend._getMinShift();
			}
			else {
				return 0;
			}
		}

		getTotalPassesForTechnique(pRenderTechnique: IRenderTechnique):  number  {
			this.prepareTechniqueBlend(pRenderTechnique);

			var id:  number  = pRenderTechnique.getGuid();

			if(isDefAndNotNull(this._pTechniqueToBlendMap[id])) {
				return this._pTechniqueToBlendMap[id].getTotalPasses();
			}
			else {
				return 0;
			}
		}

		addOwnComponentToTechnique(pRenderTechnique: IRenderTechnique,
								   pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pRenderTechnique.getGuid();
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pTechniqueToOwnBlendMap[id])){
				pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
			}

			var pNewBlend: IAFXComponentBlend = this._pBlender.addComponentToBlend(pCurrentBlend, pComponent, iShift, iPass);

			if(isNull(pNewBlend)){
				return false;
			}

			this._pTechniqueToOwnBlendMap[id] = pNewBlend;
			this._pTechniqueNeedUpdateMap[id] = true;

			return true;
		}

		removeOwnComponentToTechnique(pRenderTechnique: IRenderTechnique,
									  pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pRenderTechnique.getGuid();
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pTechniqueToOwnBlendMap[id])){
				pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
			}

			var pNewBlend: IAFXComponentBlend = this._pBlender.removeComponentFromBlend(pCurrentBlend, pComponent, iShift, iPass);
			if(isNull(pNewBlend)){
				return false;
			}

			this._pTechniqueToOwnBlendMap[id] = pNewBlend;
			this._pTechniqueNeedUpdateMap[id] = true;
			return true;
		}

		hasOwnComponentInTechnique(pRenderTechnique: IRenderTechnique,
								   pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pRenderTechnique.getGuid();
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pTechniqueToOwnBlendMap[id])){
				pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
			}

			if(isNull(pCurrentBlend)){
				return false;
			}

			return pCurrentBlend.containComponent(pComponent, iShift, iPass);
		}

		prepareTechniqueBlend(pRenderTechnique: IRenderTechnique): bool {
			if(pRenderTechnique.isFreeze()){
				return true;
			}

			var id:  number  = pRenderTechnique.getGuid();

			var isTechniqueUpdate: bool = !!(this._pTechniqueNeedUpdateMap[id]);
			var isUpdateGlobalBlend: bool = (this._pGlobalComponentBlend !== this._pTechniqueLastGlobalBlendMap[id]);
			var isNeedToUpdatePasses: bool = false;

			if(isTechniqueUpdate || isUpdateGlobalBlend){
				var iEffect:  number  = pRenderTechnique.getMethod().effect.resourceHandle;
				var pEffectBlend: IAFXComponentBlend = this._pEffectResourceToComponentBlendMap[iEffect] || null;
				var pTechniqueBlend: IAFXComponentBlend = this._pTechniqueToOwnBlendMap[id] || null;

				var pNewBlend: IAFXComponentBlend = null;

				pNewBlend = this._pBlender.addBlendToBlend(this._pGlobalComponentBlend, pEffectBlend, 0);
				pNewBlend = this._pBlender.addBlendToBlend(pNewBlend, pTechniqueBlend, 0);

				if(this._pTechniqueToBlendMap[id] !== pNewBlend){
					isNeedToUpdatePasses = true;
				}

				this._pTechniqueToBlendMap[id] = pNewBlend;
				this._pTechniqueNeedUpdateMap[id] = false;
				this._pTechniqueLastGlobalBlendMap[id] = this._pGlobalComponentBlend;
			}

			var pBlend: IAFXComponentBlend = this._pTechniqueToBlendMap[id];

			if(isDefAndNotNull(pBlend)) {
				if(!pBlend.isReadyToUse()){
					isNeedToUpdatePasses = true;
				}

				if(!pBlend.finalizeBlend()){
					return false;
				}

				if(isNeedToUpdatePasses) {
					pRenderTechnique.updatePasses(isTechniqueUpdate);
				}

				pRenderTechnique._setPostEffectsFrom(pBlend.getPostEffectStartPass());
				return true;
			}
			else {
				return false;
			}
		}

		markTechniqueAsNeedUpdate(pRenderTechnique: IRenderTechnique): void {
			this._pTechniqueNeedUpdateMap[pRenderTechnique.getGuid()] = true;
		}

		getPassInputBlendForTechnique(pRenderTechnique: IRenderTechnique, iPass:  number ): IAFXPassInputBlend {
			var id:  number  = pRenderTechnique.getGuid();

			if(!isDef(this._pTechniqueToBlendMap[id])){
				return null;
			}

			return this._pTechniqueToBlendMap[id].getPassInputForPass(iPass);
		}


//-----------------------------------------------------------------------------//
//---------------------------------API for render------------------------------//
//-----------------------------------------------------------------------------//

		applyBufferMap(pMap: IBufferMap): bool {
			this._pCurrentBufferMap = pMap;
			return true;
// var pBufferMap: util.BufferMap = <util.BufferMap>pMap;

// var pState: IPreRenderState = this._pPreRenderState;

// if(pState.isClear){
// 	pState.primType = pBufferMap.primType;
// 	pState.offset = pBufferMap.offset;
// 	pState.length = pBufferMap.length;
// 	pState.index = pBufferMap.index;
// }
// else if(pState.primType !== pBufferMap.primType ||
// 		pState.offset !== pBufferMap.offset ||
// 		pState.length !== pBufferMap.length ||
// 		pState.index !== pBufferMap.index) {

// 	ERROR("Could not blend buffer maps");
// 	return false;
// }

// var pFlows: IDataFlow[] = pBufferMap.flows;

// for(var i: uint = 0; i < pFlows.length; i++){
// 	pState.flows.push(pFlows[i]);
// }

// pState.isClear = false;
		}

		applySurfaceMaterial(pSurfaceMaterial: ISurfaceMaterial): bool {
			this._pCurrentSurfaceMaterial = pSurfaceMaterial;
			return true;
		}

		/**@inline*/  _setCurrentSceneObject(pSceneObject: ISceneObject): void {
			this._pCurrentSceneObject = pSceneObject;
		}

		/**@inline*/  _setCurrentViewport(pViewport: IViewport): void {
			this._pCurrentViewport = pViewport;
		}

		/**@inline*/  _setCurrentRenderableObject(pRenderable: IRenderableObject): void {
			this._pCurrentRenderable = pRenderable;
		}

		/**@inline*/  _getCurrentSceneObject(): ISceneObject {
			return this._pCurrentSceneObject;
		}

		/**@inline*/  _getCurrentViewport(): IViewport {
			return this._pCurrentViewport;
		}

		/**@inline*/  _getCurrentRenderableObject(): IRenderableObject {
			return this._pCurrentRenderable;
		}

		_setDefaultCurrentState(): void {
			this._setCurrentViewport(null);
			this._setCurrentRenderableObject(null);
			this._setCurrentSceneObject(null);
		}


		renderTechniquePass(pRenderTechnique: IRenderTechnique, iPass:  number ): void {
// if(true){
// 	return;
// }
			var pPass: IRenderPass = pRenderTechnique.getPass(iPass);
			var pPassInput: IAFXPassInputBlend = pPass.getPassInput();

			var pPassBlend: IAFXPassBlend = null;
			var pMaker: IAFXMaker = null;

			this.applySystemUnifoms(pPassInput);

// if(!pPassInput._isNeedToCalcShader()){
// 	//TODO: set pShader to shader program by id
// }
// else {
// if(!pPassInput._isNeedToCalcBlend()){
// 	pPassBlend = this._pBlender.getPassBlendById(pPassInput._getLastPassBlendId());
// }
// else {
			var id:  number  = pRenderTechnique.getGuid();
			var pComponentBlend: IAFXComponentBlend = this._pTechniqueToBlendMap[id];
			var pPassInstructionList: IAFXPassInstruction[] = pComponentBlend.getPassListAtPass(iPass);

			this.prepareComposerState();

			pPassBlend = this._pBlender.generatePassBlend(pPassInstructionList, this._pComposerState,
														  pPassInput.foreigns, pPassInput.uniforms);
// }

			if(isNull(pPassBlend)){
				{ logger.setSourceLocation( "fx/Composer.ts" , 584 ); logger.error("Could not render. Error with generation pass-blend."); } ;
				return;
			}

			pMaker = pPassBlend.generateFXMaker(pPassInput,
												this._pCurrentSurfaceMaterial,
												this._pCurrentBufferMap);
			if(isNull(pMaker)){
				return;
			}
// }

//TODO: generate input from PassInputBlend to correct unifoms and attributes list
//TODO: generate RenderEntry

//this.clearPreRenderState();
			var pInput: IShaderInput = pMaker._make(pPassInput, this._pCurrentBufferMap);
			var pRenderer: IRenderer = this._pEngine.getRenderer();
			var pEntry: IRenderEntry = pRenderer.createEntry();

			pEntry.maker = pMaker;
			pEntry.input = pInput;
			pEntry.viewport = this._pCurrentViewport;
			pEntry.bufferMap = this._pCurrentBufferMap;

			this.prepareRenderTarget(pEntry, pRenderTechnique, iPass);

			pRenderer.pushEntry(pEntry);
		}

//-----------------------------------------------------------------------------//
//-----------------------API for load components/AFXEffects--------------------//
//-----------------------------------------------------------------------------//


		_loadEffectFromSyntaxTree(pTree: IParseTree, sFileName: string): bool {
			var pEffect: IAFXEffect = new fx.Effect(this);
// LOG(sFileName, pTree);
			pEffect.setAnalyzedFileName(sFileName);
// LOG("\n\n\n-------------------------Try to analyze '" + sFileName + "'-------------");
			var isOk: bool = pEffect.analyze(pTree);

			if(isOk){
// LOG("------ANALYZE IS GOOD '" + sFileName + "'.")
				var pTechniqueList: IAFXTechniqueInstruction[] = pEffect.getTechniqueList();

				for(var i:  number  = 0; i < pTechniqueList.length; i++){
					isOk = this.initComponent(pTechniqueList[i]);
					if(!isOk){
						{ logger.setSourceLocation( "fx/Composer.ts" , 633 ); logger.warning("Cannot initialize fx-component from technique '" + pTechniqueList[i].getName() + "'."); } ;
						return false;
					}
				}
			}
			else {
				{ logger.setSourceLocation( "fx/Composer.ts" , 639 ); logger.warning("Error are occured during analyze of effect file '" + sFileName + "'."); } ;
				return false;
			}

			return true;
		}


		_loadEffectFromBinary(pData: Uint8Array, sFileName: string): bool {
			return false;
		}

		private initComponent(pTechnique: IAFXTechniqueInstruction): bool {
			var sTechniqueName: string = pTechnique.getName();
			var pComponentPool: IResourcePool = this._pEngine.getResourceManager().componentPool;

			if(!isNull(pComponentPool.findResource(sTechniqueName))){
				return false;
			}

			var pComponent: IAFXComponent = <IAFXComponent>pComponentPool.createResource(sTechniqueName);
			pComponent.create();
			pComponent.setTechnique(pTechnique);

			pTechnique.finalize(this);

			return true;
		}

		private clearPreRenderState(): void {
// this._pPreRenderState.primType = 0;
// this._pPreRenderState.offset = 0;
// this._pPreRenderState.length = 0;
// this._pPreRenderState.index = null;
// this._pPreRenderState.flows.clear(false);

// this._pPreRenderState.isClear = true;
		}

		protected bNormalFix: bool = true;
		protected bUseNormalMap: bool = true;
		protected bIsDebug: bool = false;
		protected bIsRealNormal: bool = false;
		protected bTerrainBlackSectors: bool = false;
		protected bShowTriangles: bool = false;

//sun parameters
		protected kFixNormal:  number  = 0.43;
		protected fSunSpecular:  number  = 0.5;
		protected fSunAmbient:  number  = 0.22;

//fog
		protected cHeightFalloff:  number  = 0.04;
		protected cGlobalDensity:  number  = 0.002;

		_calcRenderID(pSceneObject: ISceneObject, pRenderable: IRenderableObject, bCreateIfNotExists: bool = false):  number  {
//assume, that less than 1024 draw calls may be & less than 1024 scene object will be rendered.
//beacause only 1024

			var iSceneObjectGuid:  number  = !isDefAndNotNull(pSceneObject)? 0: pSceneObject.getGuid();
			var iRenderableObjectGuid:  number  = !isDefAndNotNull(pRenderable)? MAX_UINT32: pRenderable.getGuid();

			if (this._nRidSO ===  1024  || this._nRidRE ===  1024 ) {
				this._pRidTable = <any>{};
				this._nRidRE = 0;
				this._nRidSO = 0;
			}

			var pRidTable: IRIDTable = this._pRidTable;
			var pRidMap: IRIDMap = this._pRidMap;
			var pRidByRenderable: IntMap = pRidTable[iSceneObjectGuid];
			var pRidPair: IRIDPair;

			var iRid:  number  = 0;

			if (!isDefAndNotNull(pRidByRenderable)) {
				if (!bCreateIfNotExists) {
					return 0;
				}

				pRidByRenderable = pRidTable[iSceneObjectGuid] = <any>{};
				pRidByRenderable[0] = this._nRidSO ++;
			}


			iRid = pRidByRenderable[iRenderableObjectGuid];

			if (!isDefAndNotNull(iRid)) {
				if (!bCreateIfNotExists) {
// LOG("here...")
					return 1 + pRidByRenderable[0] * 1024;
				}

				pRidByRenderable[iRenderableObjectGuid] = iRid = 1 + pRidByRenderable[0] * 1024 + this._nRidRE;
				pRidPair = pRidMap[iRid];

				if (!isDefAndNotNull(pRidPair)) {
					pRidPair = pRidMap[iRid] = {renderable: null, object: null};
				}

// LOG("render pair created with id: ", iRid, "roid(", iRenderableObjectGuid, "): ", this._nRidRE, "soid(", iSceneObjectGuid,"): ", pRidByRenderable[0]);

				pRidPair.renderable = pRenderable;
				pRidPair.object = pSceneObject;

				this._nRidRE ++;
			}

			return iRid;
		}

		/**@inline*/  _getRenderableByRid(iRid:  number ): IRenderableObject {
			var pRidPair: IRIDPair = this._pRidMap[iRid];
			var pRenderable: IRenderableObject = isDefAndNotNull(pRidPair)? pRidPair.renderable: null;
			return isNull(pRenderable) || pRenderable.isFrozen()? null: pRenderable;
		}

		/**@inline*/  _getObjectByRid(iRid:  number ): ISceneObject {
			var pRidPair: IRIDPair = this._pRidMap[iRid];
			var pSceneObject: ISceneObject = isDefAndNotNull(pRidPair)? pRidPair.object: null;
			return isNull(pSceneObject) || pSceneObject.isFrozen()? null: pSceneObject;
		}

		private applySystemUnifoms(pPassInput: IAFXPassInputBlend): void {
			if(this._bIsFirstApplySystemUnifoms){
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_ModelMatrix] = VariableDeclInstruction._getIndex("MODEL_MATRIX"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_FramebufferSize] = VariableDeclInstruction._getIndex("FRAMEBUFFER_SIZE"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_ViewportSize] = VariableDeclInstruction._getIndex("VIEWPORT_SIZE"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_ViewMatrix] = VariableDeclInstruction._getIndex("VIEW_MATRIX"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_ProjMatrix] = VariableDeclInstruction._getIndex("PROJ_MATRIX"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_InvViewCameraMat] = VariableDeclInstruction._getIndex("INV_VIEW_CAMERA_MAT"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_CameraPosition] = VariableDeclInstruction._getIndex("CAMERA_POSITION"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_WorldPosition] = VariableDeclInstruction._getIndex("WORLD_POSITION"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_WorldScale] = VariableDeclInstruction._getIndex("WORLD_SCALE"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_WorldOrientation] = VariableDeclInstruction._getIndex("WORLD_ORIENTATION"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_LocalScale] = VariableDeclInstruction._getIndex("LOCAL_SCALE"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_LocalPosition] = VariableDeclInstruction._getIndex("LOCAL_POSITION"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_LocalOrientation] = VariableDeclInstruction._getIndex("LOCAL_ORIENTATION"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_LocalMatrix] = VariableDeclInstruction._getIndex("LOCAL_MATRIX"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_OptimizedProjMatrix] = VariableDeclInstruction._getIndex("OPTIMIZED_PROJ_MATRIX"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_BindShapeMatrix] = VariableDeclInstruction._getIndex("BIND_SHAPE_MATRIX"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_RenderObjectId] = VariableDeclInstruction._getIndex("RENDER_OBJECT_ID"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_WireframeOverlay] = VariableDeclInstruction._getIndex("WIREFRAME_OVERLAY"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_InputTextureSize] = VariableDeclInstruction._getIndex("INPUT_TEXTURE_SIZE"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_InputTextureRatio] = VariableDeclInstruction._getIndex("INPUT_TEXTURE_RATIO"); ;

				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_useNormal] = VariableDeclInstruction._getIndex("useNormal"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_isDebug] = VariableDeclInstruction._getIndex("isDebug"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_isRealNormal] = VariableDeclInstruction._getIndex("isRealNormal"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_normalFix] = VariableDeclInstruction._getIndex("normalFix"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_isWithBalckSectors] = VariableDeclInstruction._getIndex("isWithBalckSectors"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_showTriangles] = VariableDeclInstruction._getIndex("showTriangles"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_u1] = VariableDeclInstruction._getIndex("u1"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_kFixNormal] = VariableDeclInstruction._getIndex("kFixNormal"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_fSunAmbient] = VariableDeclInstruction._getIndex("fSunAmbient"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_fSunSpecular] = VariableDeclInstruction._getIndex("fSunSpecular"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_cHeightFalloff] = VariableDeclInstruction._getIndex("cHeightFalloff"); ;
				this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_cGlobalDensity] = VariableDeclInstruction._getIndex("cGlobalDensity"); ;

				this._bIsFirstApplySystemUnifoms = false;
			}

			var pSceneObject: ISceneObject = this._getCurrentSceneObject();
			var pViewport: IViewport = this._getCurrentViewport();
			var pRenderable: IRenderableObject = this._getCurrentRenderableObject();

			var iRenderableID:  number  = this._calcRenderID(pSceneObject, pRenderable, true);
			var iIndex:  number  = 0;

			if(!isNull(pSceneObject)){
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_ModelMatrix]] = pSceneObject.worldMatrix; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_WorldPosition]] = pSceneObject.worldPosition; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_WorldScale]] = pSceneObject.worldScale; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_WorldOrientation]] = pSceneObject.worldOrientation; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_LocalScale]] = pSceneObject.localScale; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_LocalPosition]] = pSceneObject.localPosition; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_LocalOrientation]] = pSceneObject.localOrientation; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_LocalMatrix]] = pSceneObject.localMatrix; ;
			}

			if(!isNull(pViewport)){
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_FramebufferSize]] = Vec2.stackCeil.set(pViewport.width, pViewport.height) ; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_ViewportSize]] = Vec2.stackCeil.set(pViewport.actualWidth, pViewport.actualHeight) ; ;

				var pCamera: ICamera = pViewport.getCamera();
				if(!isNull(pCamera)) {
					pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_ViewMatrix]] = pCamera.viewMatrix; ;
					pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_ProjMatrix]] = pCamera.projectionMatrix; ;
					pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_InvViewCameraMat]] = pCamera.worldMatrix; ;
					pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_CameraPosition]] = pCamera.worldPosition; ;

					if(pCamera.type === EEntityTypes.SHADOW_CASTER){
						pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_OptimizedProjMatrix]] = (<IShadowCaster>pCamera).optimizedProjection; ;
					}
				}
			}

			if(!isNull(pRenderable)){

				if (render.isMeshSubset(pRenderable) && (<IMeshSubset>pRenderable).isSkinned()){
					pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_BindShapeMatrix]] = (<IMeshSubset>pRenderable).skin.getBindMatrix(); ;
				}

				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_RenderObjectId]] = iRenderableID; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_WireframeOverlay]] = pRenderable["_bWireframeOverlay"]; ;
			}

			if(!isNull(this._pLastRenderTarget)){
				var pLastTexture: ITexture = this._pLastRenderTarget === this._pRenderTargetA ?
												this._pPostEffectTextureA : this._pPostEffectTextureB;

				pPassInput.setTexture("INPUT_TEXTURE", pLastTexture);
				pPassInput.setSamplerTexture("INPUT_SAMPLER", pLastTexture);
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_InputTextureSize]] = Vec2.stackCeil.set(pLastTexture.width, pLastTexture.height) ; ;
				pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_InputTextureRatio]] = Vec2.stackCeil.set(this._pCurrentViewport.actualWidth / pLastTexture.width, this._pCurrentViewport.actualHeight / pLastTexture.height) ;
                                                                                 ;
			}

			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_useNormal]] = this.bUseNormalMap; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_isDebug]] = this.bIsDebug; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_isRealNormal]] = this.bIsRealNormal; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_normalFix]] = this.bNormalFix; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_isWithBalckSectors]] = this.bTerrainBlackSectors; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_showTriangles]] = this.bShowTriangles; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_u1]] = 64; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_kFixNormal]] = this.kFixNormal; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_fSunAmbient]] = this.fSunAmbient; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_fSunSpecular]] = this.fSunSpecular; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_cHeightFalloff]] = this.cHeightFalloff; ;
			pPassInput.uniforms[this._pSystemUniformsNameIndexList[ESystemUniformsIndices.k_cGlobalDensity]] = this.cGlobalDensity; ;

			pPassInput.setUniform("isBillboard", this._pCurrentSceneObject && this._pCurrentSceneObject.isBillboard());
		}

		private prepareComposerState(): void {
			if(!isNull(this._pCurrentRenderable)){
				this._pComposerState.renderable.isAdvancedIndex = this._pCurrentRenderable.data.useAdvancedIndex();
				this._pComposerState.object.isBillboard = this._pCurrentSceneObject && this._pCurrentSceneObject.isBillboard();


				if(render.isMeshSubset(this._pCurrentRenderable) && (<IMeshSubset>this._pCurrentRenderable).isSkinned()){
					this._pComposerState.mesh.isSkinned = true;
					this._pComposerState.mesh.isOptimizedSkinned = (<IMeshSubset>this._pCurrentRenderable).isOptimizedSkinned();
				}
				else {
					this._pComposerState.mesh.isSkinned = false;
					this._pComposerState.mesh.isOptimizedSkinned = false;
				}
			}

			if(!isNull(this._pCurrentSceneObject)){
				if(this._pCurrentSceneObject.type === EEntityTypes.TERRAIN_ROAM){
					this._pComposerState.terrain.isROAM = true;
				}
				else {
					this._pComposerState.terrain.isROAM = false;
				}
			}
		}

		private initPostEffectTextures(): void{
			var pRmgr: IResourcePoolManager = this._pEngine.getResourceManager();
			this._pPostEffectTextureA = pRmgr.createTexture(".global-post-effect-texture-A");
			this._pPostEffectTextureB = pRmgr.createTexture(".global-post-effect-texture-B");

			this._pPostEffectTextureA.create(512, 512, 1, null, ETextureFlags.RENDERTARGET, 0, 0,
								   ETextureTypes.TEXTURE_2D, EPixelFormats.R8G8B8A8);

			this._pPostEffectTextureB.create(512, 512, 1, null, ETextureFlags.RENDERTARGET, 0, 0,
								   ETextureTypes.TEXTURE_2D, EPixelFormats.R8G8B8A8);

// this._pPostEffectTextureA.notifyLoaded();
// this._pPostEffectTextureB.notifyLoaded();

			this._pRenderTargetA = this._pPostEffectTextureA.getBuffer().getRenderTarget();
			this._pRenderTargetB = this._pPostEffectTextureB.getBuffer().getRenderTarget();

			this._pPostEffectDepthBuffer = <webgl.WebGLInternalRenderBuffer>pRmgr.renderBufferPool.createResource(".global-post-effect-depth");
			(<webgl.WebGLInternalRenderBuffer>this._pPostEffectDepthBuffer).create( 0x1902 , 512, 512, false);

			this._pRenderTargetA.attachDepthPixelBuffer(this._pPostEffectDepthBuffer);

			this._pPostEffectViewport = this._pRenderTargetA.addViewport(new render.Viewport(null));
		}

		private resizePostEffectTextures(iWidth:  number , iHeight:  number ): void {
			iWidth = math.ceilingPowerOfTwo(iWidth);
			iHeight = math.ceilingPowerOfTwo(iHeight);

			this._pPostEffectTextureA.reset(iWidth, iHeight);
			this._pPostEffectTextureB.reset(iWidth, iHeight);
		}

		private prepareRenderTarget(pEntry: IRenderEntry, pRenderTechnique: IRenderTechnique, iPass:  number ): void {
			var pRenderer: IRenderer = this._pEngine.getRenderer();

			if(pRenderTechnique.hasPostEffect()){
				if (pEntry.viewport.actualWidth > this._pRenderTargetA.width ||
					pEntry.viewport.actualHeight > this._pRenderTargetA.height) {

					this.resizePostEffectTextures(pEntry.viewport.actualWidth, pEntry.viewport.actualHeight);
				}

				if(pRenderTechnique.isFirstPass(iPass)){
					var pRenderViewport: IViewport = pEntry.viewport;

					pRenderer._setDepthBufferParams(false, false, 0);
					pRenderer._setRenderTarget(this._pRenderTargetA);

					var pViewportState: IViewportState = pRenderViewport._getViewportState();
					this._pPostEffectViewport.setDimensions(0., 0.,
																 pRenderViewport.actualWidth / this._pRenderTargetA.width,
																 pRenderViewport.actualHeight / this._pRenderTargetA.height);
					this._pPostEffectViewport.setDepthParams(pViewportState.depthTest, pViewportState.depthWrite, pViewportState.depthFunction);
					this._pPostEffectViewport.setCullingMode(pViewportState.cullingMode);

// pRenderer._lockRenderTarget();

					if(pRenderViewport.getClearEveryFrame()){
						this._pPostEffectViewport.clear(pViewportState.clearBuffers,
															 pViewportState.clearColor,
															 pViewportState.clearDepth, 0);
					}
					else {
						this._pPostEffectViewport.clear(EFrameBufferTypes.COLOR | EFrameBufferTypes.DEPTH,
															 Color.ZERO,
															 1., 0);
					}

// pRenderer._unlockRenderTarget();					
				}


				if(!pRenderTechnique.isPostEffectPass(iPass)){
					this._pLastRenderTarget = this._pRenderTargetA;
					pEntry.renderTarget = this._pRenderTargetA;

					pEntry.viewport = this._pPostEffectViewport;
				}
				else {
					if(pRenderTechnique.isLastPass(iPass)){
						this._pLastRenderTarget = null;
// pEntry.renderTarget = null;
					}
					else {
						if(this._pLastRenderTarget === this._pRenderTargetA){
							pEntry.renderTarget = this._pRenderTargetB;
							this._pLastRenderTarget = this._pRenderTargetB;
						}
						else {
							pEntry.renderTarget = this._pRenderTargetA;
							this._pLastRenderTarget = this._pRenderTargetA;
						}

						pEntry.viewport = this._pPostEffectViewport;
					}
				}
			}
		}
	}
}

























module akra {


	export interface IDDSCodec extends IImgCodec{

	}


}









//  DDS_header.dwFlags










//  DDS_header.ddspf.dwFlags




















//  DDS_header.dwCaps2









//DDS_header10.dwMiscFlag

















//  DD_Sheader.ddspf.dwFourCC























module akra {

	interface IDDSPixelFormat{
		dwSize : number ;
        dwFlags : number ;
        dwFourCC : number ;
        dwRGBBitCount : number ;
        dwRBitMask : number ;
        dwGBitMask : number ;
        dwBBitMask : number ;
        dwABitMask : number ;
	}

	interface IDDSHeader{
		dwSize:  number ;
        dwFlags:  number ;
        dwHeight:  number ;
        dwWidth:  number ;
        dwPitchOrLinearSize:  number ;
        dwDepth:  number ;
        dwMipMapCount:  number ;
/*Count 11*/
        dwReserved1:  number [];

        ddspf:IDDSPixelFormat;

        dwCaps :  number ;
        dwCaps2 :  number ;
        dwCaps3 :  number ;
        dwCaps4 :  number ;
        dwReserved2 :  number ;
	}

	interface IDDSHeaderDXT10{
		dxgiFormat:  number ;
		resourceDimension: number ;
		miscFlag: number ;
		arraySize: number ;
		reserved: number ;
	}


	export class DDSCodec extends ImgCodec implements IDDSCodec
	{
		private _sType:string="dds";
		private static _pInstance:IDDSCodec=null;

		magicNumberToFileExt(pMagicNumber: Uint8Array):string
		{
			var dwMagic4: number  = (new Uint32Array(pMagicNumber.buffer, 0, 1))[0];
			if( 0x20534444 ==dwMagic4)
			{
				return "dds";
			}

			return null;
		}

/// Static method to startup and register the DDS codec
		static startup():void
		{
			if(!isDefAndNotNull(this._pInstance))
			{
				{ logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 163 ); logger.log("DDS codec registering ..."); } ;
				this._pInstance=new DDSCodec();
				Codec.registerCodec(this._pInstance);
			}
		}
/// Static method to shutdown and unregister the DDS codec
		static shutdown():void
		{
			if(isDef(this._pInstance))
			{
				Codec.unRegisterCodec(this._pInstance);
				this._pInstance=undefined;
			}
		}

		getType():string
    	{
        	return this._sType;
    	}

    	decode(pData: Uint8Array, pImgData: IImgData):Uint8Array
    	{
    		var iOffset: number =0;
    		var dwMagic4: number  = (new Uint32Array(pData.buffer, pData.byteOffset, 1))[0];

    		if(dwMagic4 !==  0x20534444 )
    		{
    			{ logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 190 ); logger.criticalError("This is not a DDS file! DDSCodec.decode"); } ;
    		}
//Считываем dds header
/*typedef struct {
             DWORD           dwSize;
             DWORD           dwFlags;
             DWORD           dwHeight;
             DWORD           dwWidth;
             DWORD           dwPitchOrLinearSize;
             DWORD           dwDepth;
             DWORD           dwMipMapCount;
             DWORD           dwReserved1[11];
             DDS_PIXELFORMAT ddspf;
             DWORD           dwCaps;
             DWORD           dwCaps2;
             DWORD           dwCaps3;
             DWORD           dwCaps4;
             DWORD           dwReserved2;
             } DDS_HEADER;*/


    		var pDDSHeader: Uint32Array = new Uint32Array(pData.buffer, pData.byteOffset + 4, 31);

    		var pHeader: IDDSHeader=<IDDSHeader>{};

    		pHeader.dwSize = pDDSHeader[0];
            pHeader.dwFlags = pDDSHeader[1];
            pHeader.dwHeight = pDDSHeader[2];
            pHeader.dwWidth = pDDSHeader[3];
            pHeader.dwPitchOrLinearSize = pDDSHeader[4];
            pHeader.dwDepth = pDDSHeader[5];
            pHeader.dwMipMapCount = pDDSHeader[6];
            pHeader.dwReserved1=[];
            pHeader.dwReserved1[0] = pDDSHeader[7];
            pHeader.dwReserved1[1] = pDDSHeader[8];
            pHeader.dwReserved1[2] = pDDSHeader[9];
            pHeader.dwReserved1[3] = pDDSHeader[10];
            pHeader.dwReserved1[4] = pDDSHeader[11];
            pHeader.dwReserved1[5] = pDDSHeader[12];
            pHeader.dwReserved1[6] = pDDSHeader[13];
            pHeader.dwReserved1[7] = pDDSHeader[14];
            pHeader.dwReserved1[8] = pDDSHeader[15];
            pHeader.dwReserved1[9] = pDDSHeader[16];
            pHeader.dwReserved1[10] = pDDSHeader[17];
/*struct DDS_PIXELFORMAT {
             DWORD dwSize;
             DWORD dwFlags;
             DWORD dwFourCC;
             DWORD dwRGBBitCount;
             DWORD dwRBitMask;
             DWORD dwGBitMask;
             DWORD dwBBitMask;
             DWORD dwABitMask;
             };*/

            pHeader.ddspf=<IDDSPixelFormat>{};
            pHeader.ddspf.dwSize = pDDSHeader[18];
            pHeader.ddspf.dwFlags = pDDSHeader[19];
            pHeader.ddspf.dwFourCC = pDDSHeader[20];
            pHeader.ddspf.dwRGBBitCount = pDDSHeader[21];
            pHeader.ddspf.dwRBitMask = pDDSHeader[22];
            pHeader.ddspf.dwGBitMask = pDDSHeader[23];
            pHeader.ddspf.dwBBitMask = pDDSHeader[24];
            pHeader.ddspf.dwABitMask = pDDSHeader[25];
            pHeader.dwCaps = pDDSHeader[26];
            pHeader.dwCaps2 = pDDSHeader[27];
            pHeader.dwCaps3 = pDDSHeader[28];
            pHeader.dwCaps4 = pDDSHeader[29];
            pHeader.dwReserved2 = pDDSHeader[30];
            iOffset += 128;
            if (pHeader.dwSize != 124) {
                    { logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 259 ); logger.error("Размер заголовка DDS всегда должэен равняться 124"); } ;
            }
            if(pHeader.ddspf.dwSize!= 32){
            	{ logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 262 ); logger.error("Размер DDS_PIXELFORMAT всегда должен равняться 32"); } ;
            }
            if (!(pHeader.dwFlags &  0x00000001 )) {
                { logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 265 ); logger.error("Флаг DDSD_CAPS в заголовке DDS всегда должен быть"); } ;
            }
            if (!(pHeader.dwFlags &  0x00000002 )) {
                { logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 268 ); logger.error("Флаг DDSD_HEIGHT в заголовке DDS всегда должен быть"); } ;
            }
            if (!(pHeader.dwFlags &  0x00000004 )) {
                { logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 271 ); logger.error("Флаг DDSD_WIDTH в заголовке DDS всегда должен быть"); } ;
            }
            if (!(pHeader.dwFlags &  0x00001000 )) {
                { logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 274 ); logger.error("Флаг DDSD_PIXELFORMAT в заголовке DDS всегда должен быть"); } ;
            }

            pImgData.width = pHeader.dwWidth;
            pImgData.height = pHeader.dwHeight;
            pImgData.depth = 1;
            var nFace:  number  = 1;

            pImgData.flags=0;

            if (pHeader.dwCaps2 &  0x200 )
			{
				pImgData.flags |=  EImageFlags.CUBEMAP;
				nFace=0;
                if (pHeader.dwCaps2 &  0x400 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.POSITIVE_X;
                }
                if (pHeader.dwCaps2 &  0x800 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.NEGATIVE_X;
                }
                if (pHeader.dwCaps2 &  0x1000 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.POSITIVE_Y;
                }
                if (pHeader.dwCaps2 &  0x2000 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.NEGATIVE_Y;
                }
                if (pHeader.dwCaps2 &  0x4000 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.POSITIVE_Z;
                }
                if (pHeader.dwCaps2 &  0x8000 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.NEGATIVE_Z;
                }

                if(nFace==0){
                	{ logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 314 ); logger.warning("Выставлен фдлаг с кубической текстурой, а самих текстур нету"); } ;
                }
			}

			if (pHeader.dwCaps2 &  0x200000 )
			{
				pImgData.flags|=EImageFlags.TEXTURE_3D;
				pImgData.depth= pHeader.dwDepth;
			}

			var eSourceFormat:EPixelFormats=EPixelFormats.UNKNOWN;

			if (pHeader.ddspf.dwFlags &  0x00000004 ) {
				if (pHeader.ddspf.dwFourCC ==  0x31545844 ) {
				    eSourceFormat = EPixelFormats.DXT1;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x32545844 ) {
				    eSourceFormat = EPixelFormats.DXT1;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x33545844 ) {
				    eSourceFormat = EPixelFormats.DXT3;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x34545844 ) {
				    eSourceFormat = EPixelFormats.DXT4;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x35545844 ) {
				    eSourceFormat = EPixelFormats.DXT5;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x30315844 ) {
				    var pDDS10Header: Uint32Array = new Uint32Array(pData.buffer, pData.byteOffset + 128, 5);
				    var header10:IDDSHeaderDXT10 = <IDDSHeaderDXT10>{};
				    header10.dxgiFormat = pDDS10Header[0];
				    header10.resourceDimension = pDDS10Header[1];
				    header10.miscFlag = pDDS10Header[2];
				    header10.arraySize = pDDS10Header[3];
				    header10.reserved = pDDS10Header[4];

				    { logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 351 ); logger.criticalError("Формат D3DFMT_DX10 не поддерживается"); } ;
/*console.log("dxgiFormat",header10.dxgiFormat);
				     console.log("resourceDimension",header10.resourceDimension);					
				     nCubeMap=1;
				     if(header10.miscFlag&RESOURCE_MISC_TEXTURECUBE)
				     {
				     nCubeMap=header10.arraySize;
				     }

				     if(nCubeMap!=6)
				     {
				     warning("Количество частей кубической текстуру не равно 6",nCubeMap);						
				     }*/

				    iOffset += 20;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x0000006F )
				{
					eSourceFormat=EPixelFormats.FLOAT16_R;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000070 )
				{
					eSourceFormat=EPixelFormats.FLOAT16_GR;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000071 )
				{
					eSourceFormat=EPixelFormats.FLOAT16_RGBA;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000072 )
				{
					eSourceFormat=EPixelFormats.FLOAT32_R;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000073 )
				{
					eSourceFormat=EPixelFormats.FLOAT32_GR;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000074 )
				{
					eSourceFormat=EPixelFormats.FLOAT32_RGBA;
				}
				else {
				    { logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 391 ); logger.criticalError("Флаг DDPF_FOURCC стоит, а подходящего dwFourCC нет"); } ;
				}
			}
			else
			{
				var iAMask=pHeader.ddspf.dwFlags &  0x00000001  ? pHeader.ddspf.dwABitMask:0;
				var ePF:EPixelFormats;
				for (ePF= EPixelFormats.UNKNOWN + 1; ePF < EPixelFormats.TOTAL; ePF++)
				{


					if((!!(pHeader.ddspf.dwFlags& 0x00020000 ))!=pixelUtil.isLuminance(ePF))
					{
						continue;
					}
					if((!!(pHeader.ddspf.dwFlags& 0x00000001 ))!=pixelUtil.hasAlpha(ePF))
					{
						continue;
					}


					if (pixelUtil.getNumElemBits(ePF) == pHeader.ddspf.dwRGBBitCount)
					{
						var pTestMasks: number []=pixelUtil.getBitMasks(ePF);
						var pTestBits: number []=pixelUtil.getBitDepths(ePF);

						if (pTestMasks[0] == pHeader.ddspf.dwRBitMask && pTestMasks[1] == pHeader.ddspf.dwGBitMask &&
							pTestMasks[2] == pHeader.ddspf.dwBBitMask &&
// for alpha, deal with 'X8' formats by checking bit counts
							(pTestMasks[3] == iAMask || (iAMask == 0 && pTestBits[3] == 0)))
						{
							break;
						}
					}

				}

				if(ePF==EPixelFormats.TOTAL)
				{
					{ logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 430 ); logger.criticalError("Cannot determine pixel format. DDSCodec.decode"); } ;
				}
				else
				{
					eSourceFormat=ePF;
				}
			}



/*if (pixelUtil.isCompressed(eSourceFormat))
			{				
				pImgData.flags |= EImageFlags.COMPRESSED;
				if (!(pHeader.dwFlags & DDSD_LINEARSIZE)) {
                    CRITICAL_ERROR("У сжатой текстуры не выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");
                }
			}
			else
			{
				if (pHeader.dwFlags & DDSD_LINEARSIZE) {
                	CRITICAL_ERROR("У несжатой текстуры выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");
            	}
			}*/


			pImgData.format = eSourceFormat;

			if (pHeader.dwFlags &  0x00020000 ) {
                pImgData.numMipMaps = pHeader.dwMipMapCount-1;
                if (pImgData.numMipMaps!=core.pool.resources.Img.getMaxMipmaps(pImgData.width,pImgData.height,pImgData.depth,pImgData.format)) {
                { logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 460 ); logger.warning("Number of mipmaps are not to degrease image size to 1x1 " + pHeader.dwMipMapCount + "," + pHeader.dwWidth + "x" + pHeader.dwHeight + ")"); }
                                                                                                           ;

            	}
            }
            else{
                pImgData.numMipMaps = 0;
            }

			var pOutput:Uint8Array=new Uint8Array(pImgData.size)
			var iOutputOffset: number =0;

			for(var i: number =0;i<nFace;i++)
			{
				var iWidth: number =pImgData.width;
				var iHeight: number =pImgData.height;
				var iDepth: number =pImgData.depth;

				for(var iMip: number =0;iMip<=pImgData.numMipMaps;iMip++)
				{

					if(pixelUtil.isCompressed(pImgData.format))
					{
						var iDXTSize: number =pixelUtil.getMemorySize(iWidth, iHeight, iDepth, pImgData.format);
						for(var a: number =0;a<iDXTSize;a++)
						{
							pOutput[a+iOutputOffset]=pData[iOffset+a];

						}
						iOffset+=iDXTSize;
						iOutputOffset+=iDXTSize;

					}
					else
					{
						var iDstPitch: number =iWidth*pixelUtil.getNumElemBytes(pImgData.format);
						var iSrcPitch: number =0;
						if (pHeader.dwFlags &  0x00000008 )
						{
							iSrcPitch = pHeader.dwPitchOrLinearSize / Math.max(1, iMip * 2);
						}
						else
						{
// assume same as final pitch
							iSrcPitch = iDstPitch;
						}
						if (iSrcPitch<iDstPitch)
						{
							{ logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 507 ); logger.warning("Странный размер питча у картинки"); }
						}

						for (var z: number  = 0; z < pImgData.depth; z++)
						{
							for (var y: number  = 0; y < pImgData.height; y++)
							{

								for(var a: number =0;a<iDstPitch;a++)
								{
									pOutput[a+iOutputOffset]=pData[iOffset+a];
								}
								iOutputOffset = iOutputOffset + iDstPitch;
								iOffset=iOffset+iSrcPitch;
							}
						}

					}
					if(iWidth!=1)
					{
						iWidth=Math.floor(iWidth/2);
					}
					if(iHeight!=1)
					{
						iHeight=Math.floor(iHeight/2);
					}
					if(iDepth!=1)
					{
						iDepth=Math.floor(iDepth/2);
					}
				}
			}
			return pOutput;
		}



	}





}





//include sub creation classes.
























module akra {
    export enum EDependenceStatuses {
        NOT_LOADED,
        LOADING,
        CHECKING,
        UNPACKING,
        LOADED
    }

    export interface IDep {
//system
        index?:  number ;
        deps?: IDependens;

//additional
        status?: EDependenceStatuses;
        content?: any;

//user
        path: string;
        name?: string;
        comment?: string;
        type?: string;
    }

	export interface IDependens {
        parent?: IDependens;
        depth?:  number ;

        loaded?:  number ;
        total?:  number ;

//user
        files?: IDep[];
        deps?: IDependens;
        root?: string;
    }

    export interface IDepsManager extends IEventProvider {
    	load(pDeps: IDependens, sRoot?: string): bool;
    }
}



















module akra.util.deps {

	export interface IScriptInfo {
		path?: string;
		scripts: string[];
	}

	var readyRegExp: RegExp = navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/;

	function removeListener(node: HTMLScriptElement, func: EventListener, name: string, ieName?: string) {
//Favor detachEvent because of IE9
//issue, see attachEvent/addEventListener comment elsewhere
//in this file.
        if (node.detachEvent && !info.is.Opera) {
//Probably IE. If not it will throw an error, which will be
//useful to know.
            if (ieName) {
                node.detachEvent(ieName, func);
            }
        } else {
            node.removeEventListener(name, func, false);
        }
    }

    function removeCallbacks(e: Event, callback: EventListener) {
    	var node: HTMLScriptElement = <HTMLScriptElement>(e.currentTarget || e.srcElement);

    	removeListener(node, callback, "load", "onreadystatechange");
        removeListener(node, callback, "error");
    }

	export function requireJS(
		url: string,
		callback: (err: Event, script: HTMLScriptElement) => void,
		parent: HTMLElement = null): void {

	    var script: HTMLScriptElement = <HTMLScriptElement>document.createElement("script");
	    script.type = "text/javascript";
	    script.charset = "utf-8";
        script.async = true;

        var fnScriptLoad: EventListener,
        	fnScriptError: EventListener;

        fnScriptLoad = (e: Event): void => {
        	if (e.type === "load" ||
                    (readyRegExp.test(<string>(<any>(e.currentTarget || e.srcElement)).readyState))) {

        		removeCallbacks(e, <EventListener>callback);
        		callback(null, script);
            }
        };

        fnScriptError = (e: Event): void => {
        	removeCallbacks(e, <EventListener>callback);
        	callback(e, null);
        }

	    if (script.readyState) {
//IE
	        script.onreadystatechange = fnScriptLoad;
	    }
	    else {
//Others
	        script.onload = fnScriptLoad;
	    }

		script.onerror = <EventListener>callback;


	    script.src = url;

	    if (isNull(parent)) {
	    	parent = <HTMLElement>document.getElementsByTagName("head")[0];
	    }

	    parent.appendChild(script);
	}

	export function js(url: string, callback: (err: Event, scripts: HTMLScriptElement[]) => void): void;
	export function js(info: IScriptInfo, callback: (err: Event, scripts: HTMLScriptElement[]) => void): void;
	export function js(arg: any, callback: (err: Event, scripts: HTMLScriptElement[]) => void): void {
		var info: IScriptInfo;

		if (isString(arguments[0])) {
			info = {
				path: akra.DATA,
				scripts: [arguments[0]]
			};
		}
		else {
			info = <IScriptInfo>arguments[0];
		}

		var iCurrentScript:  number  = 0;
		var pScripts: HTMLScriptElement[] = [];
		var fnLoad: (e: Event, pScript: HTMLScriptElement) => void;

		var fnStart = () => {
			requireJS(path.resolve(info.scripts[iCurrentScript], info.path || null), fnLoad);
		}

		fnLoad = (e: Event, pScript: HTMLScriptElement): void => {
			if (e) {
				callback(e, null);
			}

			pScripts.push(pScript);

			if ((++iCurrentScript) < info.scripts.length) {
				fnStart();
			}
			else {
				callback(null, pScripts);
			}
		};

		fnStart();
	}

	export function css(url: string): void {
	    var link: HTMLLinkElement = <HTMLLinkElement>document.createElement("link");
	    link.type = "text/css";
	    link.rel = "stylesheet";
	    link.href = url;

	    document.getElementsByTagName("head")[0].appendChild(link);
	}
}







declare function unescape(s: string): string;

module akra.util.deps {
	export enum EStates {
		IDLE,
		LOADING
	}

	export var FORCE_ETAG_CHECKING: bool = true;

	function utf8_to_b64( str: string ): string {
	    return window.btoa(unescape(encodeURIComponent( str )));
	}

	function findLastLevel(pDeps: IDependens) {
		var c: IDependens = pDeps;

		while (isDefAndNotNull(c)) {
			if (!isDefAndNotNull(c.deps)) {
				return c;
			}

			c = c.deps;
		}

		return c;
	}

	function findFirstLevel(pDeps: IDependens) {
		var c: IDependens = pDeps;

		while (isDefAndNotNull(c)) {
			if (!isDefAndNotNull(c.parent))
				return c;

			c = c.parent;
		}

		return c;
	}

	function createARADLocalName(sFilename: string, sEntry: string): string {
		return "filesystem:" + info.uri.scheme + "//" + info.uri.host + "/temporary/" + sEntry + "/" + sFilename;
	}


	function calcDepth(pDeps: IDependens):  number  {
		var c: IDependens = pDeps;
		var d:  number  = 0;

		while (isDefAndNotNull(c)) {
			d ++;
			c = c.deps;
		}

		return d;
	}


	class Manager implements IDepsManager {
		protected _eState: EStates = EStates.IDLE;
		protected _pEngine: IEngine;
		protected _pDeps: IDependens = null;
		protected _sRoot: string = null;

		/**@inline*/  get root(): string { return this._sRoot; }

		constructor (pEngine: IEngine) {
			this._pEngine = pEngine;
		}



		/**@inline*/  getEngine(): IEngine { return this._pEngine; }

		load(pDeps: IDependens, sRoot: string = akra.DATA): bool {
			if (!isDefAndNotNull(pDeps)) {
				return false;
			}

			if (this._eState !== EStates.IDLE) {
				{ logger.setSourceLocation( "util/deps/Manager.ts" , 98 ); logger.warning("deps manager in loading state"); } ;
				return false;
			}

			this._eState = EStates.LOADING;
			this._sRoot = sRoot;

			this.normalizeDeps(pDeps, pDeps.root || sRoot);
			this.createResources(pDeps);
			this.loadDeps(pDeps);

			return true;
		}

		walk(pDeps: IDependens,
			fn: (pDeps: IDependens, i:  number , iDepth:  number , pParentDeps: IDependens) => void,
			iDepth:  number  = 0,
			fnEnd: Function = null,
			pParentDeps: IDependens = null): void {

			var pFiles: IDep[] = pDeps.files;

			if (isDefAndNotNull(pFiles)) {
//normilize pathes to deps
				for (var i:  number  = 0; i < pFiles.length; ++ i) {
					fn.call(this, pDeps, i, iDepth, pParentDeps);
				}
			}

			if (isDefAndNotNull(pDeps.deps)) {
				this.walk(pDeps.deps, fn, ++ iDepth, fnEnd, pDeps);
			}
			else if (isFunction(fnEnd)) {
				fnEnd.call(this);
			}
		}

		each(pDeps: IDependens, fn: (pDep: IDep) => void): void {
			this.walk(pDeps, (pDeps: IDependens, i:  number ): void => {
				fn(pDeps.files[i]);
			});
		}

		private changeDepStatus(pDep: IDep, eStatus: EDependenceStatuses, pInfo: any = null): void {
			pDep.status = eStatus;

			if (eStatus === EDependenceStatuses.LOADED) {
				pDep.deps.loaded ++;
			}

			this.statusChanged(pDep, pInfo);

			if (eStatus === EDependenceStatuses.LOADED) {
				this.dependencyLoaded(pDep);
			}
		}

		private normalizeDeps(pDeps: IDependens, sRoot: string, iDepth:  number  = 0): void {
			sRoot = isString(sRoot)? sRoot: document.location.pathname;

			this.eachDeps(pDeps, (pDeps: IDependens, pParentDeps: IDependens): void => {
				pDeps.loaded = 0;
				pDeps.total = isArray(pDeps.files)? pDeps.files.length: 0;

				pDeps.parent = pParentDeps;
				pDeps.depth = isNull(pParentDeps)? iDepth: pParentDeps.depth + 1;
			});

			this.walk(pDeps, (pDeps: IDependens, i:  number , iDepth:  number ): void => {
				var pDep: IDep = pDeps.files[i];

				pDep.index = i;
				pDep.deps = pDeps;

				pDep.status = EDependenceStatuses.NOT_LOADED;
				pDep.path = path.resolve(pDeps.files[i].path, pDeps.root || sRoot);
			});
		}

		private eachDeps(pDeps: IDependens, fn: (pDeps: IDependens, pParentDeps: IDependens) => void): void {
			var p: IDependens = pDeps.parent || null;
			var c: IDependens = pDeps;

			while (isDefAndNotNull(c)) {
				fn(c, p);
				p = c;
				c = c.deps;
			}
		}


		private linkDeps(pParent: IDependens, pChild: IDependens): void {
			pParent = findLastLevel(pParent);
			pParent.deps = pChild;

			this.eachDeps(findFirstLevel(pParent), (pDeps: IDependens, pParentDeps: IDependens) => {
				pDeps.depth = isNull(pParentDeps)? 0: pParentDeps.depth + 1;
				pDeps.parent = pParentDeps;
			});
		}

		createResources(pDeps: IDependens): void {
			var pRmgr: IResourcePoolManager = this.getEngine().getResourceManager();
			this.each(pDeps, (pDep: IDep): void => {
				var sResource: string = pDep.name || pDep.path;

				switch ((path.info(pDep.path).ext || pDep.type || "").toLowerCase()) {
					case "fx":
					case "afx":
						if (!pRmgr.effectDataPool.findResource(sResource)) {
							pRmgr.effectDataPool.createResource(sResource);
						}
						break;
					case "jpg":
					case "jpeg":
					case "png":
					case "bmp":
					case "gif":
					case "dds":
						if (!pRmgr.imagePool.findResource(sResource)) {
							pRmgr.imagePool.createResource(sResource);
						}
						break;
					case "dae":
						if (!pRmgr.colladaPool.findResource(sResource)) {
							pRmgr.colladaPool.createResource(sResource);
						}
						break;
				}
			});
		}

		private  /**@inline*/  getResourceManager(): IResourcePoolManager {
			return this.getEngine().getResourceManager();
		}

		private loadMap(pDep: IDep): void {
			var pFile: IFile = io.fopen(pDep.path, "rj");

			pFile.read((pErr: Error, pMap: IDependens): void => {
				if (!isNull(pErr)) {
					this.error(pErr);
				}

				pFile.close();


				var pCurrDeps: IDependens = pDep.deps;
				var pNextDeps: IDependens = pCurrDeps.deps;

				this.normalizeDeps(pMap, pDep.path, pCurrDeps.depth + 1);
				this.createResources(pMap);

				var iMapDepth:  number  = calcDepth(pMap);

				pCurrDeps.deps = null;

				this.linkDeps(pCurrDeps, pMap);
				this.linkDeps(pCurrDeps, pNextDeps);

				this.changeDepStatus(pDep, EDependenceStatuses.LOADED);
			});
		}

		private loadGrammar(pDep: IDep): void {
			var pGrammar: IFile = io.fopen(pDep.path, "r");

			pGrammar.read((e: Error, sData: string): void => {
				if (!isNull(e)) {
					this.error(e);
				}

//WARNING: only for HLSL grammar files.
				util.initAFXParser(sData);

				this.changeDepStatus(pDep, EDependenceStatuses.LOADED);
				pGrammar.close();
			});
		}


		private forceExtractARADependence(pEntry: ZipEntry, sPath: string, fnCallback: Function): void {
// console.log("forceExtractARADependence(", pEntry.filename, ")");

			pEntry.getData(new zip.ArrayBufferWriter(), (data: ArrayBuffer): void => {
// console.log(sPath);
				console.log("forceExtractARADependence(", sPath, ")");
				var pCopy: IFile = fopen(sPath, "w+b");

				pCopy.write(data, (e: Error) => {
					if (e) throw e;

					{ logger.setSourceLocation( "util/deps/Manager.ts" , 290 ); logger.log("unpacked to local filesystem: ", pEntry.filename); } ;
// alert("unpacked to local filesystem: " + pEntry.filename);

					var pCrc32: IFile = fopen(sPath + ".crc32", "w+");
					pCrc32.write(String(pEntry.crc32), (e: Error) => {
						if (e) throw e;
						fnCallback(sPath);
						pCrc32.close();
					});

					pCopy.close();
				});


			});
		}

		private extractARADependence(pEntry: ZipEntry, sHash: string, fnCallback: Function): void {
			var sPath: string = createARADLocalName(pEntry.filename, sHash);
			var pCRC32File: IFile = fopen(sPath + ".crc32", "r");

			pCRC32File.isExists((e: Error, bExists: bool) => {
				if (bExists) {
					pCRC32File.read((e: Error, data: string) => {
						if (parseInt(data) === pEntry.crc32) {
							console.log("skip unpacking for dep.: ", sPath);
							fnCallback(sPath);
						}
						else {
							this.forceExtractARADependence(pEntry, sPath, fnCallback);
						}

						pCRC32File.close();
					});

					return;
				}

				this.forceExtractARADependence(pEntry, sPath, fnCallback);
			});
		}

//TODO: CREATE CORRECT UNPACKING FOR DATA_URI RESOURCES, NOW USED UNSAFE HASH <TMP>
//NEEED UNIQUE HASH!!!!

		private loadARA(pArchiveDep: IDep): void {
			if (!info.api.zip) {

				js({path: this.root + "/3d-party/zip.js/", scripts: ["zip.js", "zip-ext.js"]}, (e: Event): void => {
					{ logger.setSourceLocation( "util/deps/Manager.ts" , 339 ); logger.assert(isNull(e), "Zip loader must be specified"); } ;
					zip.workerScriptsPath = this.root + "/3d-party/zip.js/";

					this.loadARA(pArchiveDep);
				});

				return;
			}

			var sArchivePath: string = pArchiveDep.path;
//hash is required to create a unique path for the local file system
			var sArchiveHash: string = "tmp";
			var pArchive: IFile = null;
			var pPrimaryDep: IDependens = pArchiveDep.deps;
//binary data obtained immediately from the DATA URI
			var pUri: IDataURI = null;
			var sBase64Data: string = null;

//api method very slow in this case: 
//		path.uri(sArchivePath).scheme === "data:" 
			if (sArchivePath.substr(0, 5) === "data:") {
//is data URI
//data URI required cross-origin policy, and cannot be loaded with XMLHTTPRequest :(

				pUri = path.decodeDataURI(sArchivePath);
				{ logger.setSourceLocation( "util/deps/Manager.ts" , 364 ); logger.assert(pUri.base64, "only base64 decoded ARA resources supported.", sArchivePath); } ;
				sBase64Data = pUri.data;
			}
			else {
				sArchiveHash = utf8_to_b64(sArchivePath);
				pArchive = io.fopen(sArchivePath, "rb");
			}



			this.changeDepStatus(pArchiveDep, EDependenceStatuses.CHECKING);

			var fnArchiveLoaded = (pARADeps: IDependens): void => {
				this.linkDeps(pPrimaryDep, pARADeps);

				this.createResources(pARADeps);
				this.changeDepStatus(pArchiveDep, EDependenceStatuses.LOADED);
			}

			var fnLoadArchive = (): void => {
				this.changeDepStatus(pArchiveDep, EDependenceStatuses.LOADING);

				var fnZipReadedCallback = (pZipReader: ZipReader): void => {
					pZipReader.getEntries((pEntries: ZipEntry[]): void => {

						var pEntryMap: {[path: string]: ZipEntry;} = {};
						var nTotal:  number  = 0;
						var nUnpacked:  number  = 0;

						for (var i:  number  = 0; i < pEntries.length; ++ i) {
							if (pEntries[i].directory) continue;
							pEntryMap[pEntries[i].filename] = pEntries[i];
							nTotal ++;
						}

						var pMapEntry: ZipEntry = pEntryMap[ ".map" ];

						{ logger.setSourceLocation( "util/deps/Manager.ts" , 401 ); logger.assert(isDefAndNotNull(pMapEntry), "ARA dependences found, but headers corrupted."); } ;

						pMapEntry.getData(new zip.TextWriter(), (data: string): void => {
							var pARADeps: IDependens = <IDependens>JSON.parse(data);

							var fnSuccesss: Function = (sLocalPath: string): void => {
								nUnpacked ++;

								this.changeDepStatus(pArchiveDep, EDependenceStatuses.UNPACKING, {loaded: nUnpacked, total: nTotal});

								if (nUnpacked < nTotal) return;

								console.log("ARA dependences successfully loaded: ", sArchivePath);
// alert("ARA dependences successfully loaded: " + sArchivePath);

								pZipReader.close();
//id data-uri used, archive is null
								pArchive && pArchive.close();

								fnArchiveLoaded(pARADeps);
							};

							this.normalizeDeps(pARADeps, "");
							this.each(pARADeps, (pDep: IDep): void => {
								var sPath: string = pDep.path;
								var pEntry: ZipEntry = pEntryMap[sPath];

								{ logger.setSourceLocation( "util/deps/Manager.ts" , 428 ); logger.assert(isDefAndNotNull(pEntry), "Cannot resolve ARA dependence: " + sPath); } ;
								delete pEntryMap[sPath];

								this.extractARADependence(pEntry, sArchiveHash, (sLocalPath: string): void => {
									pDep.path = sLocalPath;
									fnSuccesss(sLocalPath);
								});
							});

							for (var sPath in pEntryMap) {
// console.log("unmapped deps: ", sPath);
								this.extractARADependence(pEntryMap[sPath], sArchiveHash, fnSuccesss);
							}
						});
					});
				};

				var fnDataURIReaded = (sBase64Data: string): void => {
					this.changeDepStatus(pArchiveDep, EDependenceStatuses.UNPACKING);

					zip.createReader(new zip.Data64URIReader(sBase64Data),
						fnZipReadedCallback,
						(err: Error): void => {
							console.log(err);
						}
					);
				}


				var fnArchiveReadedCallback = (err: Error, pData: ArrayBuffer): void => {

					this.changeDepStatus(pArchiveDep, EDependenceStatuses.UNPACKING);

					zip.createReader(new zip.ArrayBufferReader(pData),
						fnZipReadedCallback,
						(err: Error): void => {
							console.log(err);
						}
					);
				}

				if (pArchive) {
					pArchive.read(fnArchiveReadedCallback, (nLoaded:  number , nTotal:  number ): void => {
						this.changeDepStatus(pArchiveDep, EDependenceStatuses.LOADING, {loaded: nLoaded, total: nTotal});
					});
				}
				else {
					fnDataURIReaded(sBase64Data);
				}
			}

			if (!isNull(pArchive)) {
//non data-uri cases
				pArchive.open((err: Error, pMeta: IFileMeta): void => {
					if (FORCE_ETAG_CHECKING) {
						var pETag: IFile = fopen(createARADLocalName( ".etag" , sArchiveHash), "r+");

						pETag.read((e: Error, sETag: string) => {
							if (!isNull(e) || !isString(pMeta.eTag) || sETag !== pMeta.eTag) {
								{ logger.setSourceLocation( "util/deps/Manager.ts" , 487 ); logger.log(sArchivePath, "ETAG not verified.", pMeta.eTag); } ;

								if (isDefAndNotNull(pMeta.eTag)) {
									pETag.write(pMeta.eTag);
								}

								fnLoadArchive();
								return;
							}

							{ logger.setSourceLocation( "util/deps/Manager.ts" , 497 ); logger.log(sArchivePath, "ETAG verified successfully!", sETag); } ;

							fopen(createARADLocalName( ".map" , sArchiveHash), "rj").read((e: Error, pMap: IDependens): void => {
								this.normalizeDeps(pMap, "");
								this.each(pMap, (pDep: IDep): void => {
									pDep.path = createARADLocalName(pDep.path, sArchiveHash);
								});

								fnArchiveLoaded(pMap);
							});
						});
					}
					else {
						fnLoadArchive();
					}
				});
			}
			else {
				fnLoadArchive();
			}
		}



		private loadAFX(pDep: IDep): void {
			var sResource: string = pDep.name || pDep.path;
			var pRes: IResourcePoolItem = this.getResourceManager().effectDataPool.findResource(sResource);

			if (pRes.loadResource(pDep.path)) {
				this.handleResourceEventOnce(pRes,  "loaded" , (pItem: IResourcePoolItem): void => {
						this.changeDepStatus(pDep, EDependenceStatuses.LOADED);
					}
				);
			}
			else {
				this.error(new Error("could not load resource: " + pDep.path));
			}
		}

		private loadImage(pDep: IDep): void {
			var sResource: string = pDep.name || pDep.path;
			var pRes: IResourcePoolItem = this.getResourceManager().imagePool.findResource(sResource);

			if (pRes.loadResource(pDep.path)) {
				this.handleResourceEventOnce(pRes,  "loaded" , (pItem: IResourcePoolItem): void => {
					this.changeDepStatus(pDep, EDependenceStatuses.LOADED);
				});
			}
			else {
				this.error(new Error("could not load resource: " + pDep.path));
			}
		}

		private loadDAE(pDep: IDep): void {
			var sResource: string = pDep.name || pDep.path;
			var pRes: IResourcePoolItem = this.getResourceManager().colladaPool.findResource(sResource);

			if (pRes.loadResource(pDep.path)) {
				this.handleResourceEventOnce(pRes,  "loaded" , (pItem: IResourcePoolItem): void => {
						this.changeDepStatus(pDep, EDependenceStatuses.LOADED);
				});
			}
			else {
				this.error(new Error("could not load resource: " + pDep.path));
			}
		}

		private loadCustom(pDep: IDep): void {
			var pFile: IFile = io.fopen(pDep.path, "r");

			pFile.read((pErr: Error, sData: string): void => {
				if (!isNull(pErr)) {
					this.error(pErr);
				}

				pFile.close();

				pDep.content = sData;
				this.changeDepStatus(pDep, EDependenceStatuses.LOADED);
			});
		}

		private loadJSON(pDep: IDep): void {
			var pFile: IFile = io.fopen(pDep.path, "rj");

			pFile.read((pErr: Error, pData: Object): void => {
				if (!isNull(pErr)) {
					this.error(pErr);
				}

				pFile.close();
				pDep.content = pData;
				this.changeDepStatus(pDep, EDependenceStatuses.LOADED);
			});
		}

		private loadBSON(pDep: IDep): void {
			var pFile: IFile = io.fopen(pDep.path, "rb");

			pFile.read((pErr: Error, pBuffer: ArrayBuffer): void => {
				if (!isNull(pErr)) {
					this.error(pErr);
				}

				pFile.close();
				pDep.content = akra.io.undump(pBuffer);

				this.changeDepStatus(pDep, EDependenceStatuses.LOADED);
			});
		}

		private loadDeps(pDeps: IDependens): void {
//if got empty dependency.
			if (!isArray(pDeps.files) || pDeps.files.length === 0) {
				if (isDefAndNotNull(pDeps.deps)) {
					this.loadDeps(pDeps.deps);
				}
				else {
					this.loaded(pDeps);
				}
			}

//walk single deps level
			this.each({files: pDeps.files}, (pDep: IDep): void => {
				this.changeDepStatus(pDep, EDependenceStatuses.LOADING);

				switch ((path.info(pDep.path).ext || pDep.type || "").toLowerCase()) {
					case "ara":
//akra resource archive
						this.loadARA(pDep);
						break;
					case "gr":
						this.loadGrammar(pDep);
						break;
					case "fx":
					case "afx":
						this.loadAFX(pDep);
						break;
					case "jpeg":
					case "jpg":
					case "png":
					case "gif":
					case "bmp":
					case "dds":
						this.loadImage(pDep);
						break;
					case "dae":
						this.loadDAE(pDep);
						break;
					case "json":
						this.loadJSON(pDep);
						break;
					case "bson":
						this.loadBSON(pDep);
						break;
					case "txt":
						this.loadCustom(pDep);
						break;
					case "map":
						this.loadMap(pDep);
						break;
					default:
						{ logger.setSourceLocation( "util/deps/Manager.ts" , 659 ); logger.warning("dependence " + pDep.path + " unknown, and will be skipped."); } ;
				}

			});
		}

		private handleResourceEventOnce(pRsc: IResourcePoolItem, sSignal: string, fnHandler: (pItem: IResourcePoolItem) => void): void {
			var fn: (pItem: IResourcePoolItem) => void;

			fn = (pItem: IResourcePoolItem): void => {
				fnHandler(pItem);
				pRsc.unbind(sSignal, fn);
			}

			pRsc.bind(sSignal, fn);
		}

		dependencyLoaded(pFile: IDep): void {
			var pDeps: IDependens = pFile.deps;

			if (pDeps.loaded < pDeps.total) {
				return;
			}

			if (isDefAndNotNull(pDeps.deps)) {
				this.loadDeps(pDeps.deps);
			}
			else {
				this.loaded(pDeps);
			}
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Manager._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		statusChanged (file, info): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).statusChanged; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, file, info) : _broadcast[i].listener (_recivier, file, info) ; } } } ; ;

		loaded(pDeps: IDependens): void {
			this._eState = EStates.IDLE;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).loaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pDeps) : _broadcast[i].listener (_recivier, pDeps) ; } } ;
		}

		error(pErr: Error): void {
			if (true) throw pErr;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).error; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pErr) : _broadcast[i].listener (_recivier, pErr) ; } } ;
		}

	}

	export function createManager(pEngine: IEngine): IDepsManager {
		{ logger.setSourceLocation( "util/deps/Manager.ts" , 707 ); logger.assert(isDefAndNotNull(pEngine)); } ;
		return new Manager(pEngine);
	}
}













module akra {

	export enum EGamepadCodes {
/*Face (main) buttons*/
		FACE_1 = 0,
	    FACE_2 = 1,
	    FACE_3 = 2,
	    FACE_4 = 3,
/*Top shoulder buttons*/
	    LEFT_SHOULDER = 4,
	    RIGHT_SHOULDER = 5,
/*Bottom shoulder buttons*/
	    LEFT_SHOULDER_BOTTOM = 6,
	    RIGHT_SHOULDER_BOTTOM = 7,
	    SELECT = 8,
	    START = 9,
/*Analogue sticks (if depressible)*/
	    LEFT_ANALOGUE_STICK = 10,
	    RIGHT_ANALOGUE_STICK = 11,
/*Directional (discrete) pad*/
	    PAD_TOP = 12,
	    PAD_BOTTOM = 13,
	    PAD_LEFT = 14,
	    PAD_RIGHT = 15
	}

	export enum EGamepadAxis {
		LEFT_ANALOGUE_HOR = 0,
	    LEFT_ANALOGUE_VERT = 1,
	    RIGHT_ANALOGUE_HOR = 2,
	    RIGHT_ANALOGUE_VERT = 3
	}

    export interface IGamepadMap extends IEventProvider {
    	init(): bool;
    	update(): void;
    	isActive(): bool;


    	find(sID?: string): Gamepad;
    	find(i?:  number ): Gamepad;

    	 connected(pGamepad: Gamepad): void;
    	 disconnected(pGamepad: Gamepad): void;
    	 updated(pGamepad: Gamepad): void;
    }
}










module akra.controls {
	class GamepadMap implements IGamepadMap {
		private _bTicking: bool = false;
		private _pCollection: IObjectArray = new util.ObjectArray;
		private _pPrevRawGamepadTypes: string[] = [null, null, null, null];
		private _pPrevTimestamps:  number [] = [0, 0, 0, 0];

		init(): bool {

			if (!info.api.gamepad) {
	            { logger.setSourceLocation( "controls/GamepadMap.ts" , 21 ); logger.warning("Gamepad API is unsupported."); } ;
	            return false;
	        }

	        var pMap: GamepadMap = this;
	        var pCollection: IObjectArray = this._pCollection;

            window.addEventListener('MozGamepadConnected', (e: GamepadEvent) => {
            	pCollection.push(e.gamepad);
			    pMap.connected(e.gamepad);
			    pMap._startPolling();
            }, false);

            window.addEventListener('MozGamepadDisconnected', (e: GamepadEvent) => {
		        for (var i:  number  = 0; i <pCollection.length; ++ i) {
		            if (< number >pCollection.value(i).index == e.gamepad.index) {
		                pMap.disconnected(pCollection.takeAt(i));
		                break;
		            }
		        }

		        if (pCollection.length == 0) {
		            pMap._stopPolling();
		        }
            }, false);

            if ( !! navigator.gamepads || !! navigator.getGamepads) {
                this._startPolling();
                return true;
            }

            return false;
		}

		/**@inline*/  isActive(): bool {
			return this._bTicking;
		}


		find(sID?: string): Gamepad;
    	find(i?:  number ): Gamepad;
    	find(id?): Gamepad {
    		var sID: string = null;
    		var i:  number  = 0;

    		if (arguments.length) {
    			if (isString(arguments[0])) {
    				sID = <string>arguments[0];
    			}
    			else if (isInt(arguments[0])) {
    				i = < number >arguments[0];
    			}
    		}

    		if (!isNull(sID)) {
    			for (i = 0; i < this._pCollection.length; ++ i) {
    				if (this._pCollection.value(i).id == sID) {
    					return this._pCollection.value(i);
    				}
    			}
    		}

    		return this._pCollection.value(i);
    	}

		/**@inline*/  _startPolling(): void {
			 if (!this._bTicking) {
	            this._bTicking = true;
	            this.update();
	        }
		}

		/**@inline*/  _stopPolling(): void {
			this._bTicking = false;
		}

		/**@inline*/  update(): void {
			this.pollStatus();
		}

		private pollStatus(): void {
			if (!this._bTicking) {
				return;
			}

			this.pollGamepads();

	        for (var i = 0; i < this._pCollection.length; ++ i) {
	            var pGamepad: Gamepad = this._pCollection.value(i);

	            if (pGamepad.timestamp && (pGamepad.timestamp == this._pPrevTimestamps[i])) {
	                continue;
	            }

	            this._pPrevTimestamps[i] = pGamepad.timestamp;
	        }
		}

		private pollGamepads(): void {
			var pRawGamepads: Gamepad[] = (navigator.getGamepads && navigator.getGamepads()) || navigator.gamepads;
	        if (isDefAndNotNull(pRawGamepads)) {
//debug_print("get raw gamepads");

	            this._pCollection.clear();

	            var isGamepadsChanged: bool = false;

	            for (var i:  number  = 0; i < pRawGamepads.length; i++) {
	                if (typeof pRawGamepads[i] != this._pPrevRawGamepadTypes[i]) {

	                    isGamepadsChanged = true;
	                    this._pPrevRawGamepadTypes[i] = typeof pRawGamepads[i];

	                    if (isDefAndNotNull(pRawGamepads[i])) {
	                   		{ logger.setSourceLocation( "controls/GamepadMap.ts" , 135 ); logger.log("gamepad " + i + " updated: " + pRawGamepads[i].id); } ;
	                        this.updated(pRawGamepads[i]);
	                    }
	                }

	                if (isDefAndNotNull(pRawGamepads[i])) {
	                    this._pCollection.push(pRawGamepads[i]);
	                }
	            }

//if (isGamepadsChanged) {
//todo: collection changed...
//}
	        }
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return GamepadMap._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		connected (pGamepad): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).connected; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pGamepad) : _broadcast[i].listener (_recivier, pGamepad) ; } } } ; ;
		disconnected (pGamepad): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).disconnected; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pGamepad) : _broadcast[i].listener (_recivier, pGamepad) ; } } } ; ;
		updated (pGamepad): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).updated; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pGamepad) : _broadcast[i].listener (_recivier, pGamepad) ; } } } ; ;
	}

	export function createGamepadMap(): IGamepadMap {
		return new GamepadMap;
	}
}














module akra {
	export interface IPoint {
		x:  number ;
		y:  number ;
	}
}






module akra {
	export interface IOffset {
		x:  number ;
		y:  number ;
	}
}



module akra {
	export enum EKeyCodes {
		BACKSPACE = 8,
        TAB = 9,
		ENTER = 13,
		SHIFT = 16, CTRL, ALT,
		PAUSE = 19, BREAK = 19,
		CAPSLOCK = 20,
		ESCAPE = 27,
		SPACE = 32,
		PAGEUP = 33, PAGEDOWN,
		END = 35, HOME,
		LEFT = 37, UP, RIGHT, DOWN,
		INSERT = 45, DELETE,
		N0 = 48, N1, N2, N3, N4, N5, N6, N7, N8, N9,
		A = 65, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
		LEFTWINDOWKEY = 91, RIGHTWINDOWKEY, SELECTKEY,
		NUMPAD0 = 96, NUMPAD1, NUMPAD2, NUMPAD3, NUMPAD4, NUMPAD5, NUMPAD6, NUMPAD7, NUMPAD8, NUMPAD9,
		MULTIPLY = 106, ADD, SUBTRACT = 109, DECIMALPOINT, DIVIDE,
		F1 = 112, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
		NUMLOCK = 144, SCROLLLOCK,
		SEMICOLON = 186, EQUALSIGN, COMMA, DASH, PERIOD, FORWARDSLASH, GRAVEACCENT,
		OPENBRACKET = 219, BACKSLASH, CLOSEBRACKET, SINGLEQUOTE,
		TOTAL = 256
	}

	export enum EMouseButton {
		UNKNOWN = 0,
		LEFT = 1,
		MIDDLE = 2,
		RIGHT = 3
	}

	export interface IKeyMap {
		isKeyPress(iCode:  number );
		isKeyPress(eCode: EKeyCodes);

		getMouse(): IPoint;
/*get offset from last frame*/

		getMouseShift(): IOffset;
		isMouseMoved(): bool;
		isMousePress(): bool;

		bind(sCombination: string, fn: Function): bool;

		captureMouse(pMouseTarget: Node): void;
		captureMouse(pMouseTarget: Document): void;
		captureKeyboard(pKeyboardTarget: Node): void;
		captureKeyboard(pKeyboardTarget: Document): void;
		capture(pTarget: Node): void;
		capture(pTarget: Document): void;

		update(): void;
	}
}



module akra.controls {
	export class KeyMap implements IKeyMap {
		private _pMap: bool[] = new Array(EKeyCodes.TOTAL);
		private _pCallbackMap: {[combo: string]: Function[];} = <any>{};

		private _bMouseDown: bool = false;
		private _v2iMousePosition: IVec2 = new Vec2;
		private _v2iMousePrevPosition: IVec2 = new Vec2;
		private _v2iMouseShift: IVec2 = new Vec2;

		constructor(pTarget?: HTMLElement);
		constructor(pTarget?: Document);
		constructor(pTarget?: any) {
			for (var i = EKeyCodes.TOTAL; i--;) {
		        this._pMap[i] = false;
		    }

		    if (isDefAndNotNull(pTarget)) {
		    	this.capture(pTarget);
		    }
		}

		bind(sCombination: string, fn: Function): bool {
			var pKeys: string[] = sCombination.replace(/[\s]+/g, "").split("+");
			var pCodes:  number [] = [];

			for (var i:  number  = 0; i < pKeys.length; ++ i) {
				var iCode:  number  = EKeyCodes[pKeys[i].toUpperCase()];

				if (!isDef(iCode)) {
					return false;
				}

				pCodes.push(iCode);
			}

			var sHash: string = " " + pCodes.sort().join(' ');
			var pFuncList: Function[] = this._pCallbackMap[sHash];

			if (!isDefAndNotNull(pFuncList)) {
				pFuncList = this._pCallbackMap[sHash] = [];
			}

			if (pFuncList.indexOf(fn) === -1) {
				pFuncList.push(fn);
			}

			return true;
		}

		capture(pTarget: Document): void;
		capture(pTarget: HTMLElement): void;
		capture(pTarget: any): void {
			this.captureMouse(pTarget);
			this.captureKeyboard(pTarget);
		}

		captureMouse(pTarget: HTMLElement): void;
		captureMouse(pTarget: Document): void;
		captureMouse(pTarget: any): void {
			var pKeys: KeyMap = this;
		    var fn: EventListener = function (e: Event) {
		        pKeys.dispatch(<MouseEvent>e);
		    };

		    if (pTarget.addEventListener) {
		        pTarget.addEventListener("mousemove", fn, true);
		        pTarget.addEventListener("mouseup", fn, true);
		        pTarget.addEventListener("mousedown", fn, true);
		    }
		    else if (pTarget.attachEvent) {
		        pTarget.attachEvent("onmousemove", fn);
		        pTarget.attachEvent("onmouseup", fn);
		        pTarget.attachEvent("onmousedown", fn);
		    }
		    else {
		        pTarget.onmousemove = pTarget.onmouseup = pTarget.onmousedown = fn;
		    }
		}

		captureKeyboard(pTarget: Document): void;
		captureKeyboard(pTarget: HTMLElement): void;
		captureKeyboard(pTarget: any): void {
			var pKeys: KeyMap = this;
		    var fn: EventListener = function (e: Event) {
		        pKeys.dispatch(<MouseEvent>e);
		    };

		    if (pTarget.addEventListener) {
		        pTarget.addEventListener("keydown", fn, false);
        		pTarget.addEventListener("keyup", fn, false);
		    }
		    else if (pTarget.attachEvent) {
		        pTarget.attachEvent("onkeydown", fn);
        		pTarget.attachEvent("onkeyup", fn);
		    }
		    else {
		        pTarget.onkeydown = pTarget.onkeyup = fn;
		    }
		}

		dispatch(e: MouseEvent = <MouseEvent><any>window.event): void {
		    var iCode:  number  = (<KeyboardEvent><any>e).keyCode;

		    if (e.type == "keydown") {
		        this._pMap[iCode] = true;

		        if (e.altKey) {
		            this._pMap[EKeyCodes.ALT] = true;
		        }
		        if (e.ctrlKey) {
		            this._pMap[EKeyCodes.CTRL] = true;
		        }
		        if (e.shiftKey) {
		            this._pMap[EKeyCodes.SHIFT] = true;
		        }
// if (e.altKey || e.ctrlKey || e.shiftKey) {
//     this._pMap.splice(0);
// }
		    }
		    else if (e.type == "keyup") {
		    	this.callListeners();

		        this._pMap[iCode] = false;

		        if(iCode == EKeyCodes.ALT){
		            this._pMap[EKeyCodes.ALT] = false;
		        }
		        if(iCode == EKeyCodes.CTRL){
		            this._pMap[EKeyCodes.CTRL] = false;
		        }
		        if(iCode == EKeyCodes.SHIFT){
		            this._pMap[EKeyCodes.SHIFT] = false;
		        }
		    }

		    if (e.type == "mousemove") {
		        this._v2iMousePosition.x = (<MouseEvent>e).offsetX;
		        this._v2iMousePosition.y = (<MouseEvent>e).offsetY;
		    }
		    else if (e.type == "mouseup") {
// LOG(e);
		        this._bMouseDown = false;
		    }
		    else if (e.type == "mousedown") {
		    	e.preventDefault();
		    	this._v2iMousePrevPosition.x = (<MouseEvent>e).offsetX;
		        this._v2iMousePrevPosition.y = (<MouseEvent>e).offsetY;
		        this._bMouseDown = true;
		    }
		}

		private callListeners(): void {
			var sHash: string = "";

	        for (var i = 0; i < this._pMap.length; ++ i) {
	        	if (this._pMap[i]) {
	        		sHash += " " + i;
	        	}
	        }

	        var pFuncList: Function[] = this._pCallbackMap[sHash];

	        if (isDefAndNotNull(pFuncList)) {
	        	for (var i:  number  = 0; i < pFuncList.length; ++ i) {
	        		pFuncList[i]();
	        	}
	        }
		}

	    isKeyPress(iCode:  number );
		isKeyPress(eCode: EKeyCodes);

		/**@inline*/  isKeyPress(iCode:  number ) {
			return this._pMap[iCode];
		}

		/**@inline*/  getMouse(): IVec2 {
			return this._v2iMousePosition;
		}

		/**@inline*/  getMouseShift(): IVec2 {
			return this._v2iMouseShift.set(
				this._v2iMousePosition.x - this._v2iMousePrevPosition.x,
				this._v2iMousePosition.y - this._v2iMousePrevPosition.y);
		}

		isMouseMoved(): bool {
			return this._v2iMousePosition.x != this._v2iMousePrevPosition.x ||
					this._v2iMousePosition.y != this._v2iMousePrevPosition.y;
		}

		isMousePress(): bool {
			return this._bMouseDown;
		}

		update(): void {
			this._v2iMousePrevPosition.set(this._v2iMousePosition);
		}
	}

	export function createKeymap(target?: Document): IKeyMap;
	export function createKeymap(target?: HTMLElement): IKeyMap;
	export function createKeymap(target?: any): IKeyMap {
		return new KeyMap(target);
	}
}












module akra.util {
	export function createSceneSurface(pScene: IScene3d, nCell?:  number ): ISceneModel;
	export function createSceneSurface(pScene: IScene3d, nCellW?:  number , nCellH?:  number ): ISceneModel;

	export function createQuad(pScene: IScene3d, fSize?:  number ): ISceneModel;


	export function createSceneSurface(pScene: IScene3d, nCellW?:  number  = 10, nCellH?:  number  = nCellW): ISceneModel {
		if(nCellW % 2 === 0) {
			nCellW += 1;
		}

		if(nCellH % 2 === 0) {
			nCellH += 1;
		}

	    var nScaleX:  number  = nCellW - 1;
	    var nScaleY:  number  = nCellH - 1;

	    var pMesh: IMesh = null,
	    	pSubMesh: IMeshSubset = null;
	    var iPos:  number  = 0;
	    var pVerticesData: Float32Array = new Float32Array((nCellW + nCellH) * 6);

	    var fStepX:  number  = 1.0 / (nCellW - 1);
	    var fStepY:  number  = 1.0 / (nCellH - 1);
	    var n:  number  = 0;

	    for (var z:  number  = 0; z < nCellH; ++ z) {
	        pVerticesData[n]        = (-.5) * nScaleX;
	        pVerticesData[n + 2]    = (z * fStepY -.5) * nScaleY;
	        n += 3;

	        pVerticesData[n]        = (.5) * nScaleX;
	        pVerticesData[n + 2]    = (z * fStepY -.5) * nScaleY;
	        n += 3;
	    }

	    for (var x:  number  = 0; x < nCellW; ++ x) {
	        pVerticesData[n]        = (x * fStepX -.5)  * nScaleX;
	        pVerticesData[n + 2]    = (-.5) * nScaleY;
	        n += 3;

	        pVerticesData[n]        = (x * fStepX -.5) * nScaleX;
	        pVerticesData[n + 2]    = (.5) * nScaleY;
	        n += 3;
	    }



	    var pVertexIndicesData: Float32Array = new Float32Array((nCellW + nCellH) * 2);

	    n = 0;
	    for (var z:  number  = 0; z < nCellH; ++ z) {
	        pVertexIndicesData[n ++]   = z * 2;
	        pVertexIndicesData[n ++]   = z * 2 + 1;
	    };

	    for (var x:  number  = 0; x < nCellW; ++ x) {
	        pVertexIndicesData[n ++]   = nCellH * 2 + x * 2;
	        pVertexIndicesData[n ++]   = nCellH * 2 + x * 2 + 1;
	    };

	    var pEngine: IEngine = pScene.getManager().getEngine();

	    pMesh = model.createMesh(pEngine, 'scene-surface', EMeshOptions.HB_READABLE);
	    pSubMesh = pMesh.createSubset('scene-surface::main', EPrimitiveTypes.LINELIST);
	    pSubMesh.data.allocateData([VE_VEC3('POSITION')], pVerticesData);
	    pSubMesh.data.allocateIndex([VE_FLOAT('INDEX_POSITION')], pVertexIndicesData);
	    pSubMesh.data.index('POSITION', 'INDEX_POSITION');

	    pSubMesh.shadow = false;

	    if((<core.Engine>pEngine).isDepsLoaded()){
	    	pSubMesh.renderMethod.effect.addComponent("akra.system.plane");
	    }
	    else {
	    	pScene.getManager().getEngine().bind( "depsLoaded" , () => {
	    		pSubMesh.renderMethod.effect.addComponent("akra.system.plane");
	    	});
	    }

	    var pSceneModel: ISceneModel = pScene.createModel("scene-surface");
	    pSceneModel.mesh = pMesh;

	    return pSceneModel;
	}

	export function createQuad(pScene: IScene3d, fSize?:  number  = 20.): ISceneModel {
		var pMesh: IMesh = null,
			pSubMesh: IMeshSubset = null;

	    var pVerticesData: Float32Array = new Float32Array([
	                                             -fSize, 0., -fSize,
	                                              fSize, 0., -fSize,
	                                             -fSize, 0.,  fSize,
	                                              fSize, 0.,  fSize
	                                         ]);
	    var pNormalsData: Float32Array = new Float32Array([
	                                              0., 1., 0.
	                                        ]);
	    var pVertexIndicesData: Float32Array = new Float32Array([
	                                        		0., 1. , 2., 3.
	                                              ]);

	    var pNormalIndicesData:Float32Array = new Float32Array([
	                                                  0., 0., 0., 0.
	                                              ]);

	   	var iPos:  number  = 0,
	    	iNorm:  number  = 0;

	    var pEngine: IEngine = pScene.getManager().getEngine();

	    pMesh = model.createMesh(pEngine, 'quad', EMeshOptions.HB_READABLE);
	    pSubMesh = pMesh.createSubset('quad::main', EPrimitiveTypes.TRIANGLESTRIP);

	    iPos = pSubMesh.data.allocateData([VE_VEC3('POSITION')], pVerticesData);
	    pSubMesh.data.allocateIndex([VE_FLOAT('INDEX0')], pVertexIndicesData);
	    pSubMesh.data.index('POSITION', 'INDEX0');

	    iNorm = pSubMesh.data.allocateData([VE_VEC3('NORMAL')], pNormalsData);
	    pSubMesh.data.allocateIndex([VE_FLOAT('INDEX1')], pNormalIndicesData);


	    pSubMesh.data.index('NORMAL', 'INDEX1');

	    pSubMesh.shadow = false;

	    if((<core.Engine>pEngine).isDepsLoaded()){
	    	pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
	    }
	    else {
	    	pScene.getManager().getEngine().bind( "depsLoaded" , () => {
	    		pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
	    	});
	    }

	    var pMatrial: IMaterial = pSubMesh.renderMethod.surfaceMaterial.material;
	    pMatrial.diffuse = Color.LIGHT_GRAY;
	    pMatrial.ambient = new Color(0.7, 0.7, 0.7, 1.);
		pMatrial.specular = new Color(0.7, 0.7, 0.7 ,1);
		pMatrial.emissive = new Color(0., 0., 0., 1.);
	    pMatrial.shininess = 30.;


	    var pSceneModel: ISceneModel = pScene.createModel("quad");
	    pSceneModel.mesh = pMesh;

	    return pSceneModel;
	}

	export function basis(pScene, eOptions:  number  = EMeshOptions.HB_READABLE, fSize:  number  = 1.): ISceneModel {
	    var pMesh: IMesh, pSubMesh: IMeshSubset, pMaterial: IMaterial;
	    var iPos:  number , iNorm:  number ;
	    var pEngine: IEngine = pScene.getManager().getEngine();

	    pMesh = model.createMesh(pEngine, "basis", eOptions);
	    iNorm = pMesh.data.allocateData([VE_VEC3("NORMAL")], new Float32Array([1,0,0]));

	    function createAxis(sName: string, pCoords: Float32Array, pColor: IColor): void {
	        pSubMesh = pMesh.createSubset(sName, EPrimitiveTypes.LINELIST);

	        iPos = pSubMesh.data.allocateData([VE_VEC3("POSITION")], pCoords);
	        pSubMesh.data.allocateIndex([VE_FLOAT("INDEX0")],   new Float32Array([0,1]));
	        pSubMesh.data.allocateIndex([VE_FLOAT("INDEX1")],   new Float32Array([0,0]));

	        pSubMesh.data.index(iPos, "INDEX0");
	        pSubMesh.data.index(iNorm, "INDEX1");

//pSubMesh.applyFlexMaterial(sName + '-color');
//pSubMesh.getFlexMaterial(sName + '-color');
	        pMaterial = pSubMesh.material;
	        pMaterial.emissive = pColor;
	        pMaterial.ambient = pColor;
	        pMaterial.diffuse = pColor;
	        pMaterial.shininess = 100.;

	        pSubMesh.shadow = false;

	        if((<core.Engine>pEngine).isDepsLoaded()){
		    	pSubMesh.effect.addComponent("akra.system.mesh_texture");
		    }
		    else {
		    	pScene.getManager().getEngine().bind( "depsLoaded" , () => {
		    		pSubMesh.effect.addComponent("akra.system.mesh_texture");
		    	});
		    }
	    }

	    createAxis('basis::X-axis', new Float32Array([0,0,0, 1 * fSize,0,0]), Color.RED);
	    createAxis('basis::Y-axis', new Float32Array([0,0,0, 0,1 * fSize,0]), Color.GREEN);
	    createAxis('basis::Z-axis', new Float32Array([0,0,0, 0,0,1 * fSize]), Color.BLUE);

	    var pSceneModel: ISceneModel = pScene.createModel("basis");
	    pSceneModel.mesh = pMesh;

	    return pSceneModel;
	}

	export function bone(pJoint: IJoint): ISceneModel {

		var pScene: IScene3d = pJoint.scene;
		var pParent: INode = <INode>pJoint.parent;

		if (isNull(pParent)) {
			return null;
		}

		pParent.update();
		pJoint.update();

// return basis(pScene);

		var pMesh: IMesh, pSubMesh: IMeshSubset, pMaterial: IMaterial;
	    var iPos:  number , iNorm:  number ;
	    var pEngine: IEngine = pScene.getManager().getEngine();
	    var v: IVec3 = pJoint.worldPosition.subtract(pParent.worldPosition,  Vec3.stackCeil.set() );

	    pMesh = model.createMesh(pEngine, "bone-" + pJoint.name, EMeshOptions.HB_READABLE);
        pSubMesh = pMesh.createSubset("bone", EPrimitiveTypes.LINELIST);

// pJoint.localOrientation.inverse(quat4()).multiplyVec3(v);

// var s:IVec3 = pJoint.localScale;
// v.x *= 1./s.x;
// v.y *= 1./s.y;
// v.z *= 1./s.z;

// console.log(pJoint.name, "-->", pParent.name, pJoint.worldPosition.toString(), pParent.worldPosition.toString(), v.toString());

        pSubMesh.data.allocateData([VE_VEC3("POSITION")], new Float32Array([0,0,0, v.x, v.y, v.z]));
        pSubMesh.data.allocateIndex([VE_FLOAT("INDEX0")],   new Float32Array([0,1]));

        pSubMesh.data.index("POSITION", "INDEX0");

        pMaterial = pSubMesh.material;
        (<IColor>pMaterial.emissive).set(Color.WHITE);

        pSubMesh.shadow = false;

        pSubMesh.effect.addComponent("akra.system.mesh_texture");


	    var pSceneModel: ISceneModel = pScene.createModel("bone-" + pJoint.name);
	    pSceneModel.mesh = pMesh;

	    return pSceneModel;
	}


	export function lineCube(pScene, eOptions?:  number ): ISceneModel {
		var pMesh: IMesh, pSubMesh: IMeshSubset, pMaterial: IMaterial;
	    var iPos:  number , iNorm:  number ;
	    var pEngine: IEngine = pScene.getManager().getEngine();

	    pMesh = model.createMesh(pEngine, "basis", eOptions || EMeshOptions.HB_READABLE);
	    iNorm = pMesh.data.allocateData([VE_VEC3("NORMAL")], new Float32Array([1,0,0]));

	    pSubMesh = pMesh.createSubset("cube", EPrimitiveTypes.LINELIST);

	    pSubMesh.data.allocateAttribute([VE_VEC3("POSITION")], new Float32Array([
//front
	    	-1,	-1,	-1,
	    	1,	-1,	-1,

	    	1,	-1,	-1,
	    	1,	1,	-1,

	    	1,	1,	-1,
	    	-1,	1,	-1,

	    	-1,	1,	-1,
	    	-1,	-1,	-1,

//bottom
	    	-1,	-1,	1,
	    	1,	-1,	1,

	    	1,	-1,	1,
	    	1,	1,	1,

	    	1,	1,	1,
	    	-1,	1,	1,

	    	-1,	1,	1,
	    	-1,	-1,	1,


//left
	    	-1,	-1,	-1,
	    	-1,	1,	-1,

	    	-1,	1,	-1,
	    	-1,	1,	1,

	    	-1,	1,	1,
	    	-1,	-1,	1,

	    	-1,	-1,	1,
	    	-1,	-1,	-1,

//right
	    	1,	-1,	-1,
	    	1,	1,	-1,

	    	1,	1,	-1,
	    	1,	1,	1,

	    	1,	1,	1,
	    	1,	-1,	1,

	    	1,	-1,	1,
	    	1,	-1,	-1
	    ]));

	    pMaterial = pSubMesh.material;
        (<IColor>pMaterial.emissive).set(1.);
        (<IColor>pMaterial.ambient).set(1.);
        (<IColor>pMaterial.diffuse).set(1.);
        pMaterial.shininess = 100.;

        pSubMesh.shadow = false;

     	if((<core.Engine>pEngine).isDepsLoaded()){
	    	pSubMesh.effect.addComponent("akra.system.mesh_texture");
	    }
	    else {
	    	pScene.getManager().getEngine().bind( "depsLoaded" , () => {
	    		pSubMesh.effect.addComponent("akra.system.mesh_texture");
	    	});
	    }


	    var pSceneModel: ISceneModel = pScene.createModel("basis");
	    pSceneModel.mesh = pMesh;

	    return pSceneModel;
	}

// export  
// function cube (pScene: IScene3d, eOptions?: int, fSize: float = 1.) {
//     var pMesh: IMesh, pSubMesh: IMeshSubset;
//     var iPos: int, iNorm: int;

//     var pVerticesData = new Float32Array([
//                                              -0.5, 0.5, 0.5,
//                                              0.5, 0.5, 0.5,
//                                              -0.5, -0.5, 0.5,
//                                              0.5, -0.5, 0.5,
//                                              -0.5, 0.5, -0.5,
//                                              0.5, 0.5, -0.5,
//                                              -0.5, -0.5, -0.5,
//                                              0.5, -0.5, -0.5
//                                          ]);

//     for (var i: int = 0; i < pVerticesData.length; ++ i) {
//     	pVerticesData[i] *= fSize;
//     }

//     var pMapData = new Float32Array([
//                                         0, 0, 0,
//                                         1, 0, 0,
//                                         0, 1, 0,
//                                         1, 1, 0
//                                     ]);

//     var pNormalsData = new Float32Array([
//                                             1.0, 0.0, 0.0,
//                                             -1.0, 0.0, 0.0,
//                                             0.0, 1.0, 0.0,
//                                             0.0, -1.0, 0.0,
//                                             0.0, 0.0, 1.0,
//                                             0.0, 0.0, -1.0
//                                         ]);
//     var pVertexIndicesData = new Float32Array([
//                                                   0, 2, 3, 0, 3, 1,//front
//                                                   0, 1, 5, 0, 5, 4,//top
//                                                   6, 7, 3, 6, 3, 2,//bottom
//                                                   0, 4, 6, 0, 6, 2,//left
//                                                   3, 7, 5, 3, 5, 1,//right
//                                                   5, 7, 6, 5, 6, 4 //back
//                                               ]);
//     var pNormalIndicesData = new Float32Array([
//                                                   4, 4, 4, 4, 4, 4,
//                                                   2, 2, 2, 2, 2, 2,
//                                                   3, 3, 3, 3, 3, 3,
//                                                   1, 1, 1, 1, 1, 1,
//                                                   0, 0, 0, 0, 0, 0,
//                                                   5, 5, 5, 5, 5, 5
//                                               ]);

//     var pMapIndices = new Float32Array([
//                                            0, 2, 3, 0, 3, 1,
//                                            0, 2, 3, 0, 3, 1,
//                                            0, 2, 3, 0, 3, 1,
//                                            0, 2, 3, 0, 3, 1,
//                                            0, 2, 3, 0, 3, 1,
//                                            0, 2, 3, 0, 3, 1
//                                        ]);

//     var pSerialData = new Float32Array(pNormalIndicesData.length);

//     for (var i = 0; i < pSerialData.length; i++) {
//         pSerialData[i] = i % 3;
//     };

//     var iNorm, iPos, iMap;

//     pMesh = new a.Mesh(pEngine, eOptions || a.Mesh.VB_READABLE, sName || 'cube');
//     pSubMesh = pMesh.createSubset('cube::main');

//     iPos  = pSubMesh.data.allocateData([VE_VEC3('POSITION')], pVerticesData);
//     iNorm = pSubMesh.data.allocateData([VE_VEC3('NORMAL')], pNormalsData);
//     iMap  = pSubMesh.data.allocateData([VE_VEC3('TEXCOORD0')], pMapData);

//     pSubMesh.data.allocateIndex([VE_FLOAT('INDEX0')], pVertexIndicesData);
//     pSubMesh.data.allocateIndex([VE_FLOAT('INDEX1')], pNormalIndicesData);
//     pSubMesh.data.allocateIndex([VE_FLOAT('INDEX2')], pMapIndices);

//     pSubMesh.data.index(iPos,  'INDEX0');
//     pSubMesh.data.index(iNorm, 'INDEX1');
//     pSubMesh.data.index(iMap,  'INDEX2');

//     // pSubMesh.applyFlexMaterial('default');
//     var pMat = pSubMesh.material;

//     pMat.diffuse = new a.Color4f(0.5, 0., 0., 1.);
//     pMat.ambient = new a.Color4f(0.7, 0., 0., 1.);
//     pMat.specular = new a.Color4f(1., 0.7, 0. ,1);
//     pMat.shininess = 30.;

//     pSubMesh.effect.create();
//     pSubMesh.effect.use("akra.system.mesh_texture");
//     pSubMesh.effect.use("akra.system.prepareForDeferredShading");
//     //trace(pSubMesh._pMap.toString());

//     return pMesh;
// }

}




// var pMesh: IMesh;
// 			var pEngine: IEngine = this.getEngine();

// 			var pVerticesData = new Float32Array([
// 					-0.5, 0.5, 0.5,
// 					0.5, 0.5, 0.5,
// 					-0.5, -0.5, 0.5,
// 					0.5, -0.5, 0.5,
// 					-0.5, 0.5, -0.5,
// 					0.5, 0.5, -0.5,
// 					-0.5, -0.5, -0.5,
// 					0.5, -0.5, -0.5
// 	            ]);

// 			var pVertexIndicesData = new Float32Array([
// 					0, 2, 3, 0, 3, 1,	/*front*/
// 					0, 1, 5, 0, 5, 4,	/*top*/
// 					6, 7, 3, 6, 3, 2,	/*bottom*/
// 					0, 4, 6, 0, 6, 2,	/*left*/
// 					3, 7, 5, 3, 5, 1,	/*right*/
// 					5, 7, 6, 5, 6, 4 	/*back*/
// 				]);

// 			var pNormalsData = new Float32Array([
// 					1.0, 0.0, 0.0,
// 					-1.0, 0.0, 0.0,
// 					0.0, 1.0, 0.0,
// 					0.0, -1.0, 0.0,
// 					0.0, 0.0, 1.0,
// 					0.0, 0.0, -1.0
// 	            ]);

// 		    var pNormalIndicesData = new Float32Array([
// 					4, 4, 4, 4, 4, 4,
// 					2, 2, 2, 2, 2, 2,
// 					3, 3, 3, 3, 3, 3,
// 					1, 1, 1, 1, 1, 1,
// 					0, 0, 0, 0, 0, 0,
// 					5, 5, 5, 5, 5, 5
// 				]);

// 			var pMapData = new Float32Array([
// 	                0, 0, 0,
// 	                1, 0, 0,
// 	                0, 1, 0,
// 	                1, 1, 0
// 	            ]);

// 			//UV map
// 			/*-----------------------------------------------------*
// 		     *        *        *        *        *        *        *
// 		     *        *        *        *        *        *        *
// 		     *        *        *        *        *        *        *
// 		     *------------------------------------------------------*/


// 			var pMapData = new Float32Array([
// 	                0, 0, 0,
// 	                1, 0, 0,
// 	                0, 1, 0,
// 	                1, 1, 0
// 	            ]);

// 			var pMapIndices = new Float32Array([
// 					0, 2, 3, 0, 3, 1,
// 					0, 2, 3, 0, 3, 1,
// 					0, 2, 3, 0, 3, 1,
// 					0, 2, 3, 0, 3, 1,
// 					0, 2, 3, 0, 3, 1,
// 					0, 2, 3, 0, 3, 1
//                 ]);

// 			var pColorData = new Float32Array([
// 					1.0, 0.0, 0.0, /*red*/
// 					0.0, 1.0, 0.0, /*green*/
// 					0.0, 0.0, 1.0, /*blue*/

// 					1.0, 1.0, 0.0, /*orange*/
// 					1.0, 0.0, 1.0, /*purple*/
// 					0.0, 1.0, 1.0  /*turquoise*/
// 				]);

// 			var pColorIndices = pNormalIndicesData;
// 			var pSerialData = new Float32Array(pNormalIndicesData.length);

// 		    for (var i = 0; i < pSerialData.length; i++) {
// 		        pSerialData[i] = i % 3;
// 		    };

// 		    var iNorm: int, 
// 			    iPos: int, 
// 			    iMap: int,
// 			    iColor: int;

// 		    pMesh = model.createMesh(pEngine, "cube", eOptions || EMeshOptions.HB_READABLE);
// 		    pSubMesh = pMesh.createSubset();


// 	        iPos  = pSubMesh.data.allocateData([VE_VEC3("POSITION")], pVerticesData);
// 		    iNorm = pSubMesh.data.allocateData([VE_VEC3("NORMAL")], pNormalsData);
// 		    iMap  = pSubMesh.data.allocateData([VE_VEC3("TEXCOORD0")], pMapData);
// 		    iColor  = pSubMesh.data.allocateData([VE_VEC3("COLOR0")], pColorData);

// 		    pSubMesh.data.allocateIndex([VE_FLOAT("INDEX0")], pVertexIndicesData);
// 		    pSubMesh.data.allocateIndex([VE_FLOAT("INDEX1")], pNormalIndicesData);
// 		    pSubMesh.data.allocateIndex([VE_FLOAT("INDEX2")], pMapIndices);
// 		    pSubMesh.data.allocateIndex([VE_FLOAT("INDEX3")], pColorIndices);

// 		    pSubMesh.data.index(iPos,   "INDEX0");
// 		    pSubMesh.data.index(iNorm,  "INDEX1");
// 		    pSubMesh.data.index(iMap,   "INDEX2");
// 		    pSubMesh.data.index(iColor, "INDEX3");

// 		    pSubMesh.shadow = false;

// 		    if((<core.Engine>pEngine).isDepsLoaded()){
// 		    	pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
// 		    }
// 		    else {
// 		    	pScene.getManager().getEngine().bind(SIGNAL(depsLoaded), () => {
// 		    		pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
// 		    	});
// 		    }

// 		    var pMatrial: IMaterial = pSubMesh.renderMethod.surfaceMaterial.material;

// 		    pMatrial.diffuse = Color.LIGHT_GRAY;
// 		    pMatrial.ambient = new Color(0.7, 0.7, 0.7, 1.);
// 			pMatrial.specular = new Color(0.7, 0.7, 0.7 ,1);
// 			pMatrial.emissive = new Color(0., 0., 0., 1.);
// 		    pMatrial.shininess = 30.;


// 		    var pSceneModel: ISceneModel = pScene.createModel("cube");
// 		    pSceneModel.mesh = pMesh;

// 		    return pSceneModel;

























//#define SKY_GPU

module akra.model {

// core.Engine.depends("effects/sky.fx");

	export class Sky implements IEventProvider  {
		skyDome: ISceneModel = null;
		sun: ISunLight = null;

/*private*/
/* Theta angle from zenith to sun*/
		            _fSunTheta:  number ;
/*private*/
/* Phi angle */
		            _fSunPhi:  number ;
/*private*/
/* Rayleigh scattering constant*/
		            _fKr:  number ;
/*private*/
/* Same * 4 * PI*/
		            _fKr4PI:  number ;
/*private*/
/* Mie scattering constant*/
		            _fKm:  number ;
/*private*/
/* Same * 4 * PI*/
		            _fKm4PI:  number ;
/*private*/
/* Sun brightness constant*/
		            _fESun:  number ;
/*private*/
/**/
		            _fKrESun:  number ;
/*private*/
/**/
		            _fKmESun:  number ;
/*private*/
/* The Mie phase asymmetry factor*/
		            _fg:  number ;
/*private*/
		            _fg2:  number ;
/*private*/
/* Exposure constant*/
		            _fExposure:  number ;
/*private*/
/* Inner planetary radius */
		            _fInnerRadius:  number ;
/*private*/
/**/
		            _fInnerRadius2:  number ;
/*private*/
/* Outer atmosphere radius*/
		            _fOuterRadius:  number ;
/*private*/
/**/
		            _fOuterRadius2:  number ;
/*private*/
/* */
		            _fScale:  number ;
/*private*/
/**/
		            _fScaleOverScaleDepth:  number ;
/*private*/
/**/
		            _fRayleighScaleDepth:  number ;
/*private*/
/**/
		            _fMieScaleDepth:  number ;

/*private*/
/**/
		            _nHorinLevel:  number  = 13;

		time:  number  = 0.0;

		private _v3fSunDir: IVec3 = new Vec3;
		private _v3fInvWavelength4: IVec3 = new Vec3;
		private _v3fHG: IVec3 = new Vec3;
		private _v3fEye: IVec3 = new Vec3;
		private _v3fGroundc0: IVec3 = new Vec3;
		private _v3fGroundc1: IVec3 = new Vec3;

// Number of sample rays to use in integral equation
		private _nSize:  number ;
		private _nSamples:  number ;

// private _bSkyBuffer: bool;

// private _v2fRttQuad: IVec2[] = [new Vec2, new Vec2, new Vec2, new Vec2];

		private _pBackBuffer: IRenderTarget;
		private _pSurface: IRenderTarget;

		private _pSkyBuffer: ITexture;
		private _pSkyBackBuffer: ITexture;

		private _pSkyBlitBox: IPixelBox = null;


		constructor (private _pEngine: IEngine, nCols:  number , nRows:  number , fR:  number ) {
			{ logger.setSourceLocation( "model/Sky.ts" , 69 ); logger.assert(nCols > 2); } ;
			{ logger.setSourceLocation( "model/Sky.ts" , 70 ); logger.assert(nRows > 1); } ;
			{ logger.setSourceLocation( "model/Sky.ts" , 71 ); logger.assert(nCols * nRows < 65535); } ;

			this._fInnerRadius = fR;
			this._init();
			this.init();
			this.createBuffers();

			var pDomeMesh: IMesh = this.createDome(nCols, nRows);

			var pSceneModel: ISceneModel = _pEngine.getScene().createModel("dome" + this.getGuid());

	    	pSceneModel.mesh = pDomeMesh;
		    pSceneModel.accessLocalBounds().set(MAX_UINT32, MAX_UINT32, MAX_UINT32);
// pSceneModel.scale(this._fOuterRadius);

	    	this.skyDome = pSceneModel;

	    	this.sun = <ISunLight>_pEngine.getScene().createLightPoint(ELightTypes.SUN, true, 2048);

	    	this.sun.attachToParent(this.skyDome);
	    	this.sun.skyDome = this.skyDome;
		}

		/**@inline*/  getEngine(): IEngine {
			return this._pEngine;
		}

		/**@inline*/  scale(fCos:  number ):  number  {
			var x:  number  = 1.0 - fCos;
			return this._fRayleighScaleDepth * math.exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));
		}

		/**@inline*/  expv(v: IVec3): IVec3 {
			return  Vec3.stackCeil.set(math.exp(v.x), math.exp(v.y), math.exp(v.z)) ;
		}


		private _init(): void {
/*Higher, Better, More CPU/GPU*/
			this._nSize = 32;
/*Higher, Better, More CPU/GPU*/
			this._nSamples = 5;
			this._fKr = 0.0025;
			this._fKm = 0.0010;
			this._fESun = 20.0;
			this._fg = -0.990;
			this._fExposure = -2.0;

			this._fRayleighScaleDepth = 0.25;
			this._fMieScaleDepth = 0.1;
			this._v3fInvWavelength4.x = 1.0 / math.pow(0.650, 4.0);
			this._v3fInvWavelength4.y = 1.0 / math.pow(0.570, 4.0);
			this._v3fInvWavelength4.z = 1.0 / math.pow(0.475, 4.0);
		}

		init(): void {
// this._nSize = 32; 		
// this._nSamples = 5;		
// this._fKr = 0.0025;
			this._fKr4PI = this._fKr * 4.0 * math.PI;
// this._fKm = 0.0010;
			this._fKm4PI = this._fKm * 4.0 * math.PI;
// this._fESun = 20.0;
			this._fKrESun = this._fESun * this._fKr;
			this._fKmESun = this._fESun * this._fKm;
// this._fg = -0.990;
			this._fg2 = this._fg * this._fg;
// this._fExposure = -2.0;
			this._fInnerRadius2 = this._fInnerRadius * this._fInnerRadius;
			this._fOuterRadius = this._fInnerRadius * 1.025;
			this._fOuterRadius2 = this._fOuterRadius * this._fOuterRadius;
			this._fScale = 1.0 / (this._fOuterRadius - this._fInnerRadius);

// this._fRayleighScaleDepth = 0.25;
// this._fMieScaleDepth = 0.1;
			this._fScaleOverScaleDepth = this._fScale / this._fRayleighScaleDepth;

			this._v3fHG.x = 1.5 * ( (1.0 - this._fg2) / (2.0 + this._fg2) );
			this._v3fHG.y = 1.0 + this._fg2;
			this._v3fHG.z = 2.0 * this._fg;
			this._v3fEye.x = 0.0;
			this._v3fEye.y = this._fInnerRadius + 1.0e-6;
			this._v3fEye.z = 0.0;


// this._bSkyBuffer = false;

		}

		private  /**@inline*/  updateSunLight(): void {
			this.sun.updateSunDirection(this._v3fSunDir);
		}

		private createBuffers(): void {


			var pEngine: IEngine = this.getEngine();
			var pRsmgr: IResourcePoolManager = pEngine.getResourceManager();

			this._pSkyBuffer = pRsmgr.createTexture("sky_buffer" + this.getGuid());
// this._pSkyBackBuffer = pRsmgr.createTexture("sky_back_buffer" + this.getGuid());

			this._pSkyBuffer.create(this._nSize, this._nSize, 1, null, ETextureFlags.RENDERTARGET, 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.FLOAT32_RGBA);
// this._pSkyBackBuffer.create(this._nSize, this._nSize, 1, null, ETextureFlags.RENDERTARGET, 0, 0, ETextureTypes.TEXTURE_2D, EPixelFormats.FLOAT32_RGBA);

			this._pSkyBlitBox = new pixelUtil.PixelBox(this._nSize, this._nSize, 1, EPixelFormats.FLOAT32_RGBA, new Uint8Array(this._pSkyBuffer.byteLength));


		}



		private getWrite(): ITexture {
/*if (this._bSkyBuffer)*/
			                          return this._pSkyBuffer;
/*return this._pSkyBackBuffer;*/

		}

		private getRead(): ITexture {
/*if (!this._bSkyBuffer) */
			                           return this._pSkyBuffer;
/*return this._pSkyBackBuffer;*/

		}


		updateSkyBuffer(): void {
			var pPixelBuffer: IPixelBuffer = this.getWrite().getBuffer();
// var pBox: IBox = geometry.box(0, 0, 0, this._nSize, this._nSize, 1);

// var pRect: IPixelBox = pPixelBuffer.lock(pBox, ELockFlags.WRITE);

// debug_assert(!isNull(pRect), "cannot lock texture");

// var pBuffer: Float32Array = new Float32Array(pRect.data.buffer);
			var pBuffer: Float32Array = new Float32Array(this._pSkyBlitBox.data.buffer);
			var nIndex:  number  = 0;

			for(var x:  number  = 0; x < this._nSize; x++ ) {

				var fCosxz:  number  = math.cos( 1.0 ) * x / < number >(this._nSize - 1.0);

				for(var y:  number  = 0; y < this._nSize; y++ ) {
					var fCosy:  number  = (math.PI * 2.0) * y / < number >(this._nSize - 1.0);

					var vVecPos: IVec3 =  Vec3.stackCeil.set() ;
					var vEye: IVec3 =  Vec3.stackCeil.set(0.0, this._fInnerRadius + 1e-6, 0.0) ;

					vVecPos.x = math.sin( fCosxz ) * math.cos( fCosy  ) * this._fOuterRadius;
					vVecPos.y = math.cos( fCosxz ) * this._fOuterRadius;
					vVecPos.z = math.sin( fCosxz ) * math.sin( fCosy  ) * this._fOuterRadius;

					var v3Pos: IVec3 =  Vec3.stackCeil.set(vVecPos) ;
					var v3Ray: IVec3 = v3Pos.subtract(vEye,  Vec3.stackCeil.set() );
					var fFar:  number  = v3Ray.length();

					v3Ray.scale(1. / fFar);

// Calculate the ray's starting position, then calculate its scattering offset
					var v3Start: IVec3 =  Vec3.stackCeil.set(vEye) ;
					var fHeight:  number  = v3Start.length();
					var fDepth:  number  = math.exp(this._fScaleOverScaleDepth * (this._fInnerRadius - vEye.y));
					var fStartAngle:  number  = v3Ray.dot(v3Start) / fHeight;
					var fStartOffset:  number  = fDepth * this.scale(fStartAngle);

// Initialize the scattering loop variables
					var fSampleLength:  number  = fFar / this._nSamples;
					var fScaledLength:  number  = fSampleLength * this._fScale;
					var v3SampleRay: IVec3 = v3Ray.scale(fSampleLength,  Vec3.stackCeil.set() );
					var v3SamplePoint: IVec3 = v3SampleRay.scale(0.5,  Vec3.stackCeil.set() ).add(v3Start);

// Now loop through the sample rays
					var v3FrontColor: IVec3 =  Vec3.stackCeil.set(0.0) ;

					for(var i:  number  = 0; i < this._nSamples; i++) {
						var fHeight:  number  = v3SamplePoint.length();
						var fDepth:  number  = math.exp(this._fScaleOverScaleDepth * (this._fInnerRadius - fHeight));
						var fLightAngle:  number  = this._v3fSunDir.dot(v3SamplePoint) / fHeight;
						var fCameraAngle:  number  = v3Ray.dot(v3SamplePoint) / fHeight;
						var fScatter:  number  = (fStartOffset + fDepth * (this.scale(fLightAngle) - this.scale(fCameraAngle)));

						var v3Attenuate: IVec3 = this.expv((this._v3fInvWavelength4.scale(this._fKr4PI,  Vec3.stackCeil.set() ).add( Vec3.stackCeil.set(this._fKm4PI) )).scale(-fScatter));


						v3FrontColor.add(v3Attenuate.scale(fDepth * fScaledLength,  Vec3.stackCeil.set() ));
						v3SamplePoint.add(v3SampleRay);
					}

//D3DXVECTOR3 V = vEye - vVecPos;
//D3DXVec3Normalize( &V, &V );

					pBuffer[nIndex * 4 + 0] = math.min( v3FrontColor.x, 6.5519996e4);
					pBuffer[nIndex * 4 + 1] = math.min( v3FrontColor.y, 6.5519996e4);
					pBuffer[nIndex * 4 + 2] = math.min( v3FrontColor.z, 6.5519996e4);
					pBuffer[nIndex * 4 + 3] = 0.0;

					nIndex++;
				}
			}


			var HorizonSamples: IVec3 =  Vec3.stackCeil.set(0.) ;

			for (var x:  number  = 0; x < this._nSize; x++) {
				HorizonSamples.add( Vec3.stackCeil.set(pBuffer[((this._nSize - this._nHorinLevel) * this._nSize + x) * 4 + 0], pBuffer[((this._nSize - this._nHorinLevel) * this._nSize + x) * 4 + 1], pBuffer[((this._nSize - this._nHorinLevel) * this._nSize + x) * 4 + 2])
                                                                            );
			}

			HorizonSamples.scale(1. / < number >this._nSize);

			this._v3fGroundc0.set(HorizonSamples);
			this._v3fGroundc1.set(HorizonSamples);

			this._v3fGroundc0.x *= this._v3fInvWavelength4.x * this._fKrESun;
			this._v3fGroundc0.y *= this._v3fInvWavelength4.y * this._fKrESun;
			this._v3fGroundc0.z *= this._v3fInvWavelength4.z * this._fKrESun;
			this._v3fGroundc1.scale(this._fKmESun);

			pPixelBuffer.blitFromMemory(this._pSkyBlitBox);

// pPixelBuffer.unlock();
// this._bSkyBuffer = !this._bSkyBuffer;
			if (this.sun) {
				this.sun.params.groundC0.set(this._v3fGroundc0);
				this.sun.params.groundC1.set(this._v3fGroundc1);
				this.sun.params.eyePosition.set(this._v3fEye);
				this.sun.params.sunDir.set(this._v3fSunDir);
				this.sun.params.hg.set(this._v3fHG);

// LOG(this._v3fGroundc0.toString(), this._v3fGroundc1.toString())
			}
		}









		createDome(Cols:  number , Rows:  number ): IMesh {
			var DVSize:  number  = Cols * Rows;
			var DISize:  number  = ( Cols - 1 ) * (Rows - 1) * 2;

			var pDome: IMesh = this.getEngine().createMesh("dome", EMeshOptions.HB_READABLE);

// Fill the Vertices Buffer
			var pVertices: Float32Array = new Float32Array(DVSize * 3 + DVSize * 2);

			var DomeIndex:  number  = 0;

			for(var i:  number  = 0; i < Cols; i++ ) {
				var MoveXZ:  number  = math.cos( 1.0 ) * i / (Cols - 1) ;
				for(var j:  number  = 0; j < Rows; j++ ) {
					var MoveY:  number  = (math.PI * 2.0) * j / (Rows - 1);

					pVertices[DomeIndex * 5 + 0] = math.sin(MoveXZ) * math.cos(MoveY);
					pVertices[DomeIndex * 5 + 1] = math.cos(MoveXZ);
					pVertices[DomeIndex * 5 + 2] = math.sin(MoveXZ) * math.sin(MoveY);

					pVertices[DomeIndex * 5 + 3] = j / (Rows - 1.0);
					pVertices[DomeIndex * 5 + 4] = i / (Cols - 1.0);

					DomeIndex++;
				}
			}

// console.log(pVertices);

// Fill the Indices Buffer
			var pIndices: Float32Array = new Float32Array(DISize * 3);
			DomeIndex = 0;

			for ( var i:  number  = 0; i < Rows - 1; i++) {
				for ( var j:  number  = 0; j < Cols - 1; j++) {
					pIndices[DomeIndex++] = i * Rows + j;
					pIndices[DomeIndex++] = (i + 1) * Rows + j;
					pIndices[DomeIndex++] = (i + 1) * Rows + j + 1;

					pIndices[DomeIndex++] = (i + 1) * Rows + j + 1;
					pIndices[DomeIndex++] = i * Rows + j + 1;
					pIndices[DomeIndex++] = i * Rows + j;
				}
			}

			var pSubMesh: IMeshSubset = pDome.createSubset("main", EPrimitiveTypes.TRIANGLELIST);

		    var e = pSubMesh.data.allocateData([VE_VEC3("POSITION"), VE_VEC2("TEXCOORD0")], pVertices);
		    pSubMesh.data.allocateIndex([VE_FLOAT("INDEX0")], pIndices);
		    pSubMesh.data.index(e, "INDEX0");
		    pSubMesh.shadow = false;

		    var pMatrial: IMaterial = pSubMesh.renderMethod.surfaceMaterial.material;
		    pMatrial.diffuse = Color.LIGHT_GRAY;
		    pMatrial.ambient = new Color(0.7, 0.7, 0.7, 1.);
			pMatrial.specular = new Color(0.7, 0.7, 0.7 ,1);
			pMatrial.emissive = new Color(0., 0., 0., 1.);
		    pMatrial.shininess = 30.;

		    if((<core.Engine>this.getEngine()).isDepsLoaded()){
	    		pSubMesh.renderMethod.effect.addComponent("akra.system.sky");
		    }
		    else {
		    	this.getEngine().bind( "depsLoaded" , () => {
		    		pSubMesh.renderMethod.effect.addComponent("akra.system.sky");
		    	});
		    }

		    this.connect(pSubMesh.getTechnique(),  "render" ,  "_onDomeRender" );

		    return pDome;
		}

		k:  number  = 1;
// update(pModelView: IMat4, pProjection: IMat4, pPass: IRenderPass): void {
		update(pSceneObject: ISceneObject, pCamera: ICamera, pPass: IRenderPass): void {
			var pProjection: IMat4 = pCamera.projectionMatrix;
			var m4fModel: IMat4 =  Mat4.stackCeil.set(pSceneObject.worldMatrix) ;

// pModelView.data[__41] = 0.0;
// pModelView.data[__42] = 0.0;
// pModelView.data[__43] = 0.0;

			m4fModel.setTranslation( Vec3.stackCeil.set(0.0, -this._fInnerRadius - 1.0e-6, 0.0) .add(pCamera.worldPosition));
			m4fModel.scaleRight( Vec3.stackCeil.set(this._fOuterRadius* this.k) );

			var pModelView: IMat4 = pCamera.viewMatrix.multiply(m4fModel,  Mat4.stackCeil.set() );

// var m4fTranslation: IMat4 = mat4(1.).setTranslation(vec3(0.0, -this._fInnerRadius - 1.0e-6, 0.0));
// pModelView.multiply(m4fTranslation);

			var MP: IMat4 = pProjection.multiply(pModelView,  Mat4.stackCeil.set() );

			pPass.setUniform("WorldViewProjection", MP);
			pPass.setUniform("fKrESun", this._fKrESun);
			pPass.setUniform("fKmESun", this._fKmESun);
			var v2fTemp: IVec2 =  Vec2.stackCeil.set(< number >this._nSize, 1.0 / this._nSize) ;
			pPass.setUniform("Tex", v2fTemp);
			pPass.setUniform( "vSunPos", this._v3fSunDir);
			pPass.setUniform("vHG", this._v3fHG);
			pPass.setUniform("vInvWavelength", this._v3fInvWavelength4);
			pPass.setUniform( "vEye", this._v3fEye);
			pPass.setUniform( "fOuterRadius", this._fOuterRadius);

			pPass.setTexture("tSkyBuffer", this.getRead());
		}

		setTime(T:  number ): void {
			var time:  number  = this.time = T;
/*1.3788101;*/
			var meridian:  number  = 56.48 * math.RADIAN_RATIO;
/*1.3852096;*/
			var longitude:  number  = 105.5 * math.RADIAN_RATIO;
			var latitude:  number  = 0.762127107;
			var day:  number  = 172;

			var t:  number , delta:  number ;
			var A:  number , B:  number , C:  number , D:  number , E:  number , F:  number ;

			A = 4 * math.PI * (day - 80) / 373;
			B = 2 * math.PI * (day - 8)  / 355;
			C = 2 * math.PI * (day - 81) / 368;

			t = time +
				0.170 * math.sin(A) -
				0.129 * math.sin(B) +
				12 * (meridian - longitude) / math.PI;

			delta = 0.4093 * math.sin(C);

			D = math.PI * t / 12;

			E = math.sin(latitude) * math.sin(delta) -
				math.cos(latitude) * math.cos(delta) * math.cos(D);

			F = (-math.cos(delta) * math.sin(D)) / (math.cos(latitude) * math.sin(delta) -
				math.sin(latitude) * math.cos(delta) * math.cos(D));

			this._fSunTheta = math.PI * 0.5 - < number >math.asin(E);
			this._fSunPhi = < number >math.atan(F);
/*		
			vSunDir.x = math.cos(this._fSunPhi) * math.sin(this._fSunTheta);
			vSunDir.y = math.sin(this._fSunPhi) * math.sin(this._fSunTheta);
			vSunDir.z = math.cos(this._fSunTheta);
	*/

			this._v3fSunDir.x = 0.0;
			this._v3fSunDir.y = < number >math.cos(T * 0.1);
			this._v3fSunDir.z = < number >math.sin(T * 0.1);

			var Zenith: IVec3 =  Vec3.stackCeil.set(0, 1, 0) ;
			this._fSunTheta = math.acos(this._v3fSunDir.dot(Zenith));

			this._v3fSunDir.normalize();

			this.updateSkyBuffer();
			this.updateSunLight();
		}

		_onDomeRender(pTechnique: IRenderTechnique, iPass:  number ,
			pRenderable: IRenderableObject, pSceneObject: ISceneObject, pViewport: IViewport): void {
			var pPass: IRenderPass = pTechnique.getPass(iPass);
			var pCamera: ICamera = pViewport.getCamera();
			this.update(pSceneObject, pCamera, pPass);
		}

		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Sky._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
	}
}
























module akra {
	export enum EDocumentEntry {
		k_Unknown,

		k_Instance,
		k_Controller,
		k_Animation,
		k_AnimationBlend,
		k_AnimationContainer,
		k_SceneNode
	}

	export enum EDocumentFormat {
		JSON,
		BINARY_JSON
	}

	export interface IEntry {
		guid?:  number ;
	}

	export interface IDataEntry extends IEntry {
		type: EDocumentEntry;
		extra?: any;
	}

	export interface ILibraryEntry extends IEntry {
		data: IUnique;
		entry: IDataEntry;
	}

	export interface ILibrary {
		[guid:  number ]: ILibraryEntry;
	}


	export interface IContributor {
        author?: string;
        authoringTool?: string;
        comments?: string;
        copyright?: string;
        sourceData?: any;
    }

    export interface IUnit {
        name: string;
        meter:  number ;
    }

	export interface IAsset {
		unit: IUnit;
        upAxis: string;
        title?: string;
        subject?: string;
        created: string;
        modified: string;
        keywords: string[];
        contributor?: IContributor;
	}

	export interface IAnimationFrameEntry {
		time:  number ;
		weight:  number ;
		matrix:  number [];
		type:  number ;
	}

	export interface IAnimationTrackEntry {
		interpolation: EAnimationInterpolations;
		keyframes: IAnimationFrameEntry[];
		targetName: string;
		target:  number ;
	}

	export interface IAnimationTargetEntry {
		target:  number ;
		name: string;
	}

	export interface IAnimationBaseEntry extends IDataEntry {
		name: string;
		targets: IAnimationTargetEntry[];
//additional information abtout position on animation graph
		extra: {
			graph?: { x:  number ; y:  number ; };
		};
	}

	export interface IAnimationEntry extends IAnimationBaseEntry {
		tracks: IAnimationTrackEntry[];
	}

	export interface IAnimationBlendElementEntry {
		animation:  number ;
		weight:  number ;
		mask: FloatMap;
// acceleration: float;
	}

	export interface IAnimationBlendEntry extends IAnimationBaseEntry {
		animations: IAnimationBlendElementEntry[];
	}

	export interface IAnimationContainerEntry extends IAnimationBaseEntry {
		enable: bool;
		startTime:  number ;
		speed:  number ;
		loop: bool;
		animation:  number ;
		reverse: bool;
		pause: bool;
		leftInfinity: bool;
		rightInfinity: bool;
	}

	export interface IControllerEntry extends IDataEntry {
		animations:  number [];
		options:  number ;
		name: string;
	}


	export interface IDocument {
		asset?: IAsset;
		library: IDataEntry[];
		scenes:  number [];
	}


}



























module akra {
	;

	export interface IPackerOptions {
		header?: bool;
	}

	export interface IPacker extends IBinWriter {
		template: IPackerTemplate;

		write(pData: any, sType?: string, bHeader?: bool): bool;
	}
}











module akra {
	export interface IPackerBlacklist {
		[type: string]: Function;
	};

	export interface IPackerCodec {
/**
		 * Как читать данные кодека
		 * @type {String | () => any}
		 */

		read?: any;
/**
		 * Как писать данные
		 * @type{String | (pData: any) => void}
		 */

		write?: any;
	}

	export interface IPackerFormat {
		[type: string]: string;
		[type: string]: IPackerCodec;
	}

//вспомогательный класс, для разрешения форматов, при упаковке данных
	export interface IPackerTemplate {
		getType(iType:  number ): any;
		getTypeId(sType: string):  number ;

		set(pFormat: IPackerFormat): void;

		detectType(pObject: any): string;
		resolveType(sType: string): string;
		properties(sType): IPackerCodec;
		data(): IPackerFormat;
	}
}



module akra.io {
	var pCommonTemplate: IPackerTemplate = null;

	export function getPackerTemplate(): IPackerTemplate {
		return pCommonTemplate;
	}

	export class PackerTemplate {
		protected _pData: IPackerFormat = <IPackerFormat>{};
		protected _nTypes:  number  = 0;
		protected _pNum2Tpl: StringMap = <StringMap>{};
		protected _pTpl2Num: IntMap = <IntMap>{};

		constructor (pData?: IPackerFormat) {
			if (isDef(pData)) {
				this.set(pData);
			}
		}

		getType(iType:  number ): string {
			{ logger.setSourceLocation( "PackerFormat.ts" , 26 ); logger.assert(isDef(this._pNum2Tpl[iType]), "unknown type detected: " + iType); } ;
			return this._pNum2Tpl[iType];
		}

		getTypeId(sType: string):  number  {
			{ logger.setSourceLocation( "PackerFormat.ts" , 31 ); logger.assert(isDef(this._pTpl2Num[sType]), "unknown type detected: " + sType); } ;
			return this._pTpl2Num[sType];
		}

		set(pFormat: IPackerFormat): void {
			var iType:  number ;

		    for (var i in pFormat) {
		        this._pData[i] = pFormat[i];

		        iType = this._nTypes ++;

		        this._pNum2Tpl[iType] = i;
		        this._pTpl2Num[i] = iType;
		    }
		}

		detectType(pObject: any): string {
			return PackerTemplate.getClass(pObject);
		}

		resolveType(sType: string): string {
			var pTemplates: IPackerFormat = this._pData;
			var pProperties: IPackerCodec;
			var sProperties: string;


			while (isString(sProperties = pTemplates[sType])) {
		        sType = sProperties;
		    }

			{ logger.setSourceLocation( "PackerFormat.ts" , 62 ); logger.assert(!isString(sProperties), "cannot resolve type: " + sType); } ;

		    return sType;
		}

		properties(sType): IPackerCodec {
			var pProperties: any = this._pData[sType];

			if (isString(pProperties)) {
				return this.properties(this.resolveType(sType));
			}

		    return <IPackerCodec>pProperties;
		}

		data(): IPackerFormat {
			return this._pData;
		}

		static getClass(pObj: any): string {
			 if (pObj &&
			 	isObject(pObj) &&
		        Object.prototype.toString.call(pObj) !== "[object Array]" &&
		        isDefAndNotNull(pObj.constructor) && pObj != this.window) {

		        var arr: string[] = pObj.constructor.toString().match(/function\s*(\w+)/);

		        if (!isNull(arr) && arr.length == 2) {
		            return arr[1];
		        }
		    }

		    var sType: string = typeOf(pObj);

		    if (sType === "array" && isDef(pObj.$type)) {
		    	sType = pObj.$type;
		    }

		    return sType[0].toUpperCase() + sType.substr(1);
		}
	}

	pCommonTemplate = new PackerTemplate;

	pCommonTemplate.set({
		"Float32Array": {
			write	: function (pData) { this.float32Array(pData); },
			read	: function () { return this.float32Array(); }
		},
		"Float64Array": {
			write	: function (pData) { this.float64Array(pData); },
			read	: function () { return this.float64Array(); }
		},

		"Int32Array":  {
			write	: function (pData) { this.int32Array(pData); },
			read	: function () { return this.int32Array(); }
		},
		"Int16Array": {
			write	: function (pData) { this.int16Array(pData); },
			read	: function () { return this.int16Array(); }
		},
		"Int8Array"	: {
			write	: function (pData) { this.int8Array(pData); },
			read	: function () { return this.int8Array(); }
		},

		"Uint32Array": {
			write	: function (pData) { this.uint32Array(pData); },
			read	: function () { return this.uint32Array(); }
		},
		"Uint16Array": {
			write	: function (pData) { this.uint16Array(pData); },
			read	: function () { return this.uint16Array(); }
		},
		"Uint8Array" : {
			write	: function (pData) { this.uint8Array(pData); },
			read	: function () { return this.uint8Array(); }
		},

		"String": {
			write	: function (str) { this.string(str); },
			read	: function () { return this.string(); }
		},

//float
		"Float64": {
			write	: function (val) { this.float64(val); },
			read	: function () { return this.float64(); }
		},
		"Float32": {
			write	: function (val) { this.float32(val); },
			read	: function () { return this.float32(); }
		},


//int
		"Int32"	: {
			write	: function (val) { this.int32(val); },
			read	: function () { return this.int32(); }
		},
		"Int16"	: {
			write	: function (val) { this.int16(val); },
			read	: function () { return this.int16(); }
		},
		"Int8"	: {
			write	: function (val) { this.int8(val); },
			read	: function () { return this.int8(); }
		},

//uint
		"Uint32": {
			write	: function (val) { this.uint32(val); },
			read	: function () { return this.uint32(); }
		},
		"Uint16": {
			write	: function (val) { this.uint16(val); },
			read	: function () { return this.uint16(); }
		},
		"Uint8"	: {
			write	: function (val) { this.uint8(val); },
			read	: function () { return this.uint8(); }
		},

		"Boolean": {
			write	: function (b) { this.bool(b); },
			read	: function () { return this.bool(); }
		},

		"Object": {
			write: function (object: any) {

				if (isArray(object)) {
/*is array*/
					this.bool(true);
					this.uint32((<any[]>object).length);

					for (var i = 0; i < (<any[]>object).length; ++ i) {
						this.write((<any[]>object)[i]);
					}
				}
				else {
/*is not array*/
					this.bool(false);
					this.stringArray(Object.keys(object));

					for (var key in object) {
						this.write(object[key]);
					}
				}
			},
			read: function (object: any) {
				var isArray: bool = this.bool();
				var keys: string[];
				var n:  number ;

				if (isArray) {
					n = this.uint32();
					object = object || new Array(n);

					for (var i = 0; i < n; ++ i) {
						object[i] = this.read();
					}
				}
				else {
					object = object || {};
					keys = this.stringArray();

					for (var i = 0; i < keys.length; ++ i) {
						object[keys[i]] = this.read();
					}
				}

				return object;
			}
		},

		"Function": {
			write: function (fn: Function): void {
				var sFunc: string = String(fn.valueOf());
				var sBody: string = sFunc.substr(sFunc.indexOf("{") + 1, sFunc.lastIndexOf("}") - sFunc.indexOf("{") - 1);
				var pArgs: string[] = sFunc.substr(sFunc.indexOf("(") + 1, sFunc.indexOf(")") - sFunc.indexOf("(") - 1).match(/[$A-Z_][0-9A-Z_$]*/gi);
//var sName: string = null;

//var pMatches: string[] = sFunc.match(/(function\s+)([_$a-zA-Z][_$a-zA-Z0-9]*)(?=\s*\()/gi);

// if (isDefAndNotNull(pMatches) && pMatches.length > 2) {
// 	sName = pMatches[2];
// }

//this.string(sName);
				this.stringArray(pArgs);
				this.string(sBody);
			},
			read: function (): Function {
				return new Function(this.stringArray(), this.string());
			}
		},
		"Number": "Float32",
		"Float"	: "Float32",
		"Int"	: "Int32",
		"Uint"	: "Uint32",
		"Array"	: "Object"
	});
}












module akra {
	export interface IBinWriter {
		byteLength:  number ;

		string(sData: string): void;

		uint32(iValue:  number ): void;
		uint16(iValue:  number ): void;
		uint8(iValue:  number ): void;

		bool(bValue: bool): void;

		int32(iValue:  number ): void;
		int16(iValue:  number ): void;
		int8(iValue:  number ): void;

		float64(fValue:  number ): void;
		float32(fValue:  number ): void;

		stringArray(pValue: string[]): void;

		uint32Array(pValue: Uint32Array): void;
		uint16Array(pValue: Uint16Array): void;
		uint8Array(pValue: Uint8Array): void;

		int32Array(pValue: Int32Array): void;
		int16Array(pValue: Int16Array): void;
		int8Array(pValue: Int8Array): void;

		float64Array(pValue: Float64Array): void;
		float32Array(pValue: Float64Array): void;

		data(): ArrayBuffer;
		dataAsString(): string;
		dataAsUint8Array(): Uint8Array;
	}
}



/**
 * Как исполльзовать:
 * var bw = new BinWriter();      //создаем экземпляр класса
 *                        STRING
 * bw.string("abc");              //запигшет строку
 * bw.stringArray(["abc", "abc"]) //запишет массив строк
 *                        UINT
 * bw.uint8(1)             //варовняет до 4 байт uint и запишет
 * bw.uint16(1)            //варовняет до 4 байт uint и запишет
 * bw.uint32(1)            //запишет uint32
 * bw.uint8Array([1, 2])   //запишет массив uint8 где каждое число будет занимать
 *                         //1 байт и выровняет общую длинну массива до 4
 * bw.uint16Array([1, 2])  //запишет массив uint16 где каждое число будет занимать
 *                         //2 байта и выровняет общую длинну массива до 4
 * bw.uint32Array([1, 2])  //запишет массив uint32 где каждое число будет занимать
 *                         //4 байта
 *                        INT
 * bw.int8(1)              //варовняет до 4 байт int и запишет
 * bw.int16(1)             //варовняет до 4 байт int и запишет
 * bw.int32(1)             //запишет int32
 * bw.int8Array([1, 2])    //запишет массив int8 где каждое число будет занимать
 *                         //1 байт и выровняет общую длинну массива до 4
 * bw.int16Array([1, 2])   //запишет массив int16 где каждое число будет занимать
 *                         //2 байта и выровняет общую длинну массива до 4
 * bw.int32Array([1, 2])   //запишет массив int32 где каждое число будет занимать
 *                         //4 байта
 *                         FLOAT
 * bw.float64(1.1)             //запишет float64
 * bw.float32(1.1)             //запишет float32
 * bw.float32Array([1.2, 2.3]) //запишет массив float32
 * bw.float64Array([1.2, 2.3]) //запишет массив float64
 *
 * bw.data()             //возвратит массив типа ArrayBuffer где бедет лежать все записанные данные
 * bw.dataAsString()     //соберет все данные в строку и вернет
 * bw.dataAsUint8Array() //соберет все данные в массив Uint8 и вернет
 */




module akra.io {
	export class BinWriter implements IBinWriter {
/**
	     * Двумерный массив куда заносятся данные.
	     * @private
	     * @type Uint8Array[]
	     */

	    protected _pArrData: Uint8Array[] = [];
/**
	     * Счетчик общего количества байт.
	     * @private
	     * @type int
	     */

	    protected _iCountData:  number  = 0;

		/**@inline*/  get byteLength():  number  {
			return this._iCountData;
		}

/******************************************************************************/

/*                                 string                                     */

/******************************************************************************/


/**
		 * @property string(str)
		 * Запись строки. Перед строкой записывается длинна строки в тип uint32. Если
		 * передано null или undefined то длинна строки записывается как 0xffffffff.
		 * Это сделано для того что при дальнейшем считывании такая строка будет
		 * возвращена как null.
		 * @memberof BinWriter
		 * @tparam String str строка. Все не строковые типы преобразуются к строке.
		 */

		string(str: string): void {
		    if (!isDefAndNotNull(str)) {
		        this.uint32(MAX_UINT32);
		        return;
		    }

		    str = String(str);

// LOG("string: ", str);

		    var sUTF8String: string = str.toUTF8();
		    var iStrLen:  number  = sUTF8String.length;
		    var arrUTF8string: Uint8Array = BinWriter.rawStringToBuffer(sUTF8String);

		    { logger.setSourceLocation( "BinWriter.ts" , 92 ); logger.assert(iStrLen <= Math.pow(2, 32) - 1, "Это значение не влезет в тип string"); } ;

		    this.uint32(iStrLen);

		    var iBitesToAdd:  number  = (( 4 - (iStrLen % 4) == 4)) ? 0 : ( 4 - (iStrLen % 4));

		    this._pArrData[this._pArrData.length] = arrUTF8string;
		    this._iCountData += (iStrLen + iBitesToAdd);
//trace('string', str);
		}

/******************************************************************************/

/*                                   uintX                                    */

/******************************************************************************/


/**
		 * @property uintX(iValue, iX)
		 * Запись числа типа uint(8, 16, 32). Если число занимает меньше 4 байт то оно
		 * выравнивается до 4 байт. Если передан null то число принимается равным 0.
		 * Если передано любое другое не числовое значение то выводится ошибка.
		 * @memberof BinWriter
		 * @tparam uint iValue число.
		 * @tparam int iX - 8, 16, 32 количество бит.
		 */

		private uintX(iValue:  number , iX:  number ): void {

		    if (isNull(iValue)) {
		        iValue = 0;
		    }

// LOG("uint" + iX + ": ", iValue);

		    { logger.setSourceLocation( "BinWriter.ts" , 124 ); logger.assert(isNumber(iValue), "Не является числом: " + iValue); } ; ;

		    { logger.setSourceLocation( "BinWriter.ts" , 126 ); logger.assert(0 <= iValue && iValue <= Math.pow(2, iX), "Это значение не влезет в тип uint" + iX); } ;
		    var arrTmpBuf: ArrayBufferView = null;

		    switch (iX) {
		        case 8:
		            arrTmpBuf = new Uint8Array(4);
		            arrTmpBuf[0] = iValue;
		            break;
		        case 16:
		            arrTmpBuf = new Uint16Array(2);
		            arrTmpBuf[0] = iValue;
		            break;
		        case 32:
		            arrTmpBuf = new Uint32Array(1);
		            arrTmpBuf[0] = iValue;
		            break;
		        default:
		            { logger.setSourceLocation( "BinWriter.ts" , 143 ); logger.error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32."); } ;
		            break;
		    }
//trace('uint' + iX, iValue);
//if(iX == 8)
//  this._pArrData[this._pArrData.length] = arrTmpBuf;
//else
		    this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
		    this._iCountData += 4;
		}

/**
		 * @property uint8(iValue)
		 * Запись числа типа uint8. Оно выравнивается до 4 байт. Если передан null то
		 * число принимается равным 0. Если передано любое другое не числовое значение
		 * то выводится ошибка.
		 * Сокращенная запись функции uintX(iValue, 8).
		 * @memberof BinWriter
		 * @tparam uint iValue число.
		 */

		/**@inline*/  uint8(iValue:  number ): void {
		    this.uintX(iValue, 8);
		}

/**
		 * @property uint16(iValue)
		 * Запись числа типа uint16. Оно выравнивается до 4 байт. Если передан null то
		 * число принимается равным 0. Если передано любое другое не числовое значение
		 * то выводится ошибка.
		 * Сокращенная запись функции uintX(iValue, 16).
		 * @memberof BinWriter
		 * @tparam uint iValue число.
		 */

		/**@inline*/  uint16(iValue:  number ): void {
		    this.uintX(iValue, 16);
		}

/**
		 * @property uint32(iValue)
		 * Запись числа типа uint8. Если передан null то число принимается равным 0.
		 * Если передано любое другое не числовое значение то выводится ошибка.
		 * Сокращенная запись функции uintX(iValue, 32).
		 * @memberof BinWriter
		 * @tparam uint iValue число.
		 */

		/**@inline*/  uint32(iValue:  number ): void {
		    this.uintX(iValue, 32);
		}

/**
		 * @property bool(bValue)
		 * Запись числа типа bool. В зависимости от bValue записывается либо 1 либо ноль.
		 * Если передано любое другое не числовое значение то выводится ошибка.
		 * Сокращенная запись функции uintX(bValue? 1: 0, 8).
		 * @memberof BinWriter
		 * @tparam bool bValue число.
		 */

		/**@inline*/  bool(bValue: bool): void {
// LOG(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>> BOOL >>> ");
		    this.uintX(bValue ? 1 : 0, 8);
		}


/******************************************************************************/

/*                       writeArrayElementUintX                               */

/******************************************************************************/


/**
		 * @property writeArrayElementUintX(iValue, iX)
		 * Запись числа типа uint(8, 16, 32). Используется для записи элементов массивов.
		 * В отличии от uintX число не выравнивается до 4 байт, а записывается ровно
		 * столько байт сколько передано во втором параметре в функцию. Вторым
		 * параметром передается колчиество бит а не байт. Если передан null то число
		 * принимается равным 0. Если передано любое другое не числовое значение то
		 * выводится ошибка.
		 * @memberof BinWriter
		 * @tparam uint iValue число.
		 * @tparam int iX - 8, 16, 32 количество бит.
		 */

		private writeArrayElementUintX(iValue:  number , iX:  number ): void {
		    if (isNull(iValue)) {
		        iValue = 0;
		    }

// LOG("array uint", iX, ": ", iValue);

		    { logger.setSourceLocation( "BinWriter.ts" , 229 ); logger.assert(isNumber(iValue), "Не является числом: " + iValue); } ;
		    { logger.setSourceLocation( "BinWriter.ts" , 230 ); logger.assert(0 <= iValue && iValue <= Math.pow(2, iX), "Это значение не влезет в тип uint" + iX); } ;

		    var arrTmpBuf: ArrayBufferView = null;

		    switch (iX) {
/* WARNING Только private и записи масивов. Нет выравнивания на 4, оно ложится на функцию записи массива.*/
		        case 8:
		            arrTmpBuf = new Uint8Array(1);
		            arrTmpBuf[0] = iValue;
		            break;
/* WARNING Только private и записи масивов. Нет выравнивания на 4, оно ложится на функцию записи массива.*/
		        case 16:
		            arrTmpBuf = new Uint16Array(1);
		            arrTmpBuf[0] = iValue;
		            break;
		        case 32:
		            arrTmpBuf = new Uint32Array(1);
		            arrTmpBuf[0] = iValue;
		            break;
		        default:
		            { logger.setSourceLocation( "BinWriter.ts" , 248 ); logger.error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32."); } ;
		            break;
		    }

		    if (iX == 8) {
		        this._pArrData[this._pArrData.length] = <Uint8Array>arrTmpBuf;
		    }
		    else {
		        this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
		    }

		    this._iCountData += (iX / 8);
		}

/******************************************************************************/

/*                                    intX                                    */

/******************************************************************************/


/**
		 * @property intX(iValue, iX)
		 * Запись числа типа int(8, 16, 32). Если число занимает меньше 4 байт то оно
		 * выравнивается до 4 байт. Если передан null то число принимается равным 0.
		 * Если передано любое другое не числовое значение то выводится ошибка.
		 * @memberof BinWriter
		 * @tparam int iValue число.
		 * @tparam int iX - 8, 16, 32 количество бит.
		 */

		private intX(iValue:  number , iX:  number ): void {
		    if (isNull(iValue)) {
		        iValue = 0;
		    }

// LOG("int", iX, ": ", iValue);

		    { logger.setSourceLocation( "BinWriter.ts" , 282 ); logger.assert(isNumber(iValue), "Не является числом: " + iValue); } ;
		    { logger.setSourceLocation( "BinWriter.ts" , 284 ); logger.assert(-Math.pow(2, iX - 1) <= iValue && iValue <= Math.pow(2, iX - 1) - 1, "Это значение не влезет в тип int" + iX); }
                                                                                  ;

		    var arrTmpBuf: ArrayBufferView = null;

		    switch (iX) {
		        case 8:
		            arrTmpBuf = new Int8Array(4);
		            arrTmpBuf[0] = iValue;
		            break;
		        case 16:
		            arrTmpBuf = new Int16Array(2);
		            arrTmpBuf[0] = iValue;
		            break;
		        case 32:
		            arrTmpBuf = new Int32Array(1);
		            arrTmpBuf[0] = iValue;
		            break;
		        default:
		            { logger.setSourceLocation( "BinWriter.ts" , 302 ); logger.error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32."); } ;
		            break;
		    }
//trace('int' + iX, iValue);
		    this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
		    this._iCountData += 4;
		}

/**
		 * @property int8(iValue)
		 * Запись числа типа int8. Оно выравнивается до 4 байт. Если передан null то
		 * число принимается равным 0. Если передано любое другое не числовое значение
		 * то выводится ошибка.
		 * Сокращенная запись функции intX(iValue, 8).
		 * @memberof BinWriter
		 * @tparam uint iValue число.
		 */

		/**@inline*/  int8(iValue:  number ): void {
		    this.intX(iValue, 8);
		}

/**
		 * @property int16(iValue)
		 * Запись числа типа uint16. Оно выравнивается до 4 байт. Если передан null то
		 * число принимается равным 0. Если передано любое другое не числовое значение
		 * то выводится ошибка.
		 * Сокращенная запись функции intX(iValue, 16).
		 * @memberof BinWriter
		 * @tparam int iValue число.
		 */

		/**@inline*/  int16(iValue:  number ): void {
		    this.intX(iValue, 16);
		}

/**
		 * @property uint32(iValue)
		 * Запись числа типа uint8. Если передан null то число принимается равным 0.
		 * Если передано любое другое не числовое значение то выводится ошибка.
		 * Сокращенная запись функции intX(iValue, 32).
		 * @memberof BinWriter
		 * @tparam int iValue число.
		 */

		/**@inline*/  int32(iValue:  number ): void {
		    this.intX(iValue, 32);
		}

/******************************************************************************/

/*                          writeArrayElementIntX                            */

/******************************************************************************/


/**
		 * @property writeArrayElementIntX(iValue, iX)
		 * Запись числа типа int(8, 16, 32). Используется для записи элементов массивов.
		 * В отличии от intX число не выравнивается до 4 байт, а записывается ровно
		 * столько байт сколько передано во втором параметре в функцию. Вторым
		 * параметром передается колчиество бит а не байт. Если передан null то число
		 * принимается равным 0. Если передано любое другое не числовое значение то
		 * выводится ошибка.
		 * @memberof BinWriter
		 * @tparam int iValue число.
		 * @tparam int iX - 8, 16, 32 количество бит.
		 */

		private writeArrayElementIntX(iValue:  number , iX:  number ) {
		    if (isNull(iValue)) {
		        iValue = 0;
		    }

// LOG("array int", iX, ": ", iValue);

		    { logger.setSourceLocation( "BinWriter.ts" , 371 ); logger.assert(isNumber(iValue), "Не является числом: " + iValue); } ;
		    { logger.setSourceLocation( "BinWriter.ts" , 373 ); logger.assert(-Math.pow(2, iX - 1) <= iValue && iValue <= Math.pow(2, iX - 1) - 1, "Это значение не влезет в тип int" + iX); }
                                                                                  ;

		    var arrTmpBuf: ArrayBufferView = null;

		    switch (iX) {
/* WARNING Только private и записи масивов. Нет выравнивания на 4, оно ложится на функцию записи массива.*/
		        case 8:
		            arrTmpBuf = new Int8Array(1);
		            arrTmpBuf[0] = iValue;
		            break;
/* WARNING Только private и записи масивов. Нет выравнивания на 4, оно ложится на функцию записи массива.*/
		        case 16:
		            arrTmpBuf = new Int16Array(1);
		            arrTmpBuf[0] = iValue;
		            break;
		        case 32:
		            arrTmpBuf = new Int32Array(1);
		            arrTmpBuf[0] = iValue;
		            break;
		        default:
		            { logger.setSourceLocation( "BinWriter.ts" , 391 ); logger.error("Передано недопустимое значение длинны. Допустимые значения 8, 16, 32."); } ;
		            break;
		    }
		    this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
		    this._iCountData += (iX / 8);
		}

/******************************************************************************/

/*                                  floatX                                    */

/******************************************************************************/


/**
		 * @property floatX(fValue, iX)
		 * Запись числа типа float(32, 64). выравнивания не происходит т.к. они уже
		 * выравнены до 4. Если передан null то число принимается равным 0.
		 * Если передано любое другое не числовое значение то выводится ошибка.
		 * @memberof BinWriter
		 * @tparam float fValue число.
		 * @tparam int iX - 32, 64 количество бит.
		 */

		private floatX(fValue:  number , iX:  number ): void {
		    if (isNull(fValue)) {
		        fValue = 0;
		    }

		    { logger.setSourceLocation( "BinWriter.ts" , 416 ); logger.assert(isNumber(fValue), "Не является числом: " + fValue); } ;
//debug_assert(typeof(fValue) == 'number', "Не является числом");

// LOG("float", iX, ": ", fValue);

		    var arrTmpBuf: ArrayBufferView = null;

		    switch (iX) {
		        case 32:
		            arrTmpBuf = new Float32Array(1);
		            arrTmpBuf[0] = fValue;
		            break;
		        case 64:
		            arrTmpBuf = new Float64Array(1);
		            arrTmpBuf[0] = fValue;
		            break;
		        default:
		            { logger.setSourceLocation( "BinWriter.ts" , 433 ); logger.error("Передано недопустимое значение длинны. Допустимые значения 32, 64."); } ;
		            break;
		    }
//trace('float' + iX, fValue);
		    this._pArrData[this._pArrData.length] = new Uint8Array(arrTmpBuf.buffer);
		    this._iCountData += (iX / 8);
		}

/**
		 * @property float32(fValue)
		 * Запись числа типа float32. Если передан null то число принимается равным 0.
		 * Если передано любое другое не числовое значение то выводится ошибка.
		 * Сокращенная запись функции floatX(fValue, 32).
		 * @memberof BinWriter
		 * @tparam float fValue число.
		 */

		/**@inline*/  float32(fValue) {
		    this.floatX(fValue, 32);
		}

/**
		 * @property float64(fValue)
		 * Запись числа типа float64. Если передан null то число принимается равным 0.
		 * Если передано любое другое не числовое значение то выводится ошибка.
		 * Сокращенная запись функции floatX(fValue, 64).
		 * @memberof BinWriter
		 * @tparam float fValue число.
		 */

		/**@inline*/  float64(fValue) {
		    this.floatX(fValue, 64);
		}


/******************************************************************************/

/*                             stringArray                                    */

/******************************************************************************/


/**
		 * @property stringArray(arrString)
		 * Записывает массив строк использую дял каждого элемента функцию this.string
		 * Да начала записи элементов записывает общее количество элементов как число
		 * uint32. Если в качестве параметра функции передано null или undefined
		 * то количество элементов записывается равным 0xffffffff.
		 * @memberof BinWriter
		 * @tparam Array arrString массив строк.
		 */

		stringArray(arrString: string[]): void {
		    if (!isDefAndNotNull(arrString)) {
		        this.uint32(0xffffffff);
		        return;
		    }

		    this.uint32(arrString.length);
		    for (var i = 0; i < arrString.length; i++) {
		        this.string(arrString[i]);
		    }
		}

/******************************************************************************/

/*                             uintXArray                                     */

/******************************************************************************/


/**
		 * @property uintXArray(arrUint, iX)
		 * Записывает массив чисел uint(8, 16, 32) использую для каждого элемента функцию
		 *  writeArrayElementUintX. До начала записи элементов записывает общее
		 *  количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff. Общее количество байт в массиве выравнивается к 4.
		 * Все массивы приводятся к нужному типу Uint(iX)Array.
		 * @memberof BinWriter
		 * @tparam Uint(iX)Array arrUint массив uint(iX).
		 * @tparam int iX размер элемента в битах (8, 16, 32).
		 */

		uintXArray(arrUint: ArrayBufferView, iX:  number ): void {
		    if (!isDefAndNotNull(arrUint)) {
		        this.uint32(0xffffffff);
		        return;
		    }

		    var iUintArrLength:  number  = arrUint.byteLength;
		    var iBitesToAdd:  number ;
		    var arrTmpUint: ArrayBufferView = null;

		    switch (iX) {
		        case 8:
		            iBitesToAdd = (( 4 - (iUintArrLength % 4) == 4)) ? 0 : ( 4 - (iUintArrLength % 4));
		            if (iBitesToAdd > 0 || !(arrUint instanceof Uint8Array)) {
		                arrTmpUint = new Uint8Array(iUintArrLength + iBitesToAdd);
		                (<Uint8Array>arrTmpUint).set(<Uint8Array>arrUint);
		            }
		            else {
		                arrTmpUint = arrUint;
		            }
		            break;
		        case 16:
		        	iUintArrLength /= 2;
		            iBitesToAdd = (( 2 - (iUintArrLength % 2) == 2)) ? 0 : ( 2 - (iUintArrLength % 2));
		            if (iBitesToAdd > 0 || !(arrUint instanceof Uint16Array)) {
		                arrTmpUint = new Uint16Array(iUintArrLength + iBitesToAdd);
		                (<Uint16Array>arrTmpUint).set(<Uint16Array>arrUint);
		            }
		            else {
		                arrTmpUint = arrUint;
		            }
		            break;
		        case 32:
		        	iUintArrLength /= 4;
		            if (!(arrUint instanceof Uint32Array)) {
		                arrTmpUint = new Uint32Array(<any>arrUint);
		            }
		            else {
		                arrTmpUint = arrUint;
		            }
		            break;
		    }

		    this.uint32(iUintArrLength);

		    for (var i:  number  = 0, n:  number  = arrTmpUint.byteLength / (iX / 8); i < n; i++) {
		        this.writeArrayElementUintX(arrTmpUint[i], iX);
		    }
		}

/**
		 * @property uint8Array(arrUint)
		 * Запись массива типа Uint8Array. До начала записи элементов записывает общее
		 * количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff. Общее количество байт в массиве выравнивается до 4.
		 * Сокращенная запись функции uintXArray(arrUint, 8).
		 * @memberof BinWriter
		 * @tparam Uint8Array arrUint массив uint8.
		 */

		/**@inline*/  uint8Array(arrUint: Uint8Array): void {
		    this.uintXArray(arrUint, 8);
		}

/**
		 * @property uint16Array(arrUint)
		 * Запись массива типа Uint16Array. До начала записи элементов записывает общее
		 * количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff. Общее количество байт в массиве выравнивается до 4.
		 * Сокращенная запись функции uintXArray(arrUint, 16).
		 * @memberof BinWriter
		 * @tparam Uint16Array arrUint массив uint16.
		 */

		/**@inline*/  uint16Array(arrUint: Uint16Array): void {
		    this.uintXArray(arrUint, 16);
		}

/**
		 * @property uint32Array(arrUint)
		 * Запись массива типа Uint32Array. До начала записи элементов записывает общее
		 * количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff.
		 * Сокращенная запись функции uintXArray(arrUint, 32).
		 * @memberof BinWriter
		 * @tparam Uint32Array arrUint массив uint32.
		 */

		/**@inline*/  uint32Array(arrUint: Uint32Array): void {
		    this.uintXArray(arrUint, 32);
		}


/******************************************************************************/

/*                               intXArray                                    */

/******************************************************************************/


/**
		 * @property intXArray(arrInt, iX)
		 * Записывает массив чисел int(8, 16, 32) использую для каждого элемента функцию
		 *  writeArrayElementIntX. До начала записи элементов записывает общее
		 *  количество элементов как число int32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff. Общее количество байт в массиве выравнивается к 4.
		 * Все массивы приводятся к нужному типу Int(iX)Array.
		 * @memberof BinWriter
		 * @tparam Int(iX)Array arrUint массив int(iX).
		 * @tparam int iX размер элемента в битах (8, 16, 32).
		 */

		intXArray(arrInt: ArrayBufferView, iX:  number ): void {
		    if (!isDefAndNotNull(arrInt)) {
		        this.uint32(0xffffffff);
		        return;
		    }

		    var iIntArrLength:  number  = 0;
		    var iBitesToAdd:  number  = 0;
		    var arrTmpInt: ArrayBufferView = null;

		    switch (iX) {
		        case 8:
		        	iIntArrLength = (<Int8Array>arrInt).length;
		            iBitesToAdd = (( 4 - (iIntArrLength % 4) == 4)) ? 0 : ( 4 - (iIntArrLength % 4));
		            if (iBitesToAdd > 0 || !(arrInt instanceof Int8Array)) {
		                arrTmpInt = new Int8Array(iIntArrLength + iBitesToAdd);
		                (<Int8Array>arrTmpInt).set(<Int8Array>arrInt);
		            }
		            else {
		                arrTmpInt = arrInt;
		            }
		            break;
		        case 16:
		        	iIntArrLength = (<Int16Array>arrInt).length;
		            iBitesToAdd = (( 2 - (iIntArrLength % 2) == 2)) ? 0 : ( 2 - (iIntArrLength % 2));
		            if (iBitesToAdd > 0 || !(arrInt instanceof Int16Array)) {
		                arrTmpInt = new Int16Array(iIntArrLength + iBitesToAdd);
		                (<Int16Array>arrTmpInt).set(<Int16Array>arrInt);
		            }
		            else {
		                arrTmpInt = arrInt;
		            }
		            break;
		        case 32:
		        	iIntArrLength = (<Int32Array>arrInt).length;
		            if (!(arrInt instanceof Int32Array)) {
		                arrTmpInt = new Int32Array(<any>arrInt);
		            }
		            else {
		                arrTmpInt = arrInt;
		            }
		            break;
		    }

		    this.uint32(iIntArrLength);

		    for (var i:  number  = 0, n:  number  = arrTmpInt.byteLength / (iX / 8); i < n; i++) {
		        this.writeArrayElementIntX(arrTmpInt[i], iX);
		    }
		}

/**
		 * @property int8Array(arrInt)
		 * Запись массива типа Int8Array. До начала записи элементов записывает общее
		 * количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff. Общее количество байт в массиве выравнивается до 4.
		 * Сокращенная запись функции intXArray(arrInt, 8).
		 * @memberof BinWriter
		 * @tparam Int8Array arrInt массив int8.
		 */

		/**@inline*/  int8Array(arrInt: Int8Array): void {
		    this.intXArray(arrInt, 8);
		}

/**
		 * @property int16Array(arrInt)
		 * Запись массива типа Int16Array. До начала записи элементов записывает общее
		 * количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff. Общее количество байт в массиве выравнивается до 4.
		 * Сокращенная запись функции intXArray(arrInt, 16).
		 * @memberof BinWriter
		 * @tparam Int16Array arrInt массив int16.
		 */

		/**@inline*/  int16Array(arrInt: Int16Array): void {
		    this.intXArray(arrInt, 16);
		}

/**
		 * @property int32Array(arrInt)
		 * Запись массива типа Int32Array. До начала записи элементов записывает общее
		 * количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff.
		 * Сокращенная запись функции intXArray(arrInt, 32).
		 * @memberof BinWriter
		 * @tparam Int32Array arrInt массив int32.
		 */

		/**@inline*/  int32Array(arrInt: Int32Array): void {
		    this.intXArray(arrInt, 32);
		}


/******************************************************************************/

/*                              floatXArray                                   */

/******************************************************************************/


/**
		 * @property floatXArray(arrFloat, iX)
		 * Записывает массив чисел float(32, 64) использую для каждого элемента функцию
		 *  floatX. До начала записи элементов записывает общее
		 *  количество элементов как число int32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff.
		 * Все массивы приводятся к нужному типу Float(iX)Array.
		 * @memberof BinWriter
		 * @tparam Float(iX)Array arrFloat массив float(iX).
		 * @tparam int iX размер элемента в битах (32, 64).
		 */

		floatXArray(arrFloat: ArrayBufferView, iX:  number ) {
		    if (!isDefAndNotNull(arrFloat)) {
		        this.uint32(0xffffffff);
		        return;
		    }

		    switch (iX) {
		        case 32:
		            if (!(arrFloat instanceof Float32Array)) {
		                arrFloat = new Float32Array(<any>arrFloat);
		            }
		            break;
		        case 64:
		            if (!(arrFloat instanceof Float64Array)) {
		                arrFloat = new Float64Array(<any>arrFloat);
		            }
		            break;
		    }
		    var iFloatArrLength:  number  = arrFloat.byteLength / (iX / 8);
		    this.uint32(iFloatArrLength);
//Поэлементно записываем массив
		    for (var i:  number  = 0, n:  number  = iFloatArrLength; i < n; i++) {
		        this.floatX(arrFloat[i], iX);
		    }
		}

/**
		 * @property float32Array(arrFloat)
		 * Запись массива типа Float32Array. До начала записи элементов записывает общее
		 * количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff.
		 * Все переданные массивы приводятся к типу Float32Array.
		 * Сокращенная запись функции floatXArray(arrFloat, 32).
		 * @memberof BinWriter
		 * @tparam Float32Array arrFloat массив float32.
		 */

		/**@inline*/  float32Array(arrFloat: Float32Array): void {
		    this.floatXArray(arrFloat, 32);
		}

/**
		 * @property float64Array(arrFloat)
		 * Запись массива типа Float64Array. До начала записи элементов записывает общее
		 * количество элементов как число uint32. Если в качестве параметра функции
		 * передано null или undefined то количество элементов записывается
		 * равным 0xffffffff.
		 * Все переданные массивы приводятся к типу Float64Array.
		 * Сокращенная запись функции floatXArray(arrFloat, 64).
		 * @memberof BinWriter
		 * @tparam Float64Array arrFloat массив float64.
		 */

		/**@inline*/  float64Array(arrFloat: Float64Array): void {
		    this.floatXArray(arrFloat, 64);
		}

/**
		 * @property data()
		 * Берет все данные из массива _pArrData и записывает их в массив
		 * типа ArrayBuffer.
		 * @memberof BinWriter
		 * @treturn ArrayBuffer.
		 */

		/**@inline*/  data(): ArrayBuffer {
		    return this.dataAsUint8Array().buffer;
		}

/**
		 * @property data()
		 * Берет все данные из массива _pArrData и записывает их в строку.
		 * @memberof BinWriter
		 * @treturn String.
		 */

		dataAsString(): string {
		    var tmpArrBuffer: Uint8Array = this.dataAsUint8Array();
		    var sString: string = "";

		    for (var n:  number  = 0; n < tmpArrBuffer.length; ++n) {
		        var charCode = String.fromCharCode(tmpArrBuffer[n]);
		        sString = sString + charCode;
		    }

		    return sString;
		}

/**
		 * @property toUint8Array()
		 * Берет все данные из массива _pArrData и вернет Uint8Array.
		 * @memberof BinWriter
		 * @treturn Uint8Array.
		 */

		dataAsUint8Array(): Uint8Array {
		    var arrUint8: Uint8Array = new Uint8Array(this._iCountData);

		    for (var i:  number  = 0, k:  number  = 0; i < this._pArrData.length; i++) {
		        for (var n:  number  = 0; n < this._pArrData[i].length; n++) {
		            arrUint8[k++] = this._pArrData[i][n];
		        }
		    }

		    return arrUint8;
		}


/**
		 * @property rawStringToBuffer()
		 * Берет строку и преобразует ее в массив Uint8Array.
		 * @memberof BinWriter
		 * @treturn Uint8Array.
		 */

		static rawStringToBuffer(str): Uint8Array {

		    var idx:  number ;
		    var len:  number  = str.length;
		    var iBitesToAdd:  number  = (( 4 - (len % 4) == 4)) ? 0 : ( 4 - (len % 4));
		    var arr:  number [] = new Array(len + iBitesToAdd);

		    for (idx = 0; idx < len; ++idx) {
/* & 0xFF;*/
		        arr[ idx ] = str.charCodeAt(idx);
		    }
		    return new Uint8Array(arr);
		};
	}
}



module akra.io {


	export interface IHash {
		[type: string]: any[];
	}


	export class Packer extends BinWriter implements IPacker {
		protected _pHashTable: IHash = {};
		protected _pTemplate: IPackerTemplate = getPackerTemplate();

		/**@inline*/  get template(): IPackerTemplate { return this._pTemplate; }

		private memof(pObject: any, iAddr:  number , sType: string): void;
		private addr(pObject: any, sType: string):  number ;
		private nullPtr(): void;
		private rollback(n?:  number ): Uint8Array[];
		private append(pData: Uint8Array[]): void;
		private append(pData: ArrayBuffer): void;
		private append(pData: Uint8Array): void;
		private writeData(pObject: any, sType: string): bool;

		write(pObject: any, sType?: string): bool;

		private memof(pObject: any, iAddr:  number , sType: string): void {
			if (sType === "Number") {
				return;
			}

			var pTable: IHash = this._pHashTable;
		    var pCell: any[] = pTable[sType];

		    if (!isDef(pCell)) {
		        pCell = pTable[sType] = [];
		    }

		    pCell.push(pObject, iAddr);
		}

		private addr(pObject: any, sType: string):  number  {
			if (sType === "Number") {
				return -1;
			}

			var pTable: IHash = this._pHashTable;
		    var iAddr:  number ;
		    var pCell: any[] = pTable[sType];

		    if (isDef(pCell)) {

		        for (var i:  number  = 0, n:  number  = pCell.length / 2; i < n; ++ i) {
		            var j = 2 * i;

		            if (pCell[j] === pObject) {
		                return < number >pCell[j + 1];
		            }
		        }
		    }

		    return -1;
		}

		private  /**@inline*/  nullPtr(): void {
			return this.uint32(MAX_UINT32);
		}


		private rollback(n:  number  = 1): Uint8Array[] {
		    if (n === -1) {
		        n = this._pArrData.length;
		    }

		    var pRollback: Uint8Array[] = new Array(n);
		    var iRollbackLength:  number  = 0;

		    for (var i:  number  = 0; i < n; ++ i) {
		        pRollback[i] = this._pArrData.pop();
		        iRollbackLength += pRollback[i].byteLength;
		    }

		    this._iCountData -= iRollbackLength;

		    return pRollback;
		}

		private append(pData: any): void {
			if (isArray(pData)) {
		        for (var i:  number  = 0; i < (<Uint8Array[]>pData).length; ++ i) {
		            this._pArrData.push((<Uint8Array[]>pData)[i]);
		            this._iCountData += (<Uint8Array[]>pData)[i].byteLength;
		        }
		    }
		    else{
		        if (isArrayBuffer(pData)) {
		            pData = new Uint8Array(pData);
		        }
		        this._pArrData.push(<Uint8Array>pData);
		        this._iCountData += (<Uint8Array>pData).byteLength;
		    }
		}
		private x:  number  = 0;
		private writeData(pObject: any, sType: string): bool {
			var pTemplate: IPackerTemplate = this.template;
		    var pProperties: IPackerCodec = pTemplate.properties(sType);
		    var fnWriter: Function = null;

		    fnWriter = pProperties.write;


		    this.x ++;
		    if (this.x % 1000 == 0)
		    	console.log((this.byteLength / (1024 * 1024)).toFixed(2), "mb");


		    if (!isNull(fnWriter)) {
		         if (fnWriter.call(this, pObject) === false) {
		            { logger.setSourceLocation( "io/Packer.ts" , 126 ); logger.error("cannot write type: " + sType); } ;
		        }

		        return true;
		    }

		    { logger.setSourceLocation( "io/Packer.ts" , 132 ); logger.assert(isDefAndNotNull(pProperties), "unknown object <" + sType + "> type cannot be writed"); } ;
		    return true;
		}

		write(pObject: any, sType: string = null): bool {
			var pProperties: IPackerCodec;
		    var iAddr:  number , iType:  number ;
		    var pTemplate: IPackerTemplate = this.template;

		    if (isNull(pObject)) {
		    	this.nullPtr();
		    	return false;
		    }

		    if (isNull(sType)) {
		        sType = pTemplate.detectType(pObject);
		    }


	        pProperties = pTemplate.properties(sType);
	        iType = pTemplate.getTypeId(sType);


		    if (!isDef(pObject) || !isDef(iType)) {
		        this.nullPtr();
		        return false;
		    }

		   	iAddr = this.addr(pObject, sType);


		    if (iAddr < 0) {
		        iAddr = this.byteLength + 4 + 4;

		        this.uint32(iAddr);
		        this.uint32(iType);

		        if (this.writeData(pObject, sType)) {
		            this.memof(pObject, iAddr, sType);
		        }
		        else {
		            this.rollback(2);
		            this.nullPtr();
		        }
		    }
		    else {
		        this.uint32(iAddr);
		        this.uint32(iType);
		    }

		    return true;
		}
	}

	export function dump(pObject: any): ArrayBuffer {
		var pPacker: IPacker = new Packer;
	    pPacker.write(pObject);
	    return pPacker.data();
	}

}







interface FileSaver {
	(data: Blob, filename: string): void;
}

declare var saveAs: FileSaver;



/// @FILESAVER: {data}/3d-party/FileSaver/FileSaver.min.js|location()|script()|data_location({data},DATA)










module akra.io {

	export class Exporter {
		static VERSION = "0.0.1";
		static UP_AXIS: string = "Y_UP";
		static TOOL: string = "Akra Engine exporter";

		protected _pLibrary: ILibrary = <ILibrary><any>{};
		protected _pDocument: IDocument = null;

//записаны ли сцены в документе?
		protected _bScenesWrited: bool = false;

//assset
		protected _sTitle: string = null;
		protected _sSubject: string = null;
		protected _pKeywords: string[] = null;

//contributor
		protected _sAuthor: string = null;
		protected _sComments: string = null;
		protected _sCopyright: string = null;
		protected _sSourceData: string = null;

		/**@inline*/  writeAnimation(pAnimation: IAnimationBase): void {
			switch (pAnimation.type) {
				case EAnimationTypes.ANIMATION:
					this.makeEntry(EDocumentEntry.k_Animation, pAnimation);
					break;
				case EAnimationTypes.BLEND:
					this.makeEntry(EDocumentEntry.k_AnimationBlend, pAnimation);
					break;
				case EAnimationTypes.CONTAINER:
					this.makeEntry(EDocumentEntry.k_AnimationContainer, pAnimation);
					break;
				default:
					{ logger.setSourceLocation( "io/Exporter.ts" , 55 ); logger.criticalError("unknown animation detected!"); } ;
			}
		}

		/**@inline*/  writeController(pController: IAnimationController): void {
			this.makeEntry(EDocumentEntry.k_Controller, pController);
		}

		clear(): void {
			this._bScenesWrited = false;
			this._pLibrary = <ILibrary><any>{};
		}

		/**@inline*/  findLibraryEntry(iGuid:  number ): ILibraryEntry {
			return this._pLibrary[iGuid];
		}

		/**@inline*/  findEntry(iGuid:  number ): IDataEntry {
			return this.findLibraryEntry(iGuid).entry;
		}

		/**@inline*/  findEntryData(iGuid:  number ): any {
			return this.findLibraryEntry(iGuid).data;
		}

		protected  /**@inline*/  isSceneWrited(): bool {
			return this._bScenesWrited;
		}

		protected  /**@inline*/  isEntryExists(iGuid:  number ): bool {
			return isDefAndNotNull(this._pLibrary[iGuid]);
		}

		protected makeEntry(eType: EDocumentEntry, pData: IUnique): void {
			if (!this.isEntryExists(pData.getGuid())) {
				this.writeEntry(eType, {guid: pData.getGuid(), data: pData, entry: null});
			}
		}

		protected writeEntry(eType: EDocumentEntry, pEntry: ILibraryEntry): void {
			if (isDefAndNotNull(pEntry.entry)) {
				return ;
			}

			{ logger.setSourceLocation( "io/Exporter.ts" , 99 ); logger.assert(this.encodeEntry(eType, pEntry), "cannot encode entry with type: " + eType); } ;
			this._pLibrary[pEntry.guid] = pEntry;
			pEntry.entry.guid = pEntry.guid;
		}

		protected encodeEntry(eType: EDocumentEntry, pEntry: ILibraryEntry): bool {
			switch (eType) {
				case EDocumentEntry.k_Controller:
					pEntry.entry = this.encodeControllerEntry(<IAnimationController>pEntry.data);
					break;
				case EDocumentEntry.k_Animation:
					pEntry.entry = this.encodeAnimationEntry(<IAnimation>pEntry.data);
					break;
				case EDocumentEntry.k_AnimationBlend:
					pEntry.entry = this.encodeAnimationBlendEntry(<IAnimationBlend>pEntry.data);
					break;
				case EDocumentEntry.k_AnimationContainer:
					pEntry.entry = this.encodeAnimationContainerEntry(<IAnimationContainer>pEntry.data);
					break;
				default:
					{ logger.setSourceLocation( "io/Exporter.ts" , 119 ); logger.warning("unknown entry type detected: " + eType); } ;
			}

			return isDefAndNotNull(pEntry.entry);
		}

		protected encodeAnimationBaseEntry(pAnimation: IAnimationBase): IDataEntry {
			var pEntry: IAnimationBaseEntry = {
				name: pAnimation.name,
				targets: [],
				type: EDocumentEntry.k_Unknown,
				extra: null
			}

			var pTargets: IAnimationTarget[] = pAnimation.getTargetList();

			for (var i = 0; i < pTargets.length; ++ i) {
				if (this.isSceneWrited()) {
					{ logger.setSourceLocation( "io/Exporter.ts" , 137 ); logger.criticalError("TODO: scene writed"); } ;
				}

				pEntry.targets.push({name: pTargets[i].name, target: null});
			}

			return pEntry;
		}

		protected encodeAnimationFrameEntry(pFrame: IPositionFrame): IAnimationFrameEntry {
			var pEntry: IAnimationFrameEntry = {
				time: pFrame.time,
				weight: pFrame.weight,
				matrix: [],
				type: < number >pFrame.type
			};


			pEntry.matrix['$type'] = "Float32Array";

			var pMatrix: IMat4 = pFrame.toMatrix();

			for (var i = 0; i < pMatrix.data.length; ++ i) {
				pEntry.matrix.push(pMatrix.data[i]);
			}

			return pEntry;
		}

		protected encodeAnimationTrack(pTrack: IAnimationTrack): IAnimationTrackEntry {
			var pEntry: IAnimationTrackEntry = {
/*TODO: real interpolation mode*/
				interpolation: 0,
				keyframes: [],
				targetName: pTrack.targetName,
				target: null
			};

			if (this.isSceneWrited()) {
				{ logger.setSourceLocation( "io/Exporter.ts" , 175 ); logger.criticalError("TODO: write track target"); } ;
			}

			for (var i:  number  = 0; i < pTrack.totalFrames; ++ i) {
				var pFrame: IAnimationFrameEntry = this.encodeAnimationFrameEntry(<IPositionFrame>pTrack.getKeyFrame(i));
				pEntry.keyframes.push(pFrame);
			};

			return pEntry;
		}

		protected encodeAnimationEntry(pAnimation: IAnimation): IDataEntry {
			var pEntry: IAnimationEntry = <IAnimationEntry>this.encodeAnimationBaseEntry(pAnimation);
			pEntry.tracks = [];
			pEntry.type = EDocumentEntry.k_Animation;

			for (var i:  number  = 0; i < pAnimation.totalTracks; ++ i) {
				var pTrack: IAnimationTrackEntry = this.encodeAnimationTrack(pAnimation.getTrack(i));
				pEntry.tracks.push(pTrack);
			};

			return pEntry;
		}

		protected encodeAnimationContainerEntry(pContainer: IAnimationContainer): IDataEntry {
			var pAnimation: IAnimationBase = pContainer.getAnimation();

			var pEntry: IAnimationContainerEntry = <IAnimationContainerEntry>this.encodeAnimationBaseEntry(pContainer);

			pEntry.enable = pContainer.isEnabled();
			pEntry.startTime = pContainer.getStartTime();
			pEntry.speed = pContainer.getSpeed();
			pEntry.loop = pContainer.inLoop();
			pEntry.reverse = pContainer.isReversed();
			pEntry.pause = pContainer.isPaused();
			pEntry.leftInfinity = pContainer.inLeftInfinity();
			pEntry.rightInfinity = pContainer.inRightInfinity();

			pEntry.animation = pAnimation.getGuid();
			pEntry.type = EDocumentEntry.k_AnimationContainer;

			this.writeAnimation(pAnimation);

			return pEntry;
		}

		protected encodeAnimationBlendEntry(pBlend: IAnimationBlend): IDataEntry {
			var pEntry: IAnimationBlendEntry = <IAnimationBlendEntry>this.encodeAnimationBaseEntry(pBlend);

			pEntry.animations = []
			pEntry.type = EDocumentEntry.k_AnimationBlend;

			for (var i = 0, n:  number  = pBlend.totalAnimations; i < n; ++ i) {
				var pAnimation: IAnimationBase = pBlend.getAnimation(i);

				var pBlendElement: IAnimationBlendElementEntry = {
					animation: pAnimation.getGuid(),
					weight: pBlend.getAnimationWeight(i),
// acceleration: pBlend.getAnimationAcceleration(i),
					mask: pBlend.getAnimationMask(i)
				};

				this.writeAnimation(pAnimation);
				pEntry.animations.push(pBlendElement);
			}


			return pEntry;
		}

		protected encodeControllerEntry(pController: IAnimationController): IDataEntry {
			var pEntry: IControllerEntry = {
				type: EDocumentEntry.k_Controller,

				animations: [],
				options: 0,
				name: pController.name
			};

			for (var i = 0, n:  number  = pController.totalAnimations; i < n; ++ i) {
				var pAnimation: IAnimationBase = pController.getAnimation(i);
				this.writeAnimation(pAnimation);
				pEntry.animations.push(pAnimation.getGuid());
			}

			return pEntry;
		}


		protected toolInfo(): string {
			return [
				Exporter.TOOL,
				"Version " + Exporter.VERSION,
				"Browser " + info.browser.name + ", " + info.browser.version + " (" + info.browser.os + ")"
				].join(";");
		}

		protected createUnit(): IUnit  {
			return {
				name: "meter",
				meter: 1.
			}
		}

		protected createContributor(): IContributor {
			return {
				author: this._sAuthor,
				authoringTool: this.toolInfo(),
				comments: this._sComments,
				copyright: this._sCopyright,
				sourceData: this._sSourceData
			}
		}

		protected createAsset(): IAsset {
			return {
				unit: this.createUnit(),
				upAxis: Exporter.UP_AXIS,
				title: this._sTitle,
				subject: this._sSubject,
				created: Exporter.getDate(),
				modified: Exporter.getDate(),
				contributor: this.createContributor(),
				keywords: this._pKeywords
			}
		}

		createDocument(): IDocument {
			var pDocument: IDocument  = {
				asset: this.createAsset(),
				library: [],
				scenes: null
			}

			var pLibrary: ILibrary = this._pLibrary;

			for (var iGuid in pLibrary) {
				var pLibEntry: ILibraryEntry = pLibrary[iGuid];
				pDocument.library.push(pLibEntry.entry);
			}

			return pDocument;
		}

		export(eFormat: EDocumentFormat = EDocumentFormat.JSON): Blob {
			var pDocument: IDocument = this.createDocument();

			if (eFormat === EDocumentFormat.JSON) {
				return Exporter.exportAsJSON(pDocument);
			}
			else if (eFormat === EDocumentFormat.BINARY_JSON) {
				return Exporter.exportAsJSONBinary(pDocument);
			}

			return null;
		}

		saveAs(sName: string, eFormat?: EDocumentFormat): void {
			saveAs(this.export(eFormat), sName);
		}

		static exportAsJSON(pDocument: IDocument): Blob {
/*, null, "\t"*/
			return new Blob([JSON.stringify(pDocument                )], {type: "application/json;charset=utf-8"});
		}

		static exportAsJSONBinary(pDocument: IDocument): Blob {
			return new Blob([io.dump(pDocument)], {type: "application/octet-stream"});
		}

		static protected  /**@inline*/  getDate(): string {
			return (new Date()).toString();
		}
	}
}



































module akra {

	export interface IBinReader {

		string(sDefault?: string): string;

		uint32():  number ;
		uint16():  number ;
		uint8():  number ;

		bool(): bool;

		int32():  number ;
		int16():  number ;
		int8():  number ;

		float64():  number ;
		float32():  number ;

		stringArray(): string[];

		uint32Array(): Uint32Array;
		uint16Array(): Uint16Array;
		uint8Array(): Uint8Array;

		int32Array(): Int32Array;
		int16Array(): Int16Array;
		int8Array(): Int8Array;

		float64Array(): Float64Array;
		float32Array(): Float32Array;
	}
}



module akra {
	;

	export interface IUnPacker extends IBinReader {
		template: IPackerTemplate;

		read(): any;
	}
}













/**
 * Usage:
 * var br = new Binreader(data); type of data is ArrayBuffer
 * var string = bw.string();
 * var array = bw.stringArray()
 * var value = bw.uint8()
 * var value = bw.uint16()
 * var value = bw.uint32()
 * var array = bw.uint8Array()
 * var array = bw.uint16Array()
 * var array = bw.uint32Array()
 * var value = bw.int8()
 * var value = bw.int16()
 * var value = bw.int32()
 * var array = bw.int8Array()
 * var array = bw.int16Array()
 * var array = bw.int32Array()
 * var value = bw.float64()
 * var value = bw.float32()
 * var array = bw.float32Array()
 * var array = bw.float64Array()
 */


/**
 * Работает заебись, докуменитировать лень.
 */





module akra.io {

	export class BinReader implements IBinReader {
		protected _pDataView: DataView;
		protected _iPosition:  number ;

		constructor (pBuffer: ArrayBuffer, iByteOffset?:  number , iByteLength?:  number );
		constructor (pBuffer: IBinWriter, iByteOffset?:  number , iByteLength?:  number );
		constructor (pBuffer: any, iByteOffset?:  number , iByteLength?:  number ) {
			if (!isDef(iByteOffset)) { iByteOffset = 0; }
			if (!isDef(iByteLength)) { iByteLength = pBuffer.byteLength; }

			this._pDataView = new DataView(isArrayBuffer(pBuffer)? (<ArrayBuffer>pBuffer): (<IBinWriter>pBuffer).data(),
									iByteOffset, iByteLength);
			this._iPosition = 0;
		}

		string(sDefault: string = null): string {
			var iStringLength:  number  = this.uint32();
			var iBitesToAdd:  number ;

		    if (iStringLength == MAX_INT32) {
		        return sDefault;
		    }

		    iBitesToAdd = (( 4 - (iStringLength % 4) == 4)) ? 0 : ( 4 - (iStringLength % 4));
		    iStringLength += iBitesToAdd;

//Проверка на возможный выход за пределы массива.
		    { logger.setSourceLocation( "BinReader.ts" , 66 ); logger.assert(this._iPosition + iStringLength - 1 < this._pDataView.byteLength, "Выход за пределы массива"); } ;

		    var pBuffer: Uint8Array = new Uint8Array(iStringLength);

		    for (var i:  number  = 0; i < iStringLength; i++) {
		        pBuffer[i] = this._pDataView.getUint8(this._iPosition + i);
		    }

		    this._iPosition += iStringLength;
		    var sString: string = "",
			    charCode: string,
			    code:  number ;

		    for (var n = 0; n < pBuffer.length; ++n) {
		        code = pBuffer[n];

		        if (code == 0) {
		            break;
		        }

		        charCode = String.fromCharCode(code);
		        sString = sString + charCode;
		    }

		    sString = sString.fromUTF8();
/*sString.substr(0, iStringLength);//sString;//*/

		    return sString;
		}

		uint32():  number  {
			var i:  number  = this._pDataView.getUint32(this._iPosition, true);
		    this._iPosition += 4;
// LOG("uint32:", i);
		    return i;
		}

		uint16():  number  {
			var i:  number  = this._pDataView.getUint16(this._iPosition, true);
		    this._iPosition += 4;
		    return i;
		}

		uint8():  number  {
			var i:  number  = this._pDataView.getUint8(this._iPosition);
		    this._iPosition += 4;
		    return i;
		}

		/**@inline*/  bool(): bool {
			return this.uint8() > 0;
		}

		int32():  number  {
			var i:  number  = this._pDataView.getInt32(this._iPosition, true);
		    this._iPosition += 4;
		    return i;
		}

		int16():  number  {
			var i:  number  = this._pDataView.getInt16(this._iPosition, true);
		    this._iPosition += 4;
		    return i;
		}

		int8():  number  {
			var i:  number  = this._pDataView.getInt8(this._iPosition);
		    this._iPosition += 4;
		    return i;
		}

		float64():  number  {
			var f:  number  = this._pDataView.getFloat64(this._iPosition, true);
		    this._iPosition += 8;
		    return f;
		}

		float32():  number  {
			var f:  number  = this._pDataView.getFloat32(this._iPosition, true);
		    this._iPosition += 4;
// LOG("float32:", f);
		    return f;
		}

		stringArray(): string[] {
			var iLength:  number  = this.uint32();

		    if (iLength == MAX_INT32) {
		        return null;
		    }

		    var pArray: string[] = new Array(iLength);

		    for (var i:  number  = 0; i < iLength; i++) {
		        pArray[i] = this.string();
		    }

		    return pArray;
		}

		/**@inline*/  uint32Array(): Uint32Array {
			return <Uint32Array>this.uintXArray(32);
		}

		/**@inline*/  uint16Array(): Uint16Array {
			return <Uint16Array>this.uintXArray(16);
		}

		/**@inline*/  uint8Array(): Uint8Array {
			return <Uint8Array>this.uintXArray(8);
		}

		/**@inline*/  int32Array(): Int32Array {
			return <Int32Array>this.intXArray(32);
		}

		/**@inline*/  int16Array(): Int16Array {
			return <Int16Array>this.intXArray(16);
		}

		/**@inline*/  int8Array(): Int8Array {
			return <Int8Array>this.intXArray(8);
		}

		/**@inline*/  float64Array(): Float64Array {
			return <Float64Array>this.floatXArray(64);
		}

		/**@inline*/  float32Array(): Float32Array {
			return <Float32Array>this.floatXArray(32);
		}

		private uintXArray(iX:  number ): ArrayBufferView {
		    var iLength:  number  = this.uint32();

		    if (iLength == MAX_INT32) {
		        return null;
		    }

		    var iBytes:  number  = iX / 8;
		    var pArray: ArrayBufferView;

		    switch (iBytes) {
		        case 1:
		            pArray = new Uint8Array(iLength);

		            for (var i = 0; i < iLength; i++) {
		                pArray[i] = this._pDataView.getUint8(this._iPosition + i * iBytes);
		            }

		            break;
		        case 2:
		            pArray = new Uint16Array(iLength);

		            for (var i = 0; i < iLength; i++) {
		                pArray[i] = this._pDataView.getUint16(this._iPosition + i * iBytes, true);
		            }

		            break;
		        case 4:
		            pArray = new Uint32Array(iLength);

		            for (var i = 0; i < iLength; i++) {
		                pArray[i] = this._pDataView.getUint32(this._iPosition + i * iBytes, true);
		            }

		            break;
		        default:
		            { logger.setSourceLocation( "BinReader.ts" , 233 ); logger.error("unsupported array length detected: " + iBytes); } ;
		    }

		    var iByteLength:  number  = iBytes * iLength;
		    iByteLength += -iByteLength & 3;

		    this._iPosition += iByteLength;

		    return pArray;
		}

		private intXArray(iX:  number ): ArrayBufferView {
		    var iLength:  number  = this.uint32();

		    if (iLength == MAX_INT32) {
		        return null;
		    }

		    var iBytes:  number  = iX / 8;
		    var pArray: ArrayBufferView;

		    switch (iBytes) {
		        case 1:
		            pArray = new Int8Array(iLength);

		            for (var i = 0; i < iLength; i++) {
		                pArray[i] = this._pDataView.getInt8(this._iPosition + i * iBytes);
		            }

		            break;
		        case 2:
		            pArray = new Int16Array(iLength);

		            for (var i = 0; i < iLength; i++) {
		                pArray[i] = this._pDataView.getInt16(this._iPosition + i * iBytes, true);
		            }

		            break;
		        case 4:
		            pArray = new Int32Array(iLength);

		            for (var i = 0; i < iLength; i++) {
		                pArray[i] = this._pDataView.getInt32(this._iPosition + i * iBytes, true);
		            }

		            break;
		        default:
		            { logger.setSourceLocation( "BinReader.ts" , 280 ); logger.error("unsupported array length detected: " + iBytes); } ;
		    }

		    var iByteLength:  number  = iBytes * iLength;
		    iByteLength += -iByteLength & 3;

		    this._iPosition += iByteLength;

		    return pArray;
		}

		private floatXArray(iX:  number ): ArrayBufferView {
		    var iLength:  number  = this.uint32();

		    if (iLength == MAX_INT32) {
		        return null;
		    }

		    var iBytes:  number  = iX / 8;
		    var pArray: ArrayBufferView;

		    switch (iBytes) {
		        case 4:
		            pArray = new Float32Array(iLength);

		            for (var i = 0; i < iLength; i++) {
		                pArray[i] = this._pDataView.getFloat32(this._iPosition + i * iBytes, true);
		            }

		            break;
		        case 8:
		            pArray = new Float64Array(iLength);

		            for (var i = 0; i < iLength; i++) {
		                pArray[i] = this._pDataView.getFloat64(this._iPosition + i * iBytes, true);
		            }

		            break;
		        default:
		            { logger.setSourceLocation( "BinReader.ts" , 319 ); logger.error("unsupported array length detected: " + iBytes); } ;
		    }

		    var iByteLength = iBytes * iLength;
		    iByteLength += -iByteLength & 3;

		    this._iPosition += iByteLength;

		    return pArray;
		}
	}
}



module akra.io {
	class UnPacker extends BinReader implements IUnPacker {
		protected _pHashTable: any[] = <any[]><any>{};
		protected _pTemplate: IPackerTemplate = getPackerTemplate();
		protected _pPositions:  number [] = [];

		/**@inline*/  get template(): IPackerTemplate { return this._pTemplate; }

		private pushPosition(iPosition:  number ): void;
		private popPosition(): void;
		private memof(pObject: any, iAddr:  number ): void;
		private memread(iAddr:  number ): any;
		private readPtr(iAddr:  number , sType: string, pObject?: any): any;


		private  /**@inline*/  pushPosition(iPosition:  number ): void {
			this._pPositions.push(this._iPosition);
		    this._iPosition = iPosition;
		}

		private  /**@inline*/  popPosition(): void {
			this._iPosition = this._pPositions.pop();
		}

		private memof(pObject: any, iAddr:  number ): void {
			this._pHashTable[iAddr] = pObject;
		}

		private memread(iAddr:  number ): any {
			return this._pHashTable[iAddr] || null;
		}


		private readPtr(iAddr:  number , sType: string, pObject: any = null): any {
		    if (iAddr === MAX_UINT32) {
		        return null;
		    }

		    var pTmp: any = this.memread(iAddr);
		    var isReadNext: bool = false;
		    var fnReader: Function = null;
		    var pTemplate: IPackerTemplate = this.template;
		    var pProperties: IPackerCodec;

		    if (isDefAndNotNull(pTmp)) {
		        return pTmp;
		    }

		    if (iAddr === this._iPosition) {
		        isReadNext = true;
		    }
		    else {
//set new position
		        this.pushPosition(iAddr);
		    }

		    pProperties = pTemplate.properties(sType);

		    { logger.setSourceLocation( "io/UnPacker.ts" , 67 ); logger.assert(isDefAndNotNull(pProperties), "unknown object <" + sType + "> type cannot be readed"); } ;

		    fnReader = pProperties.read;

//read primal type
		    if (isDefAndNotNull(fnReader)) {
		        pTmp = fnReader.call(this, pObject);
		        this.memof(pTmp, iAddr);

//restore prev. position
		        if (!isReadNext) {
		            this.popPosition();
		        }

		        return pTmp;
		    }

		    { logger.setSourceLocation( "io/UnPacker.ts" , 84 ); logger.criticalError("unhandled case!"); } ;
		    return null;
		}


		read(): any {
		    var iAddr:  number  = this.uint32();

		    if (iAddr === MAX_UINT32) {
		        return null;
		    }

		    var iType:  number  = this.uint32();
		    var sType: string = this.template.getType(iType);

		    return this.readPtr(iAddr, sType);
		};
	}

	export function undump (pBuffer: any): any {
	    if (!isDefAndNotNull(pBuffer)) {
	        return null;
	    }

	    return (new UnPacker(pBuffer)).read();
	}
}











module akra.io {
	export class Importer {

		private _pDocument: IDocument = null;
		private _pLibrary: ILibrary = <ILibrary><any>{};

		constructor (private _pEngine: IEngine) {

		}

		/**@inline*/  getEngine(): IEngine {
			return this._pEngine;
		}

		/**@inline*/  getDocument(): IDocument {
			return this._pDocument;
		}

		/**@inline*/  getLibrary(): ILibrary {
			return this._pLibrary;
		}

//inline getLibrary(): I

		import(pData: string, eFormat?: EDocumentFormat): Importer;
		import(pData: Object, eFormat?: EDocumentFormat): Importer;
		import(pData: ArrayBuffer, eFormat?: EDocumentFormat): Importer;
		import(pData: Blob, eFormat?: EDocumentFormat): Importer;
		import(pData: any, eFormat: EDocumentFormat = EDocumentFormat.JSON): Importer {
			if (eFormat !== EDocumentFormat.JSON && eFormat !== EDocumentFormat.BINARY_JSON) {
				{ logger.setSourceLocation( "io/Importer.ts" , 48 ); logger.criticalError("TODO: Add support for all formats"); } ;
			}

			if (eFormat === EDocumentFormat.JSON) {
				this.loadDocument(this.importFromJSON(pData));
			}
			else if (eFormat === EDocumentFormat.BINARY_JSON) {
				this.loadDocument(this.importFromBinaryJSON(<ArrayBuffer>pData));
			}

			return this;
		}

		loadDocument(pDocument: IDocument): Importer {
			this._pDocument = pDocument;
			this.updateLibrary();
			return this;
		}


		protected importFromBinaryJSON(pData: ArrayBuffer): IDocument {
			return io.undump(pData);
		}

		protected importFromJSON(pData): IDocument {
			var sData: string = null;

			if (isArrayBuffer(pData)) {
				sData = util.abtos(<ArrayBuffer>pData);
			}
			else if (isString(pData)) {
				sData = <string>pData;
			}
			else if(isBlob(pData)) {
				{ logger.setSourceLocation( "io/Importer.ts" , 82 ); logger.criticalError("TODO: Blob support!"); } ;
			}
			else {
				return <IDocument>pData;
			}

/*<IDocument>util.parseJSON(sData);*/
			return JSON.parse(sData);
		}

		protected updateLibrary(): void {
			var pDocument: IDocument = this.getDocument();
			var pLibrary: ILibrary = this.getLibrary();

			for (var i:  number  = 0; i < pDocument.library.length; ++ i) {
				var pEntry: IDataEntry = pDocument.library[i];
				var iGuid:  number  = pEntry.guid;

				pLibrary[iGuid] = {guid: iGuid, data: null, entry: pEntry};
			};
		}

		protected findEntries(eType: EDocumentEntry, fnCallback: (pEntry: ILibraryEntry, n?:  number ) => bool): void {
			var pLibrary: ILibrary = this.getLibrary();
			var i:  number  = 0;

			for (var iGuid in pLibrary) {
				var pEntry: ILibraryEntry = pLibrary[iGuid];

				if (!isNull(pEntry.entry) && pEntry.entry.type === eType) {
					if (fnCallback.call(this, pEntry, i ++) === false) {
						return;
					}
				}
			}
		}

		protected findEntryByIndex(eType: EDocumentEntry, i:  number ): ILibraryEntry {
			var pEntry: ILibraryEntry = null;
			this.findEntries(eType, (pLibEntry: ILibraryEntry, n?:  number ): bool => {
				pEntry = pLibEntry;

				if (i === n) {
					return false;
				}
			});

			return pEntry;
		}

		protected find(eType: EDocumentEntry, fnCallback: (pData: any, n?:  number ) => bool): void {
			this.findEntries(eType, (pEntry: ILibraryEntry, n?:  number ): bool => {
				if (fnCallback.call(this, pEntry.data, n) === false) {
					return;
				}
			});
		}

		protected  /**@inline*/  findByIndex(eType: EDocumentEntry, i:  number  = 0): any {
			return this.findEntryByIndex(eType, i).data;
		}

		protected  /**@inline*/  findFirst(eType: EDocumentEntry): any {
			return this.findByIndex(eType, 0);
		}

		getController(iContrller:  number  = 0): IAnimationController {
			return <IAnimationController>this.decodeEntry(this.findEntryByIndex(EDocumentEntry.k_Controller, iContrller).entry);
		}

		protected decodeEntry(pEntry: IDataEntry): any {
			if (isNull(pEntry)) {
				return null;
			}

			var pData: any = this.getLibrary()[pEntry.guid].data;

			if (!isNull(pData)) {
				return pData;
			}

			switch(pEntry.type) {
				case EDocumentEntry.k_Controller:
					pData = this.decodeControllerEntry(<IControllerEntry>pEntry);
					break;
				case EDocumentEntry.k_Animation:
					pData = this.decodeAnimationEntry(<IAnimationEntry>pEntry);
					break;
				case EDocumentEntry.k_AnimationBlend:
					pData = this.decodeAnimationBlendEntry(<IAnimationBlendEntry>pEntry);
					break;
				case EDocumentEntry.k_AnimationContainer:
					pData = this.decodeAnimationContainerEntry(<IAnimationContainerEntry>pEntry);
					break;
			}

			if (!isNull(pData)) {
				this.registerData(pEntry.guid, pData);
				return pData;
			}

			{ logger.setSourceLocation( "io/Importer.ts" , 182 ); logger.warning("USED UNKNOWN TYPE FOR DECODING!!", pEntry.type); } ;
			return null;
		}

		protected registerData(iGuid:  number , pData: any): void {
			var pLibEntry: ILibraryEntry = this.getLibrary()[iGuid];
			pLibEntry.data = pData;
		}

		protected decodeInstance(iGuid:  number ): any {
			var pLibEntry: ILibraryEntry = this.getLibrary()[iGuid];

			if (!isNull(pLibEntry.data)) {
				return pLibEntry.data;
			}

			return this.decodeEntry(pLibEntry.entry);
		}

		protected decodeEntryList(pEntryList: IDataEntry[], fnCallback: (pData: any) => void): void {
			if (isNull(pEntryList)) {
				return;
			}

			for (var i:  number  = 0; i < pEntryList.length; ++ i) {
				fnCallback.call(this, this.decodeEntry(pEntryList[i]));
			}
		}

		protected decodeInstanceList(pInstances:  number [], fnCallback: (pData: any, n?:  number ) => void): void {
			for (var i:  number  = 0; i < pInstances.length; ++ i) {
				fnCallback.call(this, this.decodeInstance(pInstances[i]), i);
			}
		}

		protected decodeAnimationFrame(pEntry: IAnimationFrameEntry): IPositionFrame {
			var pFrame: IPositionFrame = new animation.PositionFrame(pEntry.time, new Mat4(pEntry.matrix), pEntry.weight);
//FIXME: avoid capability problems
			pFrame.type = isInt(pEntry.type)? pEntry.type: EAnimationInterpolations.SPHERICAL;
			return pFrame;
		}

		protected decodeAnimationTrack(pEntry: IAnimationTrackEntry): IAnimationTrack {
			var pTrack: IAnimationTrack = animation.createTrack(pEntry.targetName);

//TODO: decode base entry
//TODO: set interpolation mode
//TODO: set target

			for (var i:  number  = 0; i < pEntry.keyframes.length; ++ i) {
				pTrack.keyFrame(this.decodeAnimationFrame(pEntry.keyframes[i]));
			};

			return pTrack;
		}

		protected decodeAnimationEntry(pEntry: IAnimationEntry): IAnimation {
			var pAnimation: IAnimation = animation.createAnimation(pEntry.name);

			pAnimation.extra = pEntry.extra;

//TODO: load read targets!!

			for (var i:  number  = 0; i < pEntry.tracks.length; ++ i) {
				pAnimation.push(this.decodeAnimationTrack(pEntry.tracks[i]));
			};

			return pAnimation;
		}

		protected decodeAnimationBlendEntry(pEntry: IAnimationBlendEntry): IAnimationBlend {
			var pBlend: IAnimationBlend = animation.createBlend(pEntry.name);

			pBlend.extra = pEntry.extra;

//TODO: decode base entry!
//TODO: set targets

			for (var i:  number  = 0; i < pEntry.animations.length; ++ i) {
				var pElement: IAnimationBlendElementEntry = pEntry.animations[i];

				var pAnimation: IAnimationBase = <IAnimationBase>this.decodeInstance(pElement.animation);
				var fWeight:  number  = pElement.weight;
				var pMask: FloatMap = pElement.mask;
// var fAcceleration: float = pEntry.acceleration;

				pBlend.setAnimation(i, pAnimation);
				pBlend.setAnimationWeight(i, fWeight);
				pBlend.setAnimationMask(i, pMask);
			};

			return pBlend;
		}

		protected decodeAnimationContainerEntry(pEntry: IAnimationContainerEntry): IAnimationContainer {
			var pAnimation: IAnimationBase = this.decodeInstance(pEntry.animation);
			var pContainer: IAnimationContainer = animation.createContainer(pAnimation, pEntry.name);

			pContainer.extra = pEntry.extra;

//TODO: decode base entry!
//TODO: set targets

			if (!pEntry.enable) {
				pContainer.disable();
			}

			pContainer.setStartTime(pEntry.startTime);
			pContainer.setSpeed(pEntry.speed);
			pContainer.useLoop(pEntry.loop);
			pContainer.reverse(pEntry.reverse);
			pContainer.pause(pEntry.pause);
			pContainer.leftInfinity(pEntry.leftInfinity);
			pContainer.rightInfinity(pEntry.rightInfinity);

			return pContainer;
		}

		protected decodeControllerEntry(pEntry: IControllerEntry): IAnimationController {
			var pController: IAnimationController = this.getEngine().createAnimationController(pEntry.name, pEntry.options);
			pController.name = pEntry.name;

			this.decodeInstanceList(pEntry.animations, (pAnimation: IAnimationBase) => {
				pController.addAnimation(pAnimation);
			});

			return pController;
		}
	}
}




module akra.core {
	export class Engine implements IEngine {

		private _pResourceManager: IResourcePoolManager;
		private _pSceneManager: ISceneManager;
		private _pParticleManager: IParticleManager;
		private _pSpriteManager: ISpriteManager;
		private _pRenderer: IRenderer;
		private _pComposer: IAFXComposer;
		private _pDepsManager: IDepsManager;

/** stop render loop?*/

		private _pTimer: util.UtilTimer;
		private _iAppPausedCount:  number  = 0;


/** is paused? */

		private _isActive: bool = false;
/** frame rendering sync / render next frame? */

		private _isFrameMoving: bool = true;
/** is all needed files loaded */

		private _isDepsLoaded: bool = false;

		private _pGamepads: IGamepadMap = null;

		private _fElapsedAppTime:  number  = 0.0;


		/**@inline*/  get time():  number  {
			return this._pTimer.appTime;
		}

		/**@inline*/  get elapsedTime():  number  {
			return this._fElapsedAppTime;
		}

		constructor (pOptions: IEngineOptions = null) {
			this._pResourceManager = new pool.ResourcePoolManager(this);
			if (!this._pResourceManager.initialize()) {
				{ logger.setSourceLocation( "core/Engine.ts" , 117 ); logger.error('cannot initialize ResourcePoolManager'); } ;
			}

			this._pSceneManager = new scene.SceneManager(this);

			if (!this._pSceneManager.initialize()) {
				{ logger.setSourceLocation( "core/Engine.ts" , 123 ); logger.error("cannot initialize SceneManager"); } ;
			}

			this._pParticleManager = null;
			this._pSpriteManager = new scene.SpriteManager(this);
			this._pTimer = util.UtilTimer.start();


			var pRendererOptions: IRendererOptions = pOptions? pOptions.renderer: null;
			this._pRenderer = new webgl.WebGLRenderer(this, pRendererOptions);

			this._pComposer = new fx.Composer(this);

// Register image codecs
			DDSCodec.startup();


			this.pause(false);

			this.parseOptions(pOptions);
		}

		enableGamepads(): bool {
			if (!isNull(this._pGamepads)) {
				return true;
			}

			var pGamepads: IGamepadMap = controls.createGamepadMap();

			if (pGamepads.init()) {
				this._pGamepads = pGamepads;
				return true;
			}

			return false;
		}

		getGamepads(): IGamepadMap {
			if (this.enableGamepads()) {
				return this._pGamepads;
			}

			return null;
		}

		private parseOptions(pOptions: IEngineOptions): void {
//== Depends Managment ====================================

			var pDeps: IDependens = Engine.DEPS;
			var sDepsRoot: string = Engine.DEPS_ROOT;
			var pDepsManager: IDepsManager = this._pDepsManager = util.deps.createManager(this);

//read options 
			if (!isNull(pOptions)) {
				sDepsRoot = pOptions.depsRoot || Engine.DEPS_ROOT;
//default deps has higher priority!
				if (isDefAndNotNull(pOptions.deps)) {
					Engine.depends(pOptions.deps);
				}

				if (pOptions.gamepads === true) {
					this.enableGamepads();
				}
			}

//get loaded signal
			this.connect(pDepsManager,  "loaded" ,  "_depsLoaded" );

			if (!isNull(pOptions) && isDefAndNotNull(pOptions.loader)) {
				var fnLoaded = pOptions.loader.loaded;
				var fnChanged = pOptions.loader.changed;

				if (isFunction(fnLoaded)) {
					pDepsManager.bind( "loaded" , fnLoaded);
				}

				if (isFunction(fnChanged)) {
					pDepsManager.bind( "statusChanged" , fnChanged);
				}
			}

//load depends!
			if (!pDepsManager.load(pDeps, sDepsRoot)) {
				{ logger.setSourceLocation( "core/Engine.ts" , 208 ); logger.criticalError("load dependencies are not started."); } ;
			}

//===========================================================
		}

		/**@inline*/  getSpriteManager(): ISpriteManager {
			return this._pSpriteManager;
		}

		/**@inline*/  getDepsManager(): IDepsManager {
			return this._pDepsManager;
		}

		/**@inline*/  getScene(): IScene3d {
			return this._pSceneManager.getScene3D(0);
		}

		/**@inline*/  getSceneManager(): ISceneManager {
			return this._pSceneManager;
		}

		/**@inline*/  getParticleManager(): IParticleManager {
			return null;
		}


		/**@inline*/  getResourceManager(): IResourcePoolManager {
			return this._pResourceManager;
		}

		/**@inline*/  getRenderer(): IRenderer {
			return this._pRenderer;
		}

		/**@inline*/  getComposer(): IAFXComposer {
			return this._pComposer;
		}

		/**@inline*/  isActive(): bool {
			return this._isActive;
		}

		/**@inline*/  isDepsLoaded(): bool {
			return this._isDepsLoaded;
		}

// _nCountFrame: uint = 0;
		exec(bValue: bool = true): void {
			var pRenderer: IRenderer = this._pRenderer;
			var pEngine: Engine = this;
// var pCanvas: HTMLCanvasElement = null;


// pCanvas = (<IWebGLRenderer>pRenderer).getHTMLCanvas();


			{ logger.setSourceLocation( "core/Engine.ts" , 265 ); logger.assert(!isNull(pRenderer)); } ;

	        pRenderer._initRenderTargets();

// Infinite loop, until broken out of by frame listeners
// or break out by calling queueEndRendering()
	        bValue? this.active(): this.inactive();


	        function render(iTime:  number ): void {

				if (!pRenderer.isValid()) {
					{ logger.setSourceLocation( "core/Engine.ts" , 277 ); logger.error(pRenderer.getError()); } ;
				}

	        	if (pEngine.isActive() && pEngine.isDepsLoaded()) {
					if (!pEngine.renderFrame()) {
		                { logger.setSourceLocation( "core/Engine.ts" , 282 ); logger.error("Engine::exec() error."); } ;
		                return;
		            }

// pEngine._nCountFrame++;

// if(pEngine._nCountFrame === 1000){
// 	pEngine.pause();
// }
	            }

/*, pCanvas*/
	            requestAnimationFrame(render             );
	        }

	        render(0);
		}

		/**@inline*/  getTimer(): IUtilTimer { return <IUtilTimer>this._pTimer; }

		renderFrame(): bool {
		    this._fElapsedAppTime = this._pTimer.elapsedTime;

		    if (0. == this._fElapsedAppTime && this._isFrameMoving) {
		        return true;
		    }

// FrameMove (animate) the scene
		    if (this._isFrameMoving) {
		    	if (!isNull(this._pGamepads)) {
		    		this._pGamepads.update();
		    	}
		    	this._pSceneManager.update();
		    }

// Render the scene as normal
	    	this.frameStarted();
		    this._pRenderer._updateAllRenderTargets();
		    this.frameEnded();

// this._pSceneManager.preUpdate();

// LOG("frame rendered();");
			return true;
		}

		play(): bool {
			if (!this.isActive()) {
				this._iAppPausedCount = 0;
				this.active();

				if (this._isFrameMoving) {
		            this._pTimer.start();
		        }
	        }

	        return this.isActive();
		}

		pause(isPause: bool = false): bool {
			this._iAppPausedCount += ( isPause ? +1 : -1 );
		   (this._iAppPausedCount ? this.inactive() : this.active());

// Handle the first pause request (of many, nestable pause requests)
		    if (isPause && ( 1 == this._iAppPausedCount )) {
// Stop the scene from animating
		        if (this._isFrameMoving) {
		            this._pTimer.stop();
		        }
		    }

		    if (0 == this._iAppPausedCount) {
// Restart the timers
		        if (this._isFrameMoving) {
		            this._pTimer.start();
		        }
		    }

		    return !this.isActive();
		}

		/**@inline*/  createMesh(sName: string = null, eOptions:  number  = 0, pDataBuffer: IRenderDataCollection = null): IMesh {
			return model.createMesh(this, sName, eOptions, pDataBuffer);
		}

		/**@inline*/  createRenderDataCollection(iOptions:  number  = 0): IRenderDataCollection {
			return render.createRenderDataCollection(this, iOptions);
		}

		/**@inline*/  createBufferMap(): IBufferMap {
			return util.createBufferMap(this);
		}

		/**@inline*/  createAnimationController(sName?: string, iOptions?:  number ): IAnimationController {
			return animation.createController(this, sName, iOptions);
		}

		_depsLoaded(pLoader: IDepsManager, pDeps: IDependens): void {
			{ logger.setSourceLocation( "core/Engine.ts" , 379 ); logger.log("[ALL DEPTS LOADED]"); } ;
			this._isDepsLoaded = true;

			this.depsLoaded(pDeps);
		}

		static depends(sData: string): void;
		static depends(pData: IDependens): void;
		static depends(pData): void {
			var pDeps: IDependens = Engine.DEPS;

			while (isDefAndNotNull(pDeps.files)) {
				if (!isDefAndNotNull(pDeps.deps)) {
					pDeps.deps = {
						files: null,
						deps: null
					};
				}

				pDeps = pDeps.deps;
			}

			if (isString(pData)) {
				pDeps.files = [{path: pData}];
			}
			else {
				pDeps.deps = pData;
			}
		}

		static DEPS_ROOT: string = DATA;
		static DEPS: IDependens =
//RELEASE
//engine core dependences
			{
				files: [
					{
						path: "@CORE_ARA",
						type: "ARA"
					}
				]
			};


		protected _iGuid: number = sid(); /**@inline*/ getGuid(): number { return this._iGuid; } protected _pUnicastSlotMap: IEventSlotMap = null; protected _pBroadcastSlotList: IEventSlotListMap = null; protected static _pEventTable: IEventTable = new events.EventTable(); /**@inline*/ getEventTable(): IEventTable { return Engine._pEventTable; } /**@inline*/ connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; /**@inline*/ disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } /**@inline*/ bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } /**@inline*/ _syncTable(pFrom: IEventProvider): void { this.getEventTable()._sync(this, pFrom); } ;
		frameStarted (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).frameStarted; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		frameEnded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).frameEnded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		depsLoaded (deps): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).depsLoaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, deps) : _broadcast[i].listener (_recivier, deps) ; } } } ; ;

		 inactive(): void {
			this._isActive = false;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).inactive; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } ;
		}

		 active(): void {
			this._isActive = true;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).active; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } ;
		}

// BROADCAST(inactive, VOID);
// BROADCAST(active, VOID);

	}

}

module akra {
	createEngine = function (pOptions?: IEngineOptions): IEngine {
		return new core.Engine(pOptions);
	}
}




// #include "util/ObjectArray.ts"
// #include "util/ObjectList.ts"



