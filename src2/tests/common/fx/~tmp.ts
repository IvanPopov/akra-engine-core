















//#define trace(...) console.log(__VA_ARGS__)



// #define CRYPTO_API 1
// #define GUI 1
// #define WEBGL_DEBUG 1





module akra {

	export enum ELogLevel {
        NONE = 0x0000,
        LOG = 0x0001,
        INFORMATION = 0x0002,
        WARNING = 0x0004,
        ERROR = 0x0008,
        CRITICAL = 0x0010,
        ALL = 0x001F
    }

    export interface ILogRoutineFunc {
        (pEntity: ILoggerEntity): void;
    }

    export interface ISourceLocation {
        file: string;
        line:  number ;
    }

    export interface ILoggerEntity {
        code:  number ;
        location: ISourceLocation;
        message?: string;
        info: any;
    }

    export interface ILogger {

///**
//* For plugin api:
//* Load file with custom user codes and three messages 
//*/
//loadManifestFile(): bool;

        init(): bool;

        setLogLevel(eLevel: ELogLevel): void;
        getLogLevel(): ELogLevel;

        registerCode(eCode:  number , sMessage?: string): bool;
        setUnknownCode(eCode:  number , sMessage: string): void;

        registerCodeFamily(eCodeMin:  number , eCodeMax:  number , sFamilyName?: string): bool;

        getFamilyName(eCode:  number ): string;

        setCodeFamilyRoutine(eCodeFromFamily:  number , fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine(sFamilyName: string, fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;

        setLogRoutine(fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): void;

        setSourceLocation(sFile: string, iLine:  number ): void;
        setSourceLocation(pLocation: ISourceLocation): void;

// Print messages methods

        log(...pArgs: any[]);

        info(pEntity: ILoggerEntity): void;
        info(eCode:  number , ...pArgs: any[]): void;
        info(...pArgs: any[]): void;

        warning(pEntity: ILoggerEntity): void;
        warning(eCode:  number , ...pArgs: any[]): void;
        warning(...pArgs: any[]): void;

        error(pEntity: ILoggerEntity): void;
        error(eCode:  number , ...pArgs: any[]): void;
        error(...pArgs: any[]): void;

        criticalError(pEntity: ILoggerEntity): void;
        criticalError(eCode:  number , ...pArgs: any[]): void;
        criticalError(...pArgs: any[]):void;

        assert(bCondition: bool, pEntity: ILoggerEntity): void;
        assert(bCondition: bool, eCode:  number , ...pArgs: any[]): void;
        assert(bCondition: bool, ...pArgs: any[]):void;

    }
}


























/*I ## */
/*I ## */
/*I ## */
/*I ## */




module akra {


    export var  DEBUG : bool = true;






    export var logger: ILogger;
    export var typeOf: (x: any) => string;

    typeOf = function typeOf(x: any): string {
        var s: string = typeof x;

        if (s === "object") {
            if (x) {

                if (x instanceof Array) {
                    return 'array';
                } else if (x instanceof Object) {
                    return s;
                }

                var sClassName = Object.prototype.toString.call(x);

                if (sClassName == '[object Window]') {
                    return 'object';
                }

                if ((sClassName == '[object Array]' ||
                     typeof x.length == 'number' &&
                     typeof x.splice != 'undefined' &&
                     typeof x.propertyIsEnumerable != 'undefined' &&
                     !x.propertyIsEnumerable('splice')

                    )) {
                    return 'array';
                }

                if ((sClassName == '[object Function]' ||
                    typeof x.call != 'undefined' &&
                    typeof x.propertyIsEnumerable != 'undefined' &&
                    !x.propertyIsEnumerable('call'))) {
                    return 'function';
                }

            } else {
                return 'null';
            }

        } else if (s == 'function' && typeof x.call == 'undefined') {
            return 'object';
        }
        return s;
    };


/** @inline */

    export var isDef = (x: any): bool =>  x !== undefined;
/** @inline */

    export var isEmpty = (x: any): bool =>  x.length == 0;

// Note that undefined == null.
/** @inline */

    export var isDefAndNotNull = (x: any): bool =>  x != null;

/** @inline */

    export var isNull = (x: any): bool =>  x === null;

/** @inline */

    export var isBoolean = (x: any): bool => typeof x === "boolean";

/** @inline */

    export var isString = (x: any): bool => typeof x === "string";

/** @inline */

    export var isNumber = (x: any): bool => typeof x === "number";
/** @inline */

    export var isFloat = isNumber;
/** @inline */

    export var isInt = isNumber;

/** @inline */

    export var isFunction = (x: any): bool => typeOf(x) === "function";

/** @inline */

    export var isObject = (x: any): bool => {
        var type = typeOf(x);
        return type == "object" || type == "array" || type == "function";
    };

    export var isArrayBuffer = (x: any): bool => x instanceof ArrayBuffer;

    export var isTypedArray = (x: any): bool => x !== null && typeof x === "object" && typeof x.byteOffset === "number";

/** @inline */

    export var isArray = (x: any): bool => {
        return typeOf(x) == "array";
    };

    export interface Pair {
        first: any;
        second: any;
    };

// if (!isDef(console.assert)) {
//     console.assert = function (isOK?: bool, ...pParams: any[]): void {
//         if (!isOK) {
//             trace('---------------------------');
//             trace.apply(null, pParams);
//             throw new Error("[assertion failed]");
//         }
//     }
// }

// export var trace = console.log.bind(console);
// export var assert = console.assert.bind(console);
// export var warning = console.warn.bind(console);
// export var error = console.error.bind(console); 









// export var debug_print = (pArg:any, ...pParams: any[]): void => {
//         trace.apply(null, arguments);
// }

// export var debug_assert = (isOK: bool, ...pParams: any[]): void => {
//         assert.apply(null, arguments);
// }

// export var debug_warning = (pArg:any, ...pParams: any[]): void => {
//         warning.apply(null, arguments);
// }

// export var debug_error = (pArg:any, ...pParams: any[]): void => {
//         error.apply(null, arguments);
// }




    export function genArray(pType: any, nSize:  number ) {
        var tmp = new Array(nSize);

        for (var i:  number  = 0; i < nSize; ++i) {
            tmp[i] = (pType? new pType: null);
        }

        return tmp;
    }


    export  /**@const*/var  INVALID_INDEX:  number  =  0xffff;

// (-2147483646);
    export  /**@const*/var  MIN_INT32:  number  = 0xffffffff;
// ( 2147483647);
    export  /**@const*/var  MAX_INT32:  number  = 0x7fffffff;
// (-32768);
    export  /**@const*/var  MIN_INT16:  number  = 0xffff;
// ( 32767);  
    export  /**@const*/var  MAX_INT16:  number  = 0x7fff;
// (-128);
    export  /**@const*/var  MIN_INT8:  number  = 0xff;
// ( 127);        
    export  /**@const*/var  MAX_INT8:  number  = 0x7f;
    export  /**@const*/var  MIN_UINT32:  number  = 0;
    export  /**@const*/var  MAX_UINT32:  number  = 0xffffffff;
    export  /**@const*/var  MIN_UINT16:  number  = 0;
    export  /**@const*/var  MAX_UINT16:  number  = 0xffff;
    export  /**@const*/var  MIN_UINT8:  number  = 0;
    export  /**@const*/var  MAX_UINT8:  number  = 0xff;


    export  /**@const*/var  SIZE_FLOAT64:  number  = 8;
    export  /**@const*/var  SIZE_REAL64:  number  = 8;
    export  /**@const*/var  SIZE_FLOAT32:  number  = 4;
    export  /**@const*/var  SIZE_REAL32:  number  = 4;
    export  /**@const*/var  SIZE_INT32:  number  = 4;
    export  /**@const*/var  SIZE_UINT32:  number  = 4;
    export  /**@const*/var  SIZE_INT16:  number  = 2;
    export  /**@const*/var  SIZE_UINT16:  number  = 2;
    export  /**@const*/var  SIZE_INT8:  number  = 1;
    export  /**@const*/var  SIZE_UINT8:  number  = 1;
    export  /**@const*/var  SIZE_BYTE:  number  = 1;
    export  /**@const*/var  SIZE_UBYTE:  number  = 1;

//1.7976931348623157e+308
    export  /**@const*/var  MAX_FLOAT64:  number  = Number.MAX_VALUE;
//-1.7976931348623157e+308
    export  /**@const*/var  MIN_FLOAT64:  number  = -Number.MAX_VALUE;
//5e-324
    export  /**@const*/var  TINY_FLOAT64:  number  = Number.MIN_VALUE;

//    export const MAX_REAL64: number = Number.MAX_VALUE;   //1.7976931348623157e+308
//    export const MIN_REAL64: number = -Number.MAX_VALUE;  //-1.7976931348623157e+308
//    export const TINY_REAL64: number = Number.MIN_VALUE;  //5e-324


//3.4e38
    export  /**@const*/var  MAX_FLOAT32:  number  = 3.4e38;
//-3.4e38
    export  /**@const*/var  MIN_FLOAT32:  number  = -3.4e38;
//1.5e-45  
    export  /**@const*/var  TINY_FLOAT32:  number  = 1.5e-45;

//    export const MAX_REAL32: number = 3.4e38;     //3.4e38
//    export const MIN_REAL32: number = -3.4e38;    //-3.4e38
//    export const TINY_REAL32: number = 1.5e-45;   //1.5e-45

    export  /**@const*/var  DEFAULT_MATERIAL_NAME: string =  "default" ;

    export enum EDataTypes {
        BYTE = 0x1400,
        UNSIGNED_BYTE = 0x1401,
        SHORT = 0x1402,
        UNSIGNED_SHORT = 0x1403,
        INT = 0x1404,
        UNSIGNED_INT = 0x1405,
        FLOAT = 0x1406
    };

    export enum EDataTypeSizes {
        BYTES_PER_BYTE = 1,
        BYTES_PER_UNSIGNED_BYTE = 1,
        BYTES_PER_UBYTE = 1,

        BYTES_PER_SHORT = 2,
        BYTES_PER_UNSIGNED_SHORT = 2,
        BYTES_PER_USHORT = 2,

        BYTES_PER_INT = 4,
        BYTES_PER_UNSIGNED_INT = 4,
        BYTES_PER_UINT = 4,

        BYTES_PER_FLOAT = 4
    };

/*
    export enum EResourceTypes {
        SURFACE = 1,
        VOLUME,
        TEXTURE,   
        VOLUMETEXTURE,
        CUBETEXTURE,
        VERTEXBUFFER,
        INDEXBUFFER,
        FORCE_DWORD = 0x7fffffff
    };

*/


    export interface StringMap {
        [index: string]: string;
        [index: number]: string;
    };

    export interface IntMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface UintMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface FloatMap {
        [index: string]:  number ;
        [index: number]:  number ;
    };

    export interface BoolMap {
        [index: string]: bool;
        [index: number]: bool;
    };

    export interface BoolDMap{
        [index: string]: BoolMap;
        [index: number]: BoolMap;
    };

    export interface StringDMap{
        [index: string]: StringMap;
        [index: number]: StringMap;
    }

/**
     * Возвращет размер типа в байтах
     **/

//export function getTypeSize(eType: EImageTypes): uint;
    export function getTypeSize(eType: EDataTypes):  number ;
    export function getTypeSize(eType):  number  {
        switch (eType) {
            case EDataTypes.BYTE:
            case EDataTypes.UNSIGNED_BYTE:
                return 1;
            case EDataTypes.SHORT:
            case EDataTypes.UNSIGNED_SHORT:
//case EImageTypes.UNSIGNED_SHORT_4_4_4_4:
//case EImageTypes.UNSIGNED_SHORT_5_5_5_1:
//case EImageTypes.UNSIGNED_SHORT_5_6_5:
                return 2;
            case EDataTypes.INT:
            case EDataTypes.UNSIGNED_INT:
            case EDataTypes.FLOAT:
                return 4;
            default:
                logger.setSourceLocation( "common.ts" , 410 ); logger.error('unknown data/image type used'); ;
        }
    }


    export var sid = ():  number  => (++ sid._iTotal);
    sid._iTotal = 0;


    export function now():  number  {
        return (new Date).getTime();
    }



    export inline function memcpy(pDst: ArrayBuffer, iDstOffset:  number , pSrc: ArrayBuffer, iSrcOffset:  number , nLength:  number ) {
      var dstU8 = new Uint8Array(pDst, iDstOffset, nLength);
      var srcU8 = new Uint8Array(pSrc, iSrcOffset, nLength);
      dstU8.set(srcU8);
    };


//export function 

	(<any>window).URL = (<any>window).URL ? (<any>window).URL : (<any>window).webkitURL ? (<any>window).webkitURL : null;
	(<any>window).BlobBuilder = (<any>window).WebKitBlobBuilder || (<any>window).MozBlobBuilder || (<any>window).BlobBuilder;
	(<any>window).requestFileSystem = (<any>window).requestFileSystem || (<any>window).webkitRequestFileSystem;
	(<any>window).requestAnimationFrame = (<any>window).requestAnimationFrame || (<any>window).webkitRequestAnimationFrame ||
		(<any>window).mozRequestAnimationFrame;
	(<any>window).WebSocket = (<any>window).WebSocket || (<any>window).MozWebSocket;
    (<any>window).storageInfo = (<any>window).storageInfo || (<any>window).webkitStorageInfo;
    (<any>navigator).gamepads = (<any>navigator).gamepads || (<any>navigator).webkitGamepads;
    (<any>navigator).getGamepads = (<any>navigator).getGamepads || (<any>navigator).webkitGetGamepads;

    Worker.prototype.postMessage = (<any>Worker).prototype.webkitPostMessage || Worker.prototype.postMessage;
};






function utf8_encode (argString: string): string {
// Encodes an ISO-8859-1 string to UTF-8  
// 
// version: 1109.2015
// discuss at: http://phpjs.org/functions/utf8_encode
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +   improved by: sowberry
// +    tweaked by: Jack
// +   bugfixed by: Onno Marsman
// +   improved by: Yves Sucaet
// +   bugfixed by: Onno Marsman
// +   bugfixed by: Ulrich
// +   bugfixed by: Rafal Kukawski
// *     example 1: utf8_encode('Kevin van Zonneveld');
// *     returns 1: 'Kevin van Zonneveld'
    if (argString === null || typeof argString === "undefined") {
        return "";
    }
// .replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    var string = (argString + "");
    var utftext = "",
        start, end, stringl = 0;

    start = end = 0;
    stringl = string.length;
    for (var n = 0; n < stringl; n++) {
        var c1 = string.charCodeAt(n);
        var enc = null;

        if (c1 < 128) {
            end++;
        } else if (c1 > 127 && c1 < 2048) {
            enc = String.fromCharCode((c1 >> 6) | 192) + String.fromCharCode((c1 & 63) | 128);
        }
        else {
            enc = String.fromCharCode((c1 >> 12) | 224) + String.fromCharCode(((c1 >> 6) & 63) | 128)
                + String.fromCharCode((c1 & 63) | 128);
        }
        if (enc !== null) {
            if (end > start) {
                utftext += string.slice(start, end);
            }
            utftext += enc;
            start = end = n + 1;
        }
    }

    if (end > start) {
        utftext += string.slice(start, stringl);
    }

    return utftext;
}


function utf8_decode (str_data: string): string {
// http://kevin.vanzonneveld.net
// +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
// +      input by: Aman Gupta
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +   improved by: Norman "zEh" Fuchs
// +   bugfixed by: hitwork
// +   bugfixed by: Onno Marsman
// +      input by: Brett Zamir (http://brett-zamir.me)
// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// *     example 1: utf8_decode('Kevin van Zonneveld');
// *     returns 1: 'Kevin van Zonneveld'
    var tmp_arr = [],
        i = 0,
        ac = 0,
        c1 = 0,
        c2 = 0,
        c3 = 0;

    str_data += "";

    while (i < str_data.length) {
        c1 = str_data.charCodeAt(i);
        if (c1 < 128) {
            tmp_arr[ac++] = String.fromCharCode(c1);
            i++;
        } else if (c1 > 191 && c1 < 224) {
            c2 = str_data.charCodeAt(i + 1);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
            i += 2;
        }
        else {
            c2 = str_data.charCodeAt(i + 1);
            c3 = str_data.charCodeAt(i + 2);
            tmp_arr[ac++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }

    return tmp_arr.join("");
}



interface String {
    toUTF8(): string;
    fromUTF8(): string;



    replaceAt(n:  number , s: string);

}

interface Array {
    last: any;
    first: any;
    el(i : number ): any;
    clear(): any[];
    swap(i:  number , j:  number ): any[];
    insert(elements: any[]): any[];
    find(pElement: any): bool;
}

interface Number {
    toHex(length:  number ): string;
    printBinary(isPretty?: bool);
}

module akra.libs {
/**
     * Encodes an ISO-8859-1 string to UTF-8
     * @treturn String
     */

    String.prototype.toUTF8 = function () {
        return utf8_encode(this);
    };

/**
     * Converts a UTF-8 encoded string to ISO-8859-1
     * @treturn String
     */

    String.prototype.fromUTF8 = function () {
        return utf8_decode(this);
    };



    String.prototype.replaceAt = function (n, chr) {
        return this.substr(0, n) + chr + this.substr(n + chr.length);
    };


    Object.defineProperty(Array.prototype, 'first', {
        enumerable: false,
        configurable: true,
        get: function() {
            return this[0];
        }
    });

    Object.defineProperty(Array.prototype, 'last', {
        enumerable: false,
        configurable: true,
        get: function() {
            return this[this.length - 1];
        }
    });

    Object.defineProperty(Array.prototype, 'el', {
        enumerable: false,
        configurable: true,
        value: function (i) {i = i || 0; return this[i < 0? this.length + i: i];}
    });

    Object.defineProperty(Array.prototype, 'clear', {
        enumerable: false,
        configurable: true,
        value: function () {this.length = 0;}
    });

    Object.defineProperty(Array.prototype, 'swap', {
        enumerable: false,
        configurable: true,
        value: function (i, j) {
            if (i < this.length && j < this.length) {
                var t = this[i]; this[i] = this[j]; this[j] = t;
            }
        }
    });

    Object.defineProperty(Array.prototype, 'insert', {
        enumerable: false,
        configurable: true,
        value: function (pElement) {
            if (typeof pElement.length === 'number') {
                for (var i = 0, n = pElement.length; i < n; ++ i) {
                    this.push(pElement[i]);
                };
            }
            else {
                this.push(pElement);
            }

            return this;
        }
    });

    Number.prototype.toHex = function (iLength:  number ): string {
        var sValue = this.toString(16);

        for (var i = 0; i < iLength - sValue.length; ++ i) {
            sValue = '0' + sValue;
        }

        return sValue;
    };

    Number.prototype.printBinary = function (isPretty: bool = true): string {
        var res: string = "";
        for (var i = 0; i < 32; ++i) {
            if (i && (i % 4) == 0 && isPretty) {
                res = ' ' + res;
            }
            (this >> i & 0x1 ? res = '1' + res : res = '0' + res);
        }
        return res;
    };
}
















/**
 * FLAG(x)
 * Сдвиг единицы на @a x позиций влево.
 */



/**
 * TEST_BIT(value, bit)
 * Проверка того что у @a value бит под номером @a bit равен единице.
 */



/**
 * TEST_ALL(value, set)
 * Проверка того что у @a value равны единице все биты,
 * которые равны единице у @a set.
 */



/**
 * TEST_ANY(value, set)
 * Проверка того что у @a value равны единице хотя бы какие то из битов,
 * которые равны единице у @a set.
 */



/**
 * SET_BIT(value, bit)
 * Выставляет бит под номером @a bit у числа @a value равным единице
 */






/**
 * CLEAR_BIT(value, bit)
 * Выставляет бит под номером @a bit у числа @a value равным нулю
 */



/**
 * SET_ALL(value, set)
 * Выставляет все биты у числа @a value равными единице,
 * которые равны единице у числа @a set
 */



/**
 * CLEAR_ALL(value, set)
 * Выставляет все биты у числа @a value равными нулю,
 * которые равны единице у числа @a set
 */



//#define SET_ALL(value, set, setting) (setting ? SET_ALL(value, set) : CLEAR_ALL(value, set))



module akra.bf {
/**
	 * Сдвиг единицы на @a x позиций влево.
	 * @inline
	 */

	export var flag = (x:  number ) => (1 << (x));
/**
	 * Проверка того что у @a value бит под номером @a bit равен единице.
	 * @inline
	 */

	export var testBit = (value:  number , bit:  number ) => ((value & flag(bit)) != 0);
/**
	 * Проверка того что у @a value равны единице все биты,
 	 * которые равны единице у @a set.
	 * @inline
	 */

	export var testAll = (value:  number , set:  number ) => (((value) & (set)) == (set));
/**
	 * Проверка того что у @a value равны единице хотя бы какие то из битов,
 	 * которые равны единице у @a set.
	 * @inline
	 */

	export var testAny = (value:  number , set:  number ) => (((value) & (set)) != 0);
/**
	 * Выставляет бит под номером @a bit у числа @a value равным единице
	 * @inline
	 */

	export var setBit = (value:  number , bit:  number , setting: bool = true) => (setting ? ((value) |= flag((bit))) : clearBit(value, bit));
/**
	 * 
	 * @inline
	 */

	export var clearBit = (value:  number , bit:  number ) => ((value) &= ~flag((bit)));
/**
	 * Выставляет бит под номером @a bit у числа @a value равным нулю
	 * @inline
	 */

	export var setAll = (value:  number , set:  number , setting: bool = true) => (setting ? setAll(value, set) : clearAll(value, set));
/**
	 * Выставляет все биты у числа @a value равными единице,
 	 * которые равны единице у числа @a set
	 * @inline
	 */

	export var clearAll = (value:  number , set:  number ) => ((value) &= ~(set));
/**
	 * Выставляет все биты у числа @a value равными нулю,
 	 * которые равны единице у числа @a set
	 * @inline
	 */

	export var equal = (value:  number , src:  number ) => { value = src; };
/**
	 * Прирасваивает числу @a value число @a src
	 * @inline
	 */

	export var isEqual = (value:  number , src:  number ) => value == src;
/**
	 * Если число @a value равно числу @a src возвращается true
	 * @inline
	 */

	export var isNotEqaul = (value:  number , src:  number ) => value != src;
/**
	 * Прирасваивает числу @a value число @a src
	 * @inline
	 */

	export var set = (value:  number , src:  number ) => { value = src; };
/**
	 * Обнуляет число @a value
	 * @inline
	 */

	export var clear = (value:  number ) => { value = 0; };
/**
	 * Выставляет все биты у числа @a value равными единице,
 	 * которые равны единице у числа @a src
	 * @inline
	 */

	export var setFlags = (value:  number , src:  number ) => (value |= src);
/**
	 * Выставляет все биты у числа @a value равными нулю,
 	 * которые равны единице у числа @a src
	 * @inline
	 */

	export var clearFlags = (value:  number , src:  number ) => value &= ~src;
/**
	 * Проверяет равно ли число @a value нулю. Если равно возвращает true.
 	 * Если не равно возвращает false.
	 * @inline
	 */

	export var isEmpty = (value:  number ) => (value == 0);
/**
	 * Возвращает общее количество бит числа @a value.
 	 * На самом деле возвращает всегда 32.
	 * @inline
	 */

	export var totalBits = (value:  number ) => 32;
/**
	 * Возвращает общее количество ненулевых бит числа @a value.
	 * @inline
	 */

	export var totalSet = (value:  number ):  number  => {
		var count:  number  = 0;
        var total:  number  = totalBits(value);

        for (var i:  number  = total; i; --i) {
            count += (value & 1);
            value >>= 1;
        }

        return(count);
	}

/**
     * Convert N bit colour channel value to P bits. It fills P bits with the
     * bit pattern repeated. (this is /((1<<n)-1) in fixed point)
     */

    export inline function fixedToFixed(value:  number , n:  number , p:  number ):  number  {
        if(n > p) {
// Less bits required than available; this is easy
            value >>= n-p;
        }
        else if(n < p) {
// More bits required than are there, do the fill
// Use old fashioned division, probably better than a loop
            if(value == 0)
                    value = 0;
            else if(value == (< number >(1)<<n)-1)
                    value = (1<<p)-1;
            else    value = value*(1<<p)/((1<<n)-1);
        }
        return value;
    }

/**
     * Convert floating point colour channel value between 0.0 and 1.0 (otherwise clamped) 
     * to integer of a certain number of bits. Works for any value of bits between 0 and 31.
     */

    export inline function floatToFixed(value:  number , bits:  number ):  number  {
        if(value <= 0.0) return 0;
        else if (value >= 1.0) return (1<<bits)-1;
        else return < number >(value * (1<<bits));
    }

/**
     * Fixed point to float
     */

    export inline function fixedToFloat(value:  number , bits:  number ):  number  {
        return < number >(value&((1<<bits)-1))/< number >((1<<bits)-1);
    }

/**
     * Write a n*8 bits integer value to memory in native endian.
     */

    export inline function intWrite(pDest: Uint8Array, n:  number , value:  number ): void {
        switch(n) {
            case 1:
                pDest[0] = value;
                break;
            case 2:
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
            case 3:
                pDest[2] = ((value >> 16) & 0xFF);
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
            case 4:
                pDest[3] = ((value >> 24) & 0xFF);
                pDest[2] = ((value >> 16) & 0xFF);
                pDest[1] = ((value >> 8) & 0xFF);
                pDest[0] = (value & 0xFF);
                break;
        }
    }

/**
     * Read a n*8 bits integer value to memory in native endian.
     */

    export inline function intRead(pSrc: Uint8Array, n:  number ):  number  {
        switch(n) {
            case 1:
                return pSrc[0];
            case 2:
                return pSrc[0] | pSrc[1]<<8;
            case 3:
                return pSrc[0] | pSrc[1]<<8 | pSrc[2]<<16;
            case 4:
                return (pSrc[0]) | (pSrc[1]<<8) | (pSrc[2]<<16) | (pSrc[3]<<24);
        }
        return 0;
    }

    export function floatToHalfI(i:  number ):  number ;

//float32/uint32 union
    var _u32 = new Uint32Array(1);
    var _f32 = new Float32Array(_u32.buffer);

    export inline function floatToHalf(f:  number ) {
    	_f32[0] = f;
    	return floatToHalfI(_u32[0]);
    }
    export inline function floatToHalfI(i:  number ):  number  {

        var s:  number  =  (i >> 16) & 0x00008000;
        var e:  number  = ((i >> 23) & 0x000000ff) - (127 - 15);
        var m:  number  =   i        & 0x007fffff;

        if (e <= 0) {
            if (e < -10)
            {
                return 0;
            }
            m = (m | 0x00800000) >> (1 - e);

            return < number >(s | (m >> 13));
        }
        else if (e == 0xff - (127 - 15)) {
// Inf
            if (m == 0)
            {
                return < number >(s | 0x7c00);
            }
// NAN
            else
            {
                m >>= 13;
                return < number >(s | 0x7c00 | m | < number ><any>(m == 0));
            }
        }
        else {
// Overflow
            if (e > 30)
            {
                return < number >(s | 0x7c00);
            }

            return < number >(s | (e << 10) | (m >> 13));
        }
    }

/**
     * Convert a float16 (NV_half_float) to a float32
     * Courtesy of OpenEXR
     */

    export inline function halfToFloat(y:  number ):  number  {
        _u32[0] = halfToFloatI(y);
        return _f32[0];
    }

/** Converts a half in uint16 format to a float
	 	in uint32 format
	 */

    export inline function halfToFloatI(y:  number ):  number  {
        var s:  number  = (y >> 15) & 0x00000001;
        var e:  number  = (y >> 10) & 0x0000001f;
        var m:  number  =  y        & 0x000003ff;

        if (e == 0) {
// Plus or minus zero
            if (m == 0)  {
                return s << 31;
            }
// Denormalized number -- renormalize it
            else {
                while (!(m & 0x00000400)) {
                    m <<= 1;
                    e -=  1;
                }

                e += 1;
                m &= ~0x00000400;
            }
        }
        else if (e == 31) {
//Inf
            if (m == 0) {
                return (s << 31) | 0x7f800000;
            }
//NaN
            else {
                return (s << 31) | 0x7f800000 | (m << 13);
            }
        }

        e = e + (127 - 15);
        m = m << 13;

        return (s << 31) | (e << 23) | m;
    }

}


// #include "Singleton.ts"

module akra.util {

    export interface ILogRoutineMap {
        [eLogLevel:  number ]: ILogRoutineFunc;
    }

    export  interface ICodeFamily {
        familyName: string;
        codeMin:  number ;
        codeMax:  number ;
    }

    export  interface ICodeFamilyMap{
        [familyName: string]: ICodeFamily;
    }

    export interface ICodeInfo{
        code:  number ;
        message: string;
        familyName: string;
    }

    export interface ICodeInfoMap{
        [code:  number ] : ICodeInfo;
    }

    export interface ICodeFamilyRoutineDMap{
        [familyName: string]: ILogRoutineMap;
    }

/* extends Singleton*/
    export class Logger                       implements ILogger {
        private _eLogLevel: ELogLevel;
        private _pGeneralRoutineMap: ILogRoutineMap;

        private _pCurrentSourceLocation: ISourceLocation;
        private _pLastLogEntity: ILoggerEntity;

        private _pCodeFamilyList: ICodeFamily[];
        private _pCodeFamilyMap: ICodeFamilyMap;
        private _pCodeInfoMap: ICodeInfoMap;

        private _pCodeFamilyRoutineDMap: ICodeFamilyRoutineDMap;

        private _nFamilyGenerator:  number ;
        static private _sDefaultFamilyName: string = "CodeFamily";

        private _eUnknownCode:  number ;
        private _sUnknownMessage: string;

        constructor () {
//super();

            this._eUnknownCode = 0;
            this._sUnknownMessage = "Unknown code";

            this._eLogLevel = ELogLevel.ALL;
            this._pGeneralRoutineMap = <ILogRoutineMap>{};

            this._pCurrentSourceLocation = <ISourceLocation>{
                                            file: "",
                                            line: 0
                                        };

            this._pLastLogEntity = <ILoggerEntity>{
                                    code: this._eUnknownCode,
                                    location: this._pCurrentSourceLocation,
                                    message: this._sUnknownMessage,
                                    info: null,
                                   };

            this._pCodeFamilyMap = <ICodeFamilyMap>{};
            this._pCodeFamilyList = <ICodeFamily[]>[];
            this._pCodeInfoMap = <ICodeInfoMap>{};

            this._pCodeFamilyRoutineDMap = <ICodeFamilyRoutineDMap>{};

            this._nFamilyGenerator = 0;


        }

        init(): bool {
//TODO: Load file
            return true;
        }

        setLogLevel(eLevel: ELogLevel): void {
            this._eLogLevel = eLevel;
        }

        getLogLevel(): ELogLevel {
            return this._eLogLevel;
        }

        registerCode(eCode:  number , sMessage?: string = this._sUnknownMessage): bool{
            if(this.isUsedCode(eCode)){
                return false;
            }

            var sFamilyName: string = this.getFamilyName(eCode);
            if(isNull(sFamilyName)){
                return false;
            }

            var pCodeInfo: ICodeInfo = <ICodeInfo>{
                                            code: eCode,
                                            message: sMessage,
                                            familyName: sFamilyName
                                            };

            this._pCodeInfoMap[eCode] = pCodeInfo;

            return true;
        }

        setUnknownCode(eCode:  number , sMessage: string):void{
            this._eUnknownCode = eCode;
            this._sUnknownMessage = sMessage;
        }

        registerCodeFamily(eCodeMin:  number , eCodeMax:  number , sFamilyName?: string): bool{
            if(!isDef(sFamilyName)){
                sFamilyName = this.generateFamilyName();
            }

            if(this.isUsedFamilyName(sFamilyName)){
                return false;
            }

            if(!this.isValidCodeInterval(eCodeMin, eCodeMax)){
                return false;
            }

            var pCodeFamily: ICodeFamily = <ICodeFamily>{
                                                    familyName: sFamilyName,
                                                    codeMin: eCodeMin,
                                                    codeMax: eCodeMax
                                                    };

            this._pCodeFamilyMap[sFamilyName] = pCodeFamily;
            this._pCodeFamilyList.push(pCodeFamily);

            return true;
        }

        getFamilyName(eCode): string{
            var i:  number  = 0;
            var pCodeFamilyList: ICodeFamily[] = this._pCodeFamilyList;
            var pCodeFamily: ICodeFamily;

            for(i = 0; i < pCodeFamilyList.length; i++){
                pCodeFamily = pCodeFamilyList[i];

                if(pCodeFamily.codeMin <= eCode && pCodeFamily.codeMax >= eCode){
                    return pCodeFamily.familyName;
                }
            }

            return null;
        }

        setCodeFamilyRoutine(eCodeFromFamily:  number , fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine(sFamilyName: string, fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): bool;
        setCodeFamilyRoutine():bool {
            var sFamilyName: string = null;
            var fnLogRoutine: ILogRoutineFunc = null;
            var eLevel: ELogLevel = ELogLevel.LOG;

            if(isInt(arguments[0])){
                sFamilyName = this.getFamilyName(arguments[0]);
                fnLogRoutine = arguments[1];
                eLevel = arguments[2];

                if(isNull(sFamilyName)){
                    return false;
                }
            }
            else if(isString(arguments[0])){
                sFamilyName = arguments[0];
                fnLogRoutine = arguments[1];
                eLevel = arguments[2];
            }

            if(!this.isUsedFamilyName(sFamilyName)){
                return false;
            }

            var pCodeFamilyRoutineMap: ILogRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName];

            if(!isDef(pCodeFamilyRoutineMap)){
                pCodeFamilyRoutineMap = this._pCodeFamilyRoutineDMap[sFamilyName] = <ILogRoutineMap>{};
            }

            if (bf.testAll(eLevel, ELogLevel.LOG)) {
               pCodeFamilyRoutineMap[ELogLevel.LOG] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.INFORMATION)) {
               pCodeFamilyRoutineMap[ELogLevel.INFORMATION] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.WARNING)) {
               pCodeFamilyRoutineMap[ELogLevel.WARNING] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.ERROR)) {
               pCodeFamilyRoutineMap[ELogLevel.ERROR] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.CRITICAL)) {
               pCodeFamilyRoutineMap[ELogLevel.CRITICAL] = fnLogRoutine;
            }

            return true;
        }

        setLogRoutine(fnLogRoutine: ILogRoutineFunc, eLevel: ELogLevel): void {

            if (bf.testAll(eLevel, ELogLevel.LOG)) {
               this._pGeneralRoutineMap[ELogLevel.LOG] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.INFORMATION)) {
               this._pGeneralRoutineMap[ELogLevel.INFORMATION] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.WARNING)) {
               this._pGeneralRoutineMap[ELogLevel.WARNING] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.ERROR)) {
               this._pGeneralRoutineMap[ELogLevel.ERROR] = fnLogRoutine;
            }
            if (bf.testAll(eLevel, ELogLevel.CRITICAL)) {
               this._pGeneralRoutineMap[ELogLevel.CRITICAL] = fnLogRoutine;
            }
        }

        setSourceLocation(sFile: string, iLine:  number ): void;
        setSourceLocation(pLocation: ISourceLocation): void;
        setSourceLocation(): void {
            var sFile: string;
            var iLine:  number ;

            if(arguments.length === 2){
                sFile = arguments[0];
                iLine = arguments[1];
            }
            else {
                if(isDef(arguments[0]) && !(isNull(arguments[0]))){
                    sFile = arguments[0].file;
                    iLine = arguments[0].line;
                }
                else{
                    sFile = "";
                    iLine = 0;
                }
            }

            this._pCurrentSourceLocation.file = sFile;
            this._pCurrentSourceLocation.line = iLine;
        }


        log(...pArgs: any[]): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.LOG)){
                return;
            }

            var fnLogRoutine:ILogRoutineFunc = this._pGeneralRoutineMap[ELogLevel.LOG];
            if(!isDef(fnLogRoutine)){
                return;
            }

            var pLogEntity: ILoggerEntity = this._pLastLogEntity;

            pLogEntity.code = this._eUnknownCode;
            pLogEntity.location = this._pCurrentSourceLocation;
            pLogEntity.info = pArgs;
            pLogEntity.message = this._sUnknownMessage;

            fnLogRoutine.call(null, pLogEntity);
        }

        info(pEntity: ILoggerEntity): void;
        info(eCode:  number , ...pArgs: any[]): void;
        info(...pArgs: any[]): void;
        info(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.INFORMATION)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.INFORMATION);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        warning(pEntity: ILoggerEntity): void;
        warning(eCode:  number , ...pArgs: any[]): void;
        warning(...pArgs: any[]): void;
        warning(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.WARNING)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.WARNING);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        error(pEntity: ILoggerEntity): void;
        error(eCode:  number , ...pArgs: any[]): void;
        error(...pArgs: any[]): void;
        error(): void {
            if(!bf.testAll(this._eLogLevel, ELogLevel.ERROR)){
                return;
            }

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.ERROR);

            if(isNull(fnLogRoutine)){
                return;
            }

            fnLogRoutine.call(null, pLogEntity);
        }

        criticalError(pEntity: ILoggerEntity): void;
        criticalError(eCode:  number , ...pArgs: any[]): void;
        criticalError(...pArgs: any[]):void;
        criticalError():void {

            var pLogEntity: ILoggerEntity;
            var fnLogRoutine: ILogRoutineFunc;

            pLogEntity = this.prepareLogEntity.apply(this, arguments);
            fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.CRITICAL);

            var sSystemMessage: string = "A Critical error has occured! Code: " + pLogEntity.code.toString();

            if(bf.testAll(this._eLogLevel, ELogLevel.CRITICAL) && !isNull(fnLogRoutine)){
                fnLogRoutine.call(null, pLogEntity);
            }

            alert(sSystemMessage);
            throw new Error(sSystemMessage);
        }

        assert(bCondition: bool, pEntity: ILoggerEntity): void;
        assert(bCondition: bool, eCode:  number , ...pArgs: any[]): void;
        assert(bCondition: bool, ...pArgs: any[]):void;
        assert():void{
            var bCondition: bool = <bool> arguments[0];

            if(!bCondition){
                var pLogEntity: ILoggerEntity;
                var fnLogRoutine: ILogRoutineFunc;

                var pArgs: any[] = [];

                for(var i = 1; i < arguments.length; i++){
                    pArgs[i - 1] = arguments[i];
                }

                pLogEntity = this.prepareLogEntity.apply(this, pArgs);
                fnLogRoutine = this.getCodeRoutineFunc(pLogEntity.code, ELogLevel.CRITICAL);

                var sSystemMessage: string = "A error has occured! Code: " + pLogEntity.code.toString() +
                                             "\n Accept to exit, refuse to continue.";

                if(bf.testAll(this._eLogLevel, ELogLevel.CRITICAL) && !isNull(fnLogRoutine)){
                    fnLogRoutine.call(null, pLogEntity);
                }

                if(confirm(sSystemMessage)){
                    throw new Error(sSystemMessage);
                }
            }
        }


        private generateFamilyName(): string {
            var sSuffix: string = <string><any>(this._nFamilyGenerator++);
            var sName: string = Logger._sDefaultFamilyName + sSuffix;

            if(this.isUsedFamilyName(sName)){
                return this.generateFamilyName();
            }
            else {
                return sName;
            }
        }

        private isValidCodeInterval(eCodeMin:  number , eCodeMax:  number ): bool{
            if(eCodeMin > eCodeMax){
                return false;
            }

            var i:  number  = 0;
            var pCodeFamilyList: ICodeFamily[] = this._pCodeFamilyList;
            var pCodeFamily: ICodeFamily;

            for(i = 0; i < pCodeFamilyList.length; i++){
                pCodeFamily = pCodeFamilyList[i];

                if((pCodeFamily.codeMin <= eCodeMin && pCodeFamily.codeMax >= eCodeMin) ||
                   (pCodeFamily.codeMin <= eCodeMax && pCodeFamily.codeMax >= eCodeMax)){

                    return false;
                }
            }

            return true;
        }

        private inline isUsedFamilyName(sFamilyName: string): bool{
            return isDef(this._pCodeFamilyMap[sFamilyName]);
        }

        private inline isUsedCode(eCode:  number ): bool{
            return isDef(this._pCodeInfoMap[eCode]);
        }

        private isLogEntity(pObj:any):bool {
            if(isObject(pObj) && isDef(pObj.code) && isDef(pObj.location)){
                return true;
            }

            return false;
        }

        private inline isLogCode(eCode:any):bool {
            return isInt(eCode);
        }

        private prepareLogEntity(pEntity: ILoggerEntity): ILoggerEntity;
        private prepareLogEntity(eCode:  number , ...pArgs: any[]): ILoggerEntity;
        private prepareLogEntity(...pArgs:any[]): ILoggerEntity;
        private prepareLogEntity(): ILoggerEntity{
            var eCode:  number  = this._eUnknownCode;
            var sMessage:string = this._sUnknownMessage;
            var pInfo: any = null;

            if(arguments.length === 1 && this.isLogEntity(arguments[0])){
                var pEntity: ILoggerEntity = arguments[0];

                eCode = pEntity.code;
                pInfo = pEntity.info;
                this.setSourceLocation(pEntity.location);

                if(!isDef(pEntity.message)){
                    var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
                    if(isDef(pCodeInfo)){
                        sMessage = pCodeInfo.message;
                    }
                }

            }
            else {
                if(this.isLogCode(arguments[0])){
                    eCode = < number >arguments[0];
                    if(arguments.length > 1){
                        pInfo = new Array(arguments.length - 1);
                        var i:  number  = 0;

                        for(i = 0; i < pInfo.length; i++){
                            pInfo[i] = arguments[i+1];
                        }
                    }
                }
                else {
                    eCode = this._eUnknownCode;
// if(arguments.length > 0){
                        pInfo = new Array(arguments.length);
                        var i:  number  = 0;

                        for(i = 0; i < pInfo.length; i++){
                            pInfo[i] = arguments[i];
                        }
// }
// else {
//     pInfo = null;    
// }
                }

                var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
                if(isDef(pCodeInfo)){
                    sMessage = pCodeInfo.message;
                }
            }

            var pLogEntity: ILoggerEntity = this._pLastLogEntity;

            pLogEntity.code = eCode;
            pLogEntity.location = this._pCurrentSourceLocation;
            pLogEntity.message = sMessage;
            pLogEntity.info = pInfo;

            return pLogEntity;
        }

        private getCodeRoutineFunc(eCode:  number , eLevel: ELogLevel): ILogRoutineFunc{
            var pCodeInfo: ICodeInfo = this._pCodeInfoMap[eCode];
            var fnLogRoutine: ILogRoutineFunc;

            if(!isDef(pCodeInfo)){
                fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                return isDef(fnLogRoutine) ? fnLogRoutine : null;
            }

            var pCodeFamilyRoutineMap: ILogRoutineMap = this._pCodeFamilyRoutineDMap[pCodeInfo.familyName];

            if(!isDef(pCodeFamilyRoutineMap) || !isDef(pCodeFamilyRoutineMap[eLevel])) {
                fnLogRoutine = this._pGeneralRoutineMap[eLevel];
                return isDef(fnLogRoutine) ? fnLogRoutine : null;
            }

            fnLogRoutine = pCodeFamilyRoutineMap[eLevel];

            return fnLogRoutine;
        }

    }
}

module akra.util {
    export var logger: ILogger = new Logger();

    logger.init();
    logger.setUnknownCode( 0 ,  "Unknown code." );
    logger.setLogLevel(ELogLevel.ALL);

//Default code families

    logger.registerCodeFamily(0, 100, "SystemCodes");
    logger.registerCodeFamily(2000, 2199, "ParserSyntaxErrors");
    logger.registerCodeFamily(2200, 2500, "EffectSyntaxErrors");

//Default log routines

    function sourceLocationToString(pLocation: ISourceLocation): string {
        var pDate: Date = new Date;
        var sTime: string = pDate.getHours() + ":" + pDate.getMinutes() + "." + pDate.getSeconds();
        var sLocation:string = "[" + pLocation.file + ":" + pLocation.line.toString() + " " + sTime + "]: ";
        return sLocation;
    }

    function logRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        pArgs.unshift(sourceLocationToString(pLogEntity.location));
        console["log"].apply(console, pArgs);
    }

    function warningRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        pArgs.unshift("Code: " + pLogEntity.code.toString());
        pArgs.unshift(sourceLocationToString(pLogEntity.location));

        console["warn"].apply(console, pArgs);
    }

    function errorRoutine(pLogEntity: ILoggerEntity): void{
        var pArgs:any[] = pLogEntity.info;

        pArgs.unshift(pLogEntity.message);
        pArgs.unshift("Error code: " + pLogEntity.code.toString() + ".");
        pArgs.unshift(sourceLocationToString(pLogEntity.location));

        console["error"].apply(console, pArgs);
    }


    logger.setLogRoutine(logRoutine, ELogLevel.LOG | ELogLevel.INFORMATION);
    logger.setLogRoutine(warningRoutine, ELogLevel.WARNING);
    logger.setLogRoutine(errorRoutine, ELogLevel.ERROR | ELogLevel.CRITICAL);
}

module akra {
    logger = util.logger;
}







module akra.util {

	window.prompt = function (message?: string, defaul?: string): string {
		console.warn("prompt > " + message);
		return null;
	}

/*window.alert = function(message?: string): void {
		console.warn("alert > " + message);
	}*/


	window.confirm = function (message?: string): bool {
		console.warn("confirm > " + message);
		return false;
	}


	var pTestCondList: ITestCond[] = [];
	var pTestList: ITestManifest[] = [];
	var isPassed: bool;
	var pTest: ITestManifest = null;
	var iBegin:  number ;

	function addCond(pCond: ITestCond): void {
		pTestCondList.unshift(pCond);
	}

	interface ITestCond {
		description: string;
		toString(): string;
		verify(pArgv: any[]): bool;
	}

	class TestCond implements ITestCond {
		private sDescription: string;
		constructor (sDescription: string) {
			this.sDescription = sDescription;
		}

		toString(): string {
			return this.sDescription;
		}

		verify(pArgv: any[]) {
			return false;
		}

		get description(): string {
			return this.sDescription;
		}
	}

	class ArrayCond extends TestCond implements ITestCond {
		/**@protected*/  _pArr: any[];
		constructor (sDescription: string, pArr: any[]) {
			super(sDescription);

			this._pArr = pArr;
		}
		verify(pArgv: any[]): bool {
			var pArr: any[] = pArgv[0];

			if (pArr.length != this._pArr.length) {
				return false;
			}

			for (var i:  number  = 0; i < pArr.length; ++ i) {
				if (pArr[i] != this._pArr[i]) {
					return false;
				}
			};

			return true;
		}
	}

	class ValueCond extends TestCond implements ITestCond {
		/**@protected*/  _pValue: any;
		/**@protected*/  _isNegate: bool;
		constructor (sDescription: string, pValue: any, isNegate: bool = false) {
			super(sDescription);

			this._pValue = pValue;
			this._isNegate = isNegate;
		}

		verify(pArgv: any[]): bool {
			var bResult: bool = pArgv[0] === this._pValue;

// console.warn(">", pArgv[0], "!==", this._pValue);
			return this._isNegate? !bResult: bResult;
		}
	}



// function output(sText: string): void {
// 	document.body.innerHTML += sText;
// }

	function output(sText: string): void {

		var pElement = document.createElement("div");
		pElement.innerHTML = sText;
		document.body.appendChild(pElement);

	}


	export function check(...pArgv: any[]): void {
		var pTest: ITestCond = pTestCondList.pop();
		var bResult: bool;

		if (!pTest) {
			console.log((<any>(new Error)).stack);
			console.warn("chech() without condition...");
			return;
		}

		bResult = pTest.verify(pArgv);
		isPassed = isPassed && bResult;

		if (bResult) {
			output("<pre style=\"margin: 0; margin-left: 20px;\"><span style=\"color: green;\"><b>[ PASSED ]</b></span> " + pTest.toString() + "</pre>");
		}
		else {
			output("<pre style=\"margin: 0; margin-left: 20px;\"><span style=\"color: red;\"><b>[ FAILED ]</b></span> " + pTest.toString() + "</pre>");
		}
	}


	export function failed(e?: Error): void {
		if (isDef(e)) {
			printError(e.message, <string>(<any>e).stack);
		}

		var iTotal:  number  = pTestCondList.length;

		for (var i:  number  = 0; i < iTotal; ++ i) {
			check(false);
		}

		isPassed = false;
		pTest = null;
		printResults();

		run();
	}

	export function shouldBeTrue(sDescription: string) {
		addCond(new ValueCond(sDescription, true));
	}

	export function shouldBeFalse(sDescription: string) {
		addCond(new ValueCond(sDescription, false));
	}

	export function shouldBeArray(sDescription: string, pArr: any) {
		addCond(new ArrayCond(sDescription, <any[]>pArr));
	}

	export function shouldBe (sDescription: string, pValue: any) {
		addCond(new ValueCond(sDescription, pValue));
	}

	export function shouldBeNotNull(sDescription: string) {
		addCond(new ValueCond(sDescription, null, true));
	}

	export interface ITestManifest {
		name: string;
		description?: string;
		entry?: () => void;
		async?: bool;
	}

	export function test(sDescription: string, fnWrapper: () => void, isAsync?: bool);
	export function test(pManifest: ITestManifest, fnWrapper: () => void, isAsync?: bool);
	export function test (manifest: any, fnWrapper: () => void, isAsync: bool = false) {
		var pManifest: ITestManifest;

		if (isString(manifest)) {
			pManifest = {
				name: <string>arguments[0],
				description: null,
				entry: fnWrapper
			};
		}
		else {
			pManifest = <ITestManifest>arguments[0];
			pManifest.entry = fnWrapper;
		}

		pManifest.async = isAsync;

		pTestList.unshift(pManifest);
	}

	function printInfo (): void {
		output("<h4 style=\"font-family: monospace;\">" + pTest.name || "" + "</h4>");
	}

	function printResults(): void {
		output(
			"<pre style=\"margin-left: 20px;\">" +
			"<hr align=\"left\" style=\"border: 0; background-color: gray; height: 1px; width: 500px;\"/><span style=\"color: gray;\">total time: " + (now() - iBegin) + " msec" + "</span>" +
			"<br /><b>" + (isPassed? "<span style=\"color: green\">TEST PASSED</span>": "<span style=\"color: red\">TEST FAILED</span>") + "</b>" +
			"</pre>");
	}

	function printError(message: string, stack?: string): void {
		message = "<b>" + message + "</b>";

		if (isDef(stack)) {
			 message += "\n" + stack;
		}

		output(
			"<pre style=\"margin-left: 20px;\">" +
			"<span style=\"color: red; background-color: rgba(255, 0, 0, .1);\">" + message + "</span>" +
			"</pre>");
	}

	export function asyncTest (manifest: any, fnWrapper: () => void) {
		test(manifest, fnWrapper, true);
	}

	export function run(): void {
//если вдруг остались тесты.
		if (pTestCondList.length) {
			failed();
		}

//если предыдущий тест был асинхронным, значит он кончился и надо распечатать результаты
		if (!isNull(pTest) && pTest.async == true) {
			printResults();
		}

		while (pTestList.length) {
//начинаем новый тест
			pTest = pTestList.pop();
			iBegin = now();
			isPassed = true;


			printInfo();
//start test

			try {
				pTest.entry();
			} catch (e) {
				failed(e);
				return;
			}

			if (!pTest.async) {
				printResults();
				pTest = null;
			}
			else {
				return;
			}
		};
	}

	window.onload = function () {
		run();
	}
}

var test 			= akra.util.test;
var asyncTest 		= akra.util.asyncTest;
var failed 			= akra.util.failed;
var run 			= akra.util.run;
var shouldBe 		= akra.util.shouldBe;
var shouldBeArray 	= akra.util.shouldBeArray;
var shouldBeTrue 	= akra.util.shouldBeTrue;
var shouldBeFalse 	= akra.util.shouldBeFalse;
var shouldBeNotNull	= akra.util.shouldBeNotNull;
var check 			= akra.util.check;
var ok = check;













module akra {

	export interface ISceneManager {} ;
	export interface IParticleManager {} ;
	export interface IResourcePoolManager {} ;
    export interface IRenderer {} ;
	export interface IUtilTimer {} ;
    export interface IMesh {} ;
    export interface IRenderDataCollection {} ;
    export interface IBufferMap {} ;
    export interface IAnimationController {} ;
    export interface ISkeleton {} ;
    export interface IScene3d {} ;
    export interface IDependens {} ;
    export interface IAFXComposer {} ;
    export interface IGamepadMap {} ;

    export interface IEngineOptions {
        depsRoot?: string;
        deps?: IDependens;
        gamepads?: bool;
    }

    export interface IEngine extends IEventProvider {
        getScene(): IScene3d;

        getSceneManager(): ISceneManager;
        getParticleManager(): IParticleManager;
        getResourceManager(): IResourcePoolManager;

        getRenderer(): IRenderer;

        getComposer(): IAFXComposer;

        pause(): bool;
        play(): bool;

/** Render one frame. */

        renderFrame(): bool;

/** Start exucution(rendering loop). */

        exec(): void;
/** О��ределяет, находитсяли Engine в цикле рендеринга */

        isActive(): bool;


        getTimer(): IUtilTimer;

        enableGamepads(): bool;
        getGamepads(): IGamepadMap;

        createMesh(sName?: string, eOptions?:  number , pDataBuffer?: IRenderDataCollection): IMesh;
        createRenderDataCollection(iOptions?:  number ): IRenderDataCollection;
        createBufferMap(): IBufferMap;
        createAnimationController(iOptions?:  number ): IAnimationController;
    };

    export var createEngine: () => IEngine;
}











module akra {
    export interface IManager {
        initialize(): bool;
        destroy(): void;
    }
}



















module akra {
	export interface IUnique {
		getGuid():  number ;
	}
}



module akra {
	export interface IEventTable {} ;

	export enum EEventTypes {
		BROADCAST,
		UNICAST
	};

	export interface IEventProvider extends IUnique {
		getEventTable(): IEventTable;
		connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool;
		disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool;																														bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool;																															unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool;
// callOnce(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool;
	}
}





module akra {
	export enum ESceneTypes {
		TYPE_3D,
		TYPE_2D
	}

	export interface IScene extends IEventProvider {
		type: ESceneTypes;

		getManager(): ISceneManager;
	}
}





module akra {

    export interface IEngine {} ;
    export interface IScene3d {} ;
    export interface IScene2d {} ;

    export interface ISceneManager extends IManager {
        createScene3D(): IScene3d;
        createScene2D(): IScene2d;

        getEngine(): IEngine;

        getScene3D(iScene?:  number ): IScene3d;
        getScene2D(iScene?:  number ): IScene2d;
        getScene(iScene?:  number , eType?: ESceneTypes): IScene;

        update(): void;
        notifyUpdateScene(): void;
        notifyPreUpdateScene(): void;
    }
}









module akra {
    export interface IParticleManager extends IManager {

    }
}










module akra {

    export interface IEngine {} ;
    export interface IResourceCode {} ;
    export interface IResourcePool {} ;
    export interface IResourceWatcherFunc {} ;
    export interface IResourcePoolItem {} ;
    export interface IRenderMethod {} ;
    export interface ITexture {} ;
    export interface IVertexBuffer {} ;
    export interface IModel {} ;
    export interface ISurfaceMaterial {} ;
    export interface IEffect {} ;




/** Семейства ресурсов */

	export enum EResourceFamilies {
		VIDEO_RESOURCE = 0,
		AUDIO_RESOURCE,
		GAME_RESOURCE,
		TOTAL_RESOURCE_FAMILIES
	};

/** Члены семейства видео ресурсов */

	export enum EVideoResources {
		TEXTURE_RESOURCE,
		VIDEOBUFFER_RESOURCE,
		VERTEXBUFFER_RESOURCE,
		INDEXBUFFER_RESOURCE,
		EFFECT_RESOURCE,
		RENDERMETHOD_RESOURCE,
		MODEL_RESOURCE,
		EFFECTFILEDATA_RESOURCE,
		IMAGE_RESOURCE,
		SURFACEMATERIAL_RESOURCE,
		SHADERPROGRAM_RESOURCE,
		COMPONENT_RESOURCE,
        EFFECTDATA_RESOURCE,
		TOTAL_VIDEO_RESOURCES
	};

	export enum EAudioResources {
		TOTAL_AUDIO_RESOURCES
	};

	export enum EGameResources {
		TOTAL_GAME_RESOURCES
	};

/** Конструктор класса, занимается очисткой списков пулов по семействам ресурсвов и краты пулов по коду ресурсов */

    export interface IResourcePoolManager extends IManager {
    	texturePool: IResourcePool;
    	surfaceMaterialPool: IResourcePool;
    	vertexBufferPool: IResourcePool;
    	videoBufferPool: IResourcePool;
    	indexBufferPool: IResourcePool;
        textureBufferPool: IResourcePool;
    	renderMethodPool: IResourcePool;
    	colladaPool: IResourcePool;
    	imagePool: IResourcePool;
//ex: private
    	shaderProgramPool: IResourcePool;
//ex: private
    	effectPool: IResourcePool;
//ex: private
    	componentPool: IResourcePool;
        effectDataPool: IResourcePool;

/** Регистрируется пул ресурсов опредленного типа в менеджере русурсов */

    	registerResourcePool(pCode: IResourceCode, pPool: IResourcePool): void;
/** Удаляет пул ресурсов опредленного типа в менеджере русурсов */

    	unregisterResourcePool(pCode: IResourceCode): IResourcePool;

/** Удаление ресурсов определенного семества */

    	destroyResourceFamily(eFamily: EResourceFamilies): void;
    	restoreResourceFamily(eFamily: EResourceFamilies): void;
    	disableResourceFamily(eFamily: EResourceFamilies): void;
    	cleanResourceFamily(eFamily: EResourceFamilies): void;

    	destroyResourceType(pCode: IResourceCode): void;
    	restoreResourceType(pCode: IResourceCode): void;
    	disableResourceType(pCode: IResourceCode): void;
    	cleanResourceType(pCode: IResourceCode): void;
/** Возвращает пул ресурса опредленного типа по его коду */

    	findResourcePool(pCode: IResourceCode): IResourcePool;
/**
		 * Возвращает хендл конкретного ресурса по его имени из конкретного пула опредленного типа
		 **/

    	findResourceHandle(pCode: IResourceCode, sName: string):  number ;
/** Возвращает конкретный ресурс по его имени из конкретного пула опредленного типа */

    	findResource(pCode: IResourceCode, sName: string): IResourcePoolItem;
        findResource(pCode: IResourceCode, iHandle:  number ): IResourcePoolItem;

    	monitorInitResources(fnMonitor: IResourceWatcherFunc): void;
    	setLoadedAllRoutine(fnCallback: Function): void;

/** Удаление всех ресурсов */

    	destroyAll(): void;
    	restoreAll(): void;
    	disableAll(): void;

    	clean(): void;

    	createDeviceResources(): bool;
    	destroyDeviceResources(): bool;
    	restoreDeviceResources(): bool;
    	disableDeviceResources(): bool;

        getEngine(): IEngine;

        createRenderMethod(sResourceName: string): IRenderMethod;
        createTexture(sResourceName: string): ITexture;
        createSurfaceMaterial(sResourceName: string): ISurfaceMaterial;
        createEffect(sResourceName: string): IEffect;
        createVertexBuffer(sResourceName: string): IVertexBuffer;
        createVideoBuffer(sResourceName: string): IVertexBuffer;
        createIndexBuffer(sResourceName: string): IIndexBuffer;
        createModel(sResourceName: string): IModel;

        createImg(sResourceName: string): IImg;
        loadModel(sFilename: string, pOptions?: any): IModel;

    }
}









module akra {

    export interface IAFXComponent {} ;
    export interface IAFXEffect {} ;
    export interface IRenderableObject {} ;
    export interface IRenderSnapshot {} ;
    export interface ISceneObject {} ;
    export interface IBufferMap {} ;
    export interface IShaderProgram {} ;
    export interface ISurfaceMaterial {} ;
    export interface IVertexData {} ;
    export interface IVertexBuffer {} ;
    export interface ITexture {} ;
    export interface IIndexBuffer {} ;
    export interface IRenderResource {} ;
    export interface IRenderEntry {} ;
    export interface IFrameBuffer {} ;
    export interface IViewport {} ;
    export interface IColor {} ;
    export interface IEngine {} ;
    export interface IRenderTarget {} ;




//API SPECIFIFC CONSTANTS

    export enum EPrimitiveTypes {
        POINTLIST = 0,
        LINELIST,
        LINELOOP,
        LINESTRIP,
        TRIANGLELIST,
        TRIANGLESTRIP,
        TRIANGLEFAN
    };

    export enum ERenderCapabilitiesCategory {
        C_COMMON = 0,
        C_COMMON_2 = 1,
        C_WEBGL = 2,

        COUNT = 3
    }

    export enum ERenderCapabilities{
        AUTOMIPMAP              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 0)) ,
        BLENDING                =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 1)) ,
/// Supports anisotropic texture filtering
        ANISOTROPY              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 2)) ,
/// Supports fixed-function DOT3 texture blend
        DOT3                    =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 3)) ,
/// Supports cube mapping
        CUBEMAPPING             =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 4)) ,
/// Supports hardware stencil buffer
        HWSTENCIL               =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 5)) ,
/// Supports hardware vertex and index buffers
        VBO                     =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 7)) ,
/// Supports vertex programs (vertex shaders)
        VERTEX_PROGRAM          =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 9)) ,
/// Supports fragment programs (pixel shaders)
        FRAGMENT_PROGRAM        =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 10)) ,
/// Supports performing a scissor test to exclude areas of the screen
        SCISSOR_TEST            =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 11)) ,
/// Supports separate stencil updates for both front and back faces
        TWO_SIDED_STENCIL       =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 12)) ,
/// Supports wrapping the stencil value at the range extremeties
        STENCIL_WRAP            =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 13)) ,
/// Supports hardware occlusion queries
        HWOCCLUSION             =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 14)) ,
/// Supports user clipping planes
        USER_CLIP_PLANES        =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 15)) ,
/// Supports the VET_UBYTE4 vertex element type
        VERTEX_FORMAT_UBYTE4    =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 16)) ,
/// Supports infinite far plane projection
        INFINITE_FAR_PLANE      =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 17)) ,
/// Supports hardware render-to-texture (bigger than framebuffer)
        HWRENDER_TO_TEXTURE     =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 18)) ,
/// Supports float textures and render targets
        TEXTURE_FLOAT           =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 19)) ,
/// Supports non-power of two textures
        NON_POWER_OF_2_TEXTURES =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 20)) ,
/// Supports 3d (volume) textures
        TEXTURE_3D              =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 21)) ,
/// Supports basic point sprite rendering
        POINT_SPRITES           =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 22)) ,
/// Supports extra point parameters (minsize, maxsize, attenuation)
        POINT_EXTENDED_PARAMETERS =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 23)) ,
/// Supports vertex texture fetch
        VERTEX_TEXTURE_FETCH =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 24)) ,
/// Supports mipmap LOD biasing
        MIPMAP_LOD_BIAS =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 25)) ,
/// Supports hardware geometry programs
        GEOMETRY_PROGRAM =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 26)) ,
/// Supports rendering to vertex buffers
        HWRENDER_TO_VERTEX_BUFFER =  ((ERenderCapabilitiesCategory.C_COMMON << (32 - 4)) | (1 << 27)) ,

/// Supports compressed textures
        TEXTURE_COMPRESSION =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 0)) ,
/// Supports compressed textures in the DXT/ST3C formats
        TEXTURE_COMPRESSION_DXT =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 1)) ,
/// Supports compressed textures in the VTC format
        TEXTURE_COMPRESSION_VTC =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 2)) ,
/// Supports compressed textures in the PVRTC format
        TEXTURE_COMPRESSION_PVRTC =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 3)) ,
/// Supports fixed-function pipeline
        FIXED_FUNCTION =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 4)) ,
/// Supports MRTs with different bit depths
        MRT_DIFFERENT_BIT_DEPTHS =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 5)) ,
/// Supports Alpha to Coverage (A2C)
        ALPHA_TO_COVERAGE =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 6)) ,
/// Supports Blending operations other than +
        ADVANCED_BLEND_OPERATIONS =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 7)) ,
/// Supports a separate depth buffer for RTTs. D3D 9 & 10, OGL w/FBO (FBO implies this flag)
        RTT_SEPARATE_DEPTHBUFFER =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 8)) ,
/// Supports using the MAIN depth buffer for RTTs. D3D 9&10, OGL w/FBO support unknown
/// (undefined behavior?), OGL w/ copy supports it
        RTT_MAIN_DEPTHBUFFER_ATTACHABLE =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 9)) ,
/// Supports attaching a depth buffer to an RTT that has width & height less or equal than RTT's.
/// Otherwise must be of _exact_ same resolution. D3D 9, OGL 3.0 (not 2.0, not D3D10)
        RTT_DEPTHBUFFER_RESOLUTION_LESSEQUAL =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 10)) ,
/// Supports using vertex buffers for instance data
        VERTEX_BUFFER_INSTANCE_DATA =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 11)) ,
/// Supports using vertex buffers for instance data
        CAN_GET_COMPILED_SHADER_BUFFER =  ((ERenderCapabilitiesCategory.C_COMMON_2 << (32 - 4)) | (1 << 12)) ,


// ***** GL Specific Caps *****
/// Supports openGL GLEW version 1.5
        GL1_5_NOVBO    =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 1)) ,
/// Support for Frame Buffer Objects (FBOs)
        FBO              =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 2)) ,
/// Support for Frame Buffer Objects ARB implementation (regular FBO is higher precedence)
        FBO_ARB          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 3)) ,
/// Support for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence)
        FBO_ATI          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 4)) ,
/// Support for PBuffer
        PBUFFER          =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 5)) ,
/// Support for GL 1.5 but without HW occlusion workaround
        GL1_5_NOHWOCCLUSION =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 6)) ,
/// Support for point parameters ARB implementation
        POINT_EXTENDED_PARAMETERS_ARB =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 7)) ,
/// Support for point parameters EXT implementation
        POINT_EXTENDED_PARAMETERS_EXT =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 8)) ,
/// Support for Separate Shader Objects
        SEPARATE_SHADER_OBJECTS =  ((ERenderCapabilitiesCategory.C_WEBGL << (32 - 4)) | (1 << 9))
    }

// export enum EGLSpecifics {
//     UNPACK_ALIGNMENT = 0x0CF5,
//     PACK_ALIGNMENT = 0x0D05,
//     UNPACK_FLIP_Y_WEBGL = 0x9240,
//     UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241,
//     CONTEXT_LOST_WEBGL = 0x9242,
//     UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243,
//     BROWSER_DEFAULT_WEBGL = 0x9244
// };

// export enum EBufferMasks {
//     DEPTH_BUFFER_BIT               = 0x00000100,
//     STENCIL_BUFFER_BIT             = 0x00000400,
//     COLOR_BUFFER_BIT               = 0x00004000
// };

// export enum EBufferUsages {
//     STREAM_DRAW = 0x88E0,
//     STATIC_DRAW = 0x88E4,
//     DYNAMIC_DRAW = 0x88E8
// };

// export enum EBufferTypes {
//     ARRAY_BUFFER = 0x8892,
//     ELEMENT_ARRAY_BUFFER = 0x8893,
//     FRAME_BUFFER = 0x8D40,
//     RENDER_BUFFER = 0x8D41
// };

// export enum EAttachmentTypes {
//     COLOR_ATTACHMENT0 = 0x8CE0,
//     DEPTH_ATTACHMENT = 0x8D00,
//     STENCIL_ATTACHMENT = 0x8D20,
//     DEPTH_STENCIL_ATTACHMENT = 0x821A
// };

// export enum ERenderStates {
//     ZENABLE = 7,
//     ZWRITEENABLE = 14,
//     SRCBLEND = 19,
//     DESTBLEND = 20,
//     CULLMODE = 22,
//     ZFUNC = 23,
//     DITHERENABLE = 26,
//     ALPHABLENDENABLE = 27,
//     ALPHATESTENABLE
// };

// export enum EBlendModes {
//     ZERO = 0,
//     ONE = 1,
//     SRCCOLOR = 0x0300,
//     INVSRCCOLOR = 0x301,
//     SRCALPHA = 0x0302,
//     INVSRCALPHA = 0x0303,
//     DESTALPHA = 0x0304,
//     INVDESTALPHA = 0x0305,
//     DESTCOLOR = 0x0306,
//     INVDESTCOLOR = 0x0307,
//     SRCALPHASAT = 0x0308
// };

// export enum ECmpFuncs {
//     NEVER = 1,
//     LESS = 2,
//     EQUAL = 3,
//     LESSEQUAL = 4,
//     GREATER = 5,
//     NOTEQUAL = 6,
//     GREATEREQUAL = 7,
//     ALWAYS = 8
// };

// export enum ECullModes {
//     NONE = 0,
//     CW = 0x404, //FRONT
//     CCW = 0x0405, //BACK
//     FRONT_AND_BACK = 0x0408
// };

//END OF API SPECIFIC

// export enum ERenderStages {
//  SHADOWS = 2,
//  LIGHTING,
//  GLOBALPOSTEFFECTS,
//  DEFAULT
// }

    export interface IRenderer extends IEventProvider {
        getEngine(): IEngine;

        debug(bValue?: bool, useApiTrace?: bool): bool;

        isDebug(): bool;
        isValid(): bool;

        getError();

        clearFrameBuffer(iBuffer:  number , cColor: IColor, iDepth:  number ): void;

        _disableAllTextureUnits(): void;
        _disableTextureUnitsFrom(iUnit:  number ): void;

        _initRenderTargets(): void;
        _updateAllRenderTargets(): void;

        _setViewport(pViewport: IViewport): void;
        _getViewport(): IViewport;

        hasCapability(eCapability: ERenderCapabilities): bool;

        attachRenderTarget(pTarget: IRenderTarget): bool;
        detachRenderTarget(pTarget: IRenderTarget): bool;
        destroyRenderTarget(pTarget: IRenderTarget): void;

        getActiveProgram(): IShaderProgram;
    }



}






module akra {
	export enum EUtilTimerCommands {
//! <to reset the timer
		TIMER_RESET,
//! <to start the timer
		TIMER_START,
//! <to stop (or pause) the timer
		TIMER_STOP,
//! <to advance the timer by 0.1 seconds
		TIMER_ADVANCE,
//! <to get the absolute system time
		TIMER_GET_ABSOLUTE_TIME,
//! <to get the current time
		TIMER_GET_APP_TIME,
		TIMER_GET_ELAPSED_TIME
//! to get the time that elapsed between TIMER_GETELAPSEDTIME calls
	}

    export interface IUtilTimer {
        absoluteTime:  number ;
        appTime:  number ;
        elapsedTime:  number ;

        start(): bool;
        stop(): bool;
        reset(): bool;
        execCommand(e: EUtilTimerCommands):  number ;

//static start(): IUtilTimer;
    }
}












module akra {
	export interface ISceneNode {} ;
	export interface ISceneModel {} ;
	export interface ILightPoint {} ;
	export interface ISprite {} ;
	export interface IJoint {} ;
	export interface IText3d {} ;
	export interface IDisplayList {} ;



	export interface IScene3d extends IScene {
		totalDL:  number ;

		getRootNode(): ISceneNode;

		recursivePreUpdate(): void;
		updateCamera(): bool;
		updateScene(): bool;
		recursiveUpdate(): void;

		isUpdated(): bool;


		createObject(sName?: string): ISceneObject;


		createNode(sName?: string): ISceneNode;
		createModel(sName?: string): ISceneModel;
		createCamera(sName?: string): ICamera;
		createLightPoint(sName?: string): ILightPoint;
		createSprite(sName?: string): ISprite;
		createJoint(sName?: string): IJoint;
		createText3d(sName?: string): IText3d;

		getDisplayList(index:  number ): IDisplayList;
		getDisplayListByName(csName: string):  number ;
		addDisplayList(pList: IDisplayList):  number ;
		delDisplayList(index:  number ): bool;

		 nodeAttachment(pNode: ISceneNode): void;
		 nodeDetachment(pNode: ISceneNode): void;

		 displayListAdded(pList: IDisplayList, index:  number ): void;
		 displayListRemoved(pList: IDisplayList, index:  number ): void;

		_render(pCamera: ICamera, pViewport: IViewport): void;
	}
}














module akra {

















    export enum ENodeCreateMode {
        k_Default,
        k_Necessary,
        k_Not
    }

    export enum EParserCode {
        k_Pause,
        k_Ok,
        k_Error
    }

    export enum EParserType {
        k_LR0,
        k_LR1,
        k_LALR
    }

    export enum EParseMode {
        k_AllNode = 0x0001,
        k_Negate = 0x0002,
        k_Add = 0x0004,
        k_Optimize = 0x0008,
        k_DebugMode = 0x0010
    }

    export enum ETokenType {
        k_NumericLiteral = 1,
        k_CommentLiteral,
        k_StringLiteral,
        k_PunctuatorLiteral,
        k_WhitespaceLiteral,
        k_IdentifierLiteral,
        k_KeywordLiteral,
        k_Unknown,
        k_End
    }

    export interface IToken {
        value: string;
        start:  number ;
        end:  number ;
        line:  number ;

        name?: string;
        type?: ETokenType;
    }


    export interface IRule {
        left: string;
        right: string[];
        index:  number ;
    }

    export interface IFinishFunc {
        (eCode: EParserCode, sFileName: string): void;
    }

    export enum EOperationType {
        k_Error = 100,
        k_Shift,
        k_Reduce,
        k_Success,
        k_Pause,
        k_Ok
    }

    export interface IRuleFunction {
        (): EOperationType;
    }

    export interface IParseNode {
        children: IParseNode[];
        parent: IParseNode;
        name: string;
        value: string;

//Data for next-step analyze
        isAnalyzed: bool;
        position:  number ;

        start?:  number ;
        end?:  number ;
        line?:  number ;
    }

    export interface IParseTree {
        setRoot(): void;

        setOptimizeMode(isOptimize: bool): void;

        addNode(pNode: IParseNode): void;
        reduceByRule(pRule: IRule, eCreate: ENodeCreateMode);

        toString(): string;

        clone(): IParseTree;

        getNodes(): IParseNode[];
        getLastNode(): IParseNode;

        root: IParseNode;
    }

    export interface ILexer {
        addPunctuator(sValue: string, sName?: string): string;
        addKeyword(sValue: string, sName: string): string;

        getTerminalValueByName(sName: string): string;

        init(sSource: string): void;

        getNextToken(): IToken;
        _getIndex():  number ;
        _setSource(sSource: string): void;
        _setIndex(iIndex:  number ): void;
    }

    export interface IParserState {
        source: string;
        index:  number ;
        fileName: string;
        tree: IParseTree;
        types: BoolMap;
        stack:  number [];
        token: IToken;
        fnCallback: IFinishFunc;
        caller: any;
    }

    export interface IParser {

        isTypeId(sValue: string): bool;

        returnCode(pNode: IParseNode): string;

        init(sGrammar: string, eMode?: EParseMode, eType?: EParserType): bool;

        parse(sSource: string, fnFinishCallback?: IFinishFunc, pCaller?: any): EParserCode;

        setParseFileName(sFileName: string): void;
        getParseFileName(): string;

        pause(): EParserCode;
        resume(): EParserCode;

        getSyntaxTree(): IParseTree;

        printStates(isPrintOnlyBase?: bool): void;
        printState(iStateIndex:  number , isPrintOnlyBase?: bool): void;

        getGrammarSymbols(): StringMap;

        _saveState(): IParserState;
        _loadState(pState: IParserState): void;

// _getLexer(): ILexer;
// _getSource(): string;
// _getIndex(): uint;
// _getTypeMap(): BoolMap;
// _getStack(): uint[];
// _getToken(): IToken;
// _getCallback(): IFinishFunc;
// _getCaller(): any;

// _setParserState(sSource: string,
//                 iIndex: uint,
//                 sFileName: string,
//                 pTree: IParseTree,
//                 pTypes: BoolMap,
//                 pStack: uint[],
//                 pToken: IToken,
//                 fnCallback: IFinishFunc,
//                 pCaller: any): void;
    }
}






















module akra {
	export interface IReferenceCounter {
/**
		 * Текущее количесвто ссылок  на объект
		 **/

		referenceCount():  number ;

/** Предупреждает если объект еще используется */

		destructor(): void;


/**
		 * Добаволение ссылки  на объект, увеличивает внутренний счетчки на 1,
		 * проверяет не достигнуто ли максимальное количесвто
		 **/

		addRef():  number ;

/**
		 * Уведомление об удалении ссылки  на объект, уменьшает внутренний счетчки на 1,
		 * проверяет есть ли ее объекты
		 **/

		release():  number ;


/** 
		 * Данная функция нужна чтобы обеспечить наследникам ее возможность,
		 * само количестdо ссылок не копируется
		 */

		eq(pSrc: IReferenceCounter): IReferenceCounter;
	}
}





module akra {

	export interface IEngine {} ;
	export interface IResourceWatcherFunc {} ;
	export interface IResourceNotifyRoutineFunc {} ;
	export interface IResourceCode {} ;
	export interface IResourcePool {} ;
	export interface IResourcePoolManager {} ;

/**
     * Отражает состояние ресурса
     **/

    export enum EResourceItemEvents{
//ресур создан
		CREATED,
//ресур заполнен данным и готов к использованию
		LOADED,
//ресур в данный момент отключен для использования
		DISABLED,
//ресур был изменен после загрузки		
		ALTERED,
		TOTALRESOURCEFLAGS
	};

	export interface IResourcePoolItem extends IReferenceCounter, IEventProvider {
/** resource code */

		 resourceCode: IResourceCode;
/** resource pool */

		 resourcePool: IResourcePool;
/** resource handle */

		 resourceHandle:  number ;
/** resource flags */

		 resourceFlags:  number ;
/** Проверка был ли изменен ресур после загрузки */

		 alteredFlag: bool;

		 manager: IResourcePoolManager;



/** Get current Engine. */

		getEngine(): IEngine;
		getManager(): IResourcePoolManager;

/** Инициализация ресурса, вызывается один раз. Виртуальная. */

		createResource(): bool;
/** Уничтожение ресурса. Виртуальная. */

		destroyResource(): bool;
/**  Удаление ресурса из энергозависимой памяти. Виртуальная. */

		disableResource(): bool;
/** Возвращение ресурса в энегрозависимю память. Виртуальная. */

		restoreResource(): bool;

/** Загрузка ресурса из файла, или null при использовании имени ресурса. Виртуальная. */

		loadResource(sFilename?: string): bool;
/** Сохранение ресурса в файл, или null при использовании имени ресурса. */

		saveResource(sFilename?: string): bool;

/** Добавление и удаление функции, которая будет вызываться при изменении состояния ресурса( fnFunc(iNewSost,iOldSost) ) */

		setChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void;
		delChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void;

		setStateWatcher(eEvent: EResourceItemEvents, fnWatcher: IResourceWatcherFunc): void;

/** sinchronize events with other resourse */

//sync(pResourceItem: IResourcePoolItem, sSignal: string, sSlot?: string): bool;
		sync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool;

//unsync(pResourceItem: IResourcePoolItem, sSignal: string, sSlot?: string): bool;
		unsync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool;

/** Установка состояния в созданный */

		notifyCreated(): void;
/** Установка в состояние не созданный */

		notifyDestroyed(): void;
/** Уставнок�� в состояние загруженный */

		notifyLoaded(): void;
/** Уставнока в состояние незагруженный */

		notifyUnloaded(): void;
/** Установка в состояние используемый */

		notifyRestored(): void;
/** Установка в состояние не используемый */

		notifyDisabled(): void;
/** Установка в состояние не используемый */

		notifyAltered(): void;
/** Установка в состояние сохраненый */

		notifySaved(): void;

		notifyStateChange(eEvent: EResourceItemEvents, pTarget?: IResourcePoolItem);

/** Проверка создан ли ресурс */

		isResourceCreated(): bool;
/** Проверка загружен ли ресурс */

		isResourceLoaded(): bool;
/** Проверка активен ли ресурс */

		isResourceDisabled(): bool;
/** Проверка обновлен ли ресурс */

		isResourceAltered(): bool;

/** Установка состояния в изменен после загружки */

		setAlteredFlag(isOn?: bool): bool;

/** Пиписывание ресурсу имени */

		setResourceName(sName: string);

/** Поиск имени ресурса */

		findResourceName(): string;

/** оповещение о уменьшении количесва ссылок на ресурс */

		release():  number ;

		setResourceCode(pCode: IResourceCode): void;
		setResourcePool(pPool: IResourcePool): void;
		setResourceHandle(iHandle:  number ): void;

		setResourceFlag(eFlagBit: EResourceItemEvents, isSetting: bool): bool;
		setResourceFlag(iFlagBit:  number , isSetting: bool): bool;

		 created(): void;
		 destroyed(): void;
		 loaded(): void;
		 unloaded(): void;
		 restored(): void;
		 disabled(): void;
		 altered(): void;
		 saved(): void;

	}

	export interface IResourcePoolItemType {
		new (pManager: IResourcePoolManager): IResourcePoolItem;
	}
}















module akra {

    export enum EAFXInstructionTypes {
        k_Instruction = 0,
        k_InstructionCollector,
        k_SimpleInstruction,
        k_VariableTypeInstruction,
        k_SystemTypeInstruction,
        k_ComplexTypeInstruction,
        k_TypedInstruction,
        k_DeclInstruction,
        k_IntInstruction,
        k_FloatInstruction,
        k_BoolInstruction,
        k_StringInstruction,
        k_IdInstruction,
        k_KeywordInstruction,
        k_TypeDeclInstruction,
        k_VariableDeclInstruction,
        k_AnnotationInstruction,
        k_UsageTypeInstruction,
        k_BaseTypeInstruction,
        k_StructDeclInstruction,
        k_StructFieldsInstruction,
        k_ExprInstruction,
        k_IdExprInstruction,
        k_ArithmeticExprInstruction,
        k_AssignmentExprInstruction,
        k_RelationalExprInstruction,
        k_LogicalExprInstruction,
        k_ConditionalExprInstruction,
        k_CastExprInstruction,
        k_UnaryExprInstruction,
        k_PostfixIndexInstruction,
        k_PostfixPointInstruction,
        k_PostfixArithmeticInstruction,
        k_PrimaryExprInstruction,
        k_ComplexExprInstruction,
        k_FunctionCallInstruction,
        k_SystemCallInstruction,
        k_ConstructorCallInstruction,
        k_CompileExprInstruction,
        k_InitExprInstruction,
        k_SamplerStateBlockInstruction,
        k_SamplerStateInstruction,
        k_ExtractExprInstruction,
        k_MemExprInstruction,
        k_FunctionDeclInstruction,
        k_ShaderFunctionInstruction,
        k_SystemFunctionInstruction,
        k_FunctionDefInstruction,
        k_StmtInstruction,
        k_StmtBlockInstruction,
        k_ExprStmtInstruction,
        k_BreakStmtInstruction,
        k_WhileStmtInstruction,
        k_ForStmtInstruction,
        k_IfStmtInstruction,
        k_DeclStmtInstruction,
        k_ReturnStmtInstruction,
        k_ExtractStmtInstruction,
        k_SemicolonStmtInstruction,
        k_PassInstruction,
        k_TechniqueInstruction
    }

    export enum EFunctionType{
        k_Vertex,
        k_Pixel,
        k_Fragment = k_Pixel,
        k_Function,
        k_PassFunction
    }

    export enum ECheckStage {
/* Отсутсвуют конструкции не поддерживаемые языком назначения (GLSL) */
        CODE_TARGET_SUPPORT,
/* Код замкнут, нет не определенных функций, пассов, техник. Нет мертвых функций. */
        SELF_CONTAINED
// VALIDATION  /* Код не содерит синтаксиески неправильных выражений, то что не исчерпывается */ 
    }

    export enum EVarUsedMode {
        k_Read,
        k_Write,
        k_ReadWrite,
        k_Undefined,
        k_Default = k_ReadWrite
    }

    export interface IAFXInstructionStateMap extends StringMap{
	}

	export interface IAFXInstructionRoutine {
		(): void;
	}

    export interface IAFXInstructionError {
        code:  number ;
        info: any;
    }

    export interface IAFXInstructionMap {
        [index:  number ]: IAFXInstruction;
    }

    export interface IAFXSimpleInstructionMap {
        [index: string]: IAFXSimpleInstruction;
        [index:  number ]: IAFXSimpleInstruction;
    }

    export interface IAFXIdExprMap {
        [index: string]: IAFXIdExprInstruction;
    }

    export interface IAFXVariableTypeMap {
        [index: string]: IAFXVariableTypeInstruction;
        [index:  number ]: IAFXVariableTypeInstruction;
    }

    export interface IAFXTypeMap {
        [index: string]: IAFXTypeInstruction;
        [index:  number ]: IAFXTypeInstruction;
    }

    export interface IAFXTypeListMap {
        [index: string] : IAFXTypeInstruction[];
        [index:  number ] : IAFXTypeInstruction[];
    }

    export interface IAFXTypeDeclMap {
        [index: string] : IAFXTypeDeclInstruction;
        [index:  number ] : IAFXTypeDeclInstruction;
    }

    export interface IAFXVariableDeclMap {
        [index:  number ]: IAFXVariableDeclInstruction;
        [index: string]: IAFXVariableDeclInstruction;
    }

    export interface IAFXVariableDeclListMap {
        [index:  number ]: IAFXVariableDeclInstruction[];
        [index: string]: IAFXVariableDeclInstruction[];
    }

    export interface IAFXVarUsedModeMap {
        [index: string]: EVarUsedMode;
    }

    export interface IAFXFunctionDeclMap {
        [index: string]: IAFXFunctionDeclInstruction;
        [index:  number ]: IAFXFunctionDeclInstruction;
    }

    export interface IAFXTypeUseInfoContainer {
        type: IAFXVariableTypeInstruction;
        isRead: bool;
        isWrite: bool;
        numRead:  number ;
        numWrite:  number ;
        numUsed:  number ;
    }

    export interface IAFXTypeUseInfoMap {
        [index:  number ]: IAFXTypeUseInfoContainer;
    }

    export enum EExtractExprType {
        k_Header,

        k_Float,
        k_Int,
        k_Bool,

        k_Float2,
        k_Int2,
        k_Bool2,

        k_Float3,
        k_Int3,
        k_Bool3,

        k_Float4,
        k_Int4,
        k_Bool4,

        k_Float4x4
    }

    export enum EAFXBlendMode {
        k_Shared,
        k_Uniform,
        k_Attribute,
        k_Foreign,
        k_Global,
        k_Varying,
        k_TypeDecl,
        k_VertexOut
    }

/**
	 * All opertion are represented by: 
	 * operator : arg1 ... argn
	 * Operator and instructions may be empty.
	 */

	export interface IAFXInstruction extends IUnique {
        setParent(pParent: IAFXInstruction): void;
        getParent(): IAFXInstruction;

        setOperator(sOperator: string): void;
        getOperator(): string;

        setInstructions(pInstructionList: IAFXInstruction[]): void;
        getInstructions(): IAFXInstruction[];

        _getInstructionType(): EAFXInstructionTypes;
        _getInstructionID():  number ;
        _getScope():  number ;
        _setScope(iScope:  number ): void;
        _isInGlobalScope(): bool;

        check(eStage: ECheckStage): bool;
        getLastError(): IAFXInstructionError;
        setError(eCode:  number , pInfo?: any): void;
        clearError(): void;
        isErrorOccured(): bool;

        setVisible(isVisible: bool): void;
        isVisible(): bool;

        initEmptyInstructions(): void;

// /**
//  * Contain states of instruction
//  */
// stateMap: IAFXInstructionStateMap;

    	push(pInstruction: IAFXInstruction, isSetParent?: bool): void;

// changeState(sStateName: string, sValue: string): void;
// changeState(iStateIndex: int, sValue: string): void;

// stateChange(): void;
// isStateChange(): bool;

    	addRoutine(fnRoutine: IAFXInstructionRoutine, iPriority?:  number );
        prepareFor(eUsedType: EFunctionType): void;

    	toString(): string;
        toFinalCode(): string;

        clone(pRelationMap?: IAFXInstructionMap): IAFXInstruction;
    }

    export interface IAFXSimpleInstruction extends IAFXInstruction {
        setValue(sValue: string): void;
        isValue(sValue: string): bool;
    }

    export interface IAFXTypeInstruction extends IAFXInstruction {
        _toDeclString(): string;

        isBuiltIn(): bool;
        setBuiltIn(isBuiltIn: bool): void;

/**
         * Simple tests
         */

        isBase(): bool;
        isArray(): bool;
        isNotBaseArray(): bool;
        isComplex(): bool;
        isEqual(pType: IAFXTypeInstruction): bool;
        isStrongEqual(pType: IAFXTypeInstruction): bool;
        isConst(): bool;

        isSampler(): bool;

        isWritable(): bool;
        isReadable(): bool;

        _containArray(): bool;
        _containSampler(): bool;
        _containPointer(): bool;
        _containComplexType(): bool;
/**
         * Set private params
         */

        setName(sName: string): void;
        _canWrite(isWritable: bool): void;
        _canRead(isReadable: bool): void;

// markAsUsed(): void;

/**
         * get type info
         */

        getName(): string;
        getRealName(): string;
        getHash(): string;
        getStrongHash(): string;
        getSize():  number ;
        getBaseType(): IAFXTypeInstruction;
        getLength():  number ;
        getArrayElementType(): IAFXTypeInstruction;
        getTypeDecl(): IAFXTypeDeclInstruction;

// Fields

        hasField(sFieldName: string): bool;
        hasFieldWithSematic(sSemantic: string);
        hasAllUniqueSemantics(): bool;
        hasFieldWithoutSemantic(): bool;

        getField(sFieldName: string): IAFXVariableDeclInstruction;
        getFieldBySemantic(sSemantic: string): IAFXVariableDeclInstruction;
        getFieldType(sFieldName: string): IAFXVariableTypeInstruction;
        getFieldNameList(): string[];

/**
         * System
         */

        clone(pRelationMap?: IAFXInstructionMap): IAFXTypeInstruction;
        blend(pType: IAFXTypeInstruction, eMode: EAFXBlendMode): IAFXTypeInstruction;
    }

    export interface IAFXVariableTypeInstruction extends IAFXTypeInstruction {
/**
         * Simple tests
         */

        isPointer(): bool;
        isStrictPointer(): bool;
        isPointIndex(): bool;

        isFromVariableDecl(): bool;
        isFromTypeDecl(): bool;

        isUniform(): bool;
        isGlobal(): bool;
        isConst(): bool;
        isShared(): bool;
        isForeign(): bool;

        _isTypeOfField(): bool;
        _isUnverifiable(): bool;

// /**
//  * set type info
//  */
// _markUsedForWrite(): bool;
// _markUsedForRead(): bool;
// _goodForRead(): bool;

// _markAsField(): void;

/**
         * init api
         */

        setPadding(iPadding:  number ): void;
        pushType(pType: IAFXTypeInstruction): void;
        addUsage(sUsage: string): void;
        addArrayIndex(pExpr: IAFXExprInstruction): void;
        addPointIndex(isStrict?:bool): void;
        setVideoBuffer(pBuffer: IAFXVariableDeclInstruction): void;
        initializePointers(): void;

        _setPointerToStrict(): void;
        _addPointIndexInDepth(): void;
        _setVideoBufferInDepth(): void;
        _markAsUnverifiable(isUnverifiable: bool): void;

/**
         * Type info
         */

        getPadding():  number ;
        getArrayElementType(): IAFXVariableTypeInstruction;

        getUsageList(): string[];
        getSubType(): IAFXTypeInstruction;

        hasUsage(sUsageName: string): bool;
        hasVideoBuffer(): bool;

        getPointDim():  number ;
        getPointer(): IAFXVariableDeclInstruction;
        getVideoBuffer():IAFXVariableDeclInstruction;
        getFieldExpr(sFieldName: string): IAFXIdExprInstruction;
        getFieldIfExist(sFieldName: string): IAFXVariableDeclInstruction;

        getSubVarDecls(): IAFXVariableDeclInstruction[];

        _getFullName(): string;
        _getVarDeclName(): string;
        _getTypeDeclName(): string;

        _getParentVarDecl(): IAFXVariableDeclInstruction;
        _getParentContainer(): IAFXVariableDeclInstruction;
        _getMainVariable(): IAFXVariableDeclInstruction;

        _getMainPointer(): IAFXVariableDeclInstruction;
        _getUpPointer(): IAFXVariableDeclInstruction;
        _getDownPointer(): IAFXVariableDeclInstruction;

/**
         * System
         */

        wrap(): IAFXVariableTypeInstruction;
        clone(pRelationMap?: IAFXInstructionMap): IAFXVariableTypeInstruction;
        blend(pVariableType: IAFXVariableTypeInstruction, eMode: EAFXBlendMode): IAFXVariableTypeInstruction;

        _setCloneHash(sHash: string, sStrongHash: string): void;
        _setCloneArrayIndex(pElementType: IAFXVariableTypeInstruction,
                            pIndexExpr: IAFXExprInstruction, iLength:  number ): void;
        _setClonePointeIndexes(nDim:  number , pPointerList: IAFXVariableDeclInstruction[]): void;
        _setCloneFields(pFieldMap: IAFXVariableDeclMap): void;

        _setUpDownPointers(pUpPointer: IAFXVariableDeclInstruction,
                           pDownPointer: IAFXVariableDeclInstruction): void;
    }

    export interface IAFXTypedInstruction extends IAFXInstruction{
        getType(): IAFXTypeInstruction;
        setType(pType: IAFXTypeInstruction): void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXTypedInstruction;
    }

    export interface IAFXDeclInstruction extends IAFXTypedInstruction {
        setSemantic(sSemantic: string);
        setAnnotation(pAnnotation: IAFXAnnotationInstruction): void;
        getName(): string;
        getRealName(): string;
        getNameId(): IAFXIdInstruction;
        getSemantic(): string;

        isBuiltIn(): bool;
        setBuiltIn(isBuiltIn: bool): void;

        _isForAll(): bool;
        _isForPixel(): bool;
        _isForVertex(): bool;

        _setForAll(canUse: bool): void;
        _setForPixel(canUse: bool): void;
        _setForVertex(canUse: bool): void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXDeclInstruction;
    }

    export interface IAFXTypeDeclInstruction extends IAFXDeclInstruction {
        clone(pRelationMap?: IAFXInstructionMap): IAFXTypeDeclInstruction;
        blend(pDecl: IAFXTypeDeclInstruction, eBlendMode: EAFXBlendMode): IAFXTypeDeclInstruction;
    }

    export interface IAFXVariableDeclInstruction extends IAFXDeclInstruction {
        hasInitializer(): bool;
        getInitializeExpr(): IAFXInitExprInstruction;

        getDefaultValue(): any;

        getType(): IAFXVariableTypeInstruction;
        setType(pType: IAFXVariableTypeInstruction): void;

        isUniform(): bool;
        isField(): bool;
        isPointer(): bool;
        isVideoBuffer(): bool;
        isSampler(): bool;

        getSubVarDecls(): IAFXVariableDeclInstruction[];

        isDefinedByZero(): bool;
        defineByZero(isDefine: bool): void;

        _markAsShaderOutput(isShaderOutput: bool): void;
        _isShaderOutput(): bool;

        _getFullNameExpr(): IAFXExprInstruction;
        _getFullName(): string;
        _getVideoBufferSampler(): IAFXVariableDeclInstruction;
        _getVideoBufferHeader(): IAFXVariableDeclInstruction;

        setName(sName: string):void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXVariableDeclInstruction;
        blend(pVariableDecl: IAFXVariableDeclInstruction, eMode: EAFXBlendMode): IAFXVariableDeclInstruction;
    }

    export interface IAFXFunctionDeclInstruction extends IAFXDeclInstruction {
        toFinalDefCode(): string;

//getNameId(): IAFXIdInstruction;
        hasImplementation(): bool;
        getArguments(): IAFXTypedInstruction[];
        getNumNeededArguments():  number ;
        getReturnType(): IAFXVariableTypeInstruction;
        getFunctionType(): EFunctionType;
        setFunctionType(eType: EFunctionType): void;

        _getVertexShader(): IAFXFunctionDeclInstruction;
        _getPixelShader(): IAFXFunctionDeclInstruction;

// closeArguments(pArguments: IAFXInstruction[]): IAFXTypedInstruction[];
        setFunctionDef(pFunctionDef: IAFXDeclInstruction): void;
        setImplementation(pImplementation: IAFXStmtInstruction): void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXFunctionDeclInstruction;

//addUsedVariableType(pType: IAFXVariableTypeInstruction, eUsedMode: EVarUsedMode): bool;

        _addOutVariable(pVariable: IAFXVariableDeclInstruction): bool;
        _getOutVariable(): IAFXVariableDeclInstruction;

        _markUsedAs(eUsedType: EFunctionType): void;
        _isUsedAs(eUsedType: EFunctionType): bool;
        _isUsedAsFunction(): bool;
        _isUsedAsVertex(): bool;
        _isUsedAsPixel(): bool;
        _isUsed(): bool;
        _markUsedInVertex(): void;
        _markUsedInPixel(): void;
        _isUsedInVertex(): bool;
        _isUsedInPixel(): bool;
        _checkVertexUsage(): bool;
        _checkPixelUsage(): bool;

        _checkDefenitionForVertexUsage(): bool;
        _checkDefenitionForPixelUsage(): bool;

        _canUsedAsFunction(): bool;
        _notCanUsedAsFunction(): void;

        _addUsedFunction(pFunction: IAFXFunctionDeclInstruction): bool;
        _getUsedFunctionList(): IAFXFunctionDeclInstruction[];
        _addUsedVariable(pVariable: IAFXVariableDeclInstruction): void;

        _isBlackListFunction(): bool;
        _addToBlackList(): void;
        _getStringDef(): string;

        _convertToVertexShader(): IAFXFunctionDeclInstruction;
        _convertToPixelShader(): IAFXFunctionDeclInstruction;

        _prepareForVertex(): void;
        _prepareForPixel(): void;

        _generateInfoAboutUsedData(): void;

        _getAttributeVariableMap(): IAFXVariableDeclMap;
        _getVaryingVariableMap(): IAFXVariableDeclMap;

        _getSharedVariableMap(): IAFXVariableDeclMap;
        _getGlobalVariableMap(): IAFXVariableDeclMap;
        _getUniformVariableMap(): IAFXVariableDeclMap;
        _getForeignVariableMap(): IAFXVariableDeclMap;
        _getTextureVariableMap(): IAFXVariableDeclMap;
        _getUsedComplexTypeMap(): IAFXTypeMap;

        _getAttributeVariableKeys():  number [];
        _getVaryingVariableKeys():  number [];

        _getSharedVariableKeys():  number [];
        _getUniformVariableKeys():  number [];
        _getForeignVariableKeys():  number [];
        _getGlobalVariableKeys():  number [];
        _getUsedComplexTypeKeys():  number [];

        _getExtSystemFunctionList(): IAFXFunctionDeclInstruction[];
        _getExtSystemMacrosList(): IAFXSimpleInstruction[];
        _getExtSystemTypeList(): IAFXTypeDeclInstruction[];
    }

    export interface IAFXStructDeclInstruction extends IAFXInstruction {
//id: IAFXIdInstruction
//structFields: IAFXStructInstruction
    }

// export interface IAFXBaseTypeInstruction extends IAFXInstruction {
//     //id: IAFXIdInstruction
//     //...
// }

    export interface IAFXIdInstruction extends IAFXInstruction {
        getName(): string;
        getRealName(): string;

        setName(sName: string): void;
        setRealName(sName: string): void;

        clone(pRelationMap?: IAFXInstructionMap): IAFXIdInstruction;
    }

    export interface IAFXKeywordInstruction extends IAFXInstruction {
        setValue(sValue: string): void;
        isValue(sTestValue: string): bool;
    }

    export interface IAFXAnalyzedInstruction extends IAFXInstruction {
        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap, eUsedMode?: EVarUsedMode): void;
    }

    export interface IAFXExprInstruction extends IAFXTypedInstruction, IAFXAnalyzedInstruction {
        evaluate(): bool;
        simplify(): bool;
        getEvalValue(): any;
        isConst(): bool;
        getType(): IAFXVariableTypeInstruction;

        clone(pRelationMap?: IAFXInstructionMap): IAFXExprInstruction;
    }

    export interface IAFXInitExprInstruction extends IAFXExprInstruction {
        optimizeForVariableType(pType: IAFXVariableTypeInstruction): bool;
    }

    export interface IAFXIdExprInstruction extends IAFXExprInstruction {
        clone(pRelationMap?: IAFXInstructionMap): IAFXIdExprInstruction;
    }

    export interface IAFXLiteralInstruction extends IAFXExprInstruction {
        setValue(pValue: any): void;
        clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction;
    }

    export interface IAFXAnnotationInstruction extends IAFXInstruction{

    }

    export interface IAFXStmtInstruction extends IAFXInstruction, IAFXAnalyzedInstruction{
    }

    export interface IAFXPassInstruction extends IAFXDeclInstruction {
        _addFoundFunction(pNode: IParseNode, pShader: IAFXFunctionDeclInstruction, eType: EFunctionType): void;
        _getFoundedFunction(pNode: IParseNode): IAFXFunctionDeclInstruction;
        _getFoundedFunctionType(pNode: IParseNode): EFunctionType;
        _setParseNode(pNode: IParseNode): void;
        _getParseNode(): IParseNode;
        _markAsComplex(isComplex: bool): void;
        _addCodeFragment(sCode: string): void;

        _getSharedVariableMapV(): IAFXVariableDeclMap;
        _getGlobalVariableMapV(): IAFXVariableDeclMap;
        _getUniformVariableMapV(): IAFXVariableDeclMap;
        _getForeignVariableMapV(): IAFXVariableDeclMap;
        _getTextureVariableMapV(): IAFXVariableDeclMap;
        _getUsedComplexTypeMapV(): IAFXTypeMap;

        _getSharedVariableMapP(): IAFXVariableDeclMap;
        _getGlobalVariableMapP(): IAFXVariableDeclMap;
        _getUniformVariableMapP(): IAFXVariableDeclMap;
        _getForeignVariableMapP(): IAFXVariableDeclMap;
        _getTextureVariableMapP(): IAFXVariableDeclMap;
        _getUsedComplexTypeMapP(): IAFXTypeMap;

        _getFullUniformMap(): IAFXVariableDeclMap;
        _getFullForeignMap(): IAFXVariableDeclMap;
        _getFullTextureMap(): IAFXVariableDeclMap;


        getVertexShader(): IAFXFunctionDeclInstruction;
        getPixelShader(): IAFXFunctionDeclInstruction;

        addShader(pShader: IAFXFunctionDeclInstruction): void;
        setState(sType: string, sValue: string): void;
        finalizePass(): void;

        isComplexPass(): bool;
        evaluate(pEngineStates: any, pForeigns: any, pUniforms: any): bool;
    }

    export interface IAFXTechniqueInstruction extends IAFXDeclInstruction{
        setName(sName: string, isComplexName: bool): void;
        getName(): string;
        hasComplexName(): bool;

        addPass(pPass: IAFXPassInstruction): void;
        getPassList(): IAFXPassInstruction[];
        getPass(iPass:  number ): IAFXPassInstruction;

        totalOwnPasses():  number ;
        totalPasses():  number ;

        getSharedVariablesForVertex(): IAFXVariableDeclInstruction[];
        getSharedVariablesForPixel(): IAFXVariableDeclInstruction[];

        addComponent(pComponent: IAFXComponent, iShift:  number ): void;

        getComponentList(): IAFXComponent[];
        getComponentListShift():  number [];

        getFullComponentList(): IAFXComponent[];
        getFullComponentShiftList():  number [];

        checkForCorrectImports(): bool;
        finalizeTechnique(sProvideNameSpace: string,
                          pGloabalComponentList: IAFXComponent[],
                          pGloabalComponentShiftList:  number []): void;
    }

}



module akra {
	export interface IAFXComponentMap {
		[index:  number ]: IAFXComponent;
		[index: string]: IAFXComponent;
	}

	export interface IAFXComponent extends IResourcePoolItem {
		create(): void;

		getTechnique(): IAFXTechniqueInstruction;
		setTechnique(pTechnique: IAFXTechniqueInstruction): void;

		getName(): string;
		getTotalPasses():  number ;
		getHash(iShift:  number , iPass:  number ): string;

	}
}






module akra {

	export interface IAFXComponent {} ;

	export interface IEffect extends IResourcePoolItem {
		totalComponents:  number ;
		totalPasses:  number ;

		isEqual(pEffect: IEffect): bool;
		isReplicated(): bool;
		isMixid(): bool;
		isParameterUsed(pParam: any, iPass?:  number ): bool;

		replicable(bValue: bool): void;
		miscible(bValue: bool): void;

		addComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(sComponent: string, iShift?:  number , iPass?:  number , isSet?: bool): bool;

		delComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		delComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;

		activate(iShift?:  number ): bool;
		deactivate(): bool;

		findParameter(pParam: any, iPass?:  number ): any;
	}
}
















module akra {
	export interface IAFXPassInputBlend {
		uniforms: any;
		foreigns: any;
		textures: any;

		uniformKeys: string[];
		foreignKeys: string[];
		textureKeys: string[];

		uniformsDefault: any;

		setUniform(sName: string, pValue: any): void;
		setForeign(sName: string, pValue: any): void;
		setTexture(sName: string, pValue: any): void;

		setSamplerTexture(sName: string, pTexture: any): void;

		_init(): void;
		_release(): void;

		_isNeedToCalcBlend(): bool;
		_isNeedToCalcShader(): bool;

		_getLastPassBlendId():  number ;
		_getLastShaderId():  number ;

		_setPassBlendId(id:  number ): void;
		_setShaderId(id:  number ): void;
	}
}





module akra {

	export interface IAFXComponentBlendMap {
		[index:  number ]: IAFXComponentBlend;
		[index: string]: IAFXComponentBlend;
	}

	export interface IAFXComponentPassInputBlend {
		uniformNameToReal: StringMap;
		uniformByRealName: IAFXVariableDeclMap;
		uniformDefaultValue: any;

		textureNameToReal: StringMap;
		textureByRealName: any;

		foreignByName: IAFXVariableDeclMap;

		uniformNameList: string[];
		uniformRealNameList: string[];

		textureNameList: string[];
		textureRealNameList: string[];

		foreignNameList: string[];

		addDataFromPass(pPass: IAFXPassInstruction): void;
		generateKeys(): void;

		getPassInput(): IAFXPassInputBlend;
		releasePassInput(pPassInput: IAFXPassInputBlend): void;
	}

	export interface IAFXComponentBlend extends IUnique {
		isReadyToUse(): bool;
		isEmpty(): bool;

		getComponentCount():  number ;
		getTotalPasses():  number ;
		getHash(): string;

		containComponentWithShift(pComponent: IAFXComponent, iShift:  number , iPass:  number );
		containComponentHash(sComponentHash: string): bool;

		addComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): void;
		removeComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): void;

		finalizeBlend(): bool;

		getPassInputForPass(iPass:  number ): IAFXPassInputBlend;
		getPassListAtPass(iPass:  number ): IAFXPassInstruction[];

		clone(): IAFXComponentBlend;

		_getComponentList(): IAFXComponent[];
		_getComponentShiftList():  number [];
		_getComponentPassIdList():  number [];

		_setDataForClone(pComponentList: IAFXComponent[],
						 pComponentShiftList:  number [],
						 pComponentPassNumnerList:  number [],
						 pComponentHashMap: BoolMap,
						 nShiftMin:  number , nShiftMax:  number ): void;
	}
}








module akra {
	export interface IReferenceCounter {} ;
	export interface IVertexData {} ;
	export interface IDataMapper {} ;
	export interface IIndexData {} ;

	export enum EDataFlowTypes {
/*!< The data stream can be marked up its index.*/
        MAPPABLE   = 1,
/*!< The data stream cannot be marked up its index.*/
        UNMAPPABLE = 0
    };

    export interface IDataFlow {
    	flow:    number ;
        data:   IVertexData;
        type:   EDataFlowTypes;
        mapper: IDataMapper;
    }

    export interface IDataMapper {
    	data: IVertexData;
    	semantics: string;
    	addition:  number ;
    }

	export interface IBufferMap extends IReferenceCounter{
		primType: EPrimitiveTypes;
		index: IIndexData;
		length:  number ;

//FIXME: hack for terraing, for force limiting length of drawinf index.
/** writeonly */
		                 _length:  number ;

/** Number of primitives. */

		 primCount:  number ;
/** Maximum flow available in buffer map. */

		 limit:  number ;
/** Start index for drawning. */

		 startIndex:  number ;
/** Number of completed flows. */

		 size:  number ;
/** Completed flows. */

		 flows: IDataFlow[];
/** 
		 * Mappers. 
		 * @private
		 */

		 mappers: IDataMapper[];
/** 
		 * Offset in bytes for drawing with global idnex. 
		 * @deprecated
		 */

		 offset:  number ;

/**
		 * Find flow by semantics in.
		 * @param sSemantics VertexElement usage or semantics.
		 * @param {bool=} bComplete Find only in completed flows. Default is TRUE.
		 */

		getFlow(sSemantics: string, bComplete?: bool): IDataFlow;
		getFlow(iFlow:  number , bComplete?: bool): IDataFlow;
		reset(): void;

/**
		 * Add data to flow.
		 */

		flow(pVertexData: IVertexData):  number ;
		flow(iFlow:  number , pVertexData: IVertexData):  number ;
/**
		 * Add index for flow.
		 */

		mapping(iFlow:  number , pMap: IVertexData, sSemantics: string, iAddition?:  number ): bool;

/**
		 * Check, Is pData already used as flow or mapper.
		 */

		checkData(pData: IVertexData): bool;

/**
		 * Recals all statistics in buffer map.
		 */

		update(): bool;

		clone(bWithMapping?: bool): IBufferMap;

/**
		 * Draw buffer map.
		 */

		_draw(): void;

		toString(bListAll?: bool): string;
	}
}



module akra {
	export interface IAFXComposer {
		getComponentByName(sComponentName: string): IAFXComponent;
		getEngine(): IEngine;

//API for Effect-resource

		getComponentCountForEffect(pEffectResource: IEffect):  number ;
		getTotalPassesForEffect(pEffectResource: IEffect):  number ;
		addComponentToEffect(pEffectResource: IEffect,
							 pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;
		removeComponentFromEffect(pEffectResource: IEffect,
								  pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;

		activateEffectResource(pEffectResource: IEffect, iShift:  number ): bool;
		deactivateEffectResource(pEffectResource: IEffect): bool;

//API for RenderTechnique

		getTotalPassesForTechnique(pRenderTechnique: IRenderTechnique):  number ;

		addOwnComponentToTechnique(pRenderTechnique: IRenderTechnique,
								   pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;
		removeOwnComponentToTechnique(pRenderTechnique: IRenderTechnique,
									  pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool;

		prepareTechniqueBlend(pRenderTechnique: IRenderTechnique): bool;

		markTechniqueAsNeedUpdate(pRenderTechnique: IRenderTechnique): void;

		getPassInputBlend(pRenderTechnique: IRenderTechnique, iPass:  number ): IAFXPassInputBlend;

//API for render

		applyBufferMap(pBufferMap: IBufferMap): bool;

		setCurrentSceneObject(pSceneObject: ISceneObject): void;
		renderTechniquePass(pRenderTechnique: IRenderTechnique, iPass:  number ): void;

//API for load components/AFXEffects


		_loadEffectFromSyntaxTree(pTree: IParseTree, sFileName: string): bool;

		_loadEffectFromBinary(pData: Uint8Array, sFileName: string): bool;
	}
}
















module akra {

        export interface IEngine {} ;
        export interface IResourceCode {} ;
        export interface IResourcePoolItem {} ;
        export interface IResourcePoolManager {} ;

        export interface IResourcePool extends IEventProvider {
                iFourcc:  number ;
                 manager: IResourcePoolManager;

/** Добавление данного пула в менеджер ресурсво по его коду */

                registerResourcePool(pCode: IResourceCode): void;
/** Удаление данного пула в менеджер ресурсво по его коду */

                unregisterResourcePool(): void;
/** По имени ресурса возвращает его хендл */

                findResourceHandle(sName: string):  number ;
/** По хендлу ресурва возвращает его имя */

                findResourceName(iHandle:  number ): string;

/** set resource name */

                setResourceName(iHandle:  number , sName: string): void;

                initialize(iGrowSize:  number ): void;
                destroy(): void;
                clean(): void;

                destroyAll(): void;
                restoreAll(): void;
                disableAll(): void;

                isInitialized(): bool;

//callbackDestroy(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackDisable(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackRestore(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;
//callbackClean(pPool: IDataPool, iHandle: int, pResource: IResourcePoolItem): void;

                createResource(sResourceName: string): IResourcePoolItem;
                loadResource(sResourceName: string): IResourcePoolItem;
                saveResource(pResource: IResourcePoolItem): bool;
                destroyResource(pResource: IResourcePoolItem): void;

                findResource(sName: string): IResourcePoolItem;
                getResource(iHandle:  number ): IResourcePoolItem;
                getResources(): IResourcePoolItem[];

                 createdResource(pResource: IResourcePoolItem): void;
        }
}








module akra {

	export interface IResourcePoolItem {} ;

	export interface IResourceWatcherFunc {
		(nLoaded?:  number , nTotal?:  number , pTarget?: IResourcePoolItem): void;
	}
}













// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;

// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;

// getAnimationController(): IAnimationController;

// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;

// addNode(pNode: ISceneNode): void;

// addSkeleton(pSkeleton: ISkeleton): void;

// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;

// getRootNodes(): ISceneNode[];

// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;

// //instead old method: applyShadow();
// _setup(): bool;

// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;

module akra {
	export interface ISkeleton {} ;
	export interface IModel {} ;
	export interface IEngine {} ;
    export interface IColladaAsset {} ;
    export interface IMesh {} ;
    export interface IAnimationController {} ;

//=============================================
// COLLADA LOAD OPTIONS
//=============================================

    export interface ICollada extends IModel {
        getAsset(): IColladaAsset;
        getFilename(): string;
        getBasename(): string;

        isVisualSceneLoaded(): bool;
        isAnimationLoaded(): bool;

        attachToScene(pNode: ISceneNode, pController?: IAnimationController): bool;
        attachToScene(pScene: IScene3d, pController?: IAnimationController): bool;
    }

	export interface IColladaAnimationLoadOptions {
		pose?: bool;
	}

    export interface IColladaCache {
        meshMap: IMeshMap;
        sharedBuffer: IRenderDataCollection;
    }



	export interface IColladaLoadOptions {
/** Add nodes, that visualize joints in animated models. */

    	drawJoints?: bool;
/** Convert all meshed to wireframe. */

    	wireframe?: bool;
/** 
    	 * Use common buffer for all data 
    	 * @deprecated
    	 */

    	sharedBuffer?: bool;

    	animation?: IColladaAnimationLoadOptions;
    	scene?: bool;
    	extractPoses?: bool;
    	skeletons?: ISkeleton[];
    }

// xml

    export interface IXMLExplorer {
        (pXML: Element, sName?: string): void;
    }

//----------------------

    export interface IColladaTarget {
        value: number;
        object?: IColladaEntry;
        source?: IColladaEntry;
    }

    export interface IColladaEntry {
        id?: string;
        sid?: string;
        name?: string;
    }

    export interface IColladaEntryMap {
        [id: string]: IColladaEntry;
    }

    export interface IColladaLibrary extends IColladaEntry {
        [element: string]: IColladaEntryMap;
    }

    export interface IColladaEffectLibrary extends IColladaLibrary {
        effect: { [id: string]: IColladaEffect; };
    }

    export interface IColladaEntryLoader {
        (pXML: Element): IColladaEntry;
    }


    export interface IColladaUnknownFormat {
    	name: string[];
    	type: string[];
    }

/** Stride for collada formats, discretized at 32 bits. */

    export interface IColladaFormatStrideTable {
    	[format: string]:  number ;
    }

    export interface IColladaConverter {
    	(data: string, output: any[], from?:  number ):  number ;
    }

    export interface IColladaConvertionTableRow {
        type: any;
        converter: IColladaConverter;
    }

    export interface IColladaConvertionTable {
    	[type: string]: IColladaConvertionTableRow;
    }

    export interface IColladaLinkMap {
    	[link: string]: any;
    }

    export interface IColladaLibraryMap {
    	[library: string]: IColladaLibrary;
    }

    export interface IColladaLibraryTemplate {
/** library tag name.*/
    	lib: string;
/** element in liibrary. */
    	element: string;
/** loader function */
    	loader: string;
    }


//=============================================
// COLLADA NODES / VISUAL SCENE AND COMMON
//=============================================

    export interface IColladaArray extends IColladaEntry {
        [i:  number ]: any;
    }

    export interface IColladaUnit extends IColladaEntry {
        name: string;
        meter:  number ;
    }

    export interface IColladaContributor extends IColladaEntry {
        author: string;
        authoringTool: string;
        comments: string;
        copyright: string;
        sourceData: any;
    }

    export interface IColladaAsset extends IColladaEntry {
        unit: IColladaUnit;
        upAxis: string;
        title: string;
        created: string;
        modified: string;
        contributor: IColladaContributor;
    }

    export interface IColladaInstance extends IColladaEntry {
        url?: string;
    }

    export interface IColladaAnnotate extends IColladaEntry {
        name: string;
        value: string;
    }

    export interface IColladaNewParam extends IColladaEntry {
        sid: string;
        annotate: IColladaAnnotate;
        semantics: string;
        modifier: string;
        value: any;
        type: string;
    }

    export interface IColladaNewParamMap {
        [sid: string]: IColladaNewParam;
    }

    export interface IColladaParam extends IColladaEntry {
        name: string;
        type: string;
    }

    export interface IColladaAccessor extends IColladaEntry {
        data: IColladaArray;
        count:  number ;
        stride:  number ;
        params: IColladaParam[];
    }


    export interface IColladaTechniqueCommon extends IColladaEntry {
        accessor: IColladaAccessor;
    }


    export interface IColladaSource extends IColladaEntry {
        name: string;

        array: Object;
        techniqueCommon: IColladaTechniqueCommon;
    }

    export interface IColladaInput extends IColladaEntry {
        semantics: string;
        source: IColladaSource;
        offset:  number ;
        set: string;

        array?: any[];
//arrayId?: string;
        accessor?: IColladaAccessor;
    }

    export interface IColladaTransform extends IColladaEntry {
/* transform name: rotate, translate, scale or matrix */
        transform: string;
        value: any;
    }

    export interface IColladaRotate extends IColladaTransform {
        value: IVec4;
    }

    export interface IColladaTranslate extends IColladaTransform {
        value: IVec3;
    }

    export interface IColladaScale extends IColladaTransform {
        value: IVec3;
    }

    export interface IColladaMatrix extends IColladaTransform {
        value: IMat4;
    }

    export interface IColladaVertices extends IColladaEntry {
        inputs: { [semantics: string]: IColladaInput; };
    }

    export interface IColladaJoints extends IColladaEntry {
        inputs: { [input: string]: IColladaInput; };

    }

    export interface IColladaPolygons extends IColladaEntry {
        name: string;

        inputs: IColladaInput[];
        p:  number [];
        material: string;

        type?: EPrimitiveTypes;
    }

    export interface IColladaMesh extends IColladaEntry {
        sources: IColladaSource[];
        polygons: IColladaPolygons[];
    }

    export interface IColladaConvexMesh extends IColladaEntry {
//TODO: IColladaConvexMesh
    }

    export interface IColladaSpline extends IColladaEntry {
//TODO: IColladaSpline
    }

    export interface IColladaGeometrie extends IColladaEntry {
        name: string;

        mesh: IColladaMesh;
        convexMesh: IColladaConvexMesh;
        spline: IColladaSpline;
    }

    export interface IColladaMorph extends IColladaEntry {
//TODO: IColladaMorph
    }

    export interface IColladaVertexWeights extends IColladaEntry {
        count:  number ;
        inputs: IColladaInput[];
        weightInput: IColladaInput;
        vcount:  number [];
        v:  number [];
    }

    export interface IColladaSkin extends IColladaEntry {
        shapeMatrix: IMat4;
        sources: IColladaSource[];
        geometry: IColladaGeometrie;
        joints: IColladaJoints;
        vertexWeights: IColladaVertexWeights;
    }

    export interface IColladaController extends IColladaEntry {
        name: string;

        skin: IColladaSkin;
        morph: IColladaMorph;
    }

    export interface IColladaImage extends IColladaEntry {
        name: string;

        data: any;
        path: string;

        format?: string;
        depth?:  number ;
        height?:  number ;
        width?:  number ;
    }

//effects

    export interface IColladaSurface extends IColladaEntry {
        initFrom: string;
    }

    export interface IColladaSampler2D extends IColladaEntry {
        source: string;
        wrapS: string;
        wrapT: string;
        minFilter: string;
        mipFilter: string;
        magFilter: string;
    }

    export interface IColladaTexture extends IColladaEntry {
        texcoord: string;
        sampler: IColladaNewParam;
        surface: IColladaNewParam;
        image: IColladaImage;
    }


    export interface IColladaInstanceEffect extends IColladaInstance {
        parameters: Object;
        techniqueHint: StringMap;
        effect: IColladaEffect;
    }


    export interface IColladaPhong extends IColladaEntry {
        diffuse: IColorValue;
        specular: IColorValue;
        ambient: IColorValue;
        emissive: IColorValue;
        shininess:  number ;

        reflective: IColorValue;
        reflectivity:  number ;
        transparent: IColorValue;
        transparency:  number ;

        indexOfRefraction:  number ;

//------------------
        textures?: {
            diffuse: IColladaTexture;
            specular: IColladaTexture;
            ambient: IColladaTexture;
            emissive: IColladaTexture;
        };
    }

    export interface IColladaEffectTechnique extends IColladaEntry {
        sid: string;
        type: string;
        value: IColladaEntry;
    }

    export interface IColladaProfileCommon extends IColladaEntry {
        technique: IColladaEffectTechnique;
        newParam: IColladaNewParamMap;
    }

    export interface IColladaEffect extends IColladaEntry {
        profileCommon: IColladaProfileCommon;
    }

// materials

    export interface IColladaMaterial extends IColladaEntry {
        name: string;

        instanceEffect: IColladaInstanceEffect;
    }



    export interface IColladaTechniqueValue extends IColladaEntry {

    }


    export interface IColladaBindVertexInput extends IColladaEntry {
        semantics: string;
        inputSemantic: string;
        inputSet:  number ;
    }

    export interface IColladaBindVertexInputMap {
        [semantics: string]: IColladaBindVertexInput;
    }

    export interface IColladaInstanceMaterial extends IColladaInstance {
        symbol: string;
        target: string;
        vertexInput: IColladaBindVertexInputMap;
        material: IColladaMaterial;
    }

    export interface IColladaBindMaterial extends IColladaEntry {
        [symbol: string]: IColladaInstanceMaterial;
    }

    export interface IColladaInstanceGeometry extends IColladaInstance {
        geometry: IColladaGeometrie;
        material: IColladaBindMaterial;
    }


    export interface IColladaInstanceController extends IColladaInstance {
        controller: IColladaController;
        material: IColladaBindMaterial;
        skeletons: string[];
    }

    export interface IColladaNode extends IColladaEntry {
        sid: string;
        name: string;
        type: string;
        layer: string;

        transform: IMat4;
        geometry: IColladaInstanceGeometry[];
        controller: IColladaInstanceController[];

        childNodes: IColladaNode[];
        depth:  number ;
        transforms: IColladaTransform[];

        constructedNode: ISceneNode;
    }

    export interface IColladaVisualScene extends IColladaEntry {
        name: string;

        nodes: IColladaNode[];
    }



/// animation

    export interface IColladaAnimationSampler extends IColladaEntry {
        inputs: { [semantics: string]: IColladaInput; };
    }

    export interface IColladaAnimationChannel extends IColladaEntry {
        target: IColladaTarget;
        sampler: IColladaAnimationSampler;
    }

    export interface IColladaAnimation extends IColladaEntry {
        name: string;

        sources: IColladaSource[];
        samplers: IColladaAnimationSampler[];
        channels: IColladaAnimationChannel[];

        animation: IColladaAnimation[];
    }


    export interface IColladaScene {

    }

    export interface IColladaFile {
        asset?: IColladaAsset;

        libEffects: IColladaEffectLibrary;
        libMaterials: IColladaLibrary;
        libGeometries: IColladaLibrary;
        libVisualScenes: IColladaLibrary;

        scene: IColladaScene;
    }


}



module akra {
    export interface IAnimationBase {} ;
    export interface IAnimationBaseController {} ;
    export interface IColladaLoadOptions {} ;
    export interface ISceneNode {} ;
    export interface IScene3d {} ;
    export interface ISkeleton {} ;
    export interface IMesh {} ;


    export interface IModel extends IResourcePoolItem {

        loadResource(sFilename?: string, pOptions?: IColladaLoadOptions): bool;
        attachToScene(pNode: ISceneNode): bool;
        attachToScene(pScene: IScene3d): bool;
    }
}



// totalAnimations: uint;
// totalMeshes: uint;
// node: ISceneNode;

// getAnimation(iAnim: uint): IAnimationBase;
// setAnimation(iAnim: uint, pAnimation: IAnimationBase): void;
// addAnimation(pAnimation: IAnimationBase): void;

// getAnimationController(): IAnimationController;

// getMesh(iMesh: uint): IMesh;
// addMesh(pMesh: IMesh): void;

// addNode(pNode: ISceneNode): void;

// addSkeleton(pSkeleton: ISkeleton): void;

// addToScene(pScene: IScene3d): bool;
//    attachToScene(pNode: ISceneNode): bool;

// getRootNodes(): ISceneNode[];

// loadResource(sFilename?: string, pOptions?: IColladaLoadOptions, fnCallback?: (pModel: IModel) => void): bool;
// loadAnimation(sFilename: string): bool;

// //instead old method: applyShadow();
// _setup(): bool;

// _notifyFileLoaded(): uint;
// _notifyFileLoad(): uint;
// _totalFiles(): uint;











module akra {
	export enum EResourceCodes {
		INVALID_CODE = 0xFFFFFFFF
	};

	export interface IResourceCode {
		family:  number ;
		type:  number ;
/** Пеерводит текущее состояние идентифиакора в невалидное */

		setInvalid(): void;
/** operator "<" */

		less(pSrc: IResourceCode): bool;
/** operator = */

		eq(pSrc: IResourceCode): IResourceCode;

		valueOf():  number ;
		toNumber():  number ;
	}
}



module akra.core.pool {
	export class ResourceCode implements IResourceCode {
		private iValue:  number  = <number>(EResourceCodes.INVALID_CODE);

		get family():  number  {
			return this.iValue >> 16;
		}

		set family(iNewFamily:  number ) {
			this.iValue &= 0x0000FFFF;
	        this.iValue |= iNewFamily << 16;
		}

		get type():  number  {
			return this.iValue & 0x0000FFFF;
		}

		set type(iNewType:  number ) {
			this.iValue &= 0xFFFF0000;
            this.iValue |= iNewType & 0x0000FFFF;
		}

		constructor ();
		constructor(iCode:  number );
		constructor(eCode: EResourceCodes);
		constructor(pCode: IResourceCode);
		constructor(iFamily:  number , iType:  number );
		constructor (iFamily?, iType?) {
			switch (arguments.length) {
		        case 0:
		            this.iValue = <number>EResourceCodes.INVALID_CODE;
		            break;
		        case 1:
		            if (arguments[0] instanceof ResourceCode) {
		                this.iValue = arguments[0].iValue;
		            }
		            else {
		                this.iValue = arguments[0];
		            }
		            break;
		        case 2:
		            this.family = arguments[0];
		            this.type = arguments[1];
		            break;
		    }
		}

		setInvalid(): void {
		    this.iValue = <number>EResourceCodes.INVALID_CODE;
		}

		less (pSrc: IResourceCode): bool {
		    return this.iValue < pSrc.valueOf();
		}

		eq(pSrc: IResourceCode): IResourceCode {
		    this.iValue = pSrc.valueOf();
		    return this;
		};

		valueOf():  number  {
		    return this.iValue;
		};

		toNumber():  number  {
			return this.iValue;
		}
	}


}
















module akra {

	export interface IEngine {} ;
	export interface IResourcePoolManager {} ;

	export interface IDataPool {
		manager: IResourcePoolManager;
/** Инициализация пула данных */

		initialize(iGrowSize:  number ): void;

/** Инициализирован ли пул */

		isInitialized(): bool;

/** Очистка пула и пометка о том что он больш не инициализирован */

		destroy(): void;

/** Высвобождаем элемент в пуле по его номеру */

		release(iHandle:  number ): void;
/*
		 * даление всех групп
 		 * Все группы должны быть пусты, иначе во время удаления произойдет ошибка
		 **/

		clear(): void;
/** Добавляет новый элемент в пул */

		add(pMembers: IResourcePoolItem):  number ;

/** Цикл по всем объектам с приминением к ним функции, как fFunction(текущий пул данных, объект к торому применяется); */

		forEach(fFunction: (pPool: IDataPool, iHandle:  number , pMember: IResourcePoolItem) => void): void;

/** Ищет первый свободный элемент в пуле */

		nextHandle():  number ;
/** Проверяется используется лм этот элемент */

		isHandleValid(iHandle:  number ): bool;

/** Возвратитть элемент по хендлу */

		get(iHandle:  number ): IResourcePoolItem;
/** Возвратитть элемент по хендлу */

		getPtr(iHandle:  number ): IResourcePoolItem;
/** Возвратитть элемент по хендлу */

		getGenericPtr(iHandle:  number ): IResourcePoolItem;
	}
}













module akra.util {
	export class ReferenceCounter implements IReferenceCounter {
		private nReferenceCount:  number  = 0;

/** Выстанавливает чило ссылок  на объект в ноль */

		constructor ();
/** 
		 * Выстанавливает чило ссылок  на объект в ноль
 		 * количесвто ссылок привязаны к конкретному экземпляру, поэтому никогда не копируются 
 		 */

		constructor (pSrc: IReferenceCounter);
		constructor (pSrc?) {}

/** @inline */

		referenceCount():  number  {
			return this.nReferenceCount;
		}

/** @inline */

		destructor(): void {
			logger.setSourceLocation( "util/ReferenceCounter.ts" , 26 ); logger.assert(this.nReferenceCount === 0, 'object is used'); ;
		}

		release():  number  {
			logger.setSourceLocation( "util/ReferenceCounter.ts" , 30 ); logger.assert(this.nReferenceCount > 0, 'object is used'); ;
		    this.nReferenceCount--;
		    return this.nReferenceCount;
		}

		addRef():  number  {
			logger.setSourceLocation( "util/ReferenceCounter.ts" , 36 ); logger.assert(this.nReferenceCount != MIN_INT32, 'reference fail'); ;

    		this.nReferenceCount ++;

			return this.nReferenceCount;
		}

/** @inline */

		eq (pSrc: IReferenceCounter): IReferenceCounter {
		    return this;
		};
	}
}










module akra {
	export interface IEventSlot {
		target: any;
		callback: string;
		listener: Function;
	}

	export interface IEventSlotListMap {
		[index: string]: IEventSlot[];
	}
	export interface IEventSlotMap {
		[index: string]: IEventSlot;
	}

	export interface IEventSlotTable {
		[index: number]: IEventSlotListMap;
		[index: string]: IEventSlotListMap;
	}

	export interface IEventSlotList {
		[index: number]: IEventSlotMap;
		[index: string]: IEventSlotMap;
	}

	export interface IEventTable {
		broadcast: IEventSlotTable;
		unicast: IEventSlotList;

		addDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType?: EEventTypes): bool;
		removeDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType?: EEventTypes): bool;
		addListener(iGuid:  number , sSignal: string, fnListener: Function, eType?: EEventTypes): bool;
		removeListener(iGuid:  number , sSignal: string, fnListener?: Function, eType?: EEventTypes): bool;

		findUnicastList(iGuid:  number ): IEventSlotMap;
		findBroadcastList(iGuid:  number ): IEventSlotListMap;
	}
}

















/*console.error(this.getEventTable());*/











/**event, signal, slot*/


/**event, signal, slot*/









//#define END_EVENT_TABLE()

module akra.events {
	export class EventTable implements IEventTable {
		broadcast: IEventSlotTable = <IEventSlotTable>{};
		unicast: IEventSlotList = <IEventSlotList>{};

		addDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
// console.log("add destination(", iGuid, "):: ", "target: ", pTarget, "slot: ", sSlot);
//TODO: проверить, что объект уже добавлен с этим колбеом
				this.findBroadcastSignalMap(iGuid, sSignal).push({target: pTarget, callback: sSlot, listener: null});
				return true;
			}
			else {
				this.unicast[iGuid] = this.unicast[iGuid] || {};
//console.log(iGuid, sSignal, pTarget, sSlot, eType);
//console.warn(this.unicast);
				if (!isDef(this.unicast[iGuid][sSignal])) {
					this.unicast[iGuid][sSignal] = {target: pTarget, callback: sSlot, listener: null};
					return true;
				}
			}
			return false;
		}

		removeDestination(iGuid:  number , sSignal: string, pTarget: IEventProvider, sSlot: string, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
				var pList: IEventSlot[] = this.findBroadcastSignalMap(iGuid, sSignal);
				for (var i:  number  = 0; i < pList.length; ++ i) {
					if (pList[i].target === pTarget && pList[i].callback === sSlot) {
						pList.splice(i, 1);
						return true;
					}
				}
			}
			else {
				if (this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
					delete this.unicast[iGuid][sSignal];
					return true;
				}
			}
			logger.setSourceLocation( "events/events.ts" , 112 ); logger.warning("cannot remove destination for GUID <%s> with signal <%s>", iGuid, sSignal); ;
			return false;
		}

		addListener(iGuid:  number , sSignal: string, fnListener: Function, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
// console.log("add listener(", iGuid, "):: ", "listener: ", fnListener, "signal: ", sSignal);
				this.findBroadcastSignalMap(iGuid, sSignal).push({target: null, callback: null, listener: fnListener});
				return true;
			}
			else {
				this.unicast[iGuid] = this.unicast[iGuid] || {};
				if (!isDef(this.unicast[iGuid][sSignal])) {
					this.unicast[iGuid][sSignal] = {target: null, callback: null, listener: fnListener};
					return true;
				}
			}
			logger.setSourceLocation( "events/events.ts" , 129 ); logger.warning("cannot add listener for GUID <%s> with signal <%s>", iGuid, sSignal); ;
			return false;
		}

		removeListener(iGuid:  number , sSignal: string, fnListener?: Function, eType: EEventTypes = EEventTypes.BROADCAST): bool {
			if (eType === EEventTypes.BROADCAST) {
				var pList: IEventSlot[] = this.findBroadcastSignalMap(iGuid, sSignal);
				for (var i:  number  = 0; i < pList.length; ++ i) {
					if (pList[i].listener === fnListener) {
						pList.splice(i, 1);
						return true;
					}
				}
			}
			else {
				if (this.unicast[iGuid] && this.unicast[iGuid][sSignal]) {
					delete this.unicast[iGuid][sSignal];
					return true;
				}
			}
			return false;
		}

		inline findBroadcastList(iGuid:  number ): IEventSlotListMap {
			return (this.broadcast[iGuid] = this.broadcast[iGuid] || {});
		}

		findUnicastList(iGuid:  number ): IEventSlotMap {
//console.error(iGuid,this.unicast[iGuid]);

			this.unicast[iGuid] = this.unicast[iGuid] || {};
			return this.unicast[iGuid];
		}

		private findBroadcastSignalMap(iGuid:  number , sSignal: string): IEventSlot[] {
			this.broadcast[iGuid] = this.broadcast[iGuid] || {};
			this.broadcast[iGuid][sSignal] = this.broadcast[iGuid][sSignal] || [];
			return this.broadcast[iGuid][sSignal];
		}
	}


	export class EventProvider implements IEventProvider {
		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return EventProvider._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
	}
}




module akra.core.pool {
    export class ResourcePool extends util.ReferenceCounter implements IResourcePool {
        private pManager: IResourcePoolManager = null;
/** Конструктор для создания данных в пуле ресурсов */

        private tTemplate: IResourcePoolItemType = null;
        private sExt: string = null;
        private pRegistrationCode: IResourceCode = new ResourceCode(EResourceCodes.INVALID_CODE);
/*{[index: number]: string;}*/
        private pNameMap: string[]                               = new Array();
        private pDataPool: IDataPool = null;


        inline get iFourcc():  number  {
            return (this.sExt.charCodeAt(3) << 24)
                      | (this.sExt.charCodeAt(2) << 16)
                      | (this.sExt.charCodeAt(1) << 8)
                      | (this.sExt.charCodeAt(0));
        }



        set iFourcc(iNewFourcc:  number ) {
            this.sExt = String.fromCharCode((iNewFourcc & 0x000000FF),
                                             (iNewFourcc & 0x0000FF00) >>> 8,
                                             (iNewFourcc & 0x00FF0000) >>> 16,
                                             (iNewFourcc & 0xFF000000) >>> 24);
        }

        inline get manager(): IResourcePoolManager {
            return this.pManager;
        }

        constructor (pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType) {
            super();

            this.pManager = pManager;
            this.tTemplate = tTemplate;
            this.pDataPool = new DataPool(this.pManager, tTemplate);
        }

/** Добавление данного пула в менеджер ресурсво по его коду */

        registerResourcePool(pCode: IResourceCode): void {
            this.pRegistrationCode.eq(pCode);
            this.pManager.registerResourcePool(this.pRegistrationCode, this);
        }

/** Удаление данного пула в менеджер ресурсво по его коду */

        unregisterResourcePool(): void {
            this.pManager.unregisterResourcePool(this.pRegistrationCode);
            this.pRegistrationCode.setInvalid();
        }

/** По имени ресурса возвращает его хендл */

        findResourceHandle(sName: string):  number  {
// look up the name in our map
            var iNewHandle = INVALID_INDEX;

            for (var iHandle:  number  = 0; iHandle < this.pNameMap.length; ++ iHandle) {
                if (this.pNameMap[iHandle] === sName) {
                    return iHandle;
                }
            }

            return iNewHandle;
        }

/** 
         * Get resource name by handle.
         * @inline
         */

        findResourceName(iHandle:  number ): string {
            return this.pNameMap[iHandle];
        }

        setResourceName(iHandle:  number , sName: string): void {
            this.pNameMap[iHandle] = sName;
        }


        initialize(iGrowSize:  number ): void {
            this.pDataPool.initialize(iGrowSize);
        }

/** @inline */

        destroy(): void {
            this.pDataPool.destroy();
        }


        clean(): void {
            this.pDataPool.forEach(ResourcePool.callbackClean);
        }

        destroyAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackDestroy);
        }

        restoreAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackRestore);
        }

        disableAll(): void {
            this.pDataPool.forEach(ResourcePool.callbackDisable);
        }

/** @inline */

        isInitialized(): bool {
            return this.pDataPool.isInitialized();
        }



        createResource(sResourceName: string): IResourcePoolItem {
            var iHandle:  number  = this.internalCreateResource(sResourceName);

            if (iHandle !== INVALID_INDEX) {
                var pResource: IResourcePoolItem = this.getResource(iHandle);

                pResource.setResourcePool(this);
                pResource.setResourceHandle(iHandle);
                pResource.setResourceCode(this.pRegistrationCode);

                this.createdResource(pResource);

                return pResource;
            }

            return null;
        }

        loadResource(sResourceName: string): IResourcePoolItem {
// does the resource already exist?
            var pResource: IResourcePoolItem = this.findResource(sResourceName);

            if (pResource == null) {
// create a new resource
                pResource = this.createResource(sResourceName);

                if (pResource != null) {
// attempt to load the desired data
                    if (pResource.loadResource(sResourceName)) {
// ok!
                        return pResource;
                    }

// loading failed.
// destroy the resource we created
// destroyResource(pResource);
                    pResource.release();
                    pResource = null;
                }

            }

            return pResource;
        }

        saveResource(pResource: IResourcePoolItem): bool {
            if (pResource != null) {
// save the resource using it's own name as the file path
                return pResource.saveResource();
            }
            return false;
        }

        destroyResource(pResource: IResourcePoolItem): void {
            if (pResource != null) {
                var iReferenceCount:  number  = pResource.referenceCount();

                logger.setSourceLocation( "ResourcePool.ts" , 181 ); logger.assert(iReferenceCount == 0, "destruction of non-zero reference count!"); ;

                if (iReferenceCount <= 0) {
                    var iHandle:  number  = pResource.resourceHandle;
                    this.internalDestroyResource(iHandle);
                }
            }
        }

        findResource(sName: string): IResourcePoolItem {

// look up the name in our map
            for (var iHandle:  number  = 0; iHandle < this.pNameMap.length; ++ iHandle) {
                if (this.pNameMap[iHandle] == sName) {
                    if (iHandle != INVALID_INDEX) {
                        var pResource = this.getResource(iHandle);
                        return pResource;
                    }
                }
            }

            return null;
        }

        getResource(iHandle:  number ): IResourcePoolItem {
            var pResource: IResourcePoolItem = this.internalGetResource(iHandle);

            if (pResource != null) {
                pResource.addRef();
            }

            return pResource;
        }

        getResources(): IResourcePoolItem[] {
            var pResources: IResourcePoolItem[] = [];

            for (var iHandleResource in this.pNameMap) {
                pResources.push(this.getResource(parseInt(iHandleResource)));
            }

            return pResources;
        }


        private internalGetResource(iHandle:  number ): IResourcePoolItem {
            return this.pDataPool.getPtr(iHandle);
        }

        private internalDestroyResource(iHandle:  number ): void {
// get a pointer to the resource and call it's destruction handler
            var pResource = this.pDataPool.getPtr(iHandle);

            pResource.destroyResource();

            delete this.pNameMap[iHandle];

// free the resource slot associated with the handle
            this.pDataPool.release(iHandle);
        };

        private internalCreateResource(sResourceName: string):  number  {
            var iHandle:  number  = this.pDataPool.nextHandle();

// make sure this name is not already in use
            for (var iter in this.pNameMap) {
                logger.setSourceLocation( "ResourcePool.ts" , 248 ); logger.assert((this.pNameMap[iter] != sResourceName), "A resource with this name already exists: " + sResourceName);
                                                                                         ;
            }

// add this resource name to our map of handles
            this.pNameMap[iHandle] = sResourceName;

// get a pointer to the resource and call it's creation function
            var pResource = this.pDataPool.getPtr(iHandle);

            pResource.createResource();

            return iHandle;
        }

        private static callbackDestroy(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.destroyResource();
        }

        private static callbackDisable(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.disableResource();
        }

        private static callbackRestore(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            pResource.restoreResource();
        }

        private static callbackClean(pPool: IDataPool, iHandle:  number , pResource: IResourcePoolItem): void {
            if (pResource.referenceCount() == 0) {
                pPool.release(iHandle);
            }
        }

        /**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return ResourcePool._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
        createdResource (pResource): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).createdResource; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pResource) : _broadcast[i].listener (_recivier, pResource) ; } } } ; ;

    }
}
















module akra.core.pool {

	export interface IGroupNumber {
		value:  number ;
	}

	export class PoolGroup {
		private pManager: IResourcePoolManager;

/** Конструктор для создания данных в группе */

		private tTemplate: IResourcePoolItemType;

/** Число свободных элементов группы */

		private iTotalOpen:  number  = 0;
/** Первый свободный элемент группы */

		private iFirstOpen:  number  = 0;
/** Колмичество элементов в группе */

		private iMaxCount:  number  = 0;

/** Список свободных элементов группы */

		private pNextOpenList:  number [] = null;
/** Массив элементов группы */

		private pMemberList: IResourcePoolItem[] = null;

		inline get manager(): IResourcePoolManager { return this.pManager; }

/** 
		 * Возвращает количесвто свободных мест в группе 
		 * @inline
		 */

		get totalOpen():  number  {
			return this.iTotalOpen;
		}

/** 
		 * Возвращает количесвто занятых мест в группе 
		 * @inline
		 */

		get totalUsed():  number  {
			return this.iMaxCount - this.iTotalOpen;
		}

/**
		 * Номер первого свободного элемента в группе
		 * @inline
		 */

		get firstOpen():  number  {
			return this.iFirstOpen;
		}

		constructor (pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType, iMaxCount:  number ) {
			this.pManager = pManager;
			this.tTemplate = tTemplate;
			this.iMaxCount = iMaxCount;
		}

/** Создание группы, создается массив элементов, инициализирется список свободный и т.д. */

		create(): void {
			var i:  number ;

		    logger.setSourceLocation( "DataPool.ts" , 70 ); logger.assert(this.pMemberList == null && this.pNextOpenList == null, "Group has already been created"); ;

		    this.pNextOpenList = new Array(this.iMaxCount);

		    logger.setSourceLocation( "DataPool.ts" , 74 ); logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!"); ;

		    this.pMemberList = new Array(this.iMaxCount);


		    for (i = 0; i < this.iMaxCount; i++) {
		        this.pMemberList[i] = new this.tTemplate(this.pManager);
		    }

		    logger.setSourceLocation( "DataPool.ts" , 83 ); logger.assert(this.pNextOpenList != null, "tragic memory allocation failure!"); ;

		    for (i = 0; i < this.iMaxCount - 1; i++) {
		        this.pNextOpenList[i] = i + 1;
		    }

		    this.pNextOpenList[i] = i;
		    this.iTotalOpen = this.iMaxCount;
		    this.iFirstOpen = 0;
		}

/**  
		 * Удаление группы: удаление массива элементов, списка совбодных элементов и т.д.
		 * Выдается ошибка если группа не пуста 
		 * */

		destroy(): void {
		    logger.setSourceLocation( "DataPool.ts" , 99 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 100 ); logger.assert(this.iTotalOpen == this.iMaxCount, "Group is not empty"); ;

		    delete this.pMemberList;
		    this.pMemberList = null;

		    delete this.pNextOpenList;
		    this.pNextOpenList = null;

		    this.iTotalOpen = 0;
		    this.iMaxCount = 0;
		}

/** Возвращает номер следующего совбодного элемента в списке, и помечает его как используемый */

		nextMember() {
		    logger.setSourceLocation( "DataPool.ts" , 114 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 115 ); logger.assert(this.iTotalOpen != null, "no open slots"); ;
//Возвращает номер первого свободного элемента в группе,
//и изменяет номер первого свободного на следующего свободного

		    var iSlot = this.iFirstOpen;
		    this.iFirstOpen = this.pNextOpenList[iSlot];
		    this.iTotalOpen --;

		    logger.setSourceLocation( "DataPool.ts" , 123 ); logger.assert(this.iFirstOpen != INVALID_INDEX, "Invalid Open Index"); ;
		    logger.setSourceLocation( "DataPool.ts" , 124 ); logger.assert(this.isOpen(iSlot), "invalid index"); ;

//помечаем что элемент который отдали является используемым
		    this.pNextOpenList[iSlot] = INVALID_INDEX;

		    return iSlot;
		}

/** Добавляем новый элемент в список */

		addMember(pMember: IResourcePoolItem):  number  {
			var iSlot:  number  = this.nextMember();
		    this.pMemberList[iSlot] = pMember;

		    return iSlot;
		}

/** Исключение элемента из списка по его номеру */

		release(iIndex:  number ): void {
			logger.setSourceLocation( "DataPool.ts" , 142 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 143 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); ;
		    logger.setSourceLocation( "DataPool.ts" , 144 ); logger.assert(this.isOpen(iIndex) == false, "invalid index to release"); ;

		    this.pNextOpenList[iIndex] = this.iTotalOpen > 0 ? this.iFirstOpen : iIndex;
		    this.iTotalOpen ++;
		    this.iFirstOpen = iIndex;
		}


/** Проверить свободна ли эта ячейка в группе */

		isOpen (iIndex:  number ): bool {
		    logger.setSourceLocation( "DataPool.ts" , 154 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 155 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); ;

		    return this.pNextOpenList[iIndex] != INVALID_INDEX;
		}

/** Получение элемента по его номеру */

		member(iIndex:  number ): IResourcePoolItem {
		    logger.setSourceLocation( "DataPool.ts" , 162 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 163 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); ;
		    return this.pMemberList[iIndex];
		}

		memberPtr(iIndex:  number ): IResourcePoolItem {
		    logger.setSourceLocation( "DataPool.ts" , 168 ); logger.assert(this.pMemberList != null && this.pNextOpenList != null, "Group has not been created"); ;
		    logger.setSourceLocation( "DataPool.ts" , 169 ); logger.assert(iIndex < this.iMaxCount, "invalid index"); ;
		    return this.pMemberList[iIndex];
		}
	}

	export class DataPool implements IDataPool {
		private pManager: IResourcePoolManager;
		private tTemplate: IResourcePoolItemType;
		private bInitialized: bool = false;

/** Массив групп */

		private pGroupList: PoolGroup[] = [];

/** Общее числ�� ячеек */

		private iTotalMembers:  number  = 0;
/** Количесвто свободных ячеек */

		private iTotalOpen:  number  = 0;
/** Количесвто элементов в группе */

		private iGroupCount:  number  = 0;
/**
		 * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
    	 * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
		 */

		private iIndexMask:  number  = 0;
/**
		 * Номер элемента состоит из номер группы сдвинутого на _iIndexShift
     	 * и номера элемента в этой группе, который можно вырезать маской _iIndexMask
		 */

		private iIndexShift:  number  = 0;


		inline get manager(): IResourcePoolManager { return this.pManager; }

		constructor(pManager: IResourcePoolManager, tTemplate: IResourcePoolItemType) {
			this.pManager = pManager;
			this.tTemplate = tTemplate;
		}


		initialize(iGrowSize:  number ): void {
			logger.setSourceLocation( "DataPool.ts" , 209 ); logger.assert(this.isInitialized() == false, "the cDataPool is already initialized"); ;

		    this.bInitialized = true;
		    this.iGroupCount = math.nearestPowerOfTwo(iGrowSize);
		    this.iIndexShift = math.lowestBitSet(this.iGroupCount);
		    this.iIndexShift = math.clamp(this.iIndexShift, 1, 15);
		    this.iGroupCount = 1 << this.iIndexShift;
		    this.iIndexMask = this.iGroupCount - 1;
		}


/** @inline */

		isInitialized(): bool {
			return this.bInitialized;
		}


		destroy(): void {
			this.clear();
    		this.bInitialized = false;
		}


		release(iHandle:  number ): void {
			logger.setSourceLocation( "DataPool.ts" , 233 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

		    if (this.isHandleValid(iHandle) == true) {
		        logger.setSourceLocation( "DataPool.ts" , 236 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); ;

		        var iGroupIndex:  number  = this.getGroupNumber(iHandle);
		        var iItemIndex:  number  = this.getItemIndex(iHandle);

		        var pGroup: PoolGroup = this.getGroup(iGroupIndex);
		        pGroup.release(iItemIndex);
		        var pGroupBack: PoolGroup = this.pGroupList[this.pGroupList.length - 1];

		        if (pGroupBack.totalOpen == this.iGroupCount) {
		            pGroupBack.destroy();
		            this.pGroupList.splice(this.pGroupList.length - 1, 1);
		        }

		        this.iTotalOpen ++;
		    }
		}

		clear(): void {
// destroy all groups in the list
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; ++ iGroupIter) {
		        this.pGroupList[iGroupIter].destroy();
		    }

// now clear the list itself
		    this.pGroupList.clear();
		}

		add(pMembers: IResourcePoolItem):  number  {
			logger.setSourceLocation( "DataPool.ts" , 265 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

		    var iGroupNumber: IGroupNumber = {value: 0};

		    var pOpenGroup: PoolGroup = this.findOpenGroup(iGroupNumber);
		    var iIndex:  number  = pOpenGroup.addMember(pMembers);

		    this.iTotalOpen --;

		    return this.buildHandle(iGroupNumber.value, iIndex);
		}

		forEach(fFunction: (pPool: IDataPool, iHandle:  number , pMember: IResourcePoolItem) => void): void {
			logger.setSourceLocation( "DataPool.ts" , 278 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;
// iterate through every group

		    var iGroupNumber:  number  = 0;
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {

		        var nCallbackCount:  number  = this.pGroupList[iGroupIter].totalUsed;
		        var iItemIndex:  number  = 0;

		        while (nCallbackCount != 0 && iItemIndex < this.iGroupCount) {
		            if (this.pGroupList[iGroupIter].isOpen(iItemIndex) == false) {
		                fFunction(
		                	this,
		                	this.buildHandle(iGroupNumber, iItemIndex),
		                	this.pGroupList[iGroupIter].member(iItemIndex)
		                	);
		                nCallbackCount--;
		            }

		            ++iItemIndex;
		        }

		        ++iGroupNumber;
		    }
		}

		nextHandle():  number  {
			logger.setSourceLocation( "DataPool.ts" , 305 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

		    var iGroupNumber: IGroupNumber = {value: 0};
		    var pOpenGroup: PoolGroup = this.findOpenGroup(iGroupNumber);
		    var iIndex:  number  = pOpenGroup.nextMember();

		    this.iTotalOpen --;

		    return this.buildHandle(iGroupNumber.value, iIndex);
		}

		isHandleValid(iHandle:  number ): bool {
			logger.setSourceLocation( "DataPool.ts" , 317 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

		    if (iHandle !== INVALID_INDEX) {
		        logger.setSourceLocation( "DataPool.ts" , 320 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); ;

		        var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));

		        return !pGroup.isOpen(this.getItemIndex(iHandle));
		    }

		    return false;
		}

		get(iHandle:  number ): IResourcePoolItem {
			logger.setSourceLocation( "DataPool.ts" , 331 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;
		    logger.setSourceLocation( "DataPool.ts" , 332 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); ;

		    var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));
		    var iItemIndex:  number  = this.getItemIndex(iHandle);

		    return pGroup.member(iItemIndex);
		}

		getPtr(iHandle:  number ): IResourcePoolItem {
			logger.setSourceLocation( "DataPool.ts" , 341 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;
		    logger.setSourceLocation( "DataPool.ts" , 342 ); logger.assert(this.pGroupList.length != 0, "The cDataPool has not been properly created"); ;

		    var pGroup: PoolGroup = this.getGroup(this.getGroupNumber(iHandle));
		    var iItemIndex:  number  = this.getItemIndex(iHandle);

		    return pGroup.memberPtr(iItemIndex);
		}

		getGenericPtr(iHandle:  number ): IResourcePoolItem {
			logger.setSourceLocation( "DataPool.ts" , 351 ); logger.assert(this.isInitialized() == true, "the cDataPool is not initialized"); ;

    		return this.getPtr(iHandle);
		}


/** 
		 * @inline 
		 * Получение номера группы по номеру элемента
		 */

		private getGroupNumber(iHandle:  number ):  number  {
			return iHandle >> this.iIndexShift;
		}

/** 
		 * @inline 
		 * Получение номера элеменат в группе по его номеру
		 */

		private getItemIndex(iHandle:  number ):  number  {
			return iHandle & this.iIndexMask;
		}

/** 
		 * @inline 
		 * Полученяи номера элеменат по его номеру группы и группе
		 */

		private buildHandle(iGroup, iIndex):  number  {
			return (iGroup << this.iIndexShift) + iIndex;
		}

/** Добавление группы в пул */

		private addGroup(): PoolGroup {
// append a new group to the list to start things off
		    var pNewGroup: PoolGroup = new PoolGroup(this.pManager, this.tTemplate, this.iGroupCount);
		    this.pGroupList.push(pNewGroup);
// gain access to the new group and innitialize it
		    pNewGroup.create();
// increment our internal counters
		    this.iTotalMembers += this.iGroupCount;
		    this.iTotalOpen += this.iGroupCount;

		    return pNewGroup;
		}

/** Поиск первой группы которая имеет свободную область */

		private findOpenGroup(pGroupNumber: IGroupNumber): PoolGroup {
			pGroupNumber.value = 0;

//найдем и вренем первую группу имеющую свободную группу
		    for (var iGroupIter:  number  = 0; iGroupIter < this.pGroupList.length; iGroupIter++) {
		        if (this.pGroupList[iGroupIter].totalOpen > 0) {
		            return this.pGroupList[iGroupIter];
		        }

		        pGroupNumber.value ++;
		    }

//свободных областей нет, поэтому мы должны добавить новую группу в пул,
//но пержде чем содавать убедимся что не достигли максимума

		    logger.setSourceLocation( "DataPool.ts" , 411 ); logger.assert((this.pGroupList.length + 1) < MAX_UINT16, "the cDataPool is full!!!!"); ;
//добавим новую группу

		    return this.addGroup();
		}

/** 
		 * @inline 
		 * Возвращает группу по ее номеру
		 */

		private getGroup(iIndex:  number ): PoolGroup {
			logger.setSourceLocation( "DataPool.ts" , 422 ); logger.assert(iIndex < this.pGroupList.length, "Invalid group index requested"); ;
    		return this.pGroupList[iIndex];
		}


	}
}














module akra {

	export interface IEffect {} ;
	export interface ISurfaceMaterial {} ;

	export interface IRenderMethod extends IResourcePoolItem {
		effect: IEffect;
		surfaceMaterial: ISurfaceMaterial;

		isEqual(pRenderMethod: IRenderMethod): bool;
	}
}























module akra {
	export interface IResourceNotifyRoutineFunc {
		(iFlagBit?:  number , iResourceFlags?:  number , isSet?: bool): void;
		(eEvent?: EResourceItemEvents, iResourceFlags?:  number , isSet?: bool): void;
	}
}









module akra.core.pool {

	export interface ICallbackSlot {
		bState: bool;
		fn: IResourceNotifyRoutineFunc;
		pResourceItem: IResourcePoolItem;
	}

	export class ResourcePoolItem extends util.ReferenceCounter implements IResourcePoolItem {
//private pManager: IResourcePoolManager;
		private pResourceCode: IResourceCode;
		private pResourcePool: IResourcePool = null;
		private iResourceHandle:  number  = 0;
		private iResourceFlags:  number  = 0;
		private pCallbackFunctions: IResourceNotifyRoutineFunc[];
		private pStateWatcher: IResourceWatcherFunc[];
		private pCallbackSlots: ICallbackSlot[][];


		inline get resourceCode(): IResourceCode {
			return this.pResourceCode;
		}

		inline get resourcePool(): IResourcePool {
			return this.pResourcePool;
		}

		inline get resourceHandle():  number  {
			return this.iResourceHandle;
		}

		inline get resourceFlags():  number  {
			return this.iResourceFlags;
		}

		inline get alteredFlag(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.ALTERED);
		}

		inline get manager(): IResourcePoolManager { return this.getManager(); }

/** Constructor of ResourcePoolItem class */

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
			super();

//this.pManager = pManager;
			this.pResourceCode = new ResourceCode(0);
			this.pCallbackFunctions = [];
			this.pStateWatcher = [];
			this.pCallbackSlots = genArray(null, <number>EResourceItemEvents.TOTALRESOURCEFLAGS);
		}

		inline getEngine(): IEngine {
			var pManager: IResourcePoolManager = this.getManager();

			if (pManager) {
				return pManager.getEngine();
			}

			return null;
		}

		inline getManager(): ResourcePoolManager {
			return <ResourcePoolManager>(<ResourcePool>this.pResourcePool).manager;
		}

		createResource(): bool {
			return false;
		}

		destroyResource(): bool {
			return false;
		}

		disableResource(): bool {
			return false;
		}

		restoreResource(): bool {
			return false;
		}

		loadResource(sFilename: string = null): bool {
			return false;
		}

		saveResource(sFilename: string = null): bool {
			return false;
		}


		setChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void {
			for (var i:  number  = 0; i < this.pCallbackFunctions.length; i ++) {

			    if (this.pCallbackFunctions[i] == fn) {
			        return;
			    }
			}

			this.pCallbackFunctions.push(fn);
		}

		delChangesNotifyRoutine(fn: IResourceNotifyRoutineFunc): void {
			for (var i:  number  = 0; i < this.pCallbackFunctions.length; i ++) {
		        if (this.pCallbackFunctions[i] == fn) {
		            this.pCallbackFunctions[i] = null;
		        }
		    }
		}

		setStateWatcher(eEvent: EResourceItemEvents, fnWatcher: IResourceWatcherFunc): void {
			this.pStateWatcher[eEvent] = fnWatcher;
		}

		sync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool {
			eSlot = isDef(eSlot)? eSlot: eSignal;

		    eSlot = ResourcePoolItem.parseEvent(<number>eSlot);
		    eSignal = ResourcePoolItem.parseEvent(<number>eSignal);

		    var pSlots: ICallbackSlot[][] = this.pCallbackSlots, pSignSlots: ICallbackSlot[];

		    var me: IResourcePoolItem = this;
		    var n:  number ;
		    var fn: IResourceNotifyRoutineFunc;
		    var bState: bool;

		    if (isNull(pSlots[eSlot])) {
		        pSlots[eSlot] = [];
		    }

		    pSignSlots = pSlots[eSlot];
		    n = pSignSlots.length;
		    bState = bf.testBit(pResourceItem.resourceFlags, <number>eSignal);

		    fn = function (eFlag?: EResourceItemEvents, iResourceFlags?:  number , isSet?: bool) {
		        if (eFlag == <number>eSignal) {
		            pSignSlots[n].bState = isSet;
		            me.notifyStateChange(eSlot, this);

		            for (var i:  number  = 0; i < pSignSlots.length; ++i) {
		                if (pSignSlots[i].bState === false) {
		                    if (bf.testBit(me.resourceFlags, <number>eFlag)) {
		                        me.setResourceFlag(eFlag, false);
		                    }
		                    return;
		                }
		            }

		            me.setResourceFlag(eFlag, true);
		        }
		    };

		    pSignSlots.push({bState : bState, fn : fn, pResourceItem : pResourceItem});

		    fn.call(pResourceItem, eSignal, pResourceItem.resourceFlags, bState);
		    pResourceItem.setChangesNotifyRoutine(fn);

		    return true;
		}

		unsync(pResourceItem: IResourcePoolItem, eSignal: EResourceItemEvents, eSlot?: EResourceItemEvents): bool {
			eSlot = isDef(eSlot)? eSlot: eSignal;
		    eSlot = ResourcePoolItem.parseEvent(<number>eSlot);
		    eSignal = ResourcePoolItem.parseEvent(<number>eSignal);

		    var pSlots: ICallbackSlot[][] = this.pCallbackSlots, pSignSlots: ICallbackSlot[];
		    var me: IResourcePoolItem = this;
		    var isRem: bool = false;

		    pSignSlots = pSlots[eSlot];


		    for (var i:  number  = 0, n:  number  = pSignSlots.length; i < n; ++i) {
		        if (pSignSlots[i].pResourceItem === pResourceItem) {
		            pSignSlots[i].pResourceItem.delChangesNotifyRoutine(pSignSlots[i].fn);
		            pSignSlots.splice(i, 1);

		            --n;
		            --i;

		            isRem = true;
		        }
		    }

		    return isRem;
		}


		inline isResourceCreated(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.CREATED);
		}

		inline isResourceLoaded(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.LOADED);
		}

		inline isResourceDisabled(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.DISABLED);
		}

		inline isResourceAltered(): bool {
			return bf.testBit(this.iResourceFlags, <number>EResourceItemEvents.ALTERED );
		}

		setAlteredFlag(isOn: bool = true): bool {
//notify always, when altered called
    		if (this.setResourceFlag(EResourceItemEvents.ALTERED, isOn) || isOn) {
    			isOn? this.altered(): this.saved();
    			return true;
    		}

    		return false;
		}

		inline setResourceName(sName: string) {
			if (this.pResourcePool != null) {
		        this.pResourcePool.setResourceName(this.iResourceHandle, sName);
		    }
		}

		findResourceName(): string {
			if (this.pResourcePool != null) {
		        return this.pResourcePool.findResourceName(this.iResourceHandle);
		    }

		    return null;
		}

		release():  number  {
			var iRefCount = super.release();

		    if (iRefCount == 0) {
//Если у нас есть менеджер попросим его удалить нас
		        if (this.pResourcePool != null) {
		            this.pResourcePool.destroyResource(this);
		        }
		    }

		    return iRefCount;
		}
		inline notifyCreated(): void {
			if (this.setResourceFlag(EResourceItemEvents.CREATED, true)) {
				this.created();
			}
		}

		inline notifyDestroyed(): void {
			if (this.setResourceFlag(EResourceItemEvents.CREATED, false)) {
				this.destroyed();
			}
		}

		inline notifyLoaded(): void {
			this.setAlteredFlag(false);
// LOG("ResourcePoolItem::notifyLoaded();");
    		if (this.setResourceFlag(EResourceItemEvents.LOADED, true)) {
// LOG("ResourcePoolItem::loaded();");
    			this.loaded();
    		}
		}

		inline notifyUnloaded(): void {
			if (this.setResourceFlag(EResourceItemEvents.LOADED, false)) {
				this.unloaded();
			}
		}

		inline notifyRestored(): void {
			if (this.setResourceFlag(EResourceItemEvents.DISABLED, false)) {
				this.restored();
			}
		}

		inline notifyDisabled(): void {
			if (this.setResourceFlag(EResourceItemEvents.DISABLED, true)) {
				this.disabled();
			}
		}

		inline notifyAltered(): void {
			this.setAlteredFlag(true);
		}

		inline notifySaved(): void {
			this.setAlteredFlag(false);
		}

/**
		 * Назначение кода ресурсу
		 * @inline
		 */

		setResourceCode(pCode: IResourceCode): void {
			this.pResourceCode.eq(pCode);
		}

/**
		 * Чтобы ресурс знал какому пулу ресурсов принадлжит
		 * @inline
		 */

		setResourcePool(pPool: IResourcePool): void {
			this.pResourcePool = pPool;
		}

/**
		 * Назначение хендла ресурсу
		 * @inline
		 */

		setResourceHandle(iHandle:  number ): void {
			this.iResourceHandle = iHandle;
		}

		notifyStateChange(eEvent: EResourceItemEvents, pTarget: IResourcePoolItem = null): void {
			if (!this.pStateWatcher[eEvent]) {
		        return;
		    }

		    var pSignSlots: ICallbackSlot[]  = this.pCallbackSlots[eEvent];
		    var nTotal:  number  = pSignSlots.length, nLoaded:  number  = 0;

		    for (var i:  number  = 0; i < nTotal; ++i) {
		        if (pSignSlots[i].bState) {
		            ++ nLoaded;
		        }
		    }

		    this.pStateWatcher[eEvent](nLoaded, nTotal, pTarget);
		}

		setResourceFlag(eFlagBit: EResourceItemEvents, isSetting: bool): bool;
		setResourceFlag(iFlagBit:  number , isSetting: bool): bool;
		setResourceFlag(iFlagBit, isSetting: bool): bool {
			var iTempFlags:  number  = this.iResourceFlags;

		    this.iResourceFlags = bf.setBit(this.iResourceFlags, iFlagBit, isSetting);
// LOG("before !=", iFlagBit, "(" + EResourceItemEvents.LOADED + ")", iTempFlags, "==>", this.iResourceFlags);

		    if (iTempFlags != this.iResourceFlags) {
// LOG("!+");
		        for (var i:  number  = 0; i < this.pCallbackFunctions.length; i++) {
		            if (this.pCallbackFunctions[i]) {
		                this.pCallbackFunctions[i].call(this, iFlagBit, this.iResourceFlags, isSetting);
		            }
		        }
		        return true;
		    }

		    return false;
		}

		static private parseEvent(sEvent: string): EResourceItemEvents;
		static private parseEvent(iEvent:  number ): EResourceItemEvents;
		static private parseEvent(pEvent) {
		 	if (isInt(pEvent)) {
		        return <EResourceItemEvents>pEvent;
		    }

		    switch (pEvent.toLowerCase()) {
		        case 'loaded':
		            return EResourceItemEvents.LOADED;
		        case 'created':
		            return EResourceItemEvents.CREATED;
		        case 'disabled':
		            return EResourceItemEvents.DISABLED;
		        case 'altered':
		            return EResourceItemEvents.ALTERED;
		        default:
		            logger.setSourceLocation( "../ResourcePoolItem.ts" , 382 ); logger.error('Использовано неизвестное событие для ресурса.'); ;
		            return 0;
		    }
		}


		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return ResourcePoolItem._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		created (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).created; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		destroyed (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).destroyed; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		loaded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).loaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		unloaded (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).unloaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		restored (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).restored; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		disabled (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).disabled; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		altered (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).altered; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		saved (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).saved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
	}

}



module akra.core.pool.resources {
	export class RenderMethod extends ResourcePoolItem implements IRenderMethod {
		/**@protected*/  _pEffect: IEffect = null;
		surfaceMaterial: ISurfaceMaterial = null;

		inline get effect(): IEffect{
			return this._pEffect;
		}

		set effect(pEffect: IEffect) {
			if(!isNull(this._pEffect)){
				this.disconnect(this._pEffect,  "altered" ,  "_updateEffect" , EEventTypes.BROADCAST);
			}

			this._pEffect = pEffect;

			if(!isNull(pEffect)){
				this.connect(pEffect,  "altered" ,  "_updateEffect" , EEventTypes.BROADCAST);
			}

			this.notifyAltered();
		}

		isEqual(pRenderMethod: IRenderMethod): bool {return false;}

		_updateEffect(pEffect: IEffect): void {
			this.notifyAltered();
		}
	}


}










module akra {
	export interface IMaterial {} ;
	export interface ITexture {} ;

	export enum ESurfaceMaterialTextures {
		TEXTURE0 = 0,
        TEXTURE1,
        TEXTURE2,
        TEXTURE3,
        TEXTURE4,
        TEXTURE5,
        TEXTURE6,
        TEXTURE7,
        TEXTURE8,
        TEXTURE9,
        TEXTURE10,
        TEXTURE11,
        TEXTURE12,
        TEXTURE13,
        TEXTURE14,
        TEXTURE15,
        DIFFUSE = TEXTURE0,
        AMBIENT,
        SPECULAR,
        EMISSIVE,
        EMISSION = EMISSIVE
	};



    export interface ISurfaceMaterial extends IResourcePoolItem {
    	totalTextures:  number ;
    	material: IMaterial;
    	textureFlags:  number ;
    	textureMatrixFlags:  number ;

        setTexture(iIndex:  number , sTexture: string, iTexcoord?:  number ): bool;
        setTexture(iIndex:  number , iTextureHandle:  number , iTexcoord?:  number ): bool;
    	setTexture(iIndex:  number , pTexture: ITexture, iTexcoord?:  number ): bool;
    	setTextureMatrix(iIndex:  number , m4fValue: IMat4): bool;
    	setMaterial(pMaterial: IMaterial): void;
    	isEqual(pSurface: ISurfaceMaterial): bool;

    	texture(iSlot:  number ): ITexture;
    	texcoord(iSlot:  number ):  number ;
    	textureMatrix(iSlot:  number ): IMat4;
    }

}













module akra {
	export interface IVertexData {} ;

	export interface IMaterialBase {
		diffuse: IColorValue;
		ambient: IColorValue;
		specular: IColorValue;
		emissive: IColorValue;
		shininess:  number ;
	}

	export interface IMaterial extends IMaterialBase {
		name: string;

		set(pMat: IMaterialBase): IMaterial;
		isEqual(pMat: IMaterialBase): bool;
	}

	export interface IFlexMaterial extends IMaterial {
		data: IVertexData;
	}

// export interface IMaterialEx extends IMaterial {
// 	reflective: 
// 	reflectivity
// 	transparent
// 	transparency
// 	indexofrefraction
// }
}












module akra {

	export interface IVertexElement {} ;

	export  /**@const*/var  DeclarationUsages = {
		POSITION 	: "POSITION",
	    POSITION1	: "POSITION1",
	    POSITION2	: "POSITION2",
	    POSITION3	: "POSITION3",

	    BLENDWEIGHT	: "BLENDWEIGHT",
	    BLENDINDICES: "BLENDINDICES",
	    BLENDMETA	: "BLENDMETA",

	    NORMAL 		: "NORMAL",
	    NORMAL1		: "NORMAL1",
	    NORMAL2		: "NORMAL2",
	    NORMAL3		: "NORMAL3",

	    PSIZE		: "PSIZE",

	    TEXCOORD 	: "TEXCOORD",
	    TEXCOORD1	: "TEXCOORD1",
	    TEXCOORD2	: "TEXCOORD2",
	    TEXCOORD3	: "TEXCOORD3",
	    TEXCOORD4	: "TEXCOORD4",
	    TEXCOORD5	: "TEXCOORD5",

	    TANGENT		: "TANGENT",
	    BINORMAL 	: "BINORMAL",

	    TESSFACTOR	: "TESSFACTOR",
	    COLOR 		: "COLOR",
	    FOG 		: "FOG",
	    DEPTH 		: "DEPTH",
	    SAMPLE 		: "SAMPLE",

	    INDEX 		: "INDEX",
		INDEX0 		: "INDEX0",
	    INDEX1 		: "INDEX1",
	    INDEX2 		: "INDEX2",
	    INDEX3 		: "INDEX3",
//system indices starts from 10
	    INDEX10 	: "INDEX10",
	    INDEX11 	: "INDEX11",
	    INDEX12 	: "INDEX12",
	    INDEX13 	: "INDEX13",

	    MATERIAL 	: "MATERIAL",
	    MATERIAL1 	: "MATERIAL1",
	    MATERIAL2 	: "MATERIAL2",

	    DIFFUSE		: "DIFFUSE",
	    AMBIENT 	: "AMBIENT",
	    SPECULAR 	: "SPECULAR",
	    EMISSIVE 	: "EMISSIVE",
	    SHININESS 	: "SHININESS",

//special semantic for video buffer
	    TEXTURE_HEADER : "TEXTURE_HEADER",

	    UNKNOWN 	: "UNKNOWN",
	    END 		: "\a\n\r"
	};

	export  /**@const*/var  DeclUsages = DeclarationUsages;

	export interface IVertexDeclaration {
		stride:  number ;
		 length:  number ;


//[index: number]: IVertexElement;

		append(...pElement: IVertexElementInterface[]): bool;
		append(pElements: IVertexElementInterface[]): bool;

		extend(pDecl: IVertexDeclaration): bool;

		hasSemantics(sSemantics: string): bool;
		findElement(sSemantics: string, iCount?:  number ): IVertexElement;
		clone(): IVertexDeclaration;

		element(i:  number ): IVertexElement;

		_update(): bool;

///DEBUG!!!
		toString(): string;
	}



	export inline function VE_CUSTOM(sUsage: string, eType: EDataTypes = EDataTypes.FLOAT, iCount:  number  = 1, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface {
		return {count: iCount, type: eType, usage: sUsage, offset: iOffset};
	}

	export inline function VE_FLOAT(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 1, iOffset); };
	export inline function VE_FLOAT2(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 2, iOffset); };
	export inline function VE_FLOAT3(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 3, iOffset); };
	export inline function VE_FLOAT4(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 4, iOffset); };
	export inline function VE_FLOAT4x4(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 16, iOffset); };
	export inline function VE_VEC2(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 2, iOffset); };
	export inline function VE_VEC3(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 3, iOffset); };
	export inline function VE_VEC4(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 4, iOffset); };
	export inline function VE_MAT4(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.FLOAT, 16, iOffset); };
	export inline function VE_INT(sUsage: string, iOffset:  number  =  MAX_INT32 ): IVertexElementInterface { return VE_CUSTOM(sUsage, EDataTypes.INT, 1, iOffset);};

	export inline function VE_END(iOffset:  number  = 0): IVertexElementInterface { return VE_CUSTOM(DeclUsages.END, EDataTypes.UNSIGNED_BYTE, 0, iOffset); };

//export var createVertexDeclaration: (pData?) => IVertexDeclaration;
}












module akra {
	export interface IVertexElementInterface {
/**
		 * Number of uint.
		 */

		count:  number ;
/**
		 * Type of units. 
		 */

		type: EDataTypes;
/**
		 * Usage of element.
		 * For ex., basicly for vertices is 'POSITION'.
		 */

		usage: string;
/**
		 * Offset in bytes.
		 */

		offset?:  number ;
	}

	export interface IVertexElement extends IVertexElementInterface {
/**
		 * Size in bytes.
		 */

		size:  number ;
/**
		 * numerical index of declaration. 
		 * For ex. for usage INDEX10, index is 10, semantics is 'INDEX'.
		 */

		index:  number ;
/**
		 * Semantics of declaration.
		 * @see DelcarationUsages.
		 */

		semantics: string;

		clone(): IVertexElement;

//DEBUG!!
		toString(): string;
	}
}




module akra.data {
	export class VertexElement implements IVertexElement {
		count:  number ;
		type: EDataTypes;
		usage: string;
		offset:  number ;

// this properties is readonly for public usage.
		size:  number  = 0;
		index:  number  = 0;
		semantics: string = DeclarationUsages.UNKNOWN;

		constructor (
			nCount:  number  = 1,
			eType: EDataTypes = EDataTypes.FLOAT,
			eUsage: string = DeclarationUsages.POSITION,
//mark invalid offset, for determine true offset in VertexDeclaration::_update();
			iOffset:  number  =  MAX_INT32 ) {

			this.count = nCount;
			this.type = eType;
			this.usage = eUsage;
			this.offset = iOffset;

			this.update();
		}

		private update(): void {
			this.size = this.count * getTypeSize(this.type);
		    this.index = 0;
		    this.semantics = null;

		    var pMatches: string[] = this.usage.match(/^(.*?\w)(\d+)$/i);

		    if (!isNull(pMatches)) {
		        this.semantics = pMatches[1];
		        this.index = parseInt(pMatches[2]);

// To avoid the colosseum between the "usage" of the element as POSITION & POSITION0, 
// given that this is the same thing, here are the elements with index 0 
// for "usage" with the POSITION.
// if (this.index === 0) {
// 	this.usage = this.semantics;
// }
		    }
		    else {
		        this.semantics = this.usage;
		    }
		};

		clone(): IVertexElement {
			return new VertexElement(this.count, this.type, this.usage, this.offset);
		};

		inline static hasUnknownOffset(pElement: IVertexElementInterface): bool {
			return (!isDef(pElement.offset) || (pElement.offset ===  MAX_INT32 ));
		};

		toString(): string {

			function _an(data: any, n:  number , bBackward: bool = false): string {
		        var s: string = String(data);

		        for (var i = 0, t = n - s.length; i < t; ++ i) {
		            if (bBackward) {
		                s = " " + s;
		            }
		            else {
		                s += " ";
		            }
		        }
		        return s;
		    }

		    var s = "[ USAGE: " + _an(this.usage == DeclUsages.END? "<END>": this.usage, 12) + ", OFFSET " + _an(this.offset, 4)
		    				+ ", SIZE " + _an(this.size, 4) +" ]";

		    return s;

		}
	}
}

module akra {
	export var VertexElement = VertexElement;
}



module akra.data {

	export class VertexDeclaration implements IVertexDeclaration {
//readonly property for public usage
		stride:  number  = 0;

		private _pElements: IVertexElement[] = [];

		inline get length():  number  {
			return this._pElements.length;
		}

//FIXME: typescript error "Overload signature is not compatible with function definition" ???
//constructor (...pElement: IVertexElement[]) 
		constructor (...pElements: IVertexElementInterface[]);
		constructor (pElements: IVertexElementInterface[]);
		constructor (pElements: any) {
			if (arguments.length > 0) {
				this.append.apply(this, arguments);
			}
		}

		inline element(i:  number ): IVertexElement {
			return this._pElements[i] || null;
		}

		append(...pElement: IVertexElementInterface[]): bool;
		append(pElements: IVertexElementInterface[]): bool;
		append(pData: any) {
			var pElements: IVertexElementInterface[];

			if (!isArray(arguments[0])) {
				pElements = <IVertexElementInterface[]><any>arguments;
			}
			else {
				pElements = <IVertexElementInterface[]><any>arguments[0];
			}

			for (var i:  number  = 0; i < pElements.length; i++) {
				var pElement: IVertexElementInterface = pElements[i];
				var iOffset:  number ;

				if (VertexElement.hasUnknownOffset(pElement)) {
//add element to end
					iOffset = this.stride;
				}
				else{
					iOffset = pElement.offset;
				}

				var pVertexElement: IVertexElement = new VertexElement(
															pElement.count,
												            pElement.type,
												            pElement.usage,
												            iOffset);

				this._pElements.push(pVertexElement);

				var iStride:  number  = iOffset + pVertexElement.size;

				if(this.stride < iStride){
					this.stride = iStride;
				}
			}

			return this._update();
		}

		_update(): bool {
			var iStride:  number ;

			for (var i:  number  = 0; i < this.length; ++ i) {
//move "END" element to end of declaration
				if (this._pElements[i].usage === DeclUsages.END) {
		            this._pElements.swap(i, i + 1);
		        }

//recalc total stride
		        iStride = this._pElements[i].size + this._pElements[i].offset;

		        if (this.stride < iStride) {
		            this.stride = iStride
		        }
			}

			var pLast: IVertexElement = this._pElements.last;

		    if (pLast.usage === DeclUsages.END && pLast.offset < this.stride) {
		        pLast.offset = this.stride;
		    }

		    return true;
		}



		extend(decl: IVertexDeclaration): bool {
			var pDecl: VertexDeclaration = <VertexDeclaration>decl;
			var pElement: IVertexElement;

		    for (var i = 0; i < this.length; ++ i) {
		        for (var j = 0; j < pDecl.length; ++ j) {
		            if (pDecl.element(j).usage == this._pElements[i].usage) {
		                logger.setSourceLocation( "data/VertexDeclaration.ts" , 110 ); logger.log('inconsistent declarations:', this, pDecl); ;
		                logger.setSourceLocation( "data/VertexDeclaration.ts" , 111 ); logger.error('The attempt to combine the declaration containing the exact same semantics.'); ;
		                return false;
		            }
		        }
		    }

		    for (var i = 0; i < pDecl.length; i++) {
		        pElement = pDecl.element(i).clone();
		        pElement.offset += this.stride;
		        this._pElements.push(pElement);
		    }

		    return this._update();
		}

		inline hasSemantics(sSemantics: string): bool {
			return this.findElement(sSemantics) !== null;
		}

		findElement(sSemantics: string, iCount:  number  = MAX_INT32): IVertexElement {
			sSemantics = sSemantics.toUpperCase();

			for (var i = 0; i < this.length; ++i) {
				if (this._pElements[i].usage === sSemantics && (iCount === MAX_INT32 || this._pElements[i].count == iCount)) {
					return this._pElements[i];
				}
			}

			return null;
		}

		clone(): IVertexDeclaration {
			var pElements: IVertexElement[] = [];
			var pDecl: VertexDeclaration;

		    for (var i = 0; i < this.length; ++ i) {
		        pElements.push(this._pElements[i].clone());
		    }

		    pDecl = new VertexDeclaration(pElements);

		    if (pDecl._update()) {
		    	return pDecl;
		    }

		    return null;
		}

///DEBUG!!!
		toString(): string {

			var s = "\n";

	    	s += "  VERTEX DECLARATION ( " + this.stride +" b. ) \n";
		    s += "---------------------------------------\n";

		    for (var i = 0; i < this.length; ++ i) {
		        s += this._pElements[i].toString() + '\n';
		    }

		    return s;

		}
	}
}

module akra {
	export var VertexDeclaration = data.VertexDeclaration;

	export var createVertexDeclaration = function (pData?): data.VertexDeclaration {
		if (!(pData instanceof VertexDeclaration)) {
	        if (!(pData instanceof Array)) {
	            pData = [pData];
	        }

	        pData = new VertexDeclaration(pData);
	    }

	    return pData;
	}

}














module akra {

	export interface IColorIValue {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;
	}

	export interface IColorValue {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;
	}
}



module akra {

	export interface IColor extends IColorValue {
		rgba:  number ;
		argb:  number ;
		bgra:  number ;
		abgr:  number ;

		set(cColor: IColorValue): IColor;
		set(cColor: IColor): IColor;
		set(r?:  number , g?:  number , b?:  number , a?:  number ): IColor;
		set(fGray:  number , fAlpha:  number ): IColor;

/** Clamps colour value to the range [0, 1].
         */

        saturate(): void;

/** As saturate, except that this colour value is unaffected and
		    the saturated colour value is returned as a copy. */

		saturateCopy(): IColor;

		add(cColor: IColor, ppDest?: IColor): IColor;
		subtract(cColor: IColor, ppDest?: IColor): IColor;
		multiply(cColor: IColor, ppDest?: IColor): IColor;
		multiply(fScalar:  number , ppDest?: IColor): IColor;
		divide(cColor: IColor, ppDest?: IColor): IColor;
		divide(fScalar:  number , ppDest?: IColor): IColor;

/** Set a colour value from Hue, Saturation and Brightness.
			@param hue Hue value, scaled to the [0,1] range as opposed to the 0-360
			@param saturation Saturation level, [0,1]
			@param brightness Brightness level, [0,1]
		*/

		setHSB(fHue:  number , fSaturation:  number , fBrightness:  number ): IColor;

/** Convert the current colour to Hue, Saturation and Brightness values. 
			@param hue Output hue value, scaled to the [0,1] range as opposed to the 0-360
			@param saturation Output saturation level, [0,1]
			@param brightness Output brightness level, [0,1]
		*/


		getHSB(pHsb?:  number []):  number [];

		toString(): string;
	}
}



module akra.util {

	export class Color implements IColor {
		r:  number ;
		g:  number ;
		b:  number ;
		a:  number ;

		constructor ();
		constructor (cColor: IColor);
		constructor (pData: ArrayBufferView);
		constructor (r:  number , g:  number , b:  number , a:  number );
		constructor (r:  number , g:  number , b:  number );
		constructor (fGray:  number , fAlpha:  number );
		constructor (fGray:  number );
		constructor (r?: any, g?: any, b?: any, a?: any) {
			this.set.apply(this, arguments);
		}

		get rgba():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.a * 255) << 24;
	        val32 += < number >(this.b * 255) << 16;
	        val32 += < number >(this.g * 255) << 8;
	        val32 += < number >(this.r * 255);

	        return val32;
		}

		get argb():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.b * 255) << 24;
	        val32 += < number >(this.g * 255) << 16;
	        val32 += < number >(this.r * 255) << 8;
	        val32 += < number >(this.a * 255);

	        return val32;
		}

		get bgra():  number  {
	        var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.a * 255) << 24;
	        val32 += < number >(this.r * 255) << 16;
	        val32 += < number >(this.g * 255) << 8;
	        val32 += < number >(this.b * 255);

	        return val32;
		}

		get abgr():  number  {
			var val32:  number  = 0;
// Convert to 32bit pattern
	        val32 = < number >(this.r * 255) << 24;
	        val32 += < number >(this.g * 255) << 16;
	        val32 += < number >(this.b * 255) << 8;
	        val32 += < number >(this.a * 255);

	        return val32;
		}

		set rgba(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.a = ((val32 >> 24) & 0xFF) / 255.0;
	        this.b = ((val32 >> 16) & 0xFF) / 255.0;
	        this.g = ((val32 >> 8) & 0xFF) / 255.0;
	        this.r = (val32 & 0xFF) / 255.0;

		}

		set argb(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.b = ((val32 >> 24) & 0xFF) / 255.0;
	        this.g = ((val32 >> 16) & 0xFF) / 255.0;
	        this.r = ((val32 >> 8) & 0xFF) / 255.0;
	        this.a = (val32 & 0xFF) / 255.0;

		}

		set bgra(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.a = ((val32 >> 24) & 0xFF) / 255.0;
	        this.r = ((val32 >> 16) & 0xFF) / 255.0;
	        this.g = ((val32 >> 8) & 0xFF) / 255.0;
	        this.b = (val32 & 0xFF) / 255.0;

		}

		set abgr(c:  number ) {
			var val32:  number  = c;

// Convert from 32bit pattern
	        this.r = ((val32 >> 24) & 0xFF) / 255.0;
	        this.g = ((val32 >> 16) & 0xFF) / 255.0;
	        this.b = ((val32 >> 8) & 0xFF) / 255.0;
	        this.a = (val32 & 0xFF) / 255.0;

		}

		set(): IColor;
		set(cColor: IColorValue): IColor;
		set(pData: ArrayBufferView): IColor;
		set(cColor: IColor): IColor;
		set(r:  number , g:  number , b:  number , a:  number ): IColor;
		set(r:  number , g:  number , b:  number ): IColor;
		set(fGray:  number , fAlpha:  number ): IColor;
		set(fGray:  number ): IColor;
		set(r?: any, g?: any, b?: any, a?: any): IColor {
			switch (arguments.length) {
				case 0:
					this.r = this.g = this.b = 0.;
					this.a = 1.;
					break;
				case 1:
					if (isInt(arguments[0])) {
						this.r = this.g = this.b = < number >r;
						this.a = 1.;
					}
					else if (isDef(arguments[0].buffer)) {
						var c: ArrayBufferView = <ArrayBufferView>arguments[0];
						this.r = c[0];
						this.g = c[1];
						this.b = c[2];
						this.a = c[3];
					}
					else {
						var v: IColorValue = <IColorValue>arguments[0];
						this.r = v.r;
						this.g = v.g;
						this.b = v.b;
						this.a = v.a;
					}
					break;
				case 2:
					this.r = this.g = this.b = < number >r;
					this.a = < number >g;
					break;
				case 3:
				case 4:
					this.r = < number >r;
					this.g = < number >g;
					this.b = < number >b;
					this.a = isDef(a)? < number >a: 1.;
					break;
			}

			return this;
		}

        saturate(): IColor {
        	if (this.r < 0.)
                this.r = 0.;
            else if (this.r > 1.)
                this.r = 1.;

            if (this.g < 0.)
                this.g = 0.;
            else if (this.g > 1.)
                this.g = 1.;

            if (this.b < 0.)
                this.b = 0.;
            else if (this.b > 1.)
                this.b = 1.;

            if (this.a < 0.)
                this.a = 0.;
            else if (this.a > 1.)
                this.a = 1.;

        	return this;
        }

/** As saturate, except that this colour value is unaffected and
		    the saturated colour value is returned as a copy. */

		saturateCopy(): IColor {
			var ret: IColor = new Color(this);
            ret.saturate();
            return ret;
		}

		add(cColor: IColor, ppDest: IColor = new Color): IColor {

            ppDest.r = this.r + cColor.r;
            ppDest.g = this.g + cColor.g;
            ppDest.b = this.b + cColor.b;
            ppDest.a = this.a + cColor.a;

            return ppDest;
		}

		subtract(cColor: IColor, ppDest: IColor = new Color): IColor {
			ppDest.r = this.r - cColor.r;
            ppDest.g = this.g - cColor.g;
            ppDest.b = this.b - cColor.b;
            ppDest.a = this.a - cColor.a;

            return ppDest;
		}

		multiply(cColor: IColor, ppDest?: IColor): IColor;
		multiply(fScalar:  number , ppDest?: IColor): IColor;
		multiply(fScalar: any, ppDest: IColor = new Color): IColor {
			if (isNumber(fScalar)) {
				var f:  number  = < number >fScalar;
				ppDest.r = this.r * f;
	            ppDest.g = this.g * f;
	            ppDest.b = this.b * f;
	            ppDest.a = this.a * f;
			}
			else {
				var c: IColor = <IColor>arguments[0];
				ppDest.r = this.r * c.r;
	            ppDest.g = this.g * c.g;
	            ppDest.b = this.b * c.b;
	            ppDest.a = this.a * c.a;
			}

            return ppDest;
		}


		divide(cColor: IColor, ppDest?: IColor): IColor;
		divide(fScalar:  number , ppDest?: IColor): IColor;
		divide(fScalar: any, ppDest: IColor = new Color): IColor {
			if (isNumber(fScalar)) {
				var f:  number  = < number >fScalar;
				ppDest.r = this.r / f;
	            ppDest.g = this.g / f;
	            ppDest.b = this.b / f;
	            ppDest.a = this.a / f;
			}
			else {
				var c: IColor = <IColor>arguments[0];
				ppDest.r = this.r / c.r;
	            ppDest.g = this.g / c.g;
	            ppDest.b = this.b / c.b;
	            ppDest.a = this.a / c.a;
			}

            return ppDest;
		}

		setHSB(fHue:  number , fSaturation:  number , fBrightness:  number ): IColor {
// wrap hue
			if (fHue > 1.0) {
				fHue -= < number >fHue;
			}
			else if (fHue < 0.0) {
				fHue += < number >fHue + 1;
			}

// clamp saturation / fBrightness
			fSaturation = math.min(fSaturation, 1.0);
			fSaturation = math.max(fSaturation, 0.0);
			fBrightness = math.min(fBrightness, 1.0);
			fBrightness = math.max(fBrightness, 0.0);

			if (fBrightness == 0.0) {
// early exit, this has to be black
				this.r = this.g = this.b = 0.0;
				return;
			}

			if (fSaturation == 0.0) {
// early exit, this has to be grey

				this.r = this.g = this.b = fBrightness;
				return;
			}


			var fHueDomain:  number   = fHue * 6.0;
			if (fHueDomain >= 6.0)
			{
// wrap around, and allow mathematical errors
				fHueDomain = 0.0;
			}

			var domain:  number  = < number >fHueDomain;
			var f1:  number  = fBrightness * (1 - fSaturation);
			var f2:  number  = fBrightness * (1 - fSaturation * (fHueDomain - domain));
			var f3:  number  = fBrightness * (1 - fSaturation * (1 - (fHueDomain - domain)));

			switch (domain) {
			case 0:
// red domain; green ascends
				this.r = fBrightness;
				this.g = f3;
				this.b = f1;
				break;
			case 1:
// yellow domain; red descends
				this.r = f2;
				this.g = fBrightness;
				this.b = f1;
				break;
			case 2:
// green domain; blue ascends
				this.r = f1;
				this.g = fBrightness;
				this.b = f3;
				break;
			case 3:
// cyan domain; green descends
				this.r = f1;
				this.g = f2;
				this.b = fBrightness;
				break;
			case 4:
// blue domain; red ascends
				this.r = f3;
				this.g = f1;
				this.b = fBrightness;
				break;
			case 5:
// magenta domain; blue descends
				this.r = fBrightness;
				this.g = f1;
				this.b = f2;
				break;
			}

			return this;
		}

		getHSB(pHsb:  number [] = [0., 0., 0.]):  number [] {
			var vMin:  number  = math.min(this.r, math.min(this.g, this.b));
			var vMax:  number  = math.max(this.r, math.max(this.g, this.b));
			var delta:  number  = vMax - vMin;

			var brightness:  number  = vMax;
			var hue:  number  = 0.;
			var saturation:  number ;

			if (math.isRealEqual(delta, 0.0, 1e-6)) {
// grey
				hue = 0.;
				saturation = 0.;
			}
			else {
// a colour
				saturation = delta / vMax;

				var deltaR:  number  = (((vMax - this.r) / 6.0) + (delta / 2.0)) / delta;
				var deltaG:  number  = (((vMax - this.g) / 6.0) + (delta / 2.0)) / delta;
				var deltaB:  number  = (((vMax - this.b) / 6.0) + (delta / 2.0)) / delta;

				if (math.isRealEqual(this.r, vMax))
					hue = deltaB - deltaG;
				else if (math.isRealEqual(this.g, vMax))
					hue = 0.3333333 + deltaR - deltaB;
				else if (math.isRealEqual(this.b, vMax))
					hue = 0.6666667 + deltaG - deltaR;

				if (hue < 0.0)
					hue += 1.0;
				if (hue > 1.0)
					hue -= 1.0;
			}

			pHsb[0] = hue;
			pHsb[1] = saturation;
			pHsb[2] = brightness;

			return pHsb;
		}

		toString(): string {
			return "{R: " + this.r + ", G: " + this.g + ", B: " + this.b + ", A: " + this.a + "} " +
			"( 0x" + this.rgba.toString(16) + " )";
		}

		static toFloat32Array(pValue: IColorValue): Float32Array {
			var pArr: Float32Array = new Float32Array(4);

			pArr[0] = pValue.r;
			pArr[1] = pValue.g;
			pArr[2] = pValue.b;
			pArr[3] = pValue.a;

			return pArr;
		}

		static BLACK: IColor = new Color(0);
		static isEqual(c1: IColorValue, c2: IColorValue): bool {
			return 	c1.r === c2.r &&
					c1.g === c2.g &&
					c1.b === c2.b &&
					c1.a === c2.a;
		}
	}
}

module akra {
	export var Color = util.Color;
}



module akra.material {
	export class Material implements IMaterial {
		name: string = null;

		diffuse: IColor = new Color(.5);
		ambient: IColor = new Color(.5);
		specular: IColor = new Color(.5);
		emissive: IColor = new Color(.5);
		shininess:  number  = 50.;

		constructor (sName: string = null, pMat?: IMaterial) {
			this.name = sName;

			if (isDefAndNotNull(pMat)) {
				this.set(pMat);
			}
		}

		set(pMat: IMaterialBase): IMaterial {
//this.name = pMat.name;

			this.diffuse.set(pMat.diffuse);
			this.ambient.set(pMat.ambient);
			this.specular.set(pMat.specular);
			this.emissive.set(pMat.emissive);
			this.shininess = pMat.shininess;

			return this;
		}

		isEqual(pMat: IMaterialBase): bool {
			return Color.isEqual(this.diffuse, pMat.diffuse) &&
			Color.isEqual(this.ambient, pMat.ambient) &&
			Color.isEqual(this.specular, pMat.specular) &&
			Color.isEqual(this.emissive, pMat.emissive) &&
				this.shininess === pMat.shininess;
		}
	}

	class FlexMaterial implements IFlexMaterial {
		name: string = null;

		/**@protected*/  _pData: IVertexData;

		inline get diffuse(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.DIFFUSE, 0, 1)); }
		inline get ambient(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.AMBIENT, 0, 1)); }
		inline get specular(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.SPECULAR, 0, 1)); }
		inline get emissive(): IColorValue { return new Color(this._pData.getTypedData(DeclUsages.EMISSIVE, 0, 1)); }
		inline get shininess():  number  { return this._pData.getTypedData(DeclUsages.SHININESS, 0, 1)[0]; }

		inline set diffuse(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.DIFFUSE); }
		inline set ambient(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.AMBIENT); }
		inline set specular(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.SPECULAR); }
		inline set emissive(pValue: IColorValue) { this._pData.setData(Color.toFloat32Array(pValue), DeclUsages.EMISSIVE); }
		inline set shininess(pValue:  number ) { this._pData.setData(new Float32Array([pValue]), DeclUsages.SHININESS); }

		inline get data(): IVertexData { return this._pData; }

		constructor (sName: string, pData: IVertexData) {
			this._pData = pData;
			this.name = sName;
		}

		set(pMat: IMaterial): IMaterial {
//this.name = 

			this.diffuse = pMat.diffuse;
			this.ambient = pMat.ambient;
			this.specular = pMat.specular;
			this.emissive = pMat.emissive;
			this.shininess = pMat.shininess;

			return this;

		}

		isEqual(pMat: IMaterial): bool {
			return Color.isEqual(this.diffuse, pMat.diffuse) &&
			Color.isEqual(this.ambient, pMat.ambient) &&
			Color.isEqual(this.specular, pMat.specular) &&
			Color.isEqual(this.emissive, pMat.emissive) &&
				this.shininess === pMat.shininess;
		}



		toString(): string {
			var s = "\nFLEX MATERIAL - " + this.name + "\n";
			s += "------------------------------------\n";
			s += "diffuse:   " + this.diffuse.toString() + "\n";
			s += "ambient:   " + this.ambient.toString() + "\n";
			s += "specular:  " + this.ambient.toString() + "\n";
			s += "emissive:  " + this.emissive.toString() + "\n";
			s += "shininess: " + this.shininess + "\n";

			return s;
		}


	}

	export  /**@const*/var  VERTEX_DECL: IVertexDeclaration = createVertexDeclaration(
		[
			VE_CUSTOM(DeclUsages.MATERIAL,  EDataTypes.FLOAT, 17),
			VE_CUSTOM(DeclUsages.DIFFUSE,   EDataTypes.FLOAT, 4, 0),
			VE_CUSTOM(DeclUsages.AMBIENT,   EDataTypes.FLOAT, 4, 16),
			VE_CUSTOM(DeclUsages.SPECULAR,  EDataTypes.FLOAT, 4, 32),
			VE_CUSTOM(DeclUsages.EMISSIVE,  EDataTypes.FLOAT, 4, 48),
			VE_CUSTOM(DeclUsages.SHININESS, EDataTypes.FLOAT, 1, 64)
        ]);

	export  /**@const*/var  DEFAULT: IMaterial = new Material;

	export function create(sName: string = null, pMat: IMaterial = null): IMaterial {
		return new Material(sName, pMat);
	}

	export function _createFlex(sName: string, pData: IVertexData): IMaterial {
		return new FlexMaterial(sName, pData);
	}
}

module akra {
	export var Material = material.Material;
}



module akra.core.pool.resources {
	export class SurfaceMaterial extends ResourcePoolItem implements ISurfaceMaterial {
		/**@protected*/  _pMaterial: IMaterial = new Material;
		/**@protected*/  _nTotalTextures:  number  = 0;
		/**@protected*/  _iTextureFlags:  number  = 0;
		/**@protected*/  _iTextureMatrixFlags:  number  = 0;
		/**@protected*/  _pTextures: ITexture[] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
		/**@protected*/  _pTexcoords:  number [] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);
		/**@protected*/  _pTextureMatrices: IMat4[] = new Array(SurfaceMaterial.MAX_TEXTURES_PER_SURFACE);



		inline get totalTextures():  number  { return this._nTotalTextures; }
    	inline get material(): IMaterial { return this._pMaterial; }
    	inline set material(pMaterial: IMaterial) { this._pMaterial.set(pMaterial); }
    	inline get textureFlags():  number  { return this._iTextureFlags; }
    	inline get textureMatrixFlags():  number  { return this._iTextureMatrixFlags; }

    	constructor () {
    		super();

    		for (var i:  number  = 0; i < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE; ++ i) {
    			this._pTexcoords[i] = i;
    		}
    	}

    	setTexture(iIndex:  number , iTextureHandle:  number , iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , sTexture: string, iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , pTexture: ITexture, iTexcoord:  number  = 0): bool;
    	setTexture(iIndex:  number , texture: any, iTexcoord:  number  = 0): bool {
//LOG(iIndex, pTexture, iTexcoord);
		    logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 40 ); logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");
                                          ;

		    var pRmgr: IResourcePoolManager = this.getManager();
		    var pTexture: ITexture = null;

		    this._pTexcoords[iIndex] = iTexcoord;

		    if (isString(texture)) {
		    	pTexture = this._pTextures[iIndex];

		        if (pTexture) {
//realise first

		            if (pTexture.release() == 0) {
		            	this._pTextures[iIndex] = null;
//pTexture.destroyResource();
		            }
		            else {
		            	logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 58 ); logger.warning("cannot destroy resource...");
		            }

		            ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		            -- this._nTotalTextures;
		        }


		        this._pTextures[iIndex] = <ITexture>pRmgr.texturePool.loadResource(<string>texture);

		        if (this._pTextures[iIndex]) {
		            ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;

		            ++ this._nTotalTextures;

		            this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);
		        }

		        return true;
		    }
		    else if (texture instanceof Texture) {
		        if (!this._pTextures[iIndex] || pTexture != this._pTextures[iIndex]) {
		            if (this._pTextures[iIndex]) {
// realise first
// DisplayManager.texturePool().releaseResource(this._pTextures[iIndex]);

		                if (this._pTextures[iIndex].release() == 0) {
// this._pTextureMatrices[iIndex].destroyResource();
		                	this._pTextures[iIndex] = null;
		                }
		                else {
		                	logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 89 ); logger.warning("cannot destroy resource..."); ;
		                }

		                ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		                -- this._nTotalTextures;
		            }

		            this._pTextures[iIndex] = pTexture;

		            this._pTextures[iIndex].addRef();
		            ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;
		            ++this._nTotalTextures;
		            this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);

// var me = this;
// trace('me get texture :)');
// pTexture.setChangesNotifyRoutine(function() {
//                 if (pTexture.isResourceLoaded()) {
//                     trace(arguments);
//                     trace('Texture <', pTexture.findResourceName(), '> loaded');
//                     if (me.isResourceLoaded()) {
//                         trace('Surface material loaded too.')
//                     }
//                 }
//             });
		        }

		        return true;
		    }
//similar to [cPoolHandle texture]
		    else if (isNumber(texture)) {
		        if (!this._pTextures[iIndex] || this._pTextures[iIndex].resourceHandle != < number >texture) {
		            if (this._pTextures[iIndex]) {
//TheGameHost.displayManager().texturePool().releaseResource(m_pTextures[index]);
		                if (this._pTextures[iIndex].release() === 0) {
// this._pTextures[iIndex].destroyResource();
		                	this._pTextures[iIndex] = null;
		                }
		                else {
		                	logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 128 ); logger.warning("cannot destroy resource..."); ;
		                }

		                ((this._iTextureFlags) &= ~ (1 << ((iIndex))) ) ;
		                -- this._nTotalTextures;
		            }

		            this._pTextures[iIndex] = <ITexture>pRmgr.texturePool.getResource(< number >texture);

		            if (this._pTextures[iIndex]) {
		                ((this._iTextureFlags) |= (1 << ((iIndex))) ) ;
		                ++ this._nTotalTextures;
		                this.sync(this._pTextures[iIndex], EResourceItemEvents.LOADED);
		            }
		        }

		        return true;
		    }

		    this._pTexcoords[iIndex] = iIndex;

		    return false;
    	}

    	setTextureMatrix(iIndex:  number , m4fValue: IMat4): bool {
    		logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 154 ); logger.assert(iIndex < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE, "invalid texture slot");
                                        ;

		    if (!m4fValue) {
		        this._pTextureMatrices[iIndex] = new Mat4();
		    }
		    else {
		        this._pTextureMatrices[iIndex] = new Mat4(m4fValue);
		    }

		    ((this._iTextureMatrixFlags) |= (1 << ((iIndex))) ) ;
		    return true;
    	}

    	inline setMaterial(pMaterial: IMaterial): void {
    		this._pMaterial.set(pMaterial);
    	}

    	isEqual(pSurfaceMaterial: ISurfaceMaterial): bool {
    		if (this._nTotalTextures === pSurfaceMaterial.totalTextures &&
		        this._iTextureFlags === pSurfaceMaterial.textureFlags &&
		        this._iTextureMatrixFlags === pSurfaceMaterial.textureMatrixFlags) {

		        if ((this._pMaterial && this._pMaterial.isEqual(pSurfaceMaterial.material))
		            || (pSurfaceMaterial.material === null)) {

		            for (var i = 0; i < this._pTextures.length; i++) {
		                if (this._pTextures[i] !== pSurfaceMaterial.texture[i]) {
		                    return false;
		                }
		            };

		            for (var i = 0; i< this._pTextureMatrices.length; ++ i) {
		                for (var j = 0; j < this._pTextureMatrices[i].data.length; j++) {
		                    if (this._pTextureMatrices[i].data[j] !== pSurfaceMaterial.textureMatrix[i].data[j]) {
		                        return false;
		                    }
		                };
		            }

		            return true;
		        }
		    }

		    return false;
    	}

    	inline texture(iSlot:  number ): ITexture {
    		logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 202 ); logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                                        ;
    		return this._pTextures[iSlot];
    	}

    	inline texcoord(iSlot:  number ):  number  {
    		logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 208 ); logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                                        ;
    		return this._pTexcoords[iSlot];
    	}

    	inline textureMatrix(iSlot:  number ): IMat4 {
    		logger.setSourceLocation( "resources/SurfaceMaterial.ts" , 214 ); logger.assert((iSlot >= 0 && iSlot < SurfaceMaterial.MAX_TEXTURES_PER_SURFACE), "invalid texture slot");
                                        ;
    		return this._pTextureMatrices[iSlot];
    	}

    	static MAX_TEXTURES_PER_SURFACE:  number  = 16;
	}
}


//#include "resources/Model.ts"











module akra.core.pool.resources {
	export class Effect implements IEffect extends ResourcePoolItem {
		get totalComponents():  number {
			return this.getComposer().getComponentCountForEffect(this);
		}

		get totalPasses():  number {
			return this.getComposer().getTotalPassesForEffect(this);
		}

		 constructor () {
            super();
        }

		isEqual(pEffect: IEffect): bool {return false;}
		isReplicated(): bool {return false;}
		isMixid(): bool {return false;}
		isParameterUsed(pParam: any, iPass?:  number ): bool {return false;}

		create(): void {
			this.getComposer() = this.manager.getEngine().getComposer();
			this.notifyRestored
		}

		replicable(bValue: bool): void {return;}
		miscible(bValue: bool): void {return;}

		addComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(sComponent: string, iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(pComponent: any, iShift?:  number  = 0, iPass?:  number  =  0xffffff , isSet?: bool = true): bool {
			var pComponentPool: IResourcePool = this.manager.componentPool;

			if(isInt(pComponent)) {
				pComponent = pComponentPool.getResource(< number >pComponent);
			}
			else if(isString(pComponent)){
				pComponent = pComponentPool.findResource(<string>pComponent);
			}

			if(!isDef(pComponent) || isNull(pComponent)){
				logger.setSourceLocation( "resources/Effect.ts" , 49 ); logger.error("Bad component for add/delete: ", pComponent); ;
				return false;
			}

			if(isSet){
				if(!this.getComposer().addComponentToEffect(this, <IAFXComponent>pComponent, iShift, iPass)){
					logger.setSourceLocation( "resources/Effect.ts" , 55 ); logger.error("Can not add component '" + <IAFXComponent>pComponent.findResourceName() + "'"); ;
					return false;
				}
			}
			else {
				if(!this.getComposer().removeComponentFromEffect(this, <IAFXComponent>pComponent, iShift, iPass)){
					logger.setSourceLocation( "resources/Effect.ts" , 61 ); logger.error("Can not delete component '" + <IAFXComponent>pComponent.findResourceName() + "'"); ;
					return false;
				}
			}

			this.notifyAltered();

		    if (this.totalComponents === 1 && isSet) {
		        this.notifyRestored();
		    }
		    else if (this.totalComponents === 0 && !isSet) {
		        this.notifyDisabled();
		    }

			return true;
		}

		delComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		delComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: any, iShift?:  number  = 0, iPass?:  number  =  0xffffff ): bool {
			return this.addComponent(pComponent, iShift, iPass, false);
		}

		activate(iShift?:  number  = 0): bool {
 			return this.getComposer().activateEffectResource(this, iShift);
		}

		deactivate(): bool {
			return this.getComposer().deactivateEffectResource(this);
		}

		findParameter(pParam: any, iPass?:  number ): any {return null;}

		private inline getComposer(): IAFXComposer {
			return this.manager.getEngine().getComposer();
		}
	}
}

















module akra {
	export enum EPixelFormats {
/*Unknown pixel format.*/
        UNKNOWN = 0,

/*8-bit pixel format, all bits luminance.*/
        L8 = 1,
        BYTE_L = L8,
/*16-bit pixel format, all bits luminance.*/
        L16 = 2,
        SHORT_L = L16,
/*8-bit pixel format, all bits alpha.*/
        A8 = 3,
        BYTE_A = A8,
/*8-bit pixel format, 4 bits alpha, 4 bits luminance.*/
        A4L4 = 4,
/*2 byte pixel format, 1 byte luminance, 1 byte alpha*/
        BYTE_LA = 5,

/*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        R5G6B5 = 6,
/*16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.*/
        B5G6R5 = 7,
/*8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.*/
        R3G3B2 = 31,
/*16-bit pixel format, 4 bits for alpha, red, green and blue.*/
        A4R4G4B4 = 8,
/*16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.*/
        A1R5G5B5 = 9,
/*24-bit pixel format, 8 bits for red, green and blue.*/
        R8G8B8 = 10,
/*24-bit pixel format, 8 bits for blue, green and red.*/
        B8G8R8 = 11,
/*32-bit pixel format, 8 bits for alpha, red, green and blue.*/
        A8R8G8B8 = 12,
/*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        A8B8G8R8 = 13,
/*32-bit pixel format, 8 bits for blue, green, red and alpha.*/
        B8G8R8A8 = 14,
/*32-bit pixel format, 8 bits for red, green, blue and alpha.*/
        R8G8B8A8 = 28,

/*32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue like A8R8G8B8, but alpha will get discarded*/
        X8R8G8B8 = 26,
/*32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red like A8B8G8R8, but alpha will get discarded*/
        X8B8G8R8 = 27,

/*3 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue*/
        BYTE_RGB = R8G8B8,
/*3 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red*/
        BYTE_BGR = B8G8R8,
/*4 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red and one byte for alpha*/
        BYTE_BGRA = B8G8R8A8,
/*4 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue, and one byte for alpha*/
        BYTE_RGBA = R8G8B8A8,

        BYTE_ABGR = A8B8G8R8,
        BYTE_ARGB = A8R8G8B8,

/*32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue.*/
        A2R10G10B10 = 15,
/*32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha.*/
        A2B10G10R10 = 16,

/*DDS (DirectDraw Surface) DXT1 format.*/
        DXT1 = 17,
/*DDS (DirectDraw Surface) DXT2 format.*/
        DXT2 = 18,
/*DDS (DirectDraw Surface) DXT3 format.*/
        DXT3 = 19,
/*DDS (DirectDraw Surface) DXT4 format.*/
        DXT4 = 20,
/*DDS (DirectDraw Surface) DXT5 format.*/
        DXT5 = 21,

/*16-bit pixel format, 16 bits (float) for red*/
        FLOAT16_R = 32,
/*48-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue*/
        FLOAT16_RGB = 22,
/*64-bit pixel format, 16 bits (float) for red, 16 bits (float) for green, 16 bits (float) for blue, 16 bits (float) for alpha*/
        FLOAT16_RGBA = 23,
/*32-bit pixel format, 32 bits (float) for red*/
        FLOAT32_R = 33,
/*96-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue*/
        FLOAT32_RGB = 24,
/*128-bit pixel format, 32 bits (float) for red, 32 bits (float) for green, 32 bits (float) for blue, 32 bits (float) for alpha*/
        FLOAT32_RGBA = 25,
/*32-bit, 2-channel s10e5 floating point pixel format, 16-bit green, 16-bit red*/
        FLOAT16_GR = 35,
/*64-bit, 2-channel floating point pixel format, 32-bit green, 32-bit red*/
        FLOAT32_GR = 36,

/*Float Depth texture format*/
        FLOAT32_DEPTH = 29,
        DEPTH8 = 44,
/*Byte Depth texture format */
        BYTE_DEPTH = DEPTH8,

        DEPTH16 = 45,
        SHORT_DEPTH = DEPTH16,
        DEPTH32 = 46,
        DEPTH24STENCIL8=47,


/*64-bit pixel format, 16 bits for red, green, blue and alpha*/
        SHORT_RGBA = 30,
/*32-bit pixel format, 16-bit green, 16-bit red*/
        SHORT_GR = 34,
/*48-bit pixel format, 16 bits for red, green and blue*/
        SHORT_RGB = 37,

/*PVRTC (PowerVR) RGB 2 bpp.*/
        PVRTC_RGB2 = 38,
/*PVRTC (PowerVR) RGBA 2 bpp.*/
        PVRTC_RGBA2 = 39,
/*PVRTC (PowerVR) RGB 4 bpp.*/
        PVRTC_RGB4 = 40,
/*PVRTC (PowerVR) RGBA 4 bpp.*/
        PVRTC_RGBA4 = 41,

/*8-bit pixel format, all bits red.*/
        R8 = 42,
/*16-bit pixel format, 8 bits red, 8 bits green.*/
        RG8 = 43,
        TOTAL = 48
    };

    export interface PixelFormatList {
    	[index:  number ]: EPixelFormats;
    }


/**
     * Flags defining some on/off properties of pixel formats
     */

    export enum  EPixelFormatFlags {
// This format has an alpha channel
        HASALPHA        = 0x00000001,
// This format is compressed. This invalidates the values in elemBytes,
// elemBits and the bit counts as these might not be fixed in a compressed format.
        COMPRESSED    = 0x00000002,
// This is a floating point format
        FLOAT           = 0x00000004,
// This is a depth format (for depth textures)
        DEPTH           = 0x00000008,
// Format is in native endian. Generally true for the 16, 24 and 32 bits
// formats which can be represented as machine integers.
        NATIVEENDIAN    = 0x00000010,
// This is an intensity format instead of a RGB one. The luminance
// replaces R,G and B. (but not A)
        LUMINANCE       = 0x00000020,
        STENCIL         = 0x00000040
    }

/** Pixel component format */

    export enum EPixelComponentTypes
    {
/*Byte per component (8 bit fixed 0.0..1.0)*/
        BYTE = 0,
/*Short per component (16 bit fixed 0.0..1.0))*/
        SHORT = 1,
        INT = 2,
/*16 bit float per component*/
        FLOAT16 = 3,
/*32 bit float per component*/
        FLOAT32 = 4,
/*Number of pixel types*/
        COUNT = 5
    };

    export enum EFilters {
        NEAREST,
        LINEAR,
        BILINEAR,
        BOX,
        TRIANGLE,
        BICUBIC
    };
}
















module akra {
	export interface IBox {
		width:  number ;
		height:  number ;
		depth:  number ;

		left:  number ;
		top:  number ;
		right:  number ;
		bottom:  number ;
		front:  number ;
		back:  number ;

		contains(pDest: IBox): bool;
	}
}




module akra {
	export interface IColor {} ;

	export interface IPixelBox extends IBox {
		format: EPixelFormats;
		data: Uint8Array;
		rowPitch:  number ;
		slicePitch:  number ;

		setConsecutive(): void;

		getRowSkip():  number ;
		getSliceSkip():  number ;

		isConsecutive(): bool;
		getConsecutiveSize():  number ;

		getSubBox(pDest: IBox): IPixelBox;
		getColorAt(x:  number , y:  number , z?:  number ): IColor;
		setColorAt(pColor: IColor, x:  number , y:  number , z?:  number ): void;

		scale(pDest: IPixelBox, eFilter?: EFilters): bool;
	}
}




module akra
{



    export enum EImageFlags {
		COMPRESSED = 0x00000001,
        CUBEMAP    = 0x00000002,
        TEXTURE_3D = 0x00000004,
	};

    export enum EImageCubeFlags{
        POSITIVE_X = 0x00000001,
        NEGATIVE_X = 0x00000002,
        POSITIVE_Y = 0x00000004,
        NEGATIVE_Y = 0x00000008,
        POSITIVE_Z = 0x0000000c,
        NEGATIVE_Z = 0x000000010,
        };

    export interface IImg extends IResourcePoolItem {
    	byteLength:  number ;

    	width:  number ;
    	height:  number ;
    	depth:  number ;

    	numFaces:  number ;
    	numMipMaps:  number ;
    	format: EPixelFormats;

        flags:  number ;
        cubeFlags: number ;


    	set(pSrc: IImg): IImg;

/** @param Destination image. If destination not specified, original image will be modified.*/

    	flipY(pDest?: IImg): IImg;
    	flipX(pDest?: IImg): IImg;


    	load(sFileName: string,  fnCallBack?: Function): IImg;
    	load(pData: Uint8Array, sType:string,  fnCallBack?: Function): IImg;
        load(pCanvas: HTMLCanvasElement, fnCallBack?: Function): IImg;


    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth?:  number , eFormat?: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): IImg;

        loadDynamicImage(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth?:  number ,
                         eFormat?: EPixelFormats, nFaces?:  number , nMipMaps?:  number ): IImg;


    	create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, nFaces:  number , nMipMaps:  number ): IImg ;

    	convert(eFormat: EPixelFormats): bool;

//Gets the physical width in bytes of each row of pixels.
    	getRawSpan():  number ;
        getPixelSize():  number ;
    	getBPP():  number ;
    	getData(): Uint8Array;

    	hasFlag(eFlag: EImageFlags): bool;

    	hasAlpha(): bool;
    	isCompressed(): bool;
    	isLuminance(): bool;

    	freeMemory();

    	getColorAt(pColor: IColor, x:  number , y:  number , z?: number ): IColor;
    	setColorAt(pColor: IColor, x:  number , y:  number , z?:  number ): void;

    	getPixels(nFace?:  number , iMipMap?:  number ): IPixelBox;

    	scale(pDest: IPixelBox, eFilter?: EFilters): bool;

    	resize(iWidth:  number , iHeight:  number , eFilter?: EFilters): bool;

    	generatePerlinNoise(fScale:  number , iOctaves:  number , fFalloff:  number ): void;
    	randomChannelNoise(iChannel:  number , iMinRange:  number , iMaxRange:  number ): void;
    }

}




























module akra {
	export interface IPathinfo {
		path: string;
		dirname: string;
		filename: string;
		ext: string;
		basename: string;


		set(sPath: string): void;
		set(pPath: IPathinfo): void;
		isAbsolute(): bool;

		toString(): string;
	}

}



module akra.util {
	export class Pathinfo implements IPathinfo {
		private _sDirname: string = null;
		private _sExtension: string = null;
		private _sFilename: string = null;

		inline get path(): string { return this.toString(); }
		inline set path(sPath: string) { this.set(sPath); }

		inline get dirname(): string { return this._sDirname; }
		inline set dirname(sDirname: string) { this._sDirname = sDirname; }

		inline get filename(): string { return this._sFilename; }
		inline set filename(sFilename: string) { this._sFilename = sFilename; }

		inline get ext(): string { return this._sExtension; }
		inline set ext(sExtension: string) { this._sExtension = sExtension; }

		inline get basename(): string {
			return (this._sFilename ? this._sFilename + (this._sExtension ? "." + this._sExtension : "") : "");
		}

		inline set basename(sBasename: string) {
			var nPos:  number  = sBasename.lastIndexOf(".");

	        if (nPos < 0) {
	            this._sFilename = sBasename.substr(0);
	            this._sExtension = null;
	        }
	        else {
	            this._sFilename = sBasename.substr(0, nPos);
	            this._sExtension = sBasename.substr(nPos + 1);
	        }
		}


		constructor (pPath: IPathinfo);
		constructor (sPath: string);
		constructor (pPath?: any) {
			if (isDef(pPath)) {
				this.set(<string>pPath);
			}
		}


		set(sPath: string): void;
		set(pPath: IPathinfo): void;
		set(sPath?: any) {
			if (isString(sPath)) {
		        var pParts: string[] = sPath.replace('\\', '/').split('/');

		        this.basename = pParts.pop();

		        this._sDirname = pParts.join('/');
		    }
		    else if (sPath instanceof Pathinfo) {
		        this._sDirname = sPath.dirname;
		        this._sFilename = sPath.filename;
		        this._sExtension = sPath.ext;
		    }
		    else {
//critical_error
		        logger.setSourceLocation( "Pathinfo.ts" , 68 ); logger.error("Unexpected data type was used."); ;
		    }
		}

		isAbsolute(): bool { return this._sDirname[0] === "/"; }


		toString(): string {
			return (this._sDirname ? this._sDirname + "/" : "") + (this.basename);
		}

	}

// export var pathinfo: (sPath: string) => IPathinfo;
// export var pathinfo: (pPath: IPathinfo) => IPathinfo;
	export var pathinfo: (pPath?) => IPathinfo;

	pathinfo = function (pPath?): IPathinfo {
		return new Pathinfo(pPath);
	}

}

module akra {
	export var Pathinfo = util.Pathinfo;
}










module akra {
	export interface IURI {
		scheme: string;
		userinfo: string;
		host: string;
		port:  number ;
		path: string;
		query: string;
		fragment: string;
		urn: string;
		url: string;
		authority: string;
		protocol: string;

		toString(): string;
	}
}



module akra.util {
	export class URI implements IURI {
		private sScheme: string = null;
		private sUserinfo: string = null;
		private sHost: string = null;
		private nPort:  number  = 0;
		private sPath: string = null;
		private sQuery: string = null;
		private sFragment: string = null;

		get urn(): string {
			return (this.sPath ? this.sPath : "") +
			(this.sQuery ? '?' + this.sQuery : "") +
			(this.sFragment ? '#' + this.sFragment : "");
		}

		get url(): string {
			return (this.sScheme ? this.sScheme : "") + this.authority;
		}

		get authority(): string {
			return (this.sHost ? '//' + (this.sUserinfo ? this.sUserinfo + '@' : "") +
				this.sHost + (this.nPort ? ':' + this.nPort : "") : "");
		}

		inline get scheme(): string {
			return this.sScheme;
		}

		get protocol(): string {
			if (!this.sScheme) {
				return this.sScheme;
			}

			return (this.sScheme.substr(0, this.sScheme.lastIndexOf(':')));
		}

		inline get userinfo(): string {
			return this.sUserinfo;
		}

		inline get host(): string {
			return this.sHost;
		}

		inline set host(sHost: string) {
//TODO: check host format
			this.sHost = sHost;
		}

		inline get port():  number  {
			return this.nPort;
		}

		inline set port(iPort:  number ) {
			this.nPort = iPort;
		}

		inline get path(): string {
			return this.sPath;
		}

		inline set path(sPath: string) {
// debug_assert(!isNull(sPath.match(new RegExp("^(/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)$"))), 
// 	"invalid path used: " + sPath);
//TODO: check path format
			this.sPath = sPath;
		}

		inline get query(): string {
//TODO: check query format
			return this.sQuery;
		}

		inline set query(sQuery: string) {
			this.sQuery = sQuery;
		}

		inline get fragment(): string {
			return this.sFragment;
		}


		constructor (pUri: URI);
		constructor (sUri: string);
		constructor (pUri?) {
			if (pUri) {
				this.set(pUri);
			}
		}

		set(pUri: URI);
		set(sUri: string);
		set(pData?): URI {
			if (isString(pData)) {
				var pUri:RegExpExecArray = URI.uriExp.exec(<string>pData);

				logger.setSourceLocation( "URI.ts" , 103 ); logger.assert(pUri !== null, 'Invalid URI format used.\nused uri: ' + pData); ;

				if (!pUri) {
					return null;
				}

				this.sScheme = pUri[1] || null;
				this.sUserinfo = pUri[2] || null;
				this.sHost = pUri[3] || null;
				this.nPort = parseInt(pUri[4]) || null;
				this.sPath = pUri[5] || pUri[6] || null;
				this.sQuery = pUri[7] || null;
				this.sFragment = pUri[8] || null;

				return this;

			}
			else if (pData instanceof URI) {
				return this.set(pData.toString());
			}

			logger.setSourceLocation( "URI.ts" , 124 ); logger.error('Unexpected data type was used.'); ;

			return null;
		}

		toString(): string {
			return this.url + this.urn;
		}

		static here(): IURI {
			return new URI(document.location.href);
		}

//------------------------------------------------------------------//
//----- Validate a URI -----//
//------------------------------------------------------------------//
//- The different parts are kept in their own groups and can be recombined
//  depending on the scheme:
//  - http as $1://$3:$4$5?$7#$8
//  - ftp as $1://$2@$3:$4$5
//  - mailto as $1:$6?$7
//- groups are as follows:
//  1   == scheme
//  2   == userinfo
//  3   == host
//  4   == port
//  5,6 == path (5 if it has an authority, 6 if it doesn't)
//  7   == query
//  8   == fragment


		static private uriExp:RegExp = new RegExp("^([a-z0-9+.-]+:)?(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})*(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$", "i");

/*
		 composed as follows:
		 ^
		 ([a-z0-9+.-]+):							#scheme
		 (?:
		 //							#it has an authority:
		 (?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?	#userinfo
		 ((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)		#host
		 (?::(\d*))?						#port
		 (/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
		 |
		 #it doesn't have an authority:
		 (/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?	#path
		 )
		 (?:
		 \?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#query string
		 )?
		 (?:
		 #((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*)	#fragment
		 )?
		 $
		 */

	}

	export var uri = (sUri:string): IURI => new util.URI(sUri);
}



// #include "ReferenceCounter.ts"
// #include "Singleton.ts"

// #include "BrowserInfo.ts"
// #include "ApiInfo.ts"
// #include "ScreenInfo.ts"
// #include "DeviceInfo.ts"

// #include "UtilTimer.ts"

// #include "Entity.ts"

// #include "ThreadManager.ts"

module akra.util {
//string to array buffer
	export var stoab = function (s: string): ArrayBuffer {
		var len:  number  = s.length;
		var pCodeList:  number [] = new Array(len);

	    for (var i:  number  = 0; i < len; ++i) {
/*& 0xFF;*/
	        pCodeList[ i ] = s.charCodeAt(i);
	    }

	    return (new Uint8Array(pCodeList)).buffer;
	}

	export var abtos = function (pBuf: ArrayBuffer): string {
		var pData: Uint8Array = new Uint8Array(pBuf);
	    var s: string = "";

	    for (var n:  number  = 0; n < pData.length; ++ n) {
	        s += String.fromCharCode(pData[n]);
	    }

	    return s;
	}


	export function abtota(pBuffer: ArrayBuffer, eType: EDataTypes): ArrayBufferView {
        switch (eType) {
            case EDataTypes.FLOAT:
                return new Float32Array(pBuffer);
            case EDataTypes.SHORT:
                return new Int16Array(pBuffer);
            case EDataTypes.UNSIGNED_SHORT:
                return new Uint16Array(pBuffer);
            case EDataTypes.INT:
                return new Int32Array(pBuffer);
            case EDataTypes.UNSIGNED_INT:
                return new Uint32Array(pBuffer);
            case EDataTypes.BYTE:
                return new Int8Array(pBuffer);
            default:
            case EDataTypes.UNSIGNED_BYTE:
                return new Uint8Array(pBuffer);
        }
    }


	export function parseJSON(sJSON: string): Object {
		return eval('(' + sJSON + ')');
	};

/**
	 * Преобразование html-сформированного текста
	 * в dom.
	 */

	export function parseHTML(sHTML: string, useDocFragment: bool = true): any {
	    var pDivEl: HTMLDivElement = <HTMLDivElement>document.createElement('div');
	    var pDocFrag: DocumentFragment;

	    pDivEl.innerHTML = sHTML;

	    if (!useDocFragment) {
	        return pDivEl.childNodes;
	    }

	    pDocFrag = document.createDocumentFragment();

	    for (var i = 0, len:  number  = pDivEl.childNodes.length; i < len; ++ i) {
	        if (!isDef(pDivEl.childNodes[i])) {
	            continue;
	        }

	        pDocFrag.appendChild(pDivEl.childNodes[i]);
	    }

	    return pDocFrag;
	};

}










module akra {
	export interface ICanvasInfo {
		width:  number ;
		height:  number ;
		id: string;
	}
}












module akra {
	export interface IBrowserInfo {
		name: string;
		version: string;
		os: string;
	}
}






module akra.util {
	export class Singleton {
		constructor () {
			var _constructor = (<any>this).constructor;

			logger.setSourceLocation( "Singleton.ts" , 10 ); logger.assert(!isDef(_constructor._pInstance), 'Singleton class may be created only one time.');
                                                    ;

			_constructor._pInstance = this;
		}
	}
}




module akra.util {
	export interface IBrowserData {
		string: string;
		subString: string;
		identity: string;
		versionSearch?: string;
		prop?: string;
	}

	export class BrowserInfo extends Singleton implements IBrowserInfo {
		private sBrowser: string = null;
		private sVersion: string = null;
		private sOS: string = null;
		private sVersionSearch: string = null;

		get name(): string {
			return this.sBrowser;
		}

		get version(): string {
			return this.sVersion;
		}

		get os(): string {
			return this.sOS;
		}

		private init(): void {
			this.sBrowser = this.searchString(BrowserInfo.dataBrowser) || "An unknown browser";
			this.sVersion = this.searchVersion(navigator.userAgent)
								|| this.searchVersion(navigator.appVersion)
				|| "an unknown version";
			this.sOS = this.searchString(BrowserInfo.dataOS) || "an unknown OS";
		}

		private searchString(pDataBrowser: IBrowserData[]): string {
			for (var i: number  = 0; i < pDataBrowser.length; i++) {
				var sData:string = pDataBrowser[i].string;
				var dataProp:string = pDataBrowser[i].prop;

				this.sVersionSearch = pDataBrowser[i].versionSearch || pDataBrowser[i].identity;

				if (sData) {
					if (sData.indexOf(pDataBrowser[i].subString) != -1) {
						return pDataBrowser[i].identity;
					}
				}
				else if (dataProp) {
					return pDataBrowser[i].identity;
				}
			}
			return null;
		}

		private searchVersion(sData: string): string {
			var iStartIndex: number  = sData.indexOf(this.sVersionSearch);

			if (iStartIndex == -1) {
				return null;
			}

			iStartIndex = sData.indexOf('/', iStartIndex + 1);

			if (iStartIndex == -1) {
				return null;
			}

			var iEndIndex: number  = sData.indexOf(' ', iStartIndex + 1);

			if (iEndIndex == -1) {
				iEndIndex = sData.indexOf(';', iStartIndex + 1);
				if (iEndIndex == -1) {
					return null;
				}
				return sData.slice(iStartIndex + 1);
			}

			return sData.slice((iStartIndex + 1), iEndIndex);
		}

		static private dataBrowser: IBrowserData[] = [
			{
				string: navigator.userAgent,
				subString: "Chrome",
				identity: "Chrome"
			},
			{
				string: navigator.userAgent,
				subString: "OmniWeb",
				versionSearch: "OmniWeb/",
				identity: "OmniWeb"
			},
			{
				string: navigator.vendor,
				subString: "Apple",
				identity: "Safari",
				versionSearch: "Version"
			},
			{
				prop: window.opera,
				identity: "Opera",
				versionSearch: "Version"
			},
			{
				string: navigator.vendor,
				subString: "iCab",
				identity: "iCab"
			},
			{
				string: navigator.vendor,
				subString: "KDE",
				identity: "Konqueror"
			},
			{
				string: navigator.userAgent,
				subString: "Firefox",
				identity: "Firefox"
			},
			{
				string: navigator.vendor,
				subString: "Camino",
				identity: "Camino"
			},
			{
// for newer Netscapes (6+)
				string: navigator.userAgent,
				subString: "Netscape",
				identity: "Netscape"
			},
			{
				string: navigator.userAgent,
				subString: "MSIE",
				identity: "Explorer",
				versionSearch: "MSIE"
			},
			{
				string: navigator.userAgent,
				subString: "Gecko",
				identity: "Mozilla",
				versionSearch: "rv"
			},
			{
// for older Netscapes (4-)
				string: navigator.userAgent,
				subString: "Mozilla",
				identity: "Netscape",
				versionSearch: "Mozilla"
			}
		];

		static private dataOS: IBrowserData[] = [
			{
				string    : navigator.platform,
				subString : "Win",
				identity  : "Windows"
			},
			{
				string    : navigator.platform,
				subString : "Mac",
				identity  : "Mac"
			},
			{
				string    : navigator.userAgent,
				subString : "iPhone",
				identity  : "iPhone/iPod"
			},
			{
				string    : navigator.platform,
				subString : "Linux",
				identity  : "Linux"
			}
		];
	}
}











module akra {
	export interface IScreenInfo {
		width:  number ;
		height:  number ;
		aspect:  number ;
		pixelDepth:  number ;
		colorDepth:  number ;
	}
}



module akra.util {
	export class ScreenInfo implements IScreenInfo {
		get width():  number  {
			return screen.width;
		}

		get height():  number  {
			return screen.height;
		}

		get aspect():  number  {
			return screen.width / screen.height;
		}

		get pixelDepth():  number  {
			return screen.pixelDepth;
		}

		get colorDepth():  number  {
			return screen.colorDepth;
		}
	}
}










module akra {
	export interface IApiInfo {
		gamepad: bool;
		webGL: bool;
		webAudio: bool;
		file: bool;
		fileSystem: bool;
		webWorker: bool;
		transferableObjects: bool;
		localStorage: bool;
		webSocket: bool;
	}
}









// see: http://www.khronos.org/registry/webgl/specs/latest/

interface WebGLObject
{
};

interface WebGLBuffer extends WebGLObject
{
};

interface WebGLFramebuffer extends WebGLObject
{
};

interface WebGLProgram extends WebGLObject
{
};

interface WebGLRenderbuffer extends WebGLObject
{
};

interface WebGLShader extends WebGLObject
{
};

interface WebGLTexture extends WebGLObject
{
};

interface WebGLUniformLocation
{
};

interface WebGLActiveInfo
{
	size: number;
	type: number;
	name: string;
};

interface WebGLShaderPrecisionFormat
{
	rangeMin: number;
	rangeMax: number;
	precision: number;
};


interface WebGLContextAttributes
{
	alpha?: bool;
	depth?: bool;
	stencil?: bool;
	antialias?: bool;
	premultipliedAlpha?: bool;
	preserveDrawingBuffer?: bool;
};

interface WebGLRenderingContext
{
/* ClearBufferMask */

	DEPTH_BUFFER_BIT: number;
	STENCIL_BUFFER_BIT: number;
	COLOR_BUFFER_BIT: number;

/* BeginMode */

	POINTS: number;
	LINES: number;
	LINE_LOOP: number;
	LINE_STRIP: number;
	TRIANGLES: number;
	TRIANGLE_STRIP: number;
	TRIANGLE_FAN: number;

/* AlphaFunction (not supported in ES20) */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* BlendingFactorDest */

	ZERO: number;
	ONE: number;
	SRC_COLOR: number;
	ONE_MINUS_SRC_COLOR: number;
	SRC_ALPHA: number;
	ONE_MINUS_SRC_ALPHA: number;
	DST_ALPHA: number;
	ONE_MINUS_DST_ALPHA: number;

/* BlendingFactorSrc */

/*      ZERO */

/*      ONE */

	DST_COLOR: number;
	ONE_MINUS_DST_COLOR: number;
	SRC_ALPHA_SATURATE: number;
/*      SRC_ALPHA */

/*      ONE_MINUS_SRC_ALPHA */

/*      DST_ALPHA */

/*      ONE_MINUS_DST_ALPHA */


/* BlendEquationSeparate */

	FUNC_ADD: number;
	BLEND_EQUATION: number;
	BLEND_EQUATION_RGB: number;
	BLEND_EQUATION_ALPHA: number;

/* BlendSubtract */

	FUNC_SUBTRACT: number;
	FUNC_REVERSE_SUBTRACT: number;

/* Separate Blend Functions */

	BLEND_DST_RGB: number;
	BLEND_SRC_RGB: number;
	BLEND_DST_ALPHA: number;
	BLEND_SRC_ALPHA: number;
	CONSTANT_COLOR: number;
	ONE_MINUS_CONSTANT_COLOR: number;
	CONSTANT_ALPHA: number;
	ONE_MINUS_CONSTANT_ALPHA: number;
	BLEND_COLOR: number;

/* Buffer Objects */

	ARRAY_BUFFER: number;
	ELEMENT_ARRAY_BUFFER: number;
	ARRAY_BUFFER_BINDING: number;
	ELEMENT_ARRAY_BUFFER_BINDING: number;

	STREAM_DRAW: number;
	STATIC_DRAW: number;
	DYNAMIC_DRAW: number;

	BUFFER_SIZE: number;
	BUFFER_USAGE: number;

	CURRENT_VERTEX_ATTRIB: number;

/* CullFaceMode */

	FRONT: number;
	BACK: number;
	FRONT_AND_BACK: number;

/* DepthFunction */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* EnableCap */

/* TEXTURE_2D */

	CULL_FACE: number;
	BLEND: number;
	DITHER: number;
	STENCIL_TEST: number;
	DEPTH_TEST: number;
	SCISSOR_TEST: number;
	POLYGON_OFFSET_FILL: number;
	SAMPLE_ALPHA_TO_COVERAGE: number;
	SAMPLE_COVERAGE: number;

/* ErrorCode */

	NO_ERROR: number;
	INVALID_ENUM: number;
	INVALID_VALUE: number;
	INVALID_OPERATION: number;
	OUT_OF_MEMORY: number;

/* FrontFaceDirection */

	CW: number;
	CCW: number;

/* GetPName */

	LINE_WIDTH: number;
	ALIASED_POINT_SIZE_RANGE: number;
	ALIASED_LINE_WIDTH_RANGE: number;
	CULL_FACE_MODE: number;
	FRONT_FACE: number;
	DEPTH_RANGE: number;
	DEPTH_WRITEMASK: number;
	DEPTH_CLEAR_VALUE: number;
	DEPTH_FUNC: number;
	STENCIL_CLEAR_VALUE: number;
	STENCIL_FUNC: number;
	STENCIL_FAIL: number;
	STENCIL_PASS_DEPTH_FAIL: number;
	STENCIL_PASS_DEPTH_PASS: number;
	STENCIL_REF: number;
	STENCIL_VALUE_MASK: number;
	STENCIL_WRITEMASK: number;
	STENCIL_BACK_FUNC: number;
	STENCIL_BACK_FAIL: number;
	STENCIL_BACK_PASS_DEPTH_FAIL: number;
	STENCIL_BACK_PASS_DEPTH_PASS: number;
	STENCIL_BACK_REF: number;
	STENCIL_BACK_VALUE_MASK: number;
	STENCIL_BACK_WRITEMASK: number;
	VIEWPORT: number;
	SCISSOR_BOX: number;
/*      SCISSOR_TEST */

	COLOR_CLEAR_VALUE: number;
	COLOR_WRITEMASK: number;
	UNPACK_ALIGNMENT: number;
	PACK_ALIGNMENT: number;
	MAX_TEXTURE_SIZE: number;
	MAX_VIEWPORT_DIMS: number;
	SUBPIXEL_BITS: number;
	RED_BITS: number;
	GREEN_BITS: number;
	BLUE_BITS: number;
	ALPHA_BITS: number;
	DEPTH_BITS: number;
	STENCIL_BITS: number;
	POLYGON_OFFSET_UNITS: number;
/*      POLYGON_OFFSET_FILL */

	POLYGON_OFFSET_FACTOR: number;
	TEXTURE_BINDING_2D: number;
	SAMPLE_BUFFERS: number;
	SAMPLES: number;
	SAMPLE_COVERAGE_VALUE: number;
	SAMPLE_COVERAGE_INVERT: number;

/* GetTextureParameter */

/*      TEXTURE_MAG_FILTER */

/*      TEXTURE_MIN_FILTER */

/*      TEXTURE_WRAP_S */

/*      TEXTURE_WRAP_T */


	COMPRESSED_TEXTURE_FORMATS: number;

/* HintMode */

	DONT_CARE: number;
	FASTEST: number;
	NICEST: number;

/* HintTarget */

	GENERATE_MIPMAP_HINT: number;

/* DataType */

	BYTE: number;
	UNSIGNED_BYTE: number;
	SHORT: number;
	UNSIGNED_SHORT: number;
	INT: number;
	UNSIGNED_INT: number;
	FLOAT: number;

/* PixelFormat */

	DEPTH_COMPONENT: number;
	ALPHA: number;
	RGB: number;
	RGBA: number;
	LUMINANCE: number;
	LUMINANCE_ALPHA: number;

/* PixelType */

/*      UNSIGNED_BYTE */

	UNSIGNED_SHORT_4_4_4_4: number;
	UNSIGNED_SHORT_5_5_5_1: number;
	UNSIGNED_SHORT_5_6_5: number;

/* Shaders */

	FRAGMENT_SHADER: number;
	VERTEX_SHADER: number;
	MAX_VERTEX_ATTRIBS: number;
	MAX_VERTEX_UNIFORM_VECTORS: number;
	MAX_VARYING_VECTORS: number;
	MAX_COMBINED_TEXTURE_IMAGE_UNITS: number;
	MAX_VERTEX_TEXTURE_IMAGE_UNITS: number;
	MAX_TEXTURE_IMAGE_UNITS: number;
	MAX_FRAGMENT_UNIFORM_VECTORS: number;
	SHADER_TYPE: number;
	DELETE_STATUS: number;
	LINK_STATUS: number;
	VALIDATE_STATUS: number;
	ATTACHED_SHADERS: number;
	ACTIVE_UNIFORMS: number;
	ACTIVE_ATTRIBUTES: number;
	SHADING_LANGUAGE_VERSION: number;
	CURRENT_PROGRAM: number;

/* StencilFunction */

	NEVER: number;
	LESS: number;
	EQUAL: number;
	LEQUAL: number;
	GREATER: number;
	NOTEQUAL: number;
	GEQUAL: number;
	ALWAYS: number;

/* StencilOp */

/*      ZERO */

	KEEP: number;
	REPLACE: number;
	INCR: number;
	DECR: number;
	INVERT: number;
	INCR_WRAP: number;
	DECR_WRAP: number;

/* StringName */

	VENDOR: number;
	RENDERER: number;
	VERSION: number;

/* TextureMagFilter */

	NEAREST: number;
	LINEAR: number;

/* TextureMinFilter */

/*      NEAREST */

/*      LINEAR */

	NEAREST_MIPMAP_NEAREST: number;
	LINEAR_MIPMAP_NEAREST: number;
	NEAREST_MIPMAP_LINEAR: number;
	LINEAR_MIPMAP_LINEAR: number;

/* TextureParameterName */

	TEXTURE_MAG_FILTER: number;
	TEXTURE_MIN_FILTER: number;
	TEXTURE_WRAP_S: number;
	TEXTURE_WRAP_T: number;

/* TextureTarget */

	TEXTURE_2D: number;
	TEXTURE: number;

	TEXTURE_CUBE_MAP: number;
	TEXTURE_BINDING_CUBE_MAP: number;
	TEXTURE_CUBE_MAP_POSITIVE_X: number;
	TEXTURE_CUBE_MAP_NEGATIVE_X: number;
	TEXTURE_CUBE_MAP_POSITIVE_Y: number;
	TEXTURE_CUBE_MAP_NEGATIVE_Y: number;
	TEXTURE_CUBE_MAP_POSITIVE_Z: number;
	TEXTURE_CUBE_MAP_NEGATIVE_Z: number;
	MAX_CUBE_MAP_TEXTURE_SIZE: number;

/* TextureUnit */

	TEXTURE0: number;
	TEXTURE1: number;
	TEXTURE2: number;
	TEXTURE3: number;
	TEXTURE4: number;
	TEXTURE5: number;
	TEXTURE6: number;
	TEXTURE7: number;
	TEXTURE8: number;
	TEXTURE9: number;
	TEXTURE10: number;
	TEXTURE11: number;
	TEXTURE12: number;
	TEXTURE13: number;
	TEXTURE14: number;
	TEXTURE15: number;
	TEXTURE16: number;
	TEXTURE17: number;
	TEXTURE18: number;
	TEXTURE19: number;
	TEXTURE20: number;
	TEXTURE21: number;
	TEXTURE22: number;
	TEXTURE23: number;
	TEXTURE24: number;
	TEXTURE25: number;
	TEXTURE26: number;
	TEXTURE27: number;
	TEXTURE28: number;
	TEXTURE29: number;
	TEXTURE30: number;
	TEXTURE31: number;
	ACTIVE_TEXTURE: number;

/* TextureWrapMode */

	REPEAT: number;
	CLAMP_TO_EDGE: number;
	MIRRORED_REPEAT: number;

/* Uniform Types */

	FLOAT_VEC2: number;
	FLOAT_VEC3: number;
	FLOAT_VEC4: number;
	INT_VEC2: number;
	INT_VEC3: number;
	INT_VEC4: number;
	BOOL: number;
	BOOL_VEC2: number;
	BOOL_VEC3: number;
	BOOL_VEC4: number;
	FLOAT_MAT2: number;
	FLOAT_MAT3: number;
	FLOAT_MAT4: number;
	SAMPLER_2D: number;
	SAMPLER_CUBE: number;

/* Vertex Arrays */

	VERTEX_ATTRIB_ARRAY_ENABLED: number;
	VERTEX_ATTRIB_ARRAY_SIZE: number;
	VERTEX_ATTRIB_ARRAY_STRIDE: number;
	VERTEX_ATTRIB_ARRAY_TYPE: number;
	VERTEX_ATTRIB_ARRAY_NORMALIZED: number;
	VERTEX_ATTRIB_ARRAY_POINTER: number;
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: number;

/* Shader Source */

	COMPILE_STATUS: number;

/* Shader Precision-Specified Types */

	LOW_FLOAT: number;
	MEDIUM_FLOAT: number;
	HIGH_FLOAT: number;
	LOW_INT: number;
	MEDIUM_INT: number;
	HIGH_INT: number;

/* Framebuffer Object. */

	FRAMEBUFFER: number;
	RENDERBUFFER: number;

	RGBA4: number;
	RGB5_A1: number;
	RGB565: number;
	DEPTH_COMPONENT16: number;
	STENCIL_INDEX: number;
	STENCIL_INDEX8: number;
	DEPTH_STENCIL: number;

	RENDERBUFFER_WIDTH: number;
	RENDERBUFFER_HEIGHT: number;
	RENDERBUFFER_INTERNAL_FORMAT: number;
	RENDERBUFFER_RED_SIZE: number;
	RENDERBUFFER_GREEN_SIZE: number;
	RENDERBUFFER_BLUE_SIZE: number;
	RENDERBUFFER_ALPHA_SIZE: number;
	RENDERBUFFER_DEPTH_SIZE: number;
	RENDERBUFFER_STENCIL_SIZE: number;

	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: number;
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: number;
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: number;
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: number;

	COLOR_ATTACHMENT0: number;
	DEPTH_ATTACHMENT: number;
	STENCIL_ATTACHMENT: number;
	DEPTH_STENCIL_ATTACHMENT: number;

	NONE: number;

	FRAMEBUFFER_COMPLETE: number;
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT: number;
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: number;
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS: number;
	FRAMEBUFFER_UNSUPPORTED: number;

	FRAMEBUFFER_BINDING: number;
	RENDERBUFFER_BINDING: number;
	MAX_RENDERBUFFER_SIZE: number;

	INVALID_FRAMEBUFFER_OPERATION: number;

/* WebGL-specific enums */

	UNPACK_FLIP_Y_WEBGL: number;
	UNPACK_PREMULTIPLY_ALPHA_WEBGL: number;
	CONTEXT_LOST_WEBGL: number;
	UNPACK_COLORSPACE_CONVERSION_WEBGL: number;
	BROWSER_DEFAULT_WEBGL: number;




	canvas: HTMLCanvasElement;
	drawingBufferWidth: number;
	drawingBufferHeight: number;

	getContextAttributes(): WebGLContextAttributes;
	isContextLost(): bool;

	getSupportedExtensions(): string[];
	getExtension(name: string): any;

	activeTexture(texture: number): void;
	attachShader(program: WebGLProgram, shader: WebGLShader): void;
	bindAttribLocation(program: WebGLProgram, index: number, name: string): void;
	bindBuffer(target: number, buffer: WebGLBuffer): void;
	bindFramebuffer(target: number, framebuffer: WebGLFramebuffer): void;
	bindRenderbuffer(target: number, renderbuffer: WebGLRenderbuffer): void;
	bindTexture(target: number, texture: WebGLTexture): void;
	blendColor(red: number, green: number, blue: number, alpha: number): void;
	blendEquation(mode: number): void;
	blendEquationSeparate(modeRGB: number, modeAlpha: number): void;
	blendFunc(sfactor: number, dfactor: number): void;
	blendFuncSeparate(srcRGB: number, dstRGB: number, srcAlpha: number, dstAlpha: number): void;

	bufferData(target: number, size: number, usage: number): void;
	bufferData(target: number, data: ArrayBufferView, usage: number): void;
	bufferData(target: number, data: ArrayBuffer, usage: number): void;
	bufferSubData(target: number, offset: number, data: ArrayBufferView): void;
	bufferSubData(target: number, offset: number, data: ArrayBuffer): void;

	checkFramebufferStatus(target: number): number;
	clear(mask: number): void;
	clearColor(red: number, green: number, blue: number, alpha: number): void;
	clearDepth(depth: number): void;
	clearStencil(s: number): void;
	colorMask(red: bool, green: bool, blue: bool, alpha: bool): void;
	compileShader(shader: WebGLShader): void;

	compressedTexImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, data: ArrayBufferView): void;
	compressedTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, data: ArrayBufferView): void;

	copyTexImage2D(target: number, level: number, internalformat: number, x: number, y: number, width: number, height: number, border: number): void;
	copyTexSubImage2D(target: number, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;

	createBuffer(): WebGLBuffer;
	createFramebuffer(): WebGLFramebuffer;
	createProgram(): WebGLProgram;
	createRenderbuffer(): WebGLRenderbuffer;
	createShader(type: number): WebGLShader;
	createTexture(): WebGLTexture;

	cullFace(mode: number): void;

	deleteBuffer(buffer: WebGLBuffer): void;
	deleteFramebuffer(framebuffer: WebGLFramebuffer): void;
	deleteProgram(program: WebGLProgram): void;
	deleteRenderbuffer(renderbuffer: WebGLRenderbuffer): void;
	deleteShader(shader: WebGLShader): void;
	deleteTexture(texture: WebGLTexture): void;

	depthFunc(func: number): void;
	depthMask(flag: bool): void;
	depthRange(zNear: number, zFar: number): void;
	detachShader(program: WebGLProgram, shader: WebGLShader): void;
	disable(cap: number): void;
	disableVertexAttribArray(index: number): void;
	drawArrays(mode: number, first: number, count: number): void;
	drawElements(mode: number, count: number, type: number, offset: number): void;

	enable(cap: number): void;
	enableVertexAttribArray(index: number): void;
	finish(): void;
	flush(): void;
	framebufferRenderbuffer(target: number, attachment: number, renderbuffertarget: number, renderbuffer: WebGLRenderbuffer): void;
	framebufferTexture2D(target: number, attachment: number, textarget: number, texture: WebGLTexture, level: number): void;
	frontFace(mode: number): void;

	generateMipmap(target: number): void;

	getActiveAttrib(program: WebGLProgram, index: number): WebGLActiveInfo;
	getActiveUniform(program: WebGLProgram, index: number): WebGLActiveInfo;
	getAttachedShaders(program: WebGLProgram): WebGLShader[];

	getAttribLocation(program: WebGLProgram, name: string): number;

	getBufferParameter(target: number, pname: number): any;
	getParameter(pname: number): any;

	getError(): number;

	getFramebufferAttachmentParameter(target: number, attachment: number, pname: number): any;
	getProgramParameter(program: WebGLProgram, pname: number): any;
	getProgramInfoLog(program: WebGLProgram): string;
	getRenderbufferParameter(target: number, pname: number): any;
	getTranslatedShaderSource(shader: WebGLShader): string;
	getShaderParameter(shader: WebGLShader, pname: number): any;
	getShaderPrecisionFormat(shadertype: number, precisiontype: number): WebGLShaderPrecisionFormat;
	getShaderInfoLog(shader: WebGLShader): string;

	getShaderSource(shader: WebGLShader): string;

	getTexParameter(target: number, pname: number): any;

	getUniform(program: WebGLProgram, location: WebGLUniformLocation): any;

	getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation;

	getVertexAttrib(index: number, pname: number): any;

	getVertexAttribOffset(index: number, pname: number): number;

	hint(target: number, mode: number): void;
	isBuffer(buffer: WebGLBuffer): bool;
	isEnabled(cap: number): bool;
	isFramebuffer(framebuffer: WebGLFramebuffer): bool;
	isProgram(program: WebGLProgram): bool;
	isRenderbuffer(renderbuffer: WebGLRenderbuffer): bool;
	isShader(shader: WebGLShader): bool;
	isTexture(texture: WebGLTexture): bool;
	lineWidth(width: number): void;
	linkProgram(program: WebGLProgram): void;
	pixelStorei(pname: number, param: number): void;
	polygonOffset(factor: number, units: number): void;

	readPixels(x: number, y: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView): void;

	renderbufferStorage(target: number, internalformat: number, width: number, height: number): void;
	sampleCoverage(value: number, invert: bool): void;
	scissor(x: number, y: number, width: number, height: number): void;

	shaderSource(shader: WebGLShader, source: string): void;

	stencilFunc(func: number, ref: number, mask: number): void;
	stencilFuncSeparate(face: number, func: number, ref: number, mask: number): void;
	stencilMask(mask: number): void;
	stencilMaskSeparate(face: number, mask: number): void;
	stencilOp(fail: number, zfail: number, zpass: number): void;
	stencilOpSeparate(face: number, fail: number, zfail: number, zpass: number): void;

	texImage2D(target: number, level: number, internalformat: number, width: number, height: number, border: number, format: number, type: number, pixels: ArrayBufferView): void;
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, pixels: ImageData): void;
/* May throw DOMException*/
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, image: HTMLImageElement): void;
/* May throw DOMException*/
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, canvas: HTMLCanvasElement): void;
/* May throw DOMException*/
	texImage2D(target: number, level: number, internalformat: number, format: number, type: number, video: HTMLVideoElement): void;

	texParameterf(target: number, pname: number, param: number): void;
	texParameteri(target: number, pname: number, param: number): void;

	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, width: number, height: number, format: number, type: number, pixels: ArrayBufferView): void;
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, pixels: ImageData): void;
/* May throw DOMException*/
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, image: HTMLImageElement): void;
/* May throw DOMException*/
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, canvas: HTMLCanvasElement): void;
/* May throw DOMException*/
	texSubImage2D(target: number, level: number, xoffset: number, yoffset: number, format: number, type: number, video: HTMLVideoElement): void;

	uniform1f(location: WebGLUniformLocation, x: number): void;
	uniform1fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform1fv(location: WebGLUniformLocation, v: number[]): void;
	uniform1i(location: WebGLUniformLocation, x: number): void;
	uniform1iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform1iv(location: WebGLUniformLocation, v: number[]): void;
	uniform2f(location: WebGLUniformLocation, x: number, y: number): void;
	uniform2fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform2fv(location: WebGLUniformLocation, v: number[]): void;
	uniform2i(location: WebGLUniformLocation, x: number, y: number): void;
	uniform2iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform2iv(location: WebGLUniformLocation, v: number[]): void;
	uniform3f(location: WebGLUniformLocation, x: number, y: number, z: number): void;
	uniform3fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform3fv(location: WebGLUniformLocation, v: number[]): void;
	uniform3i(location: WebGLUniformLocation, x: number, y: number, z: number): void;
	uniform3iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform3iv(location: WebGLUniformLocation, v: number[]): void;
	uniform4f(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
	uniform4fv(location: WebGLUniformLocation, v: Float32Array): void;
	uniform4fv(location: WebGLUniformLocation, v: number[]): void;
	uniform4i(location: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
	uniform4iv(location: WebGLUniformLocation, v: Int32Array): void;
	uniform4iv(location: WebGLUniformLocation, v: number[]): void;

	uniformMatrix2fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix2fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix3fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: bool, value: Float32Array): void;
	uniformMatrix4fv(location: WebGLUniformLocation, transpose: bool, value: number[]): void;

	useProgram(program: WebGLProgram): void;
	validateProgram(program: WebGLProgram): void;

	vertexAttrib1f(indx: number, x: number): void;
	vertexAttrib1fv(indx: number, values: Float32Array): void;
	vertexAttrib1fv(indx: number, value: number[]): void;
	vertexAttrib2f(indx: number, x: number, y: number): void;
	vertexAttrib2fv(indx: number, values: Float32Array): void;
	vertexAttrib2fv(indx: number, value: number[]): void;
	vertexAttrib3f(indx: number, x: number, y: number, z: number): void;
	vertexAttrib3fv(indx: number, values: Float32Array): void;
	vertexAttrib3fv(indx: number, value: number[]): void;
	vertexAttrib4f(indx: number, x: number, y: number, z: number, w: number): void;
	vertexAttrib4fv(indx: number, values: Float32Array): void;
	vertexAttrib4fv(indx: number, value: number[]): void;
	vertexAttribPointer(indx: number, size: number, type: number, normalized: bool, stride: number, offset: number): void;

	viewport(x: number, y: number, width: number, height: number): void;
};

interface CanvasRenderingContext {

}

interface WebGLRenderingContext extends CanvasRenderingContext {

}



declare var WebGLRenderingContext: {
    prototype: WebGLRenderingContext;
    new(): WebGLRenderingContext;
}

interface HTMLCanvasElement extends HTMLElement {
    getContext(contextId: string, args: WebGLContextAttributes): WebGLRenderingContext;
}

interface WEBGL_debug_shaders {
      getTranslatedShaderSource(shader: WebGLShader): DOMString;
};

interface WEBGL_debug_renderer_info {
    UNMASKED_VENDOR_WEBGL: number;
    UNMASKED_RENDERER_WEBGL: number;
};

interface WEBGL_compressed_texture_pvrtc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: number;
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: number;
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: number;
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: number;
};

interface WEBGL_compressed_texture_atc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_ATC_WEBGL: number;
    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: number;
    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: number;
};

interface WEBGL_compressed_texture_s3tc {
/* Compressed Texture Formats */

    COMPRESSED_RGB_S3TC_DXT1_EXT : number;
    COMPRESSED_RGBA_S3TC_DXT1_EXT: number;
    COMPRESSED_RGBA_S3TC_DXT3_EXT: number;
    COMPRESSED_RGBA_S3TC_DXT5_EXT: number;
};

interface WEBGL_depth_texture {
  UNSIGNED_INT_24_8_WEBGL: number;
};

interface OES_element_index_uint {
};

interface WebGLVertexArrayObjectOES extends WebGLObject {
};

interface OES_vertex_array_object {
    VERTEX_ARRAY_BINDING_OES: number;

    createVertexArrayOES(): WebGLVertexArrayObjectOES;
    deleteVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
    isVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): bool;
    bindVertexArrayOES(arrayObject: WebGLVertexArrayObjectOES): void;
};

interface OES_standard_derivatives {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: number;
};

interface OES_texture_half_float {
 	HALF_FLOAT_OES: number;
};

interface OES_texture_float {
};

interface WEBGL_lose_context {
      loseContext(): void;
      restoreContext(): void;
};

interface WEBGL_multiple_render_targets {
    COLOR_ATTACHMENT0_WEBGL: number;
    COLOR_ATTACHMENT1_WEBGL: number;
    COLOR_ATTACHMENT2_WEBGL: number;
    COLOR_ATTACHMENT3_WEBGL: number;
    COLOR_ATTACHMENT4_WEBGL: number;
    COLOR_ATTACHMENT5_WEBGL: number;
    COLOR_ATTACHMENT6_WEBGL: number;
    COLOR_ATTACHMENT7_WEBGL: number;
    COLOR_ATTACHMENT8_WEBGL: number;
    COLOR_ATTACHMENT9_WEBGL: number;
    COLOR_ATTACHMENT10_WEBGL: number;
    COLOR_ATTACHMENT11_WEBGL: number;
    COLOR_ATTACHMENT12_WEBGL: number;
    COLOR_ATTACHMENT13_WEBGL: number;
    COLOR_ATTACHMENT14_WEBGL: number;
    COLOR_ATTACHMENT15_WEBGL: number;

    DRAW_BUFFER0_WEBGL: number;
    DRAW_BUFFER1_WEBGL: number;
    DRAW_BUFFER2_WEBGL: number;
    DRAW_BUFFER3_WEBGL: number;
    DRAW_BUFFER4_WEBGL: number;
    DRAW_BUFFER5_WEBGL: number;
    DRAW_BUFFER6_WEBGL: number;
    DRAW_BUFFER7_WEBGL: number;
    DRAW_BUFFER8_WEBGL: number;
    DRAW_BUFFER9_WEBGL: number;
    DRAW_BUFFER10_WEBGL: number;
    DRAW_BUFFER11_WEBGL: number;
    DRAW_BUFFER12_WEBGL: number;
    DRAW_BUFFER13_WEBGL: number;
    DRAW_BUFFER14_WEBGL: number;
    DRAW_BUFFER15_WEBGL: number;

    MAX_COLOR_ATTACHMENTS_WEBGL: number;
    MAX_DRAW_BUFFERS_WEBGL: number;

    drawBuffersWEBGL(buffers: number[]): void;
};

interface WEBGL_fbo_color_attachments {
    COLOR_ATTACHMENT0: number;
    COLOR_ATTACHMENT1: number;
    COLOR_ATTACHMENT2: number;
    COLOR_ATTACHMENT3: number;
    COLOR_ATTACHMENT4: number;
    COLOR_ATTACHMENT5: number;
    COLOR_ATTACHMENT6: number;
    COLOR_ATTACHMENT7: number;
    COLOR_ATTACHMENT8: number;
    COLOR_ATTACHMENT9: number;
    COLOR_ATTACHMENT10: number;
    COLOR_ATTACHMENT11: number;
    COLOR_ATTACHMENT12: number;
    COLOR_ATTACHMENT13: number;
    COLOR_ATTACHMENT14: number;
    COLOR_ATTACHMENT15: number;

    MAX_COLOR_ATTACHMENTS: number;
};

// debug


declare var WebGLDebugUtils: {
/**
	 * Initializes this module. Safe to call more than once.
	 *    you have more than one context it doesn't matter which one
     *    you pass in, it is only used to pull out constants.
	 */

	init: (ctx: WebGLRenderingContext) => void;
/**
	 * Returns true or false if value matches any WebGL enum
	 */

	mightBeEnum: (value: any) => bool;
/**
	 * Gets an string version of an WebGL enum.
	 *
	 * Example:
	 *   WebGLDebugUtil.init(ctx);
	 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
	 *
	 */

	glEnumToString: (value: number) => string;
/**
     * Converts the argument of a WebGL function to a string.
     * Attempts to convert enum arguments to strings.
     *
     * Example:
     *   WebGLDebugUtil.init(ctx);
     *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);
     *
     * would return 'TEXTURE_2D'
     */

    glFunctionArgToString: (functionName: string, argumentIndex:  number , value: any) => string;
/**
     * Converts the arguments of a WebGL function to a string.
     * Attempts to convert enum arguments to strings.
     */

    glFunctionArgsToString: (functionName: string, args: IArguments) => string;
/**
     * Given a WebGL context returns a wrapped context that calls
     * gl.getError after every command and calls a function if the
     * result is not NO_ERROR.
     *
     * You can supply your own function if you want. For example, if you'd like
     * an exception thrown on any GL error you could do this
     *
     *    function throwOnGLError(err, funcName, args) {
     *      throw WebGLDebugUtils.glEnumToString(err) +
     *            " was caused by call to " + funcName;
     *    };
     *
     *    ctx = WebGLDebugUtils.makeDebugContext(
     *        canvas.getContext("webgl"), throwOnGLError);
     */

	makeDebugContext: (
		ctx: WebGLRenderingContext,
		onErrorFunc?: (err:  number , funcName: string, args: IArguments) => void,
		onFunc?: (funcName: string, args: IArguments) => void) => WebGLRenderingContext;

/**
	 * Given a canvas element returns a wrapped canvas element that will
	 * simulate lost context. The canvas returned adds the following functions.
	 *
	 * loseContext:
	 *   simulates a lost context event.
	 *
	 * restoreContext:
	 *   simulates the context being restored.
	 *
	 * lostContextInNCalls:
	 *   loses the context after N gl calls.
	 *
	 * getNumCalls:
	 *   tells you how many gl calls there have been so far.
	 *
	 * setRestoreTimeout:
	 *   sets the number of milliseconds until the context is restored
	 *   after it has been lost. Defaults to 0. Pass -1 to prevent
	 *   automatic restoring.
	 */

	makeLostContextSimulatingCanvas: (canvas: HTMLCanvasElement) => HTMLCanvasElement;
/**
     * Resets a context to the initial state.
     */

	resetToInitialState: (ctx: WebGLRenderingContext) => void;

}


/* ClearBufferMask */





/* BeginMode */









/* AlphaFunction (not supported in ES20) */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* BlendingFactorDest */










/* BlendingFactorSrc */

/*      ZERO */

/*      ONE */




/*      SRC_ALPHA */

/*      ONE_MINUS_SRC_ALPHA */

/*      DST_ALPHA */

/*      ONE_MINUS_DST_ALPHA */


/* BlendEquationSeparate */



/* same as BLEND_EQUATION */



/* BlendSubtract */




/* Separate Blend Functions */











/* Buffer Objects */















/* CullFaceMode */





/* DepthFunction */

/*      NEVER */

/*      LESS */

/*      EQUAL */

/*      LEQUAL */

/*      GREATER */

/*      NOTEQUAL */

/*      GEQUAL */

/*      ALWAYS */


/* EnableCap */

/* TEXTURE_2D */











/* ErrorCode */







/* FrontFaceDirection */




/* GetPName */



























/*      SCISSOR_TEST */















/*      POLYGON_OFFSET_FILL */








/* GetTextureParameter */

/*      TEXTURE_MAG_FILTER */

/*      TEXTURE_MIN_FILTER */

/*      TEXTURE_WRAP_S */

/*      TEXTURE_WRAP_T */




/* HintMode */





/* HintTarget */



/* DataType */











/* PixelFormat */










/* PixelType */

/*      UNSIGNED_BYTE */





/* Shaders */




















/* StencilFunction */










/* StencilOp */

/*      ZERO */









/* StringName */





/* TextureMagFilter */




/* TextureMinFilter */

/*      NEAREST */

/*      LINEAR */






/* TextureParameterName */






/* TextureTarget */














/* TextureUnit */



































/* TextureWrapMode */





/* Uniform Types */

















/* Vertex Arrays */









/* Shader Source */



/* Shader Precision-Specified Types */








/* Framebuffer Object. */














































/* WebGL-specific enums */





























//WebGL Extensions 










//draft











//Future





















module akra {
	export interface IBuffer {
//number of elements
		 length:  number ;

//size in bytes
		 byteLength:  number ;


	}
}



module akra {

	export enum EHardwareBufferFlags {
		STATIC 		= 0x01,
		DYNAMIC 	= 0x02,
		STREAM 		= 0x80,

		READABLE	= 0x04,

		BACKUP_COPY = 0x08,
/** indicate, that buffer does not use GPU memory or other specific memory. */

		SOFTWARE 	= 0x10,
/** Indicate, tha buffer uses specific data aligment */

		ALIGNMENT	= 0x20,
/** Indicates that the application will be refilling the contents
            of the buffer regularly (not just updating, but generating the
            contents from scratch), and therefore does not mind if the contents 
            of the buffer are lost somehow and need to be recreated. This
            allows and additional level of optimisation on the buffer.
            This option only really makes sense when combined with 
            DYNAMIC and without READING.
            */

		DISCARDABLE = 0x40,

		STATIC_READABLE = STATIC | READABLE,
		DYNAMIC_DISCARDABLE = DYNAMIC | DISCARDABLE
	}

	export enum ELockFlags {
		READ 			= 0x01,
		WRITE 			= 0x02,
		DISCARD 		= 0x04,
		NO_OVERWRITE	= 0x08,

		NORMAL			= READ | WRITE
	}

	export interface IHardwareBuffer extends IBuffer {
		clone(pSrc: IHardwareBuffer): bool;

		isValid(): bool;
		isDynamic(): bool;
		isStatic(): bool;
		isStream(): bool;
		isReadable(): bool;
		isBackupPresent(): bool;
		isSoftware(): bool;
		isAligned(): bool;
		isLocked(): bool;

		getFlags():  number ;

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;

		 writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
//writeData(pData: ArrayBuffer, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer?: bool): bool;

		copyData(pSrcBuffer: IHardwareBuffer, iSrcOffset:  number ,
				 iDstOffset:  number , iSize:  number , bDiscardWholeBuffer?: bool): bool;

		create(iSize:  number , iFlags?:  number ): bool;
// create(iByteSize: uint, iFlags: int, pData: Uint8Array): bool;
// create(iByteSize: uint, iFlags: int, pData: ArrayBuffer): bool;

		destroy(): void;

		resize(iSize:  number ): bool;

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags?:  number ): any;
		unlock(): void;

		restoreFromBackup(): bool;
	}
}

















module akra {

	export interface IVec2Constructor {
        ();
        (fValue:  number );
        (v2fVec: IVec2);
        (pArray:  number []);
        (fValue1:  number , fValue2:  number );
    }


	export interface IVec2 {
		x:  number ;
		y:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;

		set(): IVec2;
		set(fValue:  number ): IVec2;
		set(v2fVec: IVec2): IVec2;
		set(pArray:  number []): IVec2;
		set(fValue1:  number , fValue2:  number ): IVec2;

		clear(): IVec2;

		add(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;
		subtract(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;
		dot(v2fVec: IVec2):  number ;

		isEqual(v2fVec: IVec2, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v2fDestination?: IVec2): IVec2;
		scale(fScale:  number , v2fDestination?: IVec2): IVec2;
		normalize(v2fDestination?: IVec2): IVec2;
		length():  number ;
		lengthSquare():  number ;


		direction(v2fVec: IVec2, v2fDestination?: IVec2): IVec2;

		mix(v2fVec: IVec2, fA:  number , v2fDestination?: IVec2): IVec2;

		toString(): string;
	};
};



module akra.math {

    export class Vec2 implements IVec2{
        x:  number  = 0.;
        y:  number  = 0.;



get xx(): IVec2{
	return vec2(this.x, this.x);
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return vec2(this.x, this.y);
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get yx(): IVec2{
	return vec2(this.y, this.x);
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return vec2(this.y, this.y);
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

        constructor();
        constructor(fValue:  number );
        constructor(v2fVec: IVec2);
        constructor(pArray:  number []);
        constructor(fValue1:  number , fValue2:  number );
        constructor(fValue1?, fValue2?){
            var nArgumentsLength:  number  = arguments.length;

            var v2fVec: IVec2 = this;

// if (<any>this === window || <any>this === akra || <any>this === akra.math) {
//     v2fVec = Vec2.stack[Vec2.stackPosition ++];

//     if(Vec2.stackPosition == Vec2.stackSize){
//         Vec2.stackPosition = 0;
//     }
// }

            switch(nArgumentsLength){
                case 1:
                    v2fVec.set(arguments[0]);
                    break;
                case 2:
                    v2fVec.set(arguments[0], arguments[1]);
                    break;
                default:
                    v2fVec.x = v2fVec.y = 0.;
                    break;
            }

        };

        set(): IVec2;
        set(fValue:  number ): IVec2;
        set(v2fVec: IVec2): IVec2;
        set(pArray:  number []): IVec2;
        set(fValue1:  number , fValue2:  number ): IVec2;
        set(fValue1?, fValue2?): IVec2{
            var nArgumentsLength:  number  = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec2){
                        var v2fVec: IVec2 = arguments[0];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                    }
                    else{
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                    }
                    break;
                case 2:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    break;
            };

            return this;
        };

        inline clear(): IVec2{
            this.x = this.y = 0.;
            return this;
        };

        add(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x + v2fVec.x;
            v2fDestination.y = this.y + v2fVec.y;

            return v2fDestination;
        };

        subtract(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x - v2fVec.x;
            v2fDestination.y = this.y - v2fVec.y;

            return v2fDestination;
        };

        inline dot(v2fVec: IVec2):  number {
            return this.x*v2fVec.x + this.y*v2fVec.y;
        };

        isEqual(v2fVec: IVec2, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v2fVec.x
                    || this.y != v2fVec.y){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v2fVec.x) > fEps
                    || abs(this.y - v2fVec.y) > fEps){

                    return false;
                }
            }

            return true;
        };

        isClear(fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.){

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps){

                    return false;
                }
            }

            return true;
        };

        negate(v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = -this.x;
            v2fDestination.y = -this.y;

            return v2fDestination;
        };

        scale(fScale:  number , v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            v2fDestination.x = this.x*fScale;
            v2fDestination.y = this.y*fScale;

            return v2fDestination;
        };

        normalize(v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y;
            var fLength:  number  = sqrt(x*x + y*y);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
            }

            v2fDestination.x = x;
            v2fDestination.y = y;

            return v2fDestination;
        };

        inline length():  number {
            var x:  number  = this.x, y:  number  = this.y;
            return sqrt(x*x + y*y);
        };

        inline lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y;
            return x*x + y*y;
        };

        direction(v2fVec: IVec2, v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            var x:  number  = v2fVec.x - this.x;
            var y:  number  = v2fVec.y - this.y;

            var fLength:  number  = sqrt(x*x + y*y);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
            }

            v2fDestination.x = x;
            v2fDestination.y = y;

            return v2fDestination;
        };

        mix(v2fVec: IVec2, fA:  number , v2fDestination?: IVec2): IVec2{
            if(!isDef(v2fDestination)){
                v2fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v2fDestination.x = fA1*this.x + fA2*v2fVec.x;
            v2fDestination.y = fA1*this.y + fA2*v2fVec.y;

            return v2fDestination;
        };

        inline toString(): string{
            return "[x: " + this.x + ", y: " + this.y + "]";
        };

        static get stackCeil(): Vec2 { Vec2.stackPosition = Vec2.stackPosition === Vec2.stackSize - 1? 0: Vec2.stackPosition; return Vec2.stack[Vec2.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Vec2[] = (function(): Vec2[]{ var pStack: Vec2[] = new Array(Vec2.stackSize); for(var i: number = 0; i<Vec2.stackSize; i++){ pStack[i] = new Vec2(); } return pStack})();
   }
}












module akra {

	export interface IVec2 {} ;
	export interface IMat4 {} ;

	export interface IVec3Constructor {
        ();
        (fValue:  number );
        (v3fVec: IVec3);
        (pArray:  number []);
        (fValue:  number , v2fVec: IVec2);
        (v2fVec: IVec2, fValue:  number );
        (fValue1:  number , fValue2:  number , fValue3:  number );
    }


	export interface IVec3 {
		x:  number ;
		y:  number ;
		z:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

xz: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;
/*represents two-component vector from original vector*/

yz: IVec2;
/*represents two-component vector from original vector*/

zx: IVec2;
/*represents two-component vector from original vector*/

zy: IVec2;
/*represents two-component vector from original vector*/

zz: IVec2;

/*represents three-component vector from original vector*/

xxx: IVec3;
/*represents three-component vector from original vector*/

xxy: IVec3;
/*represents three-component vector from original vector*/

xxz: IVec3;
/*represents three-component vector from original vector*/

xyx: IVec3;
/*represents three-component vector from original vector*/

xyy: IVec3;
/*represents three-component vector from original vector*/

xyz: IVec3;
/*represents three-component vector from original vector*/

xzx: IVec3;
/*represents three-component vector from original vector*/

xzy: IVec3;
/*represents three-component vector from original vector*/

xzz: IVec3;
/*represents three-component vector from original vector*/

yxx: IVec3;
/*represents three-component vector from original vector*/

yxy: IVec3;
/*represents three-component vector from original vector*/

yxz: IVec3;
/*represents three-component vector from original vector*/

yyx: IVec3;
/*represents three-component vector from original vector*/

yyy: IVec3;
/*represents three-component vector from original vector*/

yyz: IVec3;
/*represents three-component vector from original vector*/

yzx: IVec3;
/*represents three-component vector from original vector*/

yzy: IVec3;
/*represents three-component vector from original vector*/

yzz: IVec3;
/*represents three-component vector from original vector*/

zxx: IVec3;
/*represents three-component vector from original vector*/

zxy: IVec3;
/*represents three-component vector from original vector*/

zxz: IVec3;
/*represents three-component vector from original vector*/

zyx: IVec3;
/*represents three-component vector from original vector*/

zyy: IVec3;
/*represents three-component vector from original vector*/

zyz: IVec3;
/*represents three-component vector from original vector*/

zzx: IVec3;
/*represents three-component vector from original vector*/

zzy: IVec3;
/*represents three-component vector from original vector*/

zzz: IVec3;

		set(): IVec3;
		set(fValue:  number ): IVec3;
		set(v3fVec: IVec3): IVec3;
		set(pArray:  number []): IVec3;
		set(fValue:  number , v2fVec: IVec2): IVec3;
		set(v2fVec: IVec2, fValue:  number ): IVec3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IVec3;

		clear(): IVec3;

		add(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;
		subtract(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;
		dot(v3fVec: IVec3):  number ;
		cross(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		isEqual(v3fVec: IVec3, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v3fDestination?: IVec3): IVec3;
		scale(fScale:  number , v3fDestination?: IVec3): IVec3;
		scale(v3fScale: IVec3, v3fDestination?: IVec3): IVec3;
		normalize(v3fDestination?: IVec3): IVec3;
		length():  number ;
		lengthSquare():  number ;

		direction(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		mix(v3fVec: IVec3, fA:  number , v3fDestination?: IVec3): IVec3;

		toString(): string;
		toTranslationMatrix(m4fDestination?: IMat4);

		vec3TransformCoord(m4fTransformation: IMat4, v3fDestination?: IVec3): IVec3;
	};
};






/**
 * @important Если внезапно задумаем перейти обратно на 
 * хранение данных в матрицах по строкам, как собственно и было в начале,
 * то необходимо раскомментить definы и переписать метод set, 
 * так как он ложит по столбцам
 */


// #define __11 0
// #define __12 1
// #define __13 2
// #define __14 3
// #define __21 4
// #define __22 5
// #define __23 6
// #define __24 7
// #define __31 8
// #define __32 9
// #define __33 10
// #define __34 11
// #define __41 12
// #define __42 13
// #define __43 14
// #define __44 15


















module akra {

	export interface IVec3 {} ;
	export interface IVec4 {} ;
	export interface IMat3 {} ;
	export interface IQuat4 {} ;

	export interface IMat4Constructor {
		();
		(fValue:  number );
		(v4fVec: IVec4);
		(m4fMat: IMat4);
		(pArray:  number []);
		(m3fMat: IMat3, v3fTranslation?: IVec3);
		(pArray: Float32Array, bFlag: bool);
		(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
		(v4fVec1: IVec4, v4fVec2: IVec4, v4fVec3: IVec4, v4fVec4: IVec4);
		(pArray1:  number [], pArray2:  number [], pArray3:  number [], pArray4:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
				fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
				fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
				fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number );
	}

	export interface IMat4 {
		data: Float32Array;

		set(): IMat4;
		set(fValue:  number ): IMat4;
		set(v4fVec: IVec4): IMat4;
		set(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
		set(m4fMat: IMat4): IMat4;
		set(pArray:  number []): IMat4;
		set(fValue1:  number , fValue2:  number ,
			fValue3:  number , fValue4:  number ): IMat4;
		set(v4fVec1: IVec4, v4fVec2: IVec4,
			v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
		set(pArray1:  number [], pArray2:  number [],
			pArray3:  number [], pArray4:  number []): IMat4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
			fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
			fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
			fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number ): IMat4;

		identity(): IMat4;

		add(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		subtract(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiply(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiplyLeft(m4fMat: IMat4, m4fDestination?: IMat4): IMat4;
		multiplyVec4(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;

		transpose(m4fDestination?: IMat4): IMat4;
		determinant():  number ;
		inverse(m4fDestination?: IMat4): IMat4;
		trace():  number ;

		isEqual(m4fMat: IMat4, fEps?:  number ): bool;
		isDiagonal(fEps?:  number ): bool;

		toMat3(m3fDestination?: IMat3): IMat3;
		toQuat4(q4fDestination?: IQuat4): IQuat4;
		toRotationMatrix(m4fDestination?: IMat4): IMat4;
		toString(): string;

		rotateRight(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4;
		rotateLeft(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4;

//rotateXRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateXLeft(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateYRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateYLeft(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateZRight(fAngle: float, m4fDestination?: IMat4): IMat4;
//rotateZLeft(fAngle: float, m4fDestination?: IMat4): IMat4;

		setTranslation(v3fTranslation: IVec3): IMat4;
		getTranslation(v3fTranslation?: IVec3): IVec3;

		translateRight(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4;
		translateLeft(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4;

		scaleRight(v3fScale: IVec3, m4fDestination?: IMat4): IMat4;
		scaleLeft(v3fScale: IVec3, m4fDestination?: IMat4): IMat4;

		decompose(q4fRotation: IQuat4, v3fScale: IVec3, v3fTranslation: IVec3): bool;

		row(iRow:  number , v4fDestination?: IVec4): IVec4;
		column(iColumn:  number , v4fDestination?: IVec4): IVec4;

/*v3fScreen - coordinates in screen space from -1 to 1
		* returns vec4(wsCoord,1.), where wsCoord - coordinates in world space
		* use with projection matrix only
		*/

		unproj(v3fScreen: IVec3, v4fDestination?: IVec4): IVec4;
		unproj(v4fScreen: IVec4, v4fDestination?: IVec4): IVec4;

		unprojZ(fZ:  number ):  number ;

/**
		 * use only this projection matrix otherwise result doesn't have any sense
		 */

		isOrthogonalProjection(): bool;
	};
};



module akra.math {

    export class Vec3 {
        x:  number ;
        y:  number ;
        z:  number ;


get xx(): IVec2{
	return vec2(this.x, this.x);
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return vec2(this.x, this.y);
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get xz(): IVec2{
	return vec2(this.x, this.z);
};
set xz(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.z = v2fVec.y;
};

get yx(): IVec2{
	return vec2(this.y, this.x);
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return vec2(this.y, this.y);
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

get yz(): IVec2{
	return vec2(this.y, this.z);
};
set yz(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.z = v2fVec.y;
};

get zx(): IVec2{
	return vec2(this.z, this.x);
};
set zx(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.x = v2fVec.y;
};

get zy(): IVec2{
	return vec2(this.z, this.y);
};
set zy(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.y = v2fVec.y;
};

get zz(): IVec2{
	return vec2(this.z, this.z);
};
set zz(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.z = v2fVec.y;
};


get xxx(): IVec3{
	return vec3(this.x, this.x, this.x);
};
set xxx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get xxy(): IVec3{
	return vec3(this.x, this.x, this.y);
};
set xxy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get xxz(): IVec3{
	return vec3(this.x, this.x, this.z);
};
set xxz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get xyx(): IVec3{
	return vec3(this.x, this.y, this.x);
};
set xyx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get xyy(): IVec3{
	return vec3(this.x, this.y, this.y);
};
set xyy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get xyz(): IVec3{
	return vec3(this.x, this.y, this.z);
};
set xyz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get xzx(): IVec3{
	return vec3(this.x, this.z, this.x);
};
set xzx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get xzy(): IVec3{
	return vec3(this.x, this.z, this.y);
};
set xzy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get xzz(): IVec3{
	return vec3(this.x, this.z, this.z);
};
set xzz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get yxx(): IVec3{
	return vec3(this.y, this.x, this.x);
};
set yxx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get yxy(): IVec3{
	return vec3(this.y, this.x, this.y);
};
set yxy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get yxz(): IVec3{
	return vec3(this.y, this.x, this.z);
};
set yxz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get yyx(): IVec3{
	return vec3(this.y, this.y, this.x);
};
set yyx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get yyy(): IVec3{
	return vec3(this.y, this.y, this.y);
};
set yyy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get yyz(): IVec3{
	return vec3(this.y, this.y, this.z);
};
set yyz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get yzx(): IVec3{
	return vec3(this.y, this.z, this.x);
};
set yzx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get yzy(): IVec3{
	return vec3(this.y, this.z, this.y);
};
set yzy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get yzz(): IVec3{
	return vec3(this.y, this.z, this.z);
};
set yzz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get zxx(): IVec3{
	return vec3(this.z, this.x, this.x);
};
set zxx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get zxy(): IVec3{
	return vec3(this.z, this.x, this.y);
};
set zxy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get zxz(): IVec3{
	return vec3(this.z, this.x, this.z);
};
set zxz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get zyx(): IVec3{
	return vec3(this.z, this.y, this.x);
};
set zyx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get zyy(): IVec3{
	return vec3(this.z, this.y, this.y);
};
set zyy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get zyz(): IVec3{
	return vec3(this.z, this.y, this.z);
};
set zyz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get zzx(): IVec3{
	return vec3(this.z, this.z, this.x);
};
set zzx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get zzy(): IVec3{
	return vec3(this.z, this.z, this.y);
};
set zzy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get zzz(): IVec3{
	return vec3(this.z, this.z, this.z);
};
set zzz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

        constructor();
        constructor(fValue:  number );
        constructor(v3fVec: IVec3);
        constructor(pArray:  number []);
        constructor(fValue:  number , v2fVec: IVec2);
        constructor(v2fVec: IVec2, fValue:  number );
        constructor(fValue1:  number , fValue2:  number , fValue3:  number );
        constructor(fValue1?, fValue2?, fValue3?){
            var nArgumentsLength:  number  = arguments.length;


            switch(nArgumentsLength){
                case 1:
                    this.set(arguments[0]);
                    break;
                case 2:
                    this.set(arguments[0], arguments[1]);
                    break;
                case 3:
                    this.set(arguments[0], arguments[1], arguments[2]);
                    break;
                default:
                    this.x = this.y = this.z = 0.;
                    break;
            }
        };

        set(): IVec3;
        set(fValue:  number ): IVec3;
        set(v3fVec: IVec3): IVec3;
        set(pArray:  number []): IVec3;
        set(fValue:  number , v2fVec: IVec2): IVec3;
        set(v2fVec: IVec2, fValue:  number ): IVec3;
        set(fValue1:  number , fValue2:  number , fValue3:  number ): IVec3;
        set(fValue1?, fValue2?, fValue3?): IVec3{
            var nArgumentsLength = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = this.z = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = this.z = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec3){
                        var v3fVec: IVec3 = arguments[0];

                        this.x = v3fVec.x;
                        this.y = v3fVec.y;
                        this.z = v3fVec.z;
                    }
                    else{
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                        this.z = pArray[2];
                    }
                    break;
                case 2:
                    if(isFloat(arguments[0])){
                        var fValue:  number  = arguments[0];
                        var v2fVec: IVec2 = arguments[1];

                        this.x = fValue;
                        this.y = v2fVec.x;
                        this.z = v2fVec.y;
                    }
                    else{
                        var v2fVec: IVec2 = arguments[0];
                        var fValue:  number  = arguments[1];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                        this.z = fValue;
                    }
                    break;
                case 3:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    break;
            }

            return this;
        };

        inline clear(): IVec3{
            this.x = this.y = this.z = 0.;
            return this;
        };


        add(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = this.x + v3fVec.x;
            v3fDestination.y = this.y + v3fVec.y;
            v3fDestination.z = this.z + v3fVec.z;

            return v3fDestination;
        };


        subtract(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = this.x - v3fVec.x;
            v3fDestination.y = this.y - v3fVec.y;
            v3fDestination.z = this.z - v3fVec.z;

            return v3fDestination;
        };

        inline dot(v3fVec: IVec3):  number {
            return this.x*v3fVec.x + this.y*v3fVec.y + this.z*v3fVec.z;
        };


        cross(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z;
            var x2:  number  = v3fVec.x, y2:  number  = v3fVec.y, z2:  number  = v3fVec.z;

            v3fDestination.x = y1*z2 - z1*y2;
            v3fDestination.y = z1*x2 - x1*z2;
            v3fDestination.z = x1*y2 - y1*x2;

            return v3fDestination;
        };

        isEqual(v3fVec: IVec3, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v3fVec.x
                    || this.y != v3fVec.y
                    || this.z != v3fVec.z){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v3fVec.x) > fEps
                    || abs(this.y - v3fVec.y) > fEps
                    || abs(this.z - v3fVec.z) > fEps){

                    return false;
                }
            }
            return true;
        };


        isClear(fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.
                    || this.z != 0.) {

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps
                    || abs(this.z) > fEps){

                    return false;
                }
            }

            return true;
        };

        negate(v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            v3fDestination.x = -this.x;
            v3fDestination.y = -this.y;
            v3fDestination.z = -this.z;

            return v3fDestination;
        };

        scale(v3fScale: IVec3, v3fDestination?: IVec3): IVec3;
        scale(fScale:  number , v3fDestination?: IVec3): IVec3;
        scale(fScale?, v3fDestination?): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            if(isNumber(arguments[0])){
                var fScale:  number  = arguments[0];
                v3fDestination.x = this.x*fScale;
                v3fDestination.y = this.y*fScale;
                v3fDestination.z = this.z*fScale;
            }
            else{
                var v3fScale: IVec3 = arguments[0];
                v3fDestination.x = this.x*v3fScale.x;
                v3fDestination.y = this.y*v3fScale.y;
                v3fDestination.z = this.z*v3fScale.z;
            }

            return v3fDestination;
        };

        normalize(v3fDestination?: IVec3): IVec3{
            if(!v3fDestination){
                v3fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;
            var fLength:  number  = sqrt(x*x + y*y + z*z);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
            }

            v3fDestination.x = x;
            v3fDestination.y = y;
            v3fDestination.z = z;

            return v3fDestination;
        };

        inline length():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;
            return sqrt(x*x + y*y + z*z);
        };

        inline lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;
            return x*x + y*y + z*z;
        };

        direction(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
            if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            var x:  number  = v3fVec.x - this.x;
            var y:  number  = v3fVec.y - this.y;
            var z:  number  = v3fVec.z - this.z;

            var fLength:  number  = sqrt(x*x + y*y + z*z);

            if(fLength !== 0.){
                var fInvLength = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
            }

            v3fDestination.x = x;
            v3fDestination.y = y;
            v3fDestination.z = z;

            return v3fDestination;
        };

        mix(v3fVec: IVec3, fA:  number , v3fDestination?: IVec3): IVec3{
           if(!isDef(v3fDestination)){
                v3fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v3fDestination.x = fA1*this.x + fA2*v3fVec.x;
            v3fDestination.y = fA1*this.y + fA2*v3fVec.y;
            v3fDestination.z = fA1*this.z + fA2*v3fVec.z;

            return v3fDestination;
        };

        inline toString(): string{
            return "[x: " + this.x + " ,y: " + this.y + ", z: " + this.z + "]";
        };

        toTranslationMatrix(m4fDestination?: IMat4): IMat4{
            if(!isDef(m4fDestination)){
                m4fDestination = new Mat4(1.);
            }
            else{
                m4fDestination.set(1.);
            }

            var pData: Float32Array = m4fDestination.data;

            pData[ 12 ] = this.x;
            pData[ 13 ] = this.y;
            pData[ 14 ] = this.z;

            return m4fDestination;
        };

        vec3TransformCoord(m4fTransformation: IMat4, v3fDestination?: IVec3): IVec3{
            if(!v3fDestination){
                v3fDestination = this;
            }

            var pData: Float32Array = m4fTransformation.data;

            var x:  number  = this.x;
            var y:  number  = this.y;
            var z:  number  = this.z;
            var w:  number ;

            x = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ];
            y = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ];
            z = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ];
            w = pData[ 2 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ];

            var fInvW:  number  = 1./w;

            v3fDestination.x = x*fInvW;
            v3fDestination.y = y*fInvW;
            v3fDestination.z = z*fInvW;

            return v3fDestination;
        };

        static get stackCeil(): Vec3 { Vec3.stackPosition = Vec3.stackPosition === Vec3.stackSize - 1? 0: Vec3.stackPosition; return Vec3.stack[Vec3.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Vec3[] = (function(): Vec3[]{ var pStack: Vec3[] = new Array(Vec3.stackSize); for(var i: number = 0; i<Vec3.stackSize; i++){ pStack[i] = new Vec3(); } return pStack})();
    }
}











module akra.math {

    export class Vec4 implements IVec4{
        x:  number ;
        y:  number ;
        z:  number ;
        w:  number ;


get xx(): IVec2{
	return vec2(this.x, this.x);
};
set xx(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.x = v2fVec.y;
};

get xy(): IVec2{
	return vec2(this.x, this.y);
};
set xy(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.y = v2fVec.y;
};

get xz(): IVec2{
	return vec2(this.x, this.z);
};
set xz(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.z = v2fVec.y;
};

get xw(): IVec2{
	return vec2(this.x, this.w);
};
set xw(v2fVec: IVec2){
	this.x = v2fVec.x; 	this.w = v2fVec.y;
};

get yx(): IVec2{
	return vec2(this.y, this.x);
};
set yx(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.x = v2fVec.y;
};

get yy(): IVec2{
	return vec2(this.y, this.y);
};
set yy(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.y = v2fVec.y;
};

get yz(): IVec2{
	return vec2(this.y, this.z);
};
set yz(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.z = v2fVec.y;
};

get yw(): IVec2{
	return vec2(this.y, this.w);
};
set yw(v2fVec: IVec2){
	this.y = v2fVec.x; 	this.w = v2fVec.y;
};

get zx(): IVec2{
	return vec2(this.z, this.x);
};
set zx(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.x = v2fVec.y;
};

get zy(): IVec2{
	return vec2(this.z, this.y);
};
set zy(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.y = v2fVec.y;
};

get zz(): IVec2{
	return vec2(this.z, this.z);
};
set zz(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.z = v2fVec.y;
};

get zw(): IVec2{
	return vec2(this.z, this.w);
};
set zw(v2fVec: IVec2){
	this.z = v2fVec.x; 	this.w = v2fVec.y;
};

get wx(): IVec2{
	return vec2(this.w, this.x);
};
set wx(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.x = v2fVec.y;
};

get wy(): IVec2{
	return vec2(this.w, this.y);
};
set wy(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.y = v2fVec.y;
};

get wz(): IVec2{
	return vec2(this.w, this.z);
};
set wz(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.z = v2fVec.y;
};

get ww(): IVec2{
	return vec2(this.w, this.w);
};
set ww(v2fVec: IVec2){
	this.w = v2fVec.x; 	this.w = v2fVec.y;
};


get xxx(): IVec3{
	return vec3(this.x, this.x, this.x);
};
set xxx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get xxy(): IVec3{
	return vec3(this.x, this.x, this.y);
};
set xxy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get xxz(): IVec3{
	return vec3(this.x, this.x, this.z);
};
set xxz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get xxw(): IVec3{
	return vec3(this.x, this.x, this.w);
};
set xxw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get xyx(): IVec3{
	return vec3(this.x, this.y, this.x);
};
set xyx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get xyy(): IVec3{
	return vec3(this.x, this.y, this.y);
};
set xyy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get xyz(): IVec3{
	return vec3(this.x, this.y, this.z);
};
set xyz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get xyw(): IVec3{
	return vec3(this.x, this.y, this.w);
};
set xyw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get xzx(): IVec3{
	return vec3(this.x, this.z, this.x);
};
set xzx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get xzy(): IVec3{
	return vec3(this.x, this.z, this.y);
};
set xzy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get xzz(): IVec3{
	return vec3(this.x, this.z, this.z);
};
set xzz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get xzw(): IVec3{
	return vec3(this.x, this.z, this.w);
};
set xzw(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get xwx(): IVec3{
	return vec3(this.x, this.w, this.x);
};
set xwx(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get xwy(): IVec3{
	return vec3(this.x, this.w, this.y);
};
set xwy(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get xwz(): IVec3{
	return vec3(this.x, this.w, this.z);
};
set xwz(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get xww(): IVec3{
	return vec3(this.x, this.w, this.w);
};
set xww(v3fVec: IVec3){
	this.x = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get yxx(): IVec3{
	return vec3(this.y, this.x, this.x);
};
set yxx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get yxy(): IVec3{
	return vec3(this.y, this.x, this.y);
};
set yxy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get yxz(): IVec3{
	return vec3(this.y, this.x, this.z);
};
set yxz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get yxw(): IVec3{
	return vec3(this.y, this.x, this.w);
};
set yxw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get yyx(): IVec3{
	return vec3(this.y, this.y, this.x);
};
set yyx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get yyy(): IVec3{
	return vec3(this.y, this.y, this.y);
};
set yyy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get yyz(): IVec3{
	return vec3(this.y, this.y, this.z);
};
set yyz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get yyw(): IVec3{
	return vec3(this.y, this.y, this.w);
};
set yyw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get yzx(): IVec3{
	return vec3(this.y, this.z, this.x);
};
set yzx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get yzy(): IVec3{
	return vec3(this.y, this.z, this.y);
};
set yzy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get yzz(): IVec3{
	return vec3(this.y, this.z, this.z);
};
set yzz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get yzw(): IVec3{
	return vec3(this.y, this.z, this.w);
};
set yzw(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get ywx(): IVec3{
	return vec3(this.y, this.w, this.x);
};
set ywx(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get ywy(): IVec3{
	return vec3(this.y, this.w, this.y);
};
set ywy(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get ywz(): IVec3{
	return vec3(this.y, this.w, this.z);
};
set ywz(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get yww(): IVec3{
	return vec3(this.y, this.w, this.w);
};
set yww(v3fVec: IVec3){
	this.y = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get zxx(): IVec3{
	return vec3(this.z, this.x, this.x);
};
set zxx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get zxy(): IVec3{
	return vec3(this.z, this.x, this.y);
};
set zxy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get zxz(): IVec3{
	return vec3(this.z, this.x, this.z);
};
set zxz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get zxw(): IVec3{
	return vec3(this.z, this.x, this.w);
};
set zxw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get zyx(): IVec3{
	return vec3(this.z, this.y, this.x);
};
set zyx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get zyy(): IVec3{
	return vec3(this.z, this.y, this.y);
};
set zyy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get zyz(): IVec3{
	return vec3(this.z, this.y, this.z);
};
set zyz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get zyw(): IVec3{
	return vec3(this.z, this.y, this.w);
};
set zyw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get zzx(): IVec3{
	return vec3(this.z, this.z, this.x);
};
set zzx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get zzy(): IVec3{
	return vec3(this.z, this.z, this.y);
};
set zzy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get zzz(): IVec3{
	return vec3(this.z, this.z, this.z);
};
set zzz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get zzw(): IVec3{
	return vec3(this.z, this.z, this.w);
};
set zzw(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get zwx(): IVec3{
	return vec3(this.z, this.w, this.x);
};
set zwx(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get zwy(): IVec3{
	return vec3(this.z, this.w, this.y);
};
set zwy(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get zwz(): IVec3{
	return vec3(this.z, this.w, this.z);
};
set zwz(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get zww(): IVec3{
	return vec3(this.z, this.w, this.w);
};
set zww(v3fVec: IVec3){
	this.z = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};

get wxx(): IVec3{
	return vec3(this.w, this.x, this.x);
};
set wxx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.x = v3fVec.z;
};

get wxy(): IVec3{
	return vec3(this.w, this.x, this.y);
};
set wxy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.y = v3fVec.z;
};

get wxz(): IVec3{
	return vec3(this.w, this.x, this.z);
};
set wxz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.z = v3fVec.z;
};

get wxw(): IVec3{
	return vec3(this.w, this.x, this.w);
};
set wxw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.x = v3fVec.y; 	this.w = v3fVec.z;
};

get wyx(): IVec3{
	return vec3(this.w, this.y, this.x);
};
set wyx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.x = v3fVec.z;
};

get wyy(): IVec3{
	return vec3(this.w, this.y, this.y);
};
set wyy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.y = v3fVec.z;
};

get wyz(): IVec3{
	return vec3(this.w, this.y, this.z);
};
set wyz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.z = v3fVec.z;
};

get wyw(): IVec3{
	return vec3(this.w, this.y, this.w);
};
set wyw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.y = v3fVec.y; 	this.w = v3fVec.z;
};

get wzx(): IVec3{
	return vec3(this.w, this.z, this.x);
};
set wzx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.x = v3fVec.z;
};

get wzy(): IVec3{
	return vec3(this.w, this.z, this.y);
};
set wzy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.y = v3fVec.z;
};

get wzz(): IVec3{
	return vec3(this.w, this.z, this.z);
};
set wzz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.z = v3fVec.z;
};

get wzw(): IVec3{
	return vec3(this.w, this.z, this.w);
};
set wzw(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.z = v3fVec.y; 	this.w = v3fVec.z;
};

get wwx(): IVec3{
	return vec3(this.w, this.w, this.x);
};
set wwx(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.x = v3fVec.z;
};

get wwy(): IVec3{
	return vec3(this.w, this.w, this.y);
};
set wwy(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.y = v3fVec.z;
};

get wwz(): IVec3{
	return vec3(this.w, this.w, this.z);
};
set wwz(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.z = v3fVec.z;
};

get www(): IVec3{
	return vec3(this.w, this.w, this.w);
};
set www(v3fVec: IVec3){
	this.w = v3fVec.x; 	this.w = v3fVec.y; 	this.w = v3fVec.z;
};


get xxxx(): IVec4{
	return vec4(this.x, this.x, this.x, this.x);
};
set xxxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xxxy(): IVec4{
	return vec4(this.x, this.x, this.x, this.y);
};
set xxxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xxxz(): IVec4{
	return vec4(this.x, this.x, this.x, this.z);
};
set xxxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xxxw(): IVec4{
	return vec4(this.x, this.x, this.x, this.w);
};
set xxxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xxyx(): IVec4{
	return vec4(this.x, this.x, this.y, this.x);
};
set xxyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xxyy(): IVec4{
	return vec4(this.x, this.x, this.y, this.y);
};
set xxyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xxyz(): IVec4{
	return vec4(this.x, this.x, this.y, this.z);
};
set xxyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xxyw(): IVec4{
	return vec4(this.x, this.x, this.y, this.w);
};
set xxyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xxzx(): IVec4{
	return vec4(this.x, this.x, this.z, this.x);
};
set xxzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xxzy(): IVec4{
	return vec4(this.x, this.x, this.z, this.y);
};
set xxzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xxzz(): IVec4{
	return vec4(this.x, this.x, this.z, this.z);
};
set xxzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xxzw(): IVec4{
	return vec4(this.x, this.x, this.z, this.w);
};
set xxzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xxwx(): IVec4{
	return vec4(this.x, this.x, this.w, this.x);
};
set xxwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xxwy(): IVec4{
	return vec4(this.x, this.x, this.w, this.y);
};
set xxwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xxwz(): IVec4{
	return vec4(this.x, this.x, this.w, this.z);
};
set xxwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xxww(): IVec4{
	return vec4(this.x, this.x, this.w, this.w);
};
set xxww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xyxx(): IVec4{
	return vec4(this.x, this.y, this.x, this.x);
};
set xyxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xyxy(): IVec4{
	return vec4(this.x, this.y, this.x, this.y);
};
set xyxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xyxz(): IVec4{
	return vec4(this.x, this.y, this.x, this.z);
};
set xyxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xyxw(): IVec4{
	return vec4(this.x, this.y, this.x, this.w);
};
set xyxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xyyx(): IVec4{
	return vec4(this.x, this.y, this.y, this.x);
};
set xyyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xyyy(): IVec4{
	return vec4(this.x, this.y, this.y, this.y);
};
set xyyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xyyz(): IVec4{
	return vec4(this.x, this.y, this.y, this.z);
};
set xyyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xyyw(): IVec4{
	return vec4(this.x, this.y, this.y, this.w);
};
set xyyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xyzx(): IVec4{
	return vec4(this.x, this.y, this.z, this.x);
};
set xyzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xyzy(): IVec4{
	return vec4(this.x, this.y, this.z, this.y);
};
set xyzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xyzz(): IVec4{
	return vec4(this.x, this.y, this.z, this.z);
};
set xyzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xyzw(): IVec4{
	return vec4(this.x, this.y, this.z, this.w);
};
set xyzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xywx(): IVec4{
	return vec4(this.x, this.y, this.w, this.x);
};
set xywx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xywy(): IVec4{
	return vec4(this.x, this.y, this.w, this.y);
};
set xywy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xywz(): IVec4{
	return vec4(this.x, this.y, this.w, this.z);
};
set xywz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xyww(): IVec4{
	return vec4(this.x, this.y, this.w, this.w);
};
set xyww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xzxx(): IVec4{
	return vec4(this.x, this.z, this.x, this.x);
};
set xzxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xzxy(): IVec4{
	return vec4(this.x, this.z, this.x, this.y);
};
set xzxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xzxz(): IVec4{
	return vec4(this.x, this.z, this.x, this.z);
};
set xzxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xzxw(): IVec4{
	return vec4(this.x, this.z, this.x, this.w);
};
set xzxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xzyx(): IVec4{
	return vec4(this.x, this.z, this.y, this.x);
};
set xzyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xzyy(): IVec4{
	return vec4(this.x, this.z, this.y, this.y);
};
set xzyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xzyz(): IVec4{
	return vec4(this.x, this.z, this.y, this.z);
};
set xzyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xzyw(): IVec4{
	return vec4(this.x, this.z, this.y, this.w);
};
set xzyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xzzx(): IVec4{
	return vec4(this.x, this.z, this.z, this.x);
};
set xzzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xzzy(): IVec4{
	return vec4(this.x, this.z, this.z, this.y);
};
set xzzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xzzz(): IVec4{
	return vec4(this.x, this.z, this.z, this.z);
};
set xzzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xzzw(): IVec4{
	return vec4(this.x, this.z, this.z, this.w);
};
set xzzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xzwx(): IVec4{
	return vec4(this.x, this.z, this.w, this.x);
};
set xzwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xzwy(): IVec4{
	return vec4(this.x, this.z, this.w, this.y);
};
set xzwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xzwz(): IVec4{
	return vec4(this.x, this.z, this.w, this.z);
};
set xzwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xzww(): IVec4{
	return vec4(this.x, this.z, this.w, this.w);
};
set xzww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get xwxx(): IVec4{
	return vec4(this.x, this.w, this.x, this.x);
};
set xwxx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get xwxy(): IVec4{
	return vec4(this.x, this.w, this.x, this.y);
};
set xwxy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get xwxz(): IVec4{
	return vec4(this.x, this.w, this.x, this.z);
};
set xwxz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get xwxw(): IVec4{
	return vec4(this.x, this.w, this.x, this.w);
};
set xwxw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get xwyx(): IVec4{
	return vec4(this.x, this.w, this.y, this.x);
};
set xwyx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get xwyy(): IVec4{
	return vec4(this.x, this.w, this.y, this.y);
};
set xwyy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get xwyz(): IVec4{
	return vec4(this.x, this.w, this.y, this.z);
};
set xwyz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get xwyw(): IVec4{
	return vec4(this.x, this.w, this.y, this.w);
};
set xwyw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get xwzx(): IVec4{
	return vec4(this.x, this.w, this.z, this.x);
};
set xwzx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get xwzy(): IVec4{
	return vec4(this.x, this.w, this.z, this.y);
};
set xwzy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get xwzz(): IVec4{
	return vec4(this.x, this.w, this.z, this.z);
};
set xwzz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get xwzw(): IVec4{
	return vec4(this.x, this.w, this.z, this.w);
};
set xwzw(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get xwwx(): IVec4{
	return vec4(this.x, this.w, this.w, this.x);
};
set xwwx(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get xwwy(): IVec4{
	return vec4(this.x, this.w, this.w, this.y);
};
set xwwy(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get xwwz(): IVec4{
	return vec4(this.x, this.w, this.w, this.z);
};
set xwwz(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get xwww(): IVec4{
	return vec4(this.x, this.w, this.w, this.w);
};
set xwww(v4fVec: IVec4){
	this.x = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yxxx(): IVec4{
	return vec4(this.y, this.x, this.x, this.x);
};
set yxxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yxxy(): IVec4{
	return vec4(this.y, this.x, this.x, this.y);
};
set yxxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yxxz(): IVec4{
	return vec4(this.y, this.x, this.x, this.z);
};
set yxxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yxxw(): IVec4{
	return vec4(this.y, this.x, this.x, this.w);
};
set yxxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yxyx(): IVec4{
	return vec4(this.y, this.x, this.y, this.x);
};
set yxyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yxyy(): IVec4{
	return vec4(this.y, this.x, this.y, this.y);
};
set yxyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yxyz(): IVec4{
	return vec4(this.y, this.x, this.y, this.z);
};
set yxyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yxyw(): IVec4{
	return vec4(this.y, this.x, this.y, this.w);
};
set yxyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yxzx(): IVec4{
	return vec4(this.y, this.x, this.z, this.x);
};
set yxzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yxzy(): IVec4{
	return vec4(this.y, this.x, this.z, this.y);
};
set yxzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yxzz(): IVec4{
	return vec4(this.y, this.x, this.z, this.z);
};
set yxzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yxzw(): IVec4{
	return vec4(this.y, this.x, this.z, this.w);
};
set yxzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yxwx(): IVec4{
	return vec4(this.y, this.x, this.w, this.x);
};
set yxwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yxwy(): IVec4{
	return vec4(this.y, this.x, this.w, this.y);
};
set yxwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yxwz(): IVec4{
	return vec4(this.y, this.x, this.w, this.z);
};
set yxwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yxww(): IVec4{
	return vec4(this.y, this.x, this.w, this.w);
};
set yxww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yyxx(): IVec4{
	return vec4(this.y, this.y, this.x, this.x);
};
set yyxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yyxy(): IVec4{
	return vec4(this.y, this.y, this.x, this.y);
};
set yyxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yyxz(): IVec4{
	return vec4(this.y, this.y, this.x, this.z);
};
set yyxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yyxw(): IVec4{
	return vec4(this.y, this.y, this.x, this.w);
};
set yyxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yyyx(): IVec4{
	return vec4(this.y, this.y, this.y, this.x);
};
set yyyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yyyy(): IVec4{
	return vec4(this.y, this.y, this.y, this.y);
};
set yyyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yyyz(): IVec4{
	return vec4(this.y, this.y, this.y, this.z);
};
set yyyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yyyw(): IVec4{
	return vec4(this.y, this.y, this.y, this.w);
};
set yyyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yyzx(): IVec4{
	return vec4(this.y, this.y, this.z, this.x);
};
set yyzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yyzy(): IVec4{
	return vec4(this.y, this.y, this.z, this.y);
};
set yyzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yyzz(): IVec4{
	return vec4(this.y, this.y, this.z, this.z);
};
set yyzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yyzw(): IVec4{
	return vec4(this.y, this.y, this.z, this.w);
};
set yyzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yywx(): IVec4{
	return vec4(this.y, this.y, this.w, this.x);
};
set yywx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yywy(): IVec4{
	return vec4(this.y, this.y, this.w, this.y);
};
set yywy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yywz(): IVec4{
	return vec4(this.y, this.y, this.w, this.z);
};
set yywz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yyww(): IVec4{
	return vec4(this.y, this.y, this.w, this.w);
};
set yyww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get yzxx(): IVec4{
	return vec4(this.y, this.z, this.x, this.x);
};
set yzxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get yzxy(): IVec4{
	return vec4(this.y, this.z, this.x, this.y);
};
set yzxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get yzxz(): IVec4{
	return vec4(this.y, this.z, this.x, this.z);
};
set yzxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get yzxw(): IVec4{
	return vec4(this.y, this.z, this.x, this.w);
};
set yzxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get yzyx(): IVec4{
	return vec4(this.y, this.z, this.y, this.x);
};
set yzyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get yzyy(): IVec4{
	return vec4(this.y, this.z, this.y, this.y);
};
set yzyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get yzyz(): IVec4{
	return vec4(this.y, this.z, this.y, this.z);
};
set yzyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get yzyw(): IVec4{
	return vec4(this.y, this.z, this.y, this.w);
};
set yzyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get yzzx(): IVec4{
	return vec4(this.y, this.z, this.z, this.x);
};
set yzzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get yzzy(): IVec4{
	return vec4(this.y, this.z, this.z, this.y);
};
set yzzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get yzzz(): IVec4{
	return vec4(this.y, this.z, this.z, this.z);
};
set yzzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get yzzw(): IVec4{
	return vec4(this.y, this.z, this.z, this.w);
};
set yzzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get yzwx(): IVec4{
	return vec4(this.y, this.z, this.w, this.x);
};
set yzwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get yzwy(): IVec4{
	return vec4(this.y, this.z, this.w, this.y);
};
set yzwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get yzwz(): IVec4{
	return vec4(this.y, this.z, this.w, this.z);
};
set yzwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get yzww(): IVec4{
	return vec4(this.y, this.z, this.w, this.w);
};
set yzww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get ywxx(): IVec4{
	return vec4(this.y, this.w, this.x, this.x);
};
set ywxx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get ywxy(): IVec4{
	return vec4(this.y, this.w, this.x, this.y);
};
set ywxy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get ywxz(): IVec4{
	return vec4(this.y, this.w, this.x, this.z);
};
set ywxz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get ywxw(): IVec4{
	return vec4(this.y, this.w, this.x, this.w);
};
set ywxw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get ywyx(): IVec4{
	return vec4(this.y, this.w, this.y, this.x);
};
set ywyx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get ywyy(): IVec4{
	return vec4(this.y, this.w, this.y, this.y);
};
set ywyy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get ywyz(): IVec4{
	return vec4(this.y, this.w, this.y, this.z);
};
set ywyz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get ywyw(): IVec4{
	return vec4(this.y, this.w, this.y, this.w);
};
set ywyw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get ywzx(): IVec4{
	return vec4(this.y, this.w, this.z, this.x);
};
set ywzx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get ywzy(): IVec4{
	return vec4(this.y, this.w, this.z, this.y);
};
set ywzy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get ywzz(): IVec4{
	return vec4(this.y, this.w, this.z, this.z);
};
set ywzz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get ywzw(): IVec4{
	return vec4(this.y, this.w, this.z, this.w);
};
set ywzw(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get ywwx(): IVec4{
	return vec4(this.y, this.w, this.w, this.x);
};
set ywwx(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get ywwy(): IVec4{
	return vec4(this.y, this.w, this.w, this.y);
};
set ywwy(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get ywwz(): IVec4{
	return vec4(this.y, this.w, this.w, this.z);
};
set ywwz(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get ywww(): IVec4{
	return vec4(this.y, this.w, this.w, this.w);
};
set ywww(v4fVec: IVec4){
	this.y = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zxxx(): IVec4{
	return vec4(this.z, this.x, this.x, this.x);
};
set zxxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zxxy(): IVec4{
	return vec4(this.z, this.x, this.x, this.y);
};
set zxxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zxxz(): IVec4{
	return vec4(this.z, this.x, this.x, this.z);
};
set zxxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zxxw(): IVec4{
	return vec4(this.z, this.x, this.x, this.w);
};
set zxxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zxyx(): IVec4{
	return vec4(this.z, this.x, this.y, this.x);
};
set zxyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zxyy(): IVec4{
	return vec4(this.z, this.x, this.y, this.y);
};
set zxyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zxyz(): IVec4{
	return vec4(this.z, this.x, this.y, this.z);
};
set zxyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zxyw(): IVec4{
	return vec4(this.z, this.x, this.y, this.w);
};
set zxyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zxzx(): IVec4{
	return vec4(this.z, this.x, this.z, this.x);
};
set zxzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zxzy(): IVec4{
	return vec4(this.z, this.x, this.z, this.y);
};
set zxzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zxzz(): IVec4{
	return vec4(this.z, this.x, this.z, this.z);
};
set zxzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zxzw(): IVec4{
	return vec4(this.z, this.x, this.z, this.w);
};
set zxzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zxwx(): IVec4{
	return vec4(this.z, this.x, this.w, this.x);
};
set zxwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zxwy(): IVec4{
	return vec4(this.z, this.x, this.w, this.y);
};
set zxwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zxwz(): IVec4{
	return vec4(this.z, this.x, this.w, this.z);
};
set zxwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zxww(): IVec4{
	return vec4(this.z, this.x, this.w, this.w);
};
set zxww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zyxx(): IVec4{
	return vec4(this.z, this.y, this.x, this.x);
};
set zyxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zyxy(): IVec4{
	return vec4(this.z, this.y, this.x, this.y);
};
set zyxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zyxz(): IVec4{
	return vec4(this.z, this.y, this.x, this.z);
};
set zyxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zyxw(): IVec4{
	return vec4(this.z, this.y, this.x, this.w);
};
set zyxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zyyx(): IVec4{
	return vec4(this.z, this.y, this.y, this.x);
};
set zyyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zyyy(): IVec4{
	return vec4(this.z, this.y, this.y, this.y);
};
set zyyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zyyz(): IVec4{
	return vec4(this.z, this.y, this.y, this.z);
};
set zyyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zyyw(): IVec4{
	return vec4(this.z, this.y, this.y, this.w);
};
set zyyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zyzx(): IVec4{
	return vec4(this.z, this.y, this.z, this.x);
};
set zyzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zyzy(): IVec4{
	return vec4(this.z, this.y, this.z, this.y);
};
set zyzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zyzz(): IVec4{
	return vec4(this.z, this.y, this.z, this.z);
};
set zyzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zyzw(): IVec4{
	return vec4(this.z, this.y, this.z, this.w);
};
set zyzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zywx(): IVec4{
	return vec4(this.z, this.y, this.w, this.x);
};
set zywx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zywy(): IVec4{
	return vec4(this.z, this.y, this.w, this.y);
};
set zywy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zywz(): IVec4{
	return vec4(this.z, this.y, this.w, this.z);
};
set zywz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zyww(): IVec4{
	return vec4(this.z, this.y, this.w, this.w);
};
set zyww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zzxx(): IVec4{
	return vec4(this.z, this.z, this.x, this.x);
};
set zzxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zzxy(): IVec4{
	return vec4(this.z, this.z, this.x, this.y);
};
set zzxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zzxz(): IVec4{
	return vec4(this.z, this.z, this.x, this.z);
};
set zzxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zzxw(): IVec4{
	return vec4(this.z, this.z, this.x, this.w);
};
set zzxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zzyx(): IVec4{
	return vec4(this.z, this.z, this.y, this.x);
};
set zzyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zzyy(): IVec4{
	return vec4(this.z, this.z, this.y, this.y);
};
set zzyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zzyz(): IVec4{
	return vec4(this.z, this.z, this.y, this.z);
};
set zzyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zzyw(): IVec4{
	return vec4(this.z, this.z, this.y, this.w);
};
set zzyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zzzx(): IVec4{
	return vec4(this.z, this.z, this.z, this.x);
};
set zzzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zzzy(): IVec4{
	return vec4(this.z, this.z, this.z, this.y);
};
set zzzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zzzz(): IVec4{
	return vec4(this.z, this.z, this.z, this.z);
};
set zzzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zzzw(): IVec4{
	return vec4(this.z, this.z, this.z, this.w);
};
set zzzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zzwx(): IVec4{
	return vec4(this.z, this.z, this.w, this.x);
};
set zzwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zzwy(): IVec4{
	return vec4(this.z, this.z, this.w, this.y);
};
set zzwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zzwz(): IVec4{
	return vec4(this.z, this.z, this.w, this.z);
};
set zzwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zzww(): IVec4{
	return vec4(this.z, this.z, this.w, this.w);
};
set zzww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get zwxx(): IVec4{
	return vec4(this.z, this.w, this.x, this.x);
};
set zwxx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get zwxy(): IVec4{
	return vec4(this.z, this.w, this.x, this.y);
};
set zwxy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get zwxz(): IVec4{
	return vec4(this.z, this.w, this.x, this.z);
};
set zwxz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get zwxw(): IVec4{
	return vec4(this.z, this.w, this.x, this.w);
};
set zwxw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get zwyx(): IVec4{
	return vec4(this.z, this.w, this.y, this.x);
};
set zwyx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get zwyy(): IVec4{
	return vec4(this.z, this.w, this.y, this.y);
};
set zwyy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get zwyz(): IVec4{
	return vec4(this.z, this.w, this.y, this.z);
};
set zwyz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get zwyw(): IVec4{
	return vec4(this.z, this.w, this.y, this.w);
};
set zwyw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get zwzx(): IVec4{
	return vec4(this.z, this.w, this.z, this.x);
};
set zwzx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get zwzy(): IVec4{
	return vec4(this.z, this.w, this.z, this.y);
};
set zwzy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get zwzz(): IVec4{
	return vec4(this.z, this.w, this.z, this.z);
};
set zwzz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get zwzw(): IVec4{
	return vec4(this.z, this.w, this.z, this.w);
};
set zwzw(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get zwwx(): IVec4{
	return vec4(this.z, this.w, this.w, this.x);
};
set zwwx(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get zwwy(): IVec4{
	return vec4(this.z, this.w, this.w, this.y);
};
set zwwy(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get zwwz(): IVec4{
	return vec4(this.z, this.w, this.w, this.z);
};
set zwwz(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get zwww(): IVec4{
	return vec4(this.z, this.w, this.w, this.w);
};
set zwww(v4fVec: IVec4){
	this.z = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wxxx(): IVec4{
	return vec4(this.w, this.x, this.x, this.x);
};
set wxxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wxxy(): IVec4{
	return vec4(this.w, this.x, this.x, this.y);
};
set wxxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wxxz(): IVec4{
	return vec4(this.w, this.x, this.x, this.z);
};
set wxxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wxxw(): IVec4{
	return vec4(this.w, this.x, this.x, this.w);
};
set wxxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wxyx(): IVec4{
	return vec4(this.w, this.x, this.y, this.x);
};
set wxyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wxyy(): IVec4{
	return vec4(this.w, this.x, this.y, this.y);
};
set wxyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wxyz(): IVec4{
	return vec4(this.w, this.x, this.y, this.z);
};
set wxyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wxyw(): IVec4{
	return vec4(this.w, this.x, this.y, this.w);
};
set wxyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wxzx(): IVec4{
	return vec4(this.w, this.x, this.z, this.x);
};
set wxzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wxzy(): IVec4{
	return vec4(this.w, this.x, this.z, this.y);
};
set wxzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wxzz(): IVec4{
	return vec4(this.w, this.x, this.z, this.z);
};
set wxzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wxzw(): IVec4{
	return vec4(this.w, this.x, this.z, this.w);
};
set wxzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wxwx(): IVec4{
	return vec4(this.w, this.x, this.w, this.x);
};
set wxwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wxwy(): IVec4{
	return vec4(this.w, this.x, this.w, this.y);
};
set wxwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wxwz(): IVec4{
	return vec4(this.w, this.x, this.w, this.z);
};
set wxwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wxww(): IVec4{
	return vec4(this.w, this.x, this.w, this.w);
};
set wxww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.x = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wyxx(): IVec4{
	return vec4(this.w, this.y, this.x, this.x);
};
set wyxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wyxy(): IVec4{
	return vec4(this.w, this.y, this.x, this.y);
};
set wyxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wyxz(): IVec4{
	return vec4(this.w, this.y, this.x, this.z);
};
set wyxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wyxw(): IVec4{
	return vec4(this.w, this.y, this.x, this.w);
};
set wyxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wyyx(): IVec4{
	return vec4(this.w, this.y, this.y, this.x);
};
set wyyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wyyy(): IVec4{
	return vec4(this.w, this.y, this.y, this.y);
};
set wyyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wyyz(): IVec4{
	return vec4(this.w, this.y, this.y, this.z);
};
set wyyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wyyw(): IVec4{
	return vec4(this.w, this.y, this.y, this.w);
};
set wyyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wyzx(): IVec4{
	return vec4(this.w, this.y, this.z, this.x);
};
set wyzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wyzy(): IVec4{
	return vec4(this.w, this.y, this.z, this.y);
};
set wyzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wyzz(): IVec4{
	return vec4(this.w, this.y, this.z, this.z);
};
set wyzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wyzw(): IVec4{
	return vec4(this.w, this.y, this.z, this.w);
};
set wyzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wywx(): IVec4{
	return vec4(this.w, this.y, this.w, this.x);
};
set wywx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wywy(): IVec4{
	return vec4(this.w, this.y, this.w, this.y);
};
set wywy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wywz(): IVec4{
	return vec4(this.w, this.y, this.w, this.z);
};
set wywz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wyww(): IVec4{
	return vec4(this.w, this.y, this.w, this.w);
};
set wyww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.y = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wzxx(): IVec4{
	return vec4(this.w, this.z, this.x, this.x);
};
set wzxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wzxy(): IVec4{
	return vec4(this.w, this.z, this.x, this.y);
};
set wzxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wzxz(): IVec4{
	return vec4(this.w, this.z, this.x, this.z);
};
set wzxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wzxw(): IVec4{
	return vec4(this.w, this.z, this.x, this.w);
};
set wzxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wzyx(): IVec4{
	return vec4(this.w, this.z, this.y, this.x);
};
set wzyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wzyy(): IVec4{
	return vec4(this.w, this.z, this.y, this.y);
};
set wzyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wzyz(): IVec4{
	return vec4(this.w, this.z, this.y, this.z);
};
set wzyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wzyw(): IVec4{
	return vec4(this.w, this.z, this.y, this.w);
};
set wzyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wzzx(): IVec4{
	return vec4(this.w, this.z, this.z, this.x);
};
set wzzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wzzy(): IVec4{
	return vec4(this.w, this.z, this.z, this.y);
};
set wzzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wzzz(): IVec4{
	return vec4(this.w, this.z, this.z, this.z);
};
set wzzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wzzw(): IVec4{
	return vec4(this.w, this.z, this.z, this.w);
};
set wzzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wzwx(): IVec4{
	return vec4(this.w, this.z, this.w, this.x);
};
set wzwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wzwy(): IVec4{
	return vec4(this.w, this.z, this.w, this.y);
};
set wzwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wzwz(): IVec4{
	return vec4(this.w, this.z, this.w, this.z);
};
set wzwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wzww(): IVec4{
	return vec4(this.w, this.z, this.w, this.w);
};
set wzww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.z = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

get wwxx(): IVec4{
	return vec4(this.w, this.w, this.x, this.x);
};
set wwxx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.x = v4fVec.w;
};

get wwxy(): IVec4{
	return vec4(this.w, this.w, this.x, this.y);
};
set wwxy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.y = v4fVec.w;
};

get wwxz(): IVec4{
	return vec4(this.w, this.w, this.x, this.z);
};
set wwxz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.z = v4fVec.w;
};

get wwxw(): IVec4{
	return vec4(this.w, this.w, this.x, this.w);
};
set wwxw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.x = v4fVec.z; 	this.w = v4fVec.w;
};

get wwyx(): IVec4{
	return vec4(this.w, this.w, this.y, this.x);
};
set wwyx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.x = v4fVec.w;
};

get wwyy(): IVec4{
	return vec4(this.w, this.w, this.y, this.y);
};
set wwyy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.y = v4fVec.w;
};

get wwyz(): IVec4{
	return vec4(this.w, this.w, this.y, this.z);
};
set wwyz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.z = v4fVec.w;
};

get wwyw(): IVec4{
	return vec4(this.w, this.w, this.y, this.w);
};
set wwyw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.y = v4fVec.z; 	this.w = v4fVec.w;
};

get wwzx(): IVec4{
	return vec4(this.w, this.w, this.z, this.x);
};
set wwzx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.x = v4fVec.w;
};

get wwzy(): IVec4{
	return vec4(this.w, this.w, this.z, this.y);
};
set wwzy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.y = v4fVec.w;
};

get wwzz(): IVec4{
	return vec4(this.w, this.w, this.z, this.z);
};
set wwzz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.z = v4fVec.w;
};

get wwzw(): IVec4{
	return vec4(this.w, this.w, this.z, this.w);
};
set wwzw(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.z = v4fVec.z; 	this.w = v4fVec.w;
};

get wwwx(): IVec4{
	return vec4(this.w, this.w, this.w, this.x);
};
set wwwx(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.x = v4fVec.w;
};

get wwwy(): IVec4{
	return vec4(this.w, this.w, this.w, this.y);
};
set wwwy(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.y = v4fVec.w;
};

get wwwz(): IVec4{
	return vec4(this.w, this.w, this.w, this.z);
};
set wwwz(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.z = v4fVec.w;
};

get wwww(): IVec4{
	return vec4(this.w, this.w, this.w, this.w);
};
set wwww(v4fVec: IVec4){
	this.w = v4fVec.x; 	this.w = v4fVec.y;
	this.w = v4fVec.z; 	this.w = v4fVec.w;
};

        constructor();
        constructor(fValue:  number );
        constructor(v4fVec: IVec4);
        constructor(pArray:  number []);
        constructor(fValue:  number , v3fVec: IVec3);
        constructor(v2fVec1: IVec2, v2fVec2: IVec2);
        constructor(v3fVec: IVec3, fValue:  number );
        constructor(fValue1:  number , fValue2:  number , v2fVec: IVec2);
        constructor(fValue1:  number , v2fVec: IVec2, fValue2:  number );
        constructor(v2fVec: IVec2 ,fValue1:  number , fValue2:  number );
        constructor(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
        constructor(fValue1?, fValue2?, fValue3?, fValue4?){
            var nArgumentsLength:  number  = arguments.length;
            var v4fVec: IVec4 = this;

// if (<any>this === window || <any>this === akra || <any>this === akra.math) {
//     v4fVec = Vec4.stack[Vec4.stackPosition ++];

//     if(Vec4.stackPosition == Vec4.stackSize){
//         Vec4.stackPosition = 0;
//     }
// }

            switch(nArgumentsLength) {
                case 1:
                    v4fVec.set(arguments[0]);
                    break;
                case 2:
                    v4fVec.set(arguments[0],arguments[1]);
                    break;
                case 3:
                    v4fVec.set(arguments[0],arguments[1], arguments[2]);
                    break;
                case 4:
                    v4fVec.set(arguments[0],arguments[1], arguments[2], arguments[3]);
                    break;
                default:
                    v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
                    break;
            }
        };

        set(): IVec4;
        set(fValue:  number ): IVec4;
        set(v4fVec: IVec4): IVec4;
        set(c4fColor: IColorValue): IVec4;
        set(pArray:  number []): IVec4;
        set(fValue:  number , v3fVec: IVec3): IVec4;
        set(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
        set(v3fVec: IVec3, fValue:  number ): IVec4;
        set(fValue1:  number , fValue2:  number , v2fVec: IVec2): IVec4;
        set(fValue1:  number , v2fVec: IVec2, fValue2:  number ): IVec4;
        set(v2fVec: IVec2, fValue1:  number , fValue2:  number ): IVec4;
        set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ): IVec4;
        set(fValue1?, fValue2?, fValue3?, fValue4?): IVec4{
            var nArgumentsLength:  number  = arguments.length;

            switch(nArgumentsLength){
                case 0:
                    this.x = this.y = this.z = this.w = 0.;
                    break;
                case 1:
                    if(isFloat(arguments[0])){
                        this.x = this.y = this.z = this.w = arguments[0];
                    }
                    else if(arguments[0] instanceof Vec4){
                        var v4fVec: IVec4 = arguments[0];

                        this.x = v4fVec.x;
                        this.y = v4fVec.y;
                        this.z = v4fVec.z;
                        this.w = v4fVec.w;
                    }
//color
                    else if (isDef(arguments[0].r)) {
                        this.x = arguments[0].r;
                        this.y = arguments[0].g;
                        this.z = arguments[0].b;
                        this.w = arguments[0].a;
                    }
                    else{
//array
                        var pArray:  number [] = arguments[0];

                        this.x = pArray[0];
                        this.y = pArray[1];
                        this.z = pArray[2];
                        this.w = pArray[3];
                    }
                    break;
                case 2:
                    if(isFloat(arguments[0])){
                        var fValue:  number  = arguments[0];
                        var v3fVec: IVec3 = arguments[1];

                        this.x = fValue;
                        this.y = v3fVec.x;
                        this.z = v3fVec.y;
                        this.w = v3fVec.z;
                    }
                    else if(arguments[0] instanceof Vec2){
                        var v2fVec1: IVec2 = arguments[0];
                        var v2fVec2: IVec2 = arguments[1];

                        this.x = v2fVec1.x;
                        this.y = v2fVec1.y;
                        this.z = v2fVec2.x;
                        this.w = v2fVec2.y;
                    }
                    else{
                        var v3fVec: IVec3 = arguments[0];
                        var fValue:  number  = arguments[1];

                        this.x = v3fVec.x;
                        this.y = v3fVec.y;
                        this.z = v3fVec.z;
                        this.w = fValue;
                    }
                    break;
                case 3:
                    if(isFloat(arguments[0])){
                        var fValue1:  number  = arguments[0];

                        if(isFloat(arguments[1])){
                            var fValue2:  number  = arguments[1];
                            var v2fVec: IVec2 = arguments[2];

                            this.x = fValue1;
                            this.y = fValue2;
                            this.z = v2fVec.x;
                            this.w = v2fVec.y;
                        }
                        else{
                            var v2fVec: IVec2 = arguments[1];
                            var fValue2:  number  = arguments[2];

                            this.x = fValue1;
                            this.y = v2fVec.x;
                            this.z = v2fVec.y;
                            this.w = fValue2;
                        }
                    }
                    else{
                        var v2fVec: IVec2 = arguments[0];
                        var fValue1:  number  = arguments[1];
                        var fValue2:  number  = arguments[2];

                        this.x = v2fVec.x;
                        this.y = v2fVec.y;
                        this.z = fValue1;
                        this.w = fValue2;
                    }
                    break;
                case 4:
                    this.x = arguments[0];
                    this.y = arguments[1];
                    this.z = arguments[2];
                    this.w = arguments[3];
                    break;
            }

            return this;
        };

        inline clear(): IVec4{
            this.x = this.y = this.z = this.w = 0.;
            return this;
        };

        add(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x + v4fVec.x;
            v4fDestination.y = this.y + v4fVec.y;
            v4fDestination.z = this.z + v4fVec.z;
            v4fDestination.w = this.w + v4fVec.w;

            return v4fDestination;
        };

        subtract(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x - v4fVec.x;
            v4fDestination.y = this.y - v4fVec.y;
            v4fDestination.z = this.z - v4fVec.z;
            v4fDestination.w = this.w - v4fVec.w;

            return v4fDestination;
        };

        inline dot(v4fVec: IVec4):  number {
            return this.x*v4fVec.x + this.y*v4fVec.y + this.z*v4fVec.z + this.w*v4fVec.w;
        };

        isEqual(v4fVec: IVec4, fEps:  number  = 0.): bool{
            if(fEps === 0.){
                if(    this.x != v4fVec.x
                    || this.y != v4fVec.y
                    || this.z != v4fVec.z
                    || this.w != v4fVec.w){

                    return false;
                }
            }
            else{
                if(    abs(this.x - v4fVec.x) > fEps
                    || abs(this.y - v4fVec.y) > fEps
                    || abs(this.z - v4fVec.z) > fEps
                    || abs(this.w - v4fVec.w) > fEps){

                    return false;
                }
            }
            return true;
        };

        isClear(fEps:  number  = 0.): bool{

            if(fEps === 0.){
                if(    this.x != 0.
                    || this.y != 0.
                    || this.z != 0.
                    || this.w != 0.){

                    return false;
                }
            }
            else{
                if(    abs(this.x) > fEps
                    || abs(this.y) > fEps
                    || abs(this.z) > fEps
                    || abs(this.w) > fEps){

                    return false;
                }
            }
            return true;
        };

        negate(v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = -this.x;
            v4fDestination.y = -this.y;
            v4fDestination.z = -this.z;
            v4fDestination.w = -this.w;

            return v4fDestination;
        };

        scale(fScale:  number , v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            v4fDestination.x = this.x*fScale;
            v4fDestination.y = this.y*fScale;
            v4fDestination.z = this.z*fScale;
            v4fDestination.w = this.w*fScale;

            return v4fDestination;
        };

        normalize(v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            var fLength:  number  = sqrt(x*x + y*y +z*z + w*w);

            if(fLength !== 0.){
                var fInvLength:  number  = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                w *= fInvLength;
            }

            v4fDestination.x = x;
            v4fDestination.y = y;
            v4fDestination.z = z;
            v4fDestination.w = w;

            return v4fDestination;
        };

        inline length():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            return sqrt(x*x + y*y + z*z + w*w);
        };

        inline lengthSquare():  number {
            var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
            return x*x + y*y + z*z + w*w;
        };

        direction(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            var x:  number  = v4fVec.x - this.x;
            var y:  number  = v4fVec.y - this.y;
            var z:  number  = v4fVec.z - this.z;
            var w:  number  = v4fVec.w - this.w;

            var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);

            if(fLength !== 0.){
                var fInvLength = 1./fLength;

                x *= fInvLength;
                y *= fInvLength;
                z *= fInvLength;
                w *= fInvLength;
            }

            v4fDestination.x = x;
            v4fDestination.y = y;
            v4fDestination.z = z;
            v4fDestination.w = w;

            return v4fDestination;
        };

        mix(v4fVec: IVec4, fA:  number , v4fDestination?: IVec4): IVec4{
            if(!isDef(v4fDestination)){
                v4fDestination = this;
            }

            fA = clamp(fA,0.,1.);

            var fA1:  number  = 1. - fA;
            var fA2:  number  = fA;

            v4fDestination.x = fA1*this.x + fA2*v4fVec.x;
            v4fDestination.y = fA1*this.y + fA2*v4fVec.y;
            v4fDestination.z = fA1*this.z + fA2*v4fVec.z;
            v4fDestination.w = fA1*this.w + fA2*v4fVec.w;

            return v4fDestination;
        };

        inline toString(): string{
            return "[x: " + this.x + ", y: " + this.y
                        + ", z: " + this.z + ", w: " + this.w + "]";
        };

        static get stackCeil(): Vec4 { Vec4.stackPosition = Vec4.stackPosition === Vec4.stackSize - 1? 0: Vec4.stackPosition; return Vec4.stack[Vec4.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Vec4[] = (function(): Vec4[]{ var pStack: Vec4[] = new Array(Vec4.stackSize); for(var i: number = 0; i<Vec4.stackSize; i++){ pStack[i] = new Vec4(); } return pStack})();

    }
}





// module akra.math {
//     export class Mat2 {
//         private pData: Float32Array = new Float32Array(4);

//         constructor ();
//         constructor (m2f: Mat2);
//         constructor (f11: float, f12: float, f21: float, f22: float);
//         constructor (f11? , f12? , f21? , f22? ) {
//             switch (arguments.length) {
//                 case 1:
//                     this.set(f11);
//                     break;
//                 case 4:
//                     this.set(f11, f12, f21, f22);
//                     break;
//             }
//         }

//         set(): Mat2;
//         set(m2f: Mat2): Mat2;
//         set(f11: float, f12: float, f21: float, f22: float): Mat2;
//         set(f11? , f12? , f21? , f22? ): Mat2 {

//             var pData: Float32Array = this.pData;

//             switch (arguments.length) {
//                 case 1:
//                     if (isFloat(f11)) {
//                         pData[0] = pData[1] = pData[2] = pData[3] = f11;
//                     }
//                     else {
//                         //pData.set(f11.pData);
//                     }
//                     break;
//                 case 4:
//                     pData[0] = f11;
//                     pData[1] = f21;
//                     pData[2] = f12;
//                     pData[3] = f22;
//                     break;
//             }
//             return this;
//         }
//     }
// }









/**
 * @important Если внезапно задумаем перейти обратно на 
 * хранение данных в матрицах по строкам, как собственно и было в начале,
 * то необходимо раскомментить definы и переписать метод set, 
 * так как он ложит по столбцам
 */


// #define __a11 0
// #define __a12 1
// #define __a13 2
// #define __a21 3
// #define __a22 4
// #define __a23 5
// #define __a31 6
// #define __a32 7
// #define __a33 8











module akra {
	export interface IMat4 {} ;
	export interface IVec3 {} ;
	export interface IQuat4 {} ;

	export interface IMat3Constructor {
		();
		(fValue:  number );
		(v3fVec: IVec3);
		(m3fMat: IMat3);
		(m4fMat: IMat4);
		(pArray:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number );
		(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3);
		(pArray1:  number [], pArray2:  number [], pArray3:  number []);
		(fValue1:  number , fValue2:  number , fValue3:  number ,
					fValue4:  number , fValue5:  number , fValue6:  number ,
					fValue7:  number , fValue8:  number , fValue9:  number );
	}

	export interface IMat3 {
		data: Float32Array;

		set(): IMat3;
		set(fValue:  number ): IMat3;
		set(v3fVec: IVec3): IMat3;
		set(m3fMat: IMat3): IMat3;
		set(m4fMat: IMat4): IMat3;
		set(pArray:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IMat3;
		set(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
		set(pArray1:  number [], pArray2:  number [], pArray3:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ,
			fValue4:  number , fValue5:  number , fValue6:  number ,
			fValue7:  number , fValue8:  number , fValue9:  number ): IMat3;

		identity(): IMat3;

		add(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		subtract(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		multiply(m3fMat: IMat3, m3fDestination?: IMat3): IMat3;
		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		transpose(m3fDestination?: IMat3): IMat3;
		determinant():  number ;
		inverse(m3fDestination?: IMat3): IMat3;

		isEqual(m3fMat: IMat3, fEps?:  number ): bool;
		isDiagonal(fEps?:  number ) : bool;

		toMat4(m4fDestination?: IMat4): IMat4;
		toQuat4(q4fDestination?: IQuat4): IQuat4;
		toString(): string;

		decompose(q4fRotation: IQuat4, v3fScale: IVec3): bool;
		row(iRow:  number , v3fDestination?: IVec3): IVec3;
		column(iColumn:  number , v3fDestination?: IVec3): IVec3;
	};
};










module akra {

	export interface IVec3 {} ;
	export interface IMat3 {} ;
	export interface IMat4 {} ;

	export interface IQuat4Constructor {
		();
    	(q4fQuat: IQuat4);
    	(pArray:  number []);
    	(fValue:  number , fW:  number );
    	(v3fValue: IVec3, fW:  number );
    	(fX:  number , fY:  number , fZ:  number , fW:  number );
	}

	export interface IQuat4 {
		x:  number ;
		y:  number ;
		z:  number ;
		w:  number ;

		set(): IQuat4;
		set(q4fQuat: IQuat4): IQuat4;
		set(pArray:  number []): IQuat4;
		set(fValue:  number , fW:  number ): IQuat4;
		set(v3fValue: IVec3, fW:  number ): IQuat4;
		set(fX:  number , fY:  number , fZ:  number , fW:  number ): IQuat4;

		multiply(q4fQuat: IQuat4, q4fDestination?: IQuat4): IQuat4;
		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3;

		conjugate(q4fDestination?: IQuat4): IQuat4;
		inverse(q4fDestination?: IQuat4): IQuat4;

		length():  number ;
		normalize(q4fDestination?: IQuat4): IQuat4;

		calculateW(q4fDestination?: IQuat4): IQuat4;

		isEqual(q4fQuat: IQuat4, fEps?:  number , asMatrix?: bool): bool;

		getYaw():  number ;
		getPitch():  number ;
		getRoll():  number ;
		toYawPitchRoll(v3fDestination?: IVec3): IVec3;

		toMat3(m3fDestination?: IMat3): IMat3;
		toMat4(m4fDestination?: IMat4): IMat4;
		toString(): string;

		mix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath?: bool);
		smix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath?: bool);
	};
};



module akra.math {

    export class Mat3 {
	    data : Float32Array;

	    constructor();
		constructor(fValue:  number );
		constructor(v3fVec: IVec3);
		constructor(m3fMat: IMat3);
		constructor(m4fMat: IMat4);
		constructor(pArray:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number );
		constructor(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3);
		constructor(pArray1:  number [], pArray2:  number [], pArray3:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number ,
					fValue4:  number , fValue5:  number , fValue6:  number ,
					fValue7:  number , fValue8:  number , fValue9:  number );

		constructor(fValue1?, fValue2?, fValue3?,
					fValue4?, fValue5?, fValue6?,
					fValue7?, fValue8?, fValue9?){


			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				case 9:
					this.set(arguments[0], arguments[1], arguments[2],
							 arguments[3], arguments[4], arguments[5],
							 arguments[6], arguments[7], arguments[8]);
					break;
				default:
					break;
			}
		};

		set(): IMat3;
		set(fValue:  number ): IMat3;
		set(v3fVec: IVec3): IMat3;
		set(m3fMat: IMat3): IMat3;
		set(m4fMat: IMat4): IMat3;
		set(pArray:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ): IMat3;
		set(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
		set(pArray1:  number [], pArray2:  number [], pArray3:  number []): IMat3;
		set(fValue1:  number , fValue2:  number , fValue3:  number ,
			fValue4:  number , fValue5:  number , fValue6:  number ,
			fValue7:  number , fValue8:  number , fValue9:  number ): IMat3;

		set(fValue1?, fValue2?, fValue3?,
			fValue4?, fValue5?, fValue6?,
			fValue7?, fValue8?, fValue9?): IMat3{

			this.data = this.data || new Float32Array(9);

			var pData: Float32Array = this.data;

//без аргументов инициализируется нулями

		    var nArgumentsLength:  number  = arguments.length;
		    if(nArgumentsLength == 0){
		        pData[ 0 ] = pData[ 3 ] = pData[ 6 ] = 0;
		        pData[ 1 ] = pData[ 4 ] = pData[ 7 ] = 0;
		        pData[ 2 ] = pData[ 5 ] = pData[ 8 ] = 0;
		    }
		    if(nArgumentsLength == 1){
		        if(isFloat(arguments[0])){
		            var nValue:  number  = arguments[0];

		            pData[ 0 ] = nValue;
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = nValue;
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = nValue;
		        }

		        else if(isDef(arguments[0].data)){
		            var pElements: Float32Array = arguments[0].data;

		            if(pElements.length === 9){
//Mat3
			            pData[ 0 ] = pElements[ 0 ];
			            pData[ 3 ] = pElements[ 3 ];
			            pData[ 6 ] = pElements[ 6 ];

			            pData[ 1 ] = pElements[ 1 ];
			            pData[ 4 ] = pElements[ 4 ];
			            pData[ 7 ] = pElements[ 7 ];

			            pData[ 2 ] = pElements[ 2 ];
			            pData[ 5 ] = pElements[ 5 ];
			            pData[ 8 ] = pElements[ 8 ];
		        	}
		        	else{
//Mat4
		        		pData[ 0 ] = pElements[ 0 ];
			            pData[ 3 ] = pElements[ 4 ];
			            pData[ 6 ] = pElements[ 8 ];

			            pData[ 1 ] = pElements[ 1 ];
			            pData[ 4 ] = pElements[ 5 ];
			            pData[ 7 ] = pElements[ 9 ];

			            pData[ 2 ] = pElements[ 2 ];
			            pData[ 5 ] = pElements[ 6 ];
			            pData[ 8 ] = pElements[ 10 ];
		        	}
		        }
		        else if(arguments[0] instanceof Vec3){
		            var v3fVec: IVec3 = arguments[0];

//диагональ

		            pData[ 0 ] = v3fVec.x;
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = v3fVec.y;
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = v3fVec.z;
		        }
		        else{
		            var pElements:  number [] = arguments[0];

		            if(pElements.length == 3){
//ложим диагональ
		                pData[ 0 ] = pElements[0];
		                pData[ 3 ] = 0;
		                pData[ 6 ] = 0;

		                pData[ 1 ] = 0;
		                pData[ 4 ] = pElements[1];
		                pData[ 7 ] = 0;

		                pData[ 2 ] = 0;
		                pData[ 5 ] = 0;
		                pData[ 8 ] = pElements[2];
		            }
		            else{
		                pData[ 0 ] = pElements[ 0 ];
		                pData[ 3 ] = pElements[ 3 ];
		                pData[ 6 ] = pElements[ 6 ];

		                pData[ 1 ] = pElements[ 1 ];
		                pData[ 4 ] = pElements[ 4 ];
		                pData[ 7 ] = pElements[ 7 ];

		                pData[ 2 ] = pElements[ 2 ];
		                pData[ 5 ] = pElements[ 5 ];
		                pData[ 8 ] = pElements[ 8 ];
		            }
		        }
		    }
		    else if(nArgumentsLength == 3){
		        if(isFloat(arguments[0])){
//выставляем диагональ
		            pData[ 0 ] = arguments[0];
		            pData[ 3 ] = 0;
		            pData[ 6 ] = 0;

		            pData[ 1 ] = 0;
		            pData[ 4 ] = arguments[1];
		            pData[ 7 ] = 0;

		            pData[ 2 ] = 0;
		            pData[ 5 ] = 0;
		            pData[ 8 ] = arguments[2];
		        }
		        else{
		            var pData1,pData2,pData3;
		            if(arguments[0] instanceof Vec3){

		                var v3fVec1: IVec3 = arguments[0];
		                var v3fVec2: IVec3 = arguments[1];
		                var v3fVec3: IVec3 = arguments[2];

//ложим по столбцам

		                pData[ 0 ] = v3fVec1.x;
		                pData[ 3 ] = v3fVec2.x;
		                pData[ 6 ] = v3fVec3.x;

		                pData[ 1 ] = v3fVec1.y;
		                pData[ 4 ] = v3fVec2.y;
		                pData[ 7 ] = v3fVec3.y;

		                pData[ 2 ] = v3fVec1.z;
		                pData[ 5 ] = v3fVec2.z;
		                pData[ 8 ] = v3fVec3.z;
		            }
		            else{

		                var v3fVec1:  number [] = arguments[0];
		                var v3fVec2:  number [] = arguments[1];
		                var v3fVec3:  number [] = arguments[2];

//ложим по столбцам

		                pData[ 0 ] = v3fVec1[0];
		                pData[ 3 ] = v3fVec2[0];
		                pData[ 6 ] = v3fVec3[0];

		                pData[ 1 ] = v3fVec1[1];
		                pData[ 4 ] = v3fVec2[1];
		                pData[ 7 ] = v3fVec3[1];

		                pData[ 2 ] = v3fVec1[2];
		                pData[ 5 ] = v3fVec2[2];
		                pData[ 8 ] = v3fVec3[2];
		            }
		        }
		    }
		    else if(nArgumentsLength == 9){
//просто числа
		        pData[ 0 ] = arguments[ 0 ];
		        pData[ 3 ] = arguments[ 3 ];
		        pData[ 6 ] = arguments[ 6 ];

		        pData[ 1 ] = arguments[ 1 ];
		        pData[ 4 ] = arguments[ 4 ];
		        pData[ 7 ] = arguments[ 7 ];

		        pData[ 2 ] = arguments[ 2 ];
		        pData[ 5 ] = arguments[ 5 ];
		        pData[ 8 ] = arguments[ 8 ];
		    }

		    return this;
		};

		identity(): IMat3{
			var pData: Float32Array = this.data;

		    pData[ 0 ] = 1.;
		    pData[ 3 ] = 0.;
		    pData[ 6 ] = 0.;

		    pData[ 1 ] = 0.;
		    pData[ 4 ] = 1.;
		    pData[ 7 ] = 0.;

		    pData[ 2 ] = 0.;
		    pData[ 5 ] = 0.;
		    pData[ 8 ] = 1.;

		    return this;
		};

		add(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData1[ 0 ] + pData2[ 0 ];
		    pDataDestination[ 3 ] = pData1[ 3 ] + pData2[ 3 ];
		    pDataDestination[ 6 ] = pData1[ 6 ] + pData2[ 6 ];

		    pDataDestination[ 1 ] = pData1[ 1 ] + pData2[ 1 ];
		    pDataDestination[ 4 ] = pData1[ 4 ] + pData2[ 4 ];
		    pDataDestination[ 7 ] = pData1[ 7 ] + pData2[ 7 ];

		    pDataDestination[ 2 ] = pData1[ 2 ] + pData2[ 2 ];
		    pDataDestination[ 5 ] = pData1[ 5 ] + pData2[ 5 ];
		    pDataDestination[ 8 ] = pData1[ 8 ] + pData2[ 8 ];

		    return m3fDestination;
		};

		subtract(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData1[ 0 ] - pData2[ 0 ];
		    pDataDestination[ 3 ] = pData1[ 3 ] - pData2[ 3 ];
		    pDataDestination[ 6 ] = pData1[ 6 ] - pData2[ 6 ];

		    pDataDestination[ 1 ] = pData1[ 1 ] - pData2[ 1 ];
		    pDataDestination[ 4 ] = pData1[ 4 ] - pData2[ 4 ];
		    pDataDestination[ 7 ] = pData1[ 7 ] - pData2[ 7 ];

		    pDataDestination[ 2 ] = pData1[ 2 ] - pData2[ 2 ];
		    pDataDestination[ 5 ] = pData1[ 5 ] - pData2[ 5 ];
		    pDataDestination[ 8 ] = pData1[ 8 ] - pData2[ 8 ];

		    return m3fDestination;
		};

		multiply(m3fMat: IMat3, m3fDestination?: IMat3): IMat3{
			var pData1: Float32Array = this.data;
	        var pData2: Float32Array = m3fMat.data;

	        if(!isDef(m3fDestination)){
	            m3fDestination = this;
	        }
	        var pDataDestination = m3fDestination.data;

// Cache the matrix values (makes for huge speed increases!)
	        var a11:  number  = pData1[ 0 ], a12:  number  = pData1[ 3 ], a13:  number  = pData1[ 6 ];
	        var a21:  number  = pData1[ 1 ], a22:  number  = pData1[ 4 ], a23:  number  = pData1[ 7 ];
	        var a31:  number  = pData1[ 2 ], a32:  number  = pData1[ 5 ], a33:  number  = pData1[ 8 ];

	        var b11:  number  = pData2[ 0 ], b12:  number  = pData2[ 3 ], b13:  number  = pData2[ 6 ];
	        var b21:  number  = pData2[ 1 ], b22:  number  = pData2[ 4 ], b23:  number  = pData2[ 7 ];
	        var b31:  number  = pData2[ 2 ], b32:  number  = pData2[ 5 ], b33:  number  = pData2[ 8 ];

	        pDataDestination[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
	        pDataDestination[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
	        pDataDestination[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

	        pDataDestination[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
	        pDataDestination[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
	        pDataDestination[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

	        pDataDestination[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
	        pDataDestination[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
	        pDataDestination[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		    return m3fDestination;
		};

		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
			var pData: Float32Array = this.data;

	        if(!isDef(v3fDestination)){
	            v3fDestination = v3fVec;
	        }

	        var x:  number  = v3fVec.x, y:  number  = v3fVec.y, z:  number  = v3fVec.z;

	        v3fDestination.x = pData[ 0 ] * x + pData[ 3 ] * y + pData[ 6 ] * z;
	        v3fDestination.y = pData[ 1 ] * x + pData[ 4 ] * y + pData[ 7 ] * z;
	        v3fDestination.z = pData[ 2 ] * x + pData[ 5 ] * y + pData[ 8 ] * z;

		    return v3fDestination;
		};

		transpose(m3fDestination?: IMat3): IMat3{
			var pData: Float32Array = this.data;
		    if(!isDef(m3fDestination)){
//быстрее будет явно обработать оба случая
		        var a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ], a23:  number  = pData[ 7 ];

		        pData[ 3 ] = pData[ 1 ];
		        pData[ 6 ] = pData[ 2 ];

		        pData[ 1 ] = a12;
		        pData[ 7 ] = pData[ 5 ];

		        pData[ 2 ] = a13;
		        pData[ 5 ] = a23;

		        return this;
		    }

		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 3 ] = pData[ 1 ];
		    pDataDestination[ 6 ] = pData[ 2 ];

		    pDataDestination[ 1 ] = pData[ 3 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 7 ] = pData[ 5 ];

		    pDataDestination[ 2 ] = pData[ 6 ];
		    pDataDestination[ 5 ] = pData[ 7 ];
		    pDataDestination[ 8 ] = pData[ 8 ];

		    return m3fDestination;
		};

		determinant():  number {
			var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

		    return  a11 * (a22 * a33 - a23 * a32)
		            - a12 * (a21 * a33 - a23 * a31)
		            + a13 * (a21 * a32 - a22 * a31);
		};

		inverse(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = this;
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

		    var A11:  number  = a22 * a33 - a23 * a32;
		    var A12:  number  = a21 * a33 - a23 * a31;
		    var A13:  number  = a21 * a32 - a22 * a31;

		    var A21:  number  = a12 * a33 - a13 * a32;
		    var A22:  number  = a11 * a33 - a13 * a31;
		    var A23:  number  = a11 * a32 - a12 * a31;

		    var A31:  number  = a12 * a23 - a13 * a22;
		    var A32:  number  = a11 * a23 - a13 * a21;
		    var A33:  number  = a11 * a22 - a12 * a21;

		    var fDeterminant:  number  = a11*A11 - a12 * A12 + a13 * A13;

		    if(fDeterminant == 0.){
		        logger.setSourceLocation( "Mat3.ts" , 445 ); logger.error("обращение матрицы с нулевым детеминантом:\n", this.toString());
                                      ;

		        return m3fDestination.set(1.);
//чтоб все не навернулось
		    }

		    var fInverseDeterminant:  number  = 1./fDeterminant;

		    pDataDestination[ 0 ] = A11 * fInverseDeterminant;
		    pDataDestination[ 3 ] = -A21 * fInverseDeterminant;
		    pDataDestination[ 6 ] = A31 * fInverseDeterminant;

		    pDataDestination[ 1 ] = -A12 * fInverseDeterminant;
		    pDataDestination[ 4 ] = A22 * fInverseDeterminant;
		    pDataDestination[ 7 ] = -A32 * fInverseDeterminant;

		    pDataDestination[ 2 ] = A13 * fInverseDeterminant;
		    pDataDestination[ 5 ] = -A23 * fInverseDeterminant;
		    pDataDestination[ 8 ] = A33 * fInverseDeterminant;

		    return m3fDestination;
		};

		isEqual(m3fMat: IMat3, fEps:  number  = 0.): bool{
			var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m3fMat.data;

		    if(fEps == 0){
		        if(    pData1[ 0 ] != pData2[ 0 ]
		            || pData1[ 3 ] != pData2[ 3 ]
		            || pData1[ 6 ] != pData2[ 6 ]
		            || pData1[ 1 ] != pData2[ 1 ]
		            || pData1[ 4 ] != pData2[ 4 ]
		            || pData1[ 7 ] != pData2[ 7 ]
		            || pData1[ 2 ] != pData2[ 2 ]
		            || pData1[ 5 ] != pData2[ 5 ]
		            || pData1[ 8 ] != pData2[ 8 ]){

		            return false;
		        }
		    }
		    else{
		        if(    Math.abs(pData1[ 0 ] - pData2[ 0 ]) > fEps
		            || Math.abs(pData1[ 3 ] - pData2[ 3 ]) > fEps
		            || Math.abs(pData1[ 6 ] - pData2[ 6 ]) > fEps
		            || Math.abs(pData1[ 1 ] - pData2[ 1 ]) > fEps
		            || Math.abs(pData1[ 4 ] - pData2[ 4 ]) > fEps
		            || Math.abs(pData1[ 7 ] - pData2[ 7 ]) > fEps
		            || Math.abs(pData1[ 2 ] - pData2[ 2 ]) > fEps
		            || Math.abs(pData1[ 5 ] - pData2[ 5 ]) > fEps
		            || Math.abs(pData1[ 8 ] - pData2[ 8 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		isDiagonal(fEps:  number  = 0.) : bool{
			var pData: Float32Array = this.data;

		    if(fEps == 0){
		        if(    pData[ 3 ] != 0 || pData[ 6 ] != 0
		            || pData[ 1 ] != 0 || pData[ 7 ] != 0
		            || pData[ 2 ] != 0 || pData[ 5 ] != 0){

		            return false;
		        }
		    }
		    else{
		        if(    Math.abs(pData[ 3 ]) > fEps || Math.abs(pData[ 6 ]) > fEps
		            || Math.abs(pData[ 1 ]) > fEps || Math.abs(pData[ 7 ]) > fEps
		            || Math.abs(pData[ 2 ]) > fEps || Math.abs(pData[ 5 ]) > fEps){

		            return false;
		        }
		    }

		    return true;
		};

		toMat4(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 3 ];
		    pDataDestination[ 8 ] = pData[ 6 ];
		    pDataDestination[ 12 ] = 0;

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 4 ];
		    pDataDestination[ 9 ] = pData[ 7 ];
		    pDataDestination[ 13 ] = 0;

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 5 ];
		    pDataDestination[ 10 ] = pData[ 8 ];
		    pDataDestination[ 14 ] = 0;

		    pDataDestination[ 3 ] = 0;
		    pDataDestination[ 7 ] = 0;
		    pDataDestination[ 11 ] = 0;
		    pDataDestination[ 15 ] = 1;

		    return m4fDestination;
		};

		toQuat4(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 3 ], a13:  number  = pData[ 6 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 4 ], a23:  number  = pData[ 7 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 5 ], a33:  number  = pData[ 8 ];

/*x^2*/
		    var x2:  number  = ((a11 - a22 - a33) + 1)/4;
/*y^2*/
		    var y2:  number  = ((a22 - a11 - a33) + 1)/4;
/*z^2*/
		    var z2:  number  = ((a33 - a11 - a22) + 1)/4;
/*w^2*/
		    var w2:  number  = ((a11 + a22 + a33) + 1)/4;

		    var fMax:  number  = Math.max(x2,Math.max(y2,Math.max(z2,w2)));

		    if(fMax == x2){
//максимальная компонента берется положительной
		        var x:  number  = Math.sqrt(x2);

		        q4fDestination.x = x;
		        q4fDestination.y = (a21 + a12)/4/x;
		        q4fDestination.z = (a31 + a13)/4/x;
		        q4fDestination.w = (a32 - a23)/4/x;
		    }
		    else if(fMax == y2){
//максимальная компонента берется положительной
		        var y:  number  = Math.sqrt(y2);

		        q4fDestination.x = (a21 + a12)/4/y;
		        q4fDestination.y = y;
		        q4fDestination.z = (a32 + a23)/4/y;
		        q4fDestination.w = (a13 - a31)/4/y;
		    }
		    else if(fMax == z2){
//максимальная компонента берется положительной
		        var z:  number  = Math.sqrt(z2);

		        q4fDestination.x = (a31 + a13)/4/z;
		        q4fDestination.y = (a32 + a23)/4/z;
		        q4fDestination.z = z;
		        q4fDestination.w = (a21 - a12)/4/z;
		    }
		    else{
//максимальная компонента берется положительной
		        var w:  number  = Math.sqrt(w2);

		        q4fDestination.x = (a32 - a23)/4/w;
		        q4fDestination.y = (a13 - a31)/4/w;
		        q4fDestination.z = (a21 - a12)/4/w;
		        q4fDestination.w = w;
		    }

		    return q4fDestination;
		};

		toString(): string{
			var pData = this.data;
		    return '[' + pData[ 0 ] + ', ' + pData[ 3 ] + ', ' + pData[ 6 ] + ',\n' +
		               + pData[ 1 ] + ', ' + pData[ 4 ] + ', ' + pData[ 7 ] + ',\n' +
		               + pData[ 2 ] + ', ' + pData[ 5 ] + ', ' + pData[ 8 ] + ']';
		};

		decompose(q4fRotation: IQuat4, v3fScale: IVec3): bool{
//изначально предполагаем, что порядок умножения был rot * scale
			var m3fRotScale: IMat3 = this;
			var m3fRotScaleTransposed: IMat3 = this.transpose(mat3());
			var isRotScale: bool = true;

//понадобятся если порядок умножения был другим
		    var m3fScaleRot: IMat3 = null, m3fScaleRotTransposed: IMat3 = null;

//было отражение или нет
    		var scaleSign:  number  = (m3fRotScale.determinant() >= 0.) ? 1 : -1;

    		var m3fResult: IMat3 = mat3();

//first variant rot * scale
// (rot * scale)T * (rot * scale) = 
// scaleT * rotT * rot * scale = scaleT *rot^-1 * rot * scale = 
// scaleT * scale
		    m3fRotScaleTransposed.multiply(m3fRotScale, m3fResult);
		   	if(!m3fResult.isDiagonal(1e-4)){
//предположение было неверным
		   		isRotScale = false;
//просто переобозначения чтобы не было путаницы
		        m3fScaleRot = m3fRotScale;
		        m3fScaleRotTransposed = m3fRotScaleTransposed;

//second variant scale * rot
// (scale * rot) * (scale * rot)T = 
// scale * rot * rotT * scaleT = scale *rot * rot^-1 * scaleT = 
// scale * scaleT

		        m3fScaleRot.multiply(m3fScaleRotTransposed,m3fResult);
		   	}

		   	var pResultData: Float32Array = m3fResult.data;

		   	var x:  number  = sqrt(pResultData[ 0 ]);
/*если было отражение, считается что оно было по y*/
		   	var y:  number  = sqrt(pResultData[ 4 ])*scaleSign;
		   	var z:  number  = sqrt(pResultData[ 8 ]);

		   	v3fScale.x = x;
		   	v3fScale.y = y;
		   	v3fScale.z = z;

		   	var m3fInverseScale: IMat3 = mat3(1./x,1./y,1./z);

		   	if(isRotScale){
		   		m3fRotScale.multiply(m3fInverseScale,mat3()).toQuat4(q4fRotation);
		   		return true;
		   	}
		   	else{
		   		m3fInverseScale.multiply(m3fScaleRot,mat3()).toQuat4(q4fRotation);
		   		logger.setSourceLocation( "Mat3.ts" , 674 ); logger.assert(false,"порядок умножения scale rot в данный момент не поддерживается"); ;
		   		return false;
		   	}
		};

		row(iRow:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var pData: Float32Array = this.data;

			switch(iRow){
				case 1:
					v3fDestination.x = pData[ 0 ];
					v3fDestination.y = pData[ 3 ];
					v3fDestination.z = pData[ 6 ];
					break;
				case 2:
					v3fDestination.x = pData[ 1 ];
					v3fDestination.y = pData[ 4 ];
					v3fDestination.z = pData[ 7 ];
					break;
				case 3:
					v3fDestination.x = pData[ 2 ];
					v3fDestination.y = pData[ 5 ];
					v3fDestination.z = pData[ 8 ];
					break;
			}

			return v3fDestination;
		};

		column(iColumn:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var pData: Float32Array = this.data;

			switch(iColumn){
				case 1:
					v3fDestination.x = pData[ 0 ];
					v3fDestination.y = pData[ 1 ];
					v3fDestination.z = pData[ 2 ];
					break;
				case 2:
					v3fDestination.x = pData[ 3 ];
					v3fDestination.y = pData[ 4 ];
					v3fDestination.z = pData[ 5 ];
					break;
				case 3:
					v3fDestination.x = pData[ 6 ];
					v3fDestination.y = pData[ 7 ];
					v3fDestination.z = pData[ 8 ];
					break;
			}

			return v3fDestination;
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number , m3fDestination?: IMat3): IMat3;
		static fromYawPitchRoll(v3fAngles: IVec3, m3fDestination?: IMat3): IMat3;
		static fromYawPitchRoll(fYaw?,fPitch?,fRoll?,m3fDestination?): IMat3{
			if(arguments.length <= 2){
//Vec3 + m3fDestination
		        var v3fVec: IVec3 = arguments[0];

		        fYaw   = v3fVec.x;
		        fPitch = v3fVec.y;
		        fRoll  = v3fVec.z;

		        m3fDestination = arguments[1];
		    }

		    if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }

		    var pDataDestination: Float32Array = m3fDestination.data;

		    var fSin1:  number  = Math.sin(fYaw);
		    var fSin2:  number  = Math.sin(fPitch);
		    var fSin3:  number  = Math.sin(fRoll);

		    var fCos1:  number  = Math.cos(fYaw);
		    var fCos2:  number  = Math.cos(fPitch);
		    var fCos3:  number  = Math.cos(fRoll);

		    pDataDestination[ 0 ] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
		    pDataDestination[ 3 ] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
		    pDataDestination[ 6 ] = fCos2 * fSin1;

		    pDataDestination[ 1 ] = fCos2 * fSin3;
		    pDataDestination[ 4 ] = fCos2 * fCos3;
		    pDataDestination[ 7 ] = -fSin2;

		    pDataDestination[ 2 ] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
		    pDataDestination[ 5 ] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
		    pDataDestination[ 8 ] = fCos1 * fCos2;

		    return m3fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , m3fDestination?: IMat3): IMat3;
		static fromXYZ(v3fAngles: IVec3, m3fDestination?: IMat3): IMat3;
		static fromXYZ(fX?, fY?, fZ?, m3fDestination?) : IMat3{
			if(arguments.length <= 2){
//Vec3 + m3fDestination
				var v3fVec: IVec3 = arguments[0];
				return Mat3.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m3fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Mat3.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static get stackCeil(): Mat3 { Mat3.stackPosition = Mat3.stackPosition === Mat3.stackSize - 1? 0: Mat3.stackPosition; return Mat3.stack[Mat3.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Mat3[] = (function(): Mat3[]{ var pStack: Mat3[] = new Array(Mat3.stackSize); for(var i: number = 0; i<Mat3.stackSize; i++){ pStack[i] = new Mat3(); } return pStack})(); ;
    };
};
















module akra {

	export interface IVec2 {} ;
	export interface IVec3 {} ;
	export interface IColorValue {} ;

	export interface IVec4Constructor {
        ();
        (fValue:  number );
        (v4fVec: IVec4);
        (pArray:  number []);
        (fValue:  number , v3fVec: IVec3);
        (v2fVec1: IVec2, v2fVec2: IVec2);
        (v3fVec: IVec3, fValue:  number );
        (fValue1:  number , fValue2:  number , v2fVec: IVec2);
        (fValue1:  number , v2fVec: IVec2, fValue2:  number );
        (v2fVec: IVec2 ,fValue1:  number , fValue2:  number );
        (fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number );
    }


	export interface IVec4 {
		x:  number ;
		y:  number ;
		z:  number ;
		w:  number ;


/*represents two-component vector from original vector*/

xx: IVec2;
/*represents two-component vector from original vector*/

xy: IVec2;
/*represents two-component vector from original vector*/

xz: IVec2;
/*represents two-component vector from original vector*/

xw: IVec2;
/*represents two-component vector from original vector*/

yx: IVec2;
/*represents two-component vector from original vector*/

yy: IVec2;
/*represents two-component vector from original vector*/

yz: IVec2;
/*represents two-component vector from original vector*/

yw: IVec2;
/*represents two-component vector from original vector*/

zx: IVec2;
/*represents two-component vector from original vector*/

zy: IVec2;
/*represents two-component vector from original vector*/

zz: IVec2;
/*represents two-component vector from original vector*/

zw: IVec2;
/*represents two-component vector from original vector*/

wx: IVec2;
/*represents two-component vector from original vector*/

wy: IVec2;
/*represents two-component vector from original vector*/

wz: IVec2;
/*represents two-component vector from original vector*/

ww: IVec2;

/*represents three-component vector from original vector*/

xxx: IVec3;
/*represents three-component vector from original vector*/

xxy: IVec3;
/*represents three-component vector from original vector*/

xxz: IVec3;
/*represents three-component vector from original vector*/

xxw: IVec3;
/*represents three-component vector from original vector*/

xyx: IVec3;
/*represents three-component vector from original vector*/

xyy: IVec3;
/*represents three-component vector from original vector*/

xyz: IVec3;
/*represents three-component vector from original vector*/

xyw: IVec3;
/*represents three-component vector from original vector*/

xzx: IVec3;
/*represents three-component vector from original vector*/

xzy: IVec3;
/*represents three-component vector from original vector*/

xzz: IVec3;
/*represents three-component vector from original vector*/

xzw: IVec3;
/*represents three-component vector from original vector*/

xwx: IVec3;
/*represents three-component vector from original vector*/

xwy: IVec3;
/*represents three-component vector from original vector*/

xwz: IVec3;
/*represents three-component vector from original vector*/

xww: IVec3;
/*represents three-component vector from original vector*/

yxx: IVec3;
/*represents three-component vector from original vector*/

yxy: IVec3;
/*represents three-component vector from original vector*/

yxz: IVec3;
/*represents three-component vector from original vector*/

yxw: IVec3;
/*represents three-component vector from original vector*/

yyx: IVec3;
/*represents three-component vector from original vector*/

yyy: IVec3;
/*represents three-component vector from original vector*/

yyz: IVec3;
/*represents three-component vector from original vector*/

yyw: IVec3;
/*represents three-component vector from original vector*/

yzx: IVec3;
/*represents three-component vector from original vector*/

yzy: IVec3;
/*represents three-component vector from original vector*/

yzz: IVec3;
/*represents three-component vector from original vector*/

yzw: IVec3;
/*represents three-component vector from original vector*/

ywx: IVec3;
/*represents three-component vector from original vector*/

ywy: IVec3;
/*represents three-component vector from original vector*/

ywz: IVec3;
/*represents three-component vector from original vector*/

yww: IVec3;
/*represents three-component vector from original vector*/

zxx: IVec3;
/*represents three-component vector from original vector*/

zxy: IVec3;
/*represents three-component vector from original vector*/

zxz: IVec3;
/*represents three-component vector from original vector*/

zxw: IVec3;
/*represents three-component vector from original vector*/

zyx: IVec3;
/*represents three-component vector from original vector*/

zyy: IVec3;
/*represents three-component vector from original vector*/

zyz: IVec3;
/*represents three-component vector from original vector*/

zyw: IVec3;
/*represents three-component vector from original vector*/

zzx: IVec3;
/*represents three-component vector from original vector*/

zzy: IVec3;
/*represents three-component vector from original vector*/

zzz: IVec3;
/*represents three-component vector from original vector*/

zzw: IVec3;
/*represents three-component vector from original vector*/

zwx: IVec3;
/*represents three-component vector from original vector*/

zwy: IVec3;
/*represents three-component vector from original vector*/

zwz: IVec3;
/*represents three-component vector from original vector*/

zww: IVec3;
/*represents three-component vector from original vector*/

wxx: IVec3;
/*represents three-component vector from original vector*/

wxy: IVec3;
/*represents three-component vector from original vector*/

wxz: IVec3;
/*represents three-component vector from original vector*/

wxw: IVec3;
/*represents three-component vector from original vector*/

wyx: IVec3;
/*represents three-component vector from original vector*/

wyy: IVec3;
/*represents three-component vector from original vector*/

wyz: IVec3;
/*represents three-component vector from original vector*/

wyw: IVec3;
/*represents three-component vector from original vector*/

wzx: IVec3;
/*represents three-component vector from original vector*/

wzy: IVec3;
/*represents three-component vector from original vector*/

wzz: IVec3;
/*represents three-component vector from original vector*/

wzw: IVec3;
/*represents three-component vector from original vector*/

wwx: IVec3;
/*represents three-component vector from original vector*/

wwy: IVec3;
/*represents three-component vector from original vector*/

wwz: IVec3;
/*represents three-component vector from original vector*/

www: IVec3;

/*represents four-component vector from original vector*/

xxxx: IVec4;
/*represents four-component vector from original vector*/

xxxy: IVec4;
/*represents four-component vector from original vector*/

xxxz: IVec4;
/*represents four-component vector from original vector*/

xxxw: IVec4;
/*represents four-component vector from original vector*/

xxyx: IVec4;
/*represents four-component vector from original vector*/

xxyy: IVec4;
/*represents four-component vector from original vector*/

xxyz: IVec4;
/*represents four-component vector from original vector*/

xxyw: IVec4;
/*represents four-component vector from original vector*/

xxzx: IVec4;
/*represents four-component vector from original vector*/

xxzy: IVec4;
/*represents four-component vector from original vector*/

xxzz: IVec4;
/*represents four-component vector from original vector*/

xxzw: IVec4;
/*represents four-component vector from original vector*/

xxwx: IVec4;
/*represents four-component vector from original vector*/

xxwy: IVec4;
/*represents four-component vector from original vector*/

xxwz: IVec4;
/*represents four-component vector from original vector*/

xxww: IVec4;
/*represents four-component vector from original vector*/

xyxx: IVec4;
/*represents four-component vector from original vector*/

xyxy: IVec4;
/*represents four-component vector from original vector*/

xyxz: IVec4;
/*represents four-component vector from original vector*/

xyxw: IVec4;
/*represents four-component vector from original vector*/

xyyx: IVec4;
/*represents four-component vector from original vector*/

xyyy: IVec4;
/*represents four-component vector from original vector*/

xyyz: IVec4;
/*represents four-component vector from original vector*/

xyyw: IVec4;
/*represents four-component vector from original vector*/

xyzx: IVec4;
/*represents four-component vector from original vector*/

xyzy: IVec4;
/*represents four-component vector from original vector*/

xyzz: IVec4;
/*represents four-component vector from original vector*/

xyzw: IVec4;
/*represents four-component vector from original vector*/

xywx: IVec4;
/*represents four-component vector from original vector*/

xywy: IVec4;
/*represents four-component vector from original vector*/

xywz: IVec4;
/*represents four-component vector from original vector*/

xyww: IVec4;
/*represents four-component vector from original vector*/

xzxx: IVec4;
/*represents four-component vector from original vector*/

xzxy: IVec4;
/*represents four-component vector from original vector*/

xzxz: IVec4;
/*represents four-component vector from original vector*/

xzxw: IVec4;
/*represents four-component vector from original vector*/

xzyx: IVec4;
/*represents four-component vector from original vector*/

xzyy: IVec4;
/*represents four-component vector from original vector*/

xzyz: IVec4;
/*represents four-component vector from original vector*/

xzyw: IVec4;
/*represents four-component vector from original vector*/

xzzx: IVec4;
/*represents four-component vector from original vector*/

xzzy: IVec4;
/*represents four-component vector from original vector*/

xzzz: IVec4;
/*represents four-component vector from original vector*/

xzzw: IVec4;
/*represents four-component vector from original vector*/

xzwx: IVec4;
/*represents four-component vector from original vector*/

xzwy: IVec4;
/*represents four-component vector from original vector*/

xzwz: IVec4;
/*represents four-component vector from original vector*/

xzww: IVec4;
/*represents four-component vector from original vector*/

xwxx: IVec4;
/*represents four-component vector from original vector*/

xwxy: IVec4;
/*represents four-component vector from original vector*/

xwxz: IVec4;
/*represents four-component vector from original vector*/

xwxw: IVec4;
/*represents four-component vector from original vector*/

xwyx: IVec4;
/*represents four-component vector from original vector*/

xwyy: IVec4;
/*represents four-component vector from original vector*/

xwyz: IVec4;
/*represents four-component vector from original vector*/

xwyw: IVec4;
/*represents four-component vector from original vector*/

xwzx: IVec4;
/*represents four-component vector from original vector*/

xwzy: IVec4;
/*represents four-component vector from original vector*/

xwzz: IVec4;
/*represents four-component vector from original vector*/

xwzw: IVec4;
/*represents four-component vector from original vector*/

xwwx: IVec4;
/*represents four-component vector from original vector*/

xwwy: IVec4;
/*represents four-component vector from original vector*/

xwwz: IVec4;
/*represents four-component vector from original vector*/

xwww: IVec4;
/*represents four-component vector from original vector*/

yxxx: IVec4;
/*represents four-component vector from original vector*/

yxxy: IVec4;
/*represents four-component vector from original vector*/

yxxz: IVec4;
/*represents four-component vector from original vector*/

yxxw: IVec4;
/*represents four-component vector from original vector*/

yxyx: IVec4;
/*represents four-component vector from original vector*/

yxyy: IVec4;
/*represents four-component vector from original vector*/

yxyz: IVec4;
/*represents four-component vector from original vector*/

yxyw: IVec4;
/*represents four-component vector from original vector*/

yxzx: IVec4;
/*represents four-component vector from original vector*/

yxzy: IVec4;
/*represents four-component vector from original vector*/

yxzz: IVec4;
/*represents four-component vector from original vector*/

yxzw: IVec4;
/*represents four-component vector from original vector*/

yxwx: IVec4;
/*represents four-component vector from original vector*/

yxwy: IVec4;
/*represents four-component vector from original vector*/

yxwz: IVec4;
/*represents four-component vector from original vector*/

yxww: IVec4;
/*represents four-component vector from original vector*/

yyxx: IVec4;
/*represents four-component vector from original vector*/

yyxy: IVec4;
/*represents four-component vector from original vector*/

yyxz: IVec4;
/*represents four-component vector from original vector*/

yyxw: IVec4;
/*represents four-component vector from original vector*/

yyyx: IVec4;
/*represents four-component vector from original vector*/

yyyy: IVec4;
/*represents four-component vector from original vector*/

yyyz: IVec4;
/*represents four-component vector from original vector*/

yyyw: IVec4;
/*represents four-component vector from original vector*/

yyzx: IVec4;
/*represents four-component vector from original vector*/

yyzy: IVec4;
/*represents four-component vector from original vector*/

yyzz: IVec4;
/*represents four-component vector from original vector*/

yyzw: IVec4;
/*represents four-component vector from original vector*/

yywx: IVec4;
/*represents four-component vector from original vector*/

yywy: IVec4;
/*represents four-component vector from original vector*/

yywz: IVec4;
/*represents four-component vector from original vector*/

yyww: IVec4;
/*represents four-component vector from original vector*/

yzxx: IVec4;
/*represents four-component vector from original vector*/

yzxy: IVec4;
/*represents four-component vector from original vector*/

yzxz: IVec4;
/*represents four-component vector from original vector*/

yzxw: IVec4;
/*represents four-component vector from original vector*/

yzyx: IVec4;
/*represents four-component vector from original vector*/

yzyy: IVec4;
/*represents four-component vector from original vector*/

yzyz: IVec4;
/*represents four-component vector from original vector*/

yzyw: IVec4;
/*represents four-component vector from original vector*/

yzzx: IVec4;
/*represents four-component vector from original vector*/

yzzy: IVec4;
/*represents four-component vector from original vector*/

yzzz: IVec4;
/*represents four-component vector from original vector*/

yzzw: IVec4;
/*represents four-component vector from original vector*/

yzwx: IVec4;
/*represents four-component vector from original vector*/

yzwy: IVec4;
/*represents four-component vector from original vector*/

yzwz: IVec4;
/*represents four-component vector from original vector*/

yzww: IVec4;
/*represents four-component vector from original vector*/

ywxx: IVec4;
/*represents four-component vector from original vector*/

ywxy: IVec4;
/*represents four-component vector from original vector*/

ywxz: IVec4;
/*represents four-component vector from original vector*/

ywxw: IVec4;
/*represents four-component vector from original vector*/

ywyx: IVec4;
/*represents four-component vector from original vector*/

ywyy: IVec4;
/*represents four-component vector from original vector*/

ywyz: IVec4;
/*represents four-component vector from original vector*/

ywyw: IVec4;
/*represents four-component vector from original vector*/

ywzx: IVec4;
/*represents four-component vector from original vector*/

ywzy: IVec4;
/*represents four-component vector from original vector*/

ywzz: IVec4;
/*represents four-component vector from original vector*/

ywzw: IVec4;
/*represents four-component vector from original vector*/

ywwx: IVec4;
/*represents four-component vector from original vector*/

ywwy: IVec4;
/*represents four-component vector from original vector*/

ywwz: IVec4;
/*represents four-component vector from original vector*/

ywww: IVec4;
/*represents four-component vector from original vector*/

zxxx: IVec4;
/*represents four-component vector from original vector*/

zxxy: IVec4;
/*represents four-component vector from original vector*/

zxxz: IVec4;
/*represents four-component vector from original vector*/

zxxw: IVec4;
/*represents four-component vector from original vector*/

zxyx: IVec4;
/*represents four-component vector from original vector*/

zxyy: IVec4;
/*represents four-component vector from original vector*/

zxyz: IVec4;
/*represents four-component vector from original vector*/

zxyw: IVec4;
/*represents four-component vector from original vector*/

zxzx: IVec4;
/*represents four-component vector from original vector*/

zxzy: IVec4;
/*represents four-component vector from original vector*/

zxzz: IVec4;
/*represents four-component vector from original vector*/

zxzw: IVec4;
/*represents four-component vector from original vector*/

zxwx: IVec4;
/*represents four-component vector from original vector*/

zxwy: IVec4;
/*represents four-component vector from original vector*/

zxwz: IVec4;
/*represents four-component vector from original vector*/

zxww: IVec4;
/*represents four-component vector from original vector*/

zyxx: IVec4;
/*represents four-component vector from original vector*/

zyxy: IVec4;
/*represents four-component vector from original vector*/

zyxz: IVec4;
/*represents four-component vector from original vector*/

zyxw: IVec4;
/*represents four-component vector from original vector*/

zyyx: IVec4;
/*represents four-component vector from original vector*/

zyyy: IVec4;
/*represents four-component vector from original vector*/

zyyz: IVec4;
/*represents four-component vector from original vector*/

zyyw: IVec4;
/*represents four-component vector from original vector*/

zyzx: IVec4;
/*represents four-component vector from original vector*/

zyzy: IVec4;
/*represents four-component vector from original vector*/

zyzz: IVec4;
/*represents four-component vector from original vector*/

zyzw: IVec4;
/*represents four-component vector from original vector*/

zywx: IVec4;
/*represents four-component vector from original vector*/

zywy: IVec4;
/*represents four-component vector from original vector*/

zywz: IVec4;
/*represents four-component vector from original vector*/

zyww: IVec4;
/*represents four-component vector from original vector*/

zzxx: IVec4;
/*represents four-component vector from original vector*/

zzxy: IVec4;
/*represents four-component vector from original vector*/

zzxz: IVec4;
/*represents four-component vector from original vector*/

zzxw: IVec4;
/*represents four-component vector from original vector*/

zzyx: IVec4;
/*represents four-component vector from original vector*/

zzyy: IVec4;
/*represents four-component vector from original vector*/

zzyz: IVec4;
/*represents four-component vector from original vector*/

zzyw: IVec4;
/*represents four-component vector from original vector*/

zzzx: IVec4;
/*represents four-component vector from original vector*/

zzzy: IVec4;
/*represents four-component vector from original vector*/

zzzz: IVec4;
/*represents four-component vector from original vector*/

zzzw: IVec4;
/*represents four-component vector from original vector*/

zzwx: IVec4;
/*represents four-component vector from original vector*/

zzwy: IVec4;
/*represents four-component vector from original vector*/

zzwz: IVec4;
/*represents four-component vector from original vector*/

zzww: IVec4;
/*represents four-component vector from original vector*/

zwxx: IVec4;
/*represents four-component vector from original vector*/

zwxy: IVec4;
/*represents four-component vector from original vector*/

zwxz: IVec4;
/*represents four-component vector from original vector*/

zwxw: IVec4;
/*represents four-component vector from original vector*/

zwyx: IVec4;
/*represents four-component vector from original vector*/

zwyy: IVec4;
/*represents four-component vector from original vector*/

zwyz: IVec4;
/*represents four-component vector from original vector*/

zwyw: IVec4;
/*represents four-component vector from original vector*/

zwzx: IVec4;
/*represents four-component vector from original vector*/

zwzy: IVec4;
/*represents four-component vector from original vector*/

zwzz: IVec4;
/*represents four-component vector from original vector*/

zwzw: IVec4;
/*represents four-component vector from original vector*/

zwwx: IVec4;
/*represents four-component vector from original vector*/

zwwy: IVec4;
/*represents four-component vector from original vector*/

zwwz: IVec4;
/*represents four-component vector from original vector*/

zwww: IVec4;
/*represents four-component vector from original vector*/

wxxx: IVec4;
/*represents four-component vector from original vector*/

wxxy: IVec4;
/*represents four-component vector from original vector*/

wxxz: IVec4;
/*represents four-component vector from original vector*/

wxxw: IVec4;
/*represents four-component vector from original vector*/

wxyx: IVec4;
/*represents four-component vector from original vector*/

wxyy: IVec4;
/*represents four-component vector from original vector*/

wxyz: IVec4;
/*represents four-component vector from original vector*/

wxyw: IVec4;
/*represents four-component vector from original vector*/

wxzx: IVec4;
/*represents four-component vector from original vector*/

wxzy: IVec4;
/*represents four-component vector from original vector*/

wxzz: IVec4;
/*represents four-component vector from original vector*/

wxzw: IVec4;
/*represents four-component vector from original vector*/

wxwx: IVec4;
/*represents four-component vector from original vector*/

wxwy: IVec4;
/*represents four-component vector from original vector*/

wxwz: IVec4;
/*represents four-component vector from original vector*/

wxww: IVec4;
/*represents four-component vector from original vector*/

wyxx: IVec4;
/*represents four-component vector from original vector*/

wyxy: IVec4;
/*represents four-component vector from original vector*/

wyxz: IVec4;
/*represents four-component vector from original vector*/

wyxw: IVec4;
/*represents four-component vector from original vector*/

wyyx: IVec4;
/*represents four-component vector from original vector*/

wyyy: IVec4;
/*represents four-component vector from original vector*/

wyyz: IVec4;
/*represents four-component vector from original vector*/

wyyw: IVec4;
/*represents four-component vector from original vector*/

wyzx: IVec4;
/*represents four-component vector from original vector*/

wyzy: IVec4;
/*represents four-component vector from original vector*/

wyzz: IVec4;
/*represents four-component vector from original vector*/

wyzw: IVec4;
/*represents four-component vector from original vector*/

wywx: IVec4;
/*represents four-component vector from original vector*/

wywy: IVec4;
/*represents four-component vector from original vector*/

wywz: IVec4;
/*represents four-component vector from original vector*/

wyww: IVec4;
/*represents four-component vector from original vector*/

wzxx: IVec4;
/*represents four-component vector from original vector*/

wzxy: IVec4;
/*represents four-component vector from original vector*/

wzxz: IVec4;
/*represents four-component vector from original vector*/

wzxw: IVec4;
/*represents four-component vector from original vector*/

wzyx: IVec4;
/*represents four-component vector from original vector*/

wzyy: IVec4;
/*represents four-component vector from original vector*/

wzyz: IVec4;
/*represents four-component vector from original vector*/

wzyw: IVec4;
/*represents four-component vector from original vector*/

wzzx: IVec4;
/*represents four-component vector from original vector*/

wzzy: IVec4;
/*represents four-component vector from original vector*/

wzzz: IVec4;
/*represents four-component vector from original vector*/

wzzw: IVec4;
/*represents four-component vector from original vector*/

wzwx: IVec4;
/*represents four-component vector from original vector*/

wzwy: IVec4;
/*represents four-component vector from original vector*/

wzwz: IVec4;
/*represents four-component vector from original vector*/

wzww: IVec4;
/*represents four-component vector from original vector*/

wwxx: IVec4;
/*represents four-component vector from original vector*/

wwxy: IVec4;
/*represents four-component vector from original vector*/

wwxz: IVec4;
/*represents four-component vector from original vector*/

wwxw: IVec4;
/*represents four-component vector from original vector*/

wwyx: IVec4;
/*represents four-component vector from original vector*/

wwyy: IVec4;
/*represents four-component vector from original vector*/

wwyz: IVec4;
/*represents four-component vector from original vector*/

wwyw: IVec4;
/*represents four-component vector from original vector*/

wwzx: IVec4;
/*represents four-component vector from original vector*/

wwzy: IVec4;
/*represents four-component vector from original vector*/

wwzz: IVec4;
/*represents four-component vector from original vector*/

wwzw: IVec4;
/*represents four-component vector from original vector*/

wwwx: IVec4;
/*represents four-component vector from original vector*/

wwwy: IVec4;
/*represents four-component vector from original vector*/

wwwz: IVec4;
/*represents four-component vector from original vector*/

wwww: IVec4;

		set(): IVec4;
		set(fValue:  number ): IVec4;
		set(v4fVec: IVec4): IVec4;
		set(c4fColor: IColorValue): IVec4;
		set(pArray:  number []): IVec4;
		set(fValue:  number , v3fVec: IVec3): IVec4;
		set(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
		set(v3fVec: IVec3, fValue:  number ): IVec4;
		set(fValue1:  number , fValue2:  number , v2fVec: IVec2): IVec4;
		set(fValue1:  number , v2fVec: IVec2, fValue2:  number ): IVec4;
		set(v2fVec: IVec2, fValue1:  number , fValue2:  number ): IVec4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ): IVec4;

		clear(): IVec4;

		add(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;
		subtract(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;
		dot(v4fVec: IVec4):  number ;

		isEqual(v4fVec: IVec4, fEps?:  number ): bool;
		isClear(fEps?:  number ): bool;

		negate(v4fDestination?: IVec4): IVec4;
		scale(fScale:  number , v4fDestination?: IVec4): IVec4;
		normalize(v4fDestination?: IVec4): IVec4;
		length():  number ;
		lengthSquare():  number ;

		direction(v4fVec: IVec4, v4fDestination?: IVec4): IVec4;

		mix(v4fVec: IVec4, fA:  number , v4fDestination?: IVec4): IVec4;

		toString(): string;
	};
};





module akra.math {
    export class Mat4 implements IMat4{
    	data: Float32Array;

		constructor();
		constructor(fValue:  number );
		constructor(v4fVec: IVec4);
		constructor(m3fMat: IMat3, v3fTranslation?: IVec3);
		constructor(m4fMat: IMat4);
		constructor(pArray:  number []);
		constructor(pArray: Float32Array, bFlag: bool);
		constructor(fValue1:  number , fValue2:  number ,
				fValue3:  number , fValue4:  number );
		constructor(v4fVec1: IVec4, v4fVec2: IVec4,
				v4fVec3: IVec4, v4fVec4: IVec4);
		constructor(pArray1:  number [], pArray2:  number [],
				pArray3:  number [], pArray4:  number []);
		constructor(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
				fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
				fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
				fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number );
		constructor(fValue1?, fValue2?, fValue3?, fValue4?,
					fValue5?, fValue6?, fValue7?, fValue8?,
					fValue9?, fValue10?, fValue11?, fValue12?,
					fValue13?, fValue14?, fValue15?, fValue16?){
			var nArgumentsLength:  number  = arguments.length;

			if(nArgumentsLength === 2){
				if(isBoolean(arguments[1])){
					if(arguments[1]){
						this.data = arguments[0];
					}
					else{
						this.data = new Float32Array(16);
						this.set(arguments[0]);
					}
				}
				else{
					this.data = new Float32Array(16);
					this.set(arguments[0], arguments[1]);
				}
			}
			else{
				this.data = new Float32Array(16);

				switch(nArgumentsLength){
					case 1:
						if(arguments[0] instanceof Mat3){
							this.set(arguments[0],vec3(0.));
						}
						else{
							this.set(arguments[0]);
						}
						break;
					case 4:
						this.set(arguments[0],arguments[1],arguments[2],arguments[3]);
						break;
					case 16:
						this.set(arguments[0], arguments[1], arguments[2], arguments[3],
							 arguments[4], arguments[5], arguments[6], arguments[7],
							 arguments[8], arguments[9], arguments[10], arguments[11],
							 arguments[12], arguments[13], arguments[14], arguments[15]);
						 break;
					 default:
					 	break;
				}
			}
		};

		set(): IMat4;
		set(fValue:  number ): IMat4;
		set(v4fVec: IVec4): IMat4;
		set(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
		set(m4fMat: IMat4): IMat4;
		set(pArray:  number []): IMat4;
		set(fValue1:  number , fValue2:  number ,
			fValue3:  number , fValue4:  number ): IMat4;
		set(v4fVec1: IVec4, v4fVec2: IVec4,
			v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
		set(pArray1:  number [], pArray2:  number [],
			pArray3:  number [], pArray4:  number []): IMat4;
		set(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
			fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
			fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
			fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number ): IMat4;
		set(fValue1?, fValue2?, fValue3?, fValue4?,
			fValue5?, fValue6?, fValue7?, fValue8?,
			fValue9?, fValue10?, fValue11?, fValue12?,
			fValue13?, fValue14?, fValue15?, fValue16?): IMat4{

			var nArgumentsLength:  number  = arguments.length;
			var pData: Float32Array = this.data;

			if(nArgumentsLength === 0){
				pData[ 0 ] = pData[ 4 ] = pData[ 8 ] = pData[ 12 ] =
				pData[ 1 ] = pData[ 5 ] = pData[ 9 ] = pData[ 13 ] =
				pData[ 2 ] = pData[ 6 ] = pData[ 10 ] = pData[ 14 ] =
				pData[ 3 ] = pData[ 7 ] = pData[ 11 ] = pData[ 15 ] = 0.;

				return this;
			}

			if(nArgumentsLength === 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					pData[ 0 ] = fValue;
					pData[ 4 ] = 0.;
					pData[ 8 ] = 0.;
					pData[ 12 ] = 0.;

					pData[ 1 ] = 0.;
					pData[ 5 ] = fValue;
					pData[ 9 ] = 0.;
					pData[ 13 ] = 0.;

					pData[ 2 ] = 0.;
					pData[ 6 ] = 0.;
					pData[ 10 ] = fValue;
					pData[ 14 ] = 0.;

					pData[ 3 ] = 0.;
					pData[ 7 ] = 0.;
					pData[ 11 ] = 0.
					pData[ 15 ] = fValue;
				}
				else if(arguments[0] instanceof Vec4){
					var v4fVec = arguments[0];

					pData[ 0 ] = v4fVec.x;
					pData[ 4 ] = 0.;
					pData[ 8 ] = 0.;
					pData[ 12 ] = 0.;

					pData[ 1 ] = 0.;
					pData[ 5 ] = v4fVec.y;
					pData[ 9 ] = 0.;
					pData[ 13 ] = 0.;

					pData[ 2 ] = 0.;
					pData[ 6 ] = 0.;
					pData[ 10 ] = v4fVec.z;
					pData[ 14 ] = 0.;

					pData[ 3 ] = 0.;
					pData[ 7 ] = 0.;
					pData[ 11 ] = 0.
					pData[ 15 ] = v4fVec.w;
				}
				else if(isDef(arguments[0].data)){
					var pMatrixData: Float32Array = arguments[0].data;
					if(pMatrixData.length == 16){
//Mat4
						pData.set(pMatrixData);
					}
					else{
//Mat3
						pData[ 0 ] = pMatrixData[ 0 ];
						pData[ 4 ] = pMatrixData[ 3 ];
						pData[ 8 ] = pMatrixData[ 6 ];

						pData[ 1 ] = pMatrixData[ 1 ];
						pData[ 5 ] = pMatrixData[ 4 ];
						pData[ 9 ] = pMatrixData[ 7 ];

						pData[ 2 ] = pMatrixData[ 2 ];
						pData[ 6 ] = pMatrixData[ 5 ];
						pData[ 10 ] = pMatrixData[ 8 ];

						pData[ 3 ] = 0.;
						pData[ 7 ] = 0.;
						pData[ 11 ] = 0.;
						pData[ 15 ] = 1.;
					}
				}
				else{
//array
					var pArray:  number [] = arguments[0];

					if(pArray.length === 4){
						pData[ 0 ] = pArray[0];
						pData[ 4 ] = 0.;
						pData[ 8 ] = 0.;
						pData[ 12 ] = 0.;

						pData[ 1 ] = 0.;
						pData[ 5 ] = pArray[1];
						pData[ 9 ] = 0.;
						pData[ 13 ] = 0.;

						pData[ 2 ] = 0.;
						pData[ 6 ] = 0.;
						pData[ 10 ] = pArray[2];
						pData[ 14 ] = 0.;

						pData[ 3 ] = 0.;
						pData[ 7 ] = 0.;
						pData[ 11 ] = 0.
						pData[ 15 ] = pArray[3];
					}
					else{
//length == 16

						pData[ 0 ] = pArray[ 0 ];
						pData[ 4 ] = pArray[ 4 ];
						pData[ 8 ] = pArray[ 8 ];
						pData[ 12 ] = pArray[ 12 ];

						pData[ 1 ] = pArray[ 1 ];
						pData[ 5 ] = pArray[ 5 ];
						pData[ 9 ] = pArray[ 9 ];
						pData[ 13 ] = pArray[ 13 ];

						pData[ 2 ] = pArray[ 2 ];
						pData[ 6 ] = pArray[ 6 ];
						pData[ 10 ] = pArray[ 10 ];
						pData[ 14 ] = pArray[ 14 ];

						pData[ 3 ] = pArray[ 3 ];
						pData[ 7 ] = pArray[ 7 ];
						pData[ 11 ] = pArray[ 11 ];
						pData[ 15 ] = pArray[ 15 ];
					}
				}
			}
			else if(nArgumentsLength == 2){
				var pMatrixData: Float32Array = arguments[0];
				var v3fTranslation : IVec3 = arguments[1];

				pData[ 0 ] = pMatrixData[ 0 ];
				pData[ 4 ] = pMatrixData[ 3 ];
				pData[ 8 ] = pMatrixData[ 6 ];
				pData[ 12 ] = v3fTranslation.x;

				pData[ 1 ] = pMatrixData[ 1 ];
				pData[ 5 ] = pMatrixData[ 4 ];
				pData[ 9 ] = pMatrixData[ 7 ];
				pData[ 13 ] = v3fTranslation.y;

				pData[ 2 ] = pMatrixData[ 2 ];
				pData[ 6 ] = pMatrixData[ 5 ];
				pData[ 10 ] = pMatrixData[ 8 ];
				pData[ 14 ] = v3fTranslation.z;

				pData[ 3 ] = 0.;
				pData[ 7 ] = 0.;
				pData[ 11 ] = 0.;
				pData[ 15 ] = 1.;

			}
			else if(nArgumentsLength == 4){
				if(isFloat(arguments[0])){

					pData[ 0 ] = arguments[0];
					pData[ 4 ] = 0;
					pData[ 8 ] = 0;
					pData[ 12 ] = 0;

					pData[ 1 ] = 0;
					pData[ 5 ] = arguments[1];
					pData[ 9 ] = 0;
					pData[ 13 ] = 0;

					pData[ 2 ] = 0;
					pData[ 6 ] = 0;
					pData[ 10 ] = arguments[2];
					pData[ 14 ] = 0;

					pData[ 3 ] = 0;
					pData[ 7 ] = 0;
					pData[ 11 ] = 0;
					pData[ 15 ] = arguments[3];
				}
				else if(arguments[0] instanceof Vec4){

					var v4fColumn1: IVec4 = arguments[0];
					var v4fColumn2: IVec4 = arguments[1];
					var v4fColumn3: IVec4 = arguments[2];
					var v4fColumn4: IVec4 = arguments[3];

					pData[ 0 ] = v4fColumn1.x;
					pData[ 4 ] = v4fColumn2.x;
					pData[ 8 ] = v4fColumn3.x;
					pData[ 12 ] = v4fColumn4.x;

					pData[ 1 ] = v4fColumn1.y;
					pData[ 5 ] = v4fColumn2.y;
					pData[ 9 ] = v4fColumn3.y;
					pData[ 13 ] = v4fColumn4.y;

					pData[ 2 ] = v4fColumn1.z;
					pData[ 6 ] = v4fColumn2.z;
					pData[ 10 ] = v4fColumn3.z;
					pData[ 14 ] = v4fColumn4.z;

					pData[ 3 ] = v4fColumn1.w;
					pData[ 7 ] = v4fColumn2.w;
					pData[ 11 ] = v4fColumn3.w;
					pData[ 15 ] = v4fColumn4.w;
				}
				else{
//arrays

					var v4fColumn1:  number [] = arguments[0];
					var v4fColumn2:  number [] = arguments[1];
					var v4fColumn3:  number [] = arguments[2];
					var v4fColumn4:  number [] = arguments[3];

					pData[ 0 ] = v4fColumn1[0];
					pData[ 4 ] = v4fColumn2[0];
					pData[ 8 ] = v4fColumn3[0];
					pData[ 12 ] = v4fColumn4[0];

					pData[ 1 ] = v4fColumn1[1];
					pData[ 5 ] = v4fColumn2[1];
					pData[ 9 ] = v4fColumn3[1];
					pData[ 13 ] = v4fColumn4[1];

					pData[ 2 ] = v4fColumn1[2];
					pData[ 6 ] = v4fColumn2[2];
					pData[ 10 ] = v4fColumn3[2];
					pData[ 14 ] = v4fColumn4[2];

					pData[ 3 ] = v4fColumn1[3];
					pData[ 7 ] = v4fColumn2[3];
					pData[ 11 ] = v4fColumn3[3];
					pData[ 15 ] = v4fColumn4[3];

				}
			}
			else{
//nArgumentsLength === 16

				pData[ 0 ] = arguments[ 0 ];
				pData[ 4 ] = arguments[ 4 ];
				pData[ 8 ] = arguments[ 8 ];
				pData[ 12 ] = arguments[ 12 ];

				pData[ 1 ] = arguments[ 1 ];
				pData[ 5 ] = arguments[ 5 ];
				pData[ 9 ] = arguments[ 9 ];
				pData[ 13 ] = arguments[ 13 ];

				pData[ 2 ] = arguments[ 2 ];
				pData[ 6 ] = arguments[ 6 ];
				pData[ 10 ] = arguments[ 10 ];
				pData[ 14 ] = arguments[ 14 ];

				pData[ 3 ] = arguments[ 3 ];
				pData[ 7 ] = arguments[ 7 ];
				pData[ 11 ] = arguments[ 11 ];
				pData[ 15 ] = arguments[ 15 ];
			}
			return this;
		};

		identity() : IMat4{
			var pData: Float32Array = this.data;

			pData[ 0 ] = 1.;
			pData[ 4 ] = 0.;
			pData[ 8 ] = 0.;
			pData[ 12 ] = 0.;

			pData[ 1 ] = 0.;
			pData[ 5 ] = 1.;
			pData[ 9 ] = 0.;
			pData[ 13 ] = 0.;

			pData[ 2 ] = 0.;
			pData[ 6 ] = 0.;
			pData[ 10 ] = 1.;
			pData[ 14 ] = 0.;

			pData[ 3 ] = 0.;
			pData[ 7 ] = 0.;
			pData[ 11 ] = 0.;
			pData[ 15 ] = 1.;

			return this;
		};

		add(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}

			var pData1: Float32Array = this.data;
			var pData2: Float32Array = m4fMat.data;
			var pDataDestination: Float32Array = m4fDestination.data;

			pDataDestination[ 0 ] = pData1[ 0 ] + pData2[ 0 ];
			pDataDestination[ 4 ] = pData1[ 4 ] + pData2[ 4 ];
			pDataDestination[ 8 ] = pData1[ 8 ] + pData2[ 8 ];
			pDataDestination[ 12 ] = pData1[ 12 ] + pData2[ 12 ];

			pDataDestination[ 1 ] = pData1[ 1 ] + pData2[ 1 ];
			pDataDestination[ 5 ] = pData1[ 5 ] + pData2[ 5 ];
			pDataDestination[ 9 ] = pData1[ 9 ] + pData2[ 9 ];
			pDataDestination[ 13 ] = pData1[ 13 ] + pData2[ 13 ];

			pDataDestination[ 2 ] = pData1[ 2 ] + pData2[ 2 ];
			pDataDestination[ 6 ] = pData1[ 6 ] + pData2[ 6 ];
			pDataDestination[ 10 ] = pData1[ 10 ] + pData2[ 10 ];
			pDataDestination[ 14 ] = pData1[ 14 ] + pData2[ 14 ];

			pDataDestination[ 3 ] = pData1[ 3 ] + pData2[ 3 ];
			pDataDestination[ 7 ] = pData1[ 7 ] + pData2[ 7 ];
			pDataDestination[ 11 ] = pData1[ 11 ] + pData2[ 11 ];
			pDataDestination[ 15 ] = pData1[ 15 ] + pData2[ 15 ];

			return m4fDestination;
		};

		subtract(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}

			var pData1: Float32Array = this.data;
			var pData2: Float32Array = m4fMat.data;
			var pDataDestination: Float32Array = m4fDestination.data;

			pDataDestination[ 0 ] = pData1[ 0 ] - pData2[ 0 ];
			pDataDestination[ 4 ] = pData1[ 4 ] - pData2[ 4 ];
			pDataDestination[ 8 ] = pData1[ 8 ] - pData2[ 8 ];
			pDataDestination[ 12 ] = pData1[ 12 ] - pData2[ 12 ];

			pDataDestination[ 1 ] = pData1[ 1 ] - pData2[ 1 ];
			pDataDestination[ 5 ] = pData1[ 5 ] - pData2[ 5 ];
			pDataDestination[ 9 ] = pData1[ 9 ] - pData2[ 9 ];
			pDataDestination[ 13 ] = pData1[ 13 ] - pData2[ 13 ];

			pDataDestination[ 2 ] = pData1[ 2 ] - pData2[ 2 ];
			pDataDestination[ 6 ] = pData1[ 6 ] - pData2[ 6 ];
			pDataDestination[ 10 ] = pData1[ 10 ] - pData2[ 10 ];
			pDataDestination[ 14 ] = pData1[ 14 ] - pData2[ 14 ];

			pDataDestination[ 3 ] = pData1[ 3 ] - pData2[ 3 ];
			pDataDestination[ 7 ] = pData1[ 7 ] - pData2[ 7 ];
			pDataDestination[ 11 ] = pData1[ 11 ] - pData2[ 11 ];
			pDataDestination[ 15 ] = pData1[ 15 ] - pData2[ 15 ];

			return m4fDestination;
		};

		multiply(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
	            m4fDestination = this;
	        }

			var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m4fMat.data;
	        var pDataDestination: Float32Array = m4fDestination.data;

//кешируем значения матриц для ускорения

	        var a11:  number  = pData1[ 0 ], a12:  number  = pData1[ 4 ], a13:  number  = pData1[ 8 ], a14:  number  = pData1[ 12 ];
	        var a21:  number  = pData1[ 1 ], a22:  number  = pData1[ 5 ], a23:  number  = pData1[ 9 ], a24:  number  = pData1[ 13 ];
	        var a31:  number  = pData1[ 2 ], a32:  number  = pData1[ 6 ], a33:  number  = pData1[ 10 ], a34:  number  = pData1[ 14 ];
	        var a41:  number  = pData1[ 3 ], a42:  number  = pData1[ 7 ], a43:  number  = pData1[ 11 ], a44:  number  = pData1[ 15 ];

	        var b11:  number  = pData2[ 0 ], b12:  number  = pData2[ 4 ], b13:  number  = pData2[ 8 ], b14:  number  = pData2[ 12 ];
	        var b21:  number  = pData2[ 1 ], b22:  number  = pData2[ 5 ], b23:  number  = pData2[ 9 ], b24:  number  = pData2[ 13 ];
	        var b31:  number  = pData2[ 2 ], b32:  number  = pData2[ 6 ], b33:  number  = pData2[ 10 ], b34:  number  = pData2[ 14 ];
	        var b41:  number  = pData2[ 3 ], b42:  number  = pData2[ 7 ], b43:  number  = pData2[ 11 ], b44:  number  = pData2[ 15 ];

	        pDataDestination[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	        pDataDestination[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	        pDataDestination[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	        pDataDestination[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

	        pDataDestination[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	        pDataDestination[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	        pDataDestination[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	        pDataDestination[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

	        pDataDestination[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	        pDataDestination[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	        pDataDestination[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	        pDataDestination[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

	        pDataDestination[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	        pDataDestination[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	        pDataDestination[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	        pDataDestination[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		    return m4fDestination;
		};

		inline multiplyLeft(m4fMat: IMat4, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
				m4fDestination = this;
			}
			return m4fMat.multiply(this,m4fDestination);
		};

		multiplyVec4(v4fVec: IVec4, v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = v4fVec;
			}

			var pData: Float32Array = this.data;

			var x:  number  = v4fVec.x, y:  number  = v4fVec.y, z:  number  = v4fVec.z, w:  number  = v4fVec.w;

			v4fDestination.x = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ]*w;
	        v4fDestination.y = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ]*w;
	        v4fDestination.z = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ]*w;
	        v4fDestination.w = pData[ 3 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ]*w;

	        return v4fDestination;
		};

		transpose(m4fDestination?: IMat4): IMat4{

			var pData = this.data;

		    if(!isDef(m4fDestination)){
		        var a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		        var a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		        var a34:  number  = pData[ 14 ];

		        pData[ 4 ] = pData[ 1 ];
		        pData[ 8 ] = pData[ 2 ];
		        pData[ 12 ] = pData[ 3 ];

		        pData[ 1 ] = a12;
		        pData[ 9 ] = pData[ 6 ];
		        pData[ 13 ] = pData[ 7 ];

		        pData[ 2 ] = a13;
		        pData[ 6 ] = a23;
		        pData[ 14 ] = pData[ 11 ];

		        pData[ 3 ] = a14;
		        pData[ 7 ] = a24;
		        pData[ 11 ] = a34;

		        return this;
		    }

		    var pDataDestination = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 1 ];
		    pDataDestination[ 8 ] = pData[ 2 ];
		    pDataDestination[ 12 ] = pData[ 3 ];

		    pDataDestination[ 1 ] = pData[ 4 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 6 ];
		    pDataDestination[ 13 ] = pData[ 7 ];

		    pDataDestination[ 2 ] = pData[ 8 ];
		    pDataDestination[ 6 ] = pData[ 9 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = pData[ 11 ];

		    pDataDestination[ 3 ] = pData[ 12 ];
		    pDataDestination[ 7 ] = pData[ 13 ];
		    pDataDestination[ 11 ] = pData[ 14 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		determinant():  number {
			var pData = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];
		    var a41:  number  = pData[ 3 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ], a44:  number  = pData[ 15 ];

		    return  a41*a32*a23*a14 - a31*a42*a23*a14 - a41*a22*a33*a14 + a21*a42*a33*a14 +
			        a31*a22*a43*a14 - a21*a32*a43*a14 - a41*a32*a13*a24 + a31*a42*a13*a24 +
			        a41*a12*a33*a24 - a11*a42*a33*a24 - a31*a12*a43*a24 + a11*a32*a43*a24 +
			        a41*a22*a13*a34 - a21*a42*a13*a34 - a41*a12*a23*a34 + a11*a42*a23*a34 +
			        a21*a12*a43*a34 - a11*a22*a43*a34 - a31*a22*a13*a44 + a21*a32*a13*a44 +
			        a31*a12*a23*a44 - a11*a32*a23*a44 - a21*a12*a33*a44 + a11*a22*a33*a44;
		};

		inverse(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = this;
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

// Cache the matrix values (makes for huge speed increases!)
		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];
		    var a41:  number  = pData[ 3 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ], a44:  number  = pData[ 15 ];

		    var b00:  number  = a11*a22 - a12*a21;
		    var b01:  number  = a11*a23 - a13*a21;
		    var b02:  number  = a11*a24 - a14*a21;
		    var b03:  number  = a12*a23 - a13*a22;
		    var b04:  number  = a12*a24 - a14*a22;
		    var b05:  number  = a13*a24 - a14*a23;
		    var b06:  number  = a31*a42 - a32*a41;
		    var b07:  number  = a31*a43 - a33*a41;
		    var b08:  number  = a31*a44 - a34*a41;
		    var b09:  number  = a32*a43 - a33*a42;
		    var b10:  number  = a32*a44 - a34*a42;
		    var b11:  number  = a33*a44 - a34*a43;

		    var fDeterminant:  number  = b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06;

		    if(fDeterminant === 0.){
		        logger.setSourceLocation( "Mat4.ts" , 624 ); logger.assert(false,"обращение матрицы с нулевым детеминантом:\n" + this.toString());
                                            ;
//чтоб все не навернулось
		        return m4fDestination.set(1.);
		    }

		    var fInverseDeterminant:  number  = 1/fDeterminant;

		    pDataDestination[ 0 ] = (a22 * b11 - a23 * b10 + a24 * b09) * fInverseDeterminant;
		    pDataDestination[ 4 ] = (-a12 * b11 + a13 * b10 - a14 * b09) * fInverseDeterminant;
		    pDataDestination[ 8 ] = (a42 * b05 - a43 * b04 + a44 * b03) * fInverseDeterminant;
		    pDataDestination[ 12 ] = (-a32 * b05 + a33 * b04 - a34 * b03) * fInverseDeterminant;

		    pDataDestination[ 1 ] = (-a21 * b11 + a23 * b08 - a24 * b07) * fInverseDeterminant;
		    pDataDestination[ 5 ] = (a11 * b11 - a13 * b08 + a14 * b07) * fInverseDeterminant;
		    pDataDestination[ 9 ] = (-a41 * b05 + a43 * b02 - a44 * b01) * fInverseDeterminant;
		    pDataDestination[ 13 ] = (a31 * b05 - a33 * b02 + a34 * b01) * fInverseDeterminant;

		    pDataDestination[ 2 ] = (a21 * b10 - a22 * b08 + a24 * b06) * fInverseDeterminant;
		    pDataDestination[ 6 ] = (-a11 * b10 + a12 * b08 - a14 * b06) * fInverseDeterminant;
		    pDataDestination[ 10 ] = (a41 * b04 - a42 * b02 + a44 * b00) * fInverseDeterminant;
		    pDataDestination[ 14 ] = (-a31 * b04 + a32 * b02 - a34 * b00) * fInverseDeterminant;

		    pDataDestination[ 3 ] = (-a21 * b09 + a22 * b07 - a23 * b06) * fInverseDeterminant;
		    pDataDestination[ 7 ] = (a11 * b09 - a12 * b07 + a13 * b06) * fInverseDeterminant;
		    pDataDestination[ 11 ] = (-a41 * b03 + a42 * b01 - a43 * b00) * fInverseDeterminant;
		    pDataDestination[ 15 ] = (a31 * b03 - a32 * b01 + a33 * b00) * fInverseDeterminant;

		    return m4fDestination;
		};

		inline trace():  number {
			var pData: Float32Array = this.data;
			return pData[ 0 ] + pData[ 5 ] + pData[ 10 ] + pData[ 15 ];
		};

		isEqual(m4fMat: IMat4, fEps:  number  = 0.): bool{
		    var pData1: Float32Array = this.data;
		    var pData2: Float32Array = m4fMat.data;

		    if(fEps === 0.){
		        if(    pData1[ 0 ] != pData2[ 0 ]
		            || pData1[ 4 ] != pData2[ 4 ]
		            || pData1[ 8 ] != pData2[ 8 ]
		            || pData1[ 12 ] != pData2[ 12 ]
		            || pData1[ 1 ] != pData2[ 1 ]
		            || pData1[ 5 ] != pData2[ 5 ]
		            || pData1[ 9 ] != pData2[ 9 ]
		            || pData1[ 13 ] != pData2[ 13 ]
		            || pData1[ 2 ] != pData2[ 2 ]
		            || pData1[ 6 ] != pData2[ 6 ]
		            || pData1[ 10 ] != pData2[ 10 ]
		            || pData1[ 14 ] != pData2[ 14 ]
		            || pData1[ 3 ] != pData2[ 3 ]
		            || pData1[ 7 ] != pData2[ 7 ]
		            || pData1[ 11 ] != pData2[ 11 ]
		            || pData1[ 15 ] != pData2[ 15 ]){

		            return false;
		        }
		    }
		    else{
		        if(    abs(pData1[ 0 ] - pData2[ 0 ]) > fEps
		            || abs(pData1[ 4 ] - pData2[ 4 ]) > fEps
		            || abs(pData1[ 8 ] - pData2[ 8 ]) > fEps
		            || abs(pData1[ 12 ] - pData2[ 12 ]) > fEps
		            || abs(pData1[ 1 ] - pData2[ 1 ]) > fEps
		            || abs(pData1[ 5 ] - pData2[ 5 ]) > fEps
		            || abs(pData1[ 9 ] - pData2[ 9 ]) > fEps
		            || abs(pData1[ 13 ] - pData2[ 13 ]) > fEps
		            || abs(pData1[ 2 ] - pData2[ 2 ]) > fEps
		            || abs(pData1[ 6 ] - pData2[ 6 ]) > fEps
		            || abs(pData1[ 10 ] - pData2[ 10 ]) > fEps
		            || abs(pData1[ 14 ] - pData2[ 14 ]) > fEps
		            || abs(pData1[ 3 ] - pData2[ 3 ]) > fEps
		            || abs(pData1[ 7 ] - pData2[ 7 ]) > fEps
		            || abs(pData1[ 11 ] - pData2[ 11 ]) > fEps
		            || abs(pData1[ 15 ] - pData2[ 15 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		isDiagonal(fEps:  number  = 0.): bool{
			var pData: Float32Array = this.data;

		    if(fEps === 0.){
		        if(    pData[ 4 ] !== 0. || pData[ 8 ] !== 0. || pData[ 12 ] != 0.
		            || pData[ 1 ] !== 0. || pData[ 9 ] !== 0. || pData[ 13 ] != 0.
		            || pData[ 2 ] !== 0. || pData[ 6 ] !== 0. || pData[ 14 ] != 0.
		            || pData[ 3 ] !== 0. || pData[ 7 ] !== 0. || pData[ 11 ] != 0.){

		            return false;
		        }
		    }
		    else{
		        if(    abs(pData[ 4 ]) > fEps || abs(pData[ 8 ]) > fEps || abs(pData[ 12 ]) > fEps
		            || abs(pData[ 1 ]) > fEps || abs(pData[ 9 ]) > fEps || abs(pData[ 13 ]) > fEps
		            || abs(pData[ 2 ]) > fEps || abs(pData[ 6 ]) > fEps || abs(pData[ 14 ]) > fEps
		            || abs(pData[ 3 ]) > fEps || abs(pData[ 7 ]) > fEps || abs(pData[ 11 ]) > fEps){

		            return false;
		        }
		    }
		    return true;
		};

		toMat3(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m3fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 3 ] = pData[ 4 ];
		    pDataDestination[ 6 ] = pData[ 8 ];

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 4 ] = pData[ 5 ];
		    pDataDestination[ 7 ] = pData[ 9 ];

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 5 ] = pData[ 6 ];
		    pDataDestination[ 8 ] = pData[ 10 ];

		    return m3fDestination;
		};

		toQuat4(q4fDestination?: IQuat4){
			if(!isDef(q4fDestination)){
				q4fDestination = new Quat4();
			}

			var pData: Float32Array = this.data;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];

/*x^2*/
		    var x2:  number  = ((a11 - a22 - a33) + 1.)/4.;
/*y^2*/
		    var y2:  number  = ((a22 - a11 - a33) + 1.)/4.;
/*z^2*/
		    var z2:  number  = ((a33 - a11 - a22) + 1.)/4.;
/*w^2*/
		    var w2:  number  = ((a11 + a22 + a33) + 1.)/4.;

		    var fMax:  number  = max(x2,max(y2,max(z2,w2)));

		    if(fMax == x2){
//максимальная компонента берется положительной
		        var x:  number  = sqrt(x2);

		        q4fDestination.x = x;
		        q4fDestination.y = (a21 + a12)/4./x;
		        q4fDestination.z = (a31 + a13)/4./x;
		        q4fDestination.w = (a32 - a23)/4./x;
		    }
		    else if(fMax == y2){
//максимальная компонента берется положительной
		        var y:  number  = sqrt(y2);

		        q4fDestination.x = (a21 + a12)/4./y;
		        q4fDestination.y = y;
		        q4fDestination.z = (a32 + a23)/4./y;
		        q4fDestination.w = (a13 - a31)/4./y;
		    }
		    else if(fMax == z2){
//максимальная компонента берется положительной
		        var z:  number  = sqrt(z2);

		        q4fDestination.x = (a31 + a13)/4./z;
		        q4fDestination.y = (a32 + a23)/4./z;
		        q4fDestination.z = z;
		        q4fDestination.w = (a21 - a12)/4./z;
		    }
		    else{
//максимальная компонента берется положительной
		        var w:  number  = sqrt(w2);

		        q4fDestination.x = (a32 - a23)/4./w;
		        q4fDestination.y = (a13 - a31)/4./w;
		        q4fDestination.z = (a21 - a12)/4./w;
		        q4fDestination.w = w;
		    }

		    return q4fDestination;
		};

		toRotationMatrix(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pData: Float32Array = this.data;
		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 8 ] = pData[ 8 ];
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 9 ];
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 6 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		toString(): string{
			var pData: Float32Array = this.data;

		    return '['  + pData[ 0 ] + ", " + pData[ 4 ] + ', ' + pData[ 8 ] + ', ' + pData[ 12 ] + ',\n'
		                + pData[ 1 ] + ", " + pData[ 5 ] + ', ' + pData[ 9 ] + ', ' + pData[ 13 ] + ',\n'
		                + pData[ 2 ] + ", " + pData[ 6 ] + ', ' + pData[ 10 ] + ', ' + pData[ 14 ] + ',\n'
		                + pData[ 3 ] + ", " + pData[ 7 ] + ', ' + pData[ 11 ] + ', ' + pData[ 15 ]+ ']';
		};

		rotateRight(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;
		    var fLength:  number  = Math.sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		    	logger.setSourceLocation( "Mat4.ts" , 860 ); logger.assert(false,"попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString()); ;
		    	if(isDef(m4fDestination)){
		    		m4fDestination.set(this);
		    	}
		    	else{
		    		m4fDestination = this;
		    	}
		    	return m4fDestination;
		    }

		    var fInvLength:  number  = 1./fLength;

		    x*=fInvLength;
		    y*=fInvLength;
		    z*=fInvLength;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];

		    var fSin:  number  = sin(fAngle);
		    var fCos:  number  = cos(fAngle);
		    var fTmp:  number  = 1. - fCos;

//build Rotation matrix

		    var b11:  number  = fCos + fTmp*x*x, b12:  number  = fTmp*x*y - fSin*z, b13:  number  = fTmp*x*z + fSin*y;
		    var b21:  number  = fTmp*y*z + fSin*z, b22:  number  = fCos + fTmp*y*y, b23:  number  = fTmp*y*z - fSin*x;
		    var b31:  number  = fTmp*z*x - fSin*y, b32:  number  = fTmp*z*y + fSin*x, b33:  number  = fCos + fTmp*z*z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] = a11*b11 + a12*b21 + a13*b31;
		        pData[ 4 ] = a11*b12 + a12*b22 + a13*b32;
		        pData[ 8 ] = a11*b13 + a12*b23 + a13*b33;

		        pData[ 1 ] = a21*b11 + a22*b21 + a23*b31;
		        pData[ 5 ] = a21*b12 + a22*b22 + a23*b32;
		        pData[ 9 ] = a21*b13 + a22*b23 + a23*b33;

		        pData[ 2 ] = a31*b11 + a32*b21 + a33*b31;
		        pData[ 6 ] = a31*b12 + a32*b22 + a33*b32;
		        pData[ 10 ] = a31*b13 + a32*b23 + a33*b33;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = a11*b11 + a12*b21 + a13*b31;
		    pDataDestination[ 4 ] = a11*b12 + a12*b22 + a13*b32;
		    pDataDestination[ 8 ] = a11*b13 + a12*b23 + a13*b33;
		    pDataDestination[ 12 ] = pData[ 12 ];

		    pDataDestination[ 1 ] = a21*b11 + a22*b21 + a23*b31;
		    pDataDestination[ 5 ] = a21*b12 + a22*b22 + a23*b32;
		    pDataDestination[ 9 ] = a21*b13 + a22*b23 + a23*b33;
		    pDataDestination[ 13 ] = pData[ 13 ];

		    pDataDestination[ 2 ] = a31*b11 + a32*b21 + a33*b31;
		    pDataDestination[ 6 ] = a31*b12 + a32*b22 + a33*b32;
		    pDataDestination[ 10 ] = a31*b13 + a32*b23 + a33*b33;
		    pDataDestination[ 14 ] = pData[ 14 ];

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		rotateLeft(fAngle:  number , v3fAxis: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;
		    var fLength:  number  = Math.sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		    	logger.setSourceLocation( "Mat4.ts" , 938 ); logger.assert(false,"попытка вращения вокруг оси нулевой длины. Угол " + fAngle + ". Ось " + v3fAxis.toString()); ;
		    	if(isDef(m4fDestination)){
		    		m4fDestination.set(this);
		    	}
		    	else{
		    		m4fDestination = this;
		    	}
		    	return m4fDestination;
		    }

		    var fInvLength:  number  = 1./fLength;

		    x*=fInvLength;
		    y*=fInvLength;
		    z*=fInvLength;

		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
		    var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
		    var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];

		    var fSin:  number  = sin(fAngle);
		    var fCos:  number  = cos(fAngle);
		    var fTmp:  number  = 1. - fCos;

//build Rotation matrix

		    var b11:  number  = fCos + fTmp*x*x, b12:  number  = fTmp*x*y - fSin*z, b13:  number  = fTmp*x*z + fSin*y;
		    var b21:  number  = fTmp*y*z + fSin*z, b22:  number  = fCos + fTmp*y*y, b23:  number  = fTmp*y*z - fSin*x;
		    var b31:  number  = fTmp*z*x - fSin*y, b32:  number  = fTmp*z*y + fSin*x, b33:  number  = fCos + fTmp*z*z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] = b11*a11 + b12*a21 + b13*a31;
		        pData[ 4 ] = b11*a12 + b12*a22 + b13*a32;
		        pData[ 8 ] = b11*a13 + b12*a23 + b13*a33;
		        pData[ 12 ] = b11*a14 + b12*a24 + b13*a34;

		        pData[ 1 ] = b21*a11 + b22*a21 + b23*a31;
		        pData[ 5 ] = b21*a12 + b22*a22 + b23*a32;
		        pData[ 9 ] = b21*a13 + b22*a23 + b23*a33;
		        pData[ 13 ] = b21*a14 + b22*a24 + b23*a34;

		        pData[ 2 ] = b31*a11 + b32*a21 + b33*a31;
		        pData[ 6 ] = b31*a12 + b32*a22 + b33*a32;
		        pData[ 10 ] = b31*a13 + b32*a23 + b33*a33;
		        pData[ 14 ] = b31*a14 + b32*a24 + b33*a34;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = b11*a11 + b12*a21 + b13*a31;
		    pDataDestination[ 4 ] = b11*a12 + b12*a22 + b13*a32;
		    pDataDestination[ 8 ] = b11*a13 + b12*a23 + b13*a33;
		    pDataDestination[ 12 ] = b11*a14 + b12*a24 + b13*a34;

		    pDataDestination[ 1 ] = b21*a11 + b22*a21 + b23*a31;
		    pDataDestination[ 5 ] = b21*a12 + b22*a22 + b23*a32;
		    pDataDestination[ 9 ] = b21*a13 + b22*a23 + b23*a33;
		    pDataDestination[ 13 ] = b21*a14 + b22*a24 + b23*a34;

		    pDataDestination[ 2 ] = b31*a11 + b32*a21 + b33*a31;
		    pDataDestination[ 6 ] = b31*a12 + b32*a22 + b33*a32;
		    pDataDestination[ 10 ] = b31*a13 + b32*a23 + b33*a33;
		    pDataDestination[ 14 ] = b31*a14 + b32*a24 + b33*a34;

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		inline setTranslation(v3fTranslation: IVec3): IMat4{
			var pData: Float32Array = this.data;

			pData[ 12 ] = v3fTranslation.x;
			pData[ 13 ] = v3fTranslation.y;
			pData[ 14 ] = v3fTranslation.z;

			return this;
		};

		inline getTranslation(v3fTranslation?: IVec3): IVec3{
			if(!isDef(v3fTranslation)){
				v3fTranslation = new Vec3();
			}

			var pData: Float32Array = this.data;

			v3fTranslation.x = pData[ 12 ];
			v3fTranslation.y = pData[ 13 ];
			v3fTranslation.z = pData[ 14 ];

			return v3fTranslation;
		};

		translateRight(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fTranslation.x, y:  number  = v3fTranslation.y, z:  number  = v3fTranslation.z;

		    if(!isDef(m4fDestination)){
		        pData[ 12 ] = pData[ 0 ]*x + pData[ 4 ]*y + pData[ 8 ]*z + pData[ 12 ];
		        pData[ 13 ] = pData[ 1 ]*x + pData[ 5 ]*y + pData[ 9 ]*z + pData[ 13 ];
		        pData[ 14 ] = pData[ 2 ]*x + pData[ 6 ]*y + pData[ 10 ]*z + pData[ 14 ];
		        pData[ 15 ] = pData[ 3 ]*x + pData[ 7 ]*y + pData[ 11 ]*z + pData[ 15 ];
//строго говоря последнюю строчку умножать не обязательно, так как она должна быть -> 0 0 0 1
		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

//кешируем матрицу вращений
		    var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ], a13:  number  = pData[ 8 ];
		    var a21:  number  = pData[ 0 ], a22:  number  = pData[ 5 ], a23:  number  = pData[ 9 ];
		    var a31:  number  = pData[ 0 ], a32:  number  = pData[ 6 ], a33:  number  = pData[ 10 ];
		    var a41:  number  = pData[ 0 ], a42:  number  = pData[ 7 ], a43:  number  = pData[ 11 ];

		    pDataDestination[ 0 ] = a11;
		    pDataDestination[ 4 ] = a12;
		    pDataDestination[ 8 ] = a13;
		    pDataDestination[ 12 ] = a11*x + a12*y + a13*z + pData[ 12 ];

		    pDataDestination[ 1 ] = a21;
		    pDataDestination[ 5 ] = a22;
		    pDataDestination[ 9 ] = a23;
		    pDataDestination[ 13 ] = a21*x + a22*y + a23*z + pData[ 13 ];

		    pDataDestination[ 2 ] = a31;
		    pDataDestination[ 6 ] = a32;
		    pDataDestination[ 10 ] = a33;
		    pDataDestination[ 14 ] = a31*x + a32*y + a33*z + pData[ 14 ];

		    pDataDestination[ 3 ] = a41;
		    pDataDestination[ 7 ] = a42;
		    pDataDestination[ 11 ] = a43;
		    pDataDestination[ 15 ] = a41*x + a42*y + a43*z + pData[ 15 ];

		    return m4fDestination;
		};

		translateLeft(v3fTranslation: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fTranslation.x, y:  number  = v3fTranslation.y, z:  number  = v3fTranslation.z;

		    if(!isDef(m4fDestination)){
		        pData[ 12 ] = x + pData[ 12 ];
		        pData[ 13 ] = y + pData[ 13 ];
		        pData[ 14 ] = z + pData[ 14 ];
		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ];
		    pDataDestination[ 4 ] = pData[ 4 ];
		    pDataDestination[ 8 ] = pData[ 8 ];
		    pDataDestination[ 12 ] = x + pData[ 12 ];

		    pDataDestination[ 1 ] = pData[ 1 ];
		    pDataDestination[ 5 ] = pData[ 5 ];
		    pDataDestination[ 9 ] = pData[ 9 ];
		    pDataDestination[ 13 ] = y + pData[ 13 ];

		    pDataDestination[ 2 ] = pData[ 2 ];
		    pDataDestination[ 6 ] = pData[ 6 ];
		    pDataDestination[ 10 ] = pData[ 10 ];
		    pDataDestination[ 14 ] = z + pData[ 14 ];

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		scaleRight(v3fScale: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fScale.x, y:  number  = v3fScale.y, z:  number  = v3fScale.z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] *= x;
		        pData[ 4 ] *= y;
		        pData[ 8 ] *= z;

		        pData[ 1 ] *= x;
		        pData[ 5 ] *= y;
		        pData[ 9 ] *= z;

		        pData[ 2 ] *= x;
		        pData[ 6 ] *= y;
		        pData[ 10 ] *= z;

//скейлить эти компоненты необязательно, так как там должны лежать нули
		        pData[ 3 ] *= x;
		        pData[ 7 ] *= y;
		        pData[ 11 ] *= z;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ]*x;
		    pDataDestination[ 4 ] = pData[ 4 ]*y;
		    pDataDestination[ 8 ] = pData[ 8 ]*z;
		    pDataDestination[ 12 ] = pData[ 12 ];

		    pDataDestination[ 1 ] = pData[ 1 ]*x;
		    pDataDestination[ 5 ] = pData[ 5 ]*y;
		    pDataDestination[ 9 ] = pData[ 9 ]*z;
		    pDataDestination[ 13 ] = pData[ 13 ];

		    pDataDestination[ 2 ] = pData[ 2 ]*x;
		    pDataDestination[ 6 ] = pData[ 6 ]*y;
		    pDataDestination[ 10 ] = pData[ 10 ]*z;
		    pDataDestination[ 14 ] = pData[ 14 ];

//скейлить эти компоненты необязательно, так как там должны лежать нули
		    pDataDestination[ 3 ] = pData[ 3 ]*x;
		    pDataDestination[ 7 ] = pData[ 7 ]*y;
		    pDataDestination[ 11 ] = pData[ 11 ]*z;
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		scaleLeft(v3fScale: IVec3, m4fDestination?: IMat4): IMat4{
			var pData: Float32Array = this.data;

		    var x:  number  = v3fScale.x, y:  number  = v3fScale.y, z:  number  = v3fScale.z;

		    if(!isDef(m4fDestination)){
		        pData[ 0 ] *= x;
		        pData[ 4 ] *= x;
		        pData[ 8 ] *= x;
		        pData[ 12 ] *= x;

		        pData[ 1 ] *= y;
		        pData[ 5 ] *= y;
		        pData[ 9 ] *= y;
		        pData[ 13 ] *= y;

		        pData[ 2 ] *= z;
		        pData[ 6 ] *= z;
		        pData[ 10 ] *= z;
		        pData[ 14 ] *= z;

		        return this;
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    pDataDestination[ 0 ] = pData[ 0 ]*x;
		    pDataDestination[ 4 ] = pData[ 4 ]*x;
		    pDataDestination[ 8 ] = pData[ 8 ]*x;
		    pDataDestination[ 12 ] = pData[ 12 ]*x;

		    pDataDestination[ 1 ] = pData[ 1 ]*y;
		    pDataDestination[ 5 ] = pData[ 5 ]*y;
		    pDataDestination[ 9 ] = pData[ 9 ]*y;
		    pDataDestination[ 13 ] = pData[ 13 ]*y;

		    pDataDestination[ 2 ] = pData[ 2 ]*z;
		    pDataDestination[ 6 ] = pData[ 6 ]*z;
		    pDataDestination[ 10 ] = pData[ 10 ]*z;
		    pDataDestination[ 14 ] = pData[ 14 ]*z;

		    pDataDestination[ 3 ] = pData[ 3 ];
		    pDataDestination[ 7 ] = pData[ 7 ];
		    pDataDestination[ 11 ] = pData[ 11 ];
		    pDataDestination[ 15 ] = pData[ 15 ];

		    return m4fDestination;
		};

		inline decompose(q4fRotation: IQuat4, v3fScale: IVec3, v3fTranslation: IVec3): bool{
			this.getTranslation(v3fTranslation);
			var m3fRotScale = this.toMat3(mat3());
			return m3fRotScale.decompose(q4fRotation,v3fScale);
		};

		row(iRow:  number , v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;

			switch(iRow){
				case 1:
					v4fDestination.x = pData[ 0 ];
					v4fDestination.y = pData[ 4 ];
					v4fDestination.z = pData[ 8 ];
					v4fDestination.w = pData[ 12 ];
					break;
				case 2:
					v4fDestination.x = pData[ 1 ];
					v4fDestination.y = pData[ 5 ];
					v4fDestination.z = pData[ 9 ];
					v4fDestination.w = pData[ 13 ];
					break;
				case 3:
					v4fDestination.x = pData[ 2 ];
					v4fDestination.y = pData[ 6 ];
					v4fDestination.z = pData[ 10 ];
					v4fDestination.w = pData[ 14 ];
					break;
				case 4:
					v4fDestination.x = pData[ 3 ];
					v4fDestination.y = pData[ 7 ];
					v4fDestination.z = pData[ 11 ];
					v4fDestination.w = pData[ 15 ];
					break;
			}

			return v4fDestination;
		};

		column(iColumn:  number , v4fDestination?: IVec4): IVec4{
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;

			switch(iColumn){
				case 1:
					v4fDestination.x = pData[ 0 ];
					v4fDestination.y = pData[ 1 ];
					v4fDestination.z = pData[ 2 ];
					v4fDestination.w = pData[ 3 ];
					break;
				case 2:
					v4fDestination.x = pData[ 4 ];
					v4fDestination.y = pData[ 5 ];
					v4fDestination.z = pData[ 6 ];
					v4fDestination.w = pData[ 7 ];
					break;
				case 3:
					v4fDestination.x = pData[ 8 ];
					v4fDestination.y = pData[ 9 ];
					v4fDestination.z = pData[ 10 ];
					v4fDestination.w = pData[ 11 ];
					break;
				case 4:
					v4fDestination.x = pData[ 12 ];
					v4fDestination.y = pData[ 13 ];
					v4fDestination.z = pData[ 14 ];
					v4fDestination.w = pData[ 15 ];
					break;
			}

			return v4fDestination;
		};

		unproj(v3fScreen: IVec3, v4fDestination?: IVec4): IVec4;
		unproj(v4fScreen: IVec4, v4fDestination?: IVec4): IVec4;
		unproj(v: any, v4fDestination?: IVec4): IVec4 {
			if(!isDef(v4fDestination)){
				v4fDestination = new Vec4();
			}

			var pData: Float32Array = this.data;
			var v3fScreen: IVec3 = <IVec3>v;
			var x:  number , y:  number , z:  number ;

			if(this.isOrthogonalProjection()){
//orthogonal projection case

				z = (v3fScreen.z - pData[ 14 ])/pData[ 10 ];
				y = (v3fScreen.y - pData[ 13 ])/pData[ 5 ];
				x = (v3fScreen.x - pData[ 12 ])/pData[ 0 ];
			}
			else{
//frustum case

				z = -pData[ 14 ]/(pData[ 10 ] + v3fScreen.z);
			    y = -(v3fScreen.y + pData[ 9 ])*z/pData[ 5 ];
			    x = -(v3fScreen.x + pData[ 8 ])*z/pData[ 0 ];
			}

			v4fDestination.x = x;
			v4fDestination.y = y;
			v4fDestination.z = z;
			v4fDestination.w = 1.;

			return v4fDestination;
		};

		unprojZ(fZ:  number ):  number {
			var pData: Float32Array = this.data;

			if(this.isOrthogonalProjection()){
//orthogonal projection case
				return (fZ - pData[ 14 ])/pData[ 10 ];
			}
			else{
//pData[__43] === -1
//frustum case
				return -pData[ 14 ]/(pData[ 10 ] + fZ);
			}
		};

		inline isOrthogonalProjection(): bool{
// var pData: Float32Array = this.data;

// if(pData[__44] === 1){
// 	//orthogonal projection
// 	return true;
// }
// else{
// 	//pData[__43] === -1
// 	//frustum projection
// 	return false;
// }

			return ((this.data[ 15 ] === 1) ? true : false);
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number , m4fDestination?: IMat4): IMat4;
		static fromYawPitchRoll(v3fAngles: IVec3, m4fDestination?: IMat4): IMat4;
		static fromYawPitchRoll(fYaw?,fPitch?,fRoll?,m4fDestination?): IMat4{
			if(arguments.length <= 2){
//Vec3 + m4fDestination
		        var v3fVec: IVec3 = arguments[0];

		        fYaw   = v3fVec.x;
		        fPitch = v3fVec.y;
		        fRoll  = v3fVec.z;

		        m4fDestination = arguments[1];
		    }

		    if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fSin1:  number  = Math.sin(fYaw);
		    var fSin2:  number  = Math.sin(fPitch);
		    var fSin3:  number  = Math.sin(fRoll);

		    var fCos1:  number  = Math.cos(fYaw);
		    var fCos2:  number  = Math.cos(fPitch);
		    var fCos3:  number  = Math.cos(fRoll);

		    pDataDestination[ 0 ] = fCos1 * fCos3 + fSin1 * fSin2 * fSin3;
		    pDataDestination[ 4 ] = fCos3 * fSin1 * fSin2 - fCos1 * fSin3;
		    pDataDestination[ 8 ] = fCos2 * fSin1;
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = fCos2 * fSin3;
		    pDataDestination[ 5 ] = fCos2 * fCos3;
		    pDataDestination[ 9 ] = -fSin2;
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = fCos1 * fSin2 * fSin3 - fCos3 * fSin1;
		    pDataDestination[ 6 ] = fSin1 * fSin3 + fCos1 * fCos3 * fSin2;
		    pDataDestination[ 10 ] = fCos1 * fCos2;
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , m4fDestination?: IMat4): IMat4;
		static fromXYZ(v3fAngles: IVec3, m4fDestination?: IMat4): IMat4;
		static fromXYZ(fX?, fY?, fZ?, m4fDestination?) : IMat4{
			if(arguments.length <= 2){
//Vec3 + m4fDestination
				var v3fVec: IVec3 = arguments[0];
				return Mat4.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m4fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Mat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static frustum(fLeft:  number , fRight:  number , fBottom:  number , fTop:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fRL:  number  = fRight - fLeft;
		    var fTB:  number  = fTop - fBottom;
		    var fFN:  number  = fFar - fNear;

		    pDataDestination[ 0 ] = 2.*fNear/fRL;
		    pDataDestination[ 4 ] = 0.;
		    pDataDestination[ 8 ] = (fRight + fLeft)/fRL;
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = 0.;
		    pDataDestination[ 5 ] = 2.*fNear/fTB;
		    pDataDestination[ 9 ] = (fTop + fBottom)/fTB;
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = 0.;
		    pDataDestination[ 6 ] = 0.;
		    pDataDestination[ 10 ] = -(fFar + fNear)/fFN;
		    pDataDestination[ 14 ] = -2.*fFar*fNear/fFN;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = -1.;
		    pDataDestination[ 15 ] = 0.;

		    return m4fDestination;
		};

		inline static perspective(fFovy:  number , fAspect:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			var fTop:  number  = fNear*tan(fFovy/2.);
			var fRight:  number  = fTop*fAspect;

			return Mat4.frustum(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
		};

		static orthogonalProjectionAsymmetric(fLeft:  number , fRight:  number , fBottom:  number ,
												 fTop:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{

			 if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }

		    var pDataDestination: Float32Array = m4fDestination.data;

		    var fRL:  number  = fRight - fLeft;
		    var fTB:  number  = fTop - fBottom;
		    var fFN:  number  = fFar - fNear;

		    pDataDestination[ 0 ] = 2./fRL;
		    pDataDestination[ 4 ] = 0.;
		    pDataDestination[ 8 ] = 0.;
		    pDataDestination[ 12 ] = -(fRight + fLeft)/fRL;

		    pDataDestination[ 1 ] = 0.;
		    pDataDestination[ 5 ] = 2./fTB;
		    pDataDestination[ 9 ] = 0.;
		    pDataDestination[ 13 ] = -(fTop + fBottom)/fTB;

		    pDataDestination[ 2 ] = 0.;
		    pDataDestination[ 6 ] = 0.;
		    pDataDestination[ 10 ] = -2./fFN;
		    pDataDestination[ 14 ] = -(fFar + fNear)/fFN;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		inline static orthogonalProjection(fWidth:  number , fHeight:  number , fNear:  number , fFar:  number , m4fDestination?: IMat4): IMat4{
			var fRight:  number  = fWidth/2.;
		    var fTop:  number  = fHeight/2.;
		    return Mat4.orthogonalProjectionAsymmetric(-fRight, fRight, -fTop, fTop, fNear, fFar, m4fDestination);
		};

		static lookAt(v3fEye: IVec3, v3fCenter: IVec3, v3fUp: IVec3, m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4(1.);
		    }

		    var fEyeX:  number  = v3fEye.x, fEyeY:  number  = v3fEye.y, fEyeZ:  number  = v3fEye.z;
		    var fCenterX:  number  = v3fCenter.x, fCenterY:  number  = v3fCenter.y, fCenterZ:  number  = v3fCenter.z;
		    var fUpX:  number  = v3fUp.x, fUpY:  number  = v3fUp.y, fUpZ:  number  = v3fUp.z;

		    var fLength:  number ;
		    var fInvLength:  number ;

		    if(fEyeX === fCenterX && fEyeY === fCenterY && fEyeZ === fCenterZ){
		        return m4fDestination;
		    }

		    var fXNewX:  number , fXNewY:  number , fXNewZ:  number ;
		    var fYNewX:  number , fYNewY:  number , fYNewZ:  number ;
		    var fZNewX:  number , fZNewY:  number , fZNewZ:  number ;

//ось Z направлена на наблюдателя
		    fZNewX = fEyeX - fCenterX;
		    fZNewY = fEyeY - fCenterY;
		    fZNewZ = fEyeZ - fCenterZ;

		    fLength = sqrt(fZNewX*fZNewX + fZNewY*fZNewY + fZNewZ*fZNewZ);
		    fInvLength = 1./fLength;

//новая ось Z
		    fZNewX = fZNewX*fInvLength;
		    fZNewY = fZNewY*fInvLength;
		    fZNewZ = fZNewZ*fInvLength;

//новая ось X
		    fXNewX = fUpY*fZNewZ - fUpZ*fZNewY;
		    fXNewY = fUpZ*fZNewX - fUpX*fZNewZ;
		    fXNewZ = fUpX*fZNewY - fUpY*fZNewX;

		    fLength = sqrt(fXNewX*fXNewX + fXNewY*fXNewY + fXNewZ*fXNewZ);
		    if(fLength){
		    	fInvLength = 1./fLength;

		        fXNewX = fXNewX*fInvLength;
		        fXNewY = fXNewY*fInvLength;
		        fXNewZ = fXNewZ*fInvLength;
		    }

//новая ось Y

		    fYNewX = fZNewY*fXNewZ - fZNewZ*fXNewY;
		    fYNewY = fZNewZ*fXNewX - fZNewX*fXNewZ;
		    fYNewZ = fZNewX*fXNewY - fZNewY*fXNewX;

//нормировать ненужно, так как было векторное умножение двух ортонормированных векторов

//положение камеры в новых осях
		    var fEyeNewX:  number  = fEyeX*fXNewX + fEyeY*fXNewY + fEyeZ*fXNewZ;
		    var fEyeNewY:  number  = fEyeX*fYNewX + fEyeY*fYNewY + fEyeZ*fYNewZ;
		    var fEyeNewZ:  number  = fEyeX*fZNewX + fEyeY*fZNewY + fEyeZ*fZNewZ;

		    var pDataDestination: Float32Array = m4fDestination.data;

//lookAt matrix === camera view matrix 
//почему новый базис записывается по строкам?
//это сзязано с тем, что это получающаяся матрица - 
//это viewMatrix камеры, а на эту матрицу умножается при рендеринге, то есть
//модель должна испытать преобразования противоположные тем, которые испытывает камера
//то есть вращение в другую сторону(базис по строкам) и сдвиг в противоположную сторону

		    pDataDestination[ 0 ] = fXNewX;
		    pDataDestination[ 4 ] = fXNewY;
		    pDataDestination[ 8 ] = fXNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 12 ] = -fEyeNewX;

		    pDataDestination[ 1 ] = fYNewX;
		    pDataDestination[ 5 ] = fYNewY;
		    pDataDestination[ 9 ] = fYNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 13 ] = -fEyeNewY;

		    pDataDestination[ 2 ] = fZNewX;
		    pDataDestination[ 6 ] = fZNewY;
		    pDataDestination[ 10 ] = fZNewZ;
/*отъезжаем в позицию камеры*/
		    pDataDestination[ 14 ] = -fEyeNewZ;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

		    return m4fDestination;
		};

		static get stackCeil(): Mat4 { Mat4.stackPosition = Mat4.stackPosition === Mat4.stackSize - 1? 0: Mat4.stackPosition; return Mat4.stack[Mat4.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Mat4[] = (function(): Mat4[]{ var pStack: Mat4[] = new Array(Mat4.stackSize); for(var i: number = 0; i<Mat4.stackSize; i++){ pStack[i] = new Mat4(); } return pStack})();
    }
}

















module akra.math {
    export class Quat4 implements IQuat4{
    	x:  number ;
    	y:  number ;
    	z:  number ;
    	w:  number ;

    	constructor();
    	constructor(q4fQuat: IQuat4);
    	constructor(pArray:  number []);
    	constructor(fValue:  number , fW:  number );
    	constructor(v3fValue: IVec3, fW:  number );
    	constructor(fX:  number , fY:  number , fZ:  number , fW:  number );
    	constructor(fX?, fY?, fZ?, fW?){
    		var nArgumentsLength:  number  = arguments.length;

    		switch(nArgumentsLength){
    			case 1:
    				this.set(arguments[0]);
    				break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 4:
					this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
					break;
				default:
					this.x = this.y = this.z = 0.;
					this.w = 1.;
					break;
    		}
    	};

    	set(): IQuat4;
		set(q4fQuat: IQuat4): IQuat4;
		set(pArray:  number []): IQuat4;
		set(fValue:  number , fW:  number ): IQuat4;
		set(v3fValue: IVec3, fW:  number ): IQuat4;
		set(fX:  number , fY:  number , fZ:  number , fW:  number ): IQuat4;
		set(fX?, fY?, fZ?, fW?): IQuat4{
			var nArgumentsLength:  number  = arguments.length;

		    if(nArgumentsLength === 0){
		        this.x = this.y = this.z = 0.;
		        this.w = 1.;
		    }
		    if(nArgumentsLength === 1){
		        if(arguments[0] instanceof Quat4){
		        	var q4fQuat: IQuat4 = arguments[0];

		            this.x = q4fQuat.x;
		            this.y = q4fQuat.y;
		            this.z = q4fQuat.z;
		            this.w = q4fQuat.w;
		        }
		        else{
//Array
		            var pElements:  number [] = arguments[0];

		            this.x = pElements[0];
		            this.y = pElements[1];
		            this.z = pElements[2];
		            this.w = pElements[3];
		        }
		    }
		    else if(nArgumentsLength === 2){
//float float
//vec3 float
		        if(isFloat(arguments[0])){
//float float
		            var fValue:  number  = arguments[0];

		            this.x = fValue;
		            this.y = fValue;
		            this.z = fValue;
		            this.w = arguments[1];
		        }
		        else{
//vec3 float
		            var v3fValue: IVec3 = arguments[0];

		            this.x = v3fValue.x;
		            this.y = v3fValue.y;
		            this.z = v3fValue.z;
		            this.w = arguments[1];
		        }
		    }
		    else if(nArgumentsLength === 4){
		        this.x = arguments[0];
		        this.y = arguments[1];
		        this.z = arguments[2];
		        this.w = arguments[3];
		    }

		    return this;
		};

		multiply(q4fQuat: IQuat4, q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

		    q4fDestination.x = x1*w2 + x2*w1 + y1*z2 - z1*y2;
		    q4fDestination.y = y1*w2 + y2*w1 + z1*x2 - x1*z2;
		    q4fDestination.z = z1*w2 + z2*w1 + x1*y2 - y1*x2;
		    q4fDestination.w = w1*w2 - x1*x2 - y1*y2 - z1*z2;

		    return q4fDestination;
		};

		multiplyVec3(v3fVec: IVec3, v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
		        v3fDestination = v3fVec;
		    }

		    var q4fVec: IQuat4 = quat4(v3fVec,0);
		    var qInverse: IQuat4 = this.inverse(quat4());

		    var qResult: IQuat4 = this.multiply(q4fVec.multiply(qInverse),quat4());

		    v3fDestination.x = qResult.x;
		    v3fDestination.y = qResult.y;
		    v3fDestination.z = qResult.z;

		    return v3fDestination;
		};

		conjugate(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
			    this.x = -this.x;
			    this.y = -this.y;
			    this.z = -this.z;

			    return this;
			}

			q4fDestination.x = -this.x;
			q4fDestination.y = -this.y;
			q4fDestination.z = -this.z;
			q4fDestination.w = this.w;

			return q4fDestination;
		};

		inverse(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
		    var fSqLength:  number  = x*x + y*y + z*z + w*w;

		    if(fSqLength === 0.){
		        q4fDestination.x = 0.;
		        q4fDestination.y = 0.;
		        q4fDestination.z = 0.;
		        q4fDestination.w = 0.;
		    }
		    else{
		        var fInvSqLength :  number = 1./fSqLength;
		        q4fDestination.x = -x*fInvSqLength;
		        q4fDestination.y = -y*fInvSqLength;
		        q4fDestination.z = -z*fInvSqLength;
		        q4fDestination.w =  w*fInvSqLength;
		    }

		    return q4fDestination;
		};

		inline length() :  number {
			var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;
    		return sqrt(x*x + y*y + z*z + w*w);
		};

		normalize(q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);

		    if(fLength === 0.){
		    	q4fDestination.x = 0.;
		    	q4fDestination.y = 0.;
		    	q4fDestination.z = 0.;
		    	q4fDestination.w = 0.;

		    }
		    else{
		    	var fInvLength:  number  = 1/fLength;

		    	q4fDestination.x = x*fInvLength;
		    	q4fDestination.y = y*fInvLength;
		    	q4fDestination.z = z*fInvLength;
		    	q4fDestination.w = w*fInvLength;
		    }

		    return q4fDestination;
		};

		calculateW(q4fDestination?: IQuat4): IQuat4{
			var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z;

		    if(!isDef(q4fDestination)){
		        this.w = sqrt(1. - x*x - y*y - z*z);
		        return this;
		    }

		    q4fDestination.x = x;
		    q4fDestination.y = y;
		    q4fDestination.z = z;
		    q4fDestination.w = sqrt(1. - x*x - y*y - z*z);

		    return q4fDestination;
		};

		isEqual(q4fQuat: IQuat4, fEps:  number  = 0., asMatrix: bool = false): bool{

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

		    var fLength1:  number  = sqrt(x1*x1 + y1*y1 + z1*z1 + w1*w1);
		    var fLength2:  number  = sqrt(x2*x2 + y2*y2 + z2*z2 + w2*w2);

		    if(abs(fLength2 - fLength2) > fEps){
		        return false;
		    }

		    var cosHalfTheta:  number  = (x1*x2 + y1*y2 + z1*z2 + w1*w2)/fLength1/fLength2;

		    if(asMatrix){
		        cosHalfTheta = abs(cosHalfTheta);
		    }

		    if(1. - cosHalfTheta > fEps){
		        return false;
		    }
		    return true;
		};

		getYaw():  number {
		    var fYaw:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;

		    if(abs(x) == abs(w)){
//вырожденный случай обрабатывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        fYaw = atan2(yTemp,wTemp)*2.;
//fRoll = 0;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
		            fYaw -= pi;
//fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
		            fYaw += pi;
//fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
		        fYaw = atan2(fx2*z + fy2*w, 1. - (fx2*x + fy2*y));
		    }

		    return fYaw;
		};

		getPitch():  number {
			var fPitch:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;

/*в очень редких случаях из-за ошибок округления получается результат > 1*/
		    var fSinPitch:  number  = clamp(fx2*w - fy2*z,-1.,1.);
		    fPitch = asin(fSinPitch)

		    return fPitch;
		};

		getRoll():  number {
		    var fRoll:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fz2:  number  = z*2.;

		    if(abs(x) == abs(w)){
//вырожденный случай обраба��ывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        var fYaw:  number  = atan2(yTemp,wTemp)*2.;
		        fRoll = 0.;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
//fYaw -= pi;
		            fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
//fYaw += pi;
		            fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
		        fRoll = atan2(fx2*y + fz2*w, 1. - (fx2*x + fz2*z));
		    }

		    return fRoll;
		};

		toYawPitchRoll(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
		        v3fDestination = new Vec3();
		    }

		    var fYaw:  number , fPitch:  number , fRoll:  number ;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

		    var fx2:  number  = x*2.;
		    var fy2:  number  = y*2.;
		    var fz2:  number  = z*2.;
		    var fw2:  number  = w*2.;

/*в очень редких случаях из-за ошибок округления получается результат > 1*/
		    var fSinPitch:  number  = clamp(fx2*w - fy2*z,-1.,1.);
		    fPitch = asin(fSinPitch);
//не известен знак косинуса, как следствие это потребует дополнительной проверки.
//как показала практика - это не на что не влияет, просто один и тот же кватернион можно получить двумя разными вращениями

		    if(abs(x) == abs(w)){
//вырожденный случай обрабатывается отдельно
//
		        var wTemp:  number  = w*sqrt(2.);
//cos(Yaw/2)*cos(Roll/2) + sin(Yaw/2)*sin(Roll/2) = cos((Yaw-Roll)/2); Roll = 0;
//x==-w
//cos(Yaw/2)*cos(Roll/2) - sin(Yaw/2)*sin(Roll/2) = cos((Yaw+Roll)/2); Roll = 0;
		        var yTemp:  number  = y*sqrt(2.);
//sin(Yaw/2)*cos(Roll/2) - cos(Yaw/2)*sin(Roll/2) = sin((Yaw-Roll)/2); Roll = 0;
//x==-w
//sin(Yaw/2)*cos(Roll/2) + cos(Yaw/2)*sin(Roll/2) = sin((Yaw+Roll)/2); Roll = 0;

		        fYaw = atan2(yTemp,wTemp)*2.;
		        fRoll = 0.;

//убираем дополнительный оборот
		        var pi:  number  = PI;
		        if(fYaw > pi){
		            fYaw -= pi;
		            fRoll = (x == w) ? -pi : pi;
		        }
		        else if(fYaw < -pi){
		            fYaw += pi;
		            fRoll = (x == w) ? pi : -pi;
		        }
		    }
		    else{
//Math.atan2(sin(Yaw)*cos(Pitch),cos(Yaw)*cos(Pitch));
		        fYaw = atan2(fx2*z + fy2*w, 1. - (fx2*x + fy2*y));
//Math.atan2(cos(Pitch) * sin(Roll),cos(Pitch)*cos(Roll));
		        fRoll = atan2(fx2*y + fz2*w, 1. - (fx2*x + fz2*z));
		    }

		    v3fDestination.x = fYaw;
		    v3fDestination.y = fPitch;
		    v3fDestination.z = fRoll;

		    return v3fDestination;
		};

		toMat3(m3fDestination?: IMat3): IMat3{
			if(!isDef(m3fDestination)){
		        m3fDestination = new Mat3();
		    }
		    var pDataDestination: Float32Array = m3fDestination.data;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

//потом необходимо ускорить

		    pDataDestination[ 0 ] = 1. - 2.*(y*y + z*z);
		    pDataDestination[ 3 ] = 2.*(x*y - z*w);
		    pDataDestination[ 6 ] = 2.*(x*z + y*w);

		    pDataDestination[ 1 ] = 2.*(x*y + z*w);
		    pDataDestination[ 4 ] = 1. - 2.*(x*x + z*z);
		    pDataDestination[ 7 ] = 2.*(y*z - x*w);

		    pDataDestination[ 2 ] = 2.*(x*z - y*w);
		    pDataDestination[ 5 ] = 2.*(y*z + x*w);
		    pDataDestination[ 8 ] = 1. - 2.*(x*x + y*y);

		    return m3fDestination;
		};

		toMat4(m4fDestination?: IMat4): IMat4{
			if(!isDef(m4fDestination)){
		        m4fDestination = new Mat4();
		    }
		    var pDataDestination: Float32Array = m4fDestination.data;

		    var x:  number  = this.x, y:  number  = this.y, z:  number  = this.z, w:  number  = this.w;

//потом необходимо ускорить

		    pDataDestination[ 0 ] = 1. - 2.*(y*y + z*z);
		    pDataDestination[ 4 ] = 2.*(x*y - z*w);
		    pDataDestination[ 8 ] = 2.*(x*z + y*w);
		    pDataDestination[ 12 ] = 0.;

		    pDataDestination[ 1 ] = 2.*(x*y + z*w);
		    pDataDestination[ 5 ] = 1. - 2.*(x*x + z*z);
		    pDataDestination[ 9 ] = 2.*(y*z - x*w);
		    pDataDestination[ 13 ] = 0.;

		    pDataDestination[ 2 ] = 2.*(x*z - y*w);
		    pDataDestination[ 6 ] = 2.*(y*z + x*w);
		    pDataDestination[ 10 ] = 1. - 2.*(x*x + y*y);
		    pDataDestination[ 14 ] = 0.;

		    pDataDestination[ 3 ] = 0.;
		    pDataDestination[ 7 ] = 0.;
		    pDataDestination[ 11 ] = 0.;
		    pDataDestination[ 15 ] = 1.;

    		return m4fDestination;
		};

		inline toString(): string{
			return "[x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", w: " + this.w + "]";
		};

		mix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath: bool = true){
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    fA = clamp(fA,0,1);

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

//скалярное произведение
		    var fCos:  number  = x1*x2 + y1*y2 + z1*z2 + w1*w2;

		    if(fCos < 0. && bShortestPath){
		        x2 = -x2;
		        y2 = -y2;
		        z2 = -z2;
		        w2 = -w2;
		    }

		    var k1:  number  = 1. - fA;
		    var k2:  number  = fA;

		    q4fDestination.x = x1*k1 + x2*k2;
		    q4fDestination.y = y1*k1 + y2*k2;
		    q4fDestination.z = z1*k1 + z2*k2;
		    q4fDestination.w = w1*k1 + w2*k2;

		    return q4fDestination;
		};

		smix(q4fQuat: IQuat4, fA:  number , q4fDestination?: IQuat4, bShortestPath: bool = true){
			if(!isDef(q4fDestination)){
		        q4fDestination = this;
		    }

		    fA = clamp(fA,0,1);

		    var x1:  number  = this.x, y1:  number  = this.y, z1:  number  = this.z, w1:  number  = this.w;
		    var x2:  number  = q4fQuat.x, y2:  number  = q4fQuat.y, z2:  number  = q4fQuat.z, w2:  number  = q4fQuat.w;

//скалярное произведение
		    var fCos:  number  = x1*x2 + y1*y2 + z1*z2 + w1*w2;

		    if(fCos < 0 && bShortestPath){
		        fCos = -fCos;
		        x2 = -x2;
		        y2 = -y2;
		        z2 = -z2;
		        w2 = -w2;
		    }

		    var fEps:  number  = 1e-3;
		    if(abs(fCos) < 1. - fEps){
		        var fSin:  number  = sqrt(1. - fCos*fCos);
		        var fInvSin:  number  = 1./fSin;

		        var fAngle:  number  = atan2(fSin,fCos);

		        var k1:  number  = sin((1. - fA) * fAngle)*fInvSin;
		        var k2:  number  = sin(fA * fAngle)*fInvSin;

		        q4fDestination.x = x1*k1 + x2*k2;
		        q4fDestination.y = y1*k1 + y2*k2;
		        q4fDestination.z = z1*k1 + z2*k2;
		        q4fDestination.w = w1*k1 + w2*k2;
		    }
		    else{
//два кватерниона или очень близки (тогда можно делать линейную интерполяцию) 
//или два кватениона диаметрально противоположны, тогда можно интерполировать любым способом
//позже надо будет реализовать какой-нибудь, а пока тоже линейная интерполяция

		        var k1:  number  = 1 - fA;
		        var k2:  number  = fA;

		        var x:  number  = x1*k1 + x2*k2;
		        var y:  number  = y1*k1 + y2*k2;
		        var z:  number  = z1*k1 + z2*k2;
		        var w:  number  = w1*k1 + w2*k2;

// и нормализуем так-как мы сошли со сферы

		        var fLength:  number  = sqrt(x*x + y*y + z*z + w*w);
		        var fInvLen:  number  = fLength ? 1/fLength : 0;

		        q4fDestination.x = x*fInvLen;
		        q4fDestination.y = y*fInvLen;
		        q4fDestination.z = z*fInvLen;
		        q4fDestination.w = w*fInvLen;
		    }

		    return q4fDestination;
		};

		static fromForwardUp(v3fForward: IVec3, v3fUp: IVec3, q4fDestination?: IQuat4): IQuat4{
			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var fForwardX:  number  = v3fForward.x, fForwardY:  number  = v3fForward.y, fForwardZ:  number  = v3fForward.z;
		    var fUpX:  number  = v3fUp.x, fUpY:  number  = v3fUp.y, fUpZ:  number  = v3fUp.z;

		    var m3fTemp: IMat3 = mat3();
		    var pTempData: Float32Array = m3fTemp.data;

		    pTempData[ 0 ] = fUpY*fForwardZ - fUpZ*fForwardY;
		    pTempData[ 3 ] = fUpX;
		    pTempData[ 6 ] = fForwardX;

		    pTempData[ 1 ] = fUpZ*fForwardX - fUpX*fForwardZ;
		    pTempData[ 4 ] = fUpY;
		    pTempData[ 7 ] = fForwardY;

		    pTempData[ 2 ] = fUpX*fForwardY - fUpY*fForwardX;
		    pTempData[ 5 ] = fUpZ;
		    pTempData[ 8 ] = fForwardZ;

		    return m3fTemp.toQuat4(q4fDestination);
		};

		static fromAxisAngle(v3fAxis: IVec3, fAngle:  number , q4fDestination?: IQuat4): IQuat4{

			if(!isDef(q4fDestination)){
		        q4fDestination = new Quat4();
		    }

		    var x:  number  = v3fAxis.x, y:  number  = v3fAxis.y, z:  number  = v3fAxis.z;

		    var fLength:  number  = sqrt(x*x + y*y + z*z);

		    if(fLength === 0.){
		        q4fDestination.x = q4fDestination.y = q4fDestination.z = 0;
		        q4fDestination.w = 1;
		        return q4fDestination;
		    }

		    var fInvLength = 1/fLength;

		    x *= fInvLength;
		    y *= fInvLength;
		    z *= fInvLength;

		    var fSin:  number  = sin(fAngle/2);
		    var fCos:  number  = cos(fAngle/2);

		    q4fDestination.x = x * fSin;
		    q4fDestination.y = y * fSin;
		    q4fDestination.z = z * fSin;
		    q4fDestination.w = fCos;

		    return q4fDestination;
		};

		static fromYawPitchRoll(fYaw:  number , fPitch:  number , fRoll:  number ,q4fDestination?: IQuat4): IQuat4;
		static fromYawPitchRoll(v3fAngles: IVec3,q4fDestination?: IQuat4): IQuat4;
		static fromYawPitchRoll(fYaw? ,fPitch?, fRoll?, q4fDestination?): IQuat4{
			if(arguments.length <= 2){
				var v3fVec: IVec3 = arguments[0];

				fYaw = v3fVec.x;
				fPitch = v3fVec.y;
				fRoll = v3fVec.z;

				q4fDestination = arguments[1];
			}

			if(!isDef(q4fDestination)){
				q4fDestination = new Quat4();
			}

		    var fHalfYaw:  number  = fYaw * 0.5;
		    var fHalfPitch:  number  = fPitch * 0.5;
		    var fHalfRoll:  number  = fRoll * 0.5;

		    var fCos1:  number  = cos(fHalfYaw), fSin1:  number  = sin(fHalfYaw);
		    var fCos2:  number  = cos(fHalfPitch), fSin2:  number  = sin(fHalfPitch);
		    var fCos3:  number  = cos(fHalfRoll), fSin3:  number  = sin(fHalfRoll);

		    q4fDestination.x = fCos1 * fSin2 * fCos3 + fSin1 * fCos2 * fSin3;
		    q4fDestination.y = fSin1 * fCos2 * fCos3 - fCos1 * fSin2 * fSin3;
		    q4fDestination.z = fCos1 * fCos2 * fSin3 - fSin1 * fSin2 * fCos3;
		    q4fDestination.w = fCos1 * fCos2 * fCos3 + fSin1 * fSin2 * fSin3;

		    return q4fDestination;
		};

		static fromXYZ(fX:  number , fY:  number , fZ:  number , q4fDestination?: IQuat4): IQuat4;
		static fromXYZ(v3fAngles: IVec3, q4fDestination?: IQuat4): IQuat4;
		static fromXYZ(fX?, fY?, fZ?, q4fDestination?) : IQuat4{
			if(arguments.length <= 2){
//Vec3 + m4fDestination
				var v3fVec: IVec3 = arguments[0];
				return Quat4.fromYawPitchRoll(v3fVec.y,v3fVec.x,v3fVec.z,arguments[1]);
			}
			else{
//fX fY fZ m4fDestination
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];
				var fZ:  number  = arguments[2];

				return Quat4.fromYawPitchRoll(fY, fX, fZ, arguments[3]);
			}
		};

		static get stackCeil(): Quat4 { Quat4.stackPosition = Quat4.stackPosition === Quat4.stackSize - 1? 0: Quat4.stackPosition; return Quat4.stack[Quat4.stackPosition ++]; } static stackSize: number = 100; static stackPosition: number = 0; static stack: Quat4[] = (function(): Quat4[]{ var pStack: Quat4[] = new Array(Quat4.stackSize); for(var i: number = 0; i<Quat4.stackSize; i++){ pStack[i] = new Quat4(); } return pStack})();
    }
}








module akra.math {
//
// BASIC MATH AND UNIT CONVERSION CONSTANTS
//

	export var E:  number  								= < number >Math.E;
	export var LN2:  number  								= < number >Math.LN2;
	export var LOG2E:  number  							= < number >Math.LOG2E;
	export var LOG10E:  number  							= < number >Math.LOG10E;
	export var PI:  number  								= < number >Math.PI;
	export var SQRT1_2:  number  							= < number >Math.SQRT1_2;
	export var SQRT2:  number  							= < number >Math.SQRT2;
	export var LN10:  number  								= < number >Math.LN10;

	export var POSITIVE_INFINITY:  number                  = < number >Number.POSITIVE_INFINITY;
	export var NEGATIVE_INFINITY:  number                  = < number >Number.NEGATIVE_INFINITY;


	export var FLOAT_PRECISION:  number 					= < number >(3.4e-8);
	export var TWO_PI:  number 							= < number >(2.0*PI);
	export var HALF_PI:  number 							= < number >(PI/2.0);
	export var QUARTER_PI:  number 						= < number >(PI/4.0);
	export var EIGHTH_PI:  number 							= < number >(PI/8.0);
	export var PI_SQUARED:  number 						= < number >(9.86960440108935861883449099987615113531369940724079);
	export var PI_INVERSE:  number 						= < number >(0.31830988618379067153776752674502872406891929148091);
	export var PI_OVER_180:  number 						= < number >(PI/180);
	export var PI_DIV_180:  number 						= < number >(180/PI);
	export var NATURAL_LOGARITHM_BASE:  number 			= < number >(2.71828182845904523536028747135266249775724709369996);
	export var EULERS_CONSTANT:  number 					= < number >(0.57721566490153286060651);
	export var SQUARE_ROOT_2:  number 						= < number >(1.41421356237309504880168872420969807856967187537695);
	export var INVERSE_ROOT_2:  number 					= < number >(0.707106781186547524400844362105198);
	export var SQUARE_ROOT_3:  number 						= < number >(1.73205080756887729352744634150587236694280525381038);
	export var SQUARE_ROOT_5:  number 						= < number >(2.23606797749978969640917366873127623544061835961153);
	export var SQUARE_ROOT_10:  number 					= < number >(3.16227766016837933199889354443271853371955513932522);
	export var CUBE_ROOT_2:  number 						= < number >(1.25992104989487316476721060727822835057025146470151);
	export var CUBE_ROOT_3:  number 						= < number >(1.44224957030740838232163831078010958839186925349935);
	export var FOURTH_ROOT_2:  number 						= < number >(1.18920711500272106671749997056047591529297209246382);
	export var NATURAL_LOG_2:  number 						= < number >(0.69314718055994530941723212145817656807550013436026);
	export var NATURAL_LOG_3:  number 						= < number >(1.09861228866810969139524523692252570464749055782275);
	export var NATURAL_LOG_10:  number 					= < number >(2.30258509299404568401799145468436420760110148862877);
	export var NATURAL_LOG_PI:  number 					= < number >(1.14472988584940017414342735135305871164729481291531);
	export var BASE_TEN_LOG_PI:  number 					= < number >(0.49714987269413385435126828829089887365167832438044);
	export var NATURAL_LOGARITHM_BASE_INVERSE:  number 	= < number >(0.36787944117144232159552377016146086744581113103177);
	export var NATURAL_LOGARITHM_BASE_SQUARED:  number 	= < number >(7.38905609893065022723042746057500781318031557055185);
	export var GOLDEN_RATIO:  number 						= < number >((SQUARE_ROOT_5 + 1.0) / 2.0);
	export var DEGREE_RATIO:  number 						= < number >(PI_DIV_180);
	export var RADIAN_RATIO:  number 						= < number >(PI_OVER_180);
	export var GRAVITY_CONSTANT:  number  					= 9.81;
}









module akra.math {
//
// MATH AND UNIT CONVERSION FUNCTION PROTOTYPES
//

	export var abs = Math.abs;
	export var acos = Math.acos;
	export var asin = Math.asin;
	export var atan = Math.atan;
	export var atan2 = Math.atan2;
	export var exp = Math.exp;
	export var min = Math.min;
	export var random = Math.random;
	export var sqrt = Math.sqrt;
	export var log = Math.log;
	export var round = Math.round;
	export var floor = Math.floor;
	export var ceil = Math.ceil;
	export var sin = Math.sin;
	export var cos = Math.cos;
	export var tan = Math.tan;
	export var pow = Math.pow;
	export var max = Math.max;

/*	
	-----------------------------------------------------------------
	    
		Floating Point Macros
	    
	-----------------------------------------------------------------
	*/

// reinterpret a float as an int32
/** @inline */

	export var fpBits = (f:  number ):  number  => floor(f);

// reinterpret an int32 as a float
/** @inline */

	export var intBits = (i:  number ):  number  => < number > i;

// return 0 or -1 based on the sign of the float
/** @inline */

	export var fpSign = (f:  number ) => (f >> 31);

// extract the 8 bits of exponent as a signed integer
// by masking out this bits, shifting down by 23,
// and subtracting the bias value of 127
/** @inline */

	export var fpExponent = (f:  number ):  number  => (((fpBits(f) & 0x7fffffff) >> 23) - 127);

// return 0 or -1 based on the sign of the exponent
/** @inline */

	export var fpExponentSign = (f:  number ):  number  => (fpExponent(f) >> 31) ;

// get the 23 bits of mantissa without the implied bit
/** @inline */

	export var fpPureMantissa = (f:  number ):  number  => ((fpBits(f) & 0x7fffff));

// get the 23 bits of mantissa with the implied bit replaced
/** @inline */

	export var fpMantissa = (f:  number ):  number  => (fpPureMantissa(f) | (1 << 23));

	export var fpOneBits = 0x3F800000;

// flipSign is a helper Macro to
// invert the sign of i if flip equals -1, 
// if flip equals 0, it does nothing
//export var flipSign = (i, flip) ((i^ flip) - flip)
/** @inline */

	export var flipSign = (i: number, flip: number):  number  => ((flip == -1) ? -i : i);

/**
	 * Абсолютное значение числа
	 */

	export var absoluteValue = abs;
/**
	 * Pow
	 */

	export var raiseToPower = pow;
/**
	 * Число положительно?
	 */

	export var isPositive = (a: number) => (a >= 0);
/**
	 * Число отрицательно?
	 */

	export var isNegative = (a: number) => (a < 0);
/**
	 * Число одного знака?
	 */

	export var sameSigns = (a: number, b: number): bool => (isNegative(a) == isNegative(b));
/**
	 * Копировать знак
	 */

	export var copySign = (a: number, b: number): number => (isNegative(b) ? -absoluteValue(a) : absoluteValue(a));
/**
	 * Растояние между а и b меньше epsilon?
	 */

	export var deltaRangeTest = (a: number, b: number, epsilon: number = 0.0000001): bool => ((absoluteValue(a - b) < epsilon) ? true : false);

/**
	 * Ограничивает value интервалом [low,high]
	 */

	export var clamp = (value: number, low: number, high: number): number => max(low, min(value, high));
/**
	 * Ограничивает value интервалом [0,+Infinity]
	 */

	export var clampPositive = (value: number): number => (value < 0 ? 0 : value);
/**
	 * Ограничивает value интервалом [-Infinity,0]
	 */

	export var clampNegative = (value: number): number => (value > 0 ? 0 : value);
/**
	 * Ограничивает value интервалом [-1,1]
	 */

	export var clampUnitSize = (value: number): number => clamp(value, -1, 1);


/**
	 * Номер с права начиная от нуля, самого левого установленного бита
	 */

	export var highestBitSet = (value: number):  number  => value == 0 ? (null) : (value < 0 ? 31 : ((log(value) / LN2) << 0));
/**
	 * Номер с права начиная от нуля, самого правого установленного бита
	 */

	export var lowestBitSet = (value:  number ):  number  => {
		var temp:  number ;

	    if (value == 0) {
	        return null;
	    }

	    for (temp = 0; temp <= 31; temp++) {
	        if (value & (1 << temp)) {
	            return temp;
	        }
	    }

	    return null;
	}

/**
	 * Является ли число степенью двойки
	 */

	export var isPowerOfTwo = (value:  number ): bool => (value > 0 && highestBitSet(value) == lowestBitSet(value));
/**
	 * Округление до числа наиболее близкого к степени двойки
	 */

	export var nearestPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
        	return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);
	    var roundingTest:  number  = value & (1 << (highestBit - 1));

	    if (roundingTest != 0) {
	        ++ highestBit;
	    }

	    return 1 << highestBit;
	}

/**
	 * Округление до следующего числа являющегося к степени двойки
	 */

	export var ceilingPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
	        return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);
	    var mask:  number  = value & ((1 << highestBit) - 1);
	    highestBit += mask && 1;
	    return 1 << highestBit;
	}
/**
	 * Округление до предыдущего числа являющегося к степени двойки
	 */

	export var floorPowerOfTwo = (value:  number ):  number  => {
		if (value <= 1) {
        	return 1;
	    }

	    var highestBit:  number  = highestBitSet(value);

	    return 1 << highestBit;
	}

/**
	 * Деление по модулю
	 */

	export var modulus = (e:  number , divisor:  number ):  number  => (e - floor(e / divisor) * divisor);
/**
	 * 
	 */

	export var mod = modulus;

/**
	 * Вырвнивание числа на alignment вверх
	 */

	export var alignUp = (value:  number , alignment:  number ):  number  => {
		var iRemainder:  number  = modulus(value, alignment);
	    if (iRemainder == 0) {
	        return(value);
	    }

	    return(value + (alignment - iRemainder));
	}


/**
	 * Вырвнивание числа на alignment вниз
	 */

	export var alignDown = (value:  number , alignment:  number ):  number  => {
		var remainder:  number  = modulus(value, alignment);
	    if (remainder == 0) {
	        return(value);
	    }

	    return(value - remainder);
	}

/**
	 * пнвертировать число
	 */

	export var inverse = (a: number): number => 1. / a;
/**
	 * log base 2
	 */

	export var log2 = (f:  number ):  number  => log(f) / LN2;
/**
	 * Округлени числа с определенной точностью, где округляется до значащих чисел как 1/(2^precision)
	 */

	export var trimFloat = (f:  number , precision:  number ):  number  => f;

/**
	 * Перевод дробного в целое с усеением
	 */

	export var realToInt32_chop = (a:  number ):  number  => round(a);
/**
	 * Перевод дробного в целое до меньшего
	 */

	export var realToInt32_floor = (a:  number ):  number  => floor(a);
/**
	 * Перевод дробного в целое до большего
	 */

	export var realToInt32_ceil = (a:  number ):  number  => ceil(a);

/**
	 * Наибольший общий делитель
	 */

	export var nod = (n:  number , m:  number ):  number  => {
		var p:  number  = n % m;

		while (p != 0) {
			n = m
			m = p
			p = n % m
		}

		return m;
	}
/**
	 * Наименьшее общее кратное
	 */

	export var nok = (n:  number , m:  number ):  number  => abs(n * m) / nod(n , m);
/**
	 * Greatest common devider
	 */

	export var gcd = nod;
/**
	 * Least common multiple
	 */

	export var lcm = nok;

// var pMat3Stack = new Array(100);
// var iMat3StackIndex = 0;

	export var isRealEqual = (a:  number , b:  number , tolerance:  number  = 1.19209e-007): bool => {
        if (math.abs(b - a) <= tolerance)
            return true;
        else
            return false;
    }

    export function calcPOTtextureSize (nPixels:  number ):  number [] {
	    var w:  number , h:  number ;
	    var n:  number  = nPixels;


	    w = Math.ceil(Math.log(n) / Math.LN2 / 2.0);
	    h = Math.ceil(Math.log(n / Math.pow(2, w)) / Math.LN2);
	    w = Math.pow(2, w);
	    h = Math.pow(2, h);
	    n = w * h;
	    return [w, h, n];
	}
}



module akra.math {

    export function vec2(): IVec2;
    export function vec2(fValue:  number ): IVec2;
    export function vec2(v2fVec: IVec2): IVec2;
    export function vec2(pArray:  number []): IVec2;
    export function vec2(fValue1:  number , fValue2:  number ): IVec2;
    export function vec2(fValue1?, fValue2?): IVec2{
        var nArgumentsLength:  number  = arguments.length;
        var v2fVec: IVec2 = Vec2.stack[Vec2.stackPosition ++];

        if(Vec2.stackPosition == Vec2.stackSize){
            Vec2.stackPosition = 0;
        }

        switch(nArgumentsLength){
            case 1:
                v2fVec.set(arguments[0]);
                break;
            case 2:
                v2fVec.set(arguments[0], arguments[1]);
                break;
            default:
                v2fVec.x = v2fVec.y = 0.;
                break;
        }

        return v2fVec;
    };

    export function vec3(): IVec3;
    export function vec3(fValue:  number ): IVec3;
    export function vec3(v3fVec: IVec3): IVec3;
    export function vec3(pArray:  number []): IVec3;
    export function vec3(fValue:  number , v2fVec: IVec2): IVec3;
    export function vec3(v2fVec: IVec2, fValue:  number ): IVec3;
    export function vec3(fValue1:  number , fValue2:  number , fValue3:  number ): IVec3;
    export function vec3(fValue1?, fValue2?, fValue3?): IVec3{
        var nArgumentsLength:  number  = arguments.length;
        var v3fVec: IVec3 = Vec3.stack[Vec3.stackPosition ++];

        if(Vec3.stackPosition == Vec3.stackSize){
            Vec3.stackPosition = 0;
        }

        switch(nArgumentsLength){
            case 1:
                v3fVec.set(arguments[0]);
                break;
            case 2:
                v3fVec.set(arguments[0], arguments[1]);
                break;
            case 3:
                v3fVec.set(arguments[0], arguments[1], arguments[2]);
                break;
            default:
                v3fVec.x = v3fVec.y = v3fVec.z = 0.;
                break;
        }

        return v3fVec;
    };

    export function vec4(): IVec4;
    export function vec4(fValue:  number ): IVec4;
    export function vec4(v4fVec: IVec4): IVec4;
    export function vec4(pArray:  number []): IVec4;
    export function vec4(fValue:  number , v3fVec: IVec3): IVec4;
    export function vec4(v2fVec1: IVec2, v2fVec2: IVec2): IVec4;
    export function vec4(v3fVec: IVec3, fValue:  number ): IVec4;
    export function vec4(fValue1:  number , fValue2:  number , v2fVec: IVec2): IVec4;
    export function vec4(fValue1:  number , v2fVec: IVec2, fValue2:  number ): IVec4;
    export function vec4(v2fVec: IVec2 ,fValue1:  number , fValue2:  number ): IVec4;
    export function vec4(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ): IVec4;
    export function vec4(fValue1?, fValue2?, fValue3?, fValue4?): IVec4{
        var nArgumentsLength:  number  = arguments.length;
        var v4fVec: IVec4 = Vec4.stack[Vec4.stackPosition ++];

        if(Vec4.stackPosition == Vec4.stackSize){
            Vec4.stackPosition = 0;
        }

        switch(nArgumentsLength){
            case 1:
                v4fVec.set(arguments[0]);
                break;
            case 2:
                v4fVec.set(arguments[0],arguments[1]);
                break;
            case 3:
                v4fVec.set(arguments[0],arguments[1], arguments[2]);
                break;
            case 4:
                v4fVec.set(arguments[0],arguments[1], arguments[2], arguments[3]);
                break;
            default:
                v4fVec.x = v4fVec.y = v4fVec.z = v4fVec.w = 0.;
                break;
        }

        return v4fVec;
    };

    export function quat4(): IQuat4;
	export function quat4(q4fQuat: IQuat4): IQuat4;
	export function quat4(pArray:  number []): IQuat4;
	export function quat4(fValue:  number , fW:  number ): IQuat4;
	export function quat4(v3fValue: IVec3, fW:  number ): IQuat4;
	export function quat4(fX:  number , fY:  number , fZ:  number , fW:  number ): IQuat4;
	export function quat4(fX?, fY?, fZ?, fW?): IQuat4{
		var nArgumentsLength:  number  = arguments.length;
		var q4fQuat: IQuat4 = Quat4.stack[Quat4.stackPosition ++];

		if(Quat4.stackPosition == Quat4.stackSize){
            Quat4.stackPosition = 0;
		}

		switch(nArgumentsLength){
			case 1:
				q4fQuat.set(arguments[0]);
				break;
			case 2:
				q4fQuat.set(arguments[0], arguments[1]);
				break;
			case 4:
				q4fQuat.set(arguments[0], arguments[1], arguments[2], arguments[3]);
				break;
			default:
				q4fQuat.x = q4fQuat.y = q4fQuat.z = 0.;
				q4fQuat.w = 1.;
				break;
		}

		return q4fQuat;
	};

	export function mat3(): IMat3;
	export function mat3(fValue:  number ): IMat3;
	export function mat3(v3fVec: IVec3): IMat3;
	export function mat3(m3fMat: IMat3): IMat3;
	export function mat3(m4fMat: IMat4): IMat3;
	export function mat3(pArray:  number []): IMat3;
	export function mat3(fValue1:  number , fValue2:  number , fValue3:  number ): IMat3;
	export function mat3(v3fVec1: IVec3, v3fVec2: IVec3, v3fVec3: IVec3): IMat3;
	export function mat3(pArray1:  number [], pArray2:  number [], pArray3:  number []): IMat3;
	export function mat3(fValue1:  number , fValue2:  number , fValue3:  number ,
				fValue4:  number , fValue5:  number , fValue6:  number ,
				fValue7:  number , fValue8:  number , fValue9:  number ): IMat3;
	export function mat3(fValue1?, fValue2?, fValue3?,
				fValue4?, fValue5?, fValue6?,
				fValue7?, fValue8?, fValue9?): IMat3{

		var nArgumentsLength:  number  = arguments.length;
		var m3fMat: IMat3 = Mat3.stack[Mat3.stackPosition ++];

        if(Mat3.stackPosition == Mat3.stackSize){
            Mat3.stackPosition = 0;
		}

		switch(nArgumentsLength){
			case 1:
				m3fMat.set(arguments[0]);
				break;
			case 3:
				m3fMat.set(arguments[0], arguments[1], arguments[2]);
				break;
			case 9:
				m3fMat.set(arguments[0], arguments[1], arguments[2],
						 arguments[3], arguments[4], arguments[5],
						 arguments[6], arguments[7], arguments[8]);
				break;
			default:
				m3fMat.set(0.);
				break;
		}

		return m3fMat;
	};

	export function mat4(): IMat4;
	export function mat4(fValue:  number ): IMat4;
	export function mat4(v4fVec: IVec4): IMat4;
	export function mat4(m3fMat: IMat3, v3fTranslation?: IVec3): IMat4;
	export function mat4(m4fMat: IMat4): IMat4;
	export function mat4(pArray:  number []): IMat4;
	export function mat4(pArray: Float32Array, bFlag: bool): IMat4;
	export function mat4(fValue1:  number , fValue2:  number ,
			fValue3:  number , fValue4:  number ): IMat4;
	export function mat4(v4fVec1: IVec4, v4fVec2: IVec4,
			v4fVec3: IVec4, v4fVec4: IVec4): IMat4;
	export function mat4(pArray1:  number [], pArray2:  number [],
			pArray3:  number [], pArray4:  number []): IMat4;
	export function mat4(fValue1:  number , fValue2:  number , fValue3:  number , fValue4:  number ,
			fValue5:  number , fValue6:  number , fValue7:  number , fValue8:  number ,
			fValue9:  number , fValue10:  number , fValue11:  number , fValue12:  number ,
			fValue13:  number , fValue14:  number , fValue15:  number , fValue16:  number ): IMat4;
	export function mat4(fValue1?, fValue2?, fValue3?, fValue4?,
				fValue5?, fValue6?, fValue7?, fValue8?,
				fValue9?, fValue10?, fValue11?, fValue12?,
				fValue13?, fValue14?, fValue15?, fValue16?): IMat4{

		var nArgumentsLength:  number  = arguments.length;
		var m4fMat: IMat4 = Mat4.stack[Mat4.stackPosition ++];

        if(Mat4.stackPosition == Mat4.stackSize){
            Mat4.stackPosition = 0;
		}

		if(nArgumentsLength === 2){
			if(isBoolean(arguments[1])){
				if(arguments[1]){
					m4fMat.data = arguments[0];
				}
				else{
					m4fMat.set(arguments[0]);
				}
			}
			else{
				m4fMat.set(arguments[0], arguments[1]);
			}
		}
		else{
			switch(nArgumentsLength){
				case 1:
					if(arguments[0] instanceof Mat3){
						m4fMat.set(arguments[0],vec3(0.));
					}
					else{
						m4fMat.set(arguments[0]);
					}
					break;
				case 4:
					m4fMat.set(arguments[0],arguments[1],arguments[2],arguments[3]);
					break;
				case 16:
					m4fMat.set(arguments[0], arguments[1], arguments[2], arguments[3],
						 arguments[4], arguments[5], arguments[6], arguments[7],
						 arguments[8], arguments[9], arguments[10], arguments[11],
						 arguments[12], arguments[13], arguments[14], arguments[15]);
					 break;
				 default:
				 	break;
			}
		}

		return m4fMat;
	};

}

module akra {
	export var Vec2 = math.Vec2;
	export var Vec3 = math.Vec3;
	export var Vec4 = math.Vec4;

	export var Mat3 = math.Mat3;
	export var Mat4 = math.Mat4;
	export var Quat4 = math.Quat4;

	export var vec2 = math.vec2;
	export var vec3 = math.vec3;
	export var vec4 = math.vec4;
	export var quat4 = math.quat4;
	export var mat3 = math.mat3;
	export var mat4 = math.mat4;
}






































module akra.geometry {
	export class Box implements IBox {
		left:  number ;
		top:  number ;
		front:  number ;
		right:  number ;
		bottom:  number ;
		back:  number ;

		inline get width():  number  {
			return this.right - this.left;
		}

		inline get height():  number  {
			return this.bottom - this.top;
		}

		inline get depth():  number  {
			return this.back - this.front;
		}

		constructor ();
		constructor (pExtents: IBox);
		constructor (iLeft:  number , iTop:  number , iRight:  number , iBottom:  number );
		constructor (iLeft:  number , iTop:  number , iFront:  number , iRight:  number , iBottom:  number , iBack:  number );
		constructor (l:  number  = 0, t:  number  = 0, ff:  number  = 0, r:  number  = 1, b:  number  = 1, bb:  number  = 1) {
			switch (arguments.length) {
				case 1:
					this.left 	= arguments[0].left;
					this.top 	= arguments[0].top;
					this.front 	= arguments[0].front;

					this.right 	= arguments[0].right;
					this.bottom = arguments[0].bottom;
					this.back 	= arguments[0].back;
					break;
				case 3:
				case 6:
					this.left 	= l;
					this.top 	= t;
					this.front 	= ff;

					this.right 	= r;
					this.bottom = b;
					this.back 	= bb;
					break;
				case 4:
					this.left 	= l;
					this.top 	= t;
					this.right 	= ff;
					this.bottom = r;

					this.back 	= 1;
					this.front 	= 0;
					break;
				case 5:
					logger.setSourceLocation( "geometry/Box.ts" , 62 ); logger.error("invalid number of arguments"); ;
			}

			logger.setSourceLocation( "geometry/Box.ts" , 65 ); logger.assert(this.right >= this.left && this.bottom >= this.top && this.back >= this.front); ;
		}

		contains(pDest: IBox): bool {
			return (pDest.left >= this.left && pDest.top >= this.top && pDest.front >= this.front &&
	    		pDest.right <= this.right && pDest.bottom <= this.bottom && pDest.back <= this.back);
		}
	}
}







module akra.pixelUtil {
	export class PixelBox extends geometry.Box implements IPixelBox {
		data: Uint8Array;
		format: EPixelFormats;
		rowPitch:  number ;
		slicePitch:  number ;

		constructor();
		constructor(iWidth:  number , iHeight:  number , iDepth:  number , ePixelFormat: EPixelFormats, pPixelData: any = null);
		constructor (pExtents: IBox, ePixelFormat: EPixelFormats, pPixelData: Uint8Array = null);
		constructor (iWidth?: any, iHeight?: any, iDepth?: any, ePixelFormat?: any, pPixelData: Uint8Array = null) {
			if (arguments.length === 0) {
				return;
			}

			if (arguments.length >= 4) {
				super(0, 0, 0, < number >iWidth, < number >iHeight, < number >iDepth);
				this.data = isDef(arguments[4]) ? (<Uint8Array>arguments[4]) : null;
				this.format = <EPixelFormats>arguments[3];
			}
			else {
				super(<IBox>arguments[0]);
				this.data = <Uint8Array>arguments[2];
				this.format = <EPixelFormats>arguments[1];
			}

			this.setConsecutive();
		}

		setConsecutive(): void {
			this.rowPitch = this.width;
			this.slicePitch = this.width * this.height;
		}

		getRowSkip():  number  { return this.rowPitch - this.width; }
		getSliceSkip():  number  { return this.slicePitch - (this.height * this.rowPitch); }

		isConsecutive(): bool {
			return this.rowPitch == this.width && this.slicePitch == this.width * this.height;
		}

		getConsecutiveSize():  number  {
			return pixelUtil.getMemorySize(this.width, this.height, this.depth, this.format);
		}

		getSubBox(pDest: IBox): PixelBox {
			if(pixelUtil.isCompressed(this.format)) {
				if(pDest.left == this.left && pDest.top == this.top && pDest.front == this.front &&
				   pDest.right == this.right && pDest.bottom == this.bottom && pDest.back == this.back) {
// Entire buffer is being queried
					return this;
				}

				logger.setSourceLocation( "PixelBox.ts" , 65 ); logger.error("Cannot return subvolume of compressed PixelBuffer", "PixelBox::getSubVolume"); ;
			}

			if(!this.contains(pDest))
			{
				logger.setSourceLocation( "PixelBox.ts" , 70 ); logger.error("Bounds out of range", "PixelBox::getSubVolume"); ;
			}

			var elemSize:  number  = pixelUtil.getNumElemBytes(this.format);
// Calculate new data origin
// Notice how we do not propagate left/top/front from the incoming box, since
// the returned pointer is already offset
			var rval: PixelBox = new PixelBox(pDest.width, pDest.height, pDest.depth, this.format,
				(<Uint8Array> this.data).subarray(((pDest.left - this.left) * elemSize)
				+ ((pDest.top - this.top) * this.rowPitch * elemSize)
				+ ((pDest.front - this.front) * this.slicePitch * elemSize))
			);

			rval.rowPitch = this.rowPitch;
			rval.slicePitch = this.slicePitch;
			rval.format = this.format;

			return rval;
		}

		getColorAt(x:  number , y:  number , z?:  number ): IColor {
			var cv: IColor = new Color;

	        var pixelSize:  number  = pixelUtil.getNumElemBytes(this.format);
	        var pixelOffset:  number  = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);

	        pixelUtil.unpackColour(cv, this.format, this.data.subarray(pixelOffset));

	        return cv;
		}

		setColorAt(pColor: IColor, x:  number , y:  number , z?:  number ): void {
			var pixelSize:  number  = pixelUtil.getNumElemBytes(this.format);
	        var pixelOffset:  number  = pixelSize * (z * this.slicePitch + y * this.rowPitch + x);
	        pixelUtil.packColour(pColor, this.format, this.data.subarray(pixelOffset));
		}

		scale(pDest: IPixelBox, eFilter: EFilters = EFilters.BILINEAR): bool {
			return false;
		}
	}

}










module akra {

	export interface IPixelFormatDescription {
/* Name of the format, as in the enum */

        name: string;
/* Number of bytes one element (colour value) takes. */

        elemBytes:  number ;
/* Pixel format flags, see enum PixelFormatFlags for the bit field
        * definitions
        */

        flags:  number ;
/** Component type
         */

        componentType: EPixelComponentTypes;
/** Component count
         */

        componentCount:  number ;
/* Number of bits for red(or luminance), green, blue, alpha
        */

        rbits:  number ;
        gbits:  number ;
        bbits:  number ;
/*, ibits, dbits, ... */
        abits:  number ;

/* Masks and shifts as used by packers/unpackers */

        rmask:  number ;
        gmask:  number ;
        bmask:  number ;
        amask:  number ;

        rshift:  number ;
        gshift:  number ;
        bshift:  number ;
        ashift:  number ;
	}


	function fillPixelFormats(pData: any[][]): IPixelFormatDescription[] {
		var pPixelFormats: IPixelFormatDescription[] = [];

		for (var i:  number  = 0; i < pData.length; ++ i) {
			var pEl: any[] = pData[i];
			pPixelFormats.push({
					name: 			<string>pEl[0],
					elemBytes: 		< number >	pEl[1],
					flags: 			< number >	pEl[2],
					componentType: 	<EPixelComponentTypes>pEl[3],
					componentCount: < number >	pEl[4],

					rbits: < number >pEl[5],
					gbits: < number >pEl[6],
					bbits: < number >pEl[7],
					abits: < number >pEl[8],

					rmask: < number >pEl[9],
					gmask: < number >pEl[10],
					bmask: < number >pEl[11],
					amask: < number >pEl[12],

					rshift: < number >pEl[13],
					gshift: < number >pEl[14],
					bshift: < number >pEl[15],
					ashift: < number >pEl[16]
				});
		}

		return pPixelFormats;
	}

	var pPixelFormats: IPixelFormatDescription[] = fillPixelFormats([
		["PF_UNKNOWN",
/* Bytes per element */

        0,
/* Flags */

        0,
/* Component type and count */

        EPixelComponentTypes.BYTE, 0,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//1-----------------------------------------------------------------------
        ["PF_L8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF, 0, 0, 0, 0, 0, 0, 0
        ],
//2-----------------------------------------------------------------------
        ["PF_L16",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.SHORT, 1,
/* rbits, gbits, bbits, abits */

        16, 0, 0, 0,
/* Masks and shifts */

        0xFFFF, 0, 0, 0, 0, 0, 0, 0
        ],
//3-----------------------------------------------------------------------
        ["PF_A8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 8,
/* Masks and shifts */

        0, 0, 0, 0xFF, 0, 0, 0, 0
        ],
//4-----------------------------------------------------------------------
        ["PF_A4L4",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.LUMINANCE | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        4, 0, 0, 4,
/* Masks and shifts */

        0x0F, 0, 0, 0xF0, 0, 0, 0, 4
        ],
//5-----------------------------------------------------------------------
        ["PF_BYTE_LA",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.LUMINANCE,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 8,
/* Masks and shifts */

        0,0,0,0,0,0,0,0
        ],
//6-----------------------------------------------------------------------
        ["PF_R5G6B5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        5, 6, 5, 0,
/* Masks and shifts */

        0xF800, 0x07E0, 0x001F, 0,
        11, 5, 0, 0
        ],
//7-----------------------------------------------------------------------
		["PF_B5G6R5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        5, 6, 5, 0,
/* Masks and shifts */

        0x001F, 0x07E0, 0xF800, 0,
        0, 5, 11, 0
        ],
//8-----------------------------------------------------------------------
        ["PF_A4R4G4B4",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        4, 4, 4, 4,
/* Masks and shifts */

        0x0F00, 0x00F0, 0x000F, 0xF000,
        8, 4, 0, 12
        ],
//9-----------------------------------------------------------------------
        ["PF_A1R5G5B5",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        5, 5, 5, 1,
/* Masks and shifts */

        0x7C00, 0x03E0, 0x001F, 0x8000,
        10, 5, 0, 15,
        ],
//10-----------------------------------------------------------------------
        ["PF_R8G8B8",
/* Bytes per element */

/* 24 bit integer -- special*/
        3,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0xFF0000, 0x00FF00, 0x0000FF, 0,
        16, 8, 0, 0
        ],
//11-----------------------------------------------------------------------
        ["PF_B8G8R8",
/* Bytes per element */

/* 24 bit integer -- special*/
        3,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x0000FF, 0x00FF00, 0xFF0000, 0,
        0, 8, 16, 0
        ],
//12-----------------------------------------------------------------------
        ["PF_A8R8G8B8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
        16, 8, 0, 24
        ],
//13-----------------------------------------------------------------------
        ["PF_A8B8G8R8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000,
        0, 8, 16, 24,
        ],
//14-----------------------------------------------------------------------
        ["PF_B8G8R8A8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0x0000FF00, 0x00FF0000, 0xFF000000, 0x000000FF,
        8, 16, 24, 0
        ],
//15-----------------------------------------------------------------------
        ["PF_A2R10G10B10",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        10, 10, 10, 2,
/* Masks and shifts */

        0x3FF00000, 0x000FFC00, 0x000003FF, 0xC0000000,
        20, 10, 0, 30
        ],
//16-----------------------------------------------------------------------
        ["PF_A2B10G10R10",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        10, 10, 10, 2,
/* Masks and shifts */

        0x000003FF, 0x000FFC00, 0x3FF00000, 0xC0000000,
        0, 10, 20, 30
        ],
//17-----------------------------------------------------------------------
        ["PF_DXT1",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

/* No alpha*/
        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//18-----------------------------------------------------------------------
        ["PF_DXT2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//19-----------------------------------------------------------------------
        ["PF_DXT3",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//20-----------------------------------------------------------------------
        ["PF_DXT4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//21-----------------------------------------------------------------------
        ["PF_DXT5",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//22-----------------------------------------------------------------------
        ["PF_FLOAT16_RGB",
/* Bytes per element */

        6,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 3,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//23-----------------------------------------------------------------------
        ["PF_FLOAT16_RGBA",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.FLOAT | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 4,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 16,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//24-----------------------------------------------------------------------
        ["PF_FLOAT32_RGB",
/* Bytes per element */

        12,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 3,
/* rbits, gbits, bbits, abits */

        32, 32, 32, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//25-----------------------------------------------------------------------
        ["PF_FLOAT32_RGBA",
/* Bytes per element */

        16,
/* Flags */

        EPixelFormatFlags.FLOAT | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 4,
/* rbits, gbits, bbits, abits */

        32, 32, 32, 32,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//26-----------------------------------------------------------------------
        ["PF_X8R8G8B8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000,
        16, 8, 0, 24
        ],
//27-----------------------------------------------------------------------
        ["PF_X8B8G8R8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 0,
/* Masks and shifts */

        0x000000FF, 0x0000FF00, 0x00FF0000, 0xFF000000,
        0, 8, 16, 24
        ],
//28-----------------------------------------------------------------------
        ["PF_R8G8B8A8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.HASALPHA | EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        8, 8, 8, 8,
/* Masks and shifts */

        0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF,
        24, 16, 8, 0
        ],
//29-----------------------------------------------------------------------
		["PF_FLOAT32_DEPTH",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

/* ?*/
        EPixelComponentTypes.FLOAT32, 1,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//30-----------------------------------------------------------------------
		["PF_SHORT_RGBA",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.SHORT, 4,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 16,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//31-----------------------------------------------------------------------
        ["PF_R3G3B2",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        3, 3, 2, 0,
/* Masks and shifts */

        0xE0, 0x1C, 0x03, 0,
        5, 2, 0, 0
        ],
//32-----------------------------------------------------------------------
        ["PF_FLOAT16_R",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 1,
/* rbits, gbits, bbits, abits */

        16, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//33-----------------------------------------------------------------------
        ["PF_FLOAT32_R",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 1,
/* rbits, gbits, bbits, abits */

        32, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//34-----------------------------------------------------------------------
        ["PF_SHORT_GR",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.SHORT, 2,
/* rbits, gbits, bbits, abits */

        16, 16, 0, 0,
/* Masks and shifts */

        0x0000FFFF, 0xFFFF0000, 0, 0,
		0, 16, 0, 0
        ],
//35-----------------------------------------------------------------------
        ["PF_FLOAT16_GR",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT16, 2,
/* rbits, gbits, bbits, abits */

        16, 16, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//36-----------------------------------------------------------------------
        ["PF_FLOAT32_GR",
/* Bytes per element */

        8,
/* Flags */

        EPixelFormatFlags.FLOAT,
/* Component type and count */

        EPixelComponentTypes.FLOAT32, 2,
/* rbits, gbits, bbits, abits */

        32, 32, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//37-----------------------------------------------------------------------
		["PF_SHORT_RGB",
/* Bytes per element */

        6,
/* Flags */

        0,
/* Component type and count */

        EPixelComponentTypes.SHORT, 3,
/* rbits, gbits, bbits, abits */

        16, 16, 16, 0,
/* Masks and shifts */

		0, 0, 0, 0, 0, 0, 0, 0
        ],
//38-----------------------------------------------------------------------
		["PF_PVRTC_RGB2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//39-----------------------------------------------------------------------
		["PF_PVRTC_RGBA2",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//40-----------------------------------------------------------------------
		["PF_PVRTC_RGB4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED,
/* Component type and count */

        EPixelComponentTypes.BYTE, 3,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//41-----------------------------------------------------------------------
		["PF_PVRTC_RGBA4",
/* Bytes per element */

        0,
/* Flags */

        EPixelFormatFlags.COMPRESSED | EPixelFormatFlags.HASALPHA,
/* Component type and count */

        EPixelComponentTypes.BYTE, 4,
/* rbits, gbits, bbits, abits */

        0, 0, 0, 0,
/* Masks and shifts */

        0, 0, 0, 0, 0, 0, 0, 0
        ],
//42-----------------------------------------------------------------------
        ["PF_R8",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF0000, 0, 0, 0,
        0, 0, 0, 0
        ],
//43-----------------------------------------------------------------------
        ["PF_RG8",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.NATIVEENDIAN,
/* Component type and count */

        EPixelComponentTypes.BYTE, 2,
/* rbits, gbits, bbits, abits */

        8, 8, 0, 0,
/* Masks and shifts */

        0xFF0000, 0x00FF00, 0, 0,
        8, 0, 0, 0
        ],
//44-----------------------------------------------------------------------
        ["PF_DEPTH_BYTE",
/* Bytes per element */

        1,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

        EPixelComponentTypes.BYTE, 1,
/* rbits, gbits, bbits, abits */

        8, 0, 0, 0,
/* Masks and shifts */

        0xFF, 0, 0, 0, 0, 0, 0, 0
        ],
//45-----------------------------------------------------------------------    
        ["PF_DEPTH_SHORT",
/* Bytes per element */

        2,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

        EPixelComponentTypes.SHORT, 1,
/* rbits, gbits, bbits, abits */

        16, 0, 0, 0,
/* Masks and shifts */

        0xFFFF, 0, 0, 0, 0, 0, 0, 0
        ],
//46-----------------------------------------------------------------------    
        ["PF_DEPTH_INT",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.DEPTH,
/* Component type and count */

        EPixelComponentTypes.INT, 1,
/* rbits, gbits, bbits, abits */

        32, 0, 0, 0,
/* Masks and shifts */

        0xFFFFFFFF, 0, 0, 0, 0, 0, 0, 0
        ],
//47-----------------------------------------------------------------------   
        ["PF_DEPTH24STENCIL8",
/* Bytes per element */

        4,
/* Flags */

        EPixelFormatFlags.DEPTH|EPixelFormatFlags.STENCIL,
/* Component type and count */

        EPixelComponentTypes.INT, 1,
/* rbits, gbits, bbits, abits */

        24, 8, 0, 0,
/* Masks and shifts */

        0x00FFFFFF, 0xFF000000, 0, 0,
        0, 24, 0, 0
        ],
	]);

    var _pColorValue: IColorValue = {r: 0., g: 0., b: 0., a: 1.};

	export module pixelUtil {
        export inline function getDescriptionFor(eFmt: EPixelFormats): IPixelFormatDescription {
            var ord:  number  = < number >eFmt;
            logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 736 ); logger.assert(ord>=0 && ord<EPixelFormats.TOTAL,"getDescriptionFor:"+ord); ;

            return pPixelFormats[ord];
        }

/** Returns the size in bytes of an element of the given pixel format.
         @return
               The size in bytes of an element. See Remarks.
         @remarks
               Passing PF_UNKNOWN will result in returning a size of 0 bytes.
        */

        export inline function getNumElemBytes(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).elemBytes;
        }

/** Returns the size in bits of an element of the given pixel format.
          @return
               The size in bits of an element. See Remarks.
           @remarks
               Passing PF_UNKNOWN will result in returning a size of 0 bits.
        */

        export inline function getNumElemBits(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).elemBytes * 8;
        }



/** Returns the size in memory of a region with the given extents and pixel
			format with consecutive memory layout.
			@param width
				The width of the area
			@param height
				The height of the area
			@param depth
				The depth of the area
			@param format
				The format of the area
		  	@return
		  		The size in bytes
			@remarks
				In case that the format is non-compressed, this simply returns
				width*height*depth*PixelUtil::getNumElemBytes(format). In the compressed
				case, this does serious magic.
		*/

		export function getMemorySize(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats):  number  {
			if(isCompressed(eFormat)) {
				switch(eFormat) {
// DXT formats work by dividing the image into 4x4 blocks, then encoding each
// 4x4 block with a certain number of bytes. 
					case EPixelFormats.DXT1:
						return Math.floor((iWidth + 3) / 4) * Math.floor((iHeight + 3) / 4) * 8 * iDepth;
					case EPixelFormats.DXT2:
					case EPixelFormats.DXT3:
					case EPixelFormats.DXT4:
					case EPixelFormats.DXT5:
						return Math.floor((iWidth + 3) / 4) * Math.floor((iHeight + 3) / 4) * 16 * iDepth;

// Size calculations from the PVRTC OpenGL extension spec
// http://www.khronos.org/registry/gles/extensions/IMG/IMG_texture_compression_pvrtc.txt
// Basically, 32 bytes is the minimum texture size.  Smaller textures are padded up to 32 bytes
	                case EPixelFormats.PVRTC_RGB2:
	                case EPixelFormats.PVRTC_RGBA2:
						logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 798 ); logger.assert(iDepth == 1); ;
	                    return (math.max(< number >iWidth, 16) * math.max(< number >iHeight, 8) * 2 + 7) / 8;
	                case EPixelFormats.PVRTC_RGB4:
	                case EPixelFormats.PVRTC_RGBA4:
						logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 802 ); logger.assert(iDepth == 1); ;
	                    return (math.max(< number >iWidth, 8) * math.max(< number >iHeight, 8) * 4 + 7) / 8;
					default:
						logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 805 ); logger.error("Invalid compressed pixel format", "PixelUtil::getMemorySize"); ;
				}
			}
			else {
				return iWidth * iHeight * iDepth * getNumElemBytes(eFormat);
			}
		}

/** Returns the property flags for this pixel format
          @return
               A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED,
               PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE
          @remarks
               This replaces the separate functions for formatHasAlpha, formatIsFloat, ...
        */

        export inline function getFlags(eFormat: EPixelFormats):  number  {
        	return getDescriptionFor(eFormat).flags;
        }

/** Shortcut method to determine if the format has an alpha component */

        export inline function hasAlpha(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.HASALPHA) > 0;
        }
/** Shortcut method to determine if the format is floating point */

        export inline function isFloatingPoint(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.FLOAT) > 0;
        }
/** Shortcut method to determine if the format is compressed */

        export inline function isCompressed(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.COMPRESSED) > 0;
        }
/** Shortcut method to determine if the format is a depth format. */

        export inline function isDepth(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.DEPTH) > 0;
        }
/** Shortcut method to determine if the format is in native endian format. */

        export inline function isNativeEndian(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.NATIVEENDIAN) > 0;
        }
/** Shortcut method to determine if the format is a luminance format. */

        export inline function isLuminance(eFormat: EPixelFormats): bool {
        	return (getFlags(eFormat) & EPixelFormatFlags.LUMINANCE) > 0;
        }

/** Return wether a certain image extent is valid for this image format.
			@param width
				The width of the area
			@param height
				The height of the area
			@param depth
				The depth of the area
			@param format
				The format of the area
			@remarks For non-compressed formats, this is always true. For DXT formats,
			only sizes with a width and height multiple of 4 and depth 1 are allowed.
		*/

		export function isValidExtent(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats): bool {
			if(isCompressed(eFormat)) {
				switch(eFormat) {
					case EPixelFormats.DXT1:
					case EPixelFormats.DXT2:
					case EPixelFormats.DXT3:
					case EPixelFormats.DXT4:
					case EPixelFormats.DXT5:
						return ((iWidth&3)==0 && (iHeight&3)==0 && iDepth==1);
					default:
						return true;
				}
			}
			else
			{
				return true;
			}
		}

/** Gives the number of bits (RGBA) for a format. See remarks.          
          @remarks      For non-colour formats (dxt, depth) this returns [0,0,0,0].
        */

        export function getBitDepths(eFormat: EPixelFormats):  number [] {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rbits;
	        rgba[1] = des.gbits;
	        rgba[2] = des.bbits;
	        rgba[3] = des.abits;

	        return rgba;
        }

/** Gives the masks for the R, G, B and A component
		  @note			Only valid for native endian formats
        */

        export function getBitMasks(eFormat: EPixelFormats):  number [] {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rmask;
	        rgba[1] = des.gmask;
	        rgba[2] = des.bmask;
	        rgba[3] = des.amask;

	        return rgba;
        }

/** Gives the bit shifts for R, G, B and A component
		@note			Only valid for native endian formats
		*/

		export function getBitShifts(eFormat: EPixelFormats):  number [] {
			/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(eFormat);
        	var rgba:  number [] = [];

	        rgba[0] = des.rshift;
	        rgba[1] = des.gshift;
	        rgba[2] = des.bshift;
	        rgba[3] = des.ashift;

	        return rgba;
		}

/** Gets the name of an image format
        */

        export inline function getFormatName(eSrcFormat: EPixelFormats): string {
        	return getDescriptionFor(eSrcFormat).name;
        }

/** Returns wether the format can be packed or unpacked with the packColour()
        and unpackColour() functions. This is generally not true for compressed and
        depth formats as they are special. It can only be true for formats with a
        fixed element size.
          @return 
               true if yes, otherwise false
        */

        export function isAccessible(eSrcFormat: EPixelFormats): bool {
        	if (eSrcFormat == EPixelFormats.UNKNOWN)
	            return false;
	        var flags:  number  = getFlags(eSrcFormat);
	        return !((flags & EPixelFormatFlags.COMPRESSED) || (flags & EPixelFormatFlags.DEPTH));
        }

/** Returns the component type for a certain pixel format. Returns PCT_BYTE
            in case there is no clear component type like with compressed formats.
            This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32.
        */

        export inline function getComponentType(eFmt: EPixelFormats): EPixelComponentTypes {
        	return getDescriptionFor(eFmt).componentType;
        }

/** Returns the component count for a certain pixel format. Returns 3(no alpha) or 
            4 (has alpha) in case there is no clear component type like with compressed formats.
         */

        export inline function getComponentCount(eFmt: EPixelFormats):  number  {
        	return getDescriptionFor(eFmt).componentCount;
        }

        export inline function getComponentTypeBits(eFormat: EPixelFormats):  number  {
            var eType: EPixelComponentTypes = getComponentType(eFormat);

            switch(eType) {
/*Byte per component (8 bit fixed 0.0..1.0)*/
                case EPixelComponentTypes.BYTE:      return 8;
/*Short per component (16 bit fixed 0.0..1.0))*/
                case EPixelComponentTypes.SHORT:     return 16;
/*16 bit float per component*/
                case EPixelComponentTypes.FLOAT16:   return 16;
/*32 bit float per component*/
                case EPixelComponentTypes.FLOAT32:   return 32;
            }

            return 0;
        }

/** Gets the format from given name.
            @param  name            The string of format name
            @param  accessibleOnly  If true, non-accessible format will treat as invalid format,
                                    otherwise, all supported format are valid.
            @param  caseSensitive   Should be set true if string match should use case sensitivity.
            @return                The format match the format name, or PF_UNKNOWN if is invalid name.
        */

        export function getFormatFromName(sName: string, isAccessibleOnly: bool = false, isCaseSensitive: bool = false): EPixelFormats {
        	var tmp: string = sName;

	        if (!isCaseSensitive) {
// We are stored upper-case format names.
	            tmp = tmp.toUpperCase();
	        }

	        for (var i:  number  = 0; i < EPixelFormats.TOTAL; ++i) {
	            var ePf: EPixelFormats = <EPixelFormats>i;
	            if (!isAccessibleOnly || isAccessible(ePf)) {
	                if (tmp == getFormatName(ePf))
	                    return ePf;
	            }
	        }

	        return EPixelFormats.UNKNOWN;
        }

/** Gets the BNF expression of the pixel-formats.
            @note                   The string returned by this function is intended to be used as a BNF expression
                                    to work with Compiler2Pass.
            @param  accessibleOnly  If true, only accessible pixel format will take into account, otherwise all
                                    pixel formats list in EPixelFormats enumeration will being returned.
            @return                A string contains the BNF expression.
        */

        export function getBNFExpressionOfPixelFormats(isAccessibleOnly: bool = false): string {
// Collect format names sorted by length, it's required by BNF compiler
// that similar tokens need longer ones comes first.

	        var formatNames: Pair[] = new Pair[];
	        for (var i:  number  = 0; i < EPixelFormats.TOTAL; ++i) {
	            var ePf: EPixelFormats = <EPixelFormats>(i);
	            if (!isAccessibleOnly || isAccessible(ePf))
	            {
	                var formatName: string = getFormatName(ePf);
	                formatNames.push({first: formatName.length, second: formatName});
	            }
	        }

// Populate the BNF expression in reverse order
	        var result: string = "";
// Note: Stupid M$ VC7.1 can't dealing operator!= with FormatNameMap::const_reverse_iterator.
	        for (var j in formatNames) {
	            if (!isEmpty(result))
	                result += " | ";
	            result += "'" + formatNames[j] + "'";
	        }

	        return result;
        }

/** Returns the similar format but acoording with given bit depths.
            @param fmt      The original foamt.
            @param integerBits Preferred bit depth (pixel bits) for integer pixel format.
                            Available values: 0, 16 and 32, where 0 (the default) means as it is.
            @param floatBits Preferred bit depth (channel bits) for float pixel format.
                            Available values: 0, 16 and 32, where 0 (the default) means as it is.
            @return        The format that similar original format with bit depth according
                            with preferred bit depth, or original format if no conversion occurring.
        */

        export function getFormatForBitDepths(eFmt: EPixelFormats, iIntegerBits:  number , iFloatBits:  number ): EPixelFormats {
        	switch (iIntegerBits)
            {
	        case 16:
	            switch (eFmt) {
	            case EPixelFormats.R8G8B8:
	            case EPixelFormats.X8R8G8B8:
	                return EPixelFormats.R5G6B5;

	            case EPixelFormats.B8G8R8:
	            case EPixelFormats.X8B8G8R8:
	                return EPixelFormats.B5G6R5;

	            case EPixelFormats.A8R8G8B8:
	            case EPixelFormats.R8G8B8A8:
	            case EPixelFormats.A8B8G8R8:
	            case EPixelFormats.B8G8R8A8:
	                return EPixelFormats.A4R4G4B4;

	            case EPixelFormats.A2R10G10B10:
	            case EPixelFormats.A2B10G10R10:
	                return EPixelFormats.A1R5G5B5;

	            default:
// use original image format
	                break;
	            }
	            break;

	        case 32:
	            switch (eFmt) {
	            case EPixelFormats.R5G6B5:
	                return EPixelFormats.X8R8G8B8;

	            case EPixelFormats.B5G6R5:
	                return EPixelFormats.X8B8G8R8;

	            case EPixelFormats.A4R4G4B4:
	                return EPixelFormats.A8R8G8B8;

	            case EPixelFormats.A1R5G5B5:
	                return EPixelFormats.A2R10G10B10;

	            default:
// use original image format
	                break;
	            }
	            break;

	        default:
// use original image format
	            break;
	        }

	        switch (iFloatBits) {
	        case 16:
	            switch (eFmt) {
	            case EPixelFormats.FLOAT32_R:
	                return EPixelFormats.FLOAT16_R;

	            case EPixelFormats.FLOAT32_RGB:
	                return EPixelFormats.FLOAT16_RGB;

	            case EPixelFormats.FLOAT32_RGBA:
	                return EPixelFormats.FLOAT16_RGBA;

	            default:
// use original image format
	                break;
	            }
	            break;

	        case 32:
	            switch (eFmt) {
	            case EPixelFormats.FLOAT16_R:
	                return EPixelFormats.FLOAT32_R;

	            case EPixelFormats.FLOAT16_RGB:
	                return EPixelFormats.FLOAT32_RGB;

	            case EPixelFormats.FLOAT16_RGBA:
	                return EPixelFormats.FLOAT32_RGBA;

	            default:
// use original image format
	                break;
	            }
	            break;

	        default:
// use original image format
	            break;
	        }

	        return eFmt;
        }

/** Pack a colour value to memory
        	@param colour	The colour
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export inline function packColour(cColour: IColor, ePf: EPixelFormats,  pDest: Uint8Array): void {
        	packColourFloat(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
        }
/** Pack a colour value to memory
        	@param r,g,b,a	The four colour components, range 0x00 to 0xFF
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export function packColourUint(r:  number , g:  number , b:  number , a:  number , ePf: EPixelFormats,  pDest: Uint8Array): void {
// if (arguments.length < 4) {
// 	var cColour: IColor = arguments[0];
// 	packColour(cColour.r, cColour.g, cColour.b, cColour.a, ePf, pDest);
// 	return;
// }

        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats packing
	            var value:  number  =
	            	((bf.fixedToFixed(r, 8, des.rbits)<<des.rshift) & des.rmask) |
	                ((bf.fixedToFixed(g, 8, des.gbits)<<des.gshift) & des.gmask) |
	                ((bf.fixedToFixed(b, 8, des.bbits)<<des.bshift) & des.bmask) |
	                ((bf.fixedToFixed(a, 8, des.abits)<<des.ashift) & des.amask);
// And write to memory
	            bf.intWrite(pDest, des.elemBytes, value);
	        } else {
// Convert to float
	            packColourFloat(< number >r/255.0,< number >g/255.0,< number >b/255.0,< number >a/255.0, ePf, pDest);
	        }
        }
/** Pack a colour value to memory
        	@param r,g,b,a	The four colour components, range 0.0f to 1.0f
        					(an exception to this case exists for floating point pixel
        					formats, which don't clamp to 0.0f..1.0f)
        	@param pf		Pixelformat in which to write the colour
        	@param dest		Destination memory location
        */

        export function packColourFloat(r:  number , g:  number , b:  number , a:  number , ePf: EPixelFormats,  pDest: Uint8Array): void {
// Catch-it-all here
	        /**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Do the packing
//std::cerr << dest << " " << r << " " << g <<  " " << b << " " << a << std::endl;
	            /**@const*/var  value:  number  = ((bf.floatToFixed(r, des.rbits)<<des.rshift) & des.rmask) |
	                ((bf.floatToFixed(g, des.gbits)<<des.gshift) & des.gmask) |
	                ((bf.floatToFixed(b, des.bbits)<<des.bshift) & des.bmask) |
	                ((bf.floatToFixed(a, des.abits)<<des.ashift) & des.amask);
// And write to memory
	            bf.intWrite(pDest, des.elemBytes, value);
	        } else {
	            switch(ePf) {
	            case EPixelFormats.FLOAT32_R:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                break;
				case EPixelFormats.FLOAT32_GR:
					(new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = g;
					(new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = r;
					break;
	            case EPixelFormats.FLOAT32_RGB:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = g;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 3)) [2] = b;
	                break;
	            case EPixelFormats.FLOAT32_RGBA:
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 1)) [0] = r;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 2)) [1] = g;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 3)) [2] = b;
	                (new Float32Array(pDest.buffer, pDest.byteOffset, 4)) [3] = a;
	                break;
	            case EPixelFormats.FLOAT16_R:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                break;
				case EPixelFormats.FLOAT16_GR:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(g);
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(r);
					break;
	            case EPixelFormats.FLOAT16_RGB:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(g);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToHalf(b);
	                break;
	            case EPixelFormats.FLOAT16_RGBA:
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToHalf(r);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToHalf(g);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToHalf(b);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 4)) [3] = bf.floatToHalf(a);
	                break;
	            case EPixelFormats.SHORT_RGB:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToFixed(r, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToFixed(g, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToFixed(b, 16);
	                break;
				case EPixelFormats.SHORT_RGBA:
					(new Uint16Array(pDest.buffer, pDest.byteOffset, 1)) [0] = bf.floatToFixed(r, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 2)) [1] = bf.floatToFixed(g, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 3)) [2] = bf.floatToFixed(b, 16);
	                (new Uint16Array(pDest.buffer, pDest.byteOffset, 4)) [3] = bf.floatToFixed(a, 16);
					break;
				case EPixelFormats.BYTE_LA:
					pDest[0] = bf.floatToFixed(r, 8);
	                pDest[1] = bf.floatToFixed(a, 8);
					break;
	            default:
// Not yet supported
	                logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 1249 ); logger.error("pack to "+ getFormatName(ePf)+" not implemented", "PixelUtil::packColour");
                                             ;
	                break;
	            }
	        }
        }



/** Unpack a colour value from memory
        	@param colour	The colour is returned here
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        */

        export function unpackColour(cColour: IColor, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	unpackColourFloat(cColour, ePf, pSrc);
        }
/** Unpack a colour value from memory
        	@param r,g,b,a	The colour is returned here (as byte)
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        	@remarks 	This function returns the colour components in 8 bit precision,
        		this will lose precision when coming from PF_A2R10G10B10 or floating
        		point formats.  
        */

        export function unpackColourUint(rgba: IColorIValue, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
        	var r:  number  = 0, g:  number  = 0, b:  number  = 0, a:  number  = 0;

	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats unpacking
	            /**@const*/var  value:  number  = bf.intRead(pSrc, des.elemBytes);
	            if(des.flags & EPixelFormatFlags.LUMINANCE) {
// Luminance format -- only rbits used
	                r = g = b = < number >bf.fixedToFixed(
	                    (value & des.rmask) >> des.rshift, des.rbits, 8);
	            }
	            else {
	                r = < number >bf.fixedToFixed((value & des.rmask)>>des.rshift, des.rbits, 8);
	                g = < number >bf.fixedToFixed((value & des.gmask)>>des.gshift, des.gbits, 8);
	                b = < number >bf.fixedToFixed((value & des.bmask)>>des.bshift, des.bbits, 8);
	            }
	            if(des.flags & EPixelFormatFlags.HASALPHA) {
	                a = < number >bf.fixedToFixed((value & des.amask)>>des.ashift, des.abits, 8);
	            }
	            else {
/* No alpha, default a component to full*/
	                a = 255;
	            }

	        } else {
// Do the operation with the more generic floating point
	            var pRGBA: IColorValue = _pColorValue;
	            unpackColourFloat(pRGBA, ePf, pSrc);


	            r = bf.floatToFixed(pRGBA.r, 8);
	            g = bf.floatToFixed(pRGBA.g, 8);
	            b = bf.floatToFixed(pRGBA.b, 8);
	            a = bf.floatToFixed(pRGBA.a, 8);
	        }

	        rgba[0] = r;
	        rgba[1] = g;
	        rgba[2] = b;
	        rgba[3] = a;
        }



/** Unpack a colour value from memory
        	@param r,g,b,a	The colour is returned here (as float)
        	@param pf		Pixelformat in which to read the colour
        	@param src		Source memory location
        */

        export function unpackColourFloat(rgba: IColorValue, ePf: EPixelFormats,  pSrc: Uint8Array): void {
        	/**@const*/var  des: IPixelFormatDescription = getDescriptionFor(ePf);
        	var r:  number  = 0., g:  number  = 0., b:  number  = 0., a:  number  = 0.;

	        if(des.flags & EPixelFormatFlags.NATIVEENDIAN) {
// Shortcut for integer formats unpacking
	            /**@const*/var  value:  number  = bf.intRead(pSrc, des.elemBytes);


	            if(des.flags & EPixelFormatFlags.LUMINANCE)
                {
// Luminance format -- only rbits used
	                r = g = b = bf.fixedToFloat(
	                    (value & des.rmask)>>>des.rshift, des.rbits);
	            }
	            else {
	                r = bf.fixedToFloat((value & des.rmask) >>> des.rshift, des.rbits);
	                g = bf.fixedToFloat((value & des.gmask) >>> des.gshift, des.gbits);
	                b = bf.fixedToFloat((value & des.bmask) >>> des.bshift, des.bbits);

	            }

	            if (des.flags & EPixelFormatFlags.HASALPHA)
                {

	                a = bf.fixedToFloat((value & des.amask) >>> des.ashift, des.abits);
	            }
	            else {

/* No alpha, default a component to full*/
	                a = 1.0;
	            }


	        }
            else {
	            switch(ePf) {
	            case EPixelFormats.FLOAT32_R:
	                r = g = b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                a = 1.0;
	                break;
				case EPixelFormats.FLOAT32_GR:
					g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
					r = b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
					a = 1.0;
					break;
	            case EPixelFormats.FLOAT32_RGB:
	                r =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
	                b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3)) [2];
	                a = 1.0;
	                break;
	            case EPixelFormats.FLOAT32_RGBA:
	                r =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 1)) [0];
	                g =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 2)) [1];
	                b =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 3)) [2];
	                a =  (new Float32Array(pSrc.buffer, pSrc.byteOffset, 4)) [3];
	                break;
	            case EPixelFormats.FLOAT16_R:
	                r = g = b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                a = 1.0;
	                break;
				case EPixelFormats.FLOAT16_GR:
					g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
					r = b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1]);
					a = 1.0;
					break;
	            case EPixelFormats.FLOAT16_RGB:
	                r = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[1]);
	                b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[2]);
	                a = 1.0;
	                break;
	            case EPixelFormats.FLOAT16_RGBA:
	                r = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0]);
	                g = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1]);
	                b = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2]);
	                a = bf.halfToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4)) )[3]);
	                break;
				case EPixelFormats.SHORT_RGB:
					r = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0], 16);
	                g = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1], 16);
					b = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2], 16);
					a = 1.0;
					break;
				case EPixelFormats.SHORT_RGBA:
					r = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 1)) )[0], 16);
	                g = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 2)) )[1], 16);
					b = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 3)) )[2], 16);
					a = bf.fixedToFloat(( (new Uint16Array(pSrc.buffer, pSrc.byteOffset, 4)) )[3], 16);
					break;
				case EPixelFormats.BYTE_LA:
					r = g = b = bf.fixedToFloat((pSrc)[0], 8);
					a = bf.fixedToFloat((pSrc)[1], 8);
					break;
	            default:
// Not yet supported
	                logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 1420 ); logger.error("unpack from "+ getFormatName(ePf) +" not implemented", "PixelUtil::unpackColour");
                                               ;
	                break;
	            }
	        }

	        rgba.r = r;
	        rgba.g = g;
	        rgba.b = b;
	        rgba.a = a;

        }

/** Convert consecutive pixels from one format to another. No dithering or filtering is being done. 
         	Converting from RGB to luminance takes the R channel.  In case the source and destination format match,
         	just a copy is done.
         	@param	src			Pointer to source region
         	@param	srcFormat	Pixel format of source region
         	@param   dst			Pointer to destination region
         	@param	dstFormat	Pixel format of destination region
         */

        export function bulkPixelConversion(pSrc: Uint8Array, eSrcFormat: EPixelFormats, pDest: Uint8Array, eDstFormat: EPixelFormats, iCount:  number ): void;


/** Convert pixels from one format to another. No dithering or filtering is being done. Converting
          	from RGB to luminance takes the R channel. 
		 	@param	src			PixelBox containing the source pixels, pitches and format
		 	@param	dst			PixelBox containing the destination pixels, pitches and format
		 	@remarks The source and destination boxes must have the same
         	dimensions. In case the source and destination format match, a plain copy is done.
        */


        export function bulkPixelConversion(pSrc: IPixelBox, pDest: IPixelBox): void;

        export function bulkPixelConversion(pSrc: any, eSrcFormat: any, pDest?: any, eDstFormat?: any, iCount?:  number ): void {
        	var src: IPixelBox = null,
        		dst: IPixelBox = null;

        	if (arguments.length > 2) {
	        	src = new PixelBox(iCount, 1, 1, <EPixelFormats>eSrcFormat, <Uint8Array>pSrc);
				dst = new PixelBox(iCount, 1, 1, <EPixelFormats>eDstFormat, <Uint8Array>pDest);
			}
            else
            {
                src=pSrc;
                dst=pDest;
            }

        	logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 1467 ); logger.assert(src.width == dst.width && src.height == dst.height && src.depth == dst.depth,"Size dest and src pictures is different"); ;

// Check for compressed formats, we don't support decompression, compression or recoding
			if(isCompressed(src.format) || isCompressed(dst.format)) {
				if(src.format == dst.format) {
//_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
					dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
					return;
				}
				else {
					logger.setSourceLocation( "pixelUtil/pixelUtil.ts" , 1478 ); logger.error("This method can not be used to compress or decompress images", "PixelUtil::bulkPixelConversion");
                                       ;
				}
			}

// The easy case
	        if(src.format == dst.format) {
// Everything consecutive?
	            if(src.isConsecutive() && dst.isConsecutive())
	            {
//_memcpy(dst.data.buffer, src.data.buffer, src.getConsecutiveSize());
					dst.data.set(src.data.subarray(0, src.getConsecutiveSize()));
	                return;
	            }

	            var srcPixelSize:  number  = getNumElemBytes(src.format);
	            var dstPixelSize:  number  = getNumElemBytes(dst.format);

	            var srcptr: Uint8Array = src.data.subarray(
	                (src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
	            var dstptr: Uint8Array = dst.data.subarray(
					+ (dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);

// Calculate pitches+skips in bytes
	            var srcRowPitchBytes:  number  = src.rowPitch * srcPixelSize;
//var size_t srcRowSkipBytes = src.getRowSkip()*srcPixelSize;
	            var srcSliceSkipBytes:  number  = src.getSliceSkip() * srcPixelSize;

	            var dstRowPitchBytes:  number  = dst.rowPitch * dstPixelSize;
//var size_t dstRowSkipBytes = dst.getRowSkip()*dstPixelSize;
	            var dstSliceSkipBytes:  number  = dst.getSliceSkip() * dstPixelSize;

// Otherwise, copy per row
	            /**@const*/var  rowSize:  number  = src.width * srcPixelSize;

	            for(var z:  number  = src.front; z < src.back; z++) {
	                for(var y:  number  = src.top; y < src.bottom; y++) {
//_memcpy(dstptr.buffer, srcptr.buffer, rowSize);
						dstptr.set(srcptr.subarray(0, rowSize));

	                    srcptr = srcptr.subarray(srcRowPitchBytes);
	                    dstptr = dstptr.subarray(dstRowPitchBytes);
	                }

	                srcptr = srcptr.subarray(srcSliceSkipBytes);
	                dstptr = dstptr.subarray(dstSliceSkipBytes);
	            }

	            return;
	        }



// Converting to PF_X8R8G8B8 is exactly the same as converting to
// PF_A8R8G8B8. (same with PF_X8B8G8R8 and PF_A8B8G8R8)
			if(dst.format == EPixelFormats.X8R8G8B8 || dst.format == EPixelFormats.X8B8G8R8)
            {
// Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
// optimized conversions
				var tempdst: IPixelBox = dst;
				tempdst.format = (dst.format == EPixelFormats.X8R8G8B8) ? EPixelFormats.A8R8G8B8  :EPixelFormats.A8B8G8R8;
				bulkPixelConversion(src, tempdst);
				return;
			}


// Converting from EPixelFormats.X8R8G8B8 is exactly the same as converting from
// EPixelFormats.A8R8G8B8, given that the destination format does not have alpha.
			if((src.format == EPixelFormats.X8R8G8B8||src.format == EPixelFormats.X8B8G8R8) && !hasAlpha(dst.format)) {
// Do the same conversion, with EPixelFormats.A8R8G8B8, which has a lot of
// optimized conversions
				var tempsrc: IPixelBox = src;
				tempsrc.format = src.format == EPixelFormats.X8R8G8B8 ? EPixelFormats.A8R8G8B8 : EPixelFormats.A8B8G8R8;
				bulkPixelConversion(tempsrc, dst);
				return;
			}

	        var srcPixelSize:  number  = getNumElemBytes(src.format);
	        var dstPixelSize:  number  = getNumElemBytes(dst.format);

	        var srcptr: Uint8Array = src.data.subarray(
	            (src.left + src.top * src.rowPitch + src.front * src.slicePitch) * srcPixelSize);
	        var dstptr: Uint8Array = dst.data.subarray(
	            (dst.left + dst.top * dst.rowPitch + dst.front * dst.slicePitch) * dstPixelSize);

// Old way, not taking into account box dimensions
//uint8 *srcptr = static_cast<uint8*>(src.data), *dstptr = static_cast<uint8*>(dst.data);

// Calculate pitches+skips in bytes
	        var srcRowSkipBytes:  number  = src.getRowSkip() * srcPixelSize;
	        var srcSliceSkipBytes:  number  = src.getSliceSkip() * srcPixelSize;
	        var dstRowSkipBytes:  number  = dst.getRowSkip() * dstPixelSize;
	        var dstSliceSkipBytes:  number  = dst.getSliceSkip() * dstPixelSize;

// The brute force fallback
// var r: float = 0, g: float = 0, b: float = 0, a: float = 1;
	        var rgba = _pColorValue;
	        for(var z:  number  = src.front; z < src.back; z ++) {
	            for(var y:  number  = src.top; y < src.bottom; y ++) {
	                for(var x:  number  = src.left; x < src.right; x ++) {
	                    unpackColourFloat(rgba, src.format, srcptr);
	                    packColourFloat(rgba.r, rgba.g, rgba.b, rgba.a, dst.format, dstptr);
	                    srcptr = srcptr.subarray(srcPixelSize);
	                    dstptr = dstptr.subarray(dstPixelSize);
	                }
	                srcptr = srcptr.subarray(srcRowSkipBytes);
	                dstptr = dstptr.subarray(dstRowSkipBytes);
	            }
	            srcptr = srcptr.subarray(srcSliceSkipBytes);
	            dstptr = dstptr.subarray(dstSliceSkipBytes);
	        }
        }

        export function calculateSizeForImage(nMipLevels:  number , nFaces:  number ,
                                              iWidth:  number , iHeight:  number , iDepth:  number ,
                                              eFormat: EPixelFormats):  number  {
            var iSize:  number  = 0;
            var mip:  number  = 0;

            for(mip = 0; mip <= nMipLevels; ++mip){
                iSize += getMemorySize(iWidth, iHeight, iDepth, eFormat) * nFaces;
                if(iWidth !== 1) iWidth /= 2;
                if(iHeight !== 1) iHeight /= 2;
                if(iDepth !== 1) iDepth /= 2;
            }

            return iSize;
        }
	}
}








module akra.webgl {
	export var maxTextureSize:  number  = 0;
	export var maxCubeMapTextureSize:  number  = 0;
	export var maxViewPortSize:  number  = 0;

	export var maxTextureImageUnits:  number  = 0;
	export var maxVertexAttributes:  number  = 0;
	export var maxVertexTextureImageUnits:  number  = 0;
	export var maxCombinedTextureImageUnits:  number  = 0;

	export var maxColorAttachments:  number  = 1;

	export var stencilBits:  number  = 0;
	export var colorBits:  number [] = [0, 0, 0];
	export var alphaBits:  number  = 0;
	export var multisampleType:  number  = 0.;

	export var shaderVersion:  number  = 0;
	export var hasNonPowerOf2Textures: bool = false;

    var isSupported: bool = false;
	var pSupportedExtensionList: string[] = null;
// var pLoadedExtensionList: Object = null;

    function makeDebugContext(pWebGLContext: WebGLRenderingContext): WebGLRenderingContext {
        if (isDef((<any>window).WebGLDebugUtils)) {
            pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLContext,
                (err:  number , funcName: string, args: IArguments): void => {
                    logger.setSourceLocation( "webgl/WebGL.ts" , 52 ); logger.log(("\n" + (<any>new Error).stack.split("\n").slice(1).join("\n")) ); ;
                    throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
                },
                (funcName: string, args: IArguments): void => {
                   logger.setSourceLocation( "webgl/WebGL.ts" , 56 ); logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")"); ;
                });
        }

        return pWebGLContext;
    }

    export function loadExtension(pWebGLContext: WebGLRenderingContext, sExtName: string): bool {
        var pWebGLExtentionList: Object = (<any>pWebGLContext).extentionList = (<any>pWebGLContext).extentionList || {};
        var pWebGLExtension: Object;

        if (!hasExtension(sExtName)) {
            logger.setSourceLocation( "webgl/WebGL.ts" , 68 ); logger.warning("Extension " + sExtName + " unsupported for this platform."); ;
            return false;
        }

        if (pWebGLExtension = pWebGLContext.getExtension(sExtName)) {

            if (isDefAndNotNull(pWebGLExtentionList[sExtName])) {
                logger.setSourceLocation( "webgl/WebGL.ts" , 75 ); logger.log("Extension " + sExtName + " already loaded for this context."); ;
                return true;
            }

            pWebGLExtentionList[sExtName] = pWebGLExtension;

            logger.setSourceLocation( "webgl/WebGL.ts" , 81 ); logger.log("loaded WebGL extension: ", sExtName); ;

            for (var j in pWebGLExtension) {
                if (isFunction(pWebGLExtension[j])) {
//debug_print("created func WebGLRenderingContext::" + j + "(...)");
                    pWebGLContext[j] = function () {
                        pWebGLContext[j] = new Function(
                            "var t = this.extentionList[" + sExtName + "];" +
                            "t." + j + ".apply(t, arguments);");
                    }

                }
                else {
//debug_print("created const WebGLRenderingContext::" + j + " = " + pWebGLExtension[j]);
                    pWebGLContext[j] = pWebGLExtension[j];
                }
            }

            return true;
        }

        logger.setSourceLocation( "webgl/WebGL.ts" , 102 ); logger.warning("cannot load extension: ", sExtName); ;
        return false;
    }

    function setupContext(pWebGLContext: WebGLRenderingContext): WebGLRenderingContext {
//test context not created yet
        if (isNull(pSupportedExtensionList)) {
            return pWebGLContext;
        }

        for (var i:  number  = 0; i < pSupportedExtensionList.length; ++ i) {
            if (!loadExtension(pWebGLContext, pSupportedExtensionList[i])) {
                pSupportedExtensionList.splice(i, 1);
            }
        }

        return pWebGLContext;
    }

    export var isEnabled = (): bool => isSupported;

    export function createContext(
            pCanvas: HTMLCanvasElement = <HTMLCanvasElement>document.createElement("canvas"),
            pOptions?: { antialias?: bool; }): WebGLRenderingContext {

    	var pWebGLContext: WebGLRenderingContext = null;

		try {
			pWebGLContext = pCanvas.getContext("webgl", pOptions) ||
				pCanvas.getContext("experimental-webgl", pOptions);
    	}
		catch (e) {}

		if (isDefAndNotNull(pWebGLContext)) {



            return setupContext(pWebGLContext);

		}

        logger.setSourceLocation( "webgl/WebGL.ts" , 143 ); logger.warning("cannot get 3d device"); ;

		return null;
    }

	(function (pWebGLContext: WebGLRenderingContext): void {
		if (!pWebGLContext) {
			return;
		}



		maxTextureSize 					= pWebGLContext.getParameter( 0x0D33 );
		maxCubeMapTextureSize 			= pWebGLContext.getParameter( 0x851C );
		maxViewPortSize 				= pWebGLContext.getParameter( 0x0D3A );

		maxTextureImageUnits 			= pWebGLContext.getParameter( 0x8872 );
		maxVertexAttributes 			= pWebGLContext.getParameter( 0x8869 );
		maxVertexTextureImageUnits 		= pWebGLContext.getParameter( 0x8B4C );
		maxCombinedTextureImageUnits 	= pWebGLContext.getParameter( 0x8B4D );

		stencilBits 					= pWebGLContext.getParameter( 0x0D57 );
		colorBits 						= [
									        pWebGLContext.getParameter( 0x0D52 ),
									        pWebGLContext.getParameter( 0x0D53 ),
									        pWebGLContext.getParameter( 0x0D54 )
	   									];

	    alphaBits 						= pWebGLContext.getParameter( 0x0D55 );
	    multisampleType 				= pWebGLContext.getParameter( 0x80AA );

	    pSupportedExtensionList 		= pWebGLContext.getSupportedExtensions();


//pSupportedExtensionList.push(WEBGL_DEBUG_SHADERS, WEBGL_DEBUG_RENDERER_INFO);

        isSupported = true;

	})(createContext());

	export function hasExtension(sExtName: string): bool {
        for (var i:  number  = 0; i < pSupportedExtensionList.length; ++ i) {
            if (pSupportedExtensionList[i].search(sExtName) != -1) {
                return true;
            }
        }

        return false;
	}

	export function getWebGLUsage(iFlags:  number ):  number  {
		if ( (((iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ) {
	        return  0x88E8 ;
	    }
	    else if ( (((iFlags) & (EHardwareBufferFlags.STREAM)) != 0) ) {
	        return  0x88E0 ;
	    }

	    return  0x88E4 ;
	}


	export function getWebGLFormat(eFormat: EPixelFormats):  number  {

        switch(eFormat)
        {
			case EPixelFormats.L8:
            case EPixelFormats.L16:
                return  0x1909 ;

            case EPixelFormats.A8:
                return  0x1906 ;

            case EPixelFormats.A4L4:
            case EPixelFormats.BYTE_LA:
                return  0x190A ;

            case EPixelFormats.R5G6B5:
                return 0;
            case EPixelFormats.B5G6R5:
                return  0x1907 ;
            case EPixelFormats.R3G3B2:
                return 0;
            case EPixelFormats.A4R4G4B4:
            case EPixelFormats.A1R5G5B5:
                return  0x1908 ;

            case EPixelFormats.R8G8B8:
                return 0;
            case EPixelFormats.B8G8R8:
                return  0x1907 ;
            case EPixelFormats.A8R8G8B8:
                return 0;
            case EPixelFormats.A8B8G8R8:
                return  0x1908 ;
            case EPixelFormats.B8G8R8A8:
            case EPixelFormats.R8G8B8A8:
            case EPixelFormats.X8R8G8B8:
                return 0;
            case EPixelFormats.X8B8G8R8:
               return  0x1908 ;

            case EPixelFormats.A2R10G10B10:
                return 0;
            case EPixelFormats.A2B10G10R10:
                return  0x1908 ;

            case EPixelFormats.DXT1:
                return  0x83F1 ;
            case EPixelFormats.DXT2:
                return 0;
            case EPixelFormats.DXT3:
                return  0x83F2 ;
            case EPixelFormats.DXT4:
                return 0;
            case EPixelFormats.DXT5:
                return  0x83F3 ;
            case EPixelFormats.FLOAT16_R:
                return 0;
            case EPixelFormats.FLOAT16_RGB:
                return  0x1907 ;
            case EPixelFormats.FLOAT16_RGBA:
                 return  0x1908 ;
            case EPixelFormats.FLOAT32_R:
                return 0;
            case EPixelFormats.FLOAT32_RGB:
                return  0x1907 ;
            case EPixelFormats.FLOAT32_RGBA:
                return  0x1908 ;
            case EPixelFormats.FLOAT16_GR:
            case EPixelFormats.FLOAT32_GR:
                return 0;

            case EPixelFormats.FLOAT32_DEPTH:
            case EPixelFormats.DEPTH32:
            case EPixelFormats.DEPTH16:
            case EPixelFormats.DEPTH8:
                return  0x1902 ;

            case EPixelFormats.DEPTH24STENCIL8:
                return  0x84F9 ;

            case EPixelFormats.SHORT_RGBA:
                return  0x1908 ;
            case EPixelFormats.SHORT_GR:
                return 0;
            case EPixelFormats.SHORT_RGB:
                return  0x1907 ;

            case EPixelFormats.PVRTC_RGB2:
                return  0x8C01
            case EPixelFormats.PVRTC_RGBA2:
                return  0x8C03
            case EPixelFormats.PVRTC_RGB4:
                return  0x8C00
            case EPixelFormats.PVRTC_RGBA4:
                return  0x8C02 ;

            case EPixelFormats.R8:
            case EPixelFormats.RG8:
                return 0;

            default:
                logger.setSourceLocation( "webgl/WebGL.ts" , 306 ); logger.warning("getWebGLFormat unknown format",eFormat); ;
                return 0;
        }

	}

    export function isWebGLFormatSupport(eFormat: EPixelFormats):bool
    {
        switch(eFormat)
        {
            case EPixelFormats.DXT1:
            case EPixelFormats.DXT3:
            case EPixelFormats.DXT5:
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" );
            case EPixelFormats.PVRTC_RGB2:
            case EPixelFormats.PVRTC_RGBA2:
            case EPixelFormats.PVRTC_RGB4:
            case EPixelFormats.PVRTC_RGBA4:
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" );
            case EPixelFormats.DEPTH32:
            case EPixelFormats.DEPTH16:
            case EPixelFormats.DEPTH24STENCIL8:
                return webgl.hasExtension( "WEBGL_depth_texture" );
            case EPixelFormats.DEPTH32:
            case EPixelFormats.DEPTH16:
            case EPixelFormats.DEPTH24STENCIL8:
                return webgl.hasExtension( "WEBGL_depth_texture" );
            case EPixelFormats.FLOAT16_RGB:
            case EPixelFormats.FLOAT16_RGBA:
                 return webgl.hasExtension( "OES_texture_half_float" );
            case EPixelFormats.FLOAT32_RGB:
            case EPixelFormats.FLOAT32_RGBA:
                 return webgl.hasExtension( "OES_texture_float" );

        }

        if(getWebGLFormat(eFormat)&&getWebGLDataType(eFormat))
        {
            switch(eFormat)
            {
                case EPixelFormats.FLOAT32_DEPTH:
                case EPixelFormats.L16:
                    return false;
            }
            return true;
        }

        return false;
    }


	export function getWebGLDataType(eFormat: EPixelFormats):  number  {
		switch(eFormat)
        {
            case EPixelFormats.L8:
                return  0x1401 ;
            case EPixelFormats.L16:
                return  0x1403 ;

            case EPixelFormats.A8:
                return  0x1401 ;

            case EPixelFormats.A4L4:
                return 0;
            case EPixelFormats.BYTE_LA:
                return  0x1401 ;

            case EPixelFormats.R5G6B5:
            case EPixelFormats.B5G6R5:
                return  0x8363 ;
            case EPixelFormats.R3G3B2:
                return 0;
            case EPixelFormats.A4R4G4B4:
                return  0x8033 ;
            case EPixelFormats.A1R5G5B5:
                return  0x8034 ;

            case EPixelFormats.R8G8B8:
            case EPixelFormats.B8G8R8:
            case EPixelFormats.A8R8G8B8:
            case EPixelFormats.A8B8G8R8:
            case EPixelFormats.B8G8R8A8:
            case EPixelFormats.R8G8B8A8:
            case EPixelFormats.X8R8G8B8:
            case EPixelFormats.X8B8G8R8:
               return  0x1401 ;

            case EPixelFormats.A2R10G10B10:
                return 0;
            case EPixelFormats.A2B10G10R10:
                return 0;

            case EPixelFormats.DXT1:
            case EPixelFormats.DXT2:
            case EPixelFormats.DXT3:
            case EPixelFormats.DXT4:
            case EPixelFormats.DXT5:
                return 0;

            case EPixelFormats.FLOAT16_R:
            case EPixelFormats.FLOAT16_RGB:
            case EPixelFormats.FLOAT16_RGBA:
                 return  0x8D61 ;

            case EPixelFormats.FLOAT32_R:
            case EPixelFormats.FLOAT32_RGB:
            case EPixelFormats.FLOAT32_RGBA:
            case EPixelFormats.FLOAT16_GR:
            case EPixelFormats.FLOAT32_GR:
                return  0x1406 ;

            case EPixelFormats.FLOAT32_DEPTH:
                return  0x1406 ;

            case EPixelFormats.DEPTH8:
                return  0x1401 ;
            case EPixelFormats.DEPTH16:
                return  0x1403 ;
            case EPixelFormats.DEPTH32:
                return  0x1405 ;
            case EPixelFormats.DEPTH24STENCIL8:
                return  0x8367 ;

            case EPixelFormats.SHORT_RGBA:
            case EPixelFormats.SHORT_GR:
            case EPixelFormats.SHORT_RGB:
               return  0x1403 ;

            case EPixelFormats.PVRTC_RGB2:
            case EPixelFormats.PVRTC_RGBA2:
            case EPixelFormats.PVRTC_RGB4:
            case EPixelFormats.PVRTC_RGBA4:
                return 0;

            case EPixelFormats.R8:
            case EPixelFormats.RG8:
                return  0x1401 ;

            default:
                logger.setSourceLocation( "webgl/WebGL.ts" , 445 ); logger.criticalError("getWebGLFormat unknown format"); ;
                return 0;
        }
	}



	export function getWebGLInternalFormat(eFormat: EPixelFormats):  number
    {
        if(!pixelUtil.isCompressed(eFormat))
        {
            return getWebGLFormat(eFormat);
        }
        else
        {
            switch(eFormat)
            {
                case EPixelFormats.DXT1:
                    return  0x83F1 ;
                case EPixelFormats.DXT2:
                    return 0;
                case EPixelFormats.DXT3:
                    return  0x83F2 ;
                case EPixelFormats.DXT4:
                    return 0;
                case EPixelFormats.DXT5:
                    return  0x83F3 ;
                case EPixelFormats.PVRTC_RGB2:
                    return  0x8C01
                case EPixelFormats.PVRTC_RGBA2:
                    return  0x8C03
                case EPixelFormats.PVRTC_RGB4:
                    return  0x8C00
                case EPixelFormats.PVRTC_RGBA4:
                    return  0x8C02 ;
            }
        }
    }

    export function getWebGLPrimitiveType(eType: EPrimitiveTypes):  number  {
        switch (eType) {
            case EPrimitiveTypes.POINTLIST:
                return  0x0000 ;
            case EPrimitiveTypes.LINELIST:
                return  0x0001 ;
            case EPrimitiveTypes.LINELOOP:
                return  0x0002 ;
            case EPrimitiveTypes.LINESTRIP:
                return  0x0003 ;
            case EPrimitiveTypes.TRIANGLELIST:
                return  0x0004 ;
            case EPrimitiveTypes.TRIANGLESTRIP:
                return  0x0005 ;
            case EPrimitiveTypes.TRIANGLEFAN:
                return  0x0006 ;
        }

        return  0x0000 ;
    }

//не знаю что делает эта функция
    export function getClosestWebGLInternalFormat(eFormat: EPixelFormats, isHWGamma?: bool = false):  number  {
        var iGLFormat: number  = webgl.getWebGLInternalFormat(eFormat);

        if (iGLFormat ===  0 )
        {
            if (isHWGamma) {
// TODO not supported
                return 0;
            }
            else {
                return  0x1908 ;
            }
        }
        else
        {
            return iGLFormat;
        }
    }

/**
     * Convert GL format to EPixelFormat.
     */

    export function getClosestAkraFormat(iGLFormat:  number , iGLDataType:  number ): EPixelFormats {
        switch (iGLFormat) {

            case  0x8C01 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGB2 : EPixelFormats.A8R8G8B8;
            case  0x8C03 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGBA2 : EPixelFormats.A8R8G8B8;
            case  0x8C00 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGB4 : EPixelFormats.A8R8G8B8;
            case  0x8C02 :
                return webgl.hasExtension( "WEBGL_compressed_texture_pvrtc" ) ? EPixelFormats.PVRTC_RGBA4 : EPixelFormats.A8R8G8B8;

            case  0x1909 :
                return EPixelFormats.L8;
            case  0x1906 :
                return EPixelFormats.A8;
            case  0x190A :
                return EPixelFormats.BYTE_LA;

            case  0x1907 :
                switch(iGLDataType) {
	                case  0x8363 :
	                    return EPixelFormats.B5G6R5;
	                default:
	                    return EPixelFormats.R8G8B8;
            	}
            case  0x1908 :
                switch(iGLDataType) {
	                case  0x8034 :
	                    return EPixelFormats.A1R5G5B5;
	                case  0x8033 :
	                    return EPixelFormats.A4R4G4B4;
	                default:
	                    return EPixelFormats.A8B8G8R8;
	            }

            case  0x80E1 :
                return EPixelFormats.A8B8G8R8;

            case  0x83F0 :
            case  0x83F1 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT1 : EPixelFormats.A8R8G8B8;

            case  0x83F2 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT3 : EPixelFormats.A8R8G8B8;
            case  0x83F3 :
                return webgl.hasExtension( "WEBGL_compressed_texture_s3tc" ) ? EPixelFormats.DXT5 : EPixelFormats.A8R8G8B8;

            case  0x8229 :
                return webgl.hasExtension( "EXT_texture_rg" ) ? EPixelFormats.R8 : EPixelFormats.A8R8G8B8;
            case  0x822B :
                return webgl.hasExtension( "EXT_texture_rg" ) ? EPixelFormats.RG8 : EPixelFormats.A8R8G8B8;

            default:
//TODO: not supported
                return EPixelFormats.A8R8G8B8;
        }
    }

    export function optionalPO2(iValue:  number ) :  number  {
        if (webgl.hasNonPowerOf2Textures) {
            return iValue;
        }
        else {
            return math.ceilingPowerOfTwo(< number >iValue);
        }
    }


	export function convertToWebGLformat(pSource: IPixelBox, pDest: IPixelBox): void {
// Always need to convert PF_A4R4G4B4, GL expects the colors to be in the 
// reverse order
        if (pDest.format == EPixelFormats.A4R4G4B4) {
// Convert PF_A4R4G4B4 -> PF_B4G4R4A4
// Reverse pixel order
            var iSrcPtr:  number  = (pSource.left + pSource.top * pSource.rowPitch + pSource.front * pSource.slicePitch);
            var iDstPtr:  number  = (pDest.left + pDest.top * pDest.rowPitch + pDest.front * pDest.slicePitch);
            var iSrcSliceSkip:  number  = pSource.getSliceSkip();
            var iDstSliceSkip:  number  = pDest.getSliceSkip();
            var k:  number  = pSource.right - pSource.left;
            var x:  number  = 0,
            	y:  number  = 0,
            	z:  number  = 0;

            for(z = pSource.front; z < pSource.back; z++) {
                for(y = pSource.top; y < pSource.bottom; y++) {
                    for(x = 0; x < k; x++) {
/* B*/
                        pDest[iDstPtr + x] = ((pSource[iSrcPtr + x]&0x000F)<<12) |
/* G*/
                                    		 ((pSource[iSrcPtr + x]&0x00F0)<<4)  |
/* R*/
                                    		 ((pSource[iSrcPtr + x]&0x0F00)>>4)  |
/* A*/
                                    	     ((pSource[iSrcPtr + x]&0xF000)>>12);
                    }

                    iSrcPtr += pSource.rowPitch;
                    iDstPtr += pDest.rowPitch;
                }

                iSrcPtr += iSrcSliceSkip;
                iDstPtr += iDstSliceSkip;
            }
        }
	}

	export function checkFBOAttachmentFormat(eFormat: EPixelFormats): bool {
		return false;
	}

	export function getSupportedAlternative(eFormat: EPixelFormats): EPixelFormats {
		if (checkFBOAttachmentFormat(eFormat)) {
            return eFormat;
        }

/// Find first alternative
        var pct: EPixelComponentTypes = pixelUtil.getComponentType(eFormat);

        switch (pct) {
            case EPixelComponentTypes.BYTE:
                eFormat = EPixelFormats.A8R8G8B8;
                break;
            case EPixelComponentTypes.SHORT:
                eFormat = EPixelFormats.SHORT_RGBA;
                break;
            case EPixelComponentTypes.FLOAT16:
                eFormat = EPixelFormats.FLOAT16_RGBA;
                break;
            case EPixelComponentTypes.FLOAT32:
                eFormat = EPixelFormats.FLOAT32_RGBA;
                break;
            case EPixelComponentTypes.COUNT:
            default:
                break;
        }

        if (checkFBOAttachmentFormat(eFormat)){
            return eFormat;
        }

/// If none at all, return to default
		return EPixelFormats.A8R8G8B8;
	}

}



module akra.util {
	export class ApiInfo extends Singleton implements IApiInfo {
		private bWebGL: bool = false;
		private bWebAudio: bool = false;
		private bFile: bool = false;
		private bFileSystem: bool = false;
		private bWebWorker: bool = false;
		private bTransferableObjects: bool = false;
		private bLocalStorage: bool = false;
		private bWebSocket: bool = false;
		private bGamepad: bool = false;

		inline get webGL(): bool {
			return webgl.isEnabled();
		}

		get transferableObjects(): bool {
			if (!this.bTransferableObjects) {
				this.bTransferableObjects = (this.bWebWorker && this.chechTransferableObjects() ? true : false);
			}

			return this.bTransferableObjects;
		}

		inline get file(): bool {
			return this.bFile;
		}

		inline get fileSystem(): bool {
			return this.bFileSystem;
		}

		inline get webAudio(): bool {
			return this.bWebAudio;
		}

		inline get webWorker(): bool {
			return this.bWebWorker;
		}

		inline get localStorage(): bool {
			return this.bLocalStorage;
		}

		inline get webSocket(): bool {
			return this.bWebSocket;
		}

		inline get gamepad(): bool {
			return this.bGamepad;
		}

		constructor () {
			super();

			var pApi = {};

			this.bWebAudio = ((<any>window).AudioContext && (<any>window).webkitAudioContext ? true : false);
			this.bFile = ((<any>window).File && (<any>window).FileReader && (<any>window).FileList && (<any>window).Blob ? true : false);
			this.bFileSystem = (this.bFile && (<any>window).URL && (<any>window).requestFileSystem ? true : false);
			this.bWebWorker = isDef((<any>window).Worker);
			this.bLocalStorage = isDef((<any>window).localStorage);
			this.bWebSocket = isDef((<any>window).WebSocket);
			this.bGamepad = !! (<any>navigator).webkitGetGamepads || !! (<any>navigator).webkitGamepads || (navigator.userAgent.indexOf('Firefox/') != -1);
		}

		private chechTransferableObjects(): bool {
			var pBlob: Blob = new Blob(["onmessage = function(e) { postMessage(true); }"], { "type" : "text\/javascript" });
			var sBlobURL: string = (<any>window).URL.createObjectURL(pBlob);
			var pWorker: Worker = new Worker(sBlobURL);

			var pBuffer: ArrayBuffer = new ArrayBuffer(1);

		    try {
		        pWorker.postMessage(pBuffer, [pBuffer]);
		    }
		    catch (e) {
		        logger.setSourceLocation( "util/ApiInfo.ts" , 85 ); logger.log('transferable objects not supported in your browser...'); ;
		    }

		    pWorker.terminate();

		    if (pBuffer.byteLength) {
		        return false
		    }

		    return true;
		}
	}
}





module akra.info {
	export function canvas(pCanvas: HTMLCanvasElement): ICanvasInfo;
	export function canvas(id: string): ICanvasInfo;
	export function canvas(id): ICanvasInfo {
		var pCanvas: HTMLCanvasElement = isString(id) ? document.getElementById(id) : id;

		return {
			width: isInt(pCanvas.width) ? pCanvas.width : parseInt(pCanvas.style.width),
			height: isInt(pCanvas.height) ? pCanvas.height : parseInt(pCanvas.style.height),
			id: pCanvas.id
		};
	}

	export var browser: IBrowserInfo = new util.BrowserInfo;
	export var api: IApiInfo = new util.ApiInfo;
	export var screen: IScreenInfo = new util.ScreenInfo;

	export var uri: IURI = util.uri(document.location.href);

	module is {
/**
         * show status - online or offline
         */

		export var online;
/**
         * perform test on mobile device
         */

		export var mobile: bool = (/mobile|iphone|ipad|ipod|android|blackberry|mini|windows\sce|palm/i)
			.test(navigator.userAgent.toLowerCase());
		export var linux: bool = browser.os === 'Linux';
		export var windows: bool = browser.os === 'Windows';
		export var mac: bool = browser.os === 'Mac';
		export var iPhone: bool = browser.os === 'iPhone';
	}


//TODO: move it to [akra.info.is] module, when typescript access this.
	Object.defineProperty(is, 'online', {
		get: function () {
			return navigator.onLine;
		}
	});
}


/*local and remote via thread*/








module akra {

	export interface IFileMeta {
		lastModifiedDate: string;
		size:  number ;
	}

	export interface IFile {
		 path: string;
		 name: string;
		mode:  number ;

		onread: Function;
		onopen: Function;

		position:  number ;
		byteLength:  number ;


		open(sFilename: string, iMode:  number , fnCallback?: Function): void;
		open(sFilename: string, sMode: string, fnCallback?: Function): void;
		open(sFilename: string, fnCallback?: Function): void;
		open(iMode:  number , fnCallback?: Function): void;
		open(fnCallback?: Function): void;

		close(): void;
		clear(fnCallback?: Function): void;
		read(fnCallback?: Function): void;
		write(sData: string, fnCallback?: Function, sContentType?: string): void;
		write(pData: ArrayBuffer, fnCallback?: Function, sContentType?: string): void;
		move(sFilename: string, fnCallback?: Function): void;
		copy(sFilename: string, fnCallback?: Function): void;
		rename(sFilename: string, fnCallback?: Function): void;
		remove(fnCallback?: Function): void;

//return current position
		atEnd():  number ;
//return current position;
		seek(iOffset:  number ):  number ;

		isOpened(): bool;
		isExists(fnCallback: Function): void;
		isLocal(): bool;

		getMetaData(fnCallback: Function): void;
	}
}






module akra {
	export interface IThread {
		onmessage: Function;
		onerror: Function;
		id:  number ;

		send(pData: Object, pTransferables?: any[]): void;
		send(pData: ArrayBuffer, pTransferables?: any[]): void;
		send(pData: ArrayBufferView, pTransferables?: any[]): void;
	}
}



























//#define ERR_TM_REACHED_LIMIT 0



//seconds






module akra {

	export interface IThread {} ;

	export interface IThreadManager extends IManager {
		createThread(): bool;
		occupyThread(): IThread;
		releaseThread(iThread:  number ): bool;
		releaseThread(pThread: IThread): bool;
	}
}






module akra.util {

	export enum EThreadStatuses {
		k_WorkerBusy,
		k_WorkerFree
	}

	export interface IThreadStats {
		status: EThreadStatuses;
		creationTime:  number ;
		releaseTime:  number ;
	}

	export class ThreadManager implements IThreadManager {
		private _sDefaultScript: string;
		private _pWorkerList: IThread[] = [];
		private _pStatsList: IThreadStats[] = [];

		constructor (sScript: string = null) {

			this._sDefaultScript = sScript;


			setInterval((): void => {
				var pStats: IThreadStats;
				var iNow:  number  = now();

				for (var i:  number  = 0, n:  number  = this._pStatsList.length; i < n; ++ i) {
					pStats = this._pStatsList[i];

					if (pStats.releaseTime > 0 && iNow - pStats.releaseTime >  30  * 1000) {
						if (this.terminateThread(i)) {
							logger.setSourceLocation( "util/ThreadManager.ts" , 45 ); logger.log("thread with id - " + i + " terminated. (" + i + "/" + n + ")"); ;
							return;
						}

						logger.setSourceLocation( "util/ThreadManager.ts" , 49 ); logger.warning("thread must be removed: " + i); ;
					}
				};
			}, 30000);
		}

		createThread(): bool {
//console.log((new Error).stack)
			if (this._pWorkerList.length ===  32 ) {
				logger.setSourceLocation( "util/ThreadManager.ts" , 58 ); logger.error("Reached limit the number of threads"); ;
				return false;
			}

			if (!info.api.webWorker) {
				logger.setSourceLocation( "util/ThreadManager.ts" , 63 ); logger.error("WebWorkers unsupprted.."); ;
				return false;
			}

			var pWorker: IThread = <IThread><any>(new Worker(this._sDefaultScript));

			pWorker.id = this._pWorkerList.length;
			pWorker.send = (<any>pWorker).postMessage;

			this._pWorkerList.push(<IThread>pWorker);
			this._pStatsList.push({
				status: EThreadStatuses.k_WorkerFree,
				creationTime: now(),
				releaseTime: now()
				});

			return true;
		}

		occupyThread(): IThread {
			var pStats: IThreadStats;
			for (var i:  number  = 0, n:  number  = this._pWorkerList.length; i < n; ++i) {
				pStats = this._pStatsList[i];
		        if (pStats.status == EThreadStatuses.k_WorkerFree) {
		            pStats.status = EThreadStatuses.k_WorkerBusy;
		            pStats.releaseTime = 0;

		            return this._pWorkerList[i];
		        }
		    }

		    if (this.createThread()) {
		    	return this.occupyThread();
		    }

		    else {
		    	logger.setSourceLocation( "util/ThreadManager.ts" , 99 ); logger.error("cannot occupy thread"); ;
		    	return null;
		    }
		}

		terminateThread(iThread:  number ): bool {
			var pStats: IThreadStats = this._pStatsList[iThread];
			var pWorker: IThread = this._pWorkerList[iThread];

			if (!isDefAndNotNull(pWorker) && pStats.status != EThreadStatuses.k_WorkerFree) {
				return false;
			}

			(<Worker><any>pWorker).terminate();

			this._pStatsList.splice(iThread);
			this._pWorkerList.splice(iThread);

			return true;
		}

		releaseThread(pThread: IThread): bool;
		releaseThread(iThread:  number ): bool;
		releaseThread(pThread: any): bool {
			var iThread:  number ;
			var pStats: IThreadStats;

			if (!isInt(pThread)) {
				iThread = pThread.id;
			}
			else {
				iThread = pThread;
			}

			if (isDef(this._pStatsList[iThread])) {
				pStats = this._pStatsList[iThread];

				pStats.status = EThreadStatuses.k_WorkerFree;
				pStats.releaseTime = now();
			}

			return false;
		}

		initialize(): bool { return true; }
        destroy(): void {}
	}
}



/// @dep io/FileInterface.t.js
/// @dep io/LocalFile.t.js
/// @dep io/RemoteFile.t.js 














module akra.io {

	export enum EFileActions {
		k_Open = 1,
		k_Read = 2,
		k_Write,
		k_Clear,
		k_Exists,
		k_Remove
	};

	export enum EFileTransferModes {
		k_Normal,
		k_Slow,
		k_Fast
	}

	export interface IFileCommand {
		act: EFileActions;
		name: string;
		mode:  number ;
		pos?:  number ;
		transfer?: EFileTransferModes;
		data?: any;
		contentType?: string;
	}


	var pLocalFileThreadManager = new  util.ThreadManager( "LocalFile.t.js" ) ;
	var pRemoteFileThreadManager = new  util.ThreadManager( "RemoteFile.t.js" ) ;

	export var getLocalFileThreadManager = (): IThreadManager => pLocalFileThreadManager;
	export var getRemoteFileThreadManager = (): IThreadManager => pRemoteFileThreadManager;


	export class TFile implements IFile {
		/**@protected*/  _iMode:  number ;
		/**@protected*/  _pUri: IURI = null;
		/**@protected*/  _nCursorPosition:  number  = 0;
		/**@protected*/  _bOpened: bool = false;
		/**@protected*/  _eTransferMode: EFileTransferModes = EFileTransferModes.k_Normal;
		/**@protected*/  _pFileMeta: IFileMeta = null;
		/**@protected*/  _isLocal: bool = false;


		inline get path(): string {
			logger.setSourceLocation( "TFile.ts" , 82 ); logger.assert(isDefAndNotNull(this._pFileMeta), "There is no file handle open."); ;
        	return this._pUri.toString();
		}

		inline get name(): string {
			return util.pathinfo(this._pUri.path).basename;
		}

		inline get mode():  number  {
			return this._iMode;
		}

//set mode(sMode: string);
//set mode(iMode: int);
		set mode(sMode: any) {
			this._iMode = isString(sMode)? filemode(sMode): sMode;
		}

		inline set onread(fnCallback: Function) {
			this.read(fnCallback);
		}

		inline set onopen(fnCallback: Function) {
			this.open(fnCallback);
		}

		inline get position():  number  {
			logger.setSourceLocation( "TFile.ts" , 109 ); logger.assert(isDefAndNotNull(this._pFileMeta), 'There is no file handle open.'); ;
        	return this._nCursorPosition;
		}

		set position(iOffset:  number ) {
			logger.setSourceLocation( "TFile.ts" , 114 ); logger.assert(isDefAndNotNull(this._pFileMeta), 'There is no file handle open.'); ;
			this._nCursorPosition = iOffset;
		}

		inline get byteLength():  number  {
       	 return this._pFileMeta? this._pFileMeta.size: 0;
		}

		constructor (sFilename?: string, sMode?: string, fnCallback: Function = TFile.defaultCallback);
		constructor (sFilename?: string, iMode?:  number , fnCallback: Function = TFile.defaultCallback);
		constructor (sFilename?: string, sMode?: any, fnCallback: Function = TFile.defaultCallback) {
			if (isDef(sMode)) {
				this._iMode = isString(sMode)? filemode(sMode): sMode;
			}

			this.setAndValidateUri(util.uri(sFilename));

			if (info.api.transferableObjects) {
				this._eTransferMode = EFileTransferModes.k_Fast;
			}
			else if (info.browser.name == "Opera") {
				this._eTransferMode = EFileTransferModes.k_Slow;
			}

			if (arguments.length > 2) {
				this.open(sFilename, sMode, fnCallback);
			}
		}

		open(sFilename: string, iMode:  number , fnCallback?: Function): void;
//open(sFilename: string, sMode: string, fnCallback?: Function): void;
		open(sFilename: string, fnCallback?: Function): void;
		open(iMode:  number , fnCallback?: Function): void;
		open(fnCallback?: Function): void;
		open(sFilename?: any, iMode?: any, fnCallback?: any): void {
			var pFile: IFile = this;
			var hasMode: bool = !isFunction(iMode);

			 if (arguments.length < 3) {
		        if (isString(arguments[0])) {
		            this.setAndValidateUri(util.uri(sFilename));
		            fnCallback = arguments[1];
		        }
		        else if (isInt(arguments[0])) {
		            this._iMode = arguments[0];
		            fnCallback = arguments[1];
		        }
		        else {
		            fnCallback = arguments[0];
		        }

		        logger.setSourceLocation( "TFile.ts" , 165 ); logger.assert(isDefAndNotNull(this._pUri), "No filename provided."); ;


		        this.open(this._pUri.toString(), this._iMode, fnCallback);

		        return;
		    }

		    fnCallback = arguments[hasMode ? 2 : 1];
		    fnCallback = fnCallback || TFile.defaultCallback;

		    if (this.isOpened()) {
		        logger.setSourceLocation( "TFile.ts" , 177 ); logger.warning("file already opened: " + this.name); ;
		        (<Function>fnCallback)(null, this._pFileMeta);
		    }

		    this.setAndValidateUri(util.uri(arguments[0]));

		    if (hasMode) {
		    	this._iMode = (isString(arguments[1]) ? filemode(<string>arguments[1]) : arguments[1]);
		    }

		    this.update(function (err) {
		    	if (err) {
		    		logger.setSourceLocation( "TFile.ts" , 189 ); logger.warning("file update err", err); ;
		    		fnCallback.call(pFile, err);
		    		return;
		    	}

		        if ( ((this._iMode & (1 << (3)) ) != 0) ) {
		            this.position = this.size;
		        }

		        fnCallback.call(pFile, null, pFile);
		    });
		}

		close(): void {
			this._pUri = null;
			this._iMode = EIO.IN | EIO.OUT;
			this._nCursorPosition = 0;
			this._pFileMeta = null;
		}

		clear(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.clear.apply(this, _pArgv); }); return; } ;

			var pCommand: IFileCommand = {
	                                          act:  EFileActions.k_Clear,
	                                          name: this.path,
	                                          mode: this._iMode
	                                      };

			this.execCommand(pCommand, fnCallback);
		}


		read(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.read.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var eTransferMode: EFileTransferModes = this._eTransferMode;

		    logger.setSourceLocation( "TFile.ts" , 228 ); logger.assert( ((this._iMode & (1 << (0)) ) != 0) , "The file is not readable."); ;


		    var pCommand: IFileCommand = {
		                     act:      EFileActions.k_Read,
		                     name:     this.path,
		                     mode:     this._iMode,
		                     pos:      this._nCursorPosition,
		                     transfer: this._eTransferMode
		                 };

		    var fnCallbackSystem: Function = function (err, pData) {
				if (err) {
					fnCallback.call(pFile, err);
					return;
				}

		        if (eTransferMode == EFileTransferModes.k_Slow &&  ((this._iMode & (1 << (5)) ) != 0) ) {
		            pData = new Uint8Array(pData).buffer;
		        }

		        pFile.atEnd();

		        fnCallback.call(pFile, null, pData);
		    };

		    this.execCommand(pCommand, fnCallbackSystem);
		}

		write(sData: string, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void;
		write(pData: ArrayBuffer, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void;
		write(pData: any, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.write.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var iMode:  number  = this._iMode;
		    var pCommand: IFileCommand;
			var fnCallbackSystem: Function = function (err, pMeta) {
				if (err) {
					fnCallback.call(pFile, err);
					return;
				}

		    	pFile.position += isString(pData)? pData.length: pData.byteLength;
		    	(<any>pFile)._pFileMeta = <IFileMeta>pMeta;

		    	fnCallback.call(pFile, null, pMeta);
		    };

		    logger.setSourceLocation( "TFile.ts" , 277 ); logger.assert( ((iMode & (1 << (1)) ) != 0) , "The file is not writable."); ;

		    sContentType = sContentType || ( ((iMode & (1 << (5)) ) != 0) ? "application/octet-stream" : "text/plain");

		    pCommand = {
                    act:         EFileActions.k_Write,
                    name:        this.path,
                    mode:        this._iMode,
                    data:        pData,
                    contentType: sContentType,
                    pos:         this._nCursorPosition
                 };

            if (!isString(pData)) {
            	this.execCommand(pCommand, fnCallbackSystem, [pData]);
            }
            else {
            	this.execCommand(pCommand, fnCallbackSystem);
        	}
		}

		move(sFilename: string, fnCallback: Function = TFile.defaultCallback): void {
			var pFile: IFile = this;

			this.copy(sFilename, function(err) {
				if (err) {
					fnCallback(err);
					return;
				}

				pFile.remove(fnCallback);
			});
		}

		copy(sFilename: string, fnCallback: Function = TFile.defaultCallback): void {
			var iMode:  number  = EIO.IN | EIO.OUT | EIO.TRUNC;
		    var pFile: IFile = this;
		    var pFileCopy: IFile;

		    if ( ((this._iMode & (1 << (5)) ) != 0) ) {
		        iMode |= EIO.BIN;
		    }

		    pFileCopy = new TFile(sFilename, iMode,
		                                     function (err) {
		                                     	if (err) {
		                                     		fnCallback(err);
		                                     	}

		                                        pFile.read(function (pData: ArrayBuffer) {
		                                            pFile.write(pData, fnCallback);
		                                        });
		                                     });
		}

		rename(sFilename: string, fnCallback: Function = TFile.defaultCallback): void {
			var pName: IPathinfo = util.pathinfo(sFilename);

		    logger.setSourceLocation( "TFile.ts" , 335 ); logger.assert(!pName.dirname, 'only filename can be specified.'); ;

		    this.move(util.pathinfo(this._pUri.path).dirname + "/" + pName.basename, fnCallback);
		}

		remove(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.remove.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var pCommand: IFileCommand = {
		                     act:  EFileActions.k_Remove,
		                     name: this.path,
		                     mode: this._iMode
		                 };
		    var fnCallbackSystem: Function = function (err, pData) {
		        pFile.close();

		        if (isDef(fnCallback)) {
		            fnCallback.call(pFile, err, pData);
		        }
		    }

		    this.execCommand(pCommand, fnCallbackSystem);
		}

//return current position
		atEnd():  number  {
			this.position = this.byteLength;
			return this._nCursorPosition;
		}
//return current position;
		seek(iOffset:  number ):  number  {
			logger.setSourceLocation( "TFile.ts" , 367 ); logger.assert(isDefAndNotNull(this._pFileMeta), "There is no file handle open."); ;

		    var nSeek:  number  = this._nCursorPosition + iOffset;
		    if (nSeek < 0) {
		        nSeek = this.byteLength - (math.abs(nSeek) % this.byteLength);
		    }

		    logger.setSourceLocation( "TFile.ts" , 374 ); logger.assert(nSeek >= 0 && nSeek <= this.byteLength, "Invalid offset parameter"); ;

		    this._nCursorPosition = nSeek;

		    return this._nCursorPosition;
		}

		isOpened(): bool {
			return this._pFileMeta !== null;
		}

		isExists(fnCallback: Function): void {
			var pCommand: IFileCommand = {
                                              act:  EFileActions.k_Exists,
                                              name: this.path,
                                              mode: this._iMode
                                          };
			this.execCommand(pCommand, fnCallback);
		}

		inline isLocal(): bool {
			return this._isLocal;
		}

		getMetaData(fnCallback: Function): void {
			logger.setSourceLocation( "TFile.ts" , 399 ); logger.assert(isDefAndNotNull(this._pFileMeta), 'There is no file handle open.'); ;
		    fnCallback(null, {
		                  lastModifiedDate: this._pFileMeta.lastModifiedDate
		              });
		}
		private setAndValidateUri(sFilename: IURI);
		private setAndValidateUri(sFilename: string);
		private setAndValidateUri(sFilename: any) {
			var pUri: IURI = util.uri(sFilename);
			var pUriLocal: IURI;

			if (pUri.protocol === "filesystem") {
		        pUriLocal = util.uri(pUri.path);

		        logger.setSourceLocation( "TFile.ts" , 414 ); logger.assert(!(pUriLocal.protocol && pUriLocal.host != info.uri.host), "Поддерживаются только локальные файлы в пределах текущего домена.");
                                                                                                                                              ;

		        var pFolders: string[] = pUriLocal.path.split('/');

		        if (pFolders[0] == "" || pFolders[0] == ".") {
		            pFolders = pFolders.slice(1);
		        }

		        logger.setSourceLocation( "TFile.ts" , 423 ); logger.assert(pUri.host === "temporary", "Поддерживаются только файловые системы типа \"temporary\".");
                                                                                                                     ;

		        this._pUri = util.uri(pFolders.join("/"));
		        this._isLocal = true;
		    }
		    else {
		    	this._pUri = pUri;
			}
		}

		private update(fnCallback: Function = TFile.defaultCallback) {
			var pFile: IFile = this;
			var pCommand: IFileCommand = {
                     act:  EFileActions.k_Open,
                     name: this._pUri.toString(),
                     mode: this._iMode
                 };
			var fnCallbackSystem: Function = function (err, pMeta) {
				(<any>pFile)._pFileMeta = <IFileMeta>pMeta;
				fnCallback.call(pFile, err, pFile);
			};

			this.execCommand(pCommand, fnCallbackSystem);
		}

		private execCommand(pCommand: IFileCommand, fnCallback: Function, pTransferables?: any[]): void {
			TFile.execCommand(this.isLocal(), pCommand, fnCallback);
		}

		static defaultCallback: Function = function (err) {
			if (err) {
				throw err;
			}
		}

		private static execCommand(isLocal: bool, pCommand: IFileCommand, fnCallback: Function, pTransferables?: any[]): void {

			var pFile: IFile = this;
			var pManager: IThreadManager = isLocal? getLocalFileThreadManager(): getRemoteFileThreadManager();
			var pThread: IThread = pManager.occupyThread();

			pThread.onmessage = function (e) {
				pManager.releaseThread(pThread);
				pThread.onmessage = null;
				fnCallback.call(pFile, null, e.data);
			}

			pThread.onerror = function (e) {
				pManager.releaseThread(pThread);
				pThread.onmessage = null;
				fnCallback.call(pFile, e);
			}

			if (isDef(pTransferables)) {
				pThread.send(pCommand, pTransferables);
			}
			else {
				pThread.send(pCommand);
			}
		}

	}
}


/*local file via local files system(async)*/

/**
 * FIle implementation via <Local filesystem>.
 * ONLY FOR LOCAL FILES!!
 */



















module akra.io {

	class LocalFileSystem {
		private _pFileSystem: FileSystem = null;
		private _pCallbackQueue: Function[] = [];

		setFileSystem(pFS: FileSystem): void {
			this._pFileSystem = pFS;
		}

/**
		 * Инициализация файловой системы.
		 * @tparam Function fnCallback Функция, вызываемая
		 * при успешной(получет в 1ом параметре fs)
		 * инициализации системы.
		 */

		get (fnCallback: Function): void {
			if (this._pFileSystem) {
		        fnCallback(this._pFileSystem);
		        return;
		    }

		    var pFileSystem: LocalFileSystem = this;
		    var pQueue: Function[] = this._pCallbackQueue;

		    pQueue.push(fnCallback);

		    if (pQueue.length > 1) {
		        return;
		    }

    		window.storageInfo.requestQuota(window.TEMPORARY,  (32 * 1024 * 1024) ,
				function (nGrantedBytes:  number ) {
					window.requestFileSystem(
						window.TEMPORARY,
						nGrantedBytes,
						function (pFs: FileSystem) {

						   pFileSystem.setFileSystem(pFs);

						   if (pQueue.length) {
						       for (var i:  number  = 0; i < pQueue.length; ++i) {
						           pQueue[i](pFs);
						       }
						   }


						}, LocalFileSystem.errorHandler);
				});
		}

		static errorHandler (e: FileError): void {
			var sMesg: string = "init filesystem: ";

	        switch (e.code) {
	            case FileError.QUOTA_EXCEEDED_ERR:
	                sMesg += 'QUOTA_EXCEEDED_ERR';
	                break;
	            case FileError.NOT_FOUND_ERR:
	                sMesg += 'NOT_FOUND_ERR';
	                break;
	            case FileError.SECURITY_ERR:
	                sMesg += 'SECURITY_ERR';
	                break;
	            case FileError.INVALID_MODIFICATION_ERR:
	                sMesg += 'INVALID_MODIFICATION_ERR';
	                break;
	            case FileError.INVALID_STATE_ERR:
	                sMesg += 'INVALID_STATE_ERR';
	                break;
	            default:
	                sMesg += 'Unknown Error';
	                break;
	        }

	        logger.setSourceLocation( "LocalFile.ts" , 102 ); logger.error(sMesg); ;
		}
	}

	var pLocalFileSystem: LocalFileSystem = new LocalFileSystem;

	export function getFileSystem(fnCallback: (pFileSystem: FileSystem) => void): void {
		pLocalFileSystem.get(fnCallback);
	}

	export class LocalFile implements IFile {
		private _pUri: IURI;
		private _iMode:  number ;

//File
		private _pFile: File;
//file reader
		private _pFileReader: FileReader;
//pointer to file entry in filsystem
		private _pFileEntry: FileEntry;

		private _nCursorPosition:  number  = 0;

		inline get path(): string {
			logger.setSourceLocation( "LocalFile.ts" , 126 ); logger.assert(isDefAndNotNull(this._pFile), "There is no file handle open."); ;
        	return this._pUri.toString();
		}

		inline get name(): string {
			return util.pathinfo(this._pUri.path).basename;
		}

		inline get mode():  number  {
			return this._iMode;
		}

//set mode(sMode: string);
//set mode(iMode: int);
		set mode(sMode: any) {
			this._iMode = isString(sMode)? filemode(sMode): sMode;
		}

		inline set onread(fnCallback: Function) {
			this.read(fnCallback);
		}

		inline set onopen(fnCallback: Function) {
			this.open(fnCallback);
		}

		inline get position():  number  {
			logger.setSourceLocation( "LocalFile.ts" , 153 ); logger.assert(isDefAndNotNull(this._pFile), "There is no file handle open."); ;
        	return this._nCursorPosition;
		}

		set position(iOffset:  number ) {
			logger.setSourceLocation( "LocalFile.ts" , 158 ); logger.assert(isDefAndNotNull(this._pFile), "There is no file handle open."); ;
			this._nCursorPosition = iOffset;
		}

		inline get byteLength():  number  {
       		return this._pFile? this._pFile.size: 0;
		}


		constructor (sFilename?: string, sMode?: string, fnCallback: Function = LocalFile.defaultCallback);
		constructor (sFilename?: string, iMode?:  number , fnCallback: Function = LocalFile.defaultCallback);
		constructor (sFilename?: string, sMode?: any, fnCallback: Function = LocalFile.defaultCallback) {
			if (isDef(sMode)) {
				this._iMode = isString(sMode)? filemode(sMode): sMode;
			}

			this.setAndValidateUri(util.uri(sFilename));

			if (arguments.length > 2) {
				this.open(sFilename, sMode, fnCallback);
			}
		}


		open(sFilename: string, iMode:  number , fnCallback?: Function): void;
//open(sFilename: string, sMode: string, fnCallback?: Function): void;
		open(sFilename: string, fnCallback?: Function): void;
		open(iMode:  number , fnCallback?: Function): void;
		open(fnCallback?: Function): void;
		open(sFilename?: any, iMode?: any, fnCallback?: any): void {
			var pFile: IFile = this;
			var hasMode: bool = !isFunction(iMode);

			 if (arguments.length < 3) {
		        if (isString(arguments[0])) {
		            this.setAndValidateUri(util.uri(sFilename));
		            fnCallback = arguments[1];
		        }
		        else if (isInt(arguments[0])) {
		            this._iMode = arguments[0];
		            fnCallback = arguments[1];
		        }
		        else {
		            fnCallback = arguments[0];
		        }

		        logger.setSourceLocation( "LocalFile.ts" , 204 ); logger.assert(isDefAndNotNull(this._pUri), "No filename provided."); ;


		        this.open(this._pUri.toString(), this._iMode, fnCallback);

		        return;
		    }

		    fnCallback = arguments[hasMode ? 2 : 1];
		    fnCallback = fnCallback || LocalFile.defaultCallback;

		    if (this.isOpened()) {
		        logger.setSourceLocation( "LocalFile.ts" , 216 ); logger.warning("file already opened: " + this.name); ;
		        (<Function>fnCallback)(null, this._pFile);
		    }

		    this.setAndValidateUri(util.uri(arguments[0]));

		    if (hasMode) {
		    	this._iMode = (isString(arguments[1]) ? filemode(<string>arguments[1]) : arguments[1]);
		    }

		    var fnFSInited: Function;

		    var pFile: LocalFile = this;
		    var pFileSystem: FileSystem = null;
		    var fnErrorHandler: Function = function (e) {
		        if (e.code == FileError.NOT_FOUND_ERR &&  ((pFile.mode & (1 << (1)) ) != 0) ) {
					LocalFile.createDir(
						pFileSystem.root,
						util.pathinfo(pFile.path).dirname.split('/'),
		                function (e) {
		                	if (!isNull(e)) {
		                		fnCallback.call(pFile, e);
	                		}
	                		else {
	                			fnFSInited.call(pFile, pFileSystem);
	                		}
		                });
		        }
		        else {
		            fnCallback.call(pFile, e);
		        }
		    };

		    fnFSInited = function (pFs: FileSystem) {
		        logger.setSourceLocation( "LocalFile.ts" , 250 ); logger.assert(isDefAndNotNull(pFs), "local file system not initialized"); ;

		        pFileSystem = pFs;
		        pFs.root.getFile(this.path,
		                         {
		                             create:     ((this._iMode & (1 << (1)) ) != 0) ,
		                             exclusive: false
		                         },
		                         function (fileEntry: Entry) {
		                             (<LocalFile>pFile).setFileEntry(<FileEntry>fileEntry);

		                             (<FileEntry>fileEntry).file(function (file: File) {
		                                 (<LocalFile>pFile).setFile(file);

		                                 if ( ((pFile.mode & (1 << (4)) ) != 0)  && pFile.byteLength) {
		                                     pFile.clear(function (err) {
		                                     	if (err) {
		                                     		fnCallback(err);
		                                     	}
		                                     	else {
		                                        	fnCallback.call(pFile, null, file);
		                                        }
		                                     });
		                                     return;
		                                 }

		                                 if ( ((pFile.mode & (1 << (3)) ) != 0) ) {
		                                     pFile.position = pFile.byteLength;
		                                 }

		                                 fnCallback.call(pFile, null, file);
		                             }, <ErrorCallback>fnErrorHandler);

		                         },
		                         <ErrorCallback>fnErrorHandler);
		    };

		    getFileSystem(function (pFileSystem: FileSystem) {
		        fnFSInited.call(pFile, pFileSystem);
		    });
		}

		close (): void {
		    this._pUri = null;
		    this._iMode = EIO.IN | EIO.OUT;
		    this._nCursorPosition = 0;
		    this._pFile = null;
		};


		clear(fnCallback: Function = LocalFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.clear.apply(this, _pArgv); }); return; } ;

			logger.setSourceLocation( "LocalFile.ts" , 303 ); logger.assert(isDefAndNotNull(this._pFile), 'There is no file handle open'); ;

		    var pFile: IFile = this;
		    var pFileEntry: FileEntry = this._pFileEntry;

		    pFileEntry.createWriter(
		    	function (pWriter: FileWriter) {
			        pWriter.seek(0);

			        pWriter.onwriteend = function () {
		                fnCallback.call(pFile, null);
		            }

			        pWriter.truncate(0);

			    },
			    function (e: FileError) {
			        fnCallback.call(pFile, e);
			    });
		}

		read(fnCallback: Function = LocalFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.read.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var eTransferMode: EFileTransferModes = this._iMode;

		    logger.setSourceLocation( "LocalFile.ts" , 330 ); logger.assert( ((this._iMode & (1 << (0)) ) != 0) , "The file is not readable."); ;

			var pReader: FileReader = this._pFileReader;
			var pFileObject: File = this._pFile;

		    pReader.onloadend = function (e) {
		        var pData: any = (<any>(e.target)).result;
		        var nPos:  number  = pFile.position;

		        if (nPos) {
		            if ( ((pFile.mode & (1 << (5)) ) != 0) ) {
		                pData = (new Uint8Array((new Uint8Array(pData)).subarray(nPos))).buffer;
		            }
		            else {
		                pData = pData.substr(nPos);
		            }
		        }

		        pFile.atEnd();

		        fnCallback.call(pFile, null, pData);
		    };

		    if ( ((pFile.mode & (1 << (5)) ) != 0) ) {
		        pReader.readAsArrayBuffer(pFileObject);
		    }
		    else {
		        pReader.readAsText(pFileObject);
		    }
		}

		write(sData: string, fnCallback: Function = LocalFile.defaultCallback, sContentType?: string): void;
		write(pData: ArrayBuffer, fnCallback: Function = LocalFile.defaultCallback, sContentType?: string): void;
		write(pData: any, fnCallback: Function = LocalFile.defaultCallback, sContentType?: string): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.write.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    var iMode:  number  = this._iMode;

		    logger.setSourceLocation( "LocalFile.ts" , 369 ); logger.assert( ((iMode & (1 << (1)) ) != 0) , "The file is not writable."); ;

		    sContentType = sContentType || ( ((iMode & (1 << (5)) ) != 0)  ? "application/octet-stream" : "text/plain");

		    var pFile: IFile = this;
		    var pFileEntry: FileEntry = this._pFileEntry;

		    pFileEntry.createWriter(function (pWriter: FileWriter) {
		        pWriter.seek(pFile.position);

		        pWriter.onerror = function (e: FileError) {
		            fnCallback.call(pFileEntry, e);
		        }


	            pWriter.onwriteend = function () {
	                if ( ((iMode & (1 << (5)) ) != 0) ) {
	                    pFile.seek(pData.byteLength);
	                }
	                else {
	                    pFile.seek(pData.length);
	                }

	                fnCallback.call(pFile, null);
	            };

		        pWriter.write(<Blob>(new (<any>Blob)(pData, {type: sContentType})));

		    },
		    function (e: FileError) {
		        fnCallback.call(pFile, e);
		    });
		}


		move(sFilename: string, fnCallback: Function = LocalFile.defaultCallback): void {
			var pFile: IFile = this;

			this.copy(sFilename, function(err) {
				if (err) {
					fnCallback(err);
					return;
				}

				pFile.remove(fnCallback);
			});
		}

		copy(sFilename: string, fnCallback: Function = LocalFile.defaultCallback): void {
			var iMode:  number  = EIO.IN | EIO.OUT | EIO.TRUNC;
		    var pFile: IFile = this;
		    var pFileCopy: IFile;

		    if ( ((this._iMode & (1 << (5)) ) != 0) ) {
		        iMode |= EIO.BIN;
		    }

		    pFileCopy = new LocalFile(sFilename, iMode,
		                                     function (err) {
		                                     	if (err) {
		                                     		fnCallback(err);
		                                     	}

		                                        pFile.read(function (pData: ArrayBuffer) {
		                                            pFile.write(pData, fnCallback);
		                                        });
		                                     });
		}

		rename(sFilename: string, fnCallback: Function = LocalFile.defaultCallback): void {
			var pName: IPathinfo = util.pathinfo(sFilename);

		    logger.setSourceLocation( "LocalFile.ts" , 441 ); logger.assert(!pName.dirname, 'only filename can be specified.'); ;

		    this.move(util.pathinfo(this._pUri.path).dirname + "/" + pName.basename, fnCallback);
		}

		remove(fnCallback: Function = LocalFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.remove.apply(this, _pArgv); }); return; } ;

		    var pFile: IFile = this;
		    this._pFileEntry.remove(
		    <VoidCallback>function () {
		        pFile.close();
		        fnCallback.call(pFile, null);
		    }, <ErrorCallback>fnCallback);
		}

//return current position
		atEnd():  number  {
			this.position = this.byteLength;
			return this._nCursorPosition;
		}
//return current position;
		seek(iOffset:  number ):  number  {
			logger.setSourceLocation( "LocalFile.ts" , 464 ); logger.assert(isDefAndNotNull(this._pFile), "There is no file handle open."); ;

		    var nSeek:  number  = this._nCursorPosition + iOffset;
		    if (nSeek < 0) {
		        nSeek = this.byteLength - (math.abs(nSeek) % this.byteLength);
		    }

		    logger.setSourceLocation( "LocalFile.ts" , 471 ); logger.assert(nSeek >= 0 && nSeek <= this.byteLength, "Invalid offset parameter"); ;

		    this._nCursorPosition = nSeek;

		    return this._nCursorPosition;
		}

		isOpened(): bool {
			return this._pFile !== null;
		}

		isExists(fnCallback: Function): void {
			this.open(function(e: FileError) {
				fnCallback(isNull(e)? true: false);
			});
		}

		isLocal(): bool {
			return true;
		}

		getMetaData(fnCallback: Function): void {
			logger.setSourceLocation( "LocalFile.ts" , 493 ); logger.assert(isDefAndNotNull(this._pFile), 'There is no file handle open.'); ;
		    fnCallback(null, {
		                  lastModifiedDate: this._pFile.lastModifiedDate
		              });
		}

		setFileEntry(pFileEntry: FileEntry): bool {
			if (!isNull(this._pFileEntry)) {
				return false;
			}

			this._pFileEntry = pFileEntry;
			return true;
		}

		setFile(pFile: File): bool {
			if (!isNull(this._pFile)) {
				return false;
			}

			this._pFile = pFile;

			return true;
		}

		private setAndValidateUri(sFilename: IURI);
		private setAndValidateUri(sFilename: string);
		private setAndValidateUri(sFilename: any) {
			var pUri: IURI = util.uri(sFilename);
			var pUriLocal: IURI;

			if (pUri.protocol === "filesystem") {
		        pUriLocal = util.uri(pUri.path);

		        logger.setSourceLocation( "LocalFile.ts" , 528 ); logger.assert(!(pUriLocal.protocol && pUriLocal.host != info.uri.host), "Поддерживаются только локальные файлы в пределах текущего домена.");
                                                                                                                                              ;

		        var pFolders: string[] = pUriLocal.path.split('/');

		        if (pFolders[0] == "" || pFolders[0] == ".") {
		            pFolders = pFolders.slice(1);
		        }

		        logger.setSourceLocation( "LocalFile.ts" , 537 ); logger.assert(pUri.host === "temporary", "Поддерживаются только файловые системы типа \"temporary\".");
                                                                                                                     ;

		        this._pUri = util.uri(pFolders.join("/"));
		    }
		    else {
		    	logger.setSourceLocation( "LocalFile.ts" , 542 ); logger.error("used non local uri"); ;
			}
		}

		static errorHandler (e: FileError): void {
			var sMesg: string = "";

	        switch (e.code) {
	            case FileError.QUOTA_EXCEEDED_ERR:
	                sMesg += 'QUOTA_EXCEEDED_ERR';
	                break;
	            case FileError.NOT_FOUND_ERR:
	                sMesg += 'NOT_FOUND_ERR';
	                break;
	            case FileError.SECURITY_ERR:
	                sMesg += 'SECURITY_ERR';
	                break;
	            case FileError.INVALID_MODIFICATION_ERR:
	                sMesg += 'INVALID_MODIFICATION_ERR';
	                break;
	            case FileError.INVALID_STATE_ERR:
	                sMesg += 'INVALID_STATE_ERR';
	                break;
	            default:
	                sMesg += 'Unknown Error';
	                break;
	        }

	        logger.setSourceLocation( "LocalFile.ts" , 570 ); logger.error(sMesg); ;
		}

		static createDir(pRootDirEntry: DirectoryEntry, pFolders: string[], fnCallback) {
		    if (pFolders[0] == "." || pFolders[0] == "") {
		        pFolders = pFolders.slice(1);
		    }

		    pRootDirEntry.getDirectory(
		    	pFolders[0],
			    { create: true },
			    function (dirEntry: Entry) {
			        if (pFolders.length) {
			            LocalFile.createDir(<DirectoryEntry>dirEntry, pFolders.slice(1), fnCallback);
			        }
			        else {
			            fnCallback(null);
			        }
			    }, fnCallback);
		};

		static defaultCallback: Function = function (err) {
			if (err) {
				LocalFile.errorHandler(err);
			}
		}

	}
}


/*local file via local files system(async)*/

/**
 * FIle implementation via <Local Storage>.
 * ONLY FOR LOCAL FILES!!
 */















module akra.io {
	export class StorageFile extends TFile implements IFile {

		constructor (sFilename?: string, sMode?: string, fnCallback: Function = TFile.defaultCallback);
		constructor (sFilename?: string, iMode?:  number , fnCallback: Function = TFile.defaultCallback);
		constructor (sFilename?: string, sMode?: any, fnCallback: Function = TFile.defaultCallback) {
			super(sFilename, sMode, fnCallback);
		}

		clear(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.clear.apply(this, _pArgv); }); return; } ;

			localStorage.setItem(this.path, "");
			this._pFileMeta.size = 0;

			fnCallback(null, this);
		}

		read(fnCallback: Function = TFile.defaultCallback): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.read.apply(this, _pArgv); }); return; } ;

			logger.setSourceLocation( "StorageFile.ts" , 36 ); logger.assert( ((this._iMode & (1 << (1)) ) != 0) , "The file is not readable."); ;

		    var pData: any = this.readData();
		    var nPos:  number  = this._nCursorPosition;

		    if (nPos) {
		        if ( ((this._iMode & (1 << (5)) ) != 0) ) {
		            pData = (new Uint8Array((new Uint8Array(pData)).subarray(nPos))).buffer;
		        }
		        else {
		            pData = pData.substr(nPos);
		        }
		    }

		    this.atEnd();

		    if (fnCallback) {
		        fnCallback.call(this, null, pData);
		    }
		}

		write(sData: string, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void;
		write(pData: ArrayBuffer, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void;
		write(pData: any, fnCallback: Function = TFile.defaultCallback, sContentType?: string): void {
			if (!this.isOpened()) { var _pArgv: IArguments = arguments; this.open(function(err) { if (err) fnCallback(err); this.write.apply(this, _pArgv); }); return; } ;

			var iMode:  number  = this._iMode;
			var nSeek:  number ;
			var pCurrentData: any;

		    logger.setSourceLocation( "StorageFile.ts" , 66 ); logger.assert( ((iMode & (1 << (1)) ) != 0) , "The file is not writable."); ;

		    sContentType = sContentType || ( ((iMode & (1 << (5)) ) != 0)  ? "application/octet-stream" : "text/plain");

		    pCurrentData = this.readData();

		    if (!isString(pCurrentData)) {
		        pCurrentData = util.abtos(pCurrentData);
		    }

		    nSeek = (isString(pData) ? pData.length : pData.byteLength);

		    if (!isString(pData)) {
		        pData = util.abtos(pData);
		    }

		    pData = (<string>pCurrentData).substr(0, this._nCursorPosition) + (<string>pData) +
		    	(<string>pCurrentData).substr(this._nCursorPosition + (<string>pData).length);

		    try {
		        localStorage.setItem(this.path, pData);
		    }
		    catch (e) {
		       fnCallback(e);
		    }

		    this._pFileMeta.size = pData.length;
		    this._nCursorPosition += nSeek;

		    fnCallback(null);
		}

		isExists(fnCallback: Function = TFile.defaultCallback): void {
			fnCallback.call(this, null, localStorage.getItem(this.path) == null);
		}

		remove(fnCallback: Function = TFile.defaultCallback): void {
			localStorage.removeItem(this.path);
    		fnCallback.call(this, null);
		}

		private readData(): any {
			var pFileMeta: IFileMeta = this._pFileMeta;
		    var pData: string = localStorage.getItem(this.path);
		    var pDataBin: ArrayBuffer;

		    if (pData == null) {
		        pData = "";
		        if ( ((this._iMode & (1 << (1)) ) != 0) ) {
		            localStorage.setItem(this.path, pData);
		        }
		    }


		    if ( ((this._iMode & (1 << (5)) ) != 0) ) {
		        pDataBin = util.stoab(pData);
		        pFileMeta.size = pDataBin.byteLength;
		        return pDataBin;
		    }
		    else {
		        pFileMeta.size = pData.length;
		        return pData;
		    }

//return null;
		}

		private update(fnCallback: Function): void {
			this._pFileMeta = null;
		    this.readData();
		    fnCallback.call(this, null);
		}
	}
}




module akra.io {

	export enum EIO {
		IN = 0x01,
		OUT = 0x02,
		ATE = 0x04,
		APP = 0x08,
		TRUNC = 0x10,
		BINARY = 0x20,
		BIN = 0x20,
		TEXT = 0x40
	};

	export function filemode(sMode: string):  number  {
		switch (sMode.toLowerCase()) {
	        case "a+t":
	            return EIO.IN | EIO.OUT | EIO.APP | EIO.TEXT;
	        case "w+t":
	            return EIO.IN | EIO.OUT | EIO.TRUNC | EIO.TEXT;
	        case "r+t":
	            return EIO.IN | EIO.OUT | EIO.TEXT;

	        case "at":
	            return EIO.APP | EIO.TEXT;
	        case "wt":
	            return EIO.OUT | EIO.TEXT;
	        case "rt":
	            return EIO.IN | EIO.TEXT;

	        case "a+b":
	            return EIO.IN | EIO.OUT | EIO.APP | EIO.BIN;
	        case "w+b":
	            return EIO.IN | EIO.OUT | EIO.TRUNC | EIO.BIN;
	        case "r+b":
	            return EIO.IN | EIO.OUT | EIO.BIN;

	        case "ab":
	            return EIO.APP | EIO.BIN;
	        case "wb":
	            return EIO.OUT | EIO.BIN;
	        case "rb":
	            return EIO.IN | EIO.BIN;

	        case "a+":
	            return EIO.IN | EIO.OUT | EIO.APP;
	        case "w+":
	            return EIO.IN | EIO.OUT | EIO.TRUNC;
	        case "r+":
	            return EIO.IN | EIO.OUT;

	        case "a":
	            return EIO.APP | EIO.OUT;
	        case "w":
	            return <number>EIO.OUT;
	        case "r":
	        default:
	            return <number>EIO.IN;
	    }
	}

// function _fopen (sUri: string, iMode?: int): IFile;
// function _fopen (sUri: string, sMode?: int): IFile;
// function _fopen (pUri: IURI, iMode: int): IFile;
// function _fopen (pUri: IURI, sMode: string): IFile;

	function _fopen(sUri: any, pMode: any = EIO.IN): IFile {
		if (info.api.webWorker) {
			return new TFile(<string>sUri, pMode);
		}
		else if (info.api.fileSystem) {
			return new LocalFile(<string>sUri, pMode);
		}
		else {
			return new StorageFile(<string>sUri, pMode);
		}
	}

	export var fopen = _fopen;
}

















module akra {

	export interface ICodec{

		getType():string;
		getDataType():string;
		magicNumberMatch(pMagicNumber: Uint8Array):bool;
		magicNumberToFileExt(pMagicNumber: Uint8Array):string;

		code(pInput:Uint8Array,pData:ICodecData):Uint8Array;
		decode(pData:Uint8Array,pCodecData:ICodecData):Uint8Array;


	}


	export interface ICodecData{
		dataType: string;
	}

}





module akra {


	export interface IImgCodec extends ICodec{
	}

	export interface IImgData extends ICodecData{
		height:  number ;
		width: number ;
		depth: number ;
		size: number ;

		numMipMaps: number ;
		flags:  number ;
		cubeFlags: number ;

		format: EPixelFormats;
		numFace:  number ;

	}
}










module akra
{
	export interface ICodecMap {
        	[index: string]: ICodec;
    	};


	export class Codec implements ICodec
	{


		private static _pMapCodecs: ICodecMap =<ICodecMap>{};

		static registerCodec(pCodec: ICodec):void
		{

			if(!isDef(Codec._pMapCodecs[pCodec.getType()]))
			{
				Codec._pMapCodecs[pCodec.getType()]=pCodec;
			}
			else
			{
				logger.setSourceLocation( "Codec.ts" , 28 ); logger.criticalError(pCodec.getType() + " already has a registered codec. "); ;
			}
		}

		static isCodecRegistered(pCodec: ICodec):bool
		{
			return isDef(Codec._pMapCodecs[pCodec.getType()]);
		}

		static unRegisterCodec(pCodec: ICodec):void
		{
			delete Codec._pMapCodecs[pCodec.getType()];
		}

		static getExtension():string[]
		{
			var pExt:string[]=<string[]>Array();
			var sExt:string="";
			for(sExt in Codec._pMapCodecs)
			{
				pExt.push(sExt)
			}
			return pExt;
		}

		static getCodec(sExt: string):ICodec;
		static getCodec(pMagicNumber: Uint8Array):ICodec;
		static getCodec(pMagicNumber: any):ICodec
		{
			var sExt: string="";
			if(isString(pMagicNumber))
			{
				if(isDef(Codec._pMapCodecs[pMagicNumber]))
				{
					return Codec._pMapCodecs[pMagicNumber];
				}
				else
				{
					logger.setSourceLocation( "Codec.ts" , 66 ); logger.criticalError("Can not find codec for "+pMagicNumber); ;
					return null;
				}
			}
			else
			{
				for(sExt in Codec._pMapCodecs)
				{
					var sExt1:string=Codec._pMapCodecs[sExt].magicNumberToFileExt(pMagicNumber);
					if(sExt1)
					{
						if(sExt1==Codec._pMapCodecs[sExt].getType())
						{
							return Codec._pMapCodecs[sExt];
						}
						else
						{
							return Codec.getCodec(sExt1);
						}

					}
				}
			}
			return null;
		}


		magicNumberMatch(pMagicNumber: Uint8Array):bool
		{
			return !(this.magicNumberToFileExt(pMagicNumber).length==0);
		}

		magicNumberToFileExt(pMagicNumber: Uint8Array):string
		{
			logger.setSourceLocation( "Codec.ts" , 100 ); logger.criticalError("Codec.magicNumberToFileExt is virtual"); ;
			return null;
		}

		getType():string
		{
			logger.setSourceLocation( "Codec.ts" , 106 ); logger.criticalError("Codec.getType is virtual"); ;
			return null;
		}

		getDataType():string
		{
			logger.setSourceLocation( "Codec.ts" , 112 ); logger.criticalError("Codec.getDataType is virtual"); ;
			return null;
		}

		code(pInput:Uint8Array,pData:ICodecData):Uint8Array
		{
			logger.setSourceLocation( "Codec.ts" , 118 ); logger.criticalError("Codec.code is virtual"); ;
			return null;
		}
		decode(pData:Uint8Array,pCodecData:ICodecData):Uint8Array
		{
			logger.setSourceLocation( "Codec.ts" , 123 ); logger.criticalError("Codec.decode is virtual"); ;
			return null;
		}



	}

	export class CodecData implements ICodecData
	{

		inline get dataType(): string{
			logger.setSourceLocation( "Codec.ts" , 135 ); logger.criticalError("CodecData.dataType is virtual"); ;
			return "CodecData";
		}
	}

}







module akra {


	export class ImgCodec extends Codec implements IImgCodec{
		getDataType(): string
        {
            return "ImgData"
        }

	}

	export class ImgData extends CodecData implements IImgData{

        /**@protected*/  _iHeight: number =0;
		/**@protected*/  _iWidth: number =0;
		/**@protected*/  _iDepth: number =1;
		/**@protected*/  _iSize: number =0;
        /**@protected*/  _iCubeFlags: number ;

		/**@protected*/  _nMipMaps: number =0;
		/**@protected*/  _iFlags: number =0;

		/**@protected*/  _eFormat: EPixelFormats=EPixelFormats.UNKNOWN;


		inline get width():  number  {
			return this._iWidth;
		}
    	inline set width(iWidth: number ){
			this._iWidth=iWidth;
		}


    	inline get height():  number  {
    		return this._iHeight;
    	}
    	inline set height(iHeight: number ){
			this._iHeight=iHeight;
		}

    	inline get depth():  number  {
    		return this._iDepth;
    	}
    	inline set depth(iDepth: number ){
			this._iDepth=iDepth;
		}


    	inline get size():  number  {
    		return core.pool.resources.Img.calculateSize(this.numMipMaps, this.numFace, this.width, this.height, this.depth, this.format);
        }

    	inline get numMipMaps():  number
    	{
    		return this._nMipMaps;
    	}

    	inline set numMipMaps(nNumMipMaps: number ) {
    		this._nMipMaps=nNumMipMaps;
    	}

    	inline get format(): EPixelFormats {
    		return this._eFormat;
    	}

    	inline set format(ePixelFormat:EPixelFormats){
    		this._eFormat=ePixelFormat;
    	}

        inline get flags():  number  {
            return this._iFlags;
        }

        inline set flags(iFlags: number ){
            this._iFlags=iFlags;
        }

        inline get cubeFlags():  number  {
            return this._iCubeFlags;
        }

        inline set cubeFlags(iFlags: number ){
            this._iCubeFlags=iFlags;
        }

        inline get numFace(): number {
            if (this._iFlags&EImageFlags.CUBEMAP)
            {
                var nFace: number =0;
                for(var i: number =0;i<32;i++)
                {
                    nFace++;
                }
                return nFace;
            }
            else
            {
                return 1;
            }
        }

        inline get dataType():string
        {
             return "ImgData";
        }
	}
}








module akra.core.pool.resources {

	export class Img extends ResourcePoolItem implements IImg {
		/**@protected*/  _iWidth:         number           = 0;
		/**@protected*/  _iHeight:        number           = 0;
		/**@protected*/  _iDepth:         number           = 0;

		/**@protected*/  _nMipMaps:       number           = 0;
		/**@protected*/  _iFlags:         number           = 0;
        /**@protected*/  _iCubeFlags:     number           = 0;

		/**@protected*/  _eFormat:       EPixelFormats = EPixelFormats.UNKNOWN;

		/**@protected*/  _pBuffer:       Uint8Array    = null;

        inline get byteLength():  number  {
			return this._pBuffer.buffer.byteLength;
		}

    	inline get width():  number  {
    		return this._iWidth;
    	}

    	inline get height():  number  {
    		return this._iHeight;
    	}

    	inline get depth():  number  {
    		return this._iDepth;
    	}

    	inline get numFaces(): number {
            if (this._iFlags&EImageFlags.CUBEMAP){
                var nFace: number =0;
                for(var i: number =0;i<32;i++)
                {
                    nFace++;
                }
                return nFace;
            }
            else
            {
                return 1;
            }
        }

    	inline get numMipMaps():  number  {
    		return this._nMipMaps;
    	}

    	inline get format(): EPixelFormats {
    		return this._eFormat;
    	}

         inline get flags():  number  {
            return this._iFlags;
        }

        inline get cubeFlags():  number  {
            return this._iCubeFlags;
        }

		constructor () {
			super();
		}

		createResource(): bool {
// innitialize the resource (called once)
		    logger.setSourceLocation( "resources/Img.ts" , 81 ); logger.assert(!this.isResourceCreated(), "The resource has already been created.");
                                                            ;

// signal that the resource is now created,
// but has not been enabled
		    this.notifyCreated();
		    this.notifyDisabled();

		    return true;
		}

		destroyResource(): bool {
// destroy the resource
//
// we permit redundant calls to destroy, so there are no asserts here
//
		    if (this.isResourceCreated()) {
// disable the resource
		        this.disableResource();

		        this.freeMemory();

		        this.notifyUnloaded();
		        this.notifyDestroyed();

		        return (true);
		    }

		    return (false);
		}

		restoreResource(): bool {
			logger.setSourceLocation( "resources/Img.ts" , 113 ); logger.assert(this.isResourceCreated(), "The resource has not been created.");
                                                        ;

		    this.notifyRestored();
		    return true;
		}

		disableResource(): bool {
			logger.setSourceLocation( "resources/Img.ts" , 121 ); logger.assert(this.isResourceCreated(), "The resource has not been created.");
                                                      ;

		    this.notifyDisabled();
		    return true;
		}

		loadResource(sFilename?: string): bool {
			return false;
		}

		saveResource(sFilename?: string): bool {
			return false;
		}


		create(iWidth:  number , iHeight:  number , iDepth?:  number  = 1, eFormat?: EPixelFormats = EPixelFormats.BYTE_ABGR,
                         nFaces?:  number  = 1, nMipMaps?:  number  = 0): IImg
        {
            var iSize :  number = Img.calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat);
            var pBuffer : Uint8Array = new Uint8Array(iSize);
            return this.loadDynamicImage(pBuffer, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
        }



    	freeMemory(): void {
    		this._iWidth = 0;
    		this._iHeight = 0;
    		this._iDepth = 0;
    		this._pBuffer = null;
    	}

    	set(pSrc: IImg): IImg {
    		this.freeMemory();

    		this._iWidth = pSrc.width;
    		this._iHeight = pSrc.height;
    		this._iDepth = pSrc.depth;
    		this._eFormat = pSrc.format;

    		this._iFlags = pSrc.flags;

    		this._nMipMaps = pSrc.numMipMaps;

    		this._pBuffer = new Uint8Array(pSrc.getData());

    		return this;
    	}


    	flipY(pDest?: IImg): IImg {
    		return this;
    	}

    	flipX(pDest?: IImg): IImg {
    		return this;
    	}

        load(sFileName: string,  fnCallBack?: Function): IImg;
        load(pData: Uint8Array, sType:string,  fnCallBack?: Function): IImg;
        load(pCanvas: HTMLCanvasElement, fnCallBack?: Function): IImg;


    	load(pData: any, sType?: any, fnCallBack?: Function): IImg
        {
            var pMe:IImg=this;

            if (pData instanceof HTMLCanvasElement)
            {
                var pTempContext : CanvasRenderingContext2D = pData.getContext('2d');
                if (!pTempContext)
                {
                    if (isDefAndNotNull(sType))
                    {
                        sType(false);
                    }
                    return this;
                }

                var pImageData : ImageData = pTempContext.getImageData(0, 0, pData.width, pData.height);

                this.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)),pData.width,pData.height);

                if (isDefAndNotNull(sType))
                {
                    sType(true);
                }
                return this;
            }
            else if (isString(pData))
            {

                var sExt : string = (new Pathinfo(pData)).ext;
                if(sExt=="png" || sExt=="jpg" || sExt=="jpeg" || sExt=="gif" || sExt=="bmp")
                {
                    var pImg:HTMLImageElement=new Image();

                    pImg.onload = function()
                    {
                        var pTempCanvas: HTMLCanvasElement=<HTMLCanvasElement>document.createElement("canvas");
                        pTempCanvas.width=pImg.width;
                        pTempCanvas.height=pImg.height;
                        var pTempContext : CanvasRenderingContext2D=<CanvasRenderingContext2D>((<any>pTempCanvas).getContext("2d"));
                        pTempContext.drawImage(pImg,0,0);
                        var pImageData : ImageData = pTempContext.getImageData(0, 0, pImg.width, pImg.height);

                        pMe.loadDynamicImage(new Uint8Array(pImageData.data.buffer.slice(0, pImageData.data.buffer.byteLength)),pImg.width, pImg.height,1,EPixelFormats.BYTE_ABGR);

                        if (isDefAndNotNull(sType))
                        {
                            sType(true);
                        }

                    }
                    pImg.onerror=function()
                    {
                        if (isDefAndNotNull(sType))
                        {
                            sType(false);
                        }
                    }
                    pImg.onabort=function()
                    {
                        if (isDefAndNotNull(sType))
                        {
                            sType(false);
                        }
                    }
                    pImg.src = pData;

                }
                else
                {

                    io.fopen(pData,"rb").onread=function(pError:Error,pDataInFile:ArrayBuffer)
                    {

                        pMe.load(new Uint8Array(pDataInFile),sExt,sType);
                    }
                }

                return this;
            }
            else
            {
                var pCodec:ICodec=undefined;

                if(sType)
                {
                    pCodec=Codec.getCodec(sType);
                }

                if(!pCodec)
                {
                    var iMagicLen: number =Math.min(32,pData.buffer.byteLength);
                    pCodec=Codec.getCodec(pData.buffer.slice(0,iMagicLen));
                }

                if(!pCodec)
                {
                    logger.setSourceLocation( "resources/Img.ts" , 281 ); logger.criticalError("Unable to load image: Image format is unknown. Unable to identify codec. Check it or specify format explicitly.\n"+"Img.load"); ;
                    if (fnCallBack)
                    {
                        fnCallBack(false);
                    }
                    return this;
                }



                var pImgData:IImgData=new ImgData();

                this._pBuffer=pCodec.decode(pData,pImgData);

                this._iWidth=pImgData.width;
                this._iHeight=pImgData.height;
                this._iDepth=pImgData.depth;
                this._nMipMaps=pImgData.numMipMaps;
                this._iFlags=pImgData.flags;
                this._iCubeFlags=pImgData.cubeFlags;

                this._eFormat=pImgData.format;

                if (fnCallBack)
                {
                    fnCallBack(true);
                }

                return this;
            }


    	}

    	loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number  = 1, eFormat: EPixelFormats = EPixelFormats.BYTE_BGR,
                         nFaces?:  number  = 1, nMipMaps?:  number  = 0): IImg
    	{
            var iSize :  number = Img.calculateSize(nMipMaps, nFaces, iWidth, iHeight, iDepth, eFormat);

            if (iSize != pData.buffer.byteLength)
            {
                logger.setSourceLocation( "resources/Img.ts" , 322 ); logger.criticalError("Stream size does not match calculated image size\n"+"Img.loadRawData"); ;
            }

            var pBuffer : Uint8Array = new Uint8Array(iSize);

            pBuffer.set(pData);

            return this.loadDynamicImage(pBuffer, iWidth, iHeight, iDepth, eFormat, nFaces, nMipMaps);
     	}

        loadDynamicImage(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth?:  number  = 1,
                         eFormat?: EPixelFormats = EPixelFormats.BYTE_BGR, nFaces?:  number  = 1, nMipMaps?:  number  = 0): IImg
        {
//size
            this._iWidth=iWidth;
            this._iHeight=iHeight;
            this._iDepth=iDepth;

            this._eFormat=eFormat;
            this._nMipMaps=nMipMaps;
            this._iFlags=0;

            if (pixelUtil.isCompressed(this._eFormat))
            {
                this._iFlags |= EImageFlags.COMPRESSED;
            }
            if (this._iDepth != 1)
            {
                this._iFlags |= EImageFlags.TEXTURE_3D;
            }

            if(nFaces == 6)
            {
                this._iFlags |= EImageFlags.CUBEMAP;
            }

            if(nFaces != 6 && nFaces != 1)
            {
                logger.setSourceLocation( "resources/Img.ts" , 360 ); logger.criticalError("Number of faces currently must be 6 or 1.\n"+"Img.loadDynamicImage"); ;
            }

            this._pBuffer=pData;
            return this;
        }

    	convert(eFormat: EPixelFormats): bool {
    		return false;
    	}

//Gets the physical width in bytes of each row of pixels.
    	getRawSpan():  number  {
    		return this._iWidth*this.getPixelSize();
    	}

    	getBPP():  number  {
    		return this.getPixelSize()* 8;
    	}

        getPixelSize():  number {
            return pixelUtil.getNumElemBytes(this._eFormat);
        }



    	getData(): Uint8Array {
    		return this._pBuffer;
    	}

    	hasFlag(eFlag: EImageFlags): bool
        {
    		if(this._iFlags & eFlag)
            {
                return true;
            }
            else
            {
                return false;
            }
    	}

    	hasAlpha(): bool {
    		return pixelUtil.hasAlpha(this._eFormat);
    	}

    	isCompressed(): bool {
    		return  pixelUtil.isCompressed(this._eFormat);
    	}

    	isLuminance(): bool {
    		return pixelUtil.isLuminance(this._eFormat);
    	}



    	getColorAt(pColor:IColor, x: number , y:  number , z?: number =0): IColor
        {
            var iStart: number =this.getPixelSize()* (z * this._iWidth * this._iHeight + this._iWidth * y + x);
    		pixelUtil.unpackColour(pColor, this._eFormat, this._pBuffer.subarray(iStart,iStart+this.getPixelSize()));
            return pColor;
    	}

    	setColorAt(pColor: IColor, x:  number , y:  number , z?:  number =0): void
        {
            var iStart: number =this.getPixelSize()* (z * this._iWidth * this._iHeight + this._iWidth * y + x);
            pixelUtil.packColour(pColor, this._eFormat,this._pBuffer.subarray(iStart,iStart+this.getPixelSize()));
    	}

    	getPixels(iFace?:  number , iMipMap?:  number ): IPixelBox
        {

// Image data is arranged as:
// face 0, top level (mip 0)
// face 0, mip 1
// face 0, mip 2
// face 1, top level (mip 0)
// face 1, mip 1
// face 1, mip 2
// etc

            if(iMipMap > this.numMipMaps){
                logger.setSourceLocation( "resources/Img.ts" , 442 ); logger.warning("Mipmap index out of range",iMipMap,this.numMipMaps); ;
                return null;
            }

            if(iFace >= this.numFaces){
                logger.setSourceLocation( "resources/Img.ts" , 447 ); logger.warning("Face index out of range",iFace,this.numFaces); ;
                return null;
            }

// Calculate mipmap offset and size
            var pData:Uint8Array = this.getData();


// Base offset is number of full faces
            var iWidth:  number  = this._iWidth;
            var iHeight:  number  = this._iHeight;
            var iDepth:  number  = this._iDepth;


// Figure out the offsets 
            var iFullFaceSize:  number  = 0;
            var iFinalFaceSize:  number  = 0;
            var iFinalWidth:  number  = 0;
            var iFinalHeight:  number  = 0 ;
            var iFinalDepth:  number  = 0;
            var iMipSize: number =0;
            var iOffset: number  = 0;

            for(var iMip: number =0; iMip <= this.numMipMaps; ++iMip)
            {
                if (iMip == iMipMap)
                {
                    iFinalFaceSize = iFullFaceSize;
                    iFinalWidth = iWidth;
                    iFinalHeight = iHeight;
                    iFinalDepth = iDepth;
                    iMipSize = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this.format);
                }
                iFullFaceSize += pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this.format);

/// Half size in each dimension
                if(iWidth!=1) iWidth /= 2;
                if(iHeight!=1) iHeight /= 2;
                if(iDepth!=1) iDepth /= 2;
            }
// Advance pointer by number of full faces, plus mip offset into
            iOffset += iFace * iFullFaceSize;
            iOffset += iFinalFaceSize;

// Return subface as pixelbox
            var pSrc:IPixelBox=new pixelUtil.PixelBox(iFinalWidth, iFinalHeight, iFinalDepth, this.format, pData.subarray(iOffset,iOffset+iMipSize));
            return pSrc;
    	}

    	scale(pDest: IPixelBox, eFilter?: EFilters): bool {
    		return null;
    	}

    	resize(iWidth:  number , iHeight:  number , eFilter?: EFilters): bool {
    		return null;
    	}

    	generatePerlinNoise(fScale:  number , iOctaves:  number , fFalloff:  number ): void {

    	}

    	randomChannelNoise(iChannel:  number , iMinRange:  number , iMaxRange:  number ): void {

    	}

        static calculateSize(nMipMaps:  number , nFaces:  number , iWidth:  number , iHeight:  number , iDepth:  number  , eFormat: EPixelFormats):  number
        {
            var iSize: number  = 0;
            var iMip: number  = 0;

            for(iMip=0; iMip<=nMipMaps; iMip++)
            {
                iSize += pixelUtil.getMemorySize(iWidth, iHeight, iDepth, eFormat)*nFaces;
                if(iWidth!=1) iWidth = Math.floor(iWidth/2);
                if(iHeight!=1) iHeight = Math.floor(iHeight/2);
                if(iDepth!=1) iDepth = Math.floor(iDepth/2);
            }
            return iSize;
        }

        static getMaxMipmaps(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats) :  number
        {
            var iCount:  number  = 0;
            if((iWidth > 0) && (iHeight > 0))
            {
                do {
                    if(iWidth>1)
                    {
                        iWidth = iWidth>>>1;
                    }
                    if(iHeight>1)
                    {
                        iHeight = iHeight>>>1;
                    }
                    if(iDepth>1)
                    {
                        iDepth = iDepth>>>1;
                    }
/*
                     NOT needed, compressed formats will have mipmaps up to 1x1
                     if(PixelUtil::isValidExtent(width, height, depth, format))
                     count ++;
                     else
                     break;
                     */


                    iCount ++;
                } while(!(iWidth === 1 && iHeight === 1 && iDepth === 1));
            }
            return iCount;
        }
	}
}











module akra.core.pool.resources {
	export class Component extends ResourcePoolItem implements IAFXComponent{
		private _pTechnique: IAFXTechniqueInstruction = null;
		private _pComposer: IAFXComposer = null;

		constructor(){
			super();
		}

		create(): void {
			this._pComposer = this.manager.getEngine().getComposer();
		}

		inline getTechnique(): IAFXTechniqueInstruction {
			return this._pTechnique;
		}

		inline setTechnique(pTechnique: IAFXTechniqueInstruction): void {
			this._pTechnique = pTechnique;
		}

		inline getName(): string {
			return this._pTechnique.getName();
		}

		inline getTotalPasses():  number  {
			return this._pTechnique.totalOwnPasses();
		}

		inline getHash(iShift:  number , iPass:  number ): string {
			return this.getGuid() + ">" + iShift.toString() +
				   ">" + (iPass ===  0xffffff  ? "A" : iPass.toString());
		}
	}
}
























module akra {
    export interface IRenderDataCollection {} ;
    export interface IDataFlow {} ;
    export interface IVertexDeclaration {} ;
    export interface IVertexData {} ;

	export enum ERenderDataTypes {
/*<! положить данные в текстуру, и больше ничего не делать.*/
        ISOLATED = 0,
/*<! обычные даннае из текстуры, доступные по индексу.*/
        INDEXED,
/*<! данные по 2йному индексу.*/
        I2I,
/*<! непосредственно данные для атрибута.*/
        DIRECT
    };

    export enum ERenderDataOptions {
/*<! использовать индекс на индекс упаковку данных*/
        ADVANCED_INDEX =  (1 << (0x10)) ,
        SINGLE_INDEX   =  (1 << (0x11)) ,
/*<! создать RenderData как классические данные, с данными только в аттрибутах, без использования видео буфферов.*/

/*<! определяет, будет ли объект редерится*/
        RENDERABLE     =  (1 << (0x12))
    }

    export interface IRenderDataType {
        new (): IRenderData;
    }

	export interface IRenderData extends IReferenceCounter {
		 buffer: IRenderDataCollection;

/**
         * Allocate data for rendering.
         */

        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBuffer, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBufferView, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, hasIndex?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, hasIndex?: bool):  number ;

/**
         * Remove data from this render data.
         */

        releaseData(iDataLocation:  number ): void;

        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;

        allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
        allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
        allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;

        addIndexSet(usePreviousDataSet?: bool, ePrimType?: EPrimitiveTypes, sName?: string):  number ;
        getNumIndexSet():  number ;
        getIndexSetName(iSet:  number ): string;
        selectIndexSet(iSet:  number ): bool;
        selectIndexSet(sName: string): bool;
        getIndexSet():  number ;

/**
         * Specifies uses advanced index.
         */

        hasAttributes(): bool;
        useAdvancedIndex(): bool;
        useSingleIndex(): bool;
        useMultiIndex(): bool;

/** mark index set as renderable */

        setRenderable(iIndexSet:  number , bValue: bool): void;
        isRenderable(iIndexSet:  number ): bool;

/** Mark this RenderData as renderable. */

        isRenderable(): bool;
        setRenderable(bValue: bool): void;

        hasSemantics(sSemantics: string, bSearchComplete?: bool): bool;

        getDataLocation(iDataLocation:  number ):  number ;
        getDataLocation(sSemantics: string):  number ;
        getIndices(): IBufferData;
        getPrimitiveCount():  number ;
        getAdvancedIndexData(sSemantics: string): IVertexData;

        index(sData: string, sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool;
        index(iData:  number , sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool;


        toString(): string;

//applyMe(): bool;

        _draw(): void;

        _getFlow(iDataLocation:  number ): IDataFlow;
        _getFlow(sSemantics: string, bSearchComplete?: bool): IDataFlow;

        _getData(iDataLocation:  number , bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(sSemanticsn: string, bSearchOnlyInCurrentMap?: bool): IVertexData;

        _addData(pVertexData: IVertexData, iFlow?:  number , eType?: ERenderDataTypes):  number ;

        _setup(pCollection: IRenderDataCollection, iId:  number , ePrimType?: EPrimitiveTypes, eOptions?:  number ): bool;

//FIXME: hack for terrain, for force limitin drawing index length
        _setIndexLength(iLength:  number );
	}
}







module akra {
    export interface IRenderDataCollection {} ;
    export interface ISkeleton {} ;
    export interface IRect3d {} ;
    export interface ISphere {} ;
    export interface IMeshSubset {} ;
    export interface ISceneNode {} ;
    export interface ISceneModel {} ;
    export interface ISkin {} ;

	export enum EMeshOptions {
        HB_READABLE = < number >EHardwareBufferFlags.READABLE,
        RD_ADVANCED_INDEX = < number >ERenderDataOptions.ADVANCED_INDEX
    };

    export enum EMeshCloneOptions{
/*<! copy only geometry*/
        GEOMETRY_ONLY = 0x00,
/*<! use shared geometry*/
        SHARED_GEOMETRY = 0x01
    };

    export interface IMeshMap {
        [name: string]: IMesh;
    }

	export interface IMesh extends IEventProvider {
         flexMaterials: IMaterial[];
         name: string;
         data: IRenderDataCollection;
/*<! number of submeshes in. */
         length:  number ;
         boundingBox: IRect3d;
         boundingSphere: ISphere;

		skeleton: ISkeleton;


        getOptions():  number ;
        getEngine(): IEngine;

//setup(sName: string, eOptions: int, pDataBuffer?: IRenderDataCollection): bool;
        destroy(): void;
        clone(iCloneOptions:  number ): IMesh;

/** @deprecated */

        replaceFlexMaterials(pFlexMaterials): void;
/** @deprecated */

        getFlexMaterial(iMaterial:  number ): IMaterial;
        getFlexMaterial(csName: string): IMaterial;
/** @deprecated */

        addFlexMaterial(sName: string, pMaterial?: IMaterial): bool;
/** @deprecated */

        setFlexMaterial(iMaterial:  number ): bool;
        setFlexMaterial(csName: string): bool;

        createSubset(sName: string, ePrimType: EPrimitiveTypes, eOptions?:  number );
        freeSubset(sName: string): bool;
        getSubset(sMesh: string): IMeshSubset;
        getSubset(i:  number ): IMeshSubset;
        appendSubset(sName: string, pData: IRenderData): IMeshSubset;

        setSkin(pSkin: ISkin): void;
        setSkeleton(pSkeleton: ISkeleton): void;
        createSkin(): ISkin;

        createBoundingBox(): bool;
        deleteBoundingBox(): bool;
        showBoundingBox(): bool;
        hideBoundingBox(): bool;
        createAndShowSubBoundingBox(): void;

        createBoundingSphere(): bool;
        deleteBoundingSphere(): bool;
        showBoundingSphere(): bool;
        hideBoundingSphere(): bool;
        createAndShowSubBoundingSphere(): void;

/** TRUE if only one mesh subset has a shadow. */

        hasShadow(): bool;
/** Add shadow for all subsets. */

        setShadow(bValue?: bool): void;

        isReadyForRender(): bool;

        toSceneModel(pParent: ISceneNode, sName?: string): ISceneModel;

        _drawSubset(iSubset:  number ): void;
        _draw(): void;

/** notify, when one of substets added or removed shadow */

         shadow(pSubset: IMeshSubset, bShadow: bool): void;
	}
}











module akra {
    export interface IVertexBuffer {} ;
    export interface IVertexDeclaration {} ;
    export interface IRenderDataType {} ;
    export interface IBuffer {} ;
    export interface IReferenceCounter {} ;

	export enum ERenderDataBufferOptions {
        VB_READABLE       = < number >EHardwareBufferFlags.READABLE,
        RD_ADVANCED_INDEX = < number >ERenderDataOptions.ADVANCED_INDEX,
        RD_SINGLE_INDEX   = < number >ERenderDataOptions.SINGLE_INDEX,
        RD_RENDERABLE     = < number >ERenderDataOptions.RENDERABLE
    };

// export interface IRenderDataType {
//     new (): IRenderData;
// }

/*IHardwareBuffer*/
	export interface IRenderDataCollection extends                    IBuffer, IReferenceCounter {
		 buffer: IVertexBuffer;
         byteLength:  number ;
         length:  number ;

        getEngine(): IEngine;
        getOptions():  number ;

        getData(sUsage: string): IVertexData;
        getData(iOffset:  number ): IVertexData;
        getRenderData(iSubset:  number ): IRenderData;
        getEmptyRenderData(ePrimType: EPrimitiveTypes, eOptions: ERenderDataBufferOptions): IRenderData;
        getDataLocation(sSemantics: string):  number ;

        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, isCommon?: bool):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, isCommon?: bool):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView, isCommon?: bool):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer, isCommon?: bool):  number ;

        destroy(): void;

        _draw(): void;
        _draw(iSubset:  number ): void;

// _setup(eOptions?: int): void;

        _allocateData(pVertexDecl: IVertexDeclaration, iSize:  number ): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBuffer): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], iSize:  number ): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer): IVertexData;
	}
}











module akra {
	export interface IAnimationFrame {} ;
	export interface ISkeleton {} ;
	export interface ISceneNode {} ;
	export interface IMat4 {} ;

	export interface IAnimationTrack {
		targetName: string;

		 target: ISceneNode;
		 duration:  number ;

/** Get keyframe by number */

		getKeyFrame(iFrame:  number ): IAnimationFrame;
/** Set keyframe */

		keyFrame(fTime:  number , pMatrix: IMat4): bool;
/** Find keyframe by time */

		findKeyFrame(fTime:  number ):  number ;
/** Calculate frame by time */

		frame(fTime:  number ): IAnimationFrame;

		bind(sJoint: string, pSkeleton: ISkeleton);
		bind(pSkeleton: ISkeleton);
		bind(pNode: ISceneNode);

	}
}
















module akra {

	export interface IExplorerFunc {} ;
	export interface IReferenceCounter {} ;

	export enum  EEntityTypes {
		UNKNOWN,
		NODE,

		JOINT,

		SCENE_NODE,

		CAMERA,
		SHADOW_CASTER,

		LIGHT_PROJECT = 37,
		LIGHT_OMNI_DIRECTIONAL,

		SCENE_OBJECT = 64,

		MODEL,
		TERRAIN_SECTION,
		TEXT3D,
		SPRITE,
		EMITTER,

		UI_NODE = 100,
// UI_HTMLNODE,
// UI_DNDNODE,

// UI_COMPONENT,
// UI_BUTTON,
// UI_LABEL,
// UI_TREE,

		OBJECTS_LIMIT = 128
	}

	export interface IEntity extends IEventProvider, IReferenceCounter {
		name: string;

		parent: IEntity;
		sibling: IEntity;
		child: IEntity;

		 rightSibling: IEntity;

		 type: EEntityTypes;

		 depth:  number ;
		 root: IEntity;

//create(): bool;//moved to INode
		destroy(): void;

		findEntity(sName: string): IEntity;
		explore(fn: IExplorerFunc): void;
		childOf(pParent: IEntity): bool;
		siblingCount():  number ;
		childCount():  number ;
		children(): IEntity[];
		childAt(i:  number ): IEntity;
		descCount():  number ;

		update(): bool;
		recursiveUpdate(): bool;
		recursivePreUpdate(): void;
		prepareForUpdate(): void;

		hasParent(): bool;
		hasChild(): bool;
		hasSibling(): bool;

		isASibling(pSibling: IEntity): bool;
		isAChild(pChild: IEntity): bool;
		isInFamily(pEntity: IEntity, bSearchEntireTree?: bool): bool;

//обновлен ли сам узел
		isUpdated(): bool;
//есть ли обновления среди потомков?
		hasUpdatedSubNodes(): bool;


		addSibling(pSibling: IEntity): IEntity;
		addChild(pChild: IEntity): IEntity;
		removeChild(pChild: IEntity): IEntity;
		removeAllChildren(): void;

		attachToParent(pParent: IEntity): bool;
		detachFromParent(): bool;

		promoteChildren(): void;
		relocateChildren(pParent: IEntity): void;

		toString(isRecursive?: bool, iDepth?:  number ): string;

		 attached(): void;
		 detached(): void;

		 childAdded(pChild: IEntity): void;
		 childRemoved(pChild: IEntity): void;
	}

}



module akra {

	export interface IVec3 {} ;
	export interface IMat3 {} ;
	export interface IMat4 {} ;
	export interface IQuat4 {} ;

	export enum ENodeInheritance {
//inheritance only position
		POSITION = 0,
//inheritance rotation and scale only
        ROTSCALE,
//inheritance all
    	ALL
	};

	export interface INodeMap{
		[index: string]: INode;
	}

	export interface INode extends IEntity {
		localOrientation: IQuat4;
		localPosition: IVec3;
		localScale: IVec3;
		localMatrix: IMat4;

		 worldMatrix: IMat4;
		 worldPosition: IVec3;

		 inverseWorldMatrix: IMat4;
		 normalMatrix: IMat3;

		create(): bool;

		setInheritance(eInheritance: ENodeInheritance);
		getInheritance(): ENodeInheritance;

		isWorldMatrixNew(): bool;
		isLocalMatrixNew(): bool;

//recalcWorldMatrix(): bool;

		setPosition(v3fPosition: IVec3): void;
		setPosition(fX:  number , fY:  number , fZ:  number ): void;

		addPosition(v3fPosition: IVec3): void;
		addPosition(fX:  number , fY:  number , fZ:  number ): void;
		addRelPosition(v3fPosition: IVec3): void;
		addRelPosition(fX:  number , fY:  number , fZ:  number ): void;

		setRotationByMatrix(m3fRotation: IMat3): void;
		setRotationByMatrix(m4fRotation: IMat4): void;
		setRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		setRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		setRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		setRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		setRotation(q4fRotation: IQuat4): void;

		addRelRotationByMatrix(m4fRotation: IMat4): void;
		addRelRotationByMatrix(m3fRotation: IMat3): void;
		addRelRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		addRelRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		addRelRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		addRelRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		addRelRotation(q4fRotation: IQuat4): void;

		addRotationByMatrix(m4fRotation: IMat4): void;
		addRotationByMatrix(m3fRotation: IMat3): void;
		addRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void;
		addRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void;
		addRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void;
		addRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void;
		addRotation(q4fRotation: IQuat4): void;

		scale(fScale:  number ): void;
		scale(fX:  number , fY:  number , fZ:  number ): void;
	}
}



module akra {
    export interface ISceneNodeMap {
        [index: string]: ISceneNode;
    }

    export interface ISceneNode extends INode {
    	scene: IScene3d;

/** @deprecated */

    	render(): void;
/** @deprecated */

    	prepareForRender(): void;
/** @deprecated */

    	recursiveRender(): void;
    }
}













module akra {
	export interface INode {} ;
	export interface IJoint {} ;

	export interface IJointMap{
		[index: string]: IJoint;
	}



	export interface ISkeleton {
		 totalBones:  number ;
		 totalNodes:  number ;
		 name: string;
		 root: IJoint;

		getRootJoint(): IJoint;
		getRootJoints(): IJoint[];
		getJointMap(): IJointMap;
		getNodeList(): ISceneNode[];
		addRootJoint(pJoint: IJoint): bool;
		update(): bool;
		findJoint(sName: string): IJoint;
		findJointByName(sName: string): IJoint;
		attachMesh(pMesh: IMesh): bool;
		detachMesh(): void;

	}
}















module akra {
	export interface IEngine {} ;

	export interface IJoint extends ISceneNode {
		boneName: string;
// getEngine(): IEngine;
		create(): bool;
// toString(isRecursive: bool, iDepth: int): string;
	}
}































module akra {

	export interface IEntity {} ;

	export interface IExplorerFunc {
		(pEntity: IEntity): bool;
	}
}







module akra.util {
	export enum EEntityStates {
//обновился ли сам узел?
		k_Updated = 0x01,
//есть ли среди потомков обновленные узлы
		k_DescendantsUpdtated = 0x02,
//если ли обновленные узлы среди братьев или их потомках
		k_SiblingsUpdated = 0x04
	}

	export class Entity extends ReferenceCounter implements IEntity {
		/**@protected*/  _sName: string = null;
		/**@protected*/  _pParent: IEntity = null;
		/**@protected*/  _pSibling: IEntity = null;
		/**@protected*/  _pChild: IEntity = null;
		/**@protected*/  _eType: EEntityTypes = EEntityTypes.UNKNOWN;
		/**@protected*/  _iStateFlags:  number  = 0;

		inline get name(): string { return this._sName; }
		inline set name(sName: string) { this._sName = sName; }

		inline get parent(): IEntity { return this._pParent; }
		inline set parent(pParent: IEntity) { this.attachToParent(pParent); }

		inline get sibling(): IEntity { return this._pSibling; }
		inline set sibling(pSibling: IEntity) { this._pSibling = pSibling; }

		inline get child(): IEntity { return this._pChild; }
		inline set child(pChild: IEntity) { this._pChild = pChild; }

		inline get type(): EEntityTypes { return this._eType; }

		get rightSibling(): IEntity {
			var pSibling: IEntity = this.sibling;

			if (pSibling) {
				while (pSibling.sibling) {
					pSibling = pSibling.sibling;
				}

				return pSibling;
			}

			return this;
		}

		constructor (eType: EEntityTypes) {
			super();
			this._eType = eType;
		}

		get depth():  number  {
			var iDepth:  number  = -1;
	        for (var pEntity: IEntity = this; pEntity; pEntity = pEntity.parent, ++ iDepth){};
	        return iDepth;
		}

		get root(): IEntity {
	        for (var pEntity: IEntity = this, iDepth:  number  = -1; pEntity.parent; pEntity = pEntity.parent, ++ iDepth){};
	        return pEntity;
		}



		destroy(): void {
// destroy anything attached to this node
//	destroySceneObject();
// promote any children up to our parent
		    this.promoteChildren();
// now remove ourselves from our parent
		    this.detachFromParent();
// we should now be removed from the tree, and have no dependants
		    logger.setSourceLocation( "util/Entity.ts" , 81 ); logger.assert(this.referenceCount() == 0, "Attempting to delete a scene node which is still in use"); ;
		    logger.setSourceLocation( "util/Entity.ts" , 82 ); logger.assert(this._pSibling == null, "Failure Destroying Node"); ;
		    logger.setSourceLocation( "util/Entity.ts" , 83 ); logger.assert(this._pChild == null, "Failure Destroying Node"); ;
		}

		findEntity(sName: string): IEntity {
			 var pEntity: IEntity = null;

		    if (this._sName === sName) {
		        return this;
		    }

		    if (this._pSibling) {
		        pEntity = this._pSibling.findEntity(sName);
		    }

		    if (pEntity == null && this._pChild) {
		        pEntity = this._pChild.findEntity(sName);
		    }

		    return pEntity;
		}

		explore(fn: IExplorerFunc): void {
			if (fn(this) === false) {
		        return;
		    }

		    if (this._pSibling) {
		        this._pSibling.explore(fn);
		    }

		    if (this._pChild) {
		        this._pChild.explore(fn);
		    }
		}


		childOf(pParent: IEntity): bool {
			for (var pEntity: IEntity = this; pEntity; pEntity = pEntity.parent) {
		        if (pEntity.parent === pParent) {
		            return true;
		        }
		    }

		    return false;
		}

		children(): IEntity[] {
			var pChildren: IEntity[] = [];
			var pChild: IEntity = this.child;

			while (!isNull(pChild)) {
				pChildren.push(pChild);
				pChild = pChild.sibling;
			}

			return pChildren;
		}

		childAt(i:  number ): IEntity {
			var pChild: IEntity = this.child;
			var n:  number  = 0;

			while (!isNull(pChild)) {
				if (n == i) {
					return pChild;
				}
				n ++;
				pChild = pChild.sibling;
			}

			return pChild;
		}

/**
		 * Returns the current number of siblings of this object.
		 */

		siblingCount():  number  {
			var iCount:  number  = 0;

		    if (this._pParent) {
		        var pNextSibling = this._pParent.child;
		        if (pNextSibling) {
		            while (pNextSibling) {
		                pNextSibling = pNextSibling.sibling;
		                ++ iCount;
		            }
		        }
		    }

		    return iCount;
		}


		descCount():  number  {
			var n:  number  = this.childCount();
			var pChild: IEntity = this.child;

			while(!isNull(pChild)) {
				n += pChild.descCount();
				pChild = pChild.sibling;
			}

			return n;
		}

/**
		 * Returns the current number of children of this object
		 */

		childCount():  number  {
			var iCount:  number  = 0;
			var pChild: IEntity = this.child;

			while(!isNull(pChild)) {
				iCount ++;
				pChild = pChild.sibling;
			}

// var pNextChild: IEntity = this.child;

// if (pNextChild) {
//     ++ iCount;
//     while (pNextChild) {
//         pNextChild = pNextChild.sibling;
//         ++ iCount;
//     }
// }
		    return iCount;
		}

		inline isUpdated(): bool {
			return  ((this._iStateFlags & (1 << (EEntityStates.k_Updated)) ) != 0) ;
		}

		inline hasUpdatedSubNodes(): bool {
			return  ((this._iStateFlags & (1 << (EEntityStates.k_DescendantsUpdtated)) ) != 0) ;
		}

		recursiveUpdate(): bool {
// var bUpdated: bool = false;
// update myself
		    if (this.update()) {
		    	((this._iStateFlags) |= (EEntityStates.k_Updated)) ;
// bUpdated = true;
		    }
// update my sibling
		    if (this._pSibling && this._pSibling.recursiveUpdate()) {
		        ((this._iStateFlags) |= (EEntityStates.k_SiblingsUpdated)) ;
// bUpdated = true;
		    }
// update my child
		    if (this._pChild && this._pChild.recursiveUpdate()) {
		        ((this._iStateFlags) |= (EEntityStates.k_DescendantsUpdtated)) ;
// bUpdated = true;
		    }

/*bUpdated*/
/* */
		    return (this._iStateFlags != 0);
		}

		recursivePreUpdate(): void {
// clear the flags from the previous update
		    this.prepareForUpdate();

// update my sibling
		    if (this._pSibling) {
		        this._pSibling.recursivePreUpdate();
		    }
// update my child
		    if (this._pChild) {
		        this._pChild.recursivePreUpdate();
		    }
		}


		prepareForUpdate(): void {
//this._iStateFlags = 0;
		};

/** Parent is not undef */

		inline hasParent(): bool {
		    return isDefAndNotNull(this._pParent);
		}

/** Child is not undef*/

		inline hasChild(): bool {
		    return isDefAndNotNull(this._pChild);
		}

/** Sibling is not undef */

		inline hasSibling(): bool {
			return isDefAndNotNull(this._pSibling);
		}

/**
		 * Checks to see if the provided item is a sibling of this object
		 */

		isASibling(pSibling: IEntity): bool {
			if (!pSibling) {
		        return false;
		    }
// if the sibling we are looking for is me, or my FirstSibling, return true
		    if (this == pSibling || this._pSibling == pSibling) {
		        return true;
		    }
// if we have a sibling, continue searching
		    if (this._pSibling) {
		        return this._pSibling.isASibling(pSibling);
		    }
// it's not us, and we have no sibling to check. This is not a sibling of ours.
		    return false;
		}

/** Checks to see if the provided item is a child of this object. (one branch depth only) */

		isAChild(pChild: IEntity): bool {
			if (!pChild) {
		        return (false);
		    }
// if the sibling we are looking for is my FirstChild return true
		    if (this._pChild == pChild) {
		        return (true);
		    }
// if we have a child, continue searching
		    if (this._pChild) {
		        return (this._pChild.isASibling(pChild));
		    }
// it's not us, and we have no child to check. This is not a sibling of ours.
		    return (false);
		}

/**
		 * Checks to see if the provided item is a child or sibling of this object. If SearchEntireTree
		 * is TRUE, the check is done recursivly through all siblings and children. SearchEntireTree
		 * is FALSE by default.
		 */

		isInFamily(pEntity: IEntity, bSearchEntireTree?: bool): bool {
			if (!pEntity) {
		        return (false);
		    }
// if the model we are looking for is me or my immediate family, return true
		    if (this == pEntity || this._pChild == pEntity || this._pSibling == pEntity) {
		        return (true);
		    }
// if not set to seach entire tree, just check my siblings and kids
		    if (!bSearchEntireTree) {
		        if (this.isASibling(pEntity)) {
		            return (true);
		        }
		        if (this._pChild && this._pChild.isASibling(pEntity)) {
		            return (true);
		        }
		    }
// seach entire Tree!!!
		    else {
		        if (this._pSibling && this._pSibling.isInFamily(pEntity, bSearchEntireTree)) {
		            return (true);
		        }

		        if (this._pChild && this._pChild.isInFamily(pEntity, bSearchEntireTree)) {
		            return (true);
		        }
		    }

		    return (false);
		}

/**
		 * Adds the provided ModelSpace object to the descendant list of this object. The provided
		 * ModelSpace object is removed from any parent it may already belong to.
		 */

		addSibling(pSibling: IEntity): IEntity {
			if (pSibling) {
// replace objects current sibling pointer with this new one
		        pSibling.sibling = this._pSibling;
		        this.sibling = pSibling;
		    }

		    return pSibling;
		}

/**
		 * Adds the provided ModelSpace object to the descendant list of this object. The provided
		 * ModelSpace object is removed from any parent it may already belong to.
		 */

		addChild(pChild: IEntity): IEntity {
			if (pChild) {
// Replace the new child's sibling pointer with our old first child.
		        pChild.sibling = this._pChild;
// the new child becomes our first child pointer.
		        this._pChild = pChild;
		        this.childAdded(pChild);
    		}

    		return pChild;
		}

/**
		 * Removes a specified child object from this parent object. If the child is not the
		 * FirstChild of this object, all of the Children are searched to find the object to remove.
		 */

		removeChild(pChild: IEntity): IEntity {
			if (this._pChild && pChild) {
		        if (this._pChild == pChild) {
		            this._pChild = pChild.sibling;
		            pChild.sibling  = null;
		        }
		        else {
		            var pTempNode: IEntity = this._pChild;
// keep searching until we find the node who's sibling is our target
// or we reach the end of the sibling chain
		            while (pTempNode && (pTempNode.sibling != pChild)) {
		                pTempNode = pTempNode.sibling;
		            }
// if we found the proper item, set it's FirstSibling to be the FirstSibling of the child
// we are removing
		            if (pTempNode) {
		                pTempNode.sibling = pChild.sibling;
		                pChild.sibling = null;
		            }
		        }

		        this.childRemoved(pChild);
	    	}

	    	return pChild;
		}

/** Removes all Children from this parent object */

		removeAllChildren(): void {
// keep removing children until end of chain is reached
		    while (!isNull(this._pChild)) {
		        var pNextSibling = this._pChild.sibling;
		        this._pChild.detachFromParent();
		        this._pChild = pNextSibling;
		    }
		}

/** Attaches this object ot a new parent. Same as calling the parent's addChild() routine. */

		attachToParent(pParent: IEntity): bool {

			var pParentPrev: IEntity = this.parent;

			if (pParent != this._pParent) {

		        this.detachFromParent();

		        if (pParent) {
		            if (pParent.addChild(this)) {
			            this._pParent = pParent;
			            this._pParent.addRef();
			            this.attached();
		            	return true;
		            }

		            return this.attachToParent(pParentPrev);
		        }
	    	}

	    	return false;
		}

		detachFromParent(): bool {
// tell our current parent to release us
		    if (this._pParent) {
		        this._pParent.removeChild(this);
//TODO: разобраться что за херня!!!!
		        if (this._pParent) {
		            this._pParent.release();
		        }

		        this._pParent = null;
// my world matrix is now my local matrix
		        this.detached();
		        return true;
		    }

		    return false;
		}

/**
		 * Attaches this object's children to it's parent, promoting them up the tree
		 */

		promoteChildren(): void {
// Do I have any children to promote?
		    while (!isNull(this._pChild)) {
		        var pNextSibling: IEntity = this._pChild.sibling;
		        this._pChild.attachToParent(this._pParent);
		        this._pChild = pNextSibling;
		    }
		}

		relocateChildren(pParent: IEntity): void {
			if (pParent != this) {
// Do I have any children to relocate?
		        while (!isNull(this._pChild)) {
		            var pNextSibling: IEntity = this._pChild.sibling;
		            this._pChild.attachToParent(pParent);
		            this._pChild = pNextSibling;
		        }
		    }
		}

		update(): bool { return false; }

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {

		    if (!isRecursive) {
		        return '<entity' + (this._sName? ' ' + this._sName: "") + '>';
		    }

		    var pSibling: IEntity = this.sibling;
		    var pChild: IEntity = this.child;
		    var s: string = "";

		    for (var i = 0; i < iDepth; ++ i) {
		        s += ':  ';
		    }

		    s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';

		    if (pChild) {
		        s += pChild.toString(true, iDepth + 1);
		    }

		    if (pSibling) {
		        s += pSibling.toString(true, iDepth);
		    }

		    return s;


		}

		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return Entity._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;

		attached (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).attached; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
		detached (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).detached; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
		childAdded (child): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).childAdded; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier, child) : _unicast.listener (_recivier, child) ; } } ; ;
		childRemoved (child): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).childRemoved; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier, child) : _unicast.listener (_recivier, child) ; } } ; ;
	}
}






module akra.scene {

	export enum ENodeUpdateFlags {
		k_SetForDestruction = 0,
//if changed scale, otation or position
		k_NewOrientation,
// k_NewTranslation,
// k_NewScale,
		k_NewWorldMatrix,
		k_NewLocalMatrix,
		k_RebuildInverseWorldMatrix,
		k_RebuildNormalMatrix,
     };

	export class Node extends util.Entity implements INode {
		/**@protected*/  _m4fLocalMatrix: IMat4 = null;
		/**@protected*/  _m4fWorldMatrix: IMat4 = null;
		/**@protected*/  _m4fInverseWorldMatrix: IMat4 = null;
		/**@protected*/  _m3fNormalMatrix: IMat3 = null;

		/**@protected*/  _v3fWorldPosition: IVec3 = null;

		/**@protected*/  _qRotation: IQuat4 = null;
		/**@protected*/  _v3fTranslation: IVec3 = null;
		/**@protected*/  _v3fScale: IVec3 = null;

		/**@protected*/  _iUpdateFlags:  number  = 0;
		/**@protected*/  _eInheritance: ENodeInheritance = ENodeInheritance.POSITION;

		create(): bool {
			return true;
		}


		inline get localOrientation(): IQuat4 {
			return this._qRotation;
		}

		inline set localOrientation(qOrient: IQuat4) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._qRotation.set(qOrient);
		}

		inline get localPosition(): IVec3 {
			return this._v3fTranslation;
		}

		inline set localPosition(v3fPosition: IVec3) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._v3fTranslation.set(v3fPosition);
		}

		inline get localScale(): IVec3 {
			return this._v3fScale;
		}

		inline set localScale(v3fScale: IVec3) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
			this._v3fScale.set(v3fScale);
		}

		inline get localMatrix(): IMat4 {
			return this._m4fLocalMatrix;
		}

		inline set localMatrix(m4fLocalMatrix: IMat4) {
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewLocalMatrix))) ) ;
			this._m4fLocalMatrix.set(m4fLocalMatrix);
		}


		inline get worldMatrix(): IMat4 {
			return this._m4fWorldMatrix;
		}

		inline get worldPosition(): IVec3 {
			return this._v3fWorldPosition;
		}

		get inverseWorldMatrix(): IMat4 {
			if ( ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_RebuildInverseWorldMatrix)) ) != 0) ) {
		        this._m4fWorldMatrix.inverse(this._m4fInverseWorldMatrix);
		        ((this._iUpdateFlags) &= ~ (1 << ((ENodeUpdateFlags.k_RebuildInverseWorldMatrix))) ) ;
		    }

			return this._m4fInverseWorldMatrix;
		}

		get normalMatrix(): IMat3 {
			if ( ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_RebuildNormalMatrix)) ) != 0) ) {

		        this._m4fWorldMatrix.toMat3(this._m3fNormalMatrix).inverse().transpose();

		        ((this._iUpdateFlags) &= ~ (1 << ((ENodeUpdateFlags.k_RebuildNormalMatrix))) ) ;
		    }

			return this._m3fNormalMatrix;
		}


		update(): bool {
// derived classes update the local matrix
// then call this base function to complete
// the update
		    return this.recalcWorldMatrix();
		}


		prepareForUpdate(): void {
			super.prepareForUpdate();
// clear the temporary flags
			((this._iUpdateFlags) &= ~( (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) | (1 << (ENodeUpdateFlags.k_NewOrientation)) | (1 << (ENodeUpdateFlags.k_NewWorldMatrix)) ))
                                                                                            ;
		}


		inline setInheritance(eInheritance: ENodeInheritance) {
			this._eInheritance = eInheritance;
		}

		inline getInheritance(): ENodeInheritance {
			return this._eInheritance;
		}

		inline isWorldMatrixNew(): bool {
			return  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewWorldMatrix)) ) != 0) ;
		}

		inline isLocalMatrixNew(): bool {
			return  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) ) != 0) ;
		}

		private recalcWorldMatrix(): bool {
			var isParentMoved: bool = this._pParent && (<Node>this._pParent).isWorldMatrixNew();
		    var isOrientModified: bool =  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewOrientation)) ) != 0) ;
		    var isLocalModified: bool =  ((this._iUpdateFlags & (1 << (ENodeUpdateFlags.k_NewLocalMatrix)) ) != 0) ;

		    if (isOrientModified || isParentMoved || isLocalModified) {
		        var m4fLocal: IMat4 = this._m4fLocalMatrix;
		        var m4fWorld: IMat4 = this._m4fWorldMatrix;
		        var m4fParent: IMat4 = (<Node>this._pParent).worldMatrix;
		        var m4fOrient: IMat4 = Node._m4fTemp;
		        var v3fTemp: IVec3 = Node._v3fTemp;

		        var pWorldData: Float32Array = m4fWorld.data;
		        var pParentData: Float32Array = m4fParent.data;
		        var pOrientData: Float32Array = m4fOrient.data;

		        this._qRotation.toMat4(m4fOrient);

		        m4fOrient.setTranslation(this._v3fTranslation);
		        m4fOrient.scaleLeft(this._v3fScale);
		        m4fOrient.multiply(m4fLocal);

//console.error(m4fOrient.toString());

		        if (this._pParent) {
		            if (this._eInheritance === ENodeInheritance.ALL) {
		                m4fParent.multiply(m4fOrient, m4fWorld);
		            }
		            else if (this._eInheritance === ENodeInheritance.POSITION) {
		                m4fWorld.set(m4fOrient);

		                pWorldData[ 12 ] = pParentData[ 12 ] + pOrientData[ 12 ];
		                pWorldData[ 13 ] = pParentData[ 13 ] + pOrientData[ 13 ];
		                pWorldData[ 14 ] = pParentData[ 14 ] + pOrientData[ 14 ];
		            }
		            else if (this._eInheritance === ENodeInheritance.ROTSCALE) {
		                var p11 = pParentData[ 0 ], p12 = pParentData[ 4 ],
		                    p13 = pParentData[ 8 ];
		                var p21 = pParentData[ 1 ], p22 = pParentData[ 5 ],
		                    p23 = pParentData[ 9 ];
		                var p31 = pParentData[ 2 ], p32 = pParentData[ 6 ],
		                    p33 = pParentData[ 10 ];

		                var l11 = pOrientData[ 0 ], l12 = pOrientData[ 4 ],
		                    l13 = pOrientData[ 8 ];
		                var l21 = pOrientData[ 1 ], l22 = pOrientData[ 5 ],
		                    l23 = pOrientData[ 9 ];
		                var l31 = pOrientData[ 2 ], l32 = pOrientData[ 6 ],
		                    l33 = pOrientData[ 10 ];

		                pWorldData[ 0 ] = p11 * l11 + p12 * l21 + p13 * l31;
		                pWorldData[ 4 ] = p11 * l12 + p12 * l22 + p13 * l32;
		                pWorldData[ 8 ] = p11 * l13 + p12 * l23 + p13 * l33;
		                pWorldData[ 12 ] = pOrientData[ 12 ];
		                pWorldData[ 1 ] = p21 * l11 + p22 * l21 + p23 * l31;
		                pWorldData[ 5 ] = p21 * l12 + p22 * l22 + p23 * l32;
		                pWorldData[ 9 ] = p21 * l13 + p22 * l23 + p23 * l33;
		                pWorldData[ 13 ] = pOrientData[ 13 ];
		                pWorldData[ 2 ] = p31 * l11 + p32 * l21 + p33 * l31;
		                pWorldData[ 6 ] = p31 * l12 + p32 * l22 + p33 * l32;
		                pWorldData[ 10 ] = p31 * l13 + p32 * l23 + p33 * l33;
		                pWorldData[ 14 ] = pOrientData[ 14 ];

		                pWorldData[ 3 ] = pOrientData[ 3 ];
		                pWorldData[ 7 ] = pOrientData[ 7 ];
		                pWorldData[ 11 ] = pOrientData[ 11 ];
		                pWorldData[ 15 ] = pOrientData[ 15 ];
		            }
		        }
		        else {
		            m4fWorld.set(m4fOrient);
		        }

		        this._v3fWorldPosition.x = pWorldData[ 12 ];
		        this._v3fWorldPosition.y = pWorldData[ 13 ];
		        this._v3fWorldPosition.z = pWorldData[ 14 ];

// set the flag that our world matrix has changed
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewWorldMatrix))) ) ;
// and it's inverse & vectors are out of date
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_RebuildInverseWorldMatrix))) ) ;
		        ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_RebuildNormalMatrix))) ) ;

		        return true;
		    }

		    return false;
		}

		setPosition(v3fPosition: IVec3): void;
		setPosition(fX:  number , fY:  number , fZ:  number ): void;
		setPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]: vec3(fX, fY, fZ);
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    v3fTranslation.set(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addPosition(v3fPosition: IVec3): void;
		addPosition(fX:  number , fY:  number , fZ:  number ): void;
		addPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]: vec3(fX, fY, fZ);
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    v3fTranslation.add(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addRelPosition(v3fPosition: IVec3): void;
		addRelPosition(fX:  number , fY:  number , fZ:  number ): void;
		addRelPosition(fX?: any, fY?: any, fZ?: any): void {
			var pPos: IVec3 = arguments.length === 1? arguments[0]: vec3(fX, fY, fZ);
		    var v3fTranslation: IVec3 = this._v3fTranslation;

		    this._qRotation.multiplyVec3(pPos);
    		v3fTranslation.add(pPos);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByMatrix(m3fRotation: IMat3): void;
		setRotationByMatrix(m4fRotation: IMat4): void;
		setRotationByMatrix(matrix: any): void {
			matrix.toQuat4(this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			Quat4.fromAxisAngle(v3fAxis, fAngle, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			Quat4.fromForwardUp(v3fForward, v3fUp, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			Quat4.fromYawPitchRoll(fY, fX, fZ, this._qRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		setRotation(q4fRotation: IQuat4): void {
			this._qRotation.set(q4fRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addRelRotationByMatrix(m3fRotation: IMat3): void;
		addRelRotationByMatrix(m4fRotation: IMat4): void;
		addRelRotationByMatrix(matrix: any): void {
			this.addRelRotation(arguments[0].toQuat4(Node._q4fTemp));
		}

		addRelRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			this.addRelRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp));
		}

		addRelRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			this.addRelRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp));
		}

		addRelRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			this.addRelRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp));
		}

		addRelRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			this.addRelRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp));
		}

		addRelRotation(q4fRotation: IQuat4): void {
			this._qRotation.multiply(q4fRotation);
			((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}

		addRotationByMatrix(m3fRotation: IMat3): void;
		addRotationByMatrix(m4fRotation: IMat4): void;
		addRotationByMatrix(matrix: any): void {
			this.addRotation(arguments[0].toQuat4(Node._q4fTemp));
		}

		addRotationByAxisAngle(v3fAxis: IVec3, fAngle:  number ): void {
			this.addRotation(Quat4.fromAxisAngle(v3fAxis, fAngle, Node._q4fTemp));
		}

		addRotationByForwardUp(v3fForward: IVec3, v3fUp: IVec3): void {
			this.addRotation(Quat4.fromForwardUp(v3fForward, v3fUp, Node._q4fTemp));
		}

		addRotationByEulerAngles(fYaw:  number , fPitch:  number , fRoll:  number ): void {
			this.addRotation(Quat4.fromYawPitchRoll(fYaw, fPitch, fRoll, Node._q4fTemp));
		}

		addRotationByXYZAxis(fX:  number , fY:  number , fZ:  number ): void {
			this.addRotation(Quat4.fromYawPitchRoll(fY, fX, fZ, Node._q4fTemp));
		}

		addRotation(q4fRotation: IQuat4): void {
			q4fRotation.multiplyVec3(this._v3fTranslation);
    		q4fRotation.multiply(this._qRotation, this._qRotation);
    		((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}


		scale(fScale:  number ): void;
		scale(fX:  number , fY:  number , fZ:  number ): void;
		scale(fX: any, fY?: any, fZ?: any): void {
			var pScale: IVec3 = arguments.length === 1? arguments[0]: vec3(fX);
		    var v3fScale: IVec3 = this._v3fScale;

		    v3fScale.scale(pScale);

		    ((this._iUpdateFlags) |= (1 << ((ENodeUpdateFlags.k_NewOrientation))) ) ;
		}



		attachToParent(pParent: IEntity): bool {
			if (super.attachToParent(pParent)) {
// adjust my local matrix to be relative to this new parent
	            var m4fInvertedParentMatrix: IMat4 = mat4();
	            (<Node>this._pParent)._m4fWorldMatrix.inverse(m4fInvertedParentMatrix);
	            return true;
			}

			return false;
		}

		detachFromParent(): bool {
			if (super.detachFromParent()) {
				this._m4fWorldMatrix.identity();
				return true;
			}

			return false;
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {


		    if (!isRecursive) {
		        return '<node' + (this.name? " " + this.name: "") + '>';
		    }

		    var pSibling: IEntity = this.sibling;
		    var pChild: IEntity = this.child;
		    var s = "";

		    for (var i = 0; i < iDepth; ++ i) {
		        s += ':  ';
		    }

		    s += '+----[depth: ' + this.depth + ']' + this.toString() + '\n';

		    if (pChild) {
		        s += pChild.toString(true, iDepth + 1);
		    }

		    if (pSibling) {
		        s += pSibling.toString(true, iDepth);
		    }

		    return s;

		};

		private static _v3fTemp: IVec3 = vec3();
		private static _v4fTemp: IVec4 = vec4();
		private static _m3fTemp: IMat3 = mat3();
		private static _m4fTemp: IMat4 = mat4();
		private static _q4fTemp: IQuat4 = quat4();
	}
}



module akra.scene {
	export class SceneNode extends Node implements ISceneNode {
		/**@protected*/  _pScene: IScene3d = null;

		inline get scene(): IScene3d { return this._pScene; }
		inline set scene(pScene: IScene3d) { this._pScene = pScene; }

		constructor (pScene: IScene3d, eType: EEntityTypes = EEntityTypes.SCENE_NODE) {
			super(eType);

			this.scene = pScene;
		}

		create(): bool {
			super.create();

			this._m4fLocalMatrix        = new Mat4(1);
		    this._m4fWorldMatrix        = new Mat4(1);
		    this._m4fInverseWorldMatrix = new Mat4(1);
		    this._m3fNormalMatrix       = new Mat3(1);

		    this._v3fWorldPosition  = new Vec3();

		    this._v3fTranslation    = new Vec3(0);
		    this._v3fScale          = new Vec3(1);
		    this._qRotation         = new Quat4(0, 1);

		    return true;
		}

		destroy(): void {
			super.destroy();
		}

/**
		 * @deprecated
		 */

		render(): void {

		}

/**
		 * @deprecated
		 */

		prepareForRender(): void {

		}

/**
		 * @deprecated
		 */

		recursiveRender(): void {
// render myself
		    this.prepareForRender();
		    this.render();
// render my sibling
		    if (this.sibling) {
		        (<ISceneNode>(this.sibling)).recursiveRender();
		    }
// render my child
		    if (this.child) {
		        (<ISceneNode>(this.child)).recursiveRender();
		    }
		}


		attachToParent(pParent: IEntity): bool {
			if ((<ISceneNode>pParent).scene !== this._pScene) {
				logger.setSourceLocation( "SceneNode.ts" , 77 ); logger.warning("transfer of the scene node between trees scene - forbidden"); ;
				return false;
			}

			return super.attachToParent(pParent);
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {
			if (!isRecursive) {
		        return "<scene_node" + (this.name? " " + this.name: "") + ">";
		    }

		    return super.toString(isRecursive, iDepth);
		}

	}
}



module akra.scene {
	export class Joint extends SceneNode implements IJoint {
		private _sBone: string = null;
// private _iUpdated: int = 0;
// private _pEngine: IEngine = null;

		constructor (pScene: IScene3d) {
			super(pScene, EEntityTypes.JOINT);
		}

		inline get boneName(): string{
			return this._sBone;
		}

		inline set boneName(sBone: string) {
			this._sBone = sBone;
		}

// getEngine(): IEngine {
// 	return this._pEngine;
// }

		create(): bool {
			this._m4fLocalMatrix = new Mat4(1);
			this._m4fWorldMatrix = new Mat4(1);

			this._v3fWorldPosition  = new Vec3();
			this._v3fTranslation    = new Vec3(0, 0, 0);
			this._v3fScale          = new Vec3(1);
			this._qRotation         = new Quat4(0, 1);


//maybe custom
			this.setInheritance(ENodeInheritance.ALL);
			return true;
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {
			isRecursive = isRecursive || false;

			if (!isRecursive) {
			    return "<joint" + (this._sName ? (' ' + this._sName) : "") + ">";
			}

			return Node.prototype.toString.call(this, isRecursive, iDepth);
		}
	}

	export inline function isJoint(pEntity: IEntity): bool {
		return pEntity.type == EEntityTypes.JOINT;
	}
}



module akra.model {

	class Skeleton implements ISkeleton{
		private _sName: string;
		private _pRootJoints: IJoint[] = [];
		private _pJointMap: IJointMap = null;
		private _pNodeList: ISceneNode[]  = null;
		private _pMeshNode: ISceneModel = null;
		private _iFlags: bool = false;


		inline get totalBones():  number {
			return Object.keys(this._pJointMap).length;
		}

		inline get totalNodes():  number {
			return this._pNodeList.length;
		}

		inline get name(): string{
			return this._sName;
		}

		inline get root(): IJoint {
			return this._pRootJoints[0] || null;
		}

		constructor (sName: string = null) {
			this._sName = sName;
		}

		inline getRootJoint(): IJoint {
			return this.getRootJoints()[0];
		}

		inline getRootJoints(): IJoint[] {
			return this._pRootJoints;
		}

		inline getJointMap(): IJointMap {
			return this._pJointMap;
		}

		inline getNodeList(): ISceneNode[] {
			return this._pNodeList;
		}

		addRootJoint(pJoint: IJoint): bool {
			logger.setSourceLocation( "model/Skeleton.ts" , 56 ); logger.assert(pJoint instanceof scene.Joint, 'node must be joint'); ;

		    var pRootJoints = this._pRootJoints;

			for (var i = 0; i < pRootJoints.length; i++) {
				if (pJoint.childOf(pRootJoints[i])) {
					return false;
				}
				else if (pRootJoints[i].childOf(pJoint)) {
					pRootJoints.splice(i, 1);
				}
			};

			this._pRootJoints.push(pJoint);

			return this.update();
		}

		update(): bool {
			var pRootJoints: IJoint[] 	= this.getRootJoints();
		    var pJointMap: IJointMap 	= this._pJointMap = <IJointMap>{};
		    var pNodeList: ISceneNode[] = this._pNodeList = [];
//var pNotificationJoints = this._pNotificationJoints = [];

		    function findNodes (pNode: ISceneNode): void {
		    	var sJoint: string = null;

		    	if (!isNull(pNode)) {
		    		if (scene.isJoint(pNode)) {
			    		sJoint = (<IJoint>pNode).boneName;
			    	}

			    	if (!isNull(sJoint)) {
			    		logger.setSourceLocation( "model/Skeleton.ts" , 90 ); logger.assert(!pJointMap[sJoint], 'joint with name<' + sJoint + '> already exists in skeleton <' + this._sName + '>');
                                                                                             ;

			    		pJointMap[sJoint] = <IJoint>pNode;
			    	}

			    	pNodeList.push(pNode);

			    	findNodes(<ISceneNode>pNode.sibling);
			    	findNodes(<ISceneNode>pNode.child);
		    	}
		    }

		    for (var i = 0; i < pRootJoints.length; i++) {
		    	findNodes(pRootJoints[i]);
		    };

// for (var sJoint in pJointMap) {
// 	var pJoint = pJointMap[sJoint];

//    	if (pJoint.sibling() == null && pJoint.child() == null) {
//    		pNotificationJoints.push(pJoint);
//    	}
//    };    

			return true;
		}

		findJoint(sName: string): IJoint {
			return this._pJointMap[sName];
		}

		findJointByName(sName: string): IJoint {
			for (var s in this._pJointMap) {
				if (this._pJointMap[s].name === sName) {
					return this._pJointMap[s];
				}
			}

			return null;
		}

		attachMesh(pMesh: IMesh): bool {
			if (isNull(this.root)) {
				return false;
			}

		    if (this._pMeshNode == null) {
		    	this._pMeshNode = this.root.scene.createModel();
		    	this._pMeshNode.setInheritance(ENodeInheritance.ALL);
		    	this._pMeshNode.attachToParent(this.root);
		    }

		    this._pMeshNode.name = this.name + "[mesh-container]";
		    this._pMeshNode.mesh = (pMesh);

		    return true;
		}

		detachMesh(): void {
//TODO: write detach method.
		}
	}

	export function createSkeleton(sName: string = null): ISkeleton {
		return new Skeleton(sName);
	}
}










module akra {
	export interface IMat4 {} ;
	export interface IQuat4 {} ;
	export interface IVec3 {} ;
	export interface IAnimationFrame {} ;

	export enum EAnimationInterpolations {
		MATRIX_LINEAR,
		LINEAR
	}

	export interface IAnimationFrame {
		 time:  number ;
		 weight:  number ;

		 matrix: IMat4;

		 rotation: IQuat4;
		 scale: IVec3;
		 translation: IVec3;

		toMatrix(): IMat4;
		toMatrixFromMatrix(): IMat4;

		reset(): IAnimationFrame;
		set(pFrame: IAnimationFrame): void;

		add(pFrame: IAnimationFrame, isFirst: bool): IAnimationFrame;
		addMatrix(pFrame: IAnimationFrame): IAnimationFrame;

		mult(fScalar:  number ): IAnimationFrame;

		normilize(): IAnimationFrame;
		normilizeMatrix(): IAnimationFrame;

		interpolate(pStartFrame: IAnimationFrame, pEndFrame: IAnimationFrame, fBlend:  number ): void;
		interpolateMatrix(pStartFrame: IAnimationFrame, pEndFrame: IAnimationFrame, fBlend:  number ): void;
	}
}









module akra.animation {
	export class Frame implements IAnimationFrame {
		public time:  number  = 0.0;
		public weight:  number  = 1.0;

		public matrix: IMat4 = null;

		public rotation: IQuat4 = new Quat4;
		public scale: IVec3 = new Vec3;
		public translation: IVec3 = new Vec3;

		constructor();
		constructor(fTime:  number , pMatrix: IMat4);
		constructor(fTime:  number , pMatrix: IMat4, fWeight:  number );
		constructor(fTime?:  number , pMatrix?: IMat4, fWeight?:  number ) {
			switch (arguments.length) {
				case 0:
					this.matrix = new Mat4;
					return;
				case 3:
					this.weight = fWeight;
				case 2:
					this.matrix = pMatrix;
				case 1:
					this.time = fTime;
			};

			this.matrix.decompose(this.rotation, this.scale, this.translation);
		}

		toMatrix(): IMat4{
			return this.rotation.toMat4(this.matrix)
				.setTranslation(this.translation).scaleRight(this.scale);
		}

		toMatrixFromMatrix(): IMat4 {
			return this.matrix;
		}

		reset(): IAnimationFrame {
			this.weight = 0.0;
			this.time = 0.0;

			var pData = this.matrix.data;
			pData[ 0 ] = pData[ 4 ] = pData[ 8 ] = pData[ 12 ] =
			pData[ 1 ] = pData[ 5 ] = pData[ 9 ] = pData[ 13 ] =
			pData[ 2 ] = pData[ 6 ] = pData[ 10 ] = pData[ 14 ] =
			pData[ 3 ] = pData[ 7 ] = pData[ 11 ] = pData[ 15 ] = 0;

			this.rotation.x = this.rotation.y = this.rotation.z = 0;
			this.rotation.w = 1.0;

			this.translation.x = this.translation.y = this.translation.z = 0;

			this.scale.x = this.scale.y = this.scale.z = 0;

			return this;
		}

		set(pFrame: IAnimationFrame): void {
//FIXME: расписать побыстрее
			this.matrix.set(pFrame.matrix);

			this.rotation.set(pFrame.rotation);
			this.scale.set(pFrame.scale);
			this.translation.set(pFrame.translation);

			this.time = pFrame.time;
			this.weight = pFrame.weight;
		}

/**
		 * Добавить данные к фрейму с их весом.
		 * После данного метода фрейму потребуется нормализация!!!!
		 */



		add(pFrame: IAnimationFrame, isFirst: bool): IAnimationFrame {
			var fWeight:  number  = pFrame.weight;

			this.scale.x += pFrame.scale.x * fWeight;
			this.scale.y += pFrame.scale.y * fWeight;
			this.scale.z += pFrame.scale.z * fWeight;

			this.translation.x += pFrame.translation.x * fWeight;
			this.translation.y += pFrame.translation.y * fWeight;
			this.translation.z += pFrame.translation.z * fWeight;

			this.weight += fWeight;

			if (!isFirst) {
				this.rotation.smix(pFrame.rotation, fWeight / this.weight);
			}
			else {
				this.rotation.set(pFrame.rotation);
			}

			return this;
		}

		addMatrix(pFrame: IAnimationFrame): IAnimationFrame {
			var pMatData: Float32Array = pFrame.matrix.data;
			var fWeight:  number  = pFrame.weight;
			var pResData: Float32Array = this.matrix.data;

			for (var i = 0; i < 16; ++ i) {
				pResData[i] += pMatData[i] * fWeight;
			}

			this.weight += fWeight;
			return this;
		}

		mult(fScalar:  number ): IAnimationFrame{
			this.weight *= fScalar;
			return this;
		}

		normilize(): IAnimationFrame{
			var fScalar:  number  = 1.0 / this.weight;

		    this.scale.x *= fScalar;
		    this.scale.y *= fScalar;
		    this.scale.z *= fScalar;

		    this.translation.x *= fScalar;
		    this.translation.y *= fScalar;
		    this.translation.z *= fScalar;

			return this;
		}

		normilizeMatrix(): IAnimationFrame{
			var fScalar:  number  = 1.0 / this.weight;
		    var pData = this.matrix.data;

		    pData[ 0 ] *= fScalar;
		    pData[ 4 ] *= fScalar;
		    pData[ 8 ] *= fScalar;
		    pData[ 12 ] *= fScalar;

			pData[ 1 ] *= fScalar;
		    pData[ 5 ] *= fScalar;
		    pData[ 9 ] *= fScalar;
		    pData[ 13 ] *= fScalar;

			pData[ 2 ] *= fScalar;
		    pData[ 6 ] *= fScalar;
		    pData[ 10 ] *= fScalar;
		    pData[ 14 ] *= fScalar;

			pData[ 3 ] *= fScalar;
		    pData[ 7 ] *= fScalar;
		    pData[ 11 ] *= fScalar;
		    pData[ 15 ] *= fScalar;

			return this;
		}

		interpolate(pStartFrame: IAnimationFrame, pEndFrame: IAnimationFrame, fBlend:  number ): void {
			var pResultData = this.matrix.data;
			var pStartData = pStartFrame.matrix.data;
			var pEndData = pEndFrame.matrix.data;
			var fBlendInv = 1. - fBlend;

			for (var i = 0; i < 16; i++) {
				pResultData[i] = pEndData[i] * fBlend + pStartData[i] * fBlendInv;
			};
		}

		interpolateMatrix(pStartFrame: IAnimationFrame, pEndFrame: IAnimationFrame, fBlend:  number ): void {
			var pResultData = this.matrix.data;
			var pStartData = pStartFrame.matrix.data;
			var pEndData = pEndFrame.matrix.data;
			var fBlendInv:  number  = 1. - fBlend;

			for (var i = 0; i < 16; i++) {
				pResultData[i] = pEndData[i] * fBlend + pStartData[i] * fBlendInv;
			};
		}

		static get stackCeil(): Frame { Frame.stackPosition = Frame.stackPosition === Frame.stackSize - 1? 0: Frame.stackPosition; return Frame.stack[Frame.stackPosition ++]; } static stackSize: number = 4 * 4096 ; static stackPosition: number = 0; static stack: Frame[] = (function(): Frame[]{ var pStack: Frame[] = new Array(Frame.stackSize); for(var i: number = 0; i<Frame.stackSize; i++){ pStack[i] = new Frame(); } return pStack})(); ;
	}

	export function createFrame(fTime?:  number , pMatrix?: IMat4, fWeight?:  number ): IAnimationFrame {
		return new Frame(fTime, pMatrix, fWeight);
	}
}




module akra.animation {
	class Track implements IAnimationTrack {
		private _sTarget: string = null;
		private _pTarget: ISceneNode = null;
		private _pKeyFrames: IAnimationFrame[] = [];
		private _eInterpolationType: EAnimationInterpolations = EAnimationInterpolations.MATRIX_LINEAR;

		inline get totalFrames():  number  {
			return this._pKeyFrames.length;
		}

		inline get target(): ISceneNode{
			return this._pTarget;
		}

		inline get targetName(): string{
			return this._sTarget;
		}

		inline set targetName(sValue: string){
			this._sTarget = sValue;
		}

		inline get duration():  number {
			return this._pKeyFrames.last.fTime;
		}

		constructor (sTarget: string = null) {
			this._sTarget = sTarget;
		}

		keyFrame(fTime:  number , pMatrix: IMat4): bool {
			var pFrame: IAnimationFrame;
		    var iFrame:  number ;

		    var pKeyFrames: IAnimationFrame[] = this._pKeyFrames;
		  	var nTotalFrames:  number  = pKeyFrames.length;

		  	if (arguments.length > 1) {
		  		pFrame = createFrame(fTime, pMatrix);
		  	}
		    else {
		    	pFrame = arguments[0];
		    }

		    if (nTotalFrames && (iFrame = this.findKeyFrame(pFrame.time)) >= 0) {
				pKeyFrames.splice(iFrame, 0, pFrame);
			}
			else {
				pKeyFrames.push(pFrame);
			}

			return true;
		}

		getKeyFrame(iFrame:  number ): IAnimationFrame {
			logger.setSourceLocation( "animation/Track.ts" , 69 ); logger.assert(iFrame < this.totalFrames, 'iFrame must be less then number of total jey frames.'); ;

			return this._pKeyFrames[iFrame];
		}

		findKeyFrame(fTime:  number ):  number  {
			var pKeyFrames: IAnimationFrame[] = this._pKeyFrames;
		    var nTotalFrames:  number              = pKeyFrames.length;

			if (pKeyFrames[nTotalFrames - 1].time == fTime) {
				return nTotalFrames - 1;
			}
			else {
				for (var i:  number  = nTotalFrames - 1; i >= 0; i--) {
					if (pKeyFrames[i].time > fTime && pKeyFrames[i - 1].time <= fTime) {
						return i - 1;
					}
				}
			}

			return -1;
		}

		bind(sJoint: string, pSkeleton: ISkeleton): bool;
		bind(pSkeleton: ISkeleton): bool;
		bind(pNode: ISceneNode): bool;
		bind(pJoint: any, pSkeleton?: any): bool {
			var pNode: ISceneNode = null,
				pRootNode: ISceneNode;

			var sJoint: string;

			switch (arguments.length) {
				case 2:
//bind by pair <String joint, Skeleton skeleton>
					sJoint = <string>pJoint;

					this._sTarget = sJoint;
					pNode = (<ISkeleton>pSkeleton).findJoint(sJoint);
					break;
				default:
//bind by <Skeleton skeleton>
					if (!isDef(arguments[0].type)) {

						if (this._sTarget == null) {
							return false;
						}

						pSkeleton = <ISkeleton>arguments[0];
						pNode = (<ISkeleton>pSkeleton).findJoint(this._sTarget);
					}
//bind by <Node node>
					else {
						pRootNode = <ISceneNode>arguments[0];
						pNode = <ISceneNode>pRootNode.findEntity(this.targetName);
					}
			}

			this._pTarget = pNode;

			return isDefAndNotNull(pNode);
		}

		frame(fTime:  number ): IAnimationFrame {
			var iKey1:  number  = 0, iKey2:  number  = 0;
			var fScalar:  number ;
			var fTimeDiff:  number ;

			var pKeys:  IAnimationFrame[] = this._pKeyFrames
			var nKeys:   number  = pKeys.length;
			var pFrame: IAnimationFrame =  Frame.stackCeil ;

			logger.setSourceLocation( "animation/Track.ts" , 141 ); logger.assert(nKeys > 0, 'no frames :('); ;

			if (nKeys === 1) {
				pFrame.set(pKeys[0]);
			}
			else {
//TODO: реализовать существенно более эффективный поиск кадра.
				for (var i:  number  = 0; i < nKeys; i ++) {
			    	if (fTime >= this._pKeyFrames[i].time) {
			            iKey1 = i;
			        }
			    }

			    iKey2 = (iKey1 >= (nKeys - 1))? iKey1 : iKey1 + 1;

			    fTimeDiff = pKeys[iKey2].time - pKeys[iKey1].time;

			    if (!fTimeDiff)
			        fTimeDiff = 1;

				fScalar = (fTime - pKeys[iKey1].time) / fTimeDiff;

				pFrame.interpolate(
					this._pKeyFrames[iKey1],
					this._pKeyFrames[iKey2],
					fScalar);
			}

			pFrame.time = fTime;
			pFrame.weight = 1.0;

			return pFrame;
		}
	}

	export function createTrack(sName: string = null): IAnimationTrack {
		return new Track(sName);
	}
}














module akra {
	export interface ISceneNode {} ;
	export interface IJoint {} ;
	export interface IAnimationFrame {} ;
	export interface IAnimationTrack {} ;

	export interface IAnimationTarget {
		target: ISceneNode;
		index:  number ;
		name: string;
		track?: IAnimationTrack;
	}

	export enum EAnimationTypes {
		ANIMATION,
		CONTAINER,
		BLEND
	}

	export interface IAnimationBase extends IEventProvider {
		duration:  number ;
		name: string;

		play(fRealTime:  number ): void;
		stop(fRealTime:  number ): void;

		attach(pTarget: ISceneNode): void;

		frame(sName: string, fRealTime:  number ): IAnimationFrame;
		apply(fRealTime:  number ): void;

		addTarget(sName: string, pTarget: ISceneNode): IAnimationTarget;
		setTarget(sName: string, pTarget: ISceneNode): IAnimationTarget;

		getTarget(sTargetName: string): IAnimationTarget;
		getTargetByName(sName: string): IAnimationTarget;

		getTargetList(): IAnimationTarget[];

		targetNames(): string[];
		targetList(): ISceneNode[];
		jointList(): IJoint[];

		grab(pAnimationBase: IAnimationBase, bRewrite?: bool): void;

		createAnimationMask(): FloatMap;

		 played(fTime:  number ): void;
		 stoped(fTime:  number ): void;
	}
}



module akra {
	export interface ISceneNode {} ;
	export interface IAnimationFrame {} ;
	export interface IAnimationTrack {} ;

	export interface IAnimation extends IAnimationBase {
		 totalTracks:  number ;

		push(pTrack: IAnimationTrack): void;
		attach(pTarget: ISceneNode): void;

		getTracks(): IAnimationTrack[];

		frame(sName: string, fTime:  number ): IAnimationFrame;
		extend(pAnimation: IAnimation): void;
	}
}

























module akra.animation {
	export interface IAnimationTargetMap {
		[index: string]: IAnimationTarget;
	}

	export class Base implements IAnimationBase {

		/**@protected*/  _pTargetMap: IAnimationTargetMap = {};
    	/**@protected*/  _pTargetList: IAnimationTarget[] = [];

    	/**@protected*/  _fDuration:  number  = 0.0;
		/**@protected*/  _sName: string;

		/**@protected*/  _eType: EAnimationTypes;

		constructor (eType: EAnimationTypes, sName: string = null) {
			this._sName = sName || ("animation-" + now() + "-" + this.getGuid());
			this._eType = eType;
		}

		inline get duration():  number {
			return this._fDuration;
		}

		inline set duration(fValue:  number ){
			this._fDuration = fValue;
		}

		inline get name(): string{
			return this._sName;
		};

		inline set name(sName: string){
			this._sName = sName;
		};


		inline play(fRealTime:  number ): void {
			this.played(fRealTime);
		}

		inline stop(fRealTime:  number ): void {
			this.stoped(fRealTime);
		}

		attach(pTarget: ISceneNode): void {
			logger.setSourceLocation( "Base.ts" , 57 ); logger.error("method AnimationBase::attach() must be overwritten."); ;
		}

		frame(sName: string, fRealTime:  number ): IAnimationFrame {
			return null;
		}

		apply(fRealTime:  number ): void {
			var pTargetList: IAnimationTarget[] = this._pTargetList;
		    var pTarget: ISceneNode;
		    var pFrame: IAnimationFrame;
		    var pTransform;

			for (var i = 0; i < pTargetList.length; ++ i) {
				pFrame = this.frame(pTargetList[i].name, fRealTime);
				pTarget = pTargetList[i].target;

				if (!pFrame || !pTarget) {
					continue;
				}

				pTransform = pFrame.toMatrix();
				pTarget.localMatrix.set(pTransform);
			};

		}

		addTarget(sName: string, pTarget: ISceneNode = null): IAnimationTarget {
//pTarget = pTarget || null;

		    var pPointer: IAnimationTarget = this._pTargetMap[sName];

		    if (pPointer) {
		    	pPointer.target = pTarget || pPointer.target || null;
		    	return pPointer;
		    }

		    pPointer = {
				target: pTarget,
				index: this._pTargetList.length,
				name: sName
			};

		    this._pTargetList.push(pPointer);
			this._pTargetMap[sName] = pPointer;

			return pPointer;
		}

		setTarget(sName: string, pTarget: ISceneNode): IAnimationTarget {

		    var pPointer: IAnimationTarget = this._pTargetMap[sName];
			pPointer.target = pTarget;
			return pPointer;
		}

		getTarget(sTargetName: string): IAnimationTarget {
			return this._pTargetMap[sTargetName];
		}

		inline getTargetList(): IAnimationTarget[] {
			return this._pTargetList;
		}

		inline getTargetByName(sName: string): IAnimationTarget {
			return this._pTargetMap[sName];
		}

		targetNames(): string[] {
			var pTargets: IAnimationTarget[] = this._pTargetList;
			var pTargetNames: string[] = [];

			for (var i = 0; i < pTargets.length; ++ i) {
				pTargetNames.push(pTargets[i].name);
			}

			return pTargetNames;
		}

		targetList(): ISceneNode[] {
			var pTargets: IAnimationTarget[] = this._pTargetList;
			var pTargetList: ISceneNode[] = [];

			for (var i = 0; i < pTargets.length; ++ i) {
				pTargetList.push(pTargets[i].target);
			}

			return pTargetList;
		}

		jointList(): IJoint[] {
			var pTargets: IAnimationTarget[] = this._pTargetList;
			var pJointList: IJoint[] = [];

			for (var i = 0; i < pTargets.length; ++ i) {
				if (scene.isJoint(pTargets[i].target)) {
					pJointList.push(<IJoint>pTargets[i].target);
				}
			}

			return pJointList;
		}

		grab(pAnimationBase: IAnimationBase, bRewrite: bool = true): void{

		    var pAdoptTargets: IAnimationTarget[] = pAnimationBase.getTargetList();

			for (var i = 0; i < pAdoptTargets.length; ++ i) {

				if (!pAdoptTargets[i].target) {
//warning('cannot grab target <' + pAdoptTargets[i].name + '>, becaus "target" is null');
					continue;
				}

				if (bRewrite || !this.getTarget(pAdoptTargets[i].name)) {
					this.addTarget(pAdoptTargets[i].name, pAdoptTargets[i].target);
				}
			};
		}

		createAnimationMask(): FloatMap {
			var pTargets: string[] = this.targetNames();
		    var pMask: FloatMap = <FloatMap>{};

		    for (var i = 0; i < pTargets.length; ++ i) {
		    	pMask[pTargets[i]] = 1.0;
		    }

		    return pMask;
		}

		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return Base._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		played (fRealTime): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).played; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, fRealTime) : _broadcast[i].listener (_recivier, fRealTime) ; } } } ; ;
		stoped (fRealTime): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).stoped; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, fRealTime) : _broadcast[i].listener (_recivier, fRealTime) ; } } } ; ;
	}
}



module akra.animation {
	class Animation extends Base implements IAnimation {
		private _pTracks: IAnimationTrack[] = [];

    	constructor (sName?: string) {
    		super(EAnimationTypes.ANIMATION, sName);
    	}

		inline get totalTracks():  number  {
			return this._pTracks.length;
		}

		push(pTrack: IAnimationTrack): void {
			this._pTracks.push(pTrack);
			this._fDuration = Math.max(this._fDuration, pTrack.duration);
			this.addTarget(pTrack.targetName);
		}

		attach(pTarget: ISceneNode): void {
			var pPointer;
		    var pTracks: IAnimationTrack[] = this._pTracks;

			for (var i = 0; i < pTracks.length; ++ i) {
				if (!pTracks[i].bind(pTarget)) {
					logger.setSourceLocation( "animation/Animation.ts" , 35 ); logger.log("cannot bind animation track [", i, "] to joint <", pTracks[i].target, ">"); ;
				}
				else {
					pPointer = this.setTarget(pTracks[i].targetName, pTracks[i].target);
					pPointer.track = pTracks[i];
				}
			}
		}

		inline getTracks(): IAnimationTrack[] {
			return this._pTracks;
		}

		frame(sName: string, fTime:  number ): IAnimationFrame {
			var pPointer: IAnimationTarget = this.getTargetByName(sName);

		    if (!pPointer || !pPointer.track) {
		    	return null;
		    }

			return pPointer.track.frame(math.clamp(fTime, 0, this._fDuration));
		}

		extend(pAnimation: IAnimation): void {
			var pTracks: IAnimationTrack[] = pAnimation.getTracks();

			for (var i = 0; i < pTracks.length; ++ i) {
				if (!this.getTarget(pTracks[i].targetName)) {
					this.push(pTracks[i]);
				}
			}
		}
	}

	export function createAnimation(sName?: string): IAnimation {
		return new Animation(sName);
	}
}












module akra {
	export interface IAnimationBase {} ;
	export interface IEngine {} ;
	export interface ISceneNode {} ;

	export interface IAnimationController {
		 totalAnimations:  number ;
		 active: IAnimationBase;

		setOptions(eOptions): void;
		addAnimation(pAnimation: IAnimationBase): bool;

		removeAnimation(pAnimation: string): bool;
		removeAnimation(pAnimation:  number ): bool;
		removeAnimation(pAnimation: IAnimationBase): bool;

		findAnimation(pAnimation: string): IAnimationBase;
		findAnimation(pAnimation:  number ): IAnimationBase;
		findAnimation(pAnimation: IAnimationBase): IAnimationBase;

		getAnimation(iAnim:  number ): IAnimationBase;

		setAnimation(iAnimation:  number , pAnimation: IAnimationBase): void;
		attach(pTarget: ISceneNode): void;

		play(pAnimation: string, fRealTime:  number ): bool;
		play(pAnimation:  number , fRealTime:  number ): bool;
		play(pAnimation: IAnimationBase, fRealTime:  number ): bool;

		update(fTime:  number ): void;
	}
}



module akra.animation {
	export class Controller implements IAnimationController {
		private _pAnimations: IAnimationBase[] = [];
		private _iOptions:  number  = 0;
	    private _pActiveAnimation: IAnimationBase = null;
	    private _fnPlayAnimation: Function = null;

	    inline get totalAnimations():  number {
			return this._pAnimations.length;
		}

		inline get active(): IAnimationBase{
			return this._pActiveAnimation;
		}

		constructor(iOptions:  number  = 0) {

			this.setOptions(iOptions);
		}

		setOptions(iOptions:  number ): void {

		}


		addAnimation(pAnimation: IAnimationBase): bool {
			if (this.findAnimation(pAnimation.name)) {
				logger.setSourceLocation( "animation/Controller.ts" , 34 ); logger.warning("Animation with name <" + pAnimation.name + "> already exists in this controller"); ;
				return false;
			}

//LOG('animation controller :: add animation >> ', pAnimation.name);

			this._pAnimations.push(pAnimation);
			this._pActiveAnimation = pAnimation;
		}

		removeAnimation(pAnimation: string): bool;
		removeAnimation(pAnimation:  number ): bool;
		removeAnimation(pAnimation: IAnimationBase): bool;
		removeAnimation(pAnimation: any): bool {
			var pAnimation = this.findAnimation(arguments[0]);
		    var pAnimations = this._pAnimations;

			for (var i = 0; i < pAnimations.length; ++ i) {
				if (pAnimations[i] === pAnimation) {
					pAnimations.splice(i, 1);
					logger.setSourceLocation( "animation/Controller.ts" , 54 ); logger.log("animation controller :: remove animation >> ", pAnimation.name); ;
					return true;
				}
			}

			return false;
		}

		findAnimation(pAnimation: string): IAnimationBase;
		findAnimation(pAnimation:  number ): IAnimationBase;
		findAnimation(pAnimation: IAnimationBase): IAnimationBase;
		findAnimation(pAnimation: any): IAnimationBase {
			var pAnimations: IAnimationBase[] = this._pAnimations;
		    var iAnimation:  number ;
		    var sAnimation: string;

			if (isString(arguments[0])) {
				sAnimation = arguments[0];

				for (var i = 0; i < pAnimations.length; ++ i) {
					if (pAnimations[i].name === sAnimation) {
						return pAnimations[i];
					}
				}

				return null;
			}

			if (typeof arguments[0] === 'number') {
				iAnimation = arguments[0];
				return pAnimations[iAnimation] || null;
			}

			return arguments[0];
		}

		inline getAnimation(iAnim:  number ): IAnimationBase {
			return this._pAnimations[iAnim];
		}

		setAnimation(iAnimation:  number , pAnimation: IAnimationBase): void {
			logger.setSourceLocation( "animation/Controller.ts" , 95 ); logger.assert(iAnimation < this._pAnimations.length, 'invalid animation slot'); ;

			this._pAnimations[iAnimation] = pAnimation;
		}

		attach(pTarget: ISceneNode): void {
			var pAnimations: IAnimationBase[] = this._pAnimations;

		    for (var i:  number  = 0; i < pAnimations.length; ++ i) {
		        pAnimations[i].attach(pTarget);
		    }
		}

		play(pAnimation: string, fRealTime:  number ): bool;
		play(pAnimation:  number , fRealTime:  number ): bool;
		play(pAnimation: IAnimationBase, fRealTime:  number ): bool;
		play(pAnimation: any, fRealTime:  number ): bool {
			var pAnimationNext: IAnimationBase = this.findAnimation(arguments[0]);
			var pAnimationPrev: IAnimationBase = this._pActiveAnimation;

			if (pAnimationNext && pAnimationNext !== pAnimationPrev) {
				if (this._fnPlayAnimation) {
					this._fnPlayAnimation(pAnimationNext);
				}
//LOG('controller::play(', pAnimationNext.name, ')', pAnimationNext);
				if (pAnimationPrev) {
					pAnimationPrev.stop(fRealTime);
				}

				pAnimationNext.play(fRealTime);

				this._pActiveAnimation = pAnimationNext;

				return true;
			}

			return false;
		}

		update(fTime:  number ): void {
			if (this._pActiveAnimation) {
				this._pActiveAnimation.apply(fTime);
			}
		}
	}


	export function createController(iOptions?:  number ): IAnimationController {
		return new Controller(iOptions);
	}
}










module akra {
	export interface IAnimationBase {} ;

	export interface IAnimationElement {
		animation: IAnimationBase;
		weight:  number ;
		mask: FloatMap;
		acceleration?:  number ;
		time:  number ;
		realTime:  number ;
	}

	export interface IAnimationBlend extends IAnimationBase {
		 totalAnimations:  number ;

		addAnimation(pAnimation: IAnimationBase, fWeight:  number , pMask: FloatMap):  number ;
		setAnimation(iAnimation:  number , pAnimation: IAnimationBase, fWeight:  number , pMask: FloatMap):  number ;

		getAnimationIndex(sName: string):  number ;
		getAnimation(iAnimation:  number ): IAnimationBase;
		getAnimationWeight(iAnimation:  number ):  number ;

		setWeights(): bool;
		setWeightSwitching(fWeight:  number , iAnimationFrom:  number , iAnimationTo:  number ): bool;
		setAnimationWeight(iAnimation:  number , fWeight:  number ): bool;

		setAnimationMask(iAnimation:  number , pMask: FloatMap): bool;
		getAnimationMask(iAnimation:  number ): FloatMap;

		createAnimationMask(iAnimation?:  number ): FloatMap;

		 durationUpdated(fDuration:  number );
	}
}






module akra.animation {
	export class Blend extends Base implements IAnimationBlend {
		public duration:  number  = 0;

		private _pAnimationList: IAnimationElement[] = [];

		constructor (sName?: string) {
			super(EAnimationTypes.BLEND, sName);
		}

		inline get totalAnimations():  number  {
			return this._pAnimationList.length;
		}

		play(fRealTime:  number ): void {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;
			var n:  number  = pAnimationList.length;

			for (var i:  number  = 0; i < n; ++ i) {

				pAnimationList[i].realTime = fRealTime;
				pAnimationList[i].time = fRealTime * pAnimationList[i].acceleration;
			}

			this.played(fRealTime);
		}

		stop(): void {
			this.stoped(0.);
		}

		attach(pTarget: ISceneNode): void {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;

			for (var i:  number  = 0; i < pAnimationList.length; ++ i) {
				var pAnim: IAnimationBase = pAnimationList[i].animation;
				pAnim.attach(pTarget);
				this.grab(pAnim, true);
			}
		}

		addAnimation(pAnimation: IAnimationBase, fWeight:  number , pMask: FloatMap):  number  {
			logger.setSourceLocation( "animation/Blend.ts" , 50 ); logger.assert(isDef(pAnimation), 'animation must be setted.'); ;

			this._pAnimationList.push(null);

			return this.setAnimation(this._pAnimationList.length - 1, pAnimation, fWeight, pMask);
		}

		setAnimation(iAnimation:  number , pAnimation: IAnimationBase, fWeight:  number  = 1.0, pMask: FloatMap = null):  number  {
			logger.setSourceLocation( "animation/Blend.ts" , 58 ); logger.assert(iAnimation <= this._pAnimationList.length, 'invalid animation slot: ' + iAnimation + '/' + this._pAnimationList.length); ;

		    var pPointer: IAnimationElement = this._pAnimationList[iAnimation];
		    var pAnimationList: IAnimationElement[] = this._pAnimationList;

		    if (!pAnimation) {
		    	pAnimationList[iAnimation] = null;
		    	return iAnimation;
		    }

		    if (!pPointer) {
		    	pPointer = {
					animation: pAnimation,
					weight: fWeight,
					mask: pMask,
					acceleration: 1.0,
					time: 0.0,
					realTime: 0.0
				};

				this.connect(pAnimation, "durationUpdated" , "_onDurationUpdate" )

				if (iAnimation == this._pAnimationList.length) {
					pAnimationList.push(pPointer);
				}
				else {
					pAnimationList[iAnimation] = pPointer;
				}
			}

			this.grab(pAnimation);
			this.updateDuration();

			return iAnimation;
		}

		_onDurationUpdate(pAnimation: IAnimationBase, fDuration:  number ): void {
			this.updateDuration();
		}

		/**@protected*/  updateDuration(): void {
			var fWeight:  number  = 0;
			var fSumm:  number  = 0;
			var pAnimationList: IAnimationElement[] = this._pAnimationList;
			var n:  number  = pAnimationList.length;

			for (var i:  number  = 0; i < n; ++ i) {
				if (pAnimationList[i] === null) {
					continue;
				}

				fSumm += pAnimationList[i].weight * pAnimationList[i].animation.duration;
				fWeight += pAnimationList[i].weight;
			}

			if (fWeight === 0) {
				this.duration = 0;
			}
			else {

				this.duration = fSumm / fWeight;

				for (var i:  number  = 0; i < n; ++ i) {
					if (pAnimationList[i] === null) {
						continue;
					}

					pAnimationList[i].acceleration = pAnimationList[i].animation.duration / this.duration;
//trace(pAnimationList[i].animation.name, '> acceleration > ', pAnimationList[i].acceleration);
				}
			}

			this.durationUpdated(this.duration);
		}

		getAnimationIndex(sName: string):  number  {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;

			for (var i:  number  = 0; i < pAnimationList.length; i++) {
				if (pAnimationList[i].animation.name === sName) {
					return i;
				}
			};

			return -1;
		}


		getAnimation(iAnimation:  number ): IAnimationBase {
			if (typeof arguments[0] === 'string') {
		    	iAnimation = this.getAnimationIndex(arguments[0]);
		    }

			return this._pAnimationList[iAnimation].animation;
		}

		getAnimationWeight(iAnimation:  number ):  number  {
			if (typeof arguments[0] === 'string') {
				iAnimation = this.getAnimationIndex(arguments[0]);
			}

			return this._pAnimationList[iAnimation].weight;
		}

		setWeights(): bool {
			var fWeight:  number ;
    		var isModified: bool = false;
		    var pAnimationList: IAnimationElement[] = this._pAnimationList;

			for (var i:  number  = 0; i < arguments.length; ++ i) {
				fWeight = arguments[i];

				if (fWeight < 0 || fWeight === null || !pAnimationList[i]) {
					continue;
				}

				if (pAnimationList[i].weight !== fWeight) {
					pAnimationList[i].weight = fWeight;
					isModified = true;
				}
			}

			if (isModified) {
				this.updateDuration();
			}

			return true;
		}

		setWeightSwitching(fWeight:  number , iAnimationFrom:  number , iAnimationTo:  number ): bool {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;
		    var isModified: bool = false;
		    var fWeightInv:  number  = 1. - fWeight;

		    if (!pAnimationList[iAnimationFrom] || !pAnimationList[iAnimationTo]) {
		    	return false;
		    }

		    if (pAnimationList[iAnimationFrom].weight !== fWeightInv) {
				pAnimationList[iAnimationFrom].weight = fWeightInv;
				isModified = true;
			}

			if (pAnimationList[iAnimationTo].weight !== fWeight) {
				pAnimationList[iAnimationTo].weight = fWeight;
				isModified = true;
			}

			if (isModified) {
				this.updateDuration();
			}

			return true;
		}

		setAnimationWeight(iAnimation:  number , fWeight:  number ): bool {
			var pAnimationList = this._pAnimationList;
		    var isModified = false;
		    if (arguments.length === 1) {
		    	fWeight = arguments[0];

		    	for (var i = 0; i < pAnimationList.length; i++) {
		    		pAnimationList[i].weight = fWeight;
		    	};

		    	isModified = true;
		    }
		    else {
			    if (typeof arguments[0] === 'string') {
			    	iAnimation = this.getAnimationIndex(arguments[0]);
			    }

//trace('set weight for animation: ', iAnimation, 'to ', fWeight);
			    if (pAnimationList[iAnimation].weight !== fWeight) {
					pAnimationList[iAnimation].weight = fWeight;
					isModified = true;
				}
			}

			if (isModified) {
				this.updateDuration();
			}

			return true;
		}

		setAnimationMask(iAnimation:  number , pMask: FloatMap): bool {
			if (typeof arguments[0] === 'string') {
		    	iAnimation = this.getAnimationIndex(arguments[0]);
		    }

			this._pAnimationList[iAnimation].mask = pMask;

			return true;
		}

		getAnimationMask(iAnimation:  number ): FloatMap {
			if (typeof arguments[0] === 'string') {
		    	iAnimation = this.getAnimationIndex(arguments[0]);
		    }

			return this._pAnimationList[iAnimation].mask;
		}

		createAnimationMask(iAnimation?:  number ): FloatMap {
			if (arguments.length === 0) {
				return super.createAnimationMask();
			}

			if (typeof arguments[0] === 'string') {
		    	iAnimation = this.getAnimationIndex(arguments[0]);
		    }

		    var pAnimation: IAnimationBase = this._pAnimationList[iAnimation].animation;
			return pAnimation.createAnimationMask();
		}

		frame(sName: string, fRealTime:  number ) {
			var pAnimationList: IAnimationElement[] = this._pAnimationList;
			var pResultFrame: IAnimationFrame = animation. Frame.stackCeil .reset();
			var pFrame: IAnimationFrame;
			var pMask: FloatMap;
			var pPointer: IAnimationElement;
			var fAcceleration:  number ;

			var fBoneWeight:  number ;
			var fWeight:  number ;
			var iAnim:  number  = 0;


			for (var i:  number  = 0; i < pAnimationList.length; i++) {
				pPointer = pAnimationList[i];

				if (!pPointer) {
					continue;
				}

				fAcceleration = pPointer.acceleration;
				pMask = pPointer.mask;
				fBoneWeight = 1.0;

				pPointer.time = pPointer.time + (fRealTime - pPointer.realTime) * fAcceleration;
		    	pPointer.realTime = fRealTime;

		    	if (pMask) {
					fBoneWeight = isDef(pMask[sName]) ? pMask[sName] : 1.0;
				}

				fWeight = fBoneWeight * pPointer.weight;

				if (fWeight > 0.0) {
					pFrame = pPointer.animation.frame(sName, pPointer.time);

					if (pFrame) {
						iAnim ++;
//first, if 1
						pResultFrame.add(pFrame.mult(fWeight), iAnim === 1);
					}
				}
			}

			if (pResultFrame.weight === 0.0) {
				return null;
			}

			return pResultFrame.normilize();
		}


		durationUpdated (fDuration): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).durationUpdated; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, fDuration) : _broadcast[i].listener (_recivier, fDuration) ; } } } ; ;
	}
}
















module akra.core.pool.resources {

/* COMMON FUNCTIONS
     ------------------------------------------------------
     */


    function getSupportedFormat(sSemantic: string): IColladaUnknownFormat[];
    function calcFormatStride(pFormat: IColladaUnknownFormat[]):  number ;

// data convertion

    function parseBool(sValue: string): bool;
    function parseString(sValue: string): string;
    function retrieve(pSrc: any[], pDst: any[], iStride?:  number , iFrom?:  number , iCount?:  number , iOffset?:  number , iLen?:  number ):  number ;

    function string2Array(sData: string, ppData: any[], fnConv: (data: string) => any, iFrom?:  number ):  number ;
    function string2IntArray(sData: string, ppData:  number [], iFrom?:  number ):  number ;
    function string2FloatArray(sData: string, ppData:  number [], iFrom?:  number ):  number ;
    function string2BoolArray(sData: string, ppData: bool[], iFrom?:  number ):  number ;
    function string2StringArray(sData: string, ppData: string[], iFrom?:  number ):  number ;

    function string2Any(sData: string, n:  number , sType: string, isArray?: bool): any;

// additional

    function printArray(pArr: any[], nRow:  number , nCol:  number ): string;
    function sortArrayByProperty(pData: any[], sProperty: string): any[];

//xml

    function stringData(pXML: Element): string;
    function attr(pXML: Element, sName: string): string;
    function firstChild(pXML: Element, sTag?: string): Element;




// globals

    var pSupportedVertexFormat: IColladaUnknownFormat[];
    var pSupportedTextureFormat: IColladaUnknownFormat[];
    var pSupportedColorFormat: IColladaUnknownFormat[];
    var pSupportedWeightFormat: IColladaUnknownFormat[];
    var pSupportedJointFormat: IColladaUnknownFormat[];
    var pSupportedInvBindMatrixFormat: IColladaUnknownFormat[];
    var pSupportedInterpolationFormat: IColladaUnknownFormat[];
    var pSupportedInputFormat: IColladaUnknownFormat[];
    var pSupportedOutputFormat: IColladaUnknownFormat[];
    var pSupportedTangentFormat: IColladaUnknownFormat[];

    var pFormatStrideTable: IColladaFormatStrideTable;

    var pConvFormats: IColladaConvertionTable;

    export class Collada extends ResourcePoolItem implements ICollada {

        constructor ();

        attachToScene(pNode: ISceneNode): bool;

        parse(sXMLData: string, pOptions?: IColladaLoadOptions): bool;

// load(sFilename: string, fnCallback?: IColladaLoadCallback, pOptions?: IColladaLoadOptions): void;

// polygon index convertion

        private polygonToTriangles(pXML: Element, iStride:  number ):  number [];
        private polylistToTriangles(pXML: Element, iStride:  number ):  number [];
        private trifanToTriangles(pXML: Element, iStride:  number ):  number [];
        private tristripToTriangles(pXML: Element, iStride:  number ):  number [];

// xml    

        private eachNode(pXMLList: NodeList, fnCallback: IXMLExplorer, nMax?:  number ): void;
        private eachChild(pXML: Element, fnCallback: IXMLExplorer): void;
        private eachByTag(pXML: Element, sTag: string, fnCallback: IXMLExplorer, nMax?:  number ): void;

// Akra convertions functions

        private findNode(pNodes: IColladaNode[], sNode?: string, fnNodeCallback?: (pNode: IColladaNode) => void): IColladaNode;


// helper functions

        private COLLADATranslateMatrix(pXML: Element): IMat4;
        private COLLADARotateMatrix(pXML: Element): IMat4;
        private COLLADAScaleMatrix(pXML: Element): IMat4;
        private COLLADAData(pXML: Element): any;
        private COLLADAGetSourceData(pSource: IColladaSource, pFormat: IColladaUnknownFormat[]): IColladaArray;

// common
// -----------------------------------------------------------

        private COLLADATransform(pXML: Element, id?: string): IColladaTransform;
        private COLLADANewParam(pXML: Element): IColladaNewParam;
        private COLLADAAsset(pXML: Element): IColladaAsset;
        private COLLADALibrary(pXML: Element, pTemplate: IColladaLibraryTemplate): IColladaLibrary;

// geometry

        private COLLADAAccessor(pXML: Element): IColladaAccessor;
        private COLLADAInput(pXML: Element, iOffset?:  number ): IColladaInput;
        private COLLADATechniqueCommon(pXML: Element): IColladaTechniqueCommon;
        private COLLADASource(pXML: Element): IColladaSource;
        private COLLADAVertices(pXML: Element): IColladaVertices;
        private COLLADAJoints(pXML: Element): IColladaJoints;
        private COLLADAPolygons(pXML: Element, sType: string): IColladaPolygons;
        private COLLADAVertexWeights(pXML: Element): IColladaVertexWeights;
        private COLLADAMesh(pXML: Element): IColladaMesh;
        private COLLADAGeometrie(pXML: Element): IColladaGeometrie;
        private COLLADASkin(pXML: Element): IColladaSkin;
        private COLLADAController(pXML: Element): IColladaController;

// images
// 
        private COLLADAImage(pXML: Element): IColladaImage;

// effects

        private COLLADASurface(pXML: Element): IColladaSurface;
        private COLLADATexture(pXML: Element): IColladaTexture;
        private COLLADASampler2D(pXML: Element): IColladaSampler2D;
        private COLLADAPhong(pXML: Element): IColladaPhong;
        private COLLADAEffectTechnique(pXML: Element): IColladaEffectTechnique;
        private COLLADAProfileCommon(pXML: Element): IColladaProfileCommon;
        private COLLADAEffect(pXML: Element): IColladaEffect;

//materials

        private COLLADAMaterial(pXML: Element): IColladaMaterial;

// scene

        private COLLADANode(pXML: Element, iDepth?:  number ): IColladaNode;
        private COLLADAVisualScene(pXML: Element): IColladaVisualScene;
        private COLLADABindMaterial(pXML: Element): IColladaBindMaterial;
        private COLLADAInstanceEffect(pXML: Element): IColladaInstanceEffect;
        private COLLADAInstanceController(pXML: Element): IColladaInstanceController;
        private COLLADAInstanceGeometry(pXML: Element): IColladaInstanceGeometry;

// directly load <visual_scene> from <instance_visual_scene> from <scene>.
        private COLLADAScene(pXML: Element): IColladaVisualScene;

// animation

        private COLLADAAnimationSampler(pXML: Element): IColladaAnimationSampler;
        private COLLADAAnimationChannel(pXML: Element): IColladaAnimationChannel;
        private COLLADAAnimation(pXML: Element): IColladaAnimation;


// collada mapping

        private source(sUrl: string): IColladaEntry;
        private link(sId: string, pTarget: IColladaEntry): void;
        private link(pEntry: IColladaEntry): void;
        private target(sPath: string): IColladaTarget;

//animation 

        private buildAnimationTrack(pChannel: IColladaAnimationChannel): IAnimationTrack;
        private buildAnimationTrackList(pAnimationData: IColladaAnimation): IAnimationTrack[];
        private buildAnimation(pAnimationData: IColladaAnimation): IAnimation;
        private buildAnimations(pAnimations: IColladaAnimation[], pAnimationsList?: IAnimation[]): IAnimation[];

// common

        private buildAssetTransform(pNode: ISceneNode, pAsset?: IColladaAsset): ISceneNode;
        private buildDeclarationFromAccessor(sSemantic: string, pAccessor: IColladaAccessor): IVertexElementInterface[];

// materials & meshes

        private buildMaterials(pMesh: IMesh, pGeometryInstance: IColladaInstanceGeometry): IMesh;
        private buildSkeleton(pSkeletonsList: string[]): ISkeleton;
        private buildMesh(pGeometryInstance: IColladaInstanceGeometry): IMesh;
        private buildSkinMesh(pControllerInstance: IColladaInstanceController): IMesh;

        private buildMeshInstance(pGeometries: IColladaInstanceGeometry[], pSceneNode?: ISceneNode): IMesh[];
        private buildSkinMeshInstance(pControllers: IColladaInstanceController[], pSceneNode?: ISceneNode): IMesh[];
        private buildMeshes(): IMesh[];

// scene

        private buildSceneNode(pNode: IColladaNode, pParentNode: ISceneNode): ISceneNode;
        private buildJointNode(pNode: IColladaNode, pParentNode: ISceneNode): IJoint;
        private buildNodes(pNodes: IColladaNode[], pParentNode?: ISceneNode): ISceneNode;
        private buildScene(pRootNode: ISceneNode): ISceneNode[];

        private buildInititalPose(pNodes: IColladaNode[], pSkeleton: ISkeleton): IAnimation;
        private buildInitialPoses(pPoseSkeletons?: ISkeleton[]): IAnimation[];

// additional

        private buildComplete(): void;

//---------------------------

        private setOptions(pUserOptions: IColladaLoadOptions): void;
        private setXMLRoot(pXML: Element): void;
        private getXMLRoot(): Element;

        private findMesh(sName: string): IMesh;
        private addMesh(pMesh: IMesh): void;

        private sharedBuffer(pBuffer?: IRenderDataCollection): IRenderDataCollection;
        private prepareInput(pInput: IColladaInput): IColladaInput;

        private isJointsVisualizationNeeded(): bool;
        public  isVisualSceneLoaded(): bool;
        public  isAnimationLoaded(): bool;
        private isSceneNeeded(): bool;
        private isAnimationNeeded(): bool;
        private isPoseExtractionNeeded(): bool;
        private isWireframeEnabled(): bool;
        private getSkeletonsOutput(): ISkeleton[];
        private getVisualScene(): IColladaVisualScene;
        public  getAsset(): IColladaAsset;

        private isLibraryLoaded(sLib: string): bool;
        private isLibraryExists(sLib: string): bool;
        private getLibrary(sLib: string): IColladaLibrary;
        public  getBasename(): string;
        public  getFilename(): string;
        private setFilename(sName: string): void;

        private checkLibraries(pXML: Element, pTemplates: IColladaLibraryTemplate[]): void;
        private readLibraries(pXML: Element, pTemplates: IColladaLibraryTemplate[]): void;


        static DEFAULT_OPTIONS: IColladaLoadOptions = {
            drawJoints      : false,
            wireframe       : false,
            sharedBuffer    : false,
            animation       : { pose: true },
            scene           : true,
            extractPoses    : true,
            skeletons       : null
        };

        private static SCENE_TEMPLATE: IColladaLibraryTemplate[] = [
            {lib : 'library_images',        element : 'image',          loader : "COLLADAImage"         },
            {lib : 'library_effects',       element : 'effect',         loader : "COLLADAEffect"        },
            {lib : 'library_materials',     element : 'material',       loader : "COLLADAMaterial"      },
            {lib : 'library_geometries',    element : 'geometry',       loader : "COLLADAGeometrie"     },
            {lib : 'library_controllers',   element : 'controller',     loader : "COLLADAController"    },
            {lib : 'library_visual_scenes', element : 'visual_scene',   loader : "COLLADAVisualScene"   }
        ];

        private static ANIMATION_TEMPLATE: IColladaLibraryTemplate[] = [
            {lib : 'library_animations',    element : 'animation',      loader : "COLLADAAnimation"     }
        ];

        private static COLLADA_MATERIAL_NAMES: string[] = [
            "emission",
            "ambient",
            "diffuse",
            "shininess",
            "reflective",
            "reflectivity",
            "transparent",
            "transparency",
            "specular"
        ];

//=======================================================================================

        private _pModel: IModel = null;
        private _pOptions: IColladaLoadOptions = null;

        private _pLinks: IColladaLinkMap = {};
        private _pLib: IColladaLibraryMap = {};
        private _pCache: IColladaCache = { meshMap: {}, sharedBuffer: null };

        private _pAsset: IColladaAsset = null;
        private _pVisualScene: IColladaVisualScene = null;

        private _sFilename: string = null;

        private _pXMLRoot: Element = null;



        constructor () {
            super();

        }

// polygon index convertion


        private trifanToTriangles(pXML: Element, iStride:  number ):  number [] {
            var pFans2Tri:  number [] = [0, 0, 0];
            var pData:  number [] = [];
            var tmp:  number [] = new Array(iStride), n;
            var pIndexes:  number [] = [];

            this.eachByTag(pXML, "p", function (pXMLData) {
                n = string2IntArray(stringData(pXMLData), pData);
                for (var i:  number  = 0; i < 3; i++) {
                    retrieve(pData, tmp, iStride, i, 1);
                    for (var j:  number  = 0; j < iStride; ++j) {
                        pIndexes.push(tmp[j]);
                    }
                }

                for (var i:  number  = 3, m = n / iStride; i < m; i++) {
                    pFans2Tri[1] = i - 1;
                    pFans2Tri[2] = i;
                    for (var j:  number  = 0; j < pFans2Tri.length; ++j) {
                        for (var k:  number  = 0; k < iStride; ++k) {
                            pIndexes.push(pData[pFans2Tri[j] * iStride + k]);
                        }
                    }
                }
            });

            return pIndexes;
        }

        private inline polygonToTriangles(pXML: Element, iStride:  number ):  number [] {
//TODO для невыпуклых многоугольников с самоперечечениями работать будет не верно
            return this.trifanToTriangles(pXML, iStride);
        }

        private tristripToTriangles(pXML: Element, iStride:  number ):  number [] {
            var pStrip2Tri:  number [] = [0, 0, 0];
            var pData:  number [] = [];
            var tmp:  number [] = new Array(iStride), n;
            var pIndexes:  number [] = [];

            this.eachByTag(pXML, "p", function (pXMLData) {
                n = string2IntArray(stringData(pXMLData), pData);

                for (var i:  number  = 0; i < 3; i++) {
                    retrieve(pData, tmp, iStride, i, 1);
                    for (var j:  number  = 0; j < iStride; ++j) {
                        pIndexes.push(tmp[j]);
                    }
                }

                for (var i:  number  = 3, m = n / iStride; i < m; i++) {
                    pStrip2Tri[0] = i - 1;
                    pStrip2Tri[1] = i - 2;
                    pStrip2Tri[2] = i;
                    for (var j:  number  = 0; j < pStrip2Tri.length; ++j) {
                        for (var k:  number  = 0; k < iStride; ++k) {
                            pIndexes.push(pData[pStrip2Tri[j] * iStride + k]);
                        }
                    }
                }
            });

            return pIndexes;
        }

        private polylistToTriangles(pXML: Element, iStride:  number ):  number [] {
            var pXMLvcount: Element = firstChild(pXML, "vcount");
            var pXMLp: Element = firstChild(pXML, "p");
            var pVcount:  number [] = new Array(parseInt(attr(pXML, "count")));
            var pData:  number [],
                pIndexes:  number [];
            var n:  number , h:  number  = 0;
            var tmp = new Array(128);
            var buf = new Array(256);
            var pPoly2Tri = [0, 0, 0];

            string2IntArray(stringData(pXMLvcount), pVcount);

            var nElements:  number  = 0,
                nTotalElement:  number  = 0;

            for (var i:  number  = 0; i < pVcount.length; i++) {
                nElements += pVcount[i];
                nTotalElement += (pVcount[i] - 2) * 3;
            }

            pIndexes = new Array(iStride * nTotalElement);
            pData = new Array(iStride * nElements);

            string2IntArray(stringData(pXMLp), pData);

            for (var i:  number  = 0, m = 0; i < pVcount.length; i++) {
                n = retrieve(pData, tmp, iStride, m, pVcount[i]);

                for (var j:  number  = 0; j < 3; j++) {
                    retrieve(tmp, buf, iStride, j, 1);
                    for (var k:  number  = 0; k < iStride; ++k) {
                        pIndexes[h++] = buf[k];
                    }
                }

                for (var x:  number  = 3, t = n / iStride; x < t; x++) {
                    pPoly2Tri[1] = x - 1;
                    pPoly2Tri[2] = x;
                    for (var j:  number  = 0; j < pPoly2Tri.length; ++j) {
                        for (var k:  number  = 0; k < iStride; ++k) {
                            pIndexes[h++] = pData[(m + pPoly2Tri[j]) * iStride + k];
                        }
                    }
                }

                m += pVcount[i];
            }

            return pIndexes;
        }

//xml

        private eachNode(pXMLList: NodeList, fnCallback: IXMLExplorer, nMax?:  number ): void {
            var n:  number  = pXMLList.length, i:  number ;
            nMax = (isNumber(nMax) ? (nMax < n ? nMax : n) : n);

            n = 0;
            i = 0;

            while (n < pXMLList.length) {
//skip text nodes
                if (pXMLList[n ++].nodeType === Node.TEXT_NODE) {
                    continue;
                }

                var pXMLData: Element = <Element>pXMLList[n - 1];
                fnCallback.call(this, pXMLData, pXMLData.nodeName);

                i ++;

                if (nMax === i) {
                    break;
                }
            }

//        for (var i = 0; i < nMax; i++) {
//            var pXMLData = pXMLList.item(i);
//            var sName = pXMLData.getNodeName();
//            fnCallback(pXMLData, sName);
//        }
        }

        private eachChild(pXML: Element, fnCallback: IXMLExplorer): void {
            this.eachNode(pXML.childNodes, fnCallback);
        }

        private inline eachByTag(pXML: Element, sTag: string, fnCallback: IXMLExplorer, nMax?:  number ): void {
            this.eachNode(pXML.getElementsByTagName(sTag), fnCallback, nMax);
        }


// akra additional functions

        private findNode(pNodes: IColladaNode[], sNode: string = null, fnNodeCallback: (pNode: IColladaNode) => void = null): IColladaNode {
            var pNode: IColladaNode = null;
            var pRootJoint: IColladaNode = null;

            for (var i = pNodes.length - 1; i >= 0; i--) {
                pNode = pNodes[i];

                if (pNode === null) {
                    continue;
                }

                if (sNode && "#" + pNode.id === sNode) {
                    return pNode;
                }

                if (!isNull(fnNodeCallback)) {
                    fnNodeCallback.call(this, pNode);
                }

                if (pNode.childNodes) {
                    pRootJoint = this.findNode(pNode.childNodes, sNode, fnNodeCallback);

                    if (!isNull(pRootJoint)) {
                        return pRootJoint;
                    }
                }
            }

            return null;
        }


// helper functions

        private COLLADATranslateMatrix(pXML: Element): IMat4 {
            var pData:  number [] = new Array(3);

            string2FloatArray(stringData(pXML), pData);

            return (vec3(pData)).toTranslationMatrix();
        }

        private COLLADARotateMatrix(pXML: Element): IMat4 {
            var pData:  number [] = new Array(4);

            string2FloatArray(stringData(pXML), pData);

            return (new Mat4(1)).rotateLeft(pData[3] * Math.PI / 180.0, vec3(pData[0], pData[1], pData[2]));
        }

        private COLLADAScaleMatrix(pXML: Element): IMat4 {
            var pData:  number [] = new Array(3);

            string2FloatArray(stringData(pXML), pData);

            return new Mat4(pData[0], pData[1], pData[2], 1.0);
        }

        private COLLADAData(pXML: Element): any {
            var sName: string = pXML.nodeName;
            var sData: string = stringData(pXML);

            switch (sName) {
                case "bool":
                    return string2Any(sData, 1, "bool");

                case "int":
                    return string2Any(sData, 1, "int");

                case "float":
                    return string2Any(sData, 1, "float");

                case "float2":
                    return string2Any(sData, 2, "float");

                case "float3":
                    return string2Any(sData, 3, "float");

                case "float4":
                case "color":
                    return string2Any(sData, 4, "float");

                case "rotate":
                    return this.COLLADARotateMatrix(pXML);

                case "translate":
                    return this.COLLADATranslateMatrix(pXML);

                case "scale":
                    return this.COLLADAScaleMatrix(pXML);

                case "bind_shape_matrix":
                case "matrix":
                    return (new Mat4(string2Any(sData, 16, "float"), true)).transpose();

                case "float_array":
                    return string2Any(sData, parseInt(attr(pXML, "count")), "float", true);

                case "int_array":
                    return string2Any(sData, parseInt(attr(pXML, "count")), "int", true);

                case "bool_array":
                    return string2Any(sData, parseInt(attr(pXML, "count")), "bool", true);

                case "Name_array":
                case "name_array":
                case "IDREF_array":
                    return string2Any(sData, parseInt(attr(pXML, "count")), "string", true);

                case "sampler2D":
                    return this.COLLADASampler2D(pXML);

                case "surface":
                    return this.COLLADASurface(pXML);

                default:
                    logger.setSourceLocation( "resources/Collada.ts" , 588 ); logger.error("unsupported COLLADA data type <" + sName + " />"); ;
            }

//return null;
        }

        private COLLADAGetSourceData(pSource: IColladaSource, pFormat: IColladaUnknownFormat[]): IColladaArray {

            logger.setSourceLocation( "resources/Collada.ts" , 596 ); logger.assert(isDefAndNotNull(pSource), "<source /> with expected format ", pFormat, " not founded"); ;

            var nStride:  number  = calcFormatStride(pFormat);
            var pTech: IColladaTechniqueCommon = pSource.techniqueCommon;

            logger.setSourceLocation( "resources/Collada.ts" , 601 ); logger.assert(isDefAndNotNull(pTech), "<source /> with id <" + pSource.id + "> has no <technique_common />"); ;

            var pAccess: IColladaAccessor = pTech.accessor;
            var isFormatSupported: bool;


            if (!(pAccess.stride <= nStride)) {
                logger.setSourceLocation( "resources/Collada.ts" , 608 ); logger.log(pAccess.stride, "/", nStride); ;
            }


            logger.setSourceLocation( "resources/Collada.ts" , 613 ); logger.assert(pAccess.stride <= nStride, "<source /> width id" + pSource.id + " has unsupported stride: " + pAccess.stride);
                                                                                                           ;

            var fnUnsupportedFormatError = function (): void {
                logger.setSourceLocation( "resources/Collada.ts" , 616 ); logger.log("expected format: " , pFormat); ;
                logger.setSourceLocation( "resources/Collada.ts" , 617 ); logger.log("given format: " , pAccess.params); ;
                logger.setSourceLocation( "resources/Collada.ts" , 618 ); logger.error("accessor of <" + pSource.id + "> has unsupported format"); ;
            }

            for (var i:  number  = 0; i < pAccess.params.length; ++ i) {

                isFormatSupported = false;

//finding name in format names..
                for (var f:  number  = 0; f < pFormat[i].name.length; ++ f) {
                    if ((pAccess.params[i].name || "").toLowerCase() == (pFormat[i].name[f] || "").toLowerCase()) {
                        isFormatSupported = true;
                    }
                }

                if (!isFormatSupported) {
                    fnUnsupportedFormatError();
                }


                isFormatSupported = false;

                for (var f:  number  = 0; f < pFormat[i].type.length; ++f) {
                    if (pAccess.params[i].type.toLowerCase() == pFormat[i].type[f].toLowerCase()) {
                        isFormatSupported = true;
                    }
                }

                if (!isFormatSupported) {
                    fnUnsupportedFormatError();
                }

            }

            return pAccess.data;
        }


// common
// -----------------------------------------------------------

        private COLLADATransform(pXML: Element, id?: string): IColladaTransform {
            var pTransform: IColladaTransform = {
                sid         : attr(pXML, "sid"),
                transform   : String(pXML.nodeName),
                value       : null
            };

            if (isString(id) && isDefAndNotNull(pTransform.sid)) {
                this.link(id + "/" + pTransform.sid, pTransform);
            }
            else {
                this.link(id + "/" + pTransform.transform, pTransform);
            }

            var v4f: IVec4,
                m4f: IMat4;
            var pData:  number [];

            switch (pTransform.transform) {
                case "rotate":

                    pData = new Array(4);
                    string2FloatArray(stringData(pXML), pData);
                    v4f = new Vec4(pData);
/* to radians. */
                    v4f.w *= Math.PI / 180.0;
                    pTransform.value = v4f;

                    break;

                case "translate":
                case "scale":

                    pData = new Array(3);
                    string2FloatArray(stringData(pXML), pData);
                    pTransform.value = new Vec3(pData);
                    break;

                case "matrix":

                    m4f = new Mat4;
                    string2FloatArray(stringData(pXML), < number []><any>m4f.data);
                    m4f.transpose();
                    pTransform.value = m4f;

                    break;

                default:
                    logger.setSourceLocation( "resources/Collada.ts" , 705 ); logger.error("unsupported transform detected: " + pTransform.transform); ;
            }


            return pTransform;
        }

        private COLLADANewParam(pXML: Element): IColladaNewParam {
            var pParam: IColladaNewParam = {
                sid         : attr(pXML, "sid"),
                annotate    : null,
                semantics   : null,
                modifier    : null,
                value       : null,
                type        : null
            };

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "semantic":
                        pParam.semantics = stringData(pXMLData);
                        break;

                    case "modifier":
                        pParam.modifier = stringData(pXMLData);

                    case "annotate":

                        pParam.annotate = {
                            name  : attr(pXMLData, "name"),
                            value : stringData(pXMLData)
                        };

                    case "float":
                    case "float2":
                    case "float3":
                    case "float4":
                    case "surface":
                    case "sampler2D":
                        pParam.type = sName;
                        pParam.value = this.COLLADAData(pXMLData);
                        break;

                    default:
                        pParam.value = this.COLLADAData(pXMLData);
                }
            });

            this.link(pParam.sid, pParam);

            return pParam;
        }

        private COLLADAAsset(pXML: Element): IColladaAsset {
            var pAsset: IColladaAsset = {
                unit : {
                    meter : 1.0,
                    name  : "meter"
                },

                upAxis   : "Y_UP",
                title    : null,
                created  : null,
                modified : null,

                contributor : {
                    author          : null,
                    authoringTool   : null,
                    comments        : null,
                    copyright       : null,
                    sourceData      : null
                }
            };

            this.eachChild(pXML, (pXMLNode: Element, sName?: string) => {
                var sValue: string = stringData(pXMLNode);

                switch (sName) {
                    case "up_axis":
                        pAsset.upAxis = sValue;
                        break;

                    case "created":
                        pAsset.created = sValue;
                        break;

                    case "modified":
                        pAsset.modified = sValue;
                        break;

                    case "title":
                        pAsset.title = sValue;
                        break;

                    case "contributor":
//TODO contributor
                        break;

                    case "unit":
                        pAsset.unit.meter = parseFloat(attr(pXMLNode, "meter"));
                        pAsset.unit.name = attr(pXMLNode, "name");
                        break;
                }
            });

            return this._pAsset = pAsset;
        }

        private COLLADALibrary(pXML: Element, pTemplate: IColladaLibraryTemplate): IColladaLibrary {
            if (!isDefAndNotNull(pXML)) {
                return null;
            }

            var pLib: IColladaLibrary = <IColladaLibrary>{};
            var pData: IColladaEntry;
            var sTag: string = pTemplate.element;

            pLib[sTag] = {};

            this.eachChild(pXML, (pXMLData: Element, sName?: string): void => {
                if (sTag !== sName) {
                    return;
                }

                pData = (<IColladaEntryLoader>((<any>this)[pTemplate.loader]))(pXMLData);

                if (isNull(pData)) {
                    return;
                }

                pLib[sTag][attr(pXMLData, 'id')] = pData;
            });

            return pLib;
        }


// geometry

        private COLLADAAccessor(pXML: Element): IColladaAccessor {
            var pAccessor: IColladaAccessor = {
                data   : <IColladaArray>this.source(attr(pXML, "source")),
                count  : parseInt(attr(pXML, "count")),
                stride : parseInt(attr(pXML, "stride") || 1),
                params : []
            };


            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                pAccessor.params.push({
                                          name : attr(pXMLData, "name"),
                                          type : attr(pXMLData, "type")
                                      });
            });

            return pAccessor;
        }

//dangerous: the default offset is 0, but collada required this attribute
        private COLLADAInput(pXML: Element, iOffset:  number  = 0): IColladaInput {
            var pInput: IColladaInput = {
                semantics : attr(pXML, "semantic"),
                source    : <IColladaSource>this.source(attr(pXML, "source")),
                offset    : -1,
                set       : attr(pXML, "set")
            };
//pInput.set = (pInput.set ? parseInt(pInput.set) : 0);

            if (!isNull(attr(pXML, "offset"))) {
                pInput.offset = parseInt(attr(pXML, "offset"));
            }

            if (isInt(iOffset) && pInput.offset === -1) {
                pInput.offset = iOffset;
            }

            logger.setSourceLocation( "resources/Collada.ts" , 881 ); logger.assert(isInt(pInput.offset) && pInput.offset >= 0, "invalid offset detected"); ;

            return pInput;
        }

        private COLLADATechniqueCommon(pXML: Element): IColladaTechniqueCommon {
            var pTechniqueCommon: IColladaTechniqueCommon = {
                accessor : null
            };

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "accessor":
                        pTechniqueCommon.accessor = this.COLLADAAccessor(pXMLData);
                        break;
                }
            });

            return pTechniqueCommon;
        }

        private COLLADASource(pXML: Element): IColladaSource {
            var pSource: IColladaSource = {
                id               : attr(pXML, "id"),
                name             : attr(pXML, "name"),
                array           : {},
                techniqueCommon : null
            };

            this.link(pSource);

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                var pColladaArray: IColladaArray;
                var id: string;

                switch (sName.toLowerCase()) {
                    case "int_array":
                    case "bool_array":
                    case "float_array":
                    case "idref_array":
                    case "name_array":
                        pColladaArray = <IColladaArray>this.COLLADAData(pXMLData);

                        id = attr(pXMLData, "id");
                        pSource.array[id] = pColladaArray;

                        this.link(id, pColladaArray);

                        break;
                    case "technique_common":
                        pSource.techniqueCommon = this.COLLADATechniqueCommon(pXMLData);
                        break;
                }
            });

            return pSource;
        }

        private COLLADAVertices(pXML: Element): IColladaVertices {
            var pVertices: IColladaVertices = {
                id      : attr(pXML, "id"),
                inputs  : {}
            };


            this.eachByTag(pXML, "input", function (pXMLData) {
                var sSemantic: string = attr(pXMLData, "semantic");
                pVertices.inputs[sSemantic] = this.COLLADAInput(pXMLData);
            });


            logger.setSourceLocation( "resources/Collada.ts" , 953 ); logger.assert(isDefAndNotNull(pVertices.inputs["POSITION"]), "semantics POSITION must be in the <vertices /> tag");
                                                                              ;

            this.link(pVertices);

            return pVertices;
        }

        private COLLADAJoints(pXML: Element): IColladaJoints {
            var pJoints: IColladaJoints = {
                inputs : {}
            };

            var pMatrixArray: IMat4[];
            var iCount:  number ;
            var pInvMatrixArray: Float32Array;

            this.eachByTag(pXML, "input", (pXMLData: Element): void => {
                switch (attr(pXMLData, "semantic")) {
                    case "JOINT":
                        pJoints.inputs["JOINT"] = this.COLLADAInput(pXMLData);
                        break;

                    case "INV_BIND_MATRIX":
                        pJoints.inputs["INV_BIND_MATRIX"] = this.COLLADAInput(pXMLData);
                        break;

                    default:
                        logger.setSourceLocation( "resources/Collada.ts" , 980 ); logger.error("semantics are different from JOINT/INV_BIND_MATRIX is not supported in the <joints /> tag"); ;
                }
            });


            for (var sInput in pJoints.inputs) {
                this.prepareInput(pJoints.inputs[sInput]);

                if (sInput === "INV_BIND_MATRIX") {

                    pInvMatrixArray = new Float32Array(pJoints.inputs[sInput].array);
                    iCount = pInvMatrixArray.length / 16;
                    pMatrixArray = new Array(iCount);

                    for (var j:  number  = 0, n:  number  = 0; j < pInvMatrixArray.length; j += 16) {
                        pMatrixArray[n++] =
                            (new Mat4(
                                new Float32Array(pInvMatrixArray.buffer, j * Float32Array.BYTES_PER_ELEMENT, 16), true)
                            ).transpose();
                    }

                    pJoints.inputs[sInput].array = pMatrixArray;
                }
            }

            return pJoints;
        }

        private COLLADAPolygons(pXML: Element, sType: string): IColladaPolygons {
            var pPolygons: IColladaPolygons = {
/*потоки данных*/
                inputs    : [],
/*индексы*/
                p         : null,
/*идентификатор материала*/
                material  : attr(pXML, "material"),
/*имя (встречается редко, не используется)*/
                name      : null
            };

            var iOffset:  number  = 0, n:  number  = 0;
            var iCount:  number  = parseInt(attr(pXML, "count"));
            var iStride:  number ;

            this.eachByTag(pXML, "input", (pXMLData: Element): void => {
                pPolygons.inputs.push(this.COLLADAInput(pXMLData, iOffset));
                iOffset ++;
            });

            sortArrayByProperty(pPolygons.inputs, "iOffset");

            iStride = (<IColladaInput>pPolygons.inputs.last).offset + 1;

            switch (sType) {
                case "polylist":
                    pPolygons.p = this.polylistToTriangles(pXML, iStride);
                    break;

                case "polygons":
                    pPolygons.p = this.polygonToTriangles(pXML, iStride);

                    this.eachByTag(pXML, "ph", (pXMLData: Element): void => {
                        logger.setSourceLocation( "resources/Collada.ts" , 1038 ); logger.error("unsupported polygon[polygon] subtype founded: <ph>"); ;
                    });

                    break;

                case "triangles":
                    pPolygons.p = new Array(3 * iCount * iStride);

                    this.eachByTag(pXML, "p", (pXMLData: Element): void => {
                        n += string2IntArray(stringData(pXMLData), pPolygons.p, n);
                    });

                    break;
                case "trifans":
                    pPolygons.p = this.trifanToTriangles(pXML, iStride);
                    break;

                case "tristrips":
                    pPolygons.p = this.tristripToTriangles(pXML, iStride);
                    break;

                default:
                    logger.setSourceLocation( "resources/Collada.ts" , 1060 ); logger.error("unsupported polygon[" + sType + "] type founded"); ;
            }

            if (!isDef(pPolygons.type)) {
                pPolygons.type = EPrimitiveTypes.TRIANGLELIST;
            }

            return pPolygons;
        }

        private COLLADAVertexWeights(pXML: Element): IColladaVertexWeights {
            var pVertexWeights: IColladaVertexWeights = {
                count       : parseInt(attr(pXML, "count")),
                inputs      : [],
                weightInput : null,
                vcount      : null,
                v           : null
            };

            var iOffset:  number  = 0;
            var pInput: IColladaInput;

            this.eachByTag(pXML, "input", (pXMLData: Element): void => {
                pInput = this.COLLADAInput(pXMLData, iOffset);

                if (pInput.semantics === "WEIGHT") {
                    pVertexWeights.weightInput = pInput;
                }

                pVertexWeights.inputs.push(pInput);
                iOffset ++;
            });

            var pVcountData:  number [],
                pVData:  number [];

            pVcountData = new Array(pVertexWeights.count);
            string2IntArray(stringData(firstChild(pXML, "vcount")), pVcountData);
            pVertexWeights.vcount = pVcountData;


            var n:  number  = 0;

            for (var i:  number  = 0; i < pVcountData.length; ++i) {
                n += pVcountData[i];
            }

            n *= pVertexWeights.inputs.length;

            logger.setSourceLocation( "resources/Collada.ts" , 1110 ); logger.assert(pVertexWeights.inputs.length === 2, "more than 2 inputs in <vertex_weights/> not supported currently");
                                                                                           ;

            pVData = new Array(n);
            string2IntArray(stringData(firstChild(pXML, "v")), pVData);
            pVertexWeights.v = pVData;

            return pVertexWeights;
        }

        private COLLADAMesh(pXML: Element): IColladaMesh {
            var pMesh: IColladaMesh = {
                sources   : [],
                polygons  : []
            };

            var id: string;
            var pPolygons: IColladaPolygons,
                pVertices: IColladaVertices,
                pPos: IColladaInput;

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "source":
                        pMesh.sources.push(this.COLLADASource(pXMLData));
                        break;

                    case "vertices":
                        pVertices = this.COLLADAVertices(pXMLData);
                        break;

                    case "lines":
                    case "linestrips":
                    case "tristrips":
                    case "trifans":
                    case "triangles":
                    case "polygons":
                    case "polylist":
                        pPolygons = this.COLLADAPolygons(pXMLData, sName);

                        for (var i:  number  = 0; i < pPolygons.inputs.length; ++i) {
                            pPos = null;

                            if (pPolygons.inputs[i].semantics == "VERTEX") {
                                if (pPolygons.inputs[i].source.id == pVertices.id) {
                                    pPos = pVertices.inputs["POSITION"];

                                    pPolygons.inputs[i].source = pPos.source;
                                    pPolygons.inputs[i].semantics = pPos.semantics;
                                }
                                else {
                                    logger.setSourceLocation( "resources/Collada.ts" , 1160 ); logger.error("<input /> with semantic VERTEX must refer to <vertices /> tag in same mesh."); ;
                                }
                            }

                            this.prepareInput(pPolygons.inputs[i]);
                        }

                        pMesh.polygons.push(pPolygons);
                        break;
                }
            });

            return pMesh;
        }

        private COLLADAGeometrie(pXML: Element): IColladaGeometrie {
            var pGeometrie: IColladaGeometrie = {
                id         : attr(pXML, "id"),
                name       : attr(pXML, "name"),
                mesh       : null,
                convexMesh : null,
                spline     : null,
            };

            var pXMLData: Element = firstChild(pXML);
            var sName: string = pXMLData.nodeName;

            if (sName == "mesh") {
                pGeometrie.mesh = this.COLLADAMesh(pXMLData);
            }

            this.link(pGeometrie);

            return pGeometrie;
        }

        private COLLADASkin(pXML: Element): IColladaSkin {
            var pSkin: IColladaSkin = {
                shapeMatrix   : <IMat4>this.COLLADAData(firstChild(pXML, "bind_shape_matrix")),
                sources       : [],
                geometry      : <IColladaGeometrie>this.source(attr(pXML, "source")),
                joints        : null,
                vertexWeights : null

//TODO:  add other parameters to skin section
            }

            var pVertexWeights: IColladaVertexWeights,
                pInput: IColladaInput;

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "source":
                        pSkin.sources.push(this.COLLADASource(pXMLData));
                        break;

                    case "joints":
                        pSkin.joints = this.COLLADAJoints(pXMLData);
                        break;

                    case "vertex_weights":
                        pVertexWeights = this.COLLADAVertexWeights(pXMLData);

                        for (var i = 0; i < pVertexWeights.inputs.length; ++ i) {
                            pInput = this.prepareInput(pVertexWeights.inputs[i]);
                        }

                        pSkin.vertexWeights = pVertexWeights;
                        break;
                }
            });

            return pSkin;
        }

        private COLLADAController(pXML: Element): IColladaController {
            var pController: IColladaController = {
                name  : attr(pXML, "name"),
                id    : attr(pXML, "id"),
                skin  : null,
                morph : null
            };

            var pXMLData: Element = firstChild(pXML, "skin");

            if (!isNull(pXMLData)) {
                pController.skin = this.COLLADASkin(pXMLData);
            }
            else {
                logger.setSourceLocation( "resources/Collada.ts" , 1249 ); logger.warning("Founded controller without skin element!"); ;
                return null;
            }

            this.link(pController);

            return pController;
        }

// images

        private COLLADAImage(pXML: Element): IColladaImage {
            var pImage: IColladaImage = {
                id        : attr(pXML, "id"),
                name      : attr(pXML, "name"),

                format    : attr(pXML, "format"),
/*-1 == auto detection*/
                height    : parseInt(attr(pXML, "height") || -1),
                width     : parseInt(attr(pXML, "width") || -1),

/*only 2D images supported*/
                depth     : 1,
                data      : null,
                path      : null
            };

            var sFilename: string = this.getFilename();
            var sPath: string = null;
            var pXMLInitData: Element = firstChild(pXML, "init_from"),
                pXMLData: Element;

            if (isDefAndNotNull(pXMLInitData)) {
                sPath = stringData(pXMLInitData);

//modify path to the textures relative to a given file
                if (!isNull(sFilename)) {
                    if (!util.pathinfo(sPath).isAbsolute()) {
                        sPath = util.pathinfo(sFilename).dirname + "/" + sPath;
                    }
                }

                pImage.path = sPath;
            }
            else if (isDefAndNotNull(pXMLData = firstChild(pXML, "data"))) {
                logger.setSourceLocation( "resources/Collada.ts" , 1292 ); logger.error("image loading from <data /> tag unsupported yet."); ;
            }
            else {
                logger.setSourceLocation( "resources/Collada.ts" , 1295 ); logger.error("image with id: " + pImage.id + " has no data."); ;
            }

            this.link(pImage);

            return pImage;
        }

// effects

        private COLLADASurface(pXML: Element): IColladaSurface {
            var pSurface: IColladaSurface = {
                initFrom : stringData(firstChild(pXML, "init_from"))
//, format: stringData(firstChild(pXML, "format"))
            }

            return pSurface;
        }

        private COLLADATexture(pXML: Element): IColladaTexture {
            var pTexture: IColladaTexture = {
                texcoord : attr(pXML, "texcoord"),
                sampler  : <IColladaNewParam>this.source(attr(pXML, "texture")),
                surface  : null,
                image    : null
            };

            if (!isNull(pTexture.sampler) && isDefAndNotNull(pTexture.sampler.value)) {
                pTexture.surface = <IColladaNewParam>this.source((<IColladaSampler2D>pTexture.sampler.value).source);
            }

            if (!isNull(pTexture.surface)) {
                pTexture.image = <IColladaImage>this.source((<IColladaSurface>pTexture.surface.value).initFrom);
            }

            return pTexture;
        }

        private COLLADASampler2D(pXML: Element): IColladaSampler2D {
            var pSampler: IColladaSampler2D = {
                source    : stringData(firstChild(pXML, "source")),
                wrapS     : stringData(firstChild(pXML, "wrap_s")),
                wrapT     : stringData(firstChild(pXML, "wrap_t")),
                minFilter : stringData(firstChild(pXML, "minfilter")),
                mipFilter : stringData(firstChild(pXML, "mipfilter")),
                magFilter : stringData(firstChild(pXML, "magfilter"))
            };

            return pSampler;
        }

        private COLLADAPhong(pXML: Element): IColladaPhong {
            var pMat: IColladaPhong = {
                diffuse             : new Color(0.),
                specular            : new Color(0.),
                ambient             : new Color(0.),
                emissive            : new Color(0.),
                shininess           : 0.0,

                reflective          : new Color(0.),
                reflectivity        : 0.0,
                transparent         : new Color(0.),
                transparency        : 0.0,

                indexOfRefraction   : 0.0,

                textures: {
                    diffuse     : null,
                    specular    : null,
                    ambient     : null,
                    emissive    : null
                }
            };

            var pXMLData: Element;
            var pList: string[] = Collada.COLLADA_MATERIAL_NAMES;

            for (var i:  number  = 0; i < pList.length; i++) {
                var csComponent: string = pList[i];

                pXMLData = firstChild(pXML, csComponent);

//emission --> emissive
//emission does not exists in akra engine materials

                if (csComponent === "emission") {
                    csComponent = "emissive";
                }

                if (pXMLData) {
                    this.eachChild(pXMLData, (pXMLData: Element, sName?: string) => {

                        switch (sName) {
                            case "float":
                                pMat[csComponent] = < number >this.COLLADAData(pXMLData);
                                break;

                            case "color":
                                pMat[csComponent].set(<IColorValue>this.COLLADAData(pXMLData));
                                break;

                            case "texture":
                                pMat.textures[csComponent] = this.COLLADATexture(pXMLData);
                        }
                    });

                }
            }

// correct shininess
            pMat.shininess *= 10.0;

            return pMat;
        }

        private COLLADAEffectTechnique(pXML: Element): IColladaEffectTechnique {
            var pTech: IColladaEffectTechnique = {
                sid   : attr(pXML, "sid"),
                type  : null,
                value : null
            };

            var pValue: Element = firstChild(pXML);

            pTech.type = pValue.nodeName;

            switch (pTech.type) {
//FIXME: at now, all materials draws similar..
                case "blinn":
                case "lambert":
                    logger.setSourceLocation( "resources/Collada.ts" , 1425 ); logger.warning("<blinn /> or <lambert /> material interprated as phong"); ;
                case "phong":
                    pTech.value = this.COLLADAPhong(pValue);
                    break;

                default:
                    logger.setSourceLocation( "resources/Collada.ts" , 1431 ); logger.error("unsupported technique <" + pTech.type + " /> founded"); ;
            }

            this.link(pTech.sid, pTech);

            return pTech;
        }

        private COLLADAProfileCommon(pXML: Element): IColladaProfileCommon {
            var pProfile: IColladaProfileCommon = {
                technique : null,
                newParam  : {}
            };

            this.eachByTag(pXML, "newparam", (pXMLData: Element): void => {
                pProfile.newParam[attr(pXMLData, "sid")] = this.COLLADANewParam(pXMLData);
            })

            pProfile.technique = this.COLLADAEffectTechnique(firstChild(pXML, "technique"));

            return pProfile;
        }

        private COLLADAEffect(pXML: Element): IColladaEffect {
            var pEffect: IColladaEffect = {
                id             : attr(pXML, "id"),
                profileCommon  : null
            };

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "profile_COMMON":
                        pEffect.profileCommon = this.COLLADAProfileCommon(pXMLData);
                        pEffect.profileCommon.technique.value.name = pEffect.id;
                        break;

                    case "extra":
                        break;

                    default:
                        logger.setSourceLocation( "resources/Collada.ts" , 1471 ); logger.error("<" + sName + " /> unsupported in effect section"); ;
                }
            });

            this.link(pEffect);

            return pEffect;
        }


//materials

        private COLLADAMaterial(pXML: Element): IColladaMaterial {
            var pMaterial: IColladaMaterial = {
                id             : attr(pXML, "id"),
                name           : attr(pXML, "name"),
                instanceEffect : this.COLLADAInstanceEffect(firstChild(pXML, "instance_effect"))
            };

            this.link(pMaterial);

            return pMaterial;
        }

// scene

        private COLLADANode(pXML: Element, iDepth:  number  = 0): IColladaNode {
            var pNode: IColladaNode = {
                id              : attr(pXML, "id"),
                sid             : attr(pXML, "sid"),
                name            : attr(pXML, "name") || "unknown",
                type            : attr(pXML, "type"),
                layer           : attr(pXML, "layer"),
                transform       : new Mat4(1),
                geometry        : [],
                controller      : [],
                childNodes      : [],
                depth           : iDepth,
                transforms      : [],
/*<! узел, в котором будет хранится ссылка на реальный игровой нод, построенный по нему*/
                constructedNode : null
            };

            var m4fMatrix: IMat4;
            var sType: string;
            var id: string, sid: string;

            this.link(pNode);

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "rotate":
                    case "matrix":
                    case "translate":
                    case "scale":
                        pNode.transforms.push(this.COLLADATransform(pXMLData, pNode.id));
                        pNode.transform.multiply(<IMat4>this.COLLADAData(pXMLData));
                        break;

                    case "instance_geometry":
                        pNode.geometry.push(this.COLLADAInstanceGeometry(pXMLData));
                        break;

                    case "instance_controller":
                        pNode.controller.push(this.COLLADAInstanceController(pXMLData));
                        break;

                    case "node":
                        pNode.childNodes.push(this.COLLADANode(pXMLData, iDepth + 1));
                        break;
                }
            });

//TODO: do not load empty nodes..
// if (!pNode.pGeometry.length && 
//     !pNode.pController.length && 
//     !pNode.pChildNodes.length) {
//     return null;
// }

            return pNode;
        }

        private COLLADAVisualScene(pXML: Element): IColladaVisualScene {
            var pNode: IColladaNode;
            var pScene: IColladaVisualScene = {
                id     : attr(pXML, "id"),
                name   : attr(pXML, "name"),
                nodes : []
            };

            this.link(pScene);

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "node":
                        pNode = this.COLLADANode(pXMLData);

                        if (isDefAndNotNull(pNode)) {
                            pScene.nodes.push(pNode);
                        }

                        break;
                }
            });

            return pScene;
        }

        private COLLADABindMaterial(pXML: Element): IColladaBindMaterial {
            if (isNull(pXML)) {
                return null;
            }

            var pMaterials: IColladaBindMaterial = {};
            var pMat: IColladaInstanceMaterial = null;
            var pSourceMat: IColladaMaterial = null;
            var pTech: Element = firstChild(pXML, "technique_common");

            this.eachByTag(pTech, "instance_material", (pInstMat: Element): void => {

                pSourceMat = <IColladaMaterial>this.source(attr(pInstMat, "target"));

                pMat = {
// url         : pSourceMat.instanceEffect.url,
                    target      : attr(pInstMat, "target"),
                    symbol      : attr(pInstMat, "symbol"),
                    material    : pSourceMat,
                    vertexInput : <IColladaBindVertexInputMap>{}
                };

                this.eachByTag(pInstMat, "bind_vertex_input", (pXMLVertexInput: Element): void => {
                    var sInputSemantic: string = attr(pXMLVertexInput, "input_semantic");

                    if (sInputSemantic !== "TEXCOORD") {
                        logger.setSourceLocation( "resources/Collada.ts" , 1605 ); logger.error("unsupported vertex input semantics founded: " + sInputSemantic); ;
                    }


                    var sSemantic: string = attr(pXMLVertexInput, "semantic");
                    var iInputSet:  number  = parseInt(attr(pXMLVertexInput, "input_set"));

                    pMat.vertexInput[sSemantic] = {
                        semantics       : sSemantic,
                        inputSet        : iInputSet,
                        inputSemantic   : sInputSemantic
                    };
                });

                pMaterials[pMat.symbol] = pMat;
            });

            return pMaterials;
        }

        private COLLADAInstanceEffect(pXML: Element): IColladaInstanceEffect {
            var pInstance: IColladaInstanceEffect = {
                parameters    : {},
                techniqueHint : <StringMap>{},
                effect        : null
            };

/*
                Exmaple for <instance_effect /> :
            
                <instance_effect url="CarPaint">
                    <technique_hint profile="CG" platform="PS3" ref="precalc_texture"/>
                    <setparam ref="diffuse_color">
                        <float3> 0.3 0.25 0.85 </float3>
                    </setparam>
                </instance_effect>
            */


            pInstance.effect = <IColladaEffect>this.source(attr(pXML, "url"));

            this.eachByTag(pXML, "technique_hint", (pXMLData: Element): void => {
                pInstance.techniqueHint[attr(pXMLData, "platform")] = attr(pXMLData, "ref");
                logger.setSourceLocation( "resources/Collada.ts" , 1647 ); logger.warning("<technique_hint /> used, but will be ignored!"); ;
            });

            this.eachByTag(pXML, "setparam", (pXMLData: Element): void => {
//can be any type
                pInstance.parameters[attr(pXMLData, "ref")] = <any>this.COLLADAData(pXMLData);
                logger.setSourceLocation( "resources/Collada.ts" , 1653 ); logger.warning("<setparam /> used, but will be ignored!"); ;
            });

            return pInstance;
        }

        private COLLADAInstanceController(pXML: Element): IColladaInstanceController {
            var pInst: IColladaInstanceController = {
                controller : <IColladaController>this.source(attr(pXML, "url")),
                material   : <IColladaBindMaterial>this.COLLADABindMaterial(firstChild(pXML, "bind_material")),
                skeletons  : []
            };

            this.eachByTag(pXML, "skeleton", (pXMLData: Element): void => {
//cut # symbol from skeleton name
                pInst.skeletons.push(stringData(pXMLData).substr(1));
            });

            return pInst;
        }

        private COLLADAInstanceGeometry(pXML: Element): IColladaInstanceGeometry {
            var pInst: IColladaInstanceGeometry = {
                geometry : <IColladaGeometrie>this.source(attr(pXML, "url")),
                material : <IColladaBindMaterial>this.COLLADABindMaterial(firstChild(pXML, "bind_material"))
            };

            return pInst;
        }

// directly load <visual_scene> from <instance_visual_scene> from <scene>.
        private COLLADAScene(pXML: Element): IColladaVisualScene {
            var pXMLData: Element = firstChild(pXML, "instance_visual_scene");
            var pScene: IColladaVisualScene = <IColladaVisualScene>this.source(attr(pXMLData, "url"));

            if (isNull(pXMLData) || isNull(pScene)) {
                logger.setSourceLocation( "resources/Collada.ts" , 1689 ); logger.warning("collada model: <" + this.getBasename() + "> has no visual scenes."); ;
            }

            return this._pVisualScene = pScene;
        }

// animation

        private COLLADAAnimationSampler(pXML: Element): IColladaAnimationSampler {
            var pSampler: IColladaAnimationSampler = {
                inputs : {},
                id    : attr(pXML, "id")
            };


            var pInput: IColladaInput;
            var sSemantic: string;

            this.link(pSampler);

            this.eachByTag(pXML, "input", (pXMLData: Element): void => {
                sSemantic = attr(pXMLData, "semantic");

                switch (sSemantic) {
                    case "INPUT":
                    case "OUTPUT":
                    case "INTERPOLATION":
                    case "IN_TANGENT":
                    case "OUT_TANGENT":
                        pInput = this.prepareInput(this.COLLADAInput(pXMLData));
                        pSampler.inputs[sSemantic] = pInput;
                        break;

                    default:
                        logger.setSourceLocation( "resources/Collada.ts" , 1723 ); logger.error("semantics are different from OUTPUT/INTERPOLATION/IN_TANGENT/OUT_TANGENT is not supported in the <sampler /> tag"); ;
                }
            });

            return pSampler;
        }

        private COLLADAAnimationChannel(pXML: Element): IColladaAnimationChannel {
            var pChannel: IColladaAnimationChannel = {
                sampler : <IColladaAnimationSampler>this.source(attr(pXML, "source")),
                target  : this.target(attr(pXML, "target"))
            };


            if (isNull(pChannel.target) || isNull(pChannel.target.object)) {
                logger.setSourceLocation( "resources/Collada.ts" , 1738 ); logger.warning("cound not setup animation channel for <" + attr(pXML, "target") + ">"); ;
                return null;
            }

            return pChannel;
        }


        private COLLADAAnimation(pXML: Element): IColladaAnimation {
            var pAnimation: IColladaAnimation = {
                id          : attr(pXML, "id"),
                name        : attr(pXML, "name"),
                sources     : [],
                samplers    : [],
                channels    : [],
                animation   : []
            };

            var pChannel: IColladaAnimationChannel;
            var pSubAnimation: IColladaAnimation;

            this.link(pAnimation);

            this.eachChild(pXML, (pXMLData: Element, sName?: string) => {
                switch (sName) {
                    case "source":
                        pAnimation.sources.push(this.COLLADASource(pXMLData));
                        break;

                    case "sampler":
                        pAnimation.samplers.push(this.COLLADAAnimationSampler(pXMLData));
                        break;

                    case "channel":
                        pChannel = this.COLLADAAnimationChannel(pXMLData);

                        if (isDefAndNotNull(pChannel)) {
//this guard for skipping channels with unknown targets
                            pAnimation.channels.push(pChannel);
                        }

                        break;
                    case "animation":
                        pSubAnimation = this.COLLADAAnimation(pXMLData);

                        if (isDefAndNotNull(pSubAnimation)) {
                            pAnimation.animation.push(pSubAnimation);
                        }
                }
            });

            if (pAnimation.channels.length == 0 && pAnimation.animation.length == 0) {
                logger.setSourceLocation( "resources/Collada.ts" , 1790 ); logger.warning("animation with id \"" + pAnimation.id + "\" skipped, because channels/sub animation are empty"); ;
                return null;
            }

            return pAnimation;
        }

// collada mapping

        private source(sUrl: string): IColladaEntry {
             if (sUrl.charAt(0) !== "#") {
                sUrl = "#" + sUrl;
            }

            var pElement: IColladaEntry = this._pLinks[sUrl];

            if (!isDefAndNotNull(pElement)) {
                logger.setSourceLocation( "resources/Collada.ts" , 1807 ); logger.warning("cannot find element with id: " + sUrl + ("\n" + (<any>new Error).stack.split("\n").slice(1).join("\n")) ); ;
            }

            return pElement || null;
        }


        private link(el: any, pTarget?: IColladaEntry): void {
            var sId: string;

            if (!isString(arguments[0])) {
                pTarget = <IColladaEntry>arguments[0];
                sId = pTarget.id;
            }
            else {
                sId = <string>arguments[0];
            }

            this._pLinks["#" + sId] = pTarget;
        }

//astroBoy_newSkeleton_root/rotateY.ANGLE
//pObject.source: IColladaEntry = astroBoy_newSkeleton_root
//pSource: IColladaTransform = source(astroBoy_newSkeleton_root/rotateY)
//pSource: IColladaTransform = {
//    sid: string;  //rotateY
//    value: IVec4; //<0 1 0 -4.56752>
//    name: string; //rotate
//  }
//
//sValue: string = "ANGLE"
//pObject.object: IColladaTransform = pSource;
//
        private target(sPath: string): IColladaTarget {
            var pObject: IColladaTarget = {value : null};
            var pSource: IColladaTransform;

            var pMatches: string[];
            var sValue: string;

            var iPos:  number ;
            var jPos:  number  = 0;

            iPos = sPath.lastIndexOf("/");

            if (iPos >= 0) {
                pObject.source = this.source(sPath.substr(0, iPos));
            }

            iPos = sPath.lastIndexOf(".");

            if (iPos < 0) {
                iPos = sPath.indexOf("(");
                jPos = -1;
            }

            if (iPos < 0) {
                pObject.object = this.source(sPath);
                return pObject;
            }

            pSource = <IColladaTransform>this.source(sPath.substr(0, iPos));
            sValue = sPath.substr(iPos + jPos + 1);
            pObject.object = pSource;

            if (!pSource) {
                return null;
            }

            switch (sValue) {
                case "X":
                    pObject.value = (<IVec4>pSource.value).x;
                    break;
                case "Y":
                    pObject.value = (<IVec4>pSource.value).y;
                    break;
                case "Z":
                    pObject.value = (<IVec4>pSource.value).z;
                    break;
                case "W":
                    pObject.value = (<IVec4>pSource.value).w;
                    break;
                case "ANGLE":
                    pObject.value = (<IVec4>pSource.value).w;
//<rotate sid="rotateY">0 1 0 -4.56752</rotate>
                    break;
            }

            if (isDefAndNotNull(pObject.value)) {
                return pObject;
            }

            pMatches = sValue.match(/^\((\d+)\)$/);

            if (pMatches) {
                pObject.value = Number(pMatches[1]);
            }

            pMatches = sValue.match(/^\((\d+)\)\((\d+)\)$/)

            if (pMatches) {
//trace(pMatches, '--->',  Number(pMatches[2]) * 4 + Number(pMatches[1]));
//pObject.value = Number(pMatches[2]) * 4 + Number(pMatches[1]);
                pObject.value = Number(pMatches[1]) * 4 + Number(pMatches[2]);
            }

            logger.setSourceLocation( "resources/Collada.ts" , 1913 ); logger.assert(isDefAndNotNull(pObject.value), "unsupported target value founded: " + sValue); ;

            return pObject;
        }

// //animation 

        private buildAnimationTrack(pChannel: IColladaAnimationChannel): IAnimationTrack {
            var sNodeId: string = pChannel.target.source.id;
            var sJoint: string = this.source(sNodeId).sid || null;
            var pTrack: IAnimationTrack = null;
            var pSampler: IColladaAnimationSampler = pChannel.sampler;

            logger.setSourceLocation( "resources/Collada.ts" , 1926 ); logger.assert(isDefAndNotNull(pSampler), "could not find sampler for animation channel"); ;

            var pInput: IColladaInput = pSampler.inputs["INPUT"];
            var pOutput: IColladaInput = pSampler.inputs["OUTPUT"];
            var pInterpolation: IColladaInput = pSampler.inputs["INTERPOLATION"];

            var pTimeMarks:  number [] = pInput.array;
            var pOutputValues:  number [] = pOutput.array;
            var pFloatArray: Float32Array;

            var pTransform: IColladaEntry = pChannel.target.object
            var sTransform: string = pTransform.name;
            var v4f: IVec4;
            var pValue: any;
            var nMatrices:  number ;

// if (sJoint == null) {
//     warning('node\'s <' + pChannel.pTarget.pSource.id + '> "sid" attribute is null');
// }

            switch (sTransform) {
                case "translate":
// pTrack = new a.AnimationTranslation(sJoint);

// for (var i = 0, v3f = new Array(3), n; i < pTimeMarks.length; ++ i) {
//     n = i * 3;
//     v3f.X = pOutputValues[i * 3];
//     v3f.Y = pOutputValues[i * 3 + 1];
//     v3f.Z = pOutputValues[i * 3 + 2];
//     pTrack.keyFrame(pTimeMarks[i], [v3f.X, v3f.Y, v3f.Z]);
// };
                    logger.setSourceLocation( "resources/Collada.ts" , 1957 ); logger.criticalError("TODO: implement animation translation"); ;
//TODO: implement animation translation
                    break;
                case "rotate":
// v4f = pTransform.pValue;
// pTrack = new a.AnimationRotation(sJoint, [v4f[1], v4f[2], v4f[3]]);

// debug_assert(pOutput.pAccessor.iStride === 1, 
//     "matrix modification supported only for one parameter modification");

// for (var i = 0; i < pTimeMarks.length; ++ i) {
//     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i] / 180.0 * Math.PI);
// };
                    logger.setSourceLocation( "resources/Collada.ts" , 1970 ); logger.criticalError("TODO: implement animation rotation"); ;
//TODO: implement animation rotation
                    break;
                case "matrix":
                    pValue = pChannel.target.value;
                    if (isNull(pValue)) {
                        pTrack = animation.createTrack(sJoint);
                        nMatrices = pOutputValues.length / 16;
                        pFloatArray = new Float32Array(pOutputValues);

                        logger.setSourceLocation( "resources/Collada.ts" , 1981 ); logger.assert(nMatrices % 1 === 0.0, "incorrect output length of transformation data (" + pFloatArray.length + ")");
                                                                                                                   ;

                        for (var i:  number  = 0; i < nMatrices; i++) {
                            pTrack.keyFrame(pTimeMarks[i],
                                            (new Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true)).transpose());
                        }


// i=0;
// var m = (new Mat4(pFloatArray.subarray(i * 16, i * 16 + 16), true));
// trace(sFilename,sNodeId,m.toString());
                    }
                    else {
// pTrack = new a.AnimationMatrixModification(sJoint, pValue);

// for (var i = 0; i < pTimeMarks.length; ++i) {
//     pTrack.keyFrame(pTimeMarks[i], pOutputValues[i]);
// }
                        logger.setSourceLocation( "resources/Collada.ts" , 1999 ); logger.criticalError("TODO: implement animation matrix modification"); ;
                    }
                    break;
                default:
                    logger.setSourceLocation( "resources/Collada.ts" , 2003 ); logger.error("unsupported animation typed founeed: " + sTransform); ;
            }

            if (!isNull(pTrack)) {
                pTrack.targetName = sNodeId;
            }

            return pTrack;
        }

        private buildAnimationTrackList(pAnimationData: IColladaAnimation): IAnimationTrack[] {
            var pSubAnimations: IColladaAnimation[] = pAnimationData.animation;
            var pSubTracks: IAnimationTrack[];
            var pTrackList: IAnimationTrack[] = [];
            var pTrack: IAnimationTrack;
            var pChannels: IColladaAnimationChannel[] = pAnimationData.channels;

            for (var i:  number  = 0; i < pChannels.length; ++i) {
                pTrack = this.buildAnimationTrack(pChannels[i]);
                pTrackList.push(pTrack);
            }


            if (isDefAndNotNull(pSubAnimations)) {
                for (var i:  number  = 0; i < pSubAnimations.length; ++i) {
                    pSubTracks = this.buildAnimationTrackList(pSubAnimations[i]);
                    pTrackList = pTrackList.concat(pSubTracks);
                }
            }

            return pTrackList;
        }

        private buildAnimation(pAnimationData: IColladaAnimation): IAnimation {

            var pTracks: IAnimationTrack[] = this.buildAnimationTrackList(pAnimationData);
/*pAnimationData.length ? pAnimationData[0].name :*/
            var sAnimation: string =                                                      null;
            var pAnimation: IAnimation = animation.createAnimation(sAnimation || this.getBasename());

            for (var i:  number  = 0; i < pTracks.length; i++) {
                pAnimation.push(pTracks[i]);
            }

            return pAnimation;
        }

        private buildAnimations(pAnimations: IColladaAnimation[], pAnimationsList: IAnimation[] = []): IAnimation[] {
            if (isNull(pAnimations)) {
                return null;
            }
            logger.setSourceLocation( "resources/Collada.ts" , 2053 ); logger.log(pAnimations); ;
            for (var i:  number  = 0; i < pAnimations.length; ++ i) {
                var pAnimation: IAnimation = this.buildAnimation(pAnimations[i]);

                pAnimationsList.push(pAnimation);
            }

            return pAnimationsList;
        }

// common

        private buildAssetTransform(pNode: ISceneNode, pAsset: IColladaAsset = null): ISceneNode {
            pAsset = pAsset || this.getAsset();

            if (isDefAndNotNull(pAsset)) {
                var fUnit:  number  = pAsset.unit.meter;
                var sUPaxis: string = pAsset.upAxis;

                pNode.localScale = vec3(fUnit);

                if (sUPaxis.toUpperCase() == "Z_UP") {
//pNode.addRelRotation([1, 0, 0], -.5 * Math.PI);
                    pNode.addRelRotationByEulerAngles(0, -.5 * math.PI, 0);
                }
            }

            return pNode;
        }

        private buildDeclarationFromAccessor(sSemantic: string, pAccessor: IColladaAccessor): IVertexElementInterface[] {
            var pDecl: IVertexElementInterface[] = [];

            for (var i:  number  = 0; i < pAccessor.params.length; ++ i) {
                var sUsage: string = pAccessor.params[i].name;
                var sType: string = pAccessor.params[i].type;

                logger.setSourceLocation( "resources/Collada.ts" , 2090 ); logger.assert(sType === "float", "Only float type supported for construction declaration from accessor"); ;

                pDecl.push(VE_FLOAT(sUsage));
            }

            pDecl.push(VE_CUSTOM(sSemantic, EDataTypes.FLOAT, pAccessor.params.length, 0));

            logger.setSourceLocation( "resources/Collada.ts" , 2097 ); logger.log("Automatically constructed declaration: ", createVertexDeclaration(pDecl).toString()); ;

            return pDecl;
        }


// materials & meshes

        private buildMaterials(pMesh: IMesh, pGeometryInstance: IColladaInstanceGeometry): IMesh {
            var pMaterials: IColladaBindMaterial = pGeometryInstance.material;
            var pEffects: IColladaEffectLibrary = <IColladaEffectLibrary>this.getLibrary("library_effects");

            if (isNull(pEffects)) {
                return pMesh;
            }

            for (var sMaterial in pMaterials) {
                var pMaterialInst: IColladaInstanceMaterial = pMaterials[sMaterial];
                var pInputMap: IColladaBindVertexInputMap = pMaterialInst.vertexInput;
// URL --> ID (#somebody ==> somebody)
                var sEffectId: string = pMaterialInst.material.instanceEffect.effect.id;
                var pEffect: IColladaEffect = pEffects.effect[sEffectId];
                var pPhongMaterial: IColladaPhong = <IColladaPhong>pEffect.profileCommon.technique.value;
                var pMaterial: IMaterial = material.create(sEffectId)

                pMaterial.set(<IMaterialBase>pPhongMaterial);

                for (var j:  number  = 0; j < pMesh.length; ++j) {
                    var pSubMesh: IMeshSubset = pMesh.getSubset(j);

//if (pSubMesh.surfaceMaterial.findResourceName() === sMaterial) {
                    if (pSubMesh.material.name === sMaterial) {
//setup materials
                        pSubMesh.material.set(pMaterial);
//FIXME: remove flex material setup(needs only demo with flexmats..)
// pSubMesh.applyFlexMaterial(sMaterial, pMaterial);

                        pSubMesh.renderMethod.effect.addComponent("akra.system.mesh_texture");
                        pSubMesh.renderMethod.effect.addComponent("akra.system.prepareForDeferredShading");

//setup textures
                        for (var sTextureType in pPhongMaterial.textures) {

                            var pColladaTexture: IColladaTexture = pPhongMaterial.textures[sTextureType];

                            if (isNull(pColladaTexture)) {
                                continue;
                            }

                            var pInput: IColladaBindVertexInput = pInputMap[pColladaTexture.texcoord];

                            if (!isDefAndNotNull(pInput)) {
                                continue;
                            }

                            var sInputSemantics: string = pInputMap[pColladaTexture.texcoord].inputSemantic;
                            var pColladaImage: IColladaImage = pColladaTexture.image;

                            var pSurfaceMaterial: ISurfaceMaterial = pSubMesh.surfaceMaterial;
                            var pTexture: ITexture = <ITexture>this.getManager().texturePool.loadResource(pColladaImage.path);

                            var pMatches: string[] = sInputSemantics.match(/^(.*?\w)(\d+)$/i);
                            var iTexCoord:  number  = (pMatches ? parseInt(pMatches[2]) : 0);


                            var iTexture = ESurfaceMaterialTextures[sTextureType.toUpperCase()];

                            if (!isDef(iTexture)) {
                                continue;
                            }

                            pSurfaceMaterial.setTexture(iTexture, pTexture, iTexCoord);
                        }
                    }
                }
//trace('try to apply mat:', pMaterial);
            }

            return pMesh;
        }


        private buildSkeleton(pSkeletonsList: string[]): ISkeleton {
            var pSkeleton: ISkeleton = null;

            pSkeleton = model.createSkeleton(pSkeletonsList[0]);

            for (var i:  number  = 0; i < pSkeletonsList.length; ++i) {
                var pJoint: IJoint = <IJoint>(<IColladaNode>this.source(pSkeletonsList[i])).constructedNode;

                logger.setSourceLocation( "resources/Collada.ts" , 2187 ); logger.assert(scene.isJoint(pJoint), "skeleton node must be joint"); ;

                pSkeleton.addRootJoint(pJoint);
            }

            return pSkeleton;
        }

        private buildMesh(pGeometryInstance: IColladaInstanceGeometry): IMesh {
            var pMesh: IMesh = null;
            var pGeometry: IColladaGeometrie = pGeometryInstance.geometry;
            var pNodeData: IColladaMesh = pGeometry.mesh;
            var sMeshName: string = pGeometry.id;

            if (isNull(pNodeData)) {
                return null;
            }

            if ((pMesh = this.findMesh(sMeshName))) {
//mesh with same geometry data
                return this.buildMaterials(
                    pMesh.clone(EMeshCloneOptions.GEOMETRY_ONLY | EMeshCloneOptions.SHARED_GEOMETRY),
                    pGeometryInstance);
            }

            var iBegin:  number  = now();

            pMesh = this.getEngine().createMesh(
                sMeshName,
/*|EMeshOptions.RD_ADVANCED_INDEX,  0,*/
                < number >(EMeshOptions.HB_READABLE),
/*shared buffer, if supported*/
                this.sharedBuffer());

            var pPolyGroup: IColladaPolygons[] = pNodeData.polygons;
            var pMeshData: IRenderDataCollection = pMesh.data;

//creating subsets
            for (var i:  number  = 0; i < pPolyGroup.length; ++i) {
                pMesh.createSubset(
                    "submesh-" + i,
/*EPrimitiveTypes.POINTLIST);*/
                    this.isWireframeEnabled() ? EPrimitiveTypes.LINELIST : pPolyGroup[i].type);
            }

//filling data
            for (var i:  number  = 0, pUsedSemantics: BoolMap = <BoolMap>{}; i < pPolyGroup.length; ++i) {
                var pPolygons: IColladaPolygons = pPolyGroup[i];

                for (var j:  number  = 0; j < pPolygons.inputs.length; ++j) {
                    var pInput: IColladaInput = pPolygons.inputs[j];
                    var sSemantic: string = pInput.semantics;
                    var pData: ArrayBufferView = <ArrayBufferView><any>pInput.array;
                    var pDecl: IVertexElementInterface[];
                    var pDataExt: Float32Array;

//if (pMesh.buffer.getDataLocation(sSemantic) < 0) {
                    if (!pUsedSemantics[sSemantic]) {
                        pUsedSemantics[sSemantic] = true;

                        switch (sSemantic) {
                            case DeclUsages.POSITION:
                            case DeclUsages.NORMAL:
/*
                                 Extend POSITION and NORMAL from {x,y,z} --> {x,y,z,w};
                                 */


                                pDataExt = new Float32Array((<Float32Array>pData).length / 3 * 4);

                                for (var y = 0, n = 0,  m = 0, l = (<Float32Array>pData).length / 3; y < l; y++, n++) {
                                    pDataExt[n++] = pData[m++];
                                    pDataExt[n++] = pData[m++];
                                    pDataExt[n++] = pData[m++];
                                }

                                pData = pDataExt;
                                pDecl = [VE_FLOAT3(sSemantic), VE_END(16)];

                                break;
                            case DeclUsages.TEXCOORD:
                            case DeclUsages.TEXCOORD1:
                            case DeclUsages.TEXCOORD2:
                            case DeclUsages.TEXCOORD3:
                            case DeclUsages.TEXCOORD4:
                            case DeclUsages.TEXCOORD5:
//avoiding semantics collisions
                                if(sSemantic === "TEXCOORD"){
                                    sSemantic = "TEXCOORD0";
                                }

                                pDecl = [VE_CUSTOM(sSemantic, EDataTypes.FLOAT, pInput.accessor.stride)];
                                break;
                            default:
                                pDecl = this.buildDeclarationFromAccessor(sSemantic, pInput.accessor);
                                logger.setSourceLocation( "resources/Collada.ts" , 2278 ); logger.warning("unsupported semantics used: " + sSemantic); ;
                        }

                        pMeshData.allocateData(pDecl, pData);
                    }
                }
            }

//add indices to data
            for (var i:  number  = 0; i < pPolyGroup.length; ++i) {
                var pPolygons: IColladaPolygons = pPolyGroup[i];
                var pSubMesh: IMeshSubset = pMesh.getSubset(i);
                var pSubMeshData: IRenderData = pSubMesh.data;
                var pDecl: IVertexElementInterface[] = new Array(pPolygons.inputs.length);
                var iIndex:  number  = 0;
                var pSurfaceMaterial: ISurfaceMaterial = null;
                var pSurfacePool: IResourcePool = null;

                for (var j:  number  = 0; j < pPolygons.inputs.length; ++j) {
                    pDecl[j] = VE_FLOAT(DeclUsages.INDEX + (iIndex++));
                }

                pSubMeshData.allocateIndex(pDecl, new Float32Array(pPolygons.p));

                for (var j:  number  = 0; j < pDecl.length; ++j) {
                    var sSemantic: string = pPolygons.inputs[j].semantics;

                    pSubMeshData.index(sSemantic, pDecl[j].usage);
                }

// if (!pSubMesh.material) {
//     pSurfacePool = pEngine.getResourceManager().surfaceMaterialPool;
//     pSurfaceMaterial = pSurfacePool.findResource(pPolygons.material);

//     if (!pSurfaceMaterial) {
//         pSurfaceMaterial = pSurfacePool.createResource(pPolygons.material);
//     }

//     pSubMesh.surfaceMaterial = pSurfaceMaterial;
// }

                pSubMesh.material.name = pPolygons.material;
            }

            logger.setSourceLocation( "resources/Collada.ts" , 2322 ); logger.assert(pMesh.addFlexMaterial("default"), "Could not add flex material to mesh <" + pMesh.name + ">"); ;
            logger.setSourceLocation( "resources/Collada.ts" , 2323 ); logger.assert(pMesh.setFlexMaterial("default"), "Could not set flex material to mesh <" + pMesh.name + ">"); ;

//adding all data to cahce data
            this.addMesh(pMesh);

            return this.buildMaterials(pMesh, pGeometryInstance);
        }

        private buildSkinMesh(pControllerInstance: IColladaInstanceController): IMesh {
            var pController: IColladaController = pControllerInstance.controller;
            var pMaterials: IColladaBindMaterial = pControllerInstance.material;

            var pSkinData: IColladaSkin = pController.skin;

//skin data
            var pBoneList: string[] = <string[]>pSkinData.joints.inputs["JOINT"].array;
            var pBoneOffsetMatrices: IMat4[] = <IMat4[]>pSkinData.joints.inputs["INV_BIND_MATRIX"].array;

            var m4fBindMatrix: IMat4 = pSkinData.shapeMatrix;
            var pVertexWeights: IColladaVertexWeights = pSkinData.vertexWeights;

            var pGeometry: IColladaGeometrie = pSkinData.geometry;

            var pMesh: IMesh;
            var pSkeleton: ISkeleton;
            var pSkin: ISkin;

            pSkeleton = this.buildSkeleton(pControllerInstance.skeletons);
            pMesh = this.buildMesh({geometry : pGeometry, material : pMaterials});

            pSkin = pMesh.createSkin();

            pSkin.setBindMatrix(m4fBindMatrix);
            pSkin.setBoneNames(pBoneList);
            pSkin.setBoneOffsetMatrices(pBoneOffsetMatrices);

            logger.setSourceLocation( "resources/Collada.ts" , 2359 ); logger.assert(pSkin.setSkeleton(pSkeleton), "Could not set skeleton to skin."); ;

            if (!pSkin.setVertexWeights(
                < number []>pVertexWeights.vcount,
                new Float32Array(pVertexWeights.v),
                new Float32Array(pVertexWeights.weightInput.array))) {
                logger.setSourceLocation( "resources/Collada.ts" , 2365 ); logger.error("cannot set vertex weight info to skin"); ;
            }

            pMesh.setSkin(pSkin);
            pMesh.setSkeleton(pSkeleton);
            pSkeleton.attachMesh(pMesh);

            return pMesh;
        }


        private buildSkinMeshInstance(pControllers: IColladaInstanceController[], pSceneNode: ISceneModel = null): IMesh[] {
            var pMesh: IMesh = null;
            var pMeshList: IMesh[] = [];

            for (var m:  number  = 0; m < pControllers.length; ++m) {
                pMesh = this.buildSkinMesh(pControllers[m]);
                pMeshList.push(pMesh);

                logger.setSourceLocation( "resources/Collada.ts" , 2384 ); logger.assert(isDefAndNotNull(pMesh), "cannot find instance <" + pControllers[m].url + ">\"s data"); ;

                if (!isNull(pSceneNode)) {
                    pSceneNode.mesh = pMesh;
                }
            }

            return pMeshList;
        }

         private buildMeshInstance(pGeometries: IColladaInstanceGeometry[], pSceneNode: ISceneModel = null): IMesh[] {
            var pMesh: IMesh = null;
            var pMeshList: IMesh[] = [];

            for (var m:  number  = 0; m < pGeometries.length; ++m) {
                pMesh = this.buildMesh(pGeometries[m]);
                pMeshList.push(pMesh);

                logger.setSourceLocation( "resources/Collada.ts" , 2402 ); logger.assert(isDefAndNotNull(pMesh), "cannot find instance <" + pGeometries[m].url + ">\"s data"); ;

                if (!isNull(pSceneNode)) {
                    pSceneNode.mesh = pMesh;
                }
            }

            return pMeshList;
        }

        private buildMeshes(): IMesh[] {
            var pScene: IColladaVisualScene = this.getVisualScene();
            var pMeshes: IMesh[] = [];

            this.findNode(pScene.nodes, null, function (pNode: IColladaNode) {
                var pModelNode: ISceneNode = pNode.constructedNode;

                if (isNull(pModelNode)) {
                    logger.setSourceLocation( "resources/Collada.ts" , 2420 ); logger.error("you must call buildScene() before call buildMeshes() or file corrupt"); ;
                    return;
                }

                if (pNode.controller.length == 0 && pNode.geometry.length == 0) {
                    return;
                }

                if (scene.isModel(pModelNode)) {
                    pModelNode = pModelNode.scene.createModel(".joint-to-model-link-" + sid());
                    pModelNode.attachToParent(pNode.constructedNode);
                }

                pMeshes.insert(<IMesh[]>this.buildSkinMeshInstance(pNode.controller));
                pMeshes.insert(<IMesh[]>this.buildMeshInstance(pNode.geometry, pModelNode));
            });

            return pMeshes;
        }

// scene

        private buildSceneNode(pNode: IColladaNode, pParentNode: ISceneNode): ISceneNode {
            var pSceneNode: ISceneNode = pNode.constructedNode;
            var pScene: IScene3d = pParentNode.scene;

            if (isDefAndNotNull(pSceneNode)) {
                return pSceneNode;
            }

//FIXME: предпологаем, что мы никогда не аттачим контроллеры к узлам,
// где они найдены, а аттачим  их к руту скелета, на который они ссыл��ются
/*pNode.pController.length ||*/
            if (pNode.geometry.length > 0) {
                pSceneNode = pScene.createModel();
            }
            else {
                pSceneNode = pScene.createNode();
            }

            logger.setSourceLocation( "resources/Collada.ts" , 2459 ); logger.assert(pSceneNode.create(), "Can not initialize scene node!"); ;

            pSceneNode.attachToParent(pParentNode);

            return pSceneNode;
        }

        private buildJointNode(pNode: IColladaNode, pParentNode: ISceneNode): IJoint {
            var pJointNode: IJoint = <IJoint>pNode.constructedNode;
            var sJointSid: string = pNode.sid;
            var sJointName: string = pNode.id;
            var pSkeleton: ISkeleton;

            logger.setSourceLocation( "resources/Collada.ts" , 2472 ); logger.assert(isDefAndNotNull(pParentNode), "parent node is null"); ;

            if (isDefAndNotNull(pJointNode)) {
                return pJointNode;
            }

            if (isNull(pParentNode)) {
                return null;
            }

            pJointNode = pParentNode.scene.createJoint();

            logger.setSourceLocation( "resources/Collada.ts" , 2484 ); logger.assert(pJointNode.create(), "Can not initialize joint node!"); ;

            pJointNode.boneName = sJointSid;
            pJointNode.attachToParent(pParentNode);


            if (this.isJointsVisualizationNeeded()) {
//draw joints
// var pSceneNode: ISceneModel = pEngine.appendMesh(
//     pEngine.pCubeMesh.clone(a.Mesh.GEOMETRY_ONLY | a.Mesh.SHARED_GEOMETRY),
//     pJointNode);
// pSceneNode.name = sJointName + '[joint]';
// pSceneNode.setScale(0.02);
                logger.setSourceLocation( "resources/Collada.ts" , 2497 ); logger.criticalError("TODO: visualize joints..."); ;
            }


            return pJointNode;
        }

        private buildNodes(pNodes: IColladaNode[], pParentNode: ISceneNode = null): ISceneNode {
            if (isNull(pNodes)) {
                return null;
            }

            var pNode: IColladaNode = null;
            var pHierarchyNode: ISceneNode = null;
            var m4fLocalMatrix: IMat4 = null;

            for (var i:  number  = pNodes.length - 1; i >= 0; i--) {
                pNode = pNodes[i];

                if (!isDefAndNotNull(pNode)) {
                    continue;
                }

                if (pNode.type === "JOINT") {
                    pHierarchyNode = this.buildJointNode(pNode, pParentNode);
                }
                else {
                    pHierarchyNode = this.buildSceneNode(pNode, pParentNode);
                }

                pHierarchyNode.name = (pNode.id || pNode.name);
                pHierarchyNode.setInheritance(ENodeInheritance.ALL);

//cache already constructed nodes
                pNode.constructedNode = pHierarchyNode;
                pHierarchyNode.localMatrix = pNode.transform;

                this.buildNodes(pNode.childNodes, pHierarchyNode);
            }

            return pHierarchyNode;
        }

        private buildScene(pRootNode: ISceneNode): ISceneNode[] {
            var pScene: IColladaVisualScene = this.getVisualScene();
            var pAsset: IColladaAsset = this.getAsset();

            var pNodes: ISceneNode[] = [];
            var pNode: IColladaNode = null;

            for (var i:  number  = 0; i < pScene.nodes.length; i++) {
                pNode = pScene.nodes[i];
                pNodes.push(this.buildNodes([pNode], pRootNode));
            }

            for (var i:  number  = 0; i < pNodes.length; i++) {
                pNodes[i] = this.buildAssetTransform(pNodes[i]);
            }

            return pNodes;
        }

        private buildInititalPose(pNodes: IColladaNode[], pSkeleton: ISkeleton): IAnimation {
            var sPose: string = "Pose-" + this.getBasename() + "-" + pSkeleton.name;
            var pPose: IAnimation = animation.createAnimation(sPose);
            var pNodeList: ISceneNode[] = pSkeleton.getNodeList();
            var pNodeMap: ISceneNodeMap = {};
            var pTrack: IAnimationTrack;

            for (var i:  number  = 0; i < pNodeList.length; ++i) {
                pNodeMap[pNodeList[i].name] = pNodeList[i];
            }

            this.findNode(pNodes, null, function (pNode: IColladaNode) {
                var sJoint: string = pNode.sid;
                var sNodeId: string = pNode.id;

                if (!isDefAndNotNull(pNodeMap[sNodeId])) {
                    return;
                }

                pTrack = animation.createTrack(sJoint);
                pTrack.targetName = sNodeId;
                pTrack.keyFrame(0.0, pNode.transform);

                pPose.push(pTrack);
            });

            return pPose;
        }

        private buildInitialPoses(pPoseSkeletons: ISkeleton[] = null): IAnimation[] {
            pPoseSkeletons = pPoseSkeletons || this.getSkeletonsOutput();

            if (isNull(pPoseSkeletons)) {
                return null;
            }

            var pScene: IColladaVisualScene = this.getVisualScene();
            var pSkeleton: ISkeleton;
            var pPoses: IAnimation[] = [];

            for (var i:  number  = 0; i < pPoseSkeletons.length; ++i) {
                pSkeleton = pPoseSkeletons[i];
// if (pSkeleton.name === "node-Bip001_Pelvis" || pSkeleton.name === "node-Bip001") {
//     trace('skipping <node-Bip001_Pelvis> skeleto, ...', '[' + sBasename + ']');

//     trace(pSkeleton.getNodeList()[0].localMatrix().toQuat4().toYawPitchRoll(Vec3()).toString());

//     continue;
// }
                pPoses.push(this.buildInititalPose(pScene.nodes, pSkeleton));
            }

            return pPoses;
        }

// additional


        private buildComplete(): void {
            var pScene: IColladaVisualScene = this.getVisualScene();

            if (isNull(pScene)) {
                logger.setSourceLocation( "resources/Collada.ts" , 2621 ); logger.warning("build complete, but visual scene not parsed correctly!"); ;
                return;
            }

//release all links to constructed nodes
            this.findNode(pScene.nodes, null, function (pNode: IColladaNode) {
                pNode.constructedNode = null;
            });
        }

        private setOptions(pOptions: IColladaLoadOptions): void {
            if (isNull(pOptions)) {
                pOptions = Collada.DEFAULT_OPTIONS;
            }

            for (var i in Collada.DEFAULT_OPTIONS) {
                if (isDef(pOptions[i])) {
                    continue;
                }

                pOptions[i] = Collada.DEFAULT_OPTIONS[i];
            }

            this._pOptions = pOptions;
        }

        private setXMLRoot(pXML: Element): void {
            this._pXMLRoot = pXML;
        }

        private getXMLRoot(): Element {
            return this._pXMLRoot;
        }

        private findMesh(sName: string): IMesh {
            return this._pCache.meshMap[sName] || null;
        }

        private addMesh(pMesh: IMesh): void {
            this._pCache.meshMap[pMesh.name] = pMesh;
            this.sharedBuffer(pMesh.data);
        }

        private sharedBuffer(pBuffer?: IRenderDataCollection): IRenderDataCollection {
            if (isDefAndNotNull(pBuffer)) {
                this._pCache.sharedBuffer = pBuffer;
            }

            return null;
// return this._pOptions.sharedBuffer ? pCache.sharedBuffer : null;
        }

        private prepareInput(pInput: IColladaInput): IColladaInput {
            var pSupportedFormat: IColladaUnknownFormat[] = getSupportedFormat(pInput.semantics);
            logger.setSourceLocation( "resources/Collada.ts" , 2675 ); logger.assert(isDefAndNotNull(pSupportedFormat), "unsupported semantic used <" + pInput.semantics + ">"); ;

            pInput.array    = <any[]><any>this.COLLADAGetSourceData(pInput.source, pSupportedFormat);
            pInput.accessor = pInput.source.techniqueCommon.accessor;

            return pInput;
        }

        private inline isJointsVisualizationNeeded(): bool {
            return this._pOptions.drawJoints === true;
        }

        public inline isVisualSceneLoaded(): bool {
            return isDefAndNotNull(this._pVisualScene);
        }

        public inline isAnimationLoaded(): bool {
            return (this.isLibraryLoaded("library_animations") &&
                (<IColladaAnimation>this.getLibrary("library_animations")).animation.length > 0);
        }

        private inline isSceneNeeded(): bool {
            return this._pOptions.scene === true;
        }

         private inline isAnimationNeeded(): bool {
            return isDefAndNotNull(this._pOptions.animation);
        }

        private inline isPoseExtractionNeeded(): bool {
            return this._pOptions.extractPoses === true;
        }

        private inline isWireframeEnabled(): bool {
            return this._pOptions.wireframe === true;
        }

        private inline getSkeletonsOutput(): ISkeleton[] {
            return this._pOptions.skeletons || null;
        }

        private inline getVisualScene(): IColladaVisualScene {
            return this._pVisualScene;
        }

        public inline getAsset(): IColladaAsset {
            return this._pAsset;
        }

        private inline isLibraryLoaded(sLib: string): bool {
            return isDefAndNotNull(this._pLib[sLib]);
        }

        private inline isLibraryExists(sLib: string): bool {
            return !isNull(firstChild(this.getXMLRoot(), "library_animations"));
        }

        private inline getLibrary(sLib: string): IColladaLibrary {
            return this._pLib[sLib] || null;
        }

        public inline getBasename(): string {
            return util.pathinfo(this._sFilename).basename || "unknown";
        }

        public inline getFilename(): string {
            return this._sFilename;
        }

        private inline setFilename(sName: string): void {
            this._sFilename = sName;
        }

        private readLibraries(pXML: Element, pTemplates: IColladaLibraryTemplate[]): void {
            var pLibraries: IColladaLibraryMap = this._pLib;

            for (var i:  number  = 0; i < pTemplates.length; i++) {
                var sLib: string = pTemplates[i].lib;
                pLibraries[sLib] = this.COLLADALibrary(firstChild(pXML, sLib), pTemplates[i]);
            }
        }

        private checkLibraries(pXML: Element, pTemplates: IColladaLibraryTemplate[]): void {
            var pLibraries: IColladaLibraryMap = this._pLib;

            for (var i:  number  = 0; i < pTemplates.length; i++) {
                var sLib: string = pTemplates[i].lib;

                if (isDefAndNotNull(firstChild(pXML, sLib))) {
                    pLibraries[sLib] = null;
                }
            }
        }

        parse(sXMLData: string, pOptions: IColladaLoadOptions = null): bool {
            if (isNull(sXMLData)) {
                logger.setSourceLocation( "resources/Collada.ts" , 2771 ); logger.error("must be specified collada content."); ;
                return false;
            }

            var pParser: DOMParser = new DOMParser();
            var pXMLDocument: Document = pParser.parseFromString(sXMLData, "application/xml");
            var pXMLRoot: Element = <Element>pXMLDocument.getElementsByTagName("COLLADA")[0];

            this.setOptions(pOptions);
            this.setXMLRoot(pXMLRoot);

            this.checkLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);
            this.checkLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);

            this.readLibraries(pXMLRoot, Collada.SCENE_TEMPLATE);

            this.COLLADAAsset(firstChild(pXMLRoot, "asset"));
            this.COLLADAScene(firstChild(pXMLRoot, "scene"));

            if (this.isAnimationNeeded()) {
                this.readLibraries(pXMLRoot, Collada.ANIMATION_TEMPLATE);
            }

            return true;
        }

        loadResource(sFilename: string = null, pOptions: IColladaLoadOptions = null): bool {
            if (isNull(sFilename)) {
                sFilename = this.findResourceName();
            }

            if (this.isResourceLoaded()) {
                logger.setSourceLocation( "resources/Collada.ts" , 2803 ); logger.warning("collada model already loaded"); ;
                return false;
            }

            var pModel: Collada = this;

            this.setFilename(sFilename);

            this.notifyDisabled();
            this.notifyUnloaded();

            io.fopen(sFilename).read(function (pErr: Error, sXML: string) {
                if (!isNull(pErr)) {
                    logger.setSourceLocation( "resources/Collada.ts" , 2816 ); logger.error(pErr); ;
                }

                pModel.notifyRestored();

                if (pModel.parse(sXML, pOptions)) {
                    pModel.notifyLoaded();
                }
            });
        }


        attachToScene(pScene: IScene3d, pController?: IAnimationController): bool;
        attachToScene(pNode: ISceneNode, pController?: IAnimationController): bool;
        attachToScene(parent, pController: IAnimationController = null): bool {
            var pSkeletons: ISkeleton[],
                pSkeleton: ISkeleton;
            var pPoses: IAnimation[];
            var pScene: IScene3d;
            var pNode: ISceneNode;
            var pRoot: ISceneNode;

            var pSceneOutput: ISceneNode[] = null;
            var pAnimationOutput: IAnimation[] = null;
            var pMeshOutput: IMesh[] = null;
            var pInitialPosesOutput: IAnimation[] = null;


            if (isNull(parent)) {
                return false;
            }

            if (parent instanceof scene.Node) {
//attach collada scene to give node
                pNode = <ISceneNode>parent;
                pScene = pNode.scene;
                pRoot = pNode;
            }
            else {
//attaching collada scene to new node, that is child of scene root
                pScene = <IScene3d>parent;
                pNode = pScene.getRootNode();
                pRoot = pScene.createNode();

                pRoot.setInheritance(ENodeInheritance.ALL);

                if (!pRoot.attachToParent(pNode)) {
                    return false;
                }
            }



            if (this.isVisualSceneLoaded() && this.isSceneNeeded()) {
                pSceneOutput = this.buildScene(pRoot);
                pMeshOutput = this.buildMeshes();
            }

            if (this.isPoseExtractionNeeded()) {
                pInitialPosesOutput = this.buildInitialPoses();
            }

            if (!isNull(pController) && this.isAnimationNeeded() && this.isLibraryExists("library_animations")) {
                pAnimationOutput =
                        this.buildAnimations((<IColladaAnimation>this.getLibrary("library_animations")).animation);
//дополним анимации начальными позициями костей
                if (this.isPoseExtractionNeeded()) {
                    pSkeletons = this.getSkeletonsOutput() || [];

/*
     
                    // добавим к начальным позам, те, в которых находятся меши
                    // в момент выгрузки
                    if (!isNull(pMeshOutput)) {
                        for (var i = 0; i < pMeshOutput.length; ++ i) {
                            pSkeletons.push(pMeshOutput[i].skeleton);
                        }
                    }
                    else {
                        //необхоимо для посчета ссылочной информации
                        if (isNull(pSceneOutput)) {
                            this.buildScene();
                        }

                        this.eachByTag(pXMLRoot, "skeleton", function (pXML: Node) {
                            pSkeletons.push(this.buildSkeleton([stringData(pXML)]));
                        });
                    }

                    */


                    pPoses = this.buildInitialPoses(pSkeletons);

                    for (var i:  number  = 0; i < pAnimationOutput.length; ++ i) {
                        for (var j:  number  = 0; j < pPoses.length; ++ j) {
                            pAnimationOutput[i].extend(pPoses[j]);
                        }
                    }
                }
            }

//clear all links from collada nodes to scene nodes
            this.buildComplete();

            if (!isNull(pController) && !isNull(pAnimationOutput)) {
                for (var i:  number  = 0; i < pAnimationOutput.length; ++ i) {
                    pController.addAnimation(pAnimationOutput[i]);
                }

                pController.attach(pRoot);
            }

            return true;
        }
    }

    pSupportedVertexFormat = [
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["Z"], type : ["float"]}
    ];

    pSupportedTextureFormat = [
        {name : ["S"], type : ["float"]},
        {name : ["T"], type : ["float"]},
        {name : ["P"], type : ["float"]}
    ];

    pSupportedColorFormat = [
        {name : ["R"], type : ["float"]},
        {name : ["G"], type : ["float"]},
        {name : ["B"], type : ["float"]}
    ];

    pSupportedWeightFormat = [
        {name : ["WEIGHT"], type : ["float"]}
    ];

    pSupportedJointFormat = [
        {name : ["JOINT"], type : ["Name", "IDREF"]}
    ];

    pSupportedInvBindMatrixFormat = [
        {name : ["TRANSFORM"], type : ["float4x4"]}
    ];

    pSupportedInterpolationFormat = [
        {name : ["INTERPOLATION"], type : ["Name"]}
    ];

    pSupportedInputFormat = [
        {name : ["TIME"], type : ["float"]}
    ];

    pSupportedOutputFormat = [
        {name : ["TRANSFORM", "X", "ANGLE", null], type : ["float4x4", "float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["Z"], type : ["float"]}
    ];

    pSupportedTangentFormat = [
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]},
        {name : ["X"], type : ["float"]},
        {name : ["Y"], type : ["float"]}
    ];

    pFormatStrideTable = <IColladaFormatStrideTable> {
        "float"    : 1,
        "float2"   : 2,
        "float3"   : 3,
        "float4"   : 4,
        "float3x3" : 9,
        "float4x4" : 16,
        "int"      : 1,
        "name"     : 1,
        "Name"     : 1,
        "IDREF"    : 1
    };

    pConvFormats = {
        "int"    : { type: Int32Array,      converter: string2IntArray      },
        "float"  : { type: Float32Array,    converter: string2FloatArray    },
        "bool"   : { type: Array,           converter: string2BoolArray     },
        "string" : { type: Array,           converter: string2StringArray   }
    };

/* COMMON FUNCTIONS
     ------------------------------------------------------
     */


    function getSupportedFormat(sSemantics: string): IColladaUnknownFormat[] {
        switch (sSemantics) {
            case "TEXTANGENT":
            case "TEXBINORMAL":
            case "VERTEX":
            case "NORMAL":
            case "TANGENT":
            case "BINORMAL":
            case "POSITION":
                return pSupportedVertexFormat;

            case "TEXCOORD":
                return pSupportedTextureFormat;

            case "WEIGHT":
                return pSupportedWeightFormat;

            case "JOINT":
                return pSupportedJointFormat;

            case "INV_BIND_MATRIX":
                return pSupportedInvBindMatrixFormat;

            case "INTERPOLATION":
                return pSupportedInterpolationFormat;

            case "IN_TANGENT":
                return pSupportedTangentFormat;

            case "INPUT":
                return pSupportedInputFormat;

            case "OUT_TANGENT":
                return pSupportedTangentFormat;

            case "OUTPUT":
                return pSupportedOutputFormat;
            case "COLOR":
                return pSupportedColorFormat;
            case "UV":
            case "MORPH_WEIGHT":
            case "MORPH_TARGET":
            case "LINEAR_STEPS":
            case "IMAGE":
            case "CONTINUITY":
                return null;
        }

        logger.setSourceLocation( "resources/Collada.ts" , 3061 ); logger.error("unknown semantics founded: " + sSemantics); ;

        return null;
    }

    function calcFormatStride(pFormat: IColladaUnknownFormat[]):  number  {
        var iStride:  number  = 0;
        var s: string = null;

        for (var i:  number  = 0; i < pFormat.length; ++i) {
            s = pFormat[i].type[0];
            iStride += pFormatStrideTable[s];
        }

        return iStride;
    }


// data convertion

    inline function parseBool(sValue: string): bool {
        return (sValue === "true");
    }

    inline function parseString(sValue: string): string {
        return String(sValue);
    }

/**
     * Получить часть данных массива
     * @param pSrc
     * @param pDst
     * @param iStride шаг (количество элементов в шаге)
     * @param iFrom номер элемента с которого начинать
     * @param iCount сколько элементов надо получить
     * @param iOffset смещение внутри шага (в элементах)
     * @param iLen количество элементов в шаге.
     */


    function retrieve(pSrc: any[], pDst: any[], iStride:  number  = 1, iFrom:  number  = 0, iCount?:  number , iOffset:  number  = 0, iLen:  number  = iStride - iOffset):  number  {

        if (!isDef(iCount)) {
            iCount = (pSrc.length / iStride - iFrom);
        }

        if (iOffset + iLen > iStride) {
            iLen = iStride - iOffset;
        }

        var iBegin:  number  = iFrom * iStride;
        var n:  number  = 0;

        for (var i:  number  = 0; i < iCount; ++i) {
            for (var j = 0; j < iLen; ++j) {
                pDst[n++] = (pSrc[iBegin + i * iStride + iOffset + j]);
            }
        }

        return n;
    }

    function string2Array(sData: string, ppData: any[], fnConv: (data: string) => any = parseFloat, iFrom:  number  = 0):  number  {
        var pData: string[] = sData.split(/[\s]+/g);

        for (var i = 0, n = pData.length, j = 0; i < n; ++i) {
            if (pData[i] != "") {
                ppData[iFrom + j] = fnConv(pData[i]);
                j++;
            }
        }

        return n;
    }

    inline function string2IntArray(sData: string, ppData:  number [], iFrom?:  number ):  number  {
        return string2Array(sData, ppData, parseInt, iFrom);
    }

    inline function string2FloatArray(sData: string, ppData:  number [], iFrom?:  number ):  number  {
        return string2Array(sData, ppData, parseFloat, iFrom);
    }

    inline function string2BoolArray(sData: string, ppData: bool[], iFrom?:  number ):  number  {
        return string2Array(sData, ppData, parseBool, iFrom);
    }

    inline function string2StringArray(sData: string, ppData: string[], iFrom?:  number ):  number  {
        return string2Array(sData, ppData, parseString, iFrom);
    }


    function string2Any(sData: string, n:  number , sType: string, isArray = false): any {
        var ppData: any = new (pConvFormats[sType].type)(n);

        pConvFormats[sType].converter(sData, ppData);

        if (n == 1 && !isArray) {
            return ppData[0];
        }

        return ppData;
    };

// additional

    function printArray(pArr: any[], nRow:  number , nCol:  number ): string {
        var s: string = "\n";

        for (var i = 0; i < pArr.length; ++i) {
            if (i % nCol == 0) {
                s += "  ";
            }

            s += pArr[i] + ", ";

            if ((i + 1) % nRow == 0) {
                s += '\n';
            }
        }

        return s;
    }

    function sortArrayByProperty(pData: any[], sProperty: string): any[] {
        var tmp: any;

        for (var i:  number  = pData.length - 1; i > 0; i--) {
            for (var j:  number  = 0; j < i; j++) {
                if (pData[j][sProperty] > pData[j + 1][sProperty]) {
                    tmp = pData[j];
                    pData[j] = pData[j + 1];
                    pData[j + 1] = tmp;
                }
            }
        }

        return pData;
    }


    inline function stringData(pXML: Element): string {
        return (isDefAndNotNull(pXML) ? pXML.textContent : null);
    }

    inline function attr(pXML: Element, sName: string): string {
         return pXML.getAttribute(sName);

    }

    function firstChild(pXML: Element, sTag?: string): Element {
        if (isString(sTag)) {
            return <Element>pXML.getElementsByTagName(sTag)[0];
        }

        for (var i = 0; i < pXML.childNodes.length; i++) {
            if (pXML.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                return <Element>pXML.childNodes[i];
            }
        }

        return null;
    }



}


































module akra.util {











    akra.logger.registerCode( 2001 , "Grammar not LALR(1)! Cannot to generate syntax table. Add operation error.\n" +
                                                           "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                                                           "Old operation: {oldOperation}\n" +
                                                           "New operation: {newOperation}\n" +
                                                           "For more info init parser in debug-mode and see syntax table and list of states.");

    akra.logger.registerCode( 2002 , "Grammar not LALR(1)! Cannot to generate syntax table. Add state link error.\n" +
                                                            "Conflict in state with index: {stateIndex}. With grammar symbol: \"{grammarSymbol}\"\n" +
                                                            "Old next state: {oldNextStateIndex}\n" +
                                                            "New next state: {newNextStateIndex}\n" +
                                                            "For more info init parser in debug-mode and see syntax table and list of states.");

    akra.logger.registerCode( 2003 , "Grammar error. Can`t generate rules from grammar\n" +
                                                               "Unexpected symbol: {unexpectedSymbol}\n" +
                                                               "Expected: {expectedSymbol}");

    akra.logger.registerCode( 2004 , "Grammar error. Empty additional function name.");
    akra.logger.registerCode( 2005 , "Grammar error. Bad keyword: {badKeyword}\n" +
                                                         "All keyword must be define in lexer rule block.");

    akra.logger.registerCode( 2051 , "Syntax error during parsing. Token: {tokenValue}\n" +
                                                  "Line: {line}. Column: {column}.");

    akra.logger.registerCode( 2101 , "Unknown token: {tokenValue}");
    akra.logger.registerCode( 2102 , "Bad token: {tokenValue}");



    function sourceLocationToString(pLocation: ISourceLocation): string {
        var sLocation:string = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
        return sLocation;
    }

    function syntaxErrorLogRoutine(pLogEntity: ILoggerEntity): void{
        var sPosition:string = sourceLocationToString(pLogEntity.location);
        var sError: string = "Code: " + pLogEntity.code.toString() + ". ";
        var pParseMessage: string[] = pLogEntity.message.split(/\{(\w+)\}/);
        var pInfo:any = pLogEntity.info;

        for(var i = 0; i < pParseMessage.length; i++){
            if(isDef(pInfo[pParseMessage[i]])){
                pParseMessage[i] = <string><any>pInfo[pParseMessage[i]];
            }
        }

        var sMessage = sPosition + sError + pParseMessage.join("");

        console["error"].call(console, sMessage);
    }

    akra.logger.setCodeFamilyRoutine("ParserSyntaxErrors", syntaxErrorLogRoutine, ELogLevel.ERROR);

//akra.logger

    export interface IOperation {
        type: EOperationType;
        rule?: IRule;
        index?:  number ;
    }

    export interface IItem {
        isEqual(pItem: IItem, eType?: EParserType): bool;
        isParentItem(pItem: IItem): bool;
        isChildItem(pItem: IItem): bool;

        mark(): string;
        end(): string;
        nextMarked(): string;

        toString(): string;

        isExpected(sSymbol: string): bool;
        addExpected(sSymbol: string): bool;

        rule: IRule;
        position:  number ;
        index:  number ;
        state: IState;
        expectedSymbols: BoolMap;
        isNewExpected: bool;
        length:  number ;
    }

    export interface IState {

        hasItem(pItem: IItem, eType: EParserType): IItem;
        hasParentItem(pItem: IItem): IItem;
        hasChildItem(pItem: IItem): IItem;

        hasRule(pRule:IRule, iPos: number ):bool;

        isEmpty(): bool;
        isEqual(pState: IState, eType: EParserType): bool;

        push(pItem: IItem): void;

        tryPush_LR0(pRule: IRule, iPos:  number ): bool;
        tryPush_LR(pRule: IRule, iPos:  number , sExpectedSymbol: string): bool;

        deleteNotBase(): void;

        getNextStateBySymbol(sSymbol: string): IState;
        addNextState(sSymbol: string, pState: IState): bool;

        toString(isBase: bool): string;

        items: IItem[];
        numBaseItems:  number ;
        index:  number ;
        nextStates: IStateMap;
    }

    export interface IStateMap {
        [index: string]: IState;
    }


    class Item implements IItem {
        private _pRule: IRule;
        private _iPos:  number ;
        private _iIndex:  number ;
        private _pState: IState;

        private _pExpected: BoolMap;
        private _isNewExpected: bool;
        private _iLength:  number ;


        inline get rule(): IRule {
            return this._pRule;
        }

        inline set rule(pRule: IRule) {
            this._pRule = pRule;
        }

        inline get position():  number  {
            return this._iPos;
        }

        inline set position(iPos:  number ) {
            this._iPos = iPos;
        }

        inline get state(): IState {
            return this._pState;
        }

        inline set state(pState: IState) {
            this._pState = pState;
        }

        inline get index():  number  {
            return this._iIndex;
        }

        inline set index(iIndex:  number ) {
            this._iIndex = iIndex;
        }

        inline get expectedSymbols(): BoolMap {
            return this._pExpected;
        }

        inline get length():  number  {
            return this._iLength;
        }

        inline get isNewExpected(): bool {
            return this._isNewExpected;
        }

        inline set isNewExpected(_isNewExpected: bool) {
            this._isNewExpected = _isNewExpected;
        }

        constructor (pRule: IRule, iPos:  number , pExpected?: BoolMap) {
            this._pRule = pRule;
            this._iPos = iPos;
            this._iIndex = 0;
            this._pState = null;

            this._isNewExpected = true;
            this._iLength = 0;
            this._pExpected = <BoolMap>{};

            if (arguments.length === 3) {
                var i: string = null;
                for (i in <BoolMap>arguments[2]) {
                    this.addExpected(i);
                }
            }
        }

        isEqual(pItem: IItem, eType?: EParserType = EParserType.k_LR0): bool {
            if (eType === EParserType.k_LR0) {
                return (this._pRule === pItem.rule && this._iPos === pItem.position);
            }
            else if (eType === EParserType.k_LR1) {
                if (!(this._pRule === pItem.rule && this._iPos === pItem.position && this._iLength === (<IItem>pItem).length)) {
                    return false;
                }
                var i: string = null;
                for (i in this._pExpected) {
                    if (!(<IItem>pItem).isExpected(i)) {
                        return false;
                    }
                }
                return true;
            }
        }

        isParentItem(pItem: IItem): bool {
            return (this._pRule === pItem.rule && this._iPos === pItem.position + 1);
        }

        isChildItem(pItem: IItem): bool {
            return (this._pRule === pItem.rule && this._iPos === pItem.position - 1);
        }

        mark(): string {
            var pRight: string[] = this._pRule.right;
            if (this._iPos === pRight.length) {
                return  "END" ;
            }
            return pRight[this._iPos];
        }

        inline end(): string {
            return this._pRule.right[this._pRule.right.length - 1] ||  "EMPTY" ;
        }

        inline nextMarked(): string {
            return this._pRule.right[this._iPos + 1] ||  "END" ;
        }

        inline isExpected(sSymbol: string): bool {
            return !!(this._pExpected[sSymbol]);
        }

        addExpected(sSymbol: string): bool {
            if (this._pExpected[sSymbol]) {
                return false;
            }
            this._pExpected[sSymbol] = true;
            this._isNewExpected = true;
            this._iLength++;
            return true;
        }

        toString(): string {
            var sMsg: string = this._pRule.left + " -> ";
            var sExpected: string = "";
            var pRight: string[] = this._pRule.right;

            for (var k = 0; k < pRight.length; k++) {
                if (k === this._iPos) {
                    sMsg += ". ";
                }
                sMsg += pRight[k] + " ";
            }

            if (this._iPos === pRight.length) {
                sMsg += ". ";
            }

            if (isDef(this._pExpected)) {
                sExpected = ", ";
                for (var l in this._pExpected) {
                    sExpected += l + "/";
                }
                if (sExpected !== ", ") {
                    sMsg += sExpected;
                }
            }

            sMsg = sMsg.slice(0, sMsg.length - 1);
            return sMsg;
        }
    }

    class State implements IState {
        private _pItemList: IItem[];
        private _pNextStates: IStateMap;
        private _iIndex:  number ;
        private _nBaseItems:  number ;

        inline get items(): IItem[] {
            return this._pItemList;
        }

        inline get numBaseItems():  number  {
            return this._nBaseItems;
        }

        inline get index():  number  {
            return this._iIndex;
        }

        inline set index(iIndex:  number ) {
            this._iIndex = iIndex;
        }

        inline get nextStates(): IStateMap {
            return this._pNextStates;
        }

        constructor () {
            this._pItemList = <IItem[]>[];
            this._pNextStates = <IStateMap>{};
            this._iIndex = 0;
            this._nBaseItems = 0;
        }

        hasItem(pItem: IItem, eType: EParserType): IItem {
            var i;
            var pItems: IItem[] = this._pItemList;
            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].isEqual(pItem, eType)) {
                    return pItems[i];
                }
            }
            return null;
        }

        hasParentItem(pItem: IItem): IItem {
            var i;
            var pItems = this._pItemList;
            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].isParentItem(pItem)) {
                    return pItems[i];
                }
            }
            return null;
        }

        hasChildItem(pItem: IItem): IItem {
            var i;
            var pItems = this._pItemList;
            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].isChildItem(pItem)) {
                    return pItems[i];
                }
            }
            return null;
        }

        hasRule(pRule:IRule, iPos:  number ): bool {
            var i: number  = 0;
            var pItemList:IItem[] = this._pItemList;
            var pItem:IItem;

            for(i = 0; i < this._nBaseItems; i++){
                pItem = pItemList[i];
                if(pItem.rule === pRule && pItem.position === iPos){
                    return true;
                }
            }

            return false;
        }

        inline isEmpty(): bool {
            return !(this._pItemList.length);
        }

        isEqual(pState: IState, eType: EParserType): bool {

            var pItemsA: IItem[] = this._pItemList;
            var pItemsB: IItem[] = pState.items;

            if (this._nBaseItems !== pState.numBaseItems) {
                return false;
            }
            var nItems = this._nBaseItems;
            var i, j;
            var isEqual;
            for (i = 0; i < nItems; i++) {
                isEqual = false;
                for (j = 0; j < nItems; j++) {
                    if (pItemsA[i].isEqual(pItemsB[j], eType)) {
                        isEqual = true;
                        break;
                    }
                }
                if (!isEqual) {
                    return false;
                }
            }
            return true;
        }

        push(pItem: IItem): void {
            if (this._pItemList.length === 0 || pItem.position > 0) {
                this._nBaseItems += 1;
            }
            pItem.state = this;
            this._pItemList.push(pItem);
        }

        tryPush_LR0(pRule: IRule, iPos:  number ): bool {
            var i:  number ;
            var pItems: IItem[] = this._pItemList;
            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].rule === pRule && pItems[i].position === iPos) {
                    return false;
                }
            }
            var pItem: IItem = new Item(pRule, iPos);
            this.push(pItem);
            return true;
        }

        tryPush_LR(pRule: IRule, iPos:  number , sExpectedSymbol: string): bool {
            var i:  number ;
            var pItems: IItem[] = <IItem[]>(this._pItemList);

            for (i = 0; i < pItems.length; i++) {
                if (pItems[i].rule === pRule && pItems[i].position === iPos) {
                    return pItems[i].addExpected(sExpectedSymbol);
                }
            }

            var pExpected: BoolMap = <BoolMap>{};
            pExpected[sExpectedSymbol] = true;

            var pItem: IItem = new Item(pRule, iPos, pExpected);
            this.push(pItem);
            return true;
        }

        getNextStateBySymbol(sSymbol: string): IState {
            if (isDef(this._pNextStates[sSymbol])) {
                return this._pNextStates[sSymbol];
            }
            else {
                return null;
            }
        }

        addNextState(sSymbol: string, pState: IState): bool {
            if (isDef(this._pNextStates[sSymbol])) {
                return false;
            }
            else {
                this._pNextStates[sSymbol] = pState;
                return true;
            }
        }

        inline deleteNotBase(): void {
            this._pItemList.length = this._nBaseItems;
        }

        toString(isBase: bool): string {
            var len:  number  = 0;
            var sMsg: string;
            var pItemList: IItem[] = this._pItemList;

            sMsg = "State " + this._iIndex + ":\n";
            len = isBase ? this._nBaseItems : pItemList.length;

            for (var j = 0; j < len; j++) {
                sMsg += "\t\t";
                sMsg += pItemList[j].toString();
                sMsg += "\n";
            }

            return sMsg;
        }
    }

    export class ParseTree implements IParseTree {
        private _pRoot: IParseNode;
        private _pNodes: IParseNode[];
        private _pNodesCountStack:  number [];
        private _isOptimizeMode: bool;

        inline get root(): IParseNode {
            return this._pRoot;
        }

        inline set root(pRoot: IParseNode) {
            this._pRoot = pRoot;
        }

        constructor () {
            this._pRoot = null;
            this._pNodes = <IParseNode[]>[];
            this._pNodesCountStack = < number []>[];
            this._isOptimizeMode = false;
        }

        setRoot(): void {
            this._pRoot = this._pNodes.pop();
        }

        setOptimizeMode(isOptimize: bool): void {
            this._isOptimizeMode = isOptimize;
        }

        addNode(pNode: IParseNode): void {
            this._pNodes.push(pNode);
            this._pNodesCountStack.push(1);
        }

        reduceByRule(pRule: IRule, eCreate: ENodeCreateMode = ENodeCreateMode.k_Default): void {
            var iReduceCount:  number  = 0;
            var pNodesCountStack:  number [] = this._pNodesCountStack;
            var pNode: IParseNode;
            var iRuleLength:  number  = pRule.right.length;
            var pNodes: IParseNode[] = this._pNodes;
            var nOptimize:  number  = this._isOptimizeMode ? 1 : 0;

            while (iRuleLength) {
                iReduceCount += pNodesCountStack.pop();
                iRuleLength--;
            }

            if ((eCreate === ENodeCreateMode.k_Default && iReduceCount > nOptimize) || (eCreate === ENodeCreateMode.k_Necessary)) {
                pNode = <IParseNode>{
                            name: pRule.left,
                            children: null,
                            parent: null,
                            value: "" ,
                            isAnalyzed: false,
                            position: this._pNodes.length
                        };

                while (iReduceCount) {
                    this.addLink(pNode, pNodes.pop());
                    iReduceCount -= 1;
                }

                pNodes.push(pNode);
                pNodesCountStack.push(1);
            }
            else {
                pNodesCountStack.push(iReduceCount);
            }
        }

        toString(): string {
            if (this._pRoot) {
                return this.toStringNode(this._pRoot);
            }
            else {
                return "";
            }
        }

        clone(): IParseTree {
            var pTree = new ParseTree();
            pTree.root = this.cloneNode(this._pRoot);
            return pTree;
        }

        inline getNodes(): IParseNode[]{
            return this._pNodes;
        }

        inline getLastNode(): IParseNode{
            return this._pNodes[this._pNodes.length - 1];
        }

        private addLink(pParent: IParseNode, pNode: IParseNode): void {
            if (!pParent.children) {
                pParent.children = <IParseNode[]>[];
            }
            pParent.children.push(pNode);
            pNode.parent = pParent;
        }

        private cloneNode(pNode: IParseNode): IParseNode {
            var pNewNode: IParseNode;
            pNewNode = <IParseNode>{
                name: pNode.name,
                value: pNode.value,
                children: null,
                parent: null,
                isAnalyzed: pNode.isAnalyzed,
                position: pNode.position
            };

            var pChildren: IParseNode[] = pNode.children;
            for (var i = 0; pChildren && i < pChildren.length; i++) {
                this.addLink(pNewNode, this.cloneNode(pChildren[i]));
            }

            return pNewNode;
        }

        private toStringNode(pNode: IParseNode, sPadding: string = ""): string {
            var sRes: string = sPadding + "{\n";
            var sOldPadding: string = sPadding;
            var sDefaultPadding: string = "  ";

            sPadding += sDefaultPadding;

            if (pNode.value) {
                sRes += sPadding + "name : \"" + pNode.name + "\"" + ",\n";
                sRes += sPadding + "value : \"" + pNode.value + "\"" + "\n";
            }
            else {

                sRes += sPadding + "name : \"" + pNode.name + "\"" + "\n";
                sRes += sPadding + "children : [";

                var pChildren: IParseNode[] = pNode.children;

                if (pChildren) {
                    sRes += "\n";
                    sPadding += sDefaultPadding;

                    for (var i = pChildren.length - 1; i >= 0; i--) {
                        sRes += this.toStringNode(pChildren[i], sPadding);
                        sRes += ",\n";
                    }

                    sRes = sRes.slice(0, sRes.length - 2);
                    sRes += "\n";
                    sRes += sOldPadding + sDefaultPadding + "]\n";
                }
                else {
                    sRes += " ]\n";
                }
            }
            sRes += sOldPadding + "}";
            return sRes;
        }
    }

    class Lexer implements ILexer {
        private _iLineNumber:  number ;
        private _iColumnNumber:  number ;
        private _sSource: string;
        private _iIndex:  number ;
        private _pParser: IParser;
        private _pPunctuatorsMap: StringMap;
        private _pKeywordsMap: StringMap;
        private _pPunctuatorsFirstSymbols: BoolMap;

        constructor (pParser: IParser) {
            this._iLineNumber = 0;
            this._iColumnNumber = 0;
            this._sSource = "";
            this._iIndex = 0;
            this._pParser = pParser;
            this._pPunctuatorsMap = <StringMap>{};
            this._pKeywordsMap = <StringMap>{};
            this._pPunctuatorsFirstSymbols = <BoolMap>{};
        }

        addPunctuator(sValue: string, sName?: string): string {
            if (sName === undefined && sValue.length === 1) {
                sName = "T_PUNCTUATOR_" + sValue.charCodeAt(0);

            }
            this._pPunctuatorsMap[sValue] = sName;
            this._pPunctuatorsFirstSymbols[sValue[0]] = true;
            return sName;
        }

        addKeyword(sValue: string, sName: string): string {
            this._pKeywordsMap[sValue] = sName;
            return sName;
        }

        getTerminalValueByName(sName: string): string{
            var sValue: string = null;

            for(sValue in this._pPunctuatorsMap){
                if(this._pPunctuatorsMap[sValue] === sName){
                    return sValue;
                }
            }

            for(sValue in this._pKeywordsMap){
                if(this._pKeywordsMap[sValue] === sName){
                    return sValue;
                }
            }

            return sName;
        }

        init(sSource: string): void {
            this._sSource = sSource;
            this._iLineNumber = 0;
            this._iColumnNumber = 0;
            this._iIndex = 0;
        }

        getNextToken(): IToken {
            var ch: string = this.currentChar();
            if (!ch) {
                return <IToken>{
                    name:  "$" ,
                    value:  "$" ,
                    start: this._iColumnNumber,
                    end: this._iColumnNumber,
                    line: this._iLineNumber
                };
            }
            var eType: ETokenType = this.identityTokenType();
            var pToken: IToken;
            switch (eType) {
                case ETokenType.k_NumericLiteral:
                    pToken = this.scanNumber();
                    break;
                case ETokenType.k_CommentLiteral:
                    this.scanComment();
                    pToken = this.getNextToken();
                    break;
                case ETokenType.k_StringLiteral:
                    pToken = this.scanString();
                    break;
                case ETokenType.k_PunctuatorLiteral:
                    pToken = this.scanPunctuator();
                    break;
                case ETokenType.k_IdentifierLiteral:
                    pToken = this.scanIdentifier();
                    break;
                case ETokenType.k_WhitespaceLiteral:
                    this.scanWhiteSpace();
                    pToken = this.getNextToken();
                    break;
                default:
                    this._error( 2101 ,
                                <IToken>{
                                    name:  "UNNOWN" ,
                                    value: ch + this._sSource[this._iIndex + 1],
                                    start: this._iColumnNumber,
                                    end: this._iColumnNumber + 1,
                                    line: this._iLineNumber
                                });
            }
            return pToken;
        }

        inline _getIndex():  number  {
            return this._iIndex;
        }

        inline _setSource(sSource: string): void {
            this._sSource = sSource;
        }

        inline _setIndex(iIndex:  number ): void {
            this._iIndex = iIndex;
        }

        private _error(eCode:  number , pToken: IToken): void {
            var pLocation: ISourceLocation = <ISourceLocation>{
                                                file: this._pParser.getParseFileName(),
                                                line: this._iLineNumber
                                             };
            var pInfo:Object = {
                tokenValue: pToken.value,
                tokenType: pToken.type
            };

            var pLogEntity: ILoggerEntity = <ILoggerEntity>{code: eCode, info: pInfo, location: pLocation};

            akra.logger["error"](pLogEntity);

            throw new Error(eCode.toString());
        }

        private identityTokenType(): ETokenType {
            if (this.isIdentifierStart()) {
                return ETokenType.k_IdentifierLiteral;
            }
            if (this.isWhiteSpaceStart()) {
                return ETokenType.k_WhitespaceLiteral;
            }
            if (this.isStringStart()) {
                return ETokenType.k_StringLiteral;
            }
            if (this.isCommentStart()) {
                return ETokenType.k_CommentLiteral;
            }
            if (this.isNumberStart()) {
                return ETokenType.k_NumericLiteral;
            }
            if (this.isPunctuatorStart()) {
                return ETokenType.k_PunctuatorLiteral;
            }
            return ETokenType.k_Unknown;
        }

        private isNumberStart(): bool {
            var ch: string = this.currentChar();

            if ((ch >= '0') && (ch <= '9')) {
                return true;
            }

            var ch1: string = this.nextChar();
            if (ch === "." && (ch1 >= '0') && (ch1 <= '9')) {
                return true;
            }

            return false;
        }

        private isCommentStart(): bool {
            var ch: string = this.currentChar();
            var ch1: string = this.nextChar();

            if (ch === "/" && (ch1 === "/" || ch1 === "*")) {
                return true;
            }

            return false;
        }

        private isStringStart(): bool {
            var ch: string = this.currentChar();
            if (ch === "\"" || ch === "'") {
                return true;
            }
            return false;
        }

        private isPunctuatorStart(): bool {
            var ch: string = this.currentChar();
            if (this._pPunctuatorsFirstSymbols[ch]) {
                return true;
            }
            return false;
        }

        private isWhiteSpaceStart(): bool {
            var ch: string = this.currentChar();
            if (ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t') {
                return true;
            }
            return false;
        }

        private isIdentifierStart(): bool {
            var ch: string = this.currentChar();
            if ((ch === '_') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                return true;
            }
            return false;
        }

        private isLineTerminator(sSymbol: string): bool {
            return (sSymbol === '\n' || sSymbol === '\r' || sSymbol === '\u2028' || sSymbol === '\u2029');
        }

        private isWhiteSpace(sSymbol: string): bool {
            return (sSymbol === ' ') || (sSymbol === '\t');
        }

        private inline isKeyword(sValue: string): bool {
            return !!(this._pKeywordsMap[sValue]);
        }

        private inline isPunctuator(sValue: string): bool {
            return !!(this._pPunctuatorsMap[sValue]);
        }

        private inline nextChar(): string {
            return this._sSource[this._iIndex + 1];
        }

        private inline currentChar(): string {
            return this._sSource[<number>this._iIndex];
        }

        private inline readNextChar(): string {
            this._iIndex++;
            this._iColumnNumber++;
            return this._sSource[<number>this._iIndex];
        }

        private scanString(): IToken {
            var chFirst: string = this.currentChar();
            var sValue: string = chFirst;
            var ch: string = null;
            var chPrevious: string = chFirst;
            var isGoodFinish: bool = false;
            var iStart:  number  = this._iColumnNumber;

            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    break;
                }
                sValue += ch;
                if (ch === chFirst && chPrevious !== '\\') {
                    isGoodFinish = true;
                    this.readNextChar();
                    break;
                }
                chPrevious = ch;
            }

            if (isGoodFinish) {
                return <IToken>{
                    name:  "T_STRING" ,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber - 1,
                    line: this._iLineNumber
                };
            }
            else {
                if (!ch) {
                    ch =  "EOF" ;
                }
                sValue += ch;

                this._error( 2102 , <IToken> {
                    type: ETokenType.k_StringLiteral,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber,
                    line: this._iLineNumber
                });
                return null;
            }
        }

        private scanPunctuator(): IToken {
            var sValue: string = this.currentChar();
            var ch: string;
            var iStart:  number  = this._iColumnNumber;

            while (true) {
                ch = this.readNextChar();
                if (ch) {
                    sValue += ch;
                    this._iColumnNumber++;
                    if (!this.isPunctuator(sValue)) {
                        sValue = sValue.slice(0, sValue.length - 1);
                        break;
                    }
                }
                else {
                    break;
                }
            }

            return <IToken>{
                name: this._pPunctuatorsMap[sValue],
                value: sValue,
                start: iStart,
                end: this._iColumnNumber - 1,
                line: this._iLineNumber
            };
        }

        private scanNumber(): IToken {
            var ch: string = this.currentChar();
            var sValue: string = "";
            var isFloat: bool = false;
            var chPrevious: string = ch;
            var isGoodFinish: bool = false;
            var iStart:  number  = this._iColumnNumber;
            var isE: bool = false;

            if (ch === '.') {
                sValue += 0;
                isFloat = true;
            }

            sValue += ch;

            while (true) {
                ch = this.readNextChar();
                if (ch === '.') {
                    if (isFloat) {
                        break;
                    }
                    else {
                        isFloat = true;
                    }
                }
                else if (ch === 'e') {
                    if (isE) {
                        break;
                    }
                    else {
                        isE = true;
                    }
                }
                else if (((ch === '+' || ch === '-') && chPrevious === 'e')) {
                    sValue += ch;
                    chPrevious = ch;
                    continue;
                }
                else if (ch === 'f' && isFloat) {
                    ch = this.readNextChar();
                    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                        break;
                    }
                    isGoodFinish = true;
                    break;
                }
                else if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
                    break;
                }
                else if (!((ch >= '0') && (ch <= '9')) || !ch) {
                    if ((isE && chPrevious !== '+' && chPrevious !== '-' && chPrevious !== 'e') || !isE) {
                        isGoodFinish = true;
                    }
                    break;
                }
                sValue += ch;
                chPrevious = ch;
            }

            if (isGoodFinish) {
                var sName = isFloat ?  "T_FLOAT"  :  "T_UINT" ;
                return {
                    name: sName,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber - 1,
                    line: this._iLineNumber
                };
            }
            else {
                if (!ch) {
                    ch =  "EOF" ;
                }
                sValue += ch;
                this._error( 2102 , <IToken> {
                    type: ETokenType.k_NumericLiteral,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber,
                    line: this._iLineNumber
                });
                return null;
            }
        }

        private scanIdentifier(): IToken {
            var ch: string = this.currentChar();
            var sValue: string = ch;
            var iStart:  number  = this._iColumnNumber;
            var isGoodFinish: bool = false;

            while (true) {
                ch = this.readNextChar();
                if (!ch) {
                    isGoodFinish = true;
                    break;
                }
                if (!((ch === '_') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9'))) {
                    isGoodFinish = true;
                    break;
                }
                sValue += ch;
            }

            if (isGoodFinish) {
                if (this.isKeyword(sValue)) {
                    return <IToken>{
                        name: this._pKeywordsMap[sValue],
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                }
                else {
                    var sName = this._pParser.isTypeId(sValue) ?  "T_TYPE_ID"  :  "T_NON_TYPE_ID" ;
                    return <IToken> {
                        name: sName,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber - 1,
                        line: this._iLineNumber
                    };
                }
            }
            else {
                if (!ch) {
                    ch =  "EOF" ;
                }
                sValue += ch;
                this._error( 2102 , <IToken> {
                    type: ETokenType.k_IdentifierLiteral,
                    value: sValue,
                    start: iStart,
                    end: this._iColumnNumber,
                    line: this._iLineNumber
                });
                return null;
            }
        }

        private scanWhiteSpace(): bool {
            var ch: string = this.currentChar();

            while (true) {
                if (!ch) {
                    break;
                }
                if (this.isLineTerminator(ch)) {
                    if(ch === "\r" && this.nextChar() === "\n"){
                        this._iLineNumber--;
                    }
                    this._iLineNumber++;
                    ch = this.readNextChar();
                    this._iColumnNumber = 0;
                    continue;
                }
                else if (ch === '\t') {
                    this._iColumnNumber += 3;
                }
                else if (ch !== ' ') {
                    break;
                }
                ch = this.readNextChar();
            }

            return true;
        }

        private scanComment(): bool {
            var sValue: string = this.currentChar();
            var ch: string = this.readNextChar();
            sValue += ch;

            if (ch === '/') {
//Line Comment
                while (true) {
                    ch = this.readNextChar();
                    if (!ch) {
                        break;
                    }
                    if (this.isLineTerminator(ch)) {
                        if(ch === "\r" && this.nextChar() === "\n"){
                            this._iLineNumber--;
                        }
                        this._iLineNumber++;
                        this.readNextChar();
                        this._iColumnNumber = 0;
                        break;
                    }
                    sValue += ch;
                }

                return true;
            }
            else {
//Multiline Comment
                var chPrevious: string = ch;
                var isGoodFinish: bool = false;
                var iStart:  number  = this._iColumnNumber;

                while (true) {
                    ch = this.readNextChar();
                    if (!ch) {
                        break;
                    }
                    sValue += ch;
                    if (ch === '/' && chPrevious === '*') {
                        isGoodFinish = true;
                        this.readNextChar();
                        break;
                    }
                    if (this.isLineTerminator(ch)) {
                        if(ch === "\r" && this.nextChar() === "\n"){
                            this._iLineNumber--;
                        }
                        this._iLineNumber++;
                        this._iColumnNumber = -1;
                    }
                    chPrevious = ch;
                }

                if (isGoodFinish) {
                    return true;
                }
                else {
                    if (!ch) {
                        ch =  "EOF" ;
                    }
                    sValue += ch;
                    this._error( 2102 , <IToken> {
                        type: ETokenType.k_CommentLiteral,
                        value: sValue,
                        start: iStart,
                        end: this._iColumnNumber,
                        line: this._iLineNumber
                    });

                }

            }
        }
    }


    export interface IOperationMap {
        [grammarSymbol: string]: IOperation;
        [stateIndex:  number ]: IOperation;
    }

    export interface IOperationDMap {
        [stateIndex:  number ]: IOperationMap;
    }

    export interface IRuleMap {
        [ruleIndex:  number ]: IRule;
        [ruleName: string]: IRule;
    }

    export interface IRuleDMap {
        [ruleIndex:  number ]: IRuleMap;
        [ruleName: string]: IRuleMap;
    }

    export interface IRuleFunctionMap {
        [grammarSymbolOrFuncName: string]: IRuleFunction;
    }

    export interface IRuleFunctionDMap {
        [stateIndex:  number ]: IRuleFunctionMap;
    }

    export interface IAdditionalFuncInfo{
        name: string;
        position:  number ;
        rule: IRule;
    }

    export class Parser implements IParser {
// //Input

        private _sSource: string;
        private _iIndex:  number ;
        private _sFileName: string;

//Output

        private _pSyntaxTree: IParseTree;
        private _pTypeIdMap: BoolMap;

//Process params

        private _pLexer: ILexer;
        private _pStack:  number [];
        private _pToken: IToken;

//For async loading of files work fine

        private _fnFinishCallback: IFinishFunc;
        private _pCaller: any;

//Grammar Info

        private _pSymbolMap: BoolMap;
        private _pSyntaxTable: IOperationDMap;
        private _pReduceOperationsMap: IOperationMap;
        private _pShiftOperationsMap: IOperationMap;
        private _pSuccessOperation: IOperation;

        private _pFirstTerminalsDMap: BoolDMap;
        private _pFollowTerminalsDMap: BoolDMap;

        private _pRulesDMap: IRuleDMap;
        private _pStateList: IState[];
        private _nRules:  number ;

        private _pAdditionalFuncInfoList: IAdditionalFuncInfo[];
        private _pAdditionalFunctionsMap: IRuleFunctionMap;

        private _pAdidtionalFunctByStateDMap: IRuleFunctionDMap;

        private _eType: EParserType;

        private _pGrammarSymbols: StringMap;

//Additioanal info

        private _pRuleCreationModeMap: IntMap;
        private _eParseMode: EParseMode;

// private _isSync: bool;

//Temp

        private _pStatesTempMap: IStateMap;
        private _pBaseItemList: IItem[];
        private _pExpectedExtensionDMap: BoolDMap;


        constructor () {
            this._sSource = "";
            this._iIndex = 0;

            this._pSyntaxTree = null;
            this._pTypeIdMap = null;

            this._pLexer = null;
            this._pStack = < number []>[];
            this._pToken = null;

            this._fnFinishCallback = null;
            this._pCaller = null;

            this._pSymbolMap = <BoolMap><any>{ "$" : true};
            this._pSyntaxTable = null;
            this._pReduceOperationsMap = null;
            this._pShiftOperationsMap = null;
            this._pSuccessOperation = null;

            this._pFirstTerminalsDMap = null;
            this._pFollowTerminalsDMap = null;
            this._pRulesDMap = null;
            this._pStateList = null;
            this._nRules = 0;
            this._pAdditionalFuncInfoList = null;
            this._pAdditionalFunctionsMap = null;
            this._pAdidtionalFunctByStateDMap = null;

            this._eType = EParserType.k_LR0;

            this._pRuleCreationModeMap = null;
            this._eParseMode = EParseMode.k_AllNode;

// this._isSync = false;

            this._pStatesTempMap = null;
            this._pBaseItemList = null;

            this._pExpectedExtensionDMap = null;

            this._sFileName = "stdin";;
        }

        isTypeId(sValue: string): bool {
            return !!(this._pTypeIdMap[sValue]);
        }

        returnCode(pNode: IParseNode): string {
            if (pNode) {
                if (pNode.value) {
                    return pNode.value + " ";
                }
                else if (pNode.children) {
                    var sCode: string = "";
                    var i:  number  = 0;
                    for (i = pNode.children.length - 1; i >= 0; i--) {
                        sCode += this.returnCode(pNode.children[i]);
                    }
                    return sCode;
                }
            }
            return "";
        }

        init(sGrammar: string, eMode?: EParseMode = EParseMode.k_AllNode, eType?: EParserType = EParserType.k_LALR): bool {
            try {
                this._eType = eType;
                this._pLexer = new Lexer(this);
                this._eParseMode = eMode;
                this.generateRules(sGrammar);
                this.buildSyntaxTable();
                this.generateFunctionByStateMap();
                if(!bf.testAll(eMode, EParseMode.k_DebugMode)){
                    this.clearMem();
                }
                return true;
            }
            catch (e) {
                logger.setSourceLocation( "util/Parser.ts" , 1397 ); logger.log(e.stack); ;
// error("Could`not initialize parser. Error with code has occurred: " + e.message + ". See log for more info.");
                return false;
            }
        }

        parse(sSource: string, fnFinishCallback?: IFinishFunc = null, pCaller?: any = null): EParserCode {
             try {
                this.defaultInit();
                this._sSource = sSource;
                this._pLexer.init(sSource);

//this._isSync = isSync;

                this._fnFinishCallback = fnFinishCallback;
                this._pCaller = pCaller;

                var pTree:IParseTree = this._pSyntaxTree;
                var pStack: number [] = this._pStack;
                var pSyntaxTable:IOperationDMap = this._pSyntaxTable;

                var isStop:bool = false;
                var isError:bool = false;
                var isPause:bool = false;
                var pToken:IToken = this.readToken();

                var pOperation:IOperation;
                var iRuleLength: number ;

                var eAdditionalOperationCode: EOperationType;
                var iStateIndex:  number  = 0;

                while (!isStop) {
                    pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                    if (isDef(pOperation)) {
                        switch (pOperation.type) {
                            case EOperationType.k_Success:
                                isStop = true;
                                break;

                            case EOperationType.k_Shift:

                                iStateIndex = pOperation.index;
                                pStack.push(iStateIndex);
                                pTree.addNode(<IParseNode>pToken);

                                eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);

                                if(eAdditionalOperationCode === EOperationType.k_Error){
                                    isError = true;
                                    isStop = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Pause){
                                    this._pToken = null;
                                    isStop = true;
                                    isPause = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Ok){
                                    pToken = this.readToken();
                                }

                                break;

                            case EOperationType.k_Reduce:

                                iRuleLength = pOperation.rule.right.length;
                                pStack.length -= iRuleLength;
                                iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                pStack.push(iStateIndex);
                                pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);

                                eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);

                                if(eAdditionalOperationCode === EOperationType.k_Error){
                                    isError = true;
                                    isStop = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Pause){
                                    this._pToken = pToken;
                                    isStop = true;
                                    isPause = true;
                                }

                                break;
                        }
                    }
                    else {
                        isError = true;
                        isStop = true;
                    }
                }
            }
            catch (e) {
// debug_print(e.stack);
                this._sFileName = "stdin";
                return EParserCode.k_Error;
            }

            if (isPause) {
                return EParserCode.k_Pause;
            }

            if (!isError) {
                pTree.setRoot();
                if (!isNull(this._fnFinishCallback)) {
                    this._fnFinishCallback.call(this._pCaller, EParserCode.k_Ok, this.getParseFileName());
                }
                this._sFileName = "stdin";
                return EParserCode.k_Ok;
            }
            else {
                this._error( 2051 , pToken);
                if (!isNull(this._fnFinishCallback)) {
                    this._fnFinishCallback.call(this._pCaller, EParserCode.k_Error, this.getParseFileName());
                }
                this._sFileName = "stdin";
                return EParserCode.k_Error;
            }
        }

        setParseFileName(sFileName: string): void {
            this._sFileName = sFileName;
        }

        getParseFileName(): string{
            return this._sFileName;
        }

        pause(): EParserCode {
            return EParserCode.k_Pause;
        }

        resume(): EParserCode {
            return this.resumeParse();
        }

        printStates(isBaseOnly?: bool = true): void {
            if(!isDef(this._pStateList)){
                logger.setSourceLocation( "util/Parser.ts" , 1535 ); logger.log("It`s impossible to print states. You must init parser in debug-mode"); ;
                return;
            }
            var sMsg: string = "\n" + this.statesToString(isBaseOnly);
            logger.setSourceLocation( "util/Parser.ts" , 1539 ); logger.log(sMsg); ;
        }

        printState(iStateIndex:  number , isBaseOnly?: bool = true): void {
            if(!isDef(this._pStateList)){
                logger.setSourceLocation( "util/Parser.ts" , 1544 ); logger.log("It`s impossible to print states. You must init parser in debug-mode"); ;
                return;
            }

            var pState:IState = this._pStateList[iStateIndex];
            if(!isDef(pState)){
                logger.setSourceLocation( "util/Parser.ts" , 1550 ); logger.log("Can not print stete with index: " + iStateIndex.toString()); ;
                return;
            }

            var sMsg: string = "\n" + pState.toString(isBaseOnly);
            logger.setSourceLocation( "util/Parser.ts" , 1555 ); logger.log(sMsg); ;
        }

        getGrammarSymbols(): StringMap{
            return this._pGrammarSymbols;
        }

        inline getSyntaxTree(): IParseTree {
            return this._pSyntaxTree;
        }

        _saveState(): IParserState {
            return {
                source: this._sSource,
                index: this._pLexer._getIndex(),
                fileName: this._sFileName,
                tree: this._pSyntaxTree,
                types: this._pTypeIdMap,
                stack: this._pStack,
                token: this._pToken,
                fnCallback: this._fnFinishCallback,
                caller: this._pCaller
            };
        }

        _loadState(pState: IParserState): void {
            this._sSource = pState.source;
            this._iIndex = pState.index;
            this._sFileName = pState.fileName;
            this._pSyntaxTree = pState.tree;
            this._pTypeIdMap = pState.types;
            this._pStack = pState.stack;
            this._pToken = pState.token;
            this._fnFinishCallback = pState.fnCallback;
            this._pCaller = pState.caller;

            this._pLexer._setSource(pState.source);
            this._pLexer._setIndex(pState.index);
        }



        /**@protected*/  addAdditionalFunction(sFuncName: string, fnRuleFunction: IRuleFunction): void {
            if(isNull(this._pAdditionalFunctionsMap)){
                this._pAdditionalFunctionsMap = <IRuleFunctionMap>{};
            }
            this._pAdditionalFunctionsMap[sFuncName] = fnRuleFunction;
        }

        /**@protected*/  addTypeId(sIdentifier: string): void {
            if(isNull(this._pTypeIdMap)){
                this._pTypeIdMap = <BoolMap>{};
            }
            this._pTypeIdMap[sIdentifier] = true;
        }

        /**@protected*/  defaultInit(): void {
            this._iIndex = 0;
            this._pStack = [0];
            this._pSyntaxTree = new ParseTree();
            this._pTypeIdMap = <BoolMap>{};

            this._pSyntaxTree.setOptimizeMode(bf.testAll(this._eParseMode, EParseMode.k_Optimize));
        }

        private _error(eCode:  number , pErrorInfo: any): void {
            var pLocation: ISourceLocation = <ISourceLocation>{};

            var pInfo:any = {
                tokenValue: null,
                line: null,
                column: null,
                stateIndex: null,
                oldNextStateIndex: null,
                newNextStateIndex: null,
                grammarSymbol: null,
                newOperation: null,
                oldOperation: null,
                expectedSymbol: null,
                unexpectedSymbol: null,
                badKeyword: null
            };

            var pLogEntity: ILoggerEntity = <ILoggerEntity>{code: eCode, info: pInfo, location: pLocation};

            if(eCode ===  2051 ){
                var pToken: IToken = <IToken>pErrorInfo;
                var iLine:  number  = pToken.line;
                var iColumn:  number  = pToken.start;

                pInfo.tokenValue = pToken.value;
                pInfo.line = iLine;
                pInfo.column = iColumn;

                pLocation.file = this.getParseFileName();
                pLocation.line = iLine;
            }
            else if(eCode ===  2001 ){
                var iStateIndex:  number  = pErrorInfo.stateIndex;
                var sSymbol: string = pErrorInfo.grammarSymbol;
                var pOldOperation: IOperation = pErrorInfo.oldOperation;
                var pNewOperation: IOperation = pErrorInfo.newOperation;

                pInfo.stateIndex = iStateIndex;
                pInfo.grammarSymbol = sSymbol;
                pInfo.oldOperation = this.operationToString(pOldOperation);
                pInfo.newOperation = this.operationToString(pNewOperation);

                pLocation.file = "GRAMMAR";
                pLocation.line = 0;
            }
            else if(eCode ===  2002 ){
                var iStateIndex:  number  = pErrorInfo.stateIndex;
                var sSymbol: string = pErrorInfo.grammarSymbol;
                var iOldNextStateIndex:  number  = pErrorInfo.oldNextStateIndex;
                var iNewNextStateIndex:  number  = pErrorInfo.newNextStateIndex;

                pInfo.stateIndex = iStateIndex;
                pInfo.grammarSymbol = sSymbol;
                pInfo.oldNextStateIndex = iOldNextStateIndex;
                pInfo.newNextStateIndex = iNewNextStateIndex;

                pLocation.file = "GRAMMAR";
                pLocation.line = 0;
            }
            else if(eCode ===  2003 ){
                var iLine:  number  = pErrorInfo.grammarLine;
                var sExpectedSymbol: string = pErrorInfo.expectedSymbol;
                var sUnexpectedSymbol: string = pErrorInfo.unexpectedSymbol;

                pInfo.expectedSymbol = sExpectedSymbol;
                pInfo.unexpectedSymbol = sExpectedSymbol;

                pLocation.file = "GRAMMAR";
                pLocation.line = iLine || 0;
            }
            else if(eCode ===  2004 ){
                var iLine:  number  = pErrorInfo.grammarLine;

                pLocation.file = "GRAMMAR";
                pLocation.line = iLine || 0;
            }
            else if(eCode ===  2005 ){
                var iLine:  number  = pErrorInfo.grammarLine;
                var sBadKeyword: string = pErrorInfo.badKeyword;

                pInfo.badKeyword = sBadKeyword;

                pLocation.file = "GRAMMAR";
                pLocation.line = iLine || 0;
            }

            akra.logger["error"](pLogEntity);

            throw new Error(eCode.toString());
        }

        private clearMem(): void {
            delete this._pFirstTerminalsDMap;
            delete this._pFollowTerminalsDMap;
            delete this._pRulesDMap;
            delete this._pStateList;
            delete this._pReduceOperationsMap;
            delete this._pShiftOperationsMap;
            delete this._pSuccessOperation;
            delete this._pStatesTempMap;
            delete this._pBaseItemList;
            delete this._pExpectedExtensionDMap;
        }

        private hasState(pState: IState, eType: EParserType) {
            var pStateList: IState[] = this._pStateList;
            var i:  number  = 0;

            for (i = 0; i < pStateList.length; i++) {
                if (pStateList[i].isEqual(pState, eType)) {
                    return pStateList[i];
                }
            }

            return null;
        }

        private isTerminal(sSymbol: string): bool {
            return !(this._pRulesDMap[sSymbol]);
        }

        private pushState(pState: IState): void {
            pState.index = this._pStateList.length;
            this._pStateList.push(pState);
        }

        private pushBaseItem(pItem: IItem): void {
            pItem.index = this._pBaseItemList.length;
            this._pBaseItemList.push(pItem);
        }

        private tryAddState(pState: IState, eType: EParserType): IState {
            var pRes = this.hasState(pState, eType);

            if (isNull(pRes)) {
                if (eType === EParserType.k_LR0) {
                    var pItems = pState.items;
                    for (var i = 0; i < pItems.length; i++) {
                        this.pushBaseItem(pItems[i]);
                    }
                }

                this.pushState(pState);
                this.closure(pState, eType);

                return pState;
            }

            return pRes;
        }

        private hasEmptyRule(sSymbol: string): bool {
            if (this.isTerminal(sSymbol)) {
                return false;
            }

            var pRulesDMap: IRuleDMap = this._pRulesDMap;
            for (var i in pRulesDMap[sSymbol]) {
                if (pRulesDMap[sSymbol][i].right.length === 0) {
                    return true;
                }
            }

            return false;
        }

        private pushInSyntaxTable(iIndex:  number , sSymbol: string, pOperation: IOperation): void {
            var pSyntaxTable: IOperationDMap = this._pSyntaxTable;
            if (!pSyntaxTable[iIndex]) {
                pSyntaxTable[iIndex] = <IOperationMap>{};
            }
            if (isDef(pSyntaxTable[iIndex][sSymbol])) {
                this._error( 2001 , {stateIndex: iIndex,
                                                           grammarSymbol: this.convertGrammarSymbol(sSymbol),
                                                           oldOperation: this._pSyntaxTable[iIndex][sSymbol],
                                                           newOperation: pOperation});
            }
            pSyntaxTable[iIndex][sSymbol] = pOperation;
        }

        private addStateLink(pState: IState, pNextState: IState, sSymbol: string): void {
            var isAddState: bool = pState.addNextState(sSymbol, pNextState);
            if (!isAddState) {
                this._error( 2002 , {stateIndex: pState.index,
                                                            oldNextStateIndex: pState.getNextStateBySymbol(sSymbol),
                                                            newNextStateIndex: pNextState.index,
                                                            grammarSymbol: this.convertGrammarSymbol(sSymbol)});
            }
        }

        private firstTerminal(sSymbol: string): BoolMap {
            if (this.isTerminal(sSymbol)) {
                return null;
            }

            if (isDef(this._pFirstTerminalsDMap[sSymbol])) {
                return this._pFirstTerminalsDMap[sSymbol];
            }

            var i: string = null, j:  number  = 0, k: string = null;
            var pRulesMap: IRuleMap = this._pRulesDMap[sSymbol];

            var pTempRes: BoolMap = <BoolMap>{};
            var pRes: BoolMap;

            var pRight: string[];
            var isFinish: bool;

            pRes = this._pFirstTerminalsDMap[sSymbol] = <BoolMap>{};

            if (this.hasEmptyRule(sSymbol)) {
                pRes[ "EMPTY" ] = true;
            }
            for (i in pRulesMap) {

                isFinish = false;
                pRight = pRulesMap[i].right;

                for (j = 0; j < pRight.length; j++) {

                    if (pRight[j] === sSymbol) {
                        if (pRes[ "EMPTY" ]) {
                            continue;
                        }
                        isFinish = true;
                        break;
                    }

                    pTempRes = this.firstTerminal(pRight[j]);

                    if (isNull(pTempRes)) {
                        pRes[pRight[j]] = true;
                    }
                    else {
                        for (k in pTempRes) {
                            pRes[k] = true;
                        }
                    }

                    if (!this.hasEmptyRule(pRight[j])) {
                        isFinish = true;
                        break;
                    }

                }

                if (!isFinish) {
                    pRes[ "EMPTY" ] = true;
                }

            }

            return pRes;
        }

        private followTerminal(sSymbol: string): BoolMap {
            if (isDef(this._pFollowTerminalsDMap[sSymbol])) {
                return this._pFollowTerminalsDMap[sSymbol];
            }

            var i: string = null, j: string = null, k:  number  = 0, l:  number  = 0, m: string = null;
            var pRulesDMap: IRuleDMap = this._pRulesDMap;

            var pTempRes: BoolMap;
            var pRes: BoolMap;

            var pRight: string[];
            var isFinish: bool;

            pRes = this._pFollowTerminalsDMap[sSymbol] = <BoolMap>{};

            for (i in pRulesDMap) {
                for (j in pRulesDMap[i]) {

                    pRight = pRulesDMap[i][j].right;

                    for (k = 0; k < pRight.length; k++) {

                        if (pRight[k] === sSymbol) {

                            if (k === pRight.length - 1) {
                                pTempRes = this.followTerminal(pRulesDMap[i][j].left);
                                for (m in pTempRes) {
                                    pRes[m] = true;
                                }
                            }
                            else {
                                isFinish = false;

                                for (l = k + 1; l < pRight.length; l++) {
                                    pTempRes = this.firstTerminal(pRight[l]);

                                    if (isNull(pTempRes)) {
                                        pRes[pRight[l]] = true;
                                        isFinish = true;
                                        break;
                                    }
                                    else {
                                        for (m in pTempRes) {
                                            pRes[m] = true;
                                        }
                                    }

                                    if (!pTempRes[ "EMPTY" ]) {
                                        isFinish = true;
                                        break;
                                    }
                                }

                                if (!isFinish) {
                                    pTempRes = this.followTerminal(pRulesDMap[i][j].left);
                                    for (m in pTempRes) {
                                        pRes[m] = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return pRes;
        }

        private firstTerminalForSet(pSet: string[], pExpected: BoolMap): BoolMap {
            var i:  number  = 0, j: string = null;

            var pTempRes: BoolMap;
            var pRes: BoolMap = <BoolMap>{};

            var isEmpty: bool;

            for (i = 0; i < pSet.length; i++) {
                pTempRes = this.firstTerminal(pSet[i]);

                if (isNull(pTempRes)) {
                    pRes[pSet[i]] = true;
                }

                isEmpty = false;

                for (j in pTempRes) {
                    if (j ===  "EMPTY" ) {
                        isEmpty = true;
                        continue;
                    }
                    pRes[j] = true;
                }

                if (!isEmpty) {
                    return pRes;
                }
            }

            for (j in pExpected) {
                pRes[j] = true;
            }

            return pRes;
        }

        private generateRules(sGrammarSource: string): void {
            var pAllRuleList: string[] = sGrammarSource.split(/\r?\n/);
            var pTempRule: string[];
            var pRule: IRule;
            var isLexerBlock: bool = false;

            this._pRulesDMap = <IRuleDMap>{};
            this._pAdditionalFuncInfoList = <IAdditionalFuncInfo[]>[];
            this._pRuleCreationModeMap = <IntMap>{};
            this._pGrammarSymbols = <StringMap>{};

            var i:  number  = 0, j:  number  = 0;

            var isAllNodeMode: bool = bf.testAll(< number >this._eParseMode, < number >EParseMode.k_AllNode);
            var isNegateMode: bool = bf.testAll(< number >this._eParseMode, < number >EParseMode.k_Negate);
            var isAddMode: bool = bf.testAll(< number >this._eParseMode, < number >EParseMode.k_Add);

            var pSymbolsWithNodeMap: IntMap = this._pRuleCreationModeMap;


            for (i = 0; i < pAllRuleList.length; i++) {
                if (pAllRuleList[i] === "" || pAllRuleList[i] === "\r") {
                    continue;
                }

                pTempRule = pAllRuleList[i].split(/\s* \s*/);

                if (isLexerBlock) {
                    if ((pTempRule.length === 3 || (pTempRule.length === 4 && pTempRule[3] === "")) &&
                        ((pTempRule[2][0] === "\"" || pTempRule[2][0] === "'") && pTempRule[2].length > 3)) {

//TERMINALS
                        if (pTempRule[2][0] !== pTempRule[2][pTempRule[2].length - 1]) {
                            this._error( 2003 , {unexpectedSymbol: pTempRule[2][pTempRule[2].length - 1],
                                                                           expectedSymbol: pTempRule[2][0],
                                                                           grammarLine: i});
                        }

                        pTempRule[2] = pTempRule[2].slice(1, pTempRule[2].length - 1);

                        var ch: string = pTempRule[2][0];
                        var sName: string;

                        if ((ch === "_") || (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z")) {
                            sName = this._pLexer.addKeyword(pTempRule[2], pTempRule[0]);
                        }
                        else {
                            sName = this._pLexer.addPunctuator(pTempRule[2], pTempRule[0]);
                        }

                        this._pGrammarSymbols[sName] = pTempRule[2];
                    }

                    continue;
                }

                if (pTempRule[0] ===  "--LEXER--" ) {
                    isLexerBlock = true;
                    continue;
                }

//NON TERMNINAL RULES
                if (isDef(this._pRulesDMap[pTempRule[0]]) === false) {
                    this._pRulesDMap[pTempRule[0]] = <IRuleMap>{};
                }

                pRule = <IRule>{
                    left: pTempRule[0],
                    right: <string[]>[],
                    index: 0
                };
                this._pSymbolMap[pTempRule[0]] = true;
                this._pGrammarSymbols[pTempRule[0]] = pTempRule[0];

                if (isAllNodeMode) {
                    pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Default;
                }
                else if (isNegateMode && !isDef(pSymbolsWithNodeMap[pTempRule[0]])) {
                    pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Default;
                }
                else if (isAddMode && !isDef(pSymbolsWithNodeMap[pTempRule[0]])) {
                    pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Not;
                }

                for (j = 2; j < pTempRule.length; j++) {
                    if (pTempRule[j] === "") {
                        continue;
                    }
                    if (pTempRule[j] ===  "--AN" ) {
                        if (isAddMode) {
                            pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Necessary;
                        }
                        continue;
                    }
                    if (pTempRule[j] ===  "--NN" ) {
                        if (isNegateMode && !isAllNodeMode) {
                            pSymbolsWithNodeMap[pTempRule[0]] = ENodeCreateMode.k_Not;
                        }
                        continue;
                    }
                    if (pTempRule[j] ===  "--F" ) {
                        if ((!pTempRule[j + 1] || pTempRule[j + 1].length === 0)) {
                            this._error( 2004 , {grammarLine: i});
                        }

                        var pFuncInfo: IAdditionalFuncInfo = <IAdditionalFuncInfo>{name: pTempRule[j + 1],
                                                                                   position: pRule.right.length,
                                                                                   rule: pRule};
                        this._pAdditionalFuncInfoList.push(pFuncInfo);
                        j++;
                        continue;
                    }
                    if (pTempRule[j][0] === "'" || pTempRule[j][0] === "\"") {
                        if (pTempRule[j].length !== 3) {
                            this._error( 2005 , {badKeyword: pTempRule[j],
                                                                     grammarLine: i});
                        }
                        if (pTempRule[j][0] !== pTempRule[j][2]) {
                            this._error( 2003 , {unexpectedSymbol: pTempRule[j][2],
                                                                           expectedSymbol: pTempRule[j][0],
                                                                           grammarLine: i});
//this._error("Can`t generate rules from grammar! Unexpected symbol! Must be");
                        }
                        var sName: string = this._pLexer.addPunctuator(pTempRule[j][1]);
                        pRule.right.push(sName);
                        this._pSymbolMap[sName] = true;
                    }
                    else {
                        pRule.right.push(pTempRule[j]);
                        this._pSymbolMap[pTempRule[j]] = true;
                    }
                }

                pRule.index = this._nRules;
                this._pRulesDMap[pTempRule[0]][pRule.index] = pRule;
                this._nRules += 1;

            }
        }

        private generateFunctionByStateMap():void {
            if(isNull(this._pAdditionalFunctionsMap)){
                return;
            }

            var pStateList: IState[] = this._pStateList;
            var pFuncInfoList: IAdditionalFuncInfo[] = this._pAdditionalFuncInfoList;
            var pFuncInfo: IAdditionalFuncInfo;
            var pRule: IRule;
            var iPos:  number  = 0;
            var pFunc: IRuleFunction;
            var sGrammarSymbol: string;

            var i: number  = 0, j:  number  = 0;

            var pFuncByStateDMap:IRuleFunctionDMap = <IRuleFunctionDMap>{};
            pFuncByStateDMap = this._pAdidtionalFunctByStateDMap = <IRuleFunctionDMap>{};

            for(i = 0; i < pFuncInfoList.length; i++){
                pFuncInfo = pFuncInfoList[i];

                pFunc = this._pAdditionalFunctionsMap[pFuncInfo.name];
                if(!isDef(pFunc)){
                    continue;
                }

                pRule = pFuncInfo.rule;
                iPos = pFuncInfo.position;
                sGrammarSymbol = pRule.right[iPos - 1];

                for(j = 0; j < pStateList.length; j++){
                    if(pStateList[j].hasRule(pRule, iPos)){
                        if(!isDef(pFuncByStateDMap[pStateList[j].index])){
                            pFuncByStateDMap[pStateList[j].index] = <IRuleFunctionMap>{};
                        }

                        pFuncByStateDMap[pStateList[j].index][sGrammarSymbol] = pFunc;
                    }
                }
            }
        }

        private generateFirstState(eType: EParserType): void {
            if (eType === EParserType.k_LR0) {
                this.generateFirstState_LR0();
            }
            else {
                this.generateFirstState_LR();
            }
        }

        private generateFirstState_LR0(): void {
            var pState: IState = new State();
            var pItem: IItem = new Item(this._pRulesDMap[ "S" ][0], 0);

            this.pushBaseItem(pItem);
            pState.push(pItem);

            this.closure_LR0(pState);
            this.pushState(pState);
        }

        private generateFirstState_LR(): void {
            var pState: IState = new State();
            var pExpected: BoolMap = <BoolMap>{};
            pExpected[ "$" ] = true;

            pState.push(new Item(this._pRulesDMap[ "S" ][0], 0, pExpected));

            this.closure_LR(pState);
            this.pushState(pState);
        }

        private closure(pState: IState, eType: EParserType): IState {
            if (eType === EParserType.k_LR0) {
                return this.closure_LR0(pState);
            }
            else {
                this.closure_LR(pState);
            }
        }

        private closure_LR0(pState: IState): IState {
            var pItemList: IItem[] = pState.items;
            var i:  number  = 0, j: string = null;
            var sSymbol: string;

            for (i = 0; i < pItemList.length; i++) {
                sSymbol = pItemList[i].mark();

                if (sSymbol !==  "END"  && (!this.isTerminal(sSymbol))) {
                    for (j in this._pRulesDMap[sSymbol]) {
                        pState.tryPush_LR0(this._pRulesDMap[sSymbol][j], 0);
                    }
                }

            }
            return pState;
        }

        private closure_LR(pState: IState): IState {
            var pItemList: IItem[] = <IItem[]>(pState.items);
            var i:  number  = 0, j: string = null, k: string = null;
            var sSymbol: string;
            var pSymbols: BoolMap;
            var pTempSet: string[];
            var isNewExpected: bool = false;

            while (true) {
                if (i === pItemList.length) {
                    if (!isNewExpected) {
                        break;
                    }
                    i = 0;
                    isNewExpected = false;
                }
                sSymbol = pItemList[i].mark();

                if (sSymbol !==  "END"  && (!this.isTerminal(sSymbol))) {
                    pTempSet = pItemList[i].rule.right.slice(pItemList[i].position + 1);
                    pSymbols = this.firstTerminalForSet(pTempSet, pItemList[i].expectedSymbols);

                    for (j in this._pRulesDMap[sSymbol]) {
                        for (k in pSymbols) {
                            if (pState.tryPush_LR(this._pRulesDMap[sSymbol][j], 0, k)) {
                                isNewExpected = true;
                            }
                        }
                    }
                }

                i++;
            }

            return pState;
        }

        private nexeState(pState: IState, sSymbol: string, eType: EParserType): IState {
            if (eType === EParserType.k_LR0) {
                return this.nextState_LR0(pState, sSymbol);
            }
            else {
                return this.nextState_LR(pState, sSymbol);
            }
        }

        private nextState_LR0(pState: IState, sSymbol: string): IState {
            var pItemList: IItem[] = pState.items;
            var i:  number  = 0;
            var pNewState: IState = new State();

            for (i = 0; i < pItemList.length; i++) {
                if (sSymbol === pItemList[i].mark()) {
                    pNewState.push(new Item(pItemList[i].rule, pItemList[i].position + 1));
                }
            }

            return pNewState;
        }

        private nextState_LR(pState: IState, sSymbol: string): IState {
            var pItemList: IItem[] = <IItem[]>pState.items;
            var i:  number  = 0;
            var pNewState: IState = new State();

            for (i = 0; i < pItemList.length; i++) {
                if (sSymbol === pItemList[i].mark()) {
                    pNewState.push(new Item(pItemList[i].rule, pItemList[i].position + 1, pItemList[i].expectedSymbols));
                }
            }

            return pNewState;
        }

        private deleteNotBaseItems(): void {
            var i:  number  = 0;
            for (i = 0; i < this._pStateList.length; i++) {
                this._pStateList[i].deleteNotBase();
            }
        }

        private closureForItem(pRule: IRule, iPos:  number ): IState {
            var sIndex: string = "";
            sIndex += pRule.index + "_" + iPos;

            var pState: IState = this._pStatesTempMap[sIndex];
            if (isDef(pState)) {
                return pState;
            }
            else {
                var pExpected: BoolMap = <BoolMap>{};
                pExpected[ "##" ] = true;

                pState = new State();
                pState.push(new Item(pRule, iPos, pExpected));

                this.closure_LR(pState);
                this._pStatesTempMap[sIndex] = pState;

                return pState;
            }
        }

        private addLinkExpected(pItem: IItem, pItemX: IItem): void {
            var pTable: BoolDMap = this._pExpectedExtensionDMap;
            var iIndex:  number  = pItem.index;

            if (!isDef(pTable[iIndex])) {
                pTable[iIndex] = <BoolMap>{};
            }

            pTable[iIndex][pItemX.index] = true;
        }

        private determineExpected(pTestState: IState, sSymbol: string): void {
            var pStateX = pTestState.getNextStateBySymbol(sSymbol);

            if (isNull(pStateX)) {
                return;
            }

            var pItemListX: IItem[] = <IItem[]>pStateX.items;
            var pItemList: IItem[] = <IItem[]>pTestState.items;
            var pState: IState;
            var pItem: IItem;
                var i:  number  = 0, j:  number  = 0, k: string = null;

            var nBaseItemTest = pTestState.numBaseItems;
            var nBaseItemX = pStateX.numBaseItems;

            for (i = 0; i < nBaseItemTest; i++) {
                pState = this.closureForItem(pItemList[i].rule, pItemList[i].position);

                for (j = 0; j < nBaseItemX; j++) {
                    pItem = <IItem>pState.hasChildItem(pItemListX[j]);

                    if (pItem) {
                        var pExpected: BoolMap = pItem.expectedSymbols;

                        for (k in pExpected) {
                            if (k ===  "##" ) {
                                this.addLinkExpected(pItemList[i], pItemListX[j]);
                            }
                            else {
                                pItemListX[j].addExpected(k);
                            }
                        }
                    }
                }
            }
        }

        private generateLinksExpected(): void {
            var i:  number  = 0, j: string = null;
            var pStates: IState[] = this._pStateList;

            for (i = 0; i < pStates.length; i++) {
                for (j in this._pSymbolMap) {
                    this.determineExpected(pStates[i], j);
                }
            }
        }

        private expandExpected(): void {
            var pItemList: IItem[] = <IItem[]>this._pBaseItemList;
            var pTable: BoolDMap = this._pExpectedExtensionDMap;
            var i:  number  = 0, j: string = null;
            var sSymbol: string = null;
            var isNewExpected: bool = false;

            pItemList[0].addExpected( "$" );
            pItemList[0].isNewExpected = true;

            while (true) {

                if (i === pItemList.length) {
                    if (!isNewExpected) {
                        break;
                    }
                    isNewExpected = false;
                    i = 0;
                }

                if (pItemList[i].isNewExpected) {
                    var pExpected: BoolMap = pItemList[i].expectedSymbols;

                    for (sSymbol in pExpected) {
                        for (j in pTable[i]) {
                            if (pItemList[<number><any>j].addExpected(sSymbol)) {
                                isNewExpected = true;
                            }
                        }
                    }
                }

                pItemList[i].isNewExpected = false;
                i++;
            }
        }

        private generateStates(eType: EParserType): void {
            if (eType === EParserType.k_LR0) {
                this.generateStates_LR0();
            }
            else if (eType === EParserType.k_LR1) {
                this.generateStates_LR();
            }
            else if (eType === EParserType.k_LALR) {
                this.generateStates_LALR();
            }
        }

        private generateStates_LR0(): void {
            this.generateFirstState_LR0();

            var i:  number  = 0;
            var pStateList: IState[] = this._pStateList;
            var sSymbol: string = null;
            var pState: IState;

            for (i = 0; i < pStateList.length; i++) {
                for (sSymbol in this._pSymbolMap) {
                    pState = this.nextState_LR0(pStateList[i], sSymbol);

                    if (!pState.isEmpty()) {
                        pState = this.tryAddState(pState, EParserType.k_LR0);
                        this.addStateLink(pStateList[i], pState, sSymbol);
                    }
                }
            }
        }

        private generateStates_LR(): void {
            this._pFirstTerminalsDMap = <BoolDMap>{};
            this.generateFirstState_LR();

            var i:  number  = 0;
            var pStateList: IState[] = this._pStateList;
            var sSymbol: string = null;
            var pState: IState;

            for (i = 0; i < pStateList.length; i++) {
                for (sSymbol in this._pSymbolMap) {
                    pState = this.nextState_LR(pStateList[i], sSymbol);

                    if (!pState.isEmpty()) {
                        pState = this.tryAddState(pState, EParserType.k_LR1);
                        this.addStateLink(pStateList[i], pState, sSymbol);
                    }
                }
            }
        }

        private generateStates_LALR(): void {

            this._pStatesTempMap = <IStateMap>{};
            this._pBaseItemList = <IItem[]>[];
            this._pExpectedExtensionDMap = <BoolDMap>{};
            this._pFirstTerminalsDMap = <BoolDMap>{};

            this.generateStates_LR0();
            this.deleteNotBaseItems();
            this.generateLinksExpected();
            this.expandExpected();

            var i:  number  = 0;
            var pStateList: IState[] = this._pStateList;

            for (i = 0; i < pStateList.length; i++) {
                this.closure_LR(pStateList[i]);
            }
        }

        private calcBaseItem():  number  {
            var num:  number  = 0;
            var i:  number  = 0;

            for (i = 0; i < this._pStateList.length; i++) {
                num += this._pStateList[i].numBaseItems;
            }

            return num;
        }

        private printExpectedTable(): string {
            var i: string = null, j: string = null;
            var sMsg: string = "";

            for (i in this._pExpectedExtensionDMap) {
                sMsg += "State " + this._pBaseItemList[<number><any>i].state.index + ":   ";
                sMsg += this._pBaseItemList[<number><any>i].toString() + "  |----->\n";

                for (j in this._pExpectedExtensionDMap[i]) {
                    sMsg += "\t\t\t\t\t" + "State " + this._pBaseItemList[<number><any>j].state.index + ":   ";
                    sMsg += this._pBaseItemList[<number><any>j].toString() + "\n";
                }

                sMsg += "\n";
            }

            return sMsg;
        }

        private addReducing(pState: IState): void {
            var i:  number  = 0, j: string = null;
            var pItemList: IItem[] = pState.items;

            for (i = 0; i < pItemList.length; i++) {
                if (pItemList[i].mark() ===  "END" ) {

                    if (pItemList[i].rule.left ===  "S" ) {
                        this.pushInSyntaxTable(pState.index,  "$" , this._pSuccessOperation);
                    }
                    else {
                        var pExpected = pItemList[i].expectedSymbols;

                        for (j in pExpected) {
                            this.pushInSyntaxTable(pState.index, j, this._pReduceOperationsMap[pItemList[i].rule.index]);
                        }
                    }
                }
            }
        }

        private addShift(pState: IState) {
            var i: string = null;
            var pStateMap: IStateMap = pState.nextStates;

            for (i in pStateMap) {
                this.pushInSyntaxTable(pState.index, i, this._pShiftOperationsMap[pStateMap[i].index]);
            }
        }

        private buildSyntaxTable(): void {
            this._pStateList = <IState[]>[];

            var pStateList: IState[] = this._pStateList;
            var pState: IState;

//Generate states
            this.generateStates(this._eType);

//Init necessary properties
            this._pSyntaxTable = <IOperationDMap>{};
            this._pReduceOperationsMap = <IOperationMap>{};
            this._pShiftOperationsMap = <IOperationMap>{};

            this._pSuccessOperation = <IOperation>{ type: EOperationType.k_Success };

            var i:  number  = 0, j: string = null, k: string = null;

            for (i = 0; i < pStateList.length; i++) {
                this._pShiftOperationsMap[pStateList[i].index] = <IOperation>{
                    type: EOperationType.k_Shift,
                    index: pStateList[i].index
                };
            }

            for (j in this._pRulesDMap) {
                for (k in this._pRulesDMap[j]) {
                    this._pReduceOperationsMap[k] = <IOperation>{
                        type: EOperationType.k_Reduce,
                        rule: this._pRulesDMap[j][k]
                    };
                }
            }

//Build syntax table
            for (var i = 0; i < pStateList.length; i++) {
                pState = pStateList[i];
                this.addReducing(pState);
                this.addShift(pState);
            }
        }

        private readToken(): IToken {
            return this._pLexer.getNextToken();
        }

        private operationAdditionalAction(iStateIndex: number , sGrammarSymbol: string): EOperationType {
            var pFuncDMap:IRuleFunctionDMap = this._pAdidtionalFunctByStateDMap;

            if(!isNull(this._pAdidtionalFunctByStateDMap) &&
               isDef(pFuncDMap[iStateIndex]) &&
               isDef(pFuncDMap[iStateIndex][sGrammarSymbol])){

                return pFuncDMap[iStateIndex][sGrammarSymbol].call(this);
            }

            return EOperationType.k_Ok;
        }

        private resumeParse(): EParserCode {
            try {
                var pTree:IParseTree = this._pSyntaxTree;
                var pStack: number [] = this._pStack;
                var pSyntaxTable:IOperationDMap = this._pSyntaxTable;

                var isStop:bool = false;
                var isError:bool = false;
                var isPause:bool = false;
                var pToken:IToken = isNull(this._pToken) ? this.readToken() : this._pToken;

                var pOperation:IOperation;
                var iRuleLength: number ;

                var eAdditionalOperationCode: EOperationType;
                var iStateIndex:  number  = 0;

                while (!isStop) {
                    pOperation = pSyntaxTable[pStack[pStack.length - 1]][pToken.name];
                    if (isDef(pOperation)) {
                        switch (pOperation.type) {
                            case EOperationType.k_Success:
                                isStop = true;
                                break;

                            case EOperationType.k_Shift:

                                iStateIndex = pOperation.index;
                                pStack.push(iStateIndex);
                                pTree.addNode(<IParseNode>pToken);

                                eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pToken.name);

                                if(eAdditionalOperationCode === EOperationType.k_Error){
                                    isError = true;
                                    isStop = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Pause){
                                    this._pToken = null;
                                    isStop = true;
                                    isPause = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Ok){
                                    pToken = this.readToken();
                                }

                                break;

                            case EOperationType.k_Reduce:

                                iRuleLength = pOperation.rule.right.length;
                                pStack.length -= iRuleLength;
                                iStateIndex = pSyntaxTable[pStack[pStack.length - 1]][pOperation.rule.left].index;
                                pStack.push(iStateIndex);
                                pTree.reduceByRule(pOperation.rule, this._pRuleCreationModeMap[pOperation.rule.left]);

                                eAdditionalOperationCode = this.operationAdditionalAction(iStateIndex, pOperation.rule.left);

                                if(eAdditionalOperationCode === EOperationType.k_Error){
                                    isError = true;
                                    isStop = true;
                                }
                                else if(eAdditionalOperationCode === EOperationType.k_Pause){
                                    this._pToken = pToken;
                                    isStop = true;
                                    isPause = true;
                                }

                                break;
                        }
                    }
                    else {
                        isError = true;
                        isStop = true;
                    }
                }
            }
            catch (e) {
                this._sFileName = "stdin";
                return EParserCode.k_Error;
            }
            if (isPause) {
                return EParserCode.k_Pause;
            }

            if (!isError) {
                pTree.setRoot();
                if (isDef(this._fnFinishCallback)) {
                    this._fnFinishCallback.call(this._pCaller, EParserCode.k_Ok, this.getParseFileName());
                }
                this._sFileName = "stdin";
                return EParserCode.k_Ok;
            }
            else {
                this._error( 2051 , pToken);
                if (isDef(this._fnFinishCallback)) {
                    this._fnFinishCallback.call(this._pCaller, EParserCode.k_Error, this.getParseFileName());
                }
                this._sFileName = "stdin";
                return EParserCode.k_Error;
            }
        }

        private statesToString(isBaseOnly?: bool = true): string {
            if(!isDef(this._pStateList)){
                return null;
            }

            var sMsg: string = "";
            var i:  number  = 0;

            for (i = 0; i < this._pStateList.length; i++) {
                sMsg += this._pStateList[i].toString(isBaseOnly);
                sMsg += " ";
            }

            return sMsg;
        }

        private operationToString(pOperation: IOperation): string{
            var sOperation: string = null;

            switch(pOperation.type){
                case EOperationType.k_Shift:
                    sOperation = "SHIFT to state " + pOperation.index.toString();
                    break;
                case EOperationType.k_Reduce:
                    sOperation = "REDUCE by rule { " + this.ruleToString(pOperation.rule) + " }";
                    break;
                case EOperationType.k_Success:
                    sOperation = "SUCCESS";
                    break;
            }

            return sOperation;
        }

        private ruleToString(pRule: IRule): string {
            var sRule: string;

            sRule = pRule.left + " : " + pRule.right.join(" ");

            return sRule;
        }

        private convertGrammarSymbol(sSymbol: string): string{
            if(!this.isTerminal(sSymbol)){
                return sSymbol;
            }
            else{
                return this._pLexer.getTerminalValueByName(sSymbol);
            }
        }

    }

}













module akra.util {

	export class EffectParser extends Parser {
		private _pIncludedFilesMap: BoolMap = null;

		constructor(){
			super();

			this.addAdditionalFunction("addType", this._addType);
			this.addAdditionalFunction("includeCode", this._includeCode);
		}

		/**@protected*/  defaultInit(): void {
			super.defaultInit();

			this.addTypeId("float2");
			this.addTypeId("float3");
			this.addTypeId("float4");

			this.addTypeId("float2x2");
			this.addTypeId("float3x3");
			this.addTypeId("float4x4");

			this.addTypeId("int2");
			this.addTypeId("int3");
			this.addTypeId("int4");

			this.addTypeId("bool2");
			this.addTypeId("bool3");
			this.addTypeId("bool4");

			this._pIncludedFilesMap = <BoolMap>{};
			this._pIncludedFilesMap[this.getParseFileName()] = true;
		}

		_addIncludedFile(sFileName: string): void {
			this._pIncludedFilesMap[sFileName] = true;
		}

		private _addType(): EOperationType {
			var pTree: IParseTree = this.getSyntaxTree();
			var pNode: IParseNode = pTree.getLastNode();
			var sTypeId: string;

			sTypeId = pNode.children[pNode.children.length - 2].value;

			this.addTypeId(sTypeId);

			return EOperationType.k_Ok;
		}

		private normalizeIncludePath(sFile: string): string {
			var pCurrentPath: IURI = null;
			var pFile: IURI = util.uri(sFile);


			if (!isNull(pFile.host) || util.pathinfo(pFile.path).isAbsolute()) {
//another server or absolute path
				return sFile;
			}

			pCurrentPath = util.uri(this.getParseFileName());
			pCurrentPath.path = util.pathinfo(pCurrentPath.path).dirname + "/" + sFile;

			return pCurrentPath.toString();
		}

		private _includeCode(): EOperationType {
			var pTree: IParseTree = this.getSyntaxTree();
		    var pNode: IParseNode = pTree.getLastNode();
		    var sFile: string = pNode.value;

//cuttin qoutes
		    sFile = this.normalizeIncludePath(sFile.substr(1, sFile.length - 2));

		    if (this._pIncludedFilesMap[sFile]) {
		    	return EOperationType.k_Ok;
		    }
		    else {
		    	var pParserState: IParserState = this._saveState();
		    	var me: EffectParser = this;
		    	var pFile: IFile = io.fopen(sFile, "r+t");

		    	pFile.read((err, sData: string) => {
		    		if (err) {
		    			logger.setSourceLocation( "util/EffectParser.ts" , 96 ); logger.error("Can not read file"); ;
		    		}
		    		else {
		    			pParserState.source = pParserState.source.substr(0, pParserState.index) +
		    								  sData + pParserState.source.substr(pParserState.index);

		    			me._loadState(pParserState);
		    			me._addIncludedFile(sFile);
		    			me.resume();
		    		}
		    	});

				return EOperationType.k_Pause;
		    }
		}

		_saveState(): IParserState {
			var pState: IParserState = super._saveState();
			pState["includeFiles"] = this._pIncludedFilesMap;
			return pState;
		}

		_loadState(pState: IParserState): void {
			super._loadState(pState);
			this._pIncludedFilesMap = <BoolMap>pState["includeFiles"];
		}

	}

	export var parser: EffectParser = new EffectParser();

	export function initAFXParser(sGrammar: string): void {
		parser.init(sGrammar, akra.EParseMode.k_Add |
				    akra.EParseMode.k_Negate |
					akra.EParseMode.k_Optimize |
					akra.EParseMode.k_DebugMode);
	}

}





module akra.core.pool.resources {
	export class EffectData extends ResourcePoolItem {

		private _pSyntaxTree: IParseTree = null;


		loadResource(sFileName?: string): bool {
			var reExt: RegExp  = /^(.+)(\.afx|\.abf|\.fx)$/;
    		var pRes:RegExpExecArray = reExt.exec(sFileName);

    		if(isNull(pRes)){
    			logger.setSourceLocation( "resources/EffectData.ts" , 23 ); logger.error("Bad effect file extension. Only .afx, .fx, .abf are available"); ;
    			return;
    		}

    		var isBinary: bool = pRes[pRes.length - 1] === ".abf";
    		var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();

			if(isBinary){
    			var pFile: IFile = io.fopen(sFileName, "r+b");
	    		pFile.read(function(err, pData: Uint8Array) {
					if (err){  logger.setSourceLocation( "resources/EffectData.ts" , 38 ); logger.error("Can not read file"); ; }
					else me._initFromBinaryData(pData, sFileName);
				});
			}


			var me: EffectData = this;

			io.fopen(sFileName, "r+t").read(function(pErr: Error, sData: string){
				if(!isNull(pErr)){
					logger.setSourceLocation( "resources/EffectData.ts" , 48 ); logger.error("Can not load .afx file: '" + sFileName + "'"); ;
				}
				else {

					util.parser.setParseFileName(sFileName);
					util.parser.parse(sData, me._initFromParsedEffect, me);
				}
			});

			return true;
		}


		_initFromParsedEffect(eCode: EParserCode, sFileName: string): void {
			if(eCode === EParserCode.k_Error) {
				return;
			}

			this._pSyntaxTree = util.parser.getSyntaxTree();

			var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();
			if(pComposer._loadEffectFromSyntaxTree(this._pSyntaxTree, sFileName)){
				this.notifyLoaded();
			}

		}


		_initFromBinaryData(pData: Uint8Array, sFileName: string): void {
// var pComposer: IAFXComposer = this.getManager().getEngine().getComposer();
// pComposer._loadEffectFromBinary(this._pSyntaxTree, sFileName);
		}
	}


}
















module akra {
	export interface IRenderTarget {} ;

	export interface IPixelBuffer extends IHardwareBuffer {
		 width:  number ;
		 height:  number ;
		 depth:  number ;

		 format: EPixelFormats;

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;

		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer);

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox?: IBox): bool;

		blitToMemory(pDest: IPixelBox): bool;
		blitToMemory(pSrcBox: IBox, pDest: IPixelBox): bool;

		getRenderTarget(): IRenderTarget;

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags?:  number ): any;
		lock(pLockBox: IBox, iLockFlags?:  number ): IPixelBox;

		_clearRTT(iZOffset:  number ): void;
	}
}






/*
-----------------------------------------------------------------------------
This source file is part of OGRE
    (Object-oriented Graphics Rendering Engine)
For the latest info, see http://www.ogre3d.org/

Copyright (c) 2000-2012 Torus Knot Software Ltd
-----------------------------------------------------------------------------
*/


module akra.core.pool.resources {
	export class HardwareBuffer extends ResourcePoolItem implements IHardwareBuffer {
		/**@protected*/  _iFlags:  number  = 0;

		/**@protected*/  _isLocked: bool = false;
/** Lock byte offset. */

		/**@protected*/  _iLockStart:  number ;
/** Lock byte size. */

		/**@protected*/  _iLockSize:  number ;

		/**@protected*/  _pBackupCopy: HardwareBuffer = null;
		/**@protected*/  _pBackupUpdated: bool = false;
		/**@protected*/  _bIgnoreHardwareUpdate: bool = false;

		byteLength:  number  = 0;
		length:  number  = 0;

		constructor() {
			super();
		}

		inline isValid(): bool {
			return false;
		}

		inline isDynamic(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ;
		}

		inline isStatic(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.STATIC)) != 0) ;
		}

		inline isStream(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.STREAM)) != 0) ;
		}

		inline isReadable(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ;
		}

		inline isBackupPresent(): bool {
			return this._pBackupCopy != null;
		}

		inline isSoftware(): bool {
    		return  (((this._iFlags) & (EHardwareBufferFlags.SOFTWARE)) != 0) ;
		}

		inline isAligned(): bool {
			return  (((this._iFlags) & (EHardwareBufferFlags.ALIGNMENT)) != 0) ;
		}

		inline isLocked(): bool {
			return this._isLocked;
		}

		clone(pSrc: IHardwareBuffer): bool {
			return false;
		}

		inline getFlags():  number  { return this._iFlags; }

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			return false;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;

		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {
			return false;
		}

		copyData(pSrcBuffer: IHardwareBuffer, iSrcOffset:  number , iDstOffset:  number , iSize:  number , bDiscardWholeBuffer: bool = false): bool {
			var pData: any = pSrcBuffer.lock(iSrcOffset, iSize);
			this.writeData(pData, iDstOffset, iSize, bDiscardWholeBuffer);
			pSrcBuffer.unlock();
			return true;
		}

		create(iSize:  number , iFlags:  number  = 0): bool {
			iFlags |= EHardwareBufferFlags.STATIC;

			if ( (((iFlags) & (EHardwareBufferFlags.DYNAMIC)) != 0) ) {
				((iFlags) &= ~(EHardwareBufferFlags.STATIC)) ;

				if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
					((iFlags) &= ~(EHardwareBufferFlags.READABLE)) ;
				}
			}

			this._iFlags = iFlags;

			this.notifyCreated();
			this.notifyRestored();

			return true;
		}

		destroy(): void {
			this._iFlags = 0;
			this.notifyDestroyed();
			this.notifyUnloaded();
		}

		resize(iSize:  number ): bool {
			return false;
		}

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags:  number  = EHardwareBufferFlags.READABLE): any;
		lock(iOffset:  number , iSize?: any, iLockFlags:  number  = EHardwareBufferFlags.READABLE): any {
			logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 129 ); logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!"); ;

			if (arguments.length == 1) {
				iLockFlags = < number >arguments[0];
				iOffset = 0;
				iSize = this.byteLength;
			}

			var pResult: any = null;

			if ((iOffset + iSize) > this.byteLength) {
				logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 140 ); logger.error("Lock request out of bounds.", "HardwareBuffer::lock"); ;
			}
			else if (this.isBackupPresent()) {
				if (! (((iLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// we have to assume a read / write lock so we use the shadow buffer
// and tag for sync on unlock()
                    this._pBackupUpdated = true;
                }

                pResult = this._pBackupCopy.lock(iOffset, iSize, iLockFlags);
            }
            else {
// Lock the real buffer if there is no shadow buffer 
                pResult = this.lockImpl(iOffset, iSize, iLockFlags);
                this._isLocked = true;
            }

			this._iLockStart = iOffset;
			this._iLockSize = iSize;

            return pResult;
		}

		unlock(): void {
			logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 164 ); logger.assert(this.isLocked(), "Cannot unlock this buffer, it is not locked!"); ;

// If we used the shadow buffer this time...
            if (this._pBackupCopy && this._pBackupCopy.isLocked()) {
                this._pBackupCopy.unlock();
// Potentially update the 'real' buffer from the shadow buffer
                this.restoreFromBackup();
            }
            else
            {
// Otherwise, unlock the real one
                this.unlockImpl();
                this._isLocked = false;
            }
		}

		restoreFromBackup(): bool {
			if (this._pBackupCopy && this._pBackupUpdated && !this._bIgnoreHardwareUpdate) {
// Do this manually to avoid locking problems
	            var pBackupData: any = this._pBackupCopy.lockImpl(this._iLockStart,
	            	this._iLockSize, ELockFlags.READ);
// Lock with discard if the whole buffer was locked, otherwise normal
				var iLockFlags:  number ;

				if (this._iLockStart == 0 && this._iLockSize == this.byteLength) {
					iLockFlags = ELockFlags.DISCARD;
				}
				else {
					iLockFlags = ELockFlags.NORMAL;
				}

	            var pRealData: any = this.lockImpl(this._iLockStart, this._iLockSize, iLockFlags);
// Copy backup to real
	            this.copyBackupToRealImpl(pRealData, pBackupData, iLockFlags);

	            this.unlockImpl();
	            this._pBackupCopy.unlockImpl();
	            this._pBackupUpdated = false;

	            return true;
	        }

	        return false;
		}

		createResource(): bool {
// innitialize the resource (called once)
		    logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 212 ); logger.assert(!this.isResourceCreated(), "The resource has already been created.");
                                                            ;

// signal that the resource is now created,
// but has not been enabled
//this.notifyCreated();
		    this.notifyDisabled();

		    return true;
		}

		destroyResource(): bool {
// destroy the resource
//
// we permit redundant calls to destroy, so there are no asserts here
//
		    if (this.isResourceCreated()) {
// disable the resource
		        this.disableResource();
		        this.destroy();
		        return true;
		    }

		    return false;
		}

		restoreResource(): bool {
		    logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 238 ); logger.assert(this.isResourceCreated(), "The resource has not been created."); ;

		    this.notifyRestored();
		    return true;
		}

		disableResource (): bool {
		    logger.setSourceLocation( "core/pool/resources/HardwareBuffer.ts" , 245 ); logger.assert(this.isResourceCreated(), "The resource has not been created."); ;

		    this.notifyDisabled();
		    return true;
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
			return null;
		}

		/**@protected*/  unlockImpl(): void {

		}

		/**@protected*/  copyBackupToRealImpl(pRealData: any, pBackupData: any, iLockFlags:  number ): void {

		}
	}
}









module akra.webgl {
	export class WebGLPixelBuffer extends core.pool.resources.HardwareBuffer implements IPixelBuffer {

		/**@protected*/  _iWidth:  number  = 0;
		/**@protected*/  _iHeight:  number  = 0;
		/**@protected*/  _iDepth:  number  = 0;

// Pitches (offsets between rows and slices)
		/**@protected*/  _iRowPitch:  number  = 0;
		/**@protected*/  _iSlicePitch:  number  = 0;

		/**@protected*/  _eFormat: EPixelFormats = EPixelFormats.UNKNOWN;

//webgl specific

		/**@protected*/  _pCurrentLock: IPixelBox = null;
		/**@protected*/  _pLockedBox: IBox = null;
		/**@protected*/  _iCurrentLockFlags:  number  = 0;

		/**@protected*/  _pBuffer: IPixelBox = null;
		/**@protected*/  _iWebGLInternalFormat:  number  = 0;

		inline get width():  number  { return this._iWidth; }
		inline get height():  number  { return this._iHeight; }
		inline get depth():  number  { return this._iDepth; }

		inline get format():  number  { return this._eFormat; }


		constructor () {
			super();
		}


//upload(download) data to(from) videocard.
		/**@protected*/  upload(pData: IPixelBox, pDestBox: IBox): void {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 46 ); logger.criticalError("Upload not possible for this pixelbuffer type"); ;
		}

		/**@protected*/  download(pData: IPixelBox): void {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 50 ); logger.criticalError("Download not possible for this pixelbuffer type"); ;
		}

		_bindToFramebuffer(pAttachment:  number , iZOffset:  number ): void {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 54 ); logger.criticalError("Framebuffer bind not possible for this pixelbuffer type"); ;
		}

		_getWebGLFormat():  number  {
			return this._iWebGLInternalFormat;
		}

		_clearRTT(iZOffset:  number ): void {
		}

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(): bool {
			if(arguments.length === 1) {
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 68 ); logger.criticalError("Invalid number of arguments. For PixelBuffer it must be six"); ;
			}
			var iWidth:  number  = arguments[0];
			var iHeight:  number  = arguments[1];
			var iDepth:  number  = arguments[2];
			var eFormat:  number  = arguments[3];
			var iFlags:  number  = arguments[4];

 			super.create(iFlags);

			this._iWidth = iWidth;
			this._iHeight = iHeight;
			this._iDepth = iDepth;
			this._eFormat = eFormat;

			this._iRowPitch = iWidth;
			this._iSlicePitch = iHeight * iWidth;
			this.byteLength = iHeight * iWidth * akra.pixelUtil.getNumElemBytes(eFormat);

			this._pBuffer = new pixelUtil.PixelBox(iWidth, iHeight, iDepth, eFormat);
			this._iWebGLInternalFormat =  0 ;

			return true;
		}

		destroy(): void {
			this._pBuffer = null;

			super.destroy();
		}

		destroyResource(): bool {
			this.destroy();
			this.notifyDestroyed();
			return true;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(): bool {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 108 ); logger.criticalError("Reading a byte range is not implemented. Use blitToMemory."); ;
			return false;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
		writeData(pData: ArrayBuffer, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool): bool;
		writeData(): bool {
			logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 115 ); logger.criticalError("Writing a byte range is not implemented. Use blitFromMemory."); ;
			return false;
		}


//=====

		blit(pSource: IPixelBuffer): bool;
		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer, pSrcBox?: IBox, pDestBox?: IBox): bool {
			if (arguments.length == 1) {
				return this.blit(pSource,
		            new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth),
		            new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth)
		        );
			}
			else {
				if(pSource === <IPixelBuffer>this) {
					logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 133 ); logger.criticalError("Source must not be the same object");  ;
				}

				/**@const*/var  pSrclock: IPixelBox = pSource.lock(pSrcBox, ELockFlags.READ);

				var eLockMethod: ELockFlags = ELockFlags.NORMAL;
				if (pDestBox.left === 0 && pDestBox.top === 0 && pDestBox.front === 0 &&
				    pDestBox.right === this._iWidth && pDestBox.bottom === this._iHeight &&
				    pDestBox.back === this._iDepth) {
// Entire buffer -- we can discard the previous contents
					eLockMethod = ELockFlags.DISCARD;
				}

				/**@const*/var  pDstlock: IPixelBox = this.lock(pDestBox, eLockMethod);

				if (pDstlock.width != pSrclock.width ||
		            pDstlock.height != pSrclock.height ||
		            pDstlock.depth != pSrclock.depth) {
// Scaling desired
					pSrclock.scale(pDstlock);
				}
				else {
// No scaling needed
					akra.pixelUtil.bulkPixelConversion(pSrclock, pDstlock);
				}

				this.unlock();
				pSource.unlock();

				return true;
			}
		}

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox: IBox): bool;
		blitFromMemory(): bool {
			var pSource: IPixelBox;
			var pDestBox: IBox;

			pSource = arguments[0];

			if(arguments.length === 1) {
				pDestBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
				return this.blitFromMemory(pSource, pDestBox);
			}
			else{
				pDestBox = arguments[1];
			}

			if (!this._pBuffer.contains(pDestBox)) {
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 183 ); logger.criticalError("Destination box out of range"); ;
	        }

	        var pScaledBox: IPixelBox;

	        if (pSource.width != pDestBox.width ||
	            pSource.height != pDestBox.height ||
	            pSource.depth != pDestBox.depth) {
// Scale to destination size.
// This also does pixel format conversion if needed
	            this.allocateBuffer();
	            pScaledBox = this._pBuffer.getSubBox(pDestBox);
	            pSource.scale(pScaledBox, EFilters.BILINEAR);
	        }
	        else if ((pSource.format != this._eFormat) ||
	                 ((getWebGLFormat(pSource.format) == 0) && (pSource.format != EPixelFormats.R8G8B8))) {
// Extents match, but format is not accepted as valid source format for GL
// do conversion in temporary buffer
	            this.allocateBuffer();
	            pScaledBox = this._pBuffer.getSubBox(pDestBox);

	            pixelUtil.bulkPixelConversion(pSource, pScaledBox);

	            if(this._eFormat === EPixelFormats.A4R4G4B4)
	            {
// ARGB->BGRA
	                convertToWebGLformat(pScaledBox, pScaledBox);
	            }
	        }
	        else {
	            this.allocateBuffer();
	            pScaledBox = pSource;

	            if (pSource.format == EPixelFormats.R8G8B8)
	            {
	                pScaledBox.format = EPixelFormats.B8G8R8;

	                pixelUtil.bulkPixelConversion(pSource, pScaledBox);
	            }
	        }

	        this.upload(pScaledBox, pDestBox);
	        this.freeBuffer();

			return true;
		}

		blitToMemory(pDest: IPixelBox): bool;
		blitToMemory(pSrcBox: IBox, pDest: IPixelBox): bool;
		blitToMemory(): bool {
			var pSrcBox: IBox;
			var pDest: IPixelBox;

			if(arguments.length === 1){
				pDest = arguments[0];
				pSrcBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
				return this.blitToMemory(pSrcBox, pDest);
			}
			else{
				pSrcBox = arguments[0];
				pDest = arguments[1];
			}

			if (!this._pBuffer.contains(pSrcBox)) {
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 247 ); logger.criticalError("source box out of range"); ;
	        }

	        if (pSrcBox.left == 0 && pSrcBox.right == this._iWidth &&
            	pSrcBox.top == 0 && pSrcBox.bottom == this._iHeight &&
            	pSrcBox.front == 0 && pSrcBox.back == this._iDepth &&
            	pDest.width == this._iWidth &&
            	pDest.height == this._iHeight &&
            	pDest.depth == this._iDepth &&
            	getWebGLFormat(pDest.format) != 0) {
// The direct case: the user wants the entire texture in a format supported by GL
// so we don't need an intermediate buffer
	            this.download(pDest);
	        }
	        else {
// Use buffer for intermediate copy
	            this.allocateBuffer();
// Download entire buffer
	            this.download(this._pBuffer);

	            if(pSrcBox.width != pDest.width ||
	               pSrcBox.height != pDest.height ||
	               pSrcBox.depth != pDest.depth) {
// We need scaling
	                this._pBuffer.getSubBox(pSrcBox).scale(pDest, EFilters.BILINEAR);
	            }
	            else {
// Just copy the bit that we need
	                pixelUtil.bulkPixelConversion(this._pBuffer.getSubBox(pSrcBox), pDest);
	            }
	            this.freeBuffer();
	        }

			return true;
		}

		getRenderTarget(): IRenderTarget {
			return null;
		}

		lock(iLockFlags:  number ): any;
		lock(iOffset:  number , iSize:  number , iLockFlags:  number  = EHardwareBufferFlags.READABLE): any;
		lock(pLockBox: IBox, iLockFlags:  number  = EHardwareBufferFlags.READABLE): IPixelBox;
		lock(): any {
			var pLockBox: IBox = null;
			var iLockFlags:  number  = 0;

			if(isInt(arguments[0])){
				var iOffset:  number ;
				var iSize:  number ;

				if(arguments.length === 1){
					iLockFlags === arguments[0];
					iOffset = 0;
					iSize = this.byteLength;
				}
				else {
					iOffset = arguments[0];
					iSize = arguments[1];
					iLockFlags = (arguments.length === 3) ? arguments[2] : EHardwareBufferFlags.READABLE;
				}

				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 310 ); logger.assert(!this.isLocked(), "Cannot lock this buffer, it is already locked!");
                                                         ;
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 312 ); logger.assert(iOffset === 0 && iSize === this.byteLength, "Cannot lock memory region, most lock box or entire buffer");
                                                                   ;

				pLockBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
			}

			if(this.isBackupPresent()){
				if (! (((iLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// we have to assume a read / write lock so we use the shadow buffer
// and tag for sync on unlock()
                    this._pBackupUpdated = true;
                }

                this._pCurrentLock = (<WebGLPixelBuffer>(this._pBackupCopy)).lock(pLockBox, iLockFlags);
			}
			else {
				this._pCurrentLock = this.lockImpl(pLockBox, iLockFlags);
				this._isLocked = true;
			}

			return this._pCurrentLock;
		}

		/**@protected*/  allocateBuffer(): void {
			if(!isNull(this._pBuffer.data)){
				return;
			}

			this._pBuffer.data = new Uint8Array(this.byteLength);
		}

		/**@protected*/  freeBuffer(): void {
			if( (((this._iFlags) & (EHardwareBufferFlags.STATIC)) != 0) ){
				this._pBuffer.data = null;
			}
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any;
		/**@protected*/  lockImpl(pLockBox: IBox, iLockFlags:  number ): IPixelBox;
		/**@protected*/  lockImpl(): any {
			if(arguments.length === 3){
				logger.setSourceLocation( "webgl/WebGLPixelBuffer.ts" , 352 ); logger.criticalError("lockImpl(offset,length) is not valid for PixelBuffers and should never be called"); ;
			}

			var pLockBox:IBox = arguments[0];
			var iLockFlags:  number  = arguments[1];

			this.allocateBuffer();

			if(! (((iLockFlags) & (ELockFlags.DISCARD)) != 0)  &&
			   (((this._iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ){

			   	this.download(this._pBuffer);
			}

			this._iCurrentLockFlags = iLockFlags;
			this._pLockedBox = pLockBox;

			return this._pBuffer.getSubBox(pLockBox);
		}

		/**@protected*/  unlockImpl(): void {
			if ( (((this._iCurrentLockFlags) & (ELockFlags.WRITE)) != 0) ) {
// From buffer to card, only upload if was locked for writing
	            this.upload(this._pCurrentLock, this._pLockedBox);
	        }

	        this.freeBuffer();
		}





	}
}






















module akra {
	export interface IHardwareObject {} ;

    export interface IRenderResource extends IResourcePoolItem {
//getHardwareObject(): IHardwareObject;
    };
}













module akra {

    export interface IImg {} ;

    export enum ETextureFlags {
        STATIC = < number >EHardwareBufferFlags.STATIC,
        DYNAMIC = < number >EHardwareBufferFlags.DYNAMIC,
        READEBLE = < number >EHardwareBufferFlags.READABLE,
        DYNAMIC_DISCARDABLE = < number >EHardwareBufferFlags.DYNAMIC_DISCARDABLE,
/// mipmaps will be automatically generated for this texture
        AUTOMIPMAP = 0x100,
/// this texture will be a render target, i.e. used as a target for render to texture
/// setting this flag will ignore all other texture usages except AUTOMIPMAP
        RENDERTARGET = 0x200,
/// default to automatic mipmap generation static textures
        DEFAULT = STATIC
    }

    export enum ETextureFilters {
        NEAREST = 0x2600,
        LINEAR = 0x2601,
        NEAREST_MIPMAP_NEAREST = 0x2700,
        LINEAR_MIPMAP_NEAREST = 0x2701,
        NEAREST_MIPMAP_LINEAR = 0x2702,
        LINEAR_MIPMAP_LINEAR = 0x2703
    };

    export enum ETextureWrapModes {
        REPEAT = 0x2901,
        CLAMP_TO_EDGE = 0x812F,
        MIRRORED_REPEAT = 0x8370
    };

    export enum ETextureParameters {
        MAG_FILTER = 0x2800,
        MIN_FILTER,
        WRAP_S,
        WRAP_T
    };

    export enum ETextureTypes {
        TEXTURE_2D = 0x0DE1,
        TEXTURE_CUBE_MAP = 0x8513,
    };

    export enum ECubeFace{
        POSITIVE_X = 0,
        NEGATIVE_X = 1,
        POSITIVE_Y = 2,
        NEGATIVE_Y = 3,
        POSITIVE_Z = 4,
        NEGATIVE_Z = 5,
        };

    export enum ETextureCubeFlags{
        POSITIVE_X = 0x00000001,
        NEGATIVE_X = 0x00000002,
        POSITIVE_Y = 0x00000004,
        NEGATIVE_Y = 0x00000008,
        POSITIVE_Z = 0x0000000c,
        NEGATIVE_Z = 0x000000010,
        };

    export enum ETextureUnits {
        TEXTURE0 = 0x84C0
    };

// export interface ITextureParameters {
//     minFilter: ETextureFilters;
//     magFilter: ETextureFilters;

//     wrapS: ETextureWrapModes;
//     wrapT: ETextureWrapModes;
// }

    export interface ITexture extends IRenderResource {
    	width:  number ;
        height:  number ;
        depth:  number ;

        format: EPixelFormats;
        mipLevels:  number ;

        textureType: ETextureTypes;

//desiredIntegerBitDepth: uint;
//desiredFloatBitDepth: uint;     

//readonly desiredFormat: EPixelFormats;
//readonly srcFormat: EPixelFormats;
//readonly srcWidth: uint;
//readonly srcHeight: uint;
//readonly srcDepth: uint;

        setFlags(iTextureFlag:  number ): void;
        getFlags():  number ;

        calculateSize():  number ;
        getNumFaces():  number ;
        getSize():  number ;

        isTexture2D(): bool;
        isTextureCube(): bool;
        isCompressed(): bool;
        isValid(): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , cFillColor?: IColor,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: Array,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: ArrayBufferView,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        getBuffer(iFace?:  number , iMipmap?:  number ): IPixelBuffer;

        setFilter(eParam: ETextureParameters, eValue: ETextureFilters): bool;
        setWrapMode(eParam: ETextureParameters, eValue: ETextureWrapModes): bool;
        getFilter(eParam: ETextureParameters): ETextureFilters;
        getWrapMode(eParam: ETextureParameters): ETextureWrapModes;

        loadRawData(pData: ArrayBufferView, iWidth:  number , iHeight:  number , eFormat: EPixelFormats): bool;
        loadImage(pImage: IImg): bool;
        loadImages(pImages: IImg[]): bool;

        convertToImage(pDestImage: IImg, bIncludeMipMaps: bool): void;

        copyToTexture(pTarget: ITexture): void;

        createInternalTexture(cFillColor?: IColor): bool;
        freeInternalTexture(): bool;

    }
}











module akra.core.pool.resources {

    export enum ETextureForcedFormatFlags {
        FORCEMIPLEVELS = 0,
        FORCEFORMAT,
        FORCESIZE
    }

	export class Texture extends ResourcePoolItem implements ITexture {
        /**@protected*/  _iFlags:  number  = ETextureFlags.DEFAULT;

        /**@protected*/  _iWidth:  number  = 512;
        /**@protected*/  _iHeight:  number  = 512;
        /**@protected*/  _iDepth:  number  = 1;

        /**@protected*/  _eFormat: EPixelFormats = EPixelFormats.UNKNOWN;

        /**@protected*/  _nMipLevels:  number  = 0;
        /**@protected*/  _nRequestedMipLevels:  number  = 0;

        /**@protected*/  _eTextureType: ETextureTypes = ETextureTypes.TEXTURE_2D;

        /**@protected*/  _pParams: IntMap = <IntMap>{};

        /**@protected*/  _isInternalResourceCreated: bool = false;
        /**@protected*/  _isMipmapsHardwareGenerated: bool = false;

        constructor () {
            super();
        }

		inline get width():  number  {
			return this._iWidth;
		}

//inline set width(iWidth: uint) {
//    this._iWidth = this._iSrcWidth = iWidth;
//}

        inline get height():  number  {
        	return this._iHeight;
        }

//inline set height(iHeight: uint) {
//    this._iHeight = this._iSrcHeight = iHeight;
//}

        inline get depth():  number  {
            return this._iDepth;
        }

//inline set depth(iDepth: uint) {
//    this._iDepth = this._iSrcDepth = iDepth;
//}

        inline get format(): EPixelFormats {
        	return this._eFormat;
        }

//inline set format(eFormat: EPixelFormats) {
//    this._eFormat = eFormat;
//    this._eDesiredFormat = eFormat;
//    this._eSrcFormat = eFormat;
//}

        inline get textureType(): ETextureTypes {
            return this._eTextureType;
        }

//inline set textureType(eTextureType: ETextureTypes) {
//    this._eTextureType = eTextureType;
//}

        inline get mipLevels():  number  {
            return this._nMipLevels;
        }

//inline set mipLevels(nMipLevels: uint) {
//    this._nMipLevels = nMipLevels;
//}

/*inline get desiredIntegerBitDepth(): uint {
            return this._iDesiredIntegerBitDepth;
        }

        inline set desiredIntegerBitDepth(iDesiredIntegerBitDepth: uint) {
            this._iDesiredIntegerBitDepth = iDesiredIntegerBitDepth;
        }

        inline get desiredFloatBitDepth(): uint {
            return this._iDesiredFloatBitDepth;
        }

        inline set desiredFloatBitDepth(iDesiredFloatBitDepth: uint) {
            this._iDesiredFloatBitDepth = iDesiredFloatBitDepth;
        }*/


        inline getFlags():  number  {
            return this._iFlags;
        }

        inline setFlags(iFlags: ETextureFlags): void {
            this._iFlags = iFlags;
        }

        inline isTexture2D(): bool {
        	return this._eTextureType === ETextureTypes.TEXTURE_2D;
        }

        inline isTextureCube(): bool {
        	return this._eTextureType === ETextureTypes.TEXTURE_CUBE_MAP;
        }

        inline isCompressed(): bool {
        	return (this._eFormat >= EPixelFormats.DXT1 && this._eFormat <= EPixelFormats.DXT5) ||
                (this._eFormat >= EPixelFormats.PVRTC_RGB2 && this._eFormat <= EPixelFormats.PVRTC_RGBA4);
        }

        inline isValid(): bool {
            return isDefAndNotNull(this._isInternalResourceCreated);
        }

        inline calculateSize():  number  {
            return this.getNumFaces() * pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
        }

        inline getNumFaces():  number  {
            return this._eTextureType === ETextureTypes.TEXTURE_CUBE_MAP ? 6 : 1;
        }

        inline getSize():  number  {
            return this.getNumFaces() * pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);
        }

        getBuffer(iFace?:  number , iMipmap?:  number ): IPixelBuffer {
            return null;
        }

        create(iWidth:  number , iHeight:  number , iDepth:  number , cFillColor?: IColor,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: Array,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth:  number , pPixels?: ArrayBufferView,
               eFlags?: ETextureFlags, nMipLevels?:  number , nFaces?:  number , eTextureType?: ETextureTypes, eFormat?: EPixelFormats): bool;

        create(iWidth:  number , iHeight:  number , iDepth?:  number  = 1, pPixels?: any = null,
               eFlags?: ETextureFlags = ETextureFlags.DEFAULT, nMipLevels?:  number  = 0, nFaces?:  number  = 0,
               eTextureType?: ETextureTypes = ETextureTypes.TEXTURE_2D,
               eFormat?: EPixelFormats = EPixelFormats.B8G8R8): bool {


            if(eTextureType!=ETextureTypes.TEXTURE_2D && eTextureType!=ETextureTypes.TEXTURE_CUBE_MAP)
            {
                logger.setSourceLocation( "core/pool/resources/Texture.ts" , 165 ); logger.criticalError("Заданный тип текстуры не поддреживается"); ;
                return false;
            }

            this.textureType=eTextureType;

            this._iWidth = iWidth;
            this._iHeight = iHeight;
            this._iDepth = iDepth;

            this._iFlags = eFlags;
            this._nMipLevels = nMipLevels;

            this._eFormat = eFormat;

            if(isArray(pPixels))
            {
                pPixels = new Uint8Array(pPixels);
                return this.loadRawData(pPixels, iWidth, iHeight,iDepth,eFormat,nFaces,nMipLevels);
            }
            else if(isTypedArray(pPixels))
            {
                return this.loadRawData(pPixels, iWidth, iHeight,iDepth,eFormat,nFaces,nMipLevels);
            }
            else
            {
                return this.createInternalTexture(pPixels);
            }
        }

        destroyResource(): bool {
            this.freeInternalTexture();
            this.notifyDestroyed();
            return true;
        }

        setFilter(eParam: ETextureParameters, eValue: ETextureFilters): bool
        {
            if (!this.isValid()) {
                return false;
            }

            this._pParams[eParam] = eValue;
            return this._setFilterInternalTexture(eParam,eValue);
        }

        setWrapMode(eParam: ETextureParameters, eValue: ETextureWrapModes): bool
        {
            if (!this.isValid()) {
                return false;
            }

            this._pParams[eParam] = eValue;
            return this._setWrapModeInternalTexture(eParam,eValue);
        }

        getFilter(eParam: ETextureParameters): ETextureFilters
        {
            if (!this.isValid()) {
                return 0;
            }
            var iValue:any=this._pParams[eParam];
            if(!isDefAndNotNull(iValue))
            {
                iValue=this._getFilterInternalTexture(eParam);
                this._pParams[eParam]=iValue;
            }
            return iValue;
        }

        getWrapMode(eParam: ETextureParameters): ETextureWrapModes
        {
            if (!this.isValid()) {
                return 0;
            }
            var iValue:any=this._pParams[eParam];
            if(!isDefAndNotNull(iValue))
            {
                iValue=this._getWrapModeInternalTexture(eParam);
                this._pParams[eParam]=iValue;
            }
            return iValue;
        }

        /**@protected*/  _setFilterInternalTexture(eParam: ETextureParameters, eValue: ETextureFilters): bool{
            logger.setSourceLocation( "core/pool/resources/Texture.ts" , 250 ); logger.criticalError("virual"); ;
            return false;
        }
        /**@protected*/  _setWrapModeInternalTexture(eParam: ETextureParameters, eValue: ETextureWrapModes): bool{
            logger.setSourceLocation( "core/pool/resources/Texture.ts" , 254 ); logger.criticalError("virual"); ;
            return false;
        }

        /**@protected*/  _getFilterInternalTexture(eParam: ETextureParameters): ETextureFilters{
            logger.setSourceLocation( "core/pool/resources/Texture.ts" , 259 ); logger.criticalError("virual"); ;
            return 0;
        }
        /**@protected*/  _getWrapModeInternalTexture(eParam: ETextureParameters): ETextureWrapModes{
            logger.setSourceLocation( "core/pool/resources/Texture.ts" , 263 ); logger.criticalError("virual"); ;
            return 0;
        }


        loadRawData(pData: Uint8Array, iWidth:  number , iHeight:  number , iDepth:  number  = 1, eFormat: EPixelFormats = EPixelFormats.BYTE_BGR,
                         nFaces?:  number  = 1, nMipMaps?:  number  = 0)
        {
            var pTempImg: IImg = <IImg>this.getManager().imagePool.findResource(".texture.temp_image");

            if(isNull(pTempImg)){
                pTempImg = <IImg>this.getManager().imagePool.createResource(".texture.temp_image");
            }

            pTempImg.loadRawData(pData, iWidth, iHeight,iDepth,eFormat,nFaces,nMipMaps);
            var isLoaded: bool = this.loadImage(pTempImg);
            this.getManager().imagePool.destroyResource(pTempImg);

            return isLoaded;
        }

        loadImage(pImage: IImg): bool
        {
            var isLoaded:bool = this._loadImages(pImage);

            if(isLoaded)
            {
                this.notifyLoaded();
                return true;
            }
            else {
                return false;
            }
        }

        loadImages(pImages: IImg[]): bool
        {
            var isLoaded:bool = this._loadImages(pImages);

            if(isLoaded) {
                this.notifyLoaded();
                return true;
            }
            else{
                return false;
            }
        }

        _loadImages(pImageList: IImg[]): bool;
        _loadImages(pImage: IImg): bool;

        _loadImages(pImage:any): bool
        {




            if(this.isResourceLoaded()){
                logger.setSourceLocation( "core/pool/resources/Texture.ts" , 321 ); logger.warning("Yoy try to load texture when it already have been loaded. All texture data was destoyed."); ;
                this.freeInternalTexture();
            }

            var pMainImage: IImg = null;
            var pImageList: IImg[] = null;

            if(!isArray(pImage))
            {
                pMainImage = pImage;
                pImageList = new Array(0);
                pImageList[0]=pMainImage;
            }
            else
            {
                pImageList = arguments[0];
                if(pImageList.length === 0) {
                    logger.setSourceLocation( "core/pool/resources/Texture.ts" , 338 ); logger.criticalError("Cannot load empty list of images"); ;
                    return false;
                }
                pMainImage = pImageList[0];
            }



            this._iWidth = pMainImage.width;
            this._iHeight = pMainImage.height;
            this._iDepth = pMainImage.depth;

// Get source image format and adjust if required

            if(webgl.isWebGLFormatSupport(pMainImage.format))
            {
                this._eFormat = pMainImage.format;
            }
            else
            {
                logger.setSourceLocation( "core/pool/resources/Texture.ts" , 358 ); logger.warning("Format not support("+pixelUtil.getFormatName(pMainImage.format)+")"); ;
                if(pMainImage.convert(EPixelFormats.B8G8R8A8))
                {
                    this._eFormat = pMainImage.format;
                }
                else
                {
                    logger.setSourceLocation( "core/pool/resources/Texture.ts" , 365 ); logger.criticalError("Format not convert"); ;
                }
            }

            for(i=1;i<pImageList.length;i++)
            {
                if(!pImageList[i].convert(pMainImage.format))
                {
                    logger.setSourceLocation( "core/pool/resources/Texture.ts" , 373 ); logger.criticalError("Format not support and not convert"); ;
                }
            }


// The custom mipmaps in the image have priority over everything
            var iImageMips:  number  = pMainImage.numMipMaps;

            if(iImageMips==Img.getMaxMipmaps(this._iWidth,this._iHeight,this._iDepth,this._eFormat)) {
                this._nMipLevels=iImageMips;

// Disable flag for auto mip generation
                ((this._iFlags) &= ~(ETextureFlags.AUTOMIPMAP)) ;
            }
            else
            {
                this._nMipLevels=0;
            }

// Create the texture
            this.createInternalTexture(null);


// Check if we're loading one image with multiple faces
// or a vector of images representing the faces
            var iFaces:  number  = 0;
            var isMultiImage:bool =false;

            if(pImageList.length == 6)
            {
                iFaces = 6;
                isMultiImage = true;
            }
            else if(pMainImage.numFaces==6)
            {
                iFaces = 6;
                isMultiImage = false;
            }
            else
            {
                iFaces = 1;
                isMultiImage = false;
            }

// Check wether number of faces in images exceeds number of faces
// in this texture. If so, clamp it.
            if(iFaces > this.getNumFaces())
            {
                iFaces = this.getNumFaces();
            }

// Main loading loop
// imageMips == 0 if the image has no custom mipmaps, otherwise contains the number of custom mips

            var mip:  number  = 0;
            var i:  number  = 0;
            for(mip = 0; mip <= this._nMipLevels; ++mip) {
                for(i = 0; i < iFaces; ++i) {
                    var pSrc: IPixelBox;

                    if(isMultiImage){
// Load from multiple images
                        pSrc = pImageList[i].getPixels(0, mip);
//console.log(mip,i);
                    }
                    else {
// Load from faces of images[0] or main Image
//console.log(mip,i);
                        pSrc = pMainImage.getPixels(i, mip);
                    }

// Destination: entire texture. blitFromMemory does the scaling to
// a power of two for us when needed
//console.log(pSrc);
//console.log(this.getBuffer(i, mip));


                    this.getBuffer(i, mip).blitFromMemory(pSrc);
                }
            }

            return true;
        }

        convertToImage(pDestImage: IImg, bIncludeMipMaps: bool): void
        {
            logger.setSourceLocation( "core/pool/resources/Texture.ts" , 459 ); logger.criticalError("!!!нехуй");
            var iNumMips:  number  = bIncludeMipMaps ? this._nMipLevels + 1 : 1;
            var iDataSize:  number  = pixelUtil.calculateSizeForImage(iNumMips, this._nMipLevels,
                                                                  this._iWidth, this._iHeight, this._iDepth,
                                                                  this._eFormat);

            var pPixData: Uint8Array = new Uint8Array(iDataSize);
// if there are multiple faces and mipmaps we must pack them into the data
// faces, then mips
            var pCurrentPixData: Uint8Array = pPixData;

            var iFace:  number  = 0;
            var mip:  number  = 0;

            for (iFace = 0; iFace < this.getNumFaces(); ++iFace) {
                for (mip = 0; mip < iNumMips; ++mip) {

                    var iMipDataSize = pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

                    var pPixBox: IPixelBox = new pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat, pCurrentPixData);
                    this.getBuffer(iFace, mip).blitToMemory(pPixBox);

                    pCurrentPixData = pCurrentPixData.subarray(iMipDataSize);

                }
            }

// load, and tell Image to delete the memory when it's done.
            pDestImage.loadDynamicImage(pPixData, this._iWidth, this._iHeight, this._iDepth, this._eFormat,
                this.getNumFaces(), iNumMips - 1);
        }

        copyToTexture(pTarget: ITexture): void {
            logger.setSourceLocation( "core/pool/resources/Texture.ts" , 492 ); logger.criticalError("!!!нехуй");
            if(pTarget.getNumFaces() !== this.getNumFaces()){
                logger.setSourceLocation( "core/pool/resources/Texture.ts" , 494 ); logger.criticalError("Texture types must match"); ;
            }

            var nMipLevels:  number  = Math.min(this._nMipLevels, pTarget.mipLevels);
            if( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0)  ||  (((this.getFlags()) & (ETextureFlags.AUTOMIPMAP)) != 0) ){
                nMipLevels = 0;
            }

            var iFace:  number  = 0, mip:  number  = 0;

            for(iFace = 0; iFace < this.getNumFaces(); iFace++){
                for(mip = 0; mip <= nMipLevels; mip++){
                    pTarget.getBuffer(iFace, mip).blit(this.getBuffer(iFace, mip));
                }
            }
        }

        createInternalTexture(cFillColor?: IColor = null): bool
        {

            if(!this._isInternalResourceCreated)
            {

                this._createInternalTextureImpl(cFillColor);
                this._isInternalResourceCreated = true;
                this.notifyCreated();
                return true;
            }

        	return false;
        }

        freeInternalTexture(): bool {
            if(this._isInternalResourceCreated){
                this.freeInternalTextureImpl();
                this._isInternalResourceCreated = false;
                this.notifyDestroyed();
                return true;
            }

            return false;
        }

        /**@protected*/  _createInternalTextureImpl(cFillColor?: IColor = null): bool {
            return false;
        }

        /**@protected*/  freeInternalTextureImpl(): bool {
            return false;
        }

        setPixelRGBA(i1:  number , i2:  number , iTextureWidth:  number , iTextureHeight:  number , pBuffer: Uint8Array): void {
            return;
        }
	}

}






























module akra {
	export interface IDepthBuffer extends IRenderResource {
		bitDepth:  number ;
		width:  number ;
		height:  number ;

		create(iBitDepth:  number , iWidth:  number , iHeight:  number , bManual: bool): void;

		isManual(): bool;
		isCompatible(pTarget: IRenderTarget): bool;

		_notifyRenderTargetAttached(pTarget: IRenderTarget): void;
		_notifyRenderTargetDetached(pTarget: IRenderTarget): void;
	}
}






module akra {
	export interface IFPSStat {
		last:  number ;
		avg:  number ;
		best:  number ;
		worst:  number ;
	};

	export interface ITimeStat {
		best:  number ;
		worst:  number ;
	};

	export interface IFrameStats {
		fps: IFPSStat;
		time: ITimeStat;
		polygonsCount:  number ;
	}
}













module akra {
    export interface IRect3d {} ;
	export interface IRenderableObject {} ;

    export interface ISceneObject extends ISceneNode {
    	worldBounds: IRect3d;
    	totalRenderable:  number ;
        hasShadows: bool;

    	 localBounds: IRect3d;

        getRenderable(i?:  number ): IRenderableObject;
    	getObjectFlags():  number ;

    	accessLocalBounds(): IRect3d;
    	isWorldBoundsNew(): bool;
// recalcWorldBounds(): void;

         worldBoundsUpdated(): void;
    }
}



module akra {
	export interface IViewport {} ;
	export interface IVec3 {} ;
	export interface IMat4 {} ;
	export interface IRect3d {} ;
	export interface IFrustum {} ;
    export interface ISceneBuilder {} ;
    export interface IObjectArray {} ;

	export enum ECameraParameters {
        CONST_ASPECT = 1
	}

    export enum ECameraTypes {
        PERSPECTIVE,
        ORTHO,
        OFFSET_ORTHO
    }



    export interface ICamera extends ISceneNode {
    	 viewMatrix: IMat4;
    	 projectionMatrix: IMat4;
    	 projViewMatrix: IMat4;
    	 internalProjectionMatrix: IMat4;
    	 internalViewProjMatrix: IMat4;
    	 targetPos: IVec3;

        fov:  number ;
    	aspect:  number ;
    	nearPlane:  number ;
    	farPlane:  number ;

    	 viewDistance:  number ;
    	 searchRect: IRect3d;
    	 frustum: IFrustum;

    	setParameter(eParam: ECameraParameters, pValue: any): void;
    	isConstantAspect(): bool;

    	setProjParams(fFOV:  number , fAspect:  number , fNearPlane:  number , fFarPlane:  number ): void;
    	setOrthoParams(fWidth:  number , fHeight:  number , fNearPlane:  number , fFarPlane:  number ): void;
    	setOffsetOrthoParams(fMinX:  number , fMaxX:  number , fMinY:  number , fMaxY:  number , fNearPlane:  number , fFarPlane:  number ): void;

//moved to private.
// recalcMatrices(): void;

    	applyRenderStageBias(iStage:  number ): void;

    	lookAt(v3fFrom: IVec3, v3fCenter: IVec3, v3fUp?: IVec3);
    	lookAt(v3fCenter: IVec3, v3fUp?: IVec3);

//display via display list with name <csList>
        display(iList?:  number ): IObjectArray;

    	_renderScene(pViewport: IViewport): void;
    	_keepLastViewport(pViewport: IViewport): void;
    	_getLastViewport(): IViewport;
    	_getNumRenderedFaces():  number ;
        _notifyRenderedFaces(nFaces:  number ): void;
    }
}





module akra {
	export enum EFramebuffer {
		FRONT,
		BACK,
		AUTO
	};

	export enum EStatFlags {
		NONE           = 0,
        FPS            = 1,
        AVG_FPS        = 2,
        BEST_FPS       = 4,
        WORST_FPS      = 8,
        TRIANGLE_COUNT = 16,
        ALL            = 0xFFFF
	};

	export interface IRenderTarget extends IEventProvider {
		name: string;
		width:  number ;
		height:  number ;


		colorDepth:  number ;

		totalViewports:  number ;

		priority:  number ;

		getRenderer(): IRenderer;

		getDepthBuffer(): IDepthBuffer;

		attachDepthBuffer(pBuffer: IDepthBuffer): bool;
		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool;
		attachDepthTexture(pTexture: ITexture): bool;

		detachDepthBuffer(): void;
		detachDepthTexture(): void;
		detachDepthPixelBuffer(): void;

		destroy(): void;

		update(): void;
		updateStats(): void;

		getCustomAttribute(sName: string): any;

		addViewport(pCamera: ICamera, csRenderMethod?: string, iZIndex?:  number , fLeft?:  number , fTop?:  number , fWidth?:  number , fHeight?:  number ): IViewport;
		addViewport(pCamera: ICamera, eType?:  number , iZIndex?:  number , fLeft?:  number , fTop?:  number , fWidth?:  number , fHeight?:  number ): IViewport;

		getViewport(iIndex:  number ): IViewport;
		getViewportByZIndex(iZIndex:  number ): IViewport;
		hasViewportByZIndex(iZIndex:  number ): bool;
		removeViewport(iZIndex:  number ): bool;
		removeAllViewports():  number ;

		getPolygonCount():  number ;

		getStatistics(): IFrameStats;
		getLastFPS():  number ;
		getAverageFPS():  number ;
		getBestFPS():  number ;
		getWorstFPS():  number ;

		getBestFrameTime():  number ;
		getWorstFrameTime():  number ;
		resetStatistics(): void;

		isActive(): bool;
		setActive(isActive?: bool): void;
		setAutoUpdated(isAutoUpdate?: bool): void;
		isAutoUpdated(): bool;
		isPrimary(): bool;

		readPixels(ppDest?: IPixelBox, eFramebuffer?: EFramebuffer): IPixelBox;

		_beginUpdate(): void;
		_updateViewport(iZIndex:  number , bUpdateStatistics?: bool): void;
		_updateViewport(pViewport: IViewport, bUpdateStatistics?: bool): void;
		_updateAutoUpdatedViewports(bUpdateStatistics?: bool): void;
		_endUpdate(): void;

		 preUpdate(): void;
		 postUpdate(): void;

		 viewportPreUpdate(pViewport: IViewport): void;
		 viewportPostUpdate(pViewport: IViewport): void;
		 viewportAdded(pViewport: IViewport): void;
		 viewportRemoved(pViewport: IViewport): void;

		 cameraRemoved(pCamera: ICamera): void;
	}
}








module akra {

	export interface IRenderTexture extends IRenderTarget {
		copyContentsToMemory(pDest: IPixelBox, pBuffer: EFramebuffer): void;
		suggestPixelFormat(): EPixelFormats;
	}
}


























module akra {

    export interface IAFXObject{
        getName(): string;
        getId(): IAFXIdInstruction;
    }

    export interface IAFXVariable extends IAFXObject {
        setName(sName: string): void;
        setType(pType: IAFXVariableTypeInstruction): void;
        getType(): IAFXVariableTypeInstruction;

        initializeFromInstruction(pInstruction: IAFXVariableDeclInstruction): void;

    }

    export interface IAFXType extends IAFXObject {
        isBase(): bool;
        initializeFromInstruction(pInstruction: IAFXTypeDeclInstruction): bool;
    }

    export interface IAFXFunction extends IAFXObject {
        getHash(): string;
    }

    export interface IAFXPass extends IAFXObject {

    }

    export interface IAFXTechnique extends IAFXObject {

    }

    export interface IAFXEffectStats{
        time:  number ;
    }

    export interface IAFXEffect {
        analyze(pTree: IParseTree): bool;
        setAnalyzedFileName(sFileName: string): void;
        getStats(): IAFXEffectStats;

        clear(): void;

        getTechniqueList(): IAFXTechniqueInstruction[];
    }
}



// #ifndef IAFXEFFECT_TS
// #define IAFXEFFECT_TS

// #include "IResourcePoolItem.ts"

// module akra {
// 	export interface IAFXEffect extends IResourcePoolItem {

// 	}
// }

// #endif





module akra {
	export interface IAFXPreRenderState {

	}
}













module akra {

	export interface IAFXPassBlendMap {
		[index:  number ]: IAFXPassBlend;
		[index: string]: IAFXPassBlend;
	}

	export interface IAFXPassBlend extends IUnique {
		initFromPassList(pPassList: IAFXPassInstruction[]): bool;
	}
}





























module akra {
	export interface IRenderPass extends IUnique {
		getRenderTarget(): IRenderTarget;
		setRenderTarget(pTarget: IRenderTarget): void;

		getPassInput(): IAFXPassInputBlend;
		setPassInput(pInput: IAFXPassInputBlend, isNeedRelocate: bool): void;

		blend(sComponentName: string, iPass:  number ): bool;
	}
}



module akra {
	export interface IRenderPass {} ;
	export interface IRenderMethod {} ;
	export interface IAFXComponentBlend {} ;

	export interface IRenderTechnique extends IEventProvider {
		 totalPasses:  number ;
		 modified:  number ;
		 data: IAFXComponentBlend;

		destroy(): void;

		getPass(n:  number ): IRenderPass;
		getMethod(): IRenderMethod;

		setMethod(pMethod: IRenderMethod);
		isReady(): bool;

		setState(sName: string, pValue: any): void;
		setForeign(sName: string, pValue: any): void;
		setStruct(sName: string, pValue: any): void;

		setTextureBySemantics(sName: string, pValue: any): void;
		setShadowSamplerArray(sName: string, pValue: any): void;
		setVec2BySemantic(sName: string, pValue: any): void;

		addComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(sComponent: string, iShift?:  number , iPass?:  number , isSet?: bool): bool;

		delComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		delComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;

		isFreeze(): bool;

		updatePasses(bSaveOldUniformValue: bool): void;

		_setComposer(pComposer: IAFXComposer): void;
		_renderTechnique(pSceneObject: ISceneObject): void;

		 render(iPass:  number ): void;
	}
}







module akra {
	export interface IRenderableObject extends IEventProvider {
		renderMethod: IRenderMethod;

		 effect: IEffect;
		 surfaceMaterial: ISurfaceMaterial;

		 material: IMaterial;

		getGuid():  number ;
		getRenderer(): IRenderer;
		getTechnique(sName?: string): IRenderTechnique;
		getTechniqueDefault(): IRenderTechnique;

		destroy(): void;

		addRenderMethod(pMethod: IRenderMethod, csName?: string): bool;
		addRenderMethod(csMethod: string, csName?: string): bool;

// findRenderMethod(csName: string): uint;
		switchRenderMethod(csName: string): bool;
		switchRenderMethod(pMethod: IRenderMethod): bool;

		removeRenderMethod(csName: string): bool;
		getRenderMethod(csName?: string): IRenderMethod;

		getRenderMethodDefault(): IRenderMethod;

		hasShadow(): bool;
		setShadow(bValue?: bool): void;

		isReadyForRender(): bool;
		isAllMethodsLoaded(): bool;


		render(csMethod?: string, pSceneObject?: ISceneObject): void;

		_setup(pRenderer: IRenderer, csDefaultMethod?: string): void;
		_draw(): void;

/** Notify, when shadow added or removed. */

		 shadow(bValue: bool): void;
	}
}









module akra {

	export interface IMaterial {} ;
	export interface IAFXSamplerState {} ;
	export interface IAFXForeign {} ;
	export interface IAFXPass {} ;
	export interface IRenderData {} ;
	export interface IRenderMethod {} ;
	export interface ITexture {} ;
	export interface IVertexBuffer {} ;
	export interface IVertexData {} ;
	export interface IBufferMap {} ;


	export interface IRenderEntry {
		totalPasses:  number ;
		pass:  number ;

		effect: IRenderMethod;
		renderMethod: IRenderMethod;
		surfaceMaterial: ISurfaceMaterial;
		material: IMaterial;

		activatePass(iPass:  number ): bool;
		deactivatePass(): bool;
		renderPass(iPass:  number ): bool;

		begin(): bool;
		end(): bool;
		updated(bValue: bool): void;

		isMethodLoaded(): bool;
		isReady(): bool;
		isUpdated(): bool;

		setParameter(sName: string, pData: any, isSemantic?: string): bool;
		setParameterBySemantics(sName: string, pData: any): bool;
		setComplexParameter(sName: string, pData: any, isSemantic?: bool): bool;
		setComplexParameterBySemantics(sName: string, pData: any): bool;
		setParameterInArray(sName: string, pData: any, iElement:  number ): bool;
		setPassStates(pPasses: IAFXPass[], pTextures: ITexture[], pForeigns: IAFXForeign[]): void;

		setVertexBuffer(sName: string, pVertexBuffer: IVertexBuffer, isSemantic?: bool): bool;
		setVideoBufferBySemantics(sName: string, pVertexBuffer: IVertexBuffer): bool;

		setSamplerStates(sName: string, eParam: ETextureParameters, eValue: any, isSemantic?: bool): bool;
		setSamplerStatesBySemantics(sName: string, pState: IAFXSamplerState): bool;
		setSamplerStates(sName: string, pState: IAFXSamplerState, isSemantic?: bool): bool;
		setSamplerStatesBySemantics(sName: string, eParam: ETextureParameters, eValue: any): bool;

		setTexture(sName: string, pTexture: ITexture, isSemantic?: bool): bool;
		setTextureBySemantics(sName: string, pTexture: ITexture, isSemantic?: bool): bool;

		setForeignVariable(sName: string, pData: any): void;

		applyVertexData(pData: IVertexData): void;
		applyBufferMap(pBufferMap: IBufferMap): void;
		applyRenderData(pData: IRenderData): void;

	}
}










module akra {

    export interface ISampler2d {} ;
    export interface IVertexData {} ;
    export interface ITexture {} ;
    export interface IMat2 {} ;
    export interface IMat3 {} ;
    export interface IMat4 {} ;
    export interface IVec2 {} ;
    export interface IVec3 {} ;
    export interface IVec4 {} ;
    export interface IQuat4 {} ;
    export interface IBufferMap {} ;

    export interface IShaderProgram extends IRenderResource {
    	create(csVertex?: string, csPixel?: string): bool;
    	compile(csVertex?: string, csPixel?: string): bool;
    	isLinked(): bool;
    	isValid(): bool;
    	isActive(): bool;

    	setFloat(sName: string, fValue:  number ): void;
    	setInt(sName: string, iValue:  number ): void;

    	setVec2(sName: string, v2fValue: IVec2): void;
    	setVec2(sName: string, x:  number , y:  number ): void;

    	setVec2i(sName: string, v2iValue: IVec2): void;
    	setVec2i(sName: string, x:  number , y:  number ): void;

    	setVec3(sName: string, v3fValue: IVec3): void;
    	setVec3(sName: string, x:  number , y:  number , z:  number ): void;

    	setVec3i(sName: string, v3iValue: IVec3): void;
    	setVec3i(sName: string, x:  number , y:  number , z:  number ): void;

    	setVec4(sName: string, v4fValue: IVec4): void;
    	setVec4(sName: string, x:  number , y:  number , z:  number , w:  number ): void;

    	setVec4i(sName: string, v4iValue: IVec4): void;
    	setVec4i(sName: string, x:  number , y:  number , z:  number , w:  number ): void;

    	setMat3(sName: string, m3fValue: IMat3): void;
    	setMat4(sName: string, m4fValue: IMat4): void;

    	setFloat32Array(sName: string, pValue: Float32Array): void;
    	setInt32Array(sName: string, pValue: Int32Array): void;

    	setVec2Array(sName: string, pValue: IVec2[]): void;
    	setVec2iArray(sName: string, pValue: IVec2[]): void;

    	setVec3Array(sName: string, pValue: IVec3[]): void;
    	setVec3iArray(sName: string, pValue: IVec3[]): void;

    	setVec4Array(sName: string, pValue: IVec4[]): void;
    	setVec4iArray(sName: string, pValue: IVec4[]): void;

    	setMat3Array(sName: string, pValue: IMat3[]): void;
    	setMat4Array(sName: string, pValue: IMat4[]): void;

    	setStruct(sName: string, pData: Object): void;
    	setSampler2D(sName: string, pData: ISampler2d): void;
    	setSampler2DToStruct(sName: string, pData: ISampler2d): void;

    	setTexture(sName: string, pData: ITexture): void;

//applyVertexBuffer(sName: string, pBuffer: IVertexBuffer);
    	applyVertexData(sName: string, pData: IVertexData): void;

        applyBufferMap(pMap: IBufferMap): void;
    }
}















module akra {
	export interface IBufferData {
		byteOffset:  number ;
		byteLength:  number ;
		buffer: IBuffer;
	}
}





module akra {
	export interface IBufferDataModifier {} ;
	export interface IVertexDeclaration {} ;
	export interface IVertexBuffer {} ;
	export interface IEventProvider {} ;

	export interface IVertexData extends IBufferData, IBuffer, IEventProvider {
		 stride:  number ;
		 startIndex:  number ;
		 id:  number ;

		getVertexDeclaration(): data.VertexDeclaration;
		setVertexDeclaration(pDecl: IVertexDeclaration): bool;

		getVertexElementCount():  number ;
		hasSemantics(sSemantics: string): bool;

		destroy(): void;

		extend(pDecl: IVertexDeclaration, pData?: ArrayBufferView): bool;
		resize(nCount:  number , pDecl?: IVertexDeclaration): bool;
		resize(nCount:  number , iStride?:  number ): bool;
		applyModifier(sUsage: string, fnModifier: IBufferDataModifier): bool;

		setData(pData: ArrayBufferView, iOffset:  number , iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView, sUsage?: string, iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;

		getData(): ArrayBuffer;
		getData(iOffset:  number , iSize:  number , iFrom?:  number , iCount?:  number ): ArrayBuffer;
		getData(sUsage: string): ArrayBuffer;
		getData(sUsage: string, iFrom:  number , iCount:  number ): ArrayBuffer;

		getTypedData(sUsage: string, iFrom?:  number , iCount?:  number ): ArrayBufferView;
		getBufferHandle():  number ;

		toString(): string;
	}
}











module akra {

	export interface IVertexData {} ;
	export interface IVertexElement {} ;
	export interface IVertexDeclaration {} ;

	export enum EVertexBufferTypes {
		UNKNOWN,
		VBO,
		TBO
	};

	export interface IVertexBuffer extends IHardwareBuffer, IRenderResource {

		 type: EVertexBufferTypes;

		getVertexData(i:  number ): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pElements: IVertexElement[]): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pDecl: IVertexDeclaration): IVertexData;

		getEmptyVertexData(iCount:  number , pElements: IVertexElement[], ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDecl: IVertexDeclaration, ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pSize:  number , ppVertexDataIn?: IVertexData): IVertexData;

		freeVertexData(pVertexData: IVertexData): bool;
		freeVertexData(): bool;

		create(iByteSize:  number , iFlags?:  number , pData?: Uint8Array): bool;

		allocateData(pElements: IVertexElement[], pData: ArrayBufferView): IVertexData;
		allocateData(pDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
	}
}















module akra {

	export interface IIndexData {} ;

	export interface IIndexBuffer extends IHardwareBuffer, IRenderResource {

		create(iByteSize:  number , iFlags?:  number , pData?: ArrayBufferView): bool;

		getIndexData(iOffset:  number , iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData;
		getEmptyIndexData(iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData;

		freeIndexData(pIndexData: IIndexData): bool;


		allocateData(ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes, pData: ArrayBufferView): IIndexData;
	}
}









module akra {
    export interface IRenderEntry {

    }
}






module akra {
	export enum EFrameBufferTypes {
		COLOR  = 0x1,
        DEPTH   = 0x2,
        STENCIL = 0x4
	}

	export interface IFrameBuffer {

	}
}







module akra {

    export interface IRect2d {} ;
    export interface IColor {} ;
    export interface IRenderTarget {} ;
    export interface ICamera {} ;

    export enum EViewportTypes {
        DEFAULT = -1,
        DSVIEWPORT = 1
    }

    export interface IViewport extends IEventProvider {
        left:  number ;
        top:  number ;
        width:  number ;
        height:  number ;

//in pixels
        actualLeft:  number ;
        actualTop:  number ;
        actualWidth:  number ;
        actualHeight:  number ;

        zIndex:  number ;

        backgroundColor: IColor;
        depthClear:  number ;

        update(): void;
        destroy(): void;

        clear(iBuffers?:  number , cColor?: IColor, iDepth?:  number ): void;

        getTarget(): IRenderTarget;
        getCamera(): ICamera;
        setCamera(pCamera: ICamera): bool;

        setDimensions(fLeft:  number , fTop:  number , fWidth:  number , fHeight:  number ): bool;
        setDimensions(pRect: IRect2d): bool;

        getActualDimensions(): IRect2d;

//iBuffers=FBT_COLOUR|FBT_DEPTH
        setClearEveryFrame(isClear: bool, iBuffers?:  number ): void;
        getClearEveryFrame(): bool;
        getClearBuffers():  number ;

        setAutoUpdated(bValue?: bool): void;
        isAutoUpdated(): bool;

        isUpdated(): bool;
        _clearUpdatedFlag(): void;

        _getNumRenderedPolygons():  number ;
        _updateDimensions(pDimensions: IRect2d): void;

         viewportDimensionsChanged(): void;
         viewportCameraChanged(): void;
    }
}



































module akra{

	export interface IVec2 {} ;
	export interface ICircle {} ;

	export interface IRect2d{
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;

		left:  number ;
		top:  number ;

		width:  number ;
		height:  number ;

		set(): IRect2d;
		set(pRect: IRect2d): IRect2d;
		set(v2fVec: IVec2): IRect2d;
		set(fSizeX:  number , fSizeY:  number ): IRect2d;
		set(fX0:  number , fX1:  number , fY0:  number , fY1:  number ): IRect2d;

		setFloor(pRect: IRect2d): IRect2d;
		setCeil(pRect: IRect2d): IRect2d;

		clear(): IRect2d;

		addSelf(fValue:  number ): IRect2d;
		addSelf(v2fVec: IVec2): IRect2d;

		subSelf(fValue:  number ): IRect2d;
		subSelf(v2fVec: IVec2): IRect2d;

		multSelf(fValue:  number ): IRect2d;
		multSelf(v2fVec: IVec2): IRect2d;

		divSelf(fValue:  number ): IRect2d;
		divSelf(v2fVec: IVec2): IRect2d;

		offset(v2fOffset: IVec2): IRect2d;
		offset(fOffsetX:  number , fOffsetY:  number ): IRect2d;

		expand(fValue:  number ): IRect2d;
		expand(v2fValue: IVec2): IRect2d;
		expand(fValueX:  number , fValueY:  number ): IRect2d;

		expandX(fValue:  number ): IRect2d;
		expandY(fValue:  number ): IRect2d;

		resize(v2fSize: IVec2): IRect2d;
		resize(fSizeX:  number , fSizeY:  number ): IRect2d;

		resizeX(fSize:  number ): IRect2d;
		resizeY(fSize:  number ): IRect2d;

		resizeMax(v2fSpan: IVec2): IRect2d;
		resizeMax(fSpanX:  number , fSpanY:  number ): IRect2d;

		resizeMaxX(fSpan:  number ): IRect2d;
		resizeMaxY(fSpan:  number ): IRect2d;

		resizeMin(v2fSpan: IVec2): IRect2d;
		resizeMin(fSpanX:  number , fSpanY:  number ): IRect2d;

		resizeMinX(fSpan:  number ): IRect2d;
		resizeMinY(fSpan:  number ): IRect2d;

		unionPoint(v2fPoint: IVec2): IRect2d;
		unionPoint(fX:  number , fY:  number ): IRect2d;
		unionRect(pRect: IRect2d): IRect2d;

		negate(pDestination?: IRect2d): IRect2d;
		normalize(): IRect2d;

		isEqual(pRect: IRect2d): bool;
		isClear(): bool;
		isValid(): bool;
		isPointInRect(v2fPoint: IVec2): bool;

		midPoint(v2fDestination?: IVec2): IVec2;
		midX():  number ;
		midY():  number ;

		size(v2fDestination?: IVec2): IVec2;
		sizeX():  number ;
		sizeY():  number ;

		minPoint(v2fDestination?: IVec2): IVec2;
		maxPoint(v2fDestination?: IVec2): IVec2;

		area():  number ;

		corner(iIndex:  number , v2fDestination?: IVec2): IVec2;

		createBoundingCircle(pCircle?: ICircle): ICircle;

		toString(): string;
	};
};












module akra {

	export interface IVec2 {} ;

	export interface ICircle {

		radius:  number ;
		center: IVec2;

		set(): ICircle;
		set(pCircle: ICircle): ICircle;
		set(v2fCenter: IVec2, fRadius:  number ): ICircle;
		set(fCenterX:  number , fCenterY:  number , fRadius:  number ): ICircle;

		clear(): ICircle;

		isEqual(pCircle: ICircle): bool;
		isClear(): bool;
		isValid(): bool;

		offset(v2fOffset: IVec2): ICircle;
		expand(fInc:  number ): ICircle;
		normalize(): ICircle;
	};
};



module akra.geometry{
	export class Circle implements ICircle{
		center: IVec2;
		radius:  number ;

		constructor();
		constructor(pCircle: ICircle);
		constructor(v2fCenter: IVec2, fRadius:  number );
		constructor(fCenterX:  number , fCenterY:  number , fRadius:  number );
		constructor(fCenterX?, fCenterY?, fRadius?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pCircle: ICircle = arguments[0];
					this.center = new Vec2(pCircle.center);
					this.radius = pCircle.radius;
					break;
				case 2:
					var v2fCenter: IVec2 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center = new Vec2(v2fCenter);
					this.radius = fRadius;
					break;
				case 3:
					this.center = new Vec2(arguments[0], arguments[1]);
					this.radius = arguments[2];
					break;
				default:
					this.center = new Vec2();
					this.radius = 0.;
					break;
			}
		};

		set(): ICircle;
		set(pCircle: ICircle): ICircle;
		set(v2fCenter: IVec2, fRadius:  number ): ICircle;
		set(fCenterX:  number , fCenterY:  number , fRadius:  number ): ICircle;
		set(fCenterX?, fCenterY?, fRadius?): ICircle{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pCircle: ICircle = arguments[0];
					this.center.set(pCircle.center);
					this.radius = pCircle.radius;
					break;
				case 2:
					var v2fCenter: IVec2 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center.set(v2fCenter);
					this.radius = fRadius;
					break;
				case 3:
					this.center.set(arguments[0], arguments[1]);
					this.radius = arguments[2];
					break;
				default:
					this.center.set(0.);
					this.radius = 0.;
			}

			return this;
		};

		inline clear(): ICircle{
			this.center.clear();
			this.radius = 0.;

			return this;
		};

		inline isEqual(pCircle: ICircle): bool{
			return this.center.isEqual(pCircle.center) && (this.radius == pCircle.radius);
		};

		inline isClear(): bool{
			return this.center.isClear() && (this.radius === 0.);
		};

		inline isValid(): bool{
			return (this.radius >= 0.);
		};

		inline offset(v2fOffset: IVec2): ICircle{
			this.center.add(v2fOffset);
			return this;
		};

		inline expand(fInc:  number ): ICircle{
			this.radius += fInc;
			return this;
		};

		inline normalize(): ICircle{
			this.radius = math.abs(this.radius);
			return this;
		};
	};
};



module akra.geometry{
	export class Rect2d implements IRect2d{
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;

		inline get left():  number  { return this.x0; }
		inline get top():  number  { return this.y0; }
		inline get width():  number  { return this.x1 - this.x0; }
		inline get height():  number  { return this.y1 - this.y0; }

		constructor();
		constructor(pRect: IRect2d);
		constructor(v2fVec: IVec2);
		constructor(fSizeX:  number , fSizeY:  number );
		constructor(fX0:  number , fX1:  number , fY0:  number , fY1:  number );
		constructor(fX0?, fX1?, fY0?, fY1?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 4:
					this.set(arguments[0], arguments[1], arguments[2], arguments[3]);
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = 0.;
					break;
			}
		};

		set(): IRect2d;
		set(pRect: IRect2d): IRect2d;
		set(v2fVec: IVec2): IRect2d;
		set(fSizeX:  number , fSizeY:  number ): IRect2d;
		set(fX0:  number , fX1:  number , fY0:  number , fY1:  number ): IRect2d;
		set(fX0?, fX1?, fY0?, fY1?): IRect2d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					if(arguments[0] instanceof Rect2d){
						var pRect: IRect2d = arguments[0];

						this.x0 = pRect.x0;
						this.x1 = pRect.x1;
						this.y0 = pRect.y0;
						this.y1 = pRect.y1;
					}
					else{
						var v2fSizes: IVec2 = arguments[0];

						this.x1 = v2fSizes.x*0.5;
						this.x0 = -this.x1;

						this.y1 = v2fSizes.y*0.5;
						this.y0 = -this.y1;
					}
					break;
				case 2:
					var fSizeX:  number  = arguments[0];
					var fSizeY:  number  = arguments[1];

					this.x1 = fSizeX*0.5;
					this.x0 = -this.x1;

					this.y1 = fSizeY*0.5;
					this.y0 = -this.y1;
					break;
				case 4:
					this.x0 = arguments[0];
					this.x1 = arguments[1];
					this.y0 = arguments[2];
					this.y1 = arguments[3];
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = 0.;
					break;
			}

			return this;
		};

		setFloor(pRect: IRect2d): IRect2d{
			this.x0 = math.floor(pRect.x0);
			this.x1 = math.floor(pRect.x1);
			this.y0 = math.floor(pRect.y0);
			this.y1 = math.floor(pRect.y1);

			return this;
		};

		setCeil(pRect: IRect2d): IRect2d{
			this.x0 = math.ceil(pRect.x0);
			this.x1 = math.ceil(pRect.x1);
			this.y0 = math.ceil(pRect.y0);
			this.y1 = math.ceil(pRect.y1);

			return this;
		};

		inline clear(): IRect2d{
			this.x0 = this.x1 = this.y0 = this.y1 = 0.;
			return this;
		};

		addSelf(fValue:  number ): IRect2d;
		addSelf(v2fVec: IVec2): IRect2d;
		addSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 += fValue;
				this.x1 += fValue;
				this.y0 += fValue;
				this.y1 += fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 += v2fVec.x;
				this.x1 += v2fVec.x;

				this.y0 += v2fVec.y;
				this.y1 += v2fVec.y;
			}

			return this;
		};

		subSelf(fValue:  number ): IRect2d;
		subSelf(v2fVec: IVec2): IRect2d;
		subSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 -= fValue;
				this.x1 -= fValue;
				this.y0 -= fValue;
				this.y1 -= fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 -= v2fVec.x;
				this.x1 -= v2fVec.x;

				this.y0 -= v2fVec.y;
				this.y1 -= v2fVec.y;
			}

			return this;
		};

		multSelf(fValue:  number ): IRect2d;
		multSelf(v2fVec: IVec2): IRect2d;
		multSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 *= fValue;
				this.x1 *= fValue;
				this.y0 *= fValue;
				this.y1 *= fValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				this.x0 *= v2fVec.x;
				this.x1 *= v2fVec.x;

				this.y0 *= v2fVec.y;
				this.y1 *= v2fVec.y;
			}

			return this;
		};

		divSelf(fValue:  number ): IRect2d;
		divSelf(v2fVec: IVec2): IRect2d;
		divSelf(v2fVec?): IRect2d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];
				logger.setSourceLocation( "geometry/Rect2d.ts" , 196 ); logger.assert(fValue != 0.,"divide by zero error"); ;

				var fInvValue:  number  = 1./fValue;

				this.x0 *= fInvValue;
				this.x1 *= fInvValue;
				this.y0 *= fInvValue;
				this.y1 *= fInvValue;
			}
			else{
				var v2fVec: IVec2 = arguments[0];

				logger.setSourceLocation( "geometry/Rect2d.ts" , 208 ); logger.assert(v2fVec.x != 0.,"divide by zero error"); ;
				logger.setSourceLocation( "geometry/Rect2d.ts" , 209 ); logger.assert(v2fVec.y != 0.,"divide by zero error"); ;

				var fInvX:  number  = 1./v2fVec.x;
				var fInvY:  number  = 1./v2fVec.y;

				this.x0 *= fInvX;
				this.x1 *= fInvX;

				this.y0 *= fInvY;
				this.y1 *= fInvY;
			}

			return this;
		};

		offset(v2fOffset: IVec2): IRect2d;
		offset(fOffsetX:  number , fOffsetY:  number ): IRect2d;
		offset(fOffsetX?, fOffsetY?): IRect2d{
			if(arguments.length === 1){
				var v2fOffset: IVec2 = arguments[0];

				this.x0 += v2fOffset.x;
				this.x1 += v2fOffset.x;

				this.y0 += v2fOffset.y;
				this.y1 += v2fOffset.y;
			}
			else{
				this.x0 += arguments[0];
				this.x1 += arguments[0];

				this.y0 += arguments[1];
				this.y1 += arguments[1];
			}

			return this;
		};

		expand(fValue:  number ): IRect2d;
		expand(v2fValue: IVec2): IRect2d;
		expand(fValueX:  number , fValueY:  number ): IRect2d;
		expand(fValueX?, fValueY?): IRect2d{
			if(arguments.length == 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					this.x0 -= fValue;
					this.x1 += fValue;

					this.y0 -= fValue;
					this.y1 += fValue;
				}
				else{
					var v2fValue: IVec2 = <IVec2>arguments[0];

					this.x0 -= v2fValue.x;
					this.x1 += v2fValue.x;

					this.y0 -= v2fValue.y;
					this.y1 += v2fValue.y;
				}
			}
			else{
//arguments.length == 2

				this.x0 -= arguments[0];
				this.x1 += arguments[0];

				this.y0 -= arguments[1];
				this.y1 += arguments[1];
			}

			return this;
		};

		expandX(fValue:  number ): IRect2d{
			this.x0 -= fValue;
			this.x1 += fValue;

			return this;
		};

		expandY(fValue:  number ): IRect2d{
			this.y0 -= fValue;
			this.y1 += fValue;

			return this;
		};

		resize(v2fSize: IVec2): IRect2d;
		resize(fSizeX:  number , fSizeY:  number ): IRect2d;
		resize(fSizeX?, fSizeY?): IRect2d{
			var fSizeX:  number , fSizeY:  number ;

			if(arguments.length == 1){
				var v2fSize: IVec2 = arguments[0];

				fSizeX = v2fSize.x;
				fSizeY = v2fSize.y;
			}
			else{
				fSizeX = arguments[0];
				fSizeY = arguments[1];
			}

			this.x1 = (this.x0 + this.x1 + fSizeX)*0.5;
			this.x0 = this.x1 - fSizeX;

			this.y1 = (this.y0 + this.y1 + fSizeY)*0.5;
			this.y0 = this.y1 - fSizeY;

			return this;
		};

		inline resizeX(fSize:  number ): IRect2d{
			this.x1 = (this.x0 + this.x1 + fSize)*0.5;
			this.x0 = this.x1 - fSize;

			return this;
		};

		inline resizeY(fSize:  number ): IRect2d{
			this.y1 = (this.y0 + this.y1 + fSize)*0.5;
			this.y0 = this.y1 - fSize;

			return this;
		};

		resizeMax(v2fSpan: IVec2): IRect2d;
		resizeMax(fSpanX:  number , fSpanY:  number ): IRect2d;
		resizeMax(fSpanX?, fSpanY?): IRect2d{
			if(arguments.length == 1){
				var v2fSpan: IVec2 = arguments[0];

				this.x1 = this.x0 + v2fSpan.x;
				this.y1 = this.y0 + v2fSpan.y;
			}
			else{
				this.x1 = this.x0 + arguments[0];
				this.y1 = this.y0 + arguments[1];
			}

			return this;
		};

		inline resizeMaxX(fSpan:  number ): IRect2d{
			this.x1 = this.x0 + fSpan;
			return this;
		};

		inline resizeMaxY(fSpan:  number ): IRect2d{
			this.y1 = this.y0 + fSpan;
			return this;
		};

		resizeMin(v2fSpan: IVec2): IRect2d;
		resizeMin(fSpanX:  number , fSpanY:  number ): IRect2d;
		resizeMin(fSpanX?, fSpanY?): IRect2d{
			if(arguments.length == 1){
				var v2fSpan: IVec2 = arguments[0];

				this.x0 = this.x1 - v2fSpan.x;
				this.y0 = this.y1 - v2fSpan.y;
			}
			else{
				this.x0 = this.x1 - arguments[0];
				this.y0 = this.y1 - arguments[1];
			}

			return this;
		};

		inline resizeMinX(fSpan:  number ): IRect2d{
			this.x0 = this.x1 - fSpan;
			return this;
		};

		inline resizeMinY(fSpan:  number ): IRect2d{
			this.y0 = this.y1 - fSpan;
			return this;
		};

		unionPoint(v2fPoint: IVec2): IRect2d;
		unionPoint(fX:  number , fY:  number ): IRect2d;
		unionPoint(fX?, fY?): IRect2d{
			if(arguments.length == 1){
				var v2fPoint: IVec2 = arguments[0];

				this.x0 = math.min(this.x0, v2fPoint.x);
				this.x1 = math.max(this.x1, v2fPoint.x);

				this.y0 = math.min(this.y0, v2fPoint.y);
				this.y1 = math.max(this.y1, v2fPoint.y);
			}
			else{
				var fX:  number  = arguments[0];
				var fY:  number  = arguments[1];

				this.x0 = math.min(this.x0, fX);
				this.x1 = math.max(this.x1, fX);

				this.y0 = math.min(this.y0, fY);
				this.y1 = math.max(this.y1, fY);
			}

			return this;
		};

		unionRect(pRect: IRect2d): IRect2d{
			this.normalize();
			pRect.normalize();

			this.x0 = math.min(this.x0, pRect.x0);
			this.x1 = math.max(this.x1, pRect.x1);

			this.y0 = math.min(this.y0, pRect.y0);
			this.y1 = math.max(this.y1, pRect.y1);

			return this;
		};

		negate(pDestination?: IRect2d): IRect2d{
			if(!isDef(pDestination)){
				pDestination = this;
			}

			return pDestination.set(-this.x1, -this.x0, -this.y1, -this.y0);
		};

		normalize(): IRect2d{
			var fTmp:  number ;
			if(this.x0 > this.x1){
				fTmp = this.x0;
				this.x0 = this.x1;
				this.x1 = fTmp;
			}
			if(this.y0 > this.y1){
				fTmp = this.y0;
				this.y0 = this.y1;
				this.y1 = fTmp;
			}
			return this;
		};

		inline isEqual(pRect: IRect2d): bool{
			return 	this.x0 == pRect.x0 && this.x1 == pRect.x1
					&& this.y0 == pRect.y0 && this.y1 == pRect.y1;
		};

		inline isClear(): bool{
			return this.x0 == 0. && this.x1 == 0. && this.y0 == 0. && this.y1 == 0.;
		};

		inline isValid(): bool{
			return this.x0 <= this.x1 && this.y0 <= this.y1;
		};

		inline isPointInRect(v2fPoint: IVec2): bool{
			var x:  number  = v2fPoint.x;
			var y:  number  = v2fPoint.y;

			return (this.x0 <= x && x <= this.x1) && (this.y0 <= y && y <= this.y1);
		};

		midPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = (this.x0 + this.x1)*0.5;
			v2fDestination.y = (this.y0 + this.y1)*0.5;

			return v2fDestination;
		};

		inline midX():  number {
			return (this.x0 + this.x1)*0.5;
		};

		inline midY():  number {
			return (this.y0 + this.y1)*0.5;
		};

		size(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x1 - this.x0;
			v2fDestination.y = this.y1 - this.y0;

			return v2fDestination;
		};

		inline sizeX():  number {
			return this.x1 - this.x0;
		};

		inline sizeY():  number {
			return this.y1 - this.y0;
		};

		minPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x0;
			v2fDestination.y = this.y0;

			return v2fDestination;
		};

		maxPoint(v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			v2fDestination.x = this.x1;
			v2fDestination.y = this.y1;

			return v2fDestination;
		};

		inline area():  number {
			return (this.x1 - this.x0)*(this.y1 - this.y0);
		};

/**
		 * counter-clockwise
		 * x0,y0 -> x1,y0 -> x1,y1 -> x0,y1;
		 */


		corner(iIndex:  number , v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			logger.setSourceLocation( "geometry/Rect2d.ts" , 547 ); logger.assert(0 <= iIndex && iIndex < 4, "invalid index"); ;

			switch(iIndex){
				case 0:
					v2fDestination.set(this.x0, this.y0);
					break;
				case 1:
					v2fDestination.set(this.x1, this.y0);
					break;
				case 2:
					v2fDestination.set(this.x1, this.y1);
					break;
				case 3:
					v2fDestination.set(this.x0, this.y1);
					break;
			};
			return v2fDestination;
		};

		createBoundingCircle(pCircle?: ICircle): ICircle{
			if(!isDef(pCircle)){
				pCircle = new Circle();
			}

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;

			var fHalfSizeX:  number  = (fX1 - fX0)*0.5;
			var fHalfSizeY:  number  = (fY1 - fY0)*0.5;

			pCircle.set((fX0 + fX1)*0.5, (fY0 + fY1)*0.5,
				math.sqrt(fHalfSizeX*fHalfSizeX + fHalfSizeY*fHalfSizeY));

			return pCircle;
		};

		toString(): string{
			return "(" + this.x0 + ", " + this.y0 + ") --> (" +
					this.x1 + ", " + this.y1 + ")";
		};
	};
}















module akra {
/** ObjectArray interface */

	export interface IObjectArray {
/** number of element in array */

		length:  number ;

/** lock array for writing */

		lock(): void;
/**
		 * unlock array.
		 */

		unlock(): void;
/**
		 * Is arrat can be modified?
		 */

		isLocked(): bool;

/**
		 * Remove all elements from array;
		 * @param {Bool=false} bRemoveLinks Remove old pointers to data. 
		 */

		clear(bRemoveLinks?: bool): IObjectArray;

/** Get value of <n> element. */

		value(n:  number ): any;
/** Set value for <n> element. */

		set(n:  number , data: any): IObjectArray;
/** Fill ObjectArray from any <Array> */

		fromArray(elements: any[], iOffset?:  number , iSize?:  number ): IObjectArray;
/** Push element to end of array */

		push(element: any): IObjectArray;
/** Get & remove last element in array */

		pop(): any;
/** Complitly remove all data from array */

		release(): IObjectArray;
/** Swap elements in array */

		swap(i:  number , j:  number ): IObjectArray;

		takeAt(iPos): any;
	}
}





module akra.util {
	export class ObjectArray implements IObjectArray {
		/**@protected*/  _pData: any[] = [];
		/**@protected*/  _bLock: bool = false;
		/**@protected*/  _iLength:  number  = 0;

		inline get length():  number  {
			return this._iLength;
		}

// set length(n: uint) {

// 	if (this._bLock) {
// 		return;
// 	}

// 	this.extend(n);
// 	this._iLength = n;
// }

		constructor (pElements?: any[]) {
			if (arguments.length) {
				this.fromArray(pElements);
			}
		}

		inline lock(): void {
			this._bLock = true;
		}

		inline unlock(): void {
			this._bLock = false;
		}

		inline isLocked(): bool {
			return this._bLock;
		}

		clear(bRemoveLinks: bool = false): IObjectArray {

			logger.setSourceLocation( "util/ObjectArray.ts" , 47 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;

			this._iLength = 0;

			if (bRemoveLinks) {
				for (var i:  number  = 0; i < this._pData.length; ++ i) {
					this._pData[i] = null;
				}
			}

			return this;
		}

		release(): IObjectArray {
			this.clear(true);
			this._pData.clear();
			return this;
		}

		inline value(n:  number ): any {
			return this._pData[n];
		}

		private extend(n:  number ): void {
			if (this._pData.length < n) {
//LOG("extending object array to > " + n);
				for (var i:  number  = this._pData.length; i < n; ++ i) {
					this._pData[i] = null;
				}
			}
		}

		set(n:  number , pData: any): IObjectArray {
			logger.setSourceLocation( "util/ObjectArray.ts" , 80 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;

			var N:  number  = n + 1;

			this.extend(N);

			if (this._iLength < N) {
				this._iLength = N;
			}

			this._pData[n] = pData;

			return this;
		}

		fromArray(pElements: any[], iOffset:  number  = 0, iSize:  number  = 0): IObjectArray {
			logger.setSourceLocation( "util/ObjectArray.ts" , 96 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;

			iSize = iSize > 0? iSize < pElements.length? iSize: pElements.length: pElements.length;

			this.extend(iSize);

			for (var i:  number  = iOffset, j:  number  = 0; i < iSize; ++ i, ++ j) {
				this._pData[i] = pElements[j];
			}

			this._iLength = i;

			return this;
		}

		inline push(pElement: any): IObjectArray {

			logger.setSourceLocation( "util/ObjectArray.ts" , 113 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;

			return this.set(this._iLength, pElement);
		}

		inline pop(): any {
			logger.setSourceLocation( "util/ObjectArray.ts" , 119 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;
			return this._iLength > 0? this._pData[-- this._iLength]: null;
		}

		inline swap(i:  number , j:  number ): IObjectArray {
			logger.setSourceLocation( "util/ObjectArray.ts" , 124 ); logger.assert(!this._bLock, "cannot clear. array is locked."); ;
			logger.setSourceLocation( "util/ObjectArray.ts" , 125 ); logger.assert(i < this._iLength && j < this._iLength, "invalid swap index."); ;

			this._pData.swap(i, j);

			return this;
		}

		takeAt(iPos): any {
			var pValue: any = this.value(iPos);

			for (var i = iPos + 1, j = iPos; i < this.length; ++ i, ++ j) {
				this._pData[j] = this._pData[i];
			}

			this._iLength --;

			return pValue;
		}

	}
}

module akra {
	export var ObjectArray = util.ObjectArray;
}



//#define DL_DEFAULT DEFAULT_NAME;

module akra.render {
	export class Viewport implements IViewport {
		/**@protected*/  _pCamera: ICamera;
		/**@protected*/  _pTarget: IRenderTarget;

		/**@protected*/  _fRelLeft:  number ;
		/**@protected*/  _fRelTop:  number ;
		/**@protected*/  _fRelWidth:  number ;
		/**@protected*/  _fRelHeight:  number ;

		/**@protected*/  _iActLeft:  number ;
		/**@protected*/  _iActTop:  number ;
		/**@protected*/  _iActWidth:  number ;
		/**@protected*/  _iActHeight:  number ;

		/**@protected*/  _iZIndex:  number ;

		/**@protected*/  _cBackColor: IColor = new Color(Color.BLACK);

		/**@protected*/  _fDepthClearValue:  number  = 1.;

		/**@protected*/  _bClearEveryFrame: bool = true;

		/**@protected*/  _iClearBuffers:  number  = EFrameBufferTypes.COLOR | EFrameBufferTypes.DEPTH;

		/**@protected*/  _bUpdated: bool = false;

// protected _bShowOverlays: bool = true;

// protected _bShowSkies: bool = true;
// protected _bShowShadows: bool = true;

		/**@protected*/  _iVisibilityMask:  number  = 0xFFFFFFFF;

// protected _sRQSequenceName: string;
// protected mRQSequence: RenderQueueInvocationSequence;

		/**@protected*/  sMaterialSchemeName: string = DEFAULT_MATERIAL_NAME;

// static _eDefaultOrientationMode: EOrientationModes;

		/**@protected*/  _isAutoUpdated: bool = true;

		/**@protected*/  _csDefaultRenderMethod: string = null;

		inline get zIndex():  number  {
			return this._iZIndex;
		}

		inline get left():  number  { return this._fRelLeft; }
        inline get top():  number  { return this._fRelTop; }
        inline get width():  number  { return this._fRelWidth; }
        inline get height():  number  { return this._fRelHeight; }

        inline get actualLeft():  number  { return this._iActLeft; }
        inline get actualTop():  number  { return this._iActTop; }
        inline get actualWidth():  number  { return this._iActWidth; }
        inline get actualHeight():  number  { return this._iActHeight; }

        inline get backgroundColor(): IColor { return this._cBackColor; }
        inline set backgroundColor(cColor: IColor) { this._cBackColor = cColor; }

        inline get depthClear():  number  { return this._fDepthClearValue; }
        inline set depthClear(fDepthClearValue:  number ) { this._fDepthClearValue = fDepthClearValue; }


		constructor (pCamera: ICamera, pTarget: IRenderTarget, csRenderMethod: string = null, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0) {
			this._pTarget = pTarget;

			this._fRelLeft = fLeft;
			this._fRelTop = fTop;
			this._fRelWidth = fWidth;
			this._fRelHeight = fHeight;

			this._iZIndex = iZIndex;

			this._csDefaultRenderMethod = csRenderMethod;

			this._updateDimensions();

			this._setCamera(pCamera);
		}

		destroy(): void {
			var pRenderer: IRenderer = this._pTarget.getRenderer();
			if (pRenderer && pRenderer._getViewport() === this) {
				pRenderer._setViewport(null);
			}
		}


		clear(iBuffers:  number  = 1, cColor: IColor = Color.BLACK, iDepth:  number  = 1.): void {

			var pRenderer: IRenderer = this._pTarget.getRenderer();

			if (pRenderer) {
				var pCurrentViewport: IViewport = pRenderer._getViewport();

				if (pCurrentViewport && pCurrentViewport == this) {
					pRenderer.clearFrameBuffer(iBuffers, cColor, iDepth);
				}
				else if (pCurrentViewport) {
					pRenderer._setViewport(this);
					pRenderer.clearFrameBuffer(iBuffers, cColor, iDepth);
					pRenderer._setViewport(pCurrentViewport);
				}
			}
		}

        inline getTarget(): IRenderTarget {
        	return this._pTarget;
        }

        inline getCamera(): ICamera {
        	return this._pCamera;
        }

        setCamera(pCamera: ICamera): bool {
        	if(this._pCamera) {
				if(this._pCamera._getLastViewport() == this) {
					this._pCamera._keepLastViewport(null);
				}
			}

			if (this._pCamera) {
// update aspect ratio of new camera if needed.
				if (!pCamera.isConstantAspect()) {
					pCamera.aspect = (< number > this._iActWidth / < number > this._iActHeight);
				}
			}

			this._setCamera(pCamera);
			this.viewportCameraChanged();

			return true;
        }

        /**@protected*/  _setCamera(pCamera: ICamera): void {
			this._pCamera = pCamera;

			if (pCamera) {
				pCamera._keepLastViewport(this);
			}
        }

        setDimensions(fLeft:  number , fTop:  number , fWidth:  number , fHeight:  number ): bool;
        setDimensions(pRect: IRect2d): bool;
        setDimensions(fLeft?, fTop?, fWidth?, fHeight?): bool {
        	var pRect: IRect2d;
        	if (isNumber(arguments[0])) {
        		this._fRelLeft = < number >fLeft;
        		this._fRelTop = < number >fTop;
        		this._fRelWidth = < number >fWidth;
        		this._fRelHeight = < number >fHeight;
        	}
        	else {
        		pRect = <IRect2d>arguments[0];
        		this._fRelLeft = pRect.left;
        		this._fRelTop = pRect.top;
        		this._fRelWidth = pRect.width;
        		this._fRelHeight = pRect.height;
        	}

         	this._updateDimensions();

         	return true;
        }

        getActualDimensions(): IRect2d {
        	return new geometry.Rect2d(< number >this._iActLeft, < number >this._iActTop, < number >this._iActWidth, < number >this._iActHeight);
        }

//iBuffers=FBT_COLOUR|FBT_DEPTH
        setClearEveryFrame(isClear: bool, iBuffers?:  number ): void {
        	this._bClearEveryFrame = isClear;
			this._iClearBuffers = iBuffers;
        }

        inline getClearEveryFrame(): bool {
        	return this._bClearEveryFrame;
        }

        inline getClearBuffers():  number  {
        	return this._iClearBuffers;
        }

        inline setAutoUpdated(bValue: bool = true): void { this._isAutoUpdated = bValue; }
        inline isAutoUpdated(): bool { return this._isAutoUpdated; }

		_updateDimensions(): void {
			var fHeight:  number   = < number >this._pTarget.height;
			var fWidth:  number   = < number >this._pTarget.width;

			this._iActLeft = < number >(this._fRelLeft * fWidth);
			this._iActTop = < number >(this._fRelTop * fHeight);
			this._iActWidth = < number >(this._fRelWidth * fWidth);
			this._iActHeight = < number >(this._fRelHeight * fHeight);

// This will check if the cameras getAutoAspectRatio() property is set.
// If it's true its aspect ratio is fit to the current viewport
// If it's false the camera remains unchanged.
// This allows cameras to be used to render to many viewports,
// which can have their own dimensions and aspect ratios.

	        if (this._pCamera)  {
	            if (!this._pCamera.isConstantAspect())
	                this._pCamera.aspect = (< number > this._iActWidth / < number > this._iActHeight);

			}

	 		this._bUpdated = true;

			this.viewportDimensionsChanged();
		}

		update(): void {
			if (this._pCamera) {
				this.renderAsNormal(this._csDefaultRenderMethod, this._pCamera);
			}
		}

		/**@protected*/  renderAsNormal(csMethod: string, pCamera: ICamera): void {
				var pVisibleObjects: IObjectArray = pCamera.display();
				var pRenderable: IRenderableObject;

				for (var i:  number  = 0; i < pVisibleObjects.length; ++ i) {
					var pSceneObject: ISceneObject = pVisibleObjects.value(i);
					pRenderable = pSceneObject.getRenderable();

					if (!isNull(pRenderable)) {
						pRenderable.render(csMethod, pSceneObject);
					}
				}
		}


        inline isUpdated(): bool {
        	return this._bUpdated;
        }

        inline _clearUpdatedFlag(): void {
        	this._bUpdated = false;
        }

        _getNumRenderedPolygons():  number  {
        	return this._pCamera? this._pCamera._getNumRenderedFaces(): 0;
        }

        /**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return Viewport._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
    	viewportDimensionsChanged (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportDimensionsChanged; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
    	viewportCameraChanged (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportCameraChanged; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
	}
}










module akra {
	export interface IDSViewport extends IViewport {
		setSkybox(pSkyTexture: ITexture): void;
		setFXAA(bValue?: bool): void;
	}
}












module akra {

	export interface ISceneNode {} ;
	export interface ICamera {} ;

	export interface ILightParameters {
//default parameters
	    ambient: IColor;
	    diffuse: IColor;
	    specular: IColor;
	    attenuation: IVec3;
	}

	export interface ILightPoint extends ISceneNode {
		params: ILightParameters;
		enabled: bool;

		isShadowCaster: bool;

		create(): bool;

//false if lighting not active 
//or it's effect don't seen
		_prepareForLighting(pCamera: ICamera): bool;

		_calculateShadows(): void;
	}
}












module akra.render {
	export interface IUniform {

	}

	export  class  LightData {
		DIFFUSE: IVec4 = new Vec4();
		AMBIENT: IVec4 = new Vec4();
		SPECULAR: IVec4 = new Vec4();
		POSITION: IVec3 = new Vec3();
		ATTENUATION: IVec3 = new Vec3();

		set(pLightParam: ILightParameters, v3fPosition: IVec3): LightData {

		    this.DIFFUSE.set(pLightParam.diffuse);
		    this.AMBIENT.set(pLightParam.ambient);
		    this.SPECULAR.set(pLightParam.specular);
		    this.ATTENUATION.set(pLightParam.attenuation);
		    this.POSITION.set(v3fPosition);

		    return this;
		}
	};

	export  class  UniformOmni implements IUniform {
		LIGHT_DATA: LightData = new LightData();

		setLightData(pLightParam: ILightParameters, v3fPosition: IVec3): UniformOmni {
			this.LIGHT_DATA.set(pLightParam, v3fPosition);

			return this;
		}

		static get stackCeil(): UniformOmni { UniformOmni.stackPosition = UniformOmni.stackPosition === UniformOmni.stackSize - 1? 0: UniformOmni.stackPosition; return UniformOmni.stack[UniformOmni.stackPosition ++]; } static stackSize: number = 200; static stackPosition: number = 0; static stack: UniformOmni[] = (function(): UniformOmni[]{ var pStack: UniformOmni[] = new Array(UniformOmni.stackSize); for(var i: number = 0; i<UniformOmni.stackSize; i++){ pStack[i] = new UniformOmni(); } return pStack})(); ;
	};

	export  class  UniformProject implements IUniform {
		LIGHT_DATA: LightData = new LightData();
    	SHADOW_MATRIX: IMat4 = new Mat4();

    	setLightData(pLightParam: ILightParameters, v3fPosition: IVec3): UniformProject {
			this.LIGHT_DATA.set(pLightParam, v3fPosition);

			return this;
		}

		setMatrix(m4fMatrix: IMat4): UniformProject {
			this.SHADOW_MATRIX.set(m4fMatrix);

			return this;
		}

    	static get stackCeil(): UniformProject { UniformProject.stackPosition = UniformProject.stackPosition === UniformProject.stackSize - 1? 0: UniformProject.stackPosition; return UniformProject.stack[UniformProject.stackPosition ++]; } static stackSize: number = 200; static stackPosition: number = 0; static stack: UniformProject[] = (function(): UniformProject[]{ var pStack: UniformProject[] = new Array(UniformProject.stackSize); for(var i: number = 0; i<UniformProject.stackSize; i++){ pStack[i] = new UniformProject(); } return pStack})(); ;
	};


	export  class  UniformProjectShadow implements IUniform {
		LIGHT_DATA: LightData = new LightData();
	    TO_LIGHT_SPACE: IMat4 = new Mat4();
	    REAL_PROJECTION_MATRIX: IMat4 = new Mat4();
	    OPTIMIZED_PROJECTION_MATRIX: IMat4 = new Mat4();
	    SHADOW_SAMPLER:  ISampler2d  = {TEXTURE: null};

	    setLightData(pLightParam: ILightParameters, v3fPosition: IVec3): UniformProjectShadow {
	    	this.LIGHT_DATA.set(pLightParam, v3fPosition);
	    	return this;
	    }

	    setMatrix(m4fToLightSpace: IMat4, m4fRealProj: IMat4, m4fOptimizedProj: IMat4): UniformProjectShadow {
	    	this.TO_LIGHT_SPACE.set(m4fToLightSpace);
		    this.REAL_PROJECTION_MATRIX.set(m4fRealProj);
		    this.OPTIMIZED_PROJECTION_MATRIX.set(m4fOptimizedProj);

	    	return this;
	    }

	    setSampler(sTexture: string): UniformProjectShadow {
	    	this.SHADOW_SAMPLER.TEXTURE = sTexture;
	    	return this;
	    }

	    static get stackCeil(): UniformProjectShadow { UniformProjectShadow.stackPosition = UniformProjectShadow.stackPosition === UniformProjectShadow.stackSize - 1? 0: UniformProjectShadow.stackPosition; return UniformProjectShadow.stack[UniformProjectShadow.stackPosition ++]; } static stackSize: number = 20; static stackPosition: number = 0; static stack: UniformProjectShadow[] = (function(): UniformProjectShadow[]{ var pStack: UniformProjectShadow[] = new Array(UniformProjectShadow.stackSize); for(var i: number = 0; i<UniformProjectShadow.stackSize; i++){ pStack[i] = new UniformProjectShadow(); } return pStack})(); ;
	}

	export  class  UniformOmniShadow implements IUniform {
		LIGHT_DATA: LightData = new LightData;
		TO_LIGHT_SPACE: IMat4[] =
		[
			new Mat4, new Mat4, new Mat4,
			new Mat4, new Mat4, new Mat4
		];

		OPTIMIZED_PROJECTION_MATRIX: IMat4[] =
		[
			new Mat4, new Mat4, new Mat4,
			new Mat4, new Mat4, new Mat4
		];

		SHADOW_SAMPLER:  ISampler2d [] =
		[
			{"TEXTURE" : null}, {"TEXTURE" : null}, {"TEXTURE" : null},
	        {"TEXTURE" : null}, {"TEXTURE" : null}, {"TEXTURE" : null}
	    ];

	    setLightData(pLightParam: ILightParameters, v3fPosition: IVec3): UniformOmniShadow {
		    this.LIGHT_DATA.set(pLightParam, v3fPosition);
		    return this;
		};

		setMatrix(m4fToLightSpace: IMat4, m4fOptimizedProj: IMat4, index:  number ): UniformOmniShadow {
		    this.TO_LIGHT_SPACE[index].set(m4fToLightSpace);
		    this.OPTIMIZED_PROJECTION_MATRIX[index].set(m4fOptimizedProj);
		    return this;
		};

		setSampler(sTexture: string, index:  number ): UniformOmniShadow {
		    this.SHADOW_SAMPLER[index].TEXTURE = sTexture;
		    return this;
		};

	    static get stackCeil(): UniformOmniShadow { UniformOmniShadow.stackPosition = UniformOmniShadow.stackPosition === UniformOmniShadow.stackSize - 1? 0: UniformOmniShadow.stackPosition; return UniformOmniShadow.stack[UniformOmniShadow.stackPosition ++]; } static stackSize: number = 3; static stackPosition: number = 0; static stack: UniformOmniShadow[] = (function(): UniformOmniShadow[]{ var pStack: UniformOmniShadow[] = new Array(UniformOmniShadow.stackSize); for(var i: number = 0; i<UniformOmniShadow.stackSize; i++){ pStack[i] = new UniformOmniShadow(); } return pStack})(); ;
	}

	export interface UniformMap {
		omni: UniformOmni[];
        project: UniformProject[];
        omniShadows: UniformOmniShadow[];
        projectShadows: UniformProjectShadow[];
        textures: ITexture[];
        samplersOmni:  ISampler2d [];
        samplersProject:  ISampler2d [];
	}
}













module akra {

	export interface ILightPoint {} ;
	export interface IShadowCaster {} ;
	export interface ITexture {} ;
	export interface IRenderTarget {} ;
	export interface ICamera {} ;

	export interface IOmniLight extends ILightPoint {
		getShadowCaster(): IShadowCaster[];
		getDepthTextureCube(): ITexture[];
		getRenderTarget(iFace:  number ): IRenderTarget;

//false if lighting not active 
//or it's effect don't seen
		_prepareForLighting(pCamera: ICamera): bool;
	}
}







module akra {

	export interface ILightPoint {} ;
	export interface ICamera {} ;

	export interface IProjectLight extends ILightPoint {

		getShadowCaster(): IShadowCaster;
		getDepthTexture(): ITexture;
		getRenderTarget(): IRenderTarget;

//false if lighting not active 
//or it's effect don't seen
		_prepareForLighting(pCamera: ICamera): bool;
	}
}







module akra {

	export interface ILightPoint {} ;
	export interface IObjectArray {} ;
	export interface IMat4 {} ;

	export interface IShadowCaster extends ICamera {
		 lightPoint: ILightPoint;
		 face:  number ;
		 affectedObjects: IObjectArray;
		 optimizedProjection: IMat4;

		_optimizeProjectionMatrix(): void;
	}
}

























module akra.render {
	export class RenderPass implements IRenderPass {
		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } ;

		private _pTechnique: IRenderTechnique = null;
		private _pRenderTarget: IRenderTarget = null;
		private _iPassNumber:  number  = 0;
		private _pInput: IAFXPassInputBlend = null;

		constructor(pTechnique: IRenderTechnique, iPass:  number ){
			this._pTechnique = pTechnique;
			this._iPassNumber = iPass;
		}

		getRenderTarget(): IRenderTarget {
			return this._pRenderTarget;
		}

		setRenderTarget(pTarget: IRenderTarget): void {
			this._pRenderTarget = pTarget;
		}

		getPassInput(): IAFXPassInputBlend {
			return this._pInput;
		}

		setPassInput(pInput: IAFXPassInputBlend, isNeedRelocate: bool): void {
			if(isNeedRelocate){
				this.relocateOldInput(pInput);
			}

			if(!isNull(this._pInput)) {
				this._pInput._release();
			}

			this._pInput = pInput;
		}

		blend(sComponentName: string, iPass:  number ): bool {
			return this._pTechnique.addComponent(sComponentName, this._iPassNumber, iPass);
		}

		private relocateOldInput(pNewInput: IAFXPassInputBlend): void {
//TODO: copy old uniforms to new
		}
	}
}



module akra.render {
	export class RenderTechnique implements IRenderTechnique {
		private _pMethod: IRenderMethod = null;

		private _isFreeze: bool = false;
		private _pComposer: IAFXComposer = null;

		private _pPassList: IRenderPass[] = null;

		private _iCurrentPass:  number  = 0;
		private _pCurrentPass: IRenderPass = null;

		inline get modified():  number  {
			return this.getGuid();
		}

		get totalPasses():  number  {
			return this._pComposer.getTotalPassesForTechnique(this);
		}

		get data(): IAFXComponentBlend {
			return null;
		}

		constructor (pMethod: IRenderMethod = null) {
			this._pPassList = [];

			if(!isNull(pMethod)){
				this.setMethod(pMethod);
			}
		}


		destroy(): void {

		}

		getPass(iPass:  number ): IRenderPass {
			return this._pPassList[iPass];
		}

		getMethod(): IRenderMethod {
			return this._pMethod;
		}

		setMethod(pMethod: IRenderMethod): void {
			if(!isNull(this._pMethod)){
				this.disconnect(this._pMethod,  "altered" ,  "_updateMethod" , EEventTypes.BROADCAST);
			}

			this._pMethod = pMethod;

			if(!isNull(pMethod)){
				var pComposer: IAFXComposer = pMethod.manager.getEngine().getComposer();
				this._setComposer(pComposer);
				this.connect(pMethod,  "altered" ,  "_updateMethod" , EEventTypes.BROADCAST);
			}

			this.informComposer();
		}

		setState(sName: string, pValue: any): void {

		}

		setForeign(sName: string, pValue: any): void {

		}

		setStruct(sName: string, pValue: any): void {

		}

		setTextureBySemantics(sName: string, pValue: any): void {

		}

		setShadowSamplerArray(sName: string, pValue: any): void {

		}

		setVec2BySemantic(sName: string, pValue: any): void {

		}

		isReady(): bool {
			return false;
		}

		addComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(sComponent: string, iShift?:  number , iPass?:  number , isSet?: bool): bool;
		addComponent(pComponent: any, iShift?:  number  = 0, iPass?:  number  =  0xffffff , isSet?: bool = true): bool {
			if(isNull(this._pComposer)){
				return false;
			}

			var pComponentPool: IResourcePool = this._pComposer.getEngine().getResourceManager().componentPool;

			if(isInt(pComponent)) {
				pComponent = pComponentPool.getResource(< number >pComponent);
			}
			else if(isString(pComponent)){
				pComponent = pComponentPool.findResource(<string>pComponent);
			}

			if(!isDef(pComponent) || isNull(pComponent)){
				logger.setSourceLocation( "RenderTechnique.ts" , 115 ); logger.error("Bad component for add/delete."); ;
				return false;
			}

			if(isSet){
				if(!this._pComposer.addOwnComponentToTechnique(this, <IAFXComponent>pComponent, iShift, iPass)){
					logger.setSourceLocation( "RenderTechnique.ts" , 121 ); logger.error("Can not add component '" + <IAFXComponent>pComponent.findResourceName() + "'"); ;
					return false;
				}
			}
			else {
				if(!this._pComposer.removeOwnComponentToTechnique(this, <IAFXComponent>pComponent, iShift, iPass)){
					logger.setSourceLocation( "RenderTechnique.ts" , 127 ); logger.error("Can not delete component '" + <IAFXComponent>pComponent.findResourceName() + "'"); ;
					return false;
				}
			}

			return true;
		}

		delComponent(iComponentHandle:  number , iShift?:  number , iPass?:  number ): bool;
		delComponent(sComponent: string, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: IAFXComponent, iShift?:  number , iPass?:  number ): bool;
		delComponent(pComponent: any, iShift?:  number  = 0, iPass?:  number  =  0xffffff ): bool {
			return this.addComponent(pComponent, iShift, iPass, false);
		}

		isFreeze(): bool {
			return this._isFreeze;
		}

		updatePasses(bSaveOldUniformValue: bool): void {
			this._isFreeze = true;

			var iTotalPasses:  number  = this.totalPasses;

			for(var i:  number  = this._pPassList.length; i < iTotalPasses; i++){
				this._pPassList[i] = new RenderPass(this, i);
			}

			for(var i:  number  = 0; i < iTotalPasses; i++){
				var pInput: IAFXPassInputBlend = this._pComposer.getPassInputBlend(this, i);
				this._pPassList[i].setPassInput(pInput, bSaveOldUniformValue);
			}

			this._isFreeze = false;
		}

		_setComposer(pComposer: IAFXComposer): void {
			this._pComposer = pComposer;
		}

		_renderTechnique(pSceneObject: ISceneObject): void {
			if(isNull(this._pComposer)){
				return;
			}

			var pComposer: IAFXComposer = this._pComposer;

			pComposer.setCurrentSceneObject(pSceneObject);
			pComposer.prepareTechniqueBlend(this);

			this._isFreeze = true;

			for(var i:  number  = 0; i < this.totalPasses; i++){
				this.activatePass(i);
				this.render(i);

				pComposer.renderTechniquePass(this, i);
			}

			this._isFreeze = false;
			pComposer.setCurrentSceneObject(null);
		}

		_updateMethod(pMethod: IRenderMethod): void {
			this.informComposer();
		}

		private informComposer(): void {
			if(!isNull(this._pComposer)){
				this._pComposer.markTechniqueAsNeedUpdate(this);
			}
		}

		private activatePass(iPass:  number ): void {
			this._iCurrentPass = iPass;
			this._pCurrentPass = this._pPassList[iPass];
		}


		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return RenderTechnique._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		render (iPass): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).render; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier, iPass) : _unicast.listener (_recivier, iPass) ; } } ; ;
	}
}








module akra.render {

	export interface IRenderTechniqueMap {
		[key: string]: IRenderTechnique;
	}

	export class RenderableObject implements IRenderableObject {
		/**@protected*/  _pRenderer: IRenderer;
		/**@protected*/  _pTechnique: IRenderTechnique = null;
		/**@protected*/  _pTechniqueMap: IRenderTechniqueMap = {};
		/**@protected*/  _bShadow: bool = false;

		inline get renderMethod(): IRenderMethod {
			return this._pTechnique.getMethod();
		}

		inline set renderMethod(pMethod: IRenderMethod) {
			this.switchRenderMethod(pMethod);
		}

		inline get effect(): IEffect { return this._pTechnique.getMethod().effect; }
		inline get surfaceMaterial(): ISurfaceMaterial  { return this._pTechnique.getMethod().surfaceMaterial; }

		inline get material(): IMaterial  { return this.surfaceMaterial.material; }

		constructor () {

		}

		_setup(pRenderer: IRenderer, csDefaultMethod: string = null): void {
			this._pRenderer = pRenderer;

			if (!this.addRenderMethod(csDefaultMethod) || this.switchRenderMethod(null) === false) {
				logger.setSourceLocation( "RenderableObject.ts" , 44 ); logger.criticalError("cannot add & switch render method to default"); ;
			}
		}

		inline getRenderer(): IRenderer {
			return this._pRenderer;
		}

		destroy(): void {
			this._pRenderer = null;
			this._pTechnique = null;

			for (var i in this._pTechniqueMap) {
				this._pTechniqueMap[i].destroy();
			}

			this._pTechniqueMap = null;
		}

		addRenderMethod(pMethod: IRenderMethod, csName: string =  "default" ): bool;
		addRenderMethod(csMethod: string, csName: string =  "default" ): bool;
		addRenderMethod(csMethod: any, csName: string =  "default" ): bool {
			var pTechnique: IRenderTechnique = new RenderTechnique;
			var pRmgr: IResourcePoolManager = this.getRenderer().getEngine().getResourceManager();
			var pMethod: IRenderMethod = null;

			if (isNull(csMethod)) {
				csMethod =  "default" ;
			}

		    if (isString(arguments[0]) || arguments.length === 0) {
		        pMethod = pRmgr.createRenderMethod((csMethod) + this.getGuid());

		        if (!isDefAndNotNull(pMethod)) {
		        	return false;
		        }

//adding empty, but NOT NULL effect & material
		        pMethod.surfaceMaterial = pRmgr.createSurfaceMaterial(csMethod + ".material." + this.getGuid());
		        pMethod.effect = pRmgr.createEffect(csMethod + ".effect." + this.getGuid());
		    }
		    else {
		    	pMethod = <IRenderMethod>arguments[0];
		    }


		    logger.setSourceLocation( "RenderableObject.ts" , 91 ); logger.assert(pMethod.getManager().getEngine().getRenderer() === this._pRenderer, "Render method should belong to the same engine instance that the renderable object.");
                                                                                                         ;

		    pTechnique.setMethod(pMethod);
//pTechnique.name = csName || DEFAULT_RT;

		    this._pTechniqueMap[csName ||  "default" ] = pTechnique;

		    return true;
		}

		switchRenderMethod(pMethod: IRenderMethod): bool;
		switchRenderMethod(csName: string): bool;
		switchRenderMethod(csName: any): bool {
			var pTechnique: IRenderTechnique;
			var sName: string = null;

			if(isNull(arguments[0])) {
				sName =  "default" ;
			}
			else if (isString(arguments[0])) {
				sName = <string>csName;
			}
			else if (isDefAndNotNull(arguments[0])) {
				sName = (<IRenderMethod>arguments[0]).findResourceName();

				if (!isDefAndNotNull(this._pTechniqueMap[sName])) {
					if (!this.addRenderMethod(<IRenderMethod>arguments[0], sName)) {
						return false;
					}
				}
			}

			pTechnique = this._pTechniqueMap[sName];

			if (isDefAndNotNull(pTechnique)) {
				this._pTechnique = pTechnique;
				return true;
			}

			return false;
		}

		removeRenderMethod(csName: string): bool {
			var pTechnique: IRenderTechnique = this._pTechniqueMap[csName];

			if (isDefAndNotNull(pTechnique)) {
				delete this._pTechniqueMap[csName ||  "default" ];
				return true
			}

		    return false;
		}



		inline getRenderMethod(csName: string = null): IRenderMethod {
			var pTechnique: IRenderTechnique = this._pTechniqueMap[csName ||  "default" ];
			return pTechnique? pTechnique.getMethod(): null;
		}

		inline getRenderMethodDefault(): IRenderMethod {
			return this.getRenderMethod( "default" );
		}

		inline hasShadow(): bool {
			return this._bShadow;
		}

		setShadow(bValue: bool = true): void {
			if (this._bShadow != bValue) {
				this._bShadow = bValue;
				this.shadow(bValue);
			}
		}

		inline isReadyForRender(): bool {
			return this._pTechnique.isReady();
		}

		isAllMethodsLoaded(): bool {
			for (var i in this._pTechniqueMap) {
				var pMethod: IRenderMethod = this._pTechniqueMap[i].getMethod();

				if (!isDefAndNotNull(pMethod) || !pMethod.isResourceLoaded()) {
					return false;
				}
			}

			return true;
		}


		render(csMethod?: string = null, pSceneObject?: ISceneObject = null): void {
			if(!this.switchRenderMethod(csMethod)){
				return;
			}

			var pTechnique: IRenderTechnique = this.getTechnique();
			pTechnique._renderTechnique(pSceneObject);
		}

		inline getTechnique(sName: string = null): IRenderTechnique {
			return this._pTechniqueMap[sName] || null;
		}

		inline getTechniqueDefault(): IRenderTechnique{
			return this.getTechnique( "default" );
		}

		_draw(): void {
			logger.setSourceLocation( "RenderableObject.ts" , 201 ); logger.error("RenderableObject::_draw() pure virtual method() isn't callable!!"); ;
		}

		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return RenderableObject._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		shadow (bValue): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).shadow; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier, bValue) : _unicast.listener (_recivier, bValue) ; } } ; ;
	}
}











module akra.render {



	export class DSViewport extends Viewport implements IDSViewport  {
		private _pDefferedColorTextures: ITexture[];
		private _pDeferredDepthTexture: ITexture;
		private _pDeferredView: IRenderableObject = null;
		private _pDeferredSkyTexture: ITexture = null;
//index of lighting display list
		private _pLightDL:  number ;

		private _pLightingUnifoms: UniformMap = {
	        omni           	: [],
	        project        	: [],
	        omniShadows    	: [],
	        projectShadows 	: [],
	        textures       	: [],
	        samplersOmni  	: [],
	        samplersProject : []
	    };

	    private _pLightPoints: ILightPoint[] = null;

		constructor(pCamera: ICamera, pTarget: IRenderTarget, csRenderMethod: string = null, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1., iZIndex:  number  = 0) {
			super(pCamera, pTarget, null, fLeft, fTop, fWidth, fHeight, iZIndex);

			var pEngine: IEngine = this.getTarget().getRenderer().getEngine();
			var pResMgr: IResourcePoolManager = pEngine.getResourceManager();
			var pDeferredData: IRenderTarget[] = <IRenderTarget[]>new Array(2);
			var pDeferredTextures: ITexture[] = <ITexture[]>new Array(2);
			var pDepthTexture: ITexture;
			var pDefferedView: IRenderableObject = this._pDeferredView = new render.RenderableObject();
			var iGuid:  number  = sid();
			var iWidth:  number  = math.ceilingPowerOfTwo(this.actualWidth);
    		var iHeight:  number  = math.ceilingPowerOfTwo(this.actualHeight);

    		if (info.browser.name === "Firefox") {
		        iWidth 	= math.min(iWidth, 1024);
		        iHeight = math.min(iHeight, 1024);
		    }

			pDepthTexture = this._pDeferredDepthTexture = pResMgr.createTexture("deferred-depth-texture-" + iGuid);
			pDepthTexture.create(iWidth, iHeight, 1, null, 0, 0, 0,
					ETextureTypes.TEXTURE_2D, EPixelFormats.FLOAT32_DEPTH);

			for (var i = 0; i < 2; ++ i) {
				pDeferredTextures[i] = this._pDefferedColorTextures[i] =
					pResMgr.createTexture("deferred-color-texture-" + i + "-" +  iGuid);
				pDeferredTextures[i].create(iWidth, iHeight, 1, null, 0, 0,0,
					ETextureTypes.TEXTURE_2D, EPixelFormats.FLOAT32_RGBA);

				pDeferredData[i] = pDeferredTextures[i].getBuffer().getRenderTarget();
				pDeferredData[i].addViewport(this.getCamera(), "deferred_shading_pass_" + i);

				pDeferredData[i].attachDepthTexture(pDepthTexture);
			}

//TODO >>>
// pResMgr.loadAFXEffect("prepare_deferred_shading.afx");
// pResMgr.loadAFXEffect("base_deferred_shading.afx");
// pResMgr.loadAFXEffect("lights_and_shadows_deferred_shading.afx");
// pResMgr.loadAFXEffect("skybox_deferred_shading.afx");
// pResMgr.loadAFXEffect("fxaa_deferred_shading.afx");

			var pDSMethod: IRenderMethod  	= pResMgr.createRenderMethod(".deferred_shading");
			var pDSEffect: IEffect 			= pResMgr.createEffect(".deferred_shading");

// pDSEffect.addComponent("akra.system.prepareForDeferredShading");
			pDSEffect.addComponent("akra.system.deferredShading");
			pDSEffect.addComponent("akra.system.omniLighting");
			pDSEffect.addComponent("akra.system.projectLighting");
			pDSEffect.addComponent("akra.system.omniShadowsLighting");
			pDSEffect.addComponent("akra.system.projectShadowsLighting");
			pDSEffect.addComponent("akra.system.skybox", 1);

			pDSMethod.effect = pDSEffect;
			pDefferedView.renderMethod = pDSMethod;



			this.connect(pDefferedView.getTechnique(),  "render" ,  "_onRender" );
		}

		update (): bool {

			this.prepareForDeferredShading();

			var pLights: ILightPoint[] = <ILightPoint[]><any>this.getCamera().display( 1 );

		    for (var i:  number  = 0; i < pLights.length; i++) {
		        pLights[i]._calculateShadows();
		    }

		    this._pLightPoints = pLights;

//prepare deferred textures




			var pNodeList: IObjectArray = this.getCamera().display();
			for (var i:  number  = 0; i < pNodeList.length; ++ i) {
				var pRenderable: IRenderableObject = pNodeList.value(i).getRenderable();
				pRenderable.render(null, pNodeList.value(i));
			}

//render defferred
			this._pDeferredView.render();

			return true;
		}

		prepareForDeferredShading(): void {

			var pNodeList: IObjectArray = this.getCamera().display();

			for (var i:  number  = 0; i < pNodeList.length; ++ i) {
				var pRenderable: IRenderableObject = pNodeList.value(i).getRenderable();
				var pTechCurr: IRenderTechnique = pRenderable.getTechniqueDefault();

				pTechCurr.getPass(0).setRenderTarget(this._pDefferedColorTextures[0].getBuffer().getRenderTarget());
				pTechCurr.getPass(1).setRenderTarget(this._pDefferedColorTextures[1].getBuffer().getRenderTarget());
			};

		}

		setSkybox(pSkyTexture: ITexture): bool {
			if (pSkyTexture.textureType !== ETextureTypes.TEXTURE_CUBE_MAP) {
				return null;
			}

			this._pDeferredSkyTexture = pSkyTexture;

			return true;
		}

		setFXAA(bValue: bool = true): void {
			var pEffect: IEffect = this._pDeferredView.renderMethod.effect;

			if (bValue) {
				pEffect.addComponent("akra.system.fxaa", 2);
			}
			else {
				pEffect.delComponent("akra.system.fxaa", 2);
			}
		}




		destroy(): void {
			super.destroy();

			this._pDeferredDepthTexture.destroyResource();

			this._pDefferedColorTextures[0].destroyResource();
			this._pDefferedColorTextures[1].destroyResource();

			this._pDeferredView.destroy();
			this._pDeferredView = null;

			this._pDeferredSkyTexture = null;
		}



		_onRender(pTechnique: IRenderTechnique, iPass:  number ): void {
			switch (iPass) {
				case 2:
					var pLightUniforms: UniformMap = this._pLightingUnifoms;
					var pLightPoints: ILightPoint[] = this._pLightPoints;
					var pCamera: ICamera = this.getCamera();
					var pDepthTexture: ITexture = this._pDeferredDepthTexture;
					var pDeferredTextures: ITexture[] = this._pDefferedColorTextures;

					this.createLightingUniforms(pCamera, pLightPoints, pLightUniforms);

					pTechnique.setState("lights.omni", pLightUniforms.omni.length);
					pTechnique.setState("lights.project", pLightUniforms.project.length);
					pTechnique.setState("lights.omniShadows", pLightUniforms.omniShadows.length);
					pTechnique.setState("lights.projectShadows", pLightUniforms.projectShadows.length);

					pTechnique.setForeign("nOmni", pLightUniforms.omni.length);
				    pTechnique.setForeign("nProject", pLightUniforms.project.length);
				    pTechnique.setForeign("nOmniShadows", pLightUniforms.omniShadows.length);
				    pTechnique.setForeign("nProjectShadows", pLightUniforms.projectShadows.length);

				    pTechnique.setStruct("points_omni", pLightUniforms.omni);
				    pTechnique.setStruct("points_project", pLightUniforms.project);
				    pTechnique.setStruct("points_omni_shadows", pLightUniforms.omniShadows);
				    pTechnique.setStruct("points_project_shadows", pLightUniforms.projectShadows);

				    for (var i:  number  = 0; i < pLightUniforms.textures.length; i++) {
				        pTechnique.setTextureBySemantics("TEXTURE" + i, pLightUniforms.textures[i]);
				    }

				    pTechnique.setShadowSamplerArray("project_shadow_sampler", pLightUniforms.samplersProject);
    				pTechnique.setShadowSamplerArray("omni_shadow_sampler", pLightUniforms.samplersOmni);

    				pTechnique.setVec2BySemantic("SCREEN_TEXTURE_RATIO",
                                     vec2(this.actualWidth / pDepthTexture.width, this.actualHeight / pDepthTexture.height));

				    pTechnique.setTextureBySemantics("DEFERRED_TEXTURE0", pDeferredTextures[0]);
				    pTechnique.setTextureBySemantics("DEFERRED_TEXTURE1", pDeferredTextures[1]);
				    pTechnique.setTextureBySemantics("SCENE_DEPTH_TEXTURE", pDepthTexture);

					break;
//case 1;
			}
		}

		private inline resetUniforms(): void {
			var pUniforms = this._pLightingUnifoms;
			pUniforms.omni.clear();
		    pUniforms.project.clear();
		    pUniforms.omniShadows.clear();
		    pUniforms.projectShadows.clear();
		    pUniforms.textures.clear();
		    pUniforms.samplersProject.clear();
		    pUniforms.samplersOmni.clear();
		}

		private createLightingUniforms(pCamera: ICamera, pLightPoints: ILightPoint[], pUniforms: UniformMap): void {
			var pLight: ILightPoint;
			var pOmniLight: IOmniLight;
			var pProjectLight: IProjectLight;
		    var i:  number , j:  number ;
		    var pUniformData: IUniform;
		    var pCameraView: IMat4 = pCamera.viewMatrix;

		    var v4fLightPosition: IVec4 = vec4();
		    var v3fLightTransformPosition: IVec3 = vec3();
		    var v4fTemp: IVec4 = vec4();

		    var pShadowCaster: IShadowCaster;
		    var m4fShadow: IMat4, m4fToLightSpace: IMat4;

		    var iLastTextureIndex:  number  = 0;
		    var sTexture: string = "TEXTURE";

		    this.resetUniforms();

		    for (i = 0; i < pLightPoints.length; i++) {
		        pLight = pLightPoints[i];

		        if (!pLight.enabled) {
		            continue;
		        }

		        v4fLightPosition.set(pLight.worldPosition, 1.);
		        pCameraView.multiplyVec4(v4fLightPosition, v4fTemp)
		        v3fLightTransformPosition.set(v4fTemp.x, v4fTemp.y, v4fTemp.z);

		        if (pLight.type === < number >EEntityTypes.LIGHT_OMNI_DIRECTIONAL) {

		        	pOmniLight = <IOmniLight>pLight;

		            if (pLight.isShadowCaster) {
		                pUniformData =  UniformOmniShadow.stackCeil ;
		                (<UniformOmniShadow>pUniformData).setLightData(pLight.params, v3fLightTransformPosition);

		                var pDepthCube: ITexture[] 					= pOmniLight.getDepthTextureCube();
		                var pShadowCasterCube: IShadowCaster[] 	= pOmniLight.getShadowCaster();
//var pOptimizedProjCube: IMat4[] 			= pOmniLight.optimizedProjectionCube;

		                for (j = 0; j < 6; ++ j) {
		                    pShadowCaster = pShadowCasterCube[j];
		                    m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix, mat4());
		                    pUniforms.textures.push(pDepthCube[j]);
		                    sTexture = "TEXTURE" + (pUniforms.textures.length - 1);

		                    (<UniformOmniShadow>pUniformData).setSampler(sTexture, j);
		                    pUniforms.samplersOmni.push((<UniformOmniShadow>pUniformData).SHADOW_SAMPLER[j]);
		                    (<UniformOmniShadow>pUniformData).setMatrix(m4fToLightSpace,pShadowCasterCube[j].optimizedProjection, j);
		                }

		                pUniforms.omniShadows.push(<UniformOmniShadow>pUniformData);
		            }
		            else {
		                pUniformData =  UniformOmni.stackCeil ;
		                (<UniformOmni>pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
		                pUniforms.omni.push(<UniformOmni>pUniformData);
		            }
		        }
		        else if (pLight.type === < number >EEntityTypes.LIGHT_PROJECT) {
		        	pProjectLight = <IProjectLight>pLight;

		            if (pLight.isShadowCaster) {
		                pUniformData =  UniformProjectShadow.stackCeil ;
		                (<UniformProjectShadow>pUniformData).setLightData(pLight.params, v3fLightTransformPosition);

		                pShadowCaster = pProjectLight.getShadowCaster();
		                m4fToLightSpace = pShadowCaster.viewMatrix.multiply(pCamera.worldMatrix, mat4());
		                pUniforms.textures.push(pProjectLight.getDepthTexture());
		                sTexture = "TEXTURE" + (pUniforms.textures.length - 1);

		                (<UniformProjectShadow>pUniformData).setSampler(sTexture);
		                pUniforms.samplersProject.push((<UniformProjectShadow>pUniformData).SHADOW_SAMPLER);
		                (<UniformProjectShadow>pUniformData).setMatrix(m4fToLightSpace, pShadowCaster.projectionMatrix, pShadowCaster.optimizedProjection);
		                pUniforms.projectShadows.push(<UniformProjectShadow>pUniformData);
		            }
		            else {
		                pUniformData =  UniformProject.stackCeil ;
		                (<UniformProject>pUniformData).setLightData(pLight.params, v3fLightTransformPosition);
		                pShadowCaster = pProjectLight.getShadowCaster();
		                m4fShadow = pShadowCaster.projViewMatrix.multiply(pCamera.worldMatrix, mat4());
		                (<UniformProject>pUniformData).setMatrix(m4fShadow);
		                pUniforms.project.push(<UniformProject>pUniformData);
		            }

		        }
		        else {
		        	logger.setSourceLocation( "DSViewport2.ts" , 363 ); logger.criticalError("Invalid light point type detected."); ;
		        }
		    }
		}
	}
}












/* Define the number of priority groups for the render system's render targets. */







module akra.render {

	export class RenderTarget implements IRenderTarget {
		/**@protected*/  _sName: string;
		/**@protected*/  _pRenderer: IRenderer;

		/**@protected*/  _iPriority:  number  =  4 ;

		/**@protected*/  _iWidth:  number ;
		/**@protected*/  _iHeight:  number ;

		/**@protected*/  _iColorDepth:  number ;
		/**@protected*/  _pDepthBuffer: IDepthBuffer = null;
		/**@protected*/  _pDepthPixelBuffer: IPixelBuffer = null;

		/**@protected*/  _pFrameStats: IFrameStats;

		/**@protected*/  _pTimer: IUtilTimer;
		/**@protected*/  _fLastSecond:  number ;
		/**@protected*/  _fLastTime:  number ;
		/**@protected*/  _iFrameCount:  number ;

		/**@protected*/  _isActive: bool = true;
		/**@protected*/  _isAutoUpdate: bool = true;

		/**@protected*/  _bHwGamma: bool = false;

		/**@protected*/  _pViewportList: IViewport[];


		inline get name(): string { return this._sName; }
		inline set name(sName: string) { this._sName = sName; }

		inline get width():  number  { return this._iWidth; }
		inline get height():  number  { return this._iHeight; }
		inline get colorDepth():  number  { return this._iColorDepth; }

		inline get totalViewports():  number  { return this._pViewportList.length; }
		inline get totalFrames():  number  { return this._iFrameCount; }

		inline get priority():  number  { return this._iPriority; }


		constructor (pRenderer: IRenderer) {
			this._pRenderer = pRenderer;
			this._pTimer = pRenderer.getEngine().getTimer();

			this.resetStatistics();
		}

		inline getRenderer(): IRenderer { return this._pRenderer; }

		destroy(): void {
			var pViewport: IViewport;

			for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];
				this.viewportRemoved(pViewport)
				pViewport.destroy();
			}

			this.detachDepthBuffer();

			logger.setSourceLocation( "render/RenderTarget.ts" , 88 ); logger.log("RenderTarget '%s'\n Average FPS: %s\n Best FPS: %s\n Worst FPS: %s", this._sName, this._pFrameStats.fps.avg, this._pFrameStats.fps.best, this._pFrameStats.fps.worst);
                                ;
		}

		getDepthBuffer(): IDepthBuffer {
			return this._pDepthBuffer;
		}

		attachDepthBuffer(pBuffer: IDepthBuffer): bool {
			var isOk: bool = false;

			if ((isOk = pBuffer.isCompatible(this))) {
				this.detachDepthBuffer();
				this._pDepthBuffer = pBuffer;
				this._pDepthBuffer._notifyRenderTargetAttached(this);
			}

			return isOk;
		}

		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool {

			if(this._iWidth !== pBuffer.width ||
			   this._iHeight !== pBuffer.height) {
				return false;
			}

			var eFormat: EPixelFormats = pBuffer.format;
			if(eFormat !== EPixelFormats.FLOAT32_DEPTH ||
			   eFormat !== EPixelFormats.DEPTH8){
				return false;
			}

			this.detachDepthPixelBuffer();
			this._pDepthPixelBuffer = pBuffer;

			return true;
		}

		detachDepthPixelBuffer(): void {
			if(this._pDepthPixelBuffer){
				this._pDepthPixelBuffer = null;
			}
		}

		detachDepthBuffer(): void {
			if (this._pDepthBuffer) {
				this._pDepthBuffer._notifyRenderTargetDetached( this );
				this._pDepthBuffer = null;
			}
		}

		attachDepthTexture(pTexture: ITexture): bool {
			return false;
		}

		detachDepthTexture(): void {

		}

		_detachDepthBuffer(): void {
			this._pDepthBuffer = null;
		}


		_beginUpdate(): void {
			this.preUpdate();

			this._pFrameStats.polygonsCount = 0;
		}

		_updateAutoUpdatedViewports(bUpdateStatistics: bool = true): void {
	        var pViewport: IViewport;

	        for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];

				if(pViewport.isAutoUpdated()) {
					this._updateViewport(pViewport, bUpdateStatistics);
				}
			}
		}

		_endUpdate(): void {
			this.postUpdate();
			this.updateStats();
		}

		_updateViewport(iZIndex:  number , bUpdateStatistics: bool = true): void;
		_updateViewport(pViewportPtr: IViewport, bUpdateStatistics: bool = true): void;
		_updateViewport(pViewportPtr: any, bUpdateStatistics: bool = true): void {
			var pViewport: IViewport;
			var iZIndex:  number

			if (isNumber(arguments[0])) {
				iZIndex = < number >arguments[0];
				pViewport = this._pViewportList[iZIndex];

				logger.setSourceLocation( "render/RenderTarget.ts" , 186 ); logger.assert(isDefAndNotNull(pViewport), "No viewport with given z-index : %s", iZIndex, "RenderTarget::_updateViewport");
                                     ;
			}
			else {
				pViewport = <IViewport>arguments[0];
			}

			logger.setSourceLocation( "render/RenderTarget.ts" , 193 ); logger.assert(pViewport.getTarget() == this, "RenderTarget::_updateViewport the requested viewport is not bound to the rendertarget!");
                                                                                             ;

			this.viewportPreUpdate(pViewport);

			pViewport.update();

			if (bUpdateStatistics) {
				this._pFrameStats.polygonsCount += pViewport._getNumRenderedPolygons();
			}

			this.viewportPostUpdate(pViewport);
		}

		addViewport(pCamera: ICamera, csRenderMethod: string = null, iZIndex:  number  = 0, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1.): IViewport;
		addViewport(pCamera: ICamera, eType:  number  = -1, iZIndex:  number  = 0, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1.): IViewport;
		addViewport(pCamera: ICamera, csRenderMethod: any = null, iZIndex:  number  = 0, fLeft:  number  = 0., fTop:  number  = 0., fWidth:  number  = 1., fHeight:  number  = 1.): IViewport {
			var pViewport: IViewport = this._pViewportList[iZIndex];

			if (isDefAndNotNull(pViewport)) {
				logger.setSourceLocation( "render/RenderTarget.ts" , 213 ); logger.criticalError("Can't create another viewport for %s with Z-index %s 					because a viewport exists with this Z-Order already.", this._sName, iZIndex, "RenderTarget::addViewport"); ;
			}

			if (isNumber(arguments[1]) && < number >arguments[1] >= 0) {
				pViewport = new DSViewport(pCamera, this, null, fLeft, fTop, fWidth, fHeight, iZIndex);
			}
			else {
				pViewport = new Viewport(pCamera, this, isNumber(arguments[1])? null: csRenderMethod,
					fLeft, fTop, fWidth, fHeight, iZIndex);
			}

			this._pViewportList[iZIndex] = pViewport;

			this.viewportAdded(pViewport);

			return pViewport;
		}


		removeViewport(iZIndex:  number ): bool {
			var pViewport: IViewport = this._pViewportList[iZIndex];

			if (isDefAndNotNull(pViewport)) {
				this.viewportRemoved(pViewport);

				this._pViewportList.splice(iZIndex, 1);
				pViewport = null;

				return true;
			}

			return false;
		}

		removeAllViewports():  number  {
			var pViewport: IViewport;
			var iTotal:  number ;

			for (var i in this._pViewportList) {
				pViewport = this._pViewportList[i];
	            this.viewportRemoved(pViewport);
	        }

	        iTotal = this._pViewportList.length;

        	(<any>this._pViewportList).clear();

        	return iTotal;
		}

		inline getStatistics(): IFrameStats {
			return this._pFrameStats;
		}

		inline getLastFPS():  number  {
			return this._pFrameStats.fps.last;
		}

		inline getAverageFPS():  number  {
			return this._pFrameStats.fps.avg;
		}

		inline getBestFPS():  number  {
			return this._pFrameStats.fps.best;
		}

		inline getWorstFPS():  number  {
			return this._pFrameStats.fps.worst;
		}

		inline getPolygonCount():  number  {
			return this._pFrameStats.polygonsCount;
		}

		inline getBestFrameTime():  number  {
			return this._pFrameStats.time.best;
		}

		inline getWorstFrameTime():  number  {
			return this._pFrameStats.time.worst;
		}

		resetStatistics(): void {
			var pStats: IFrameStats = this._pFrameStats;
			pStats.fps.avg = 0.;
			pStats.fps.best = 0.;
			pStats.fps.last = 0.;
			pStats.fps.worst = 999.;

			pStats.polygonsCount = 0;

			pStats.time.best = 9999999;
			pStats.time.worst = 0;

//FIXME: get right time!!!
			this._fLastTime = this._pTimer.appTime;
			this._fLastSecond = this._fLastTime;
			this._iFrameCount = 0;
		}

		updateStats(): void {
			this._iFrameCount ++;

			var fThisTime:  number  = this._pTimer.appTime;

			var fFrameTime:  number  = fThisTime - this._fLastTime;

			this._fLastTime = fThisTime;

			this._pFrameStats.time.best = math.min(this._pFrameStats.time.best, fFrameTime);
			this._pFrameStats.time.worst = math.min(this._pFrameStats.time.worst, fFrameTime);

			if (fThisTime - this._fLastTime > 1) {
				this._pFrameStats.fps.last = < number >this._iFrameCount / < number >(fThisTime - this._fLastSecond);

				if (this._pFrameStats.fps.avg == 0.) {
					this._pFrameStats.fps.avg = this._pFrameStats.fps.last;
				}
				else {
					this._pFrameStats.fps.avg = (this._pFrameStats.fps.avg + this._pFrameStats.fps.last) / 2.;

					this._pFrameStats.fps.best = math.max(this._pFrameStats.fps.best, this._pFrameStats.fps.last);
					this._pFrameStats.fps.worst = math.max(this._pFrameStats.fps.worst, this._pFrameStats.fps.last);

					this._fLastSecond = fThisTime;
					this._iFrameCount = 0;
				}
			}
		}

		getCustomAttribute(sName: string): any {
			return null;
		}

		getViewport(iIndex:  number ): IViewport {
			logger.setSourceLocation( "render/RenderTarget.ts" , 348 ); logger.assert(iIndex < this._pViewportList.length, "Index out of bounds"); ;

			for (var i in this._pViewportList) {
				if (iIndex --) {
					continue;
				}

				return this._pViewportList[i];
			}

			return null;
		}

		getViewportByZIndex(iZIndex:  number ): IViewport {
			var pViewport: IViewport = this._pViewportList[iZIndex];

			logger.setSourceLocation( "render/RenderTarget.ts" , 365 ); logger.assert(isDefAndNotNull(pViewport), "No viewport with given z-index : " + String(iZIndex), "RenderTarget::getViewportByZIndex");
                                                           ;

			return pViewport;
		}

		inline hasViewportByZIndex(iZIndex:  number ): bool {
			return isDefAndNotNull(this._pViewportList[iZIndex]);
		}

		inline isActive(): bool {
			return this._isActive;
		}

		setActive(bValue: bool = true): void {
			this._isActive = bValue;
		}

		inline setAutoUpdated(isAutoUpdate: bool = true): void {
			this._isAutoUpdate = isAutoUpdate;
		}

		_notifyCameraRemoved(pCamera: ICamera): void {
			var isRemoved: bool = false;
			for (var i in this._pViewportList) {
				var pViewport: IViewport = this._pViewportList[i];

				if (pViewport.getCamera() === pCamera) {
					pViewport.setCamera(null);
					isRemoved = true;
				}
			}

			if (isRemoved) {
				this.cameraRemoved(pCamera);
			}
		}

		inline setAutoUpdare(bValue: bool = true): void {
			this._isAutoUpdate = bValue;
		}

		inline isAutoUpdated(): bool {
			return this._isAutoUpdate;
		}

		inline isPrimary(): bool {
// RenderWindow will override and return true for the primary window
			return false;
		}

		update(): void {
			this.updateImpl();
		}

		readPixels(ppDest?: IPixelBox, eFramebuffer?: EFramebuffer): IPixelBox {
			return null;
		}


		/**@protected*/  updateImpl(): void {
			this._beginUpdate();
			this._updateAutoUpdatedViewports(true);
			this._endUpdate();
		}

		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return RenderTarget._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;

		preUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).preUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		viewportPreUpdate (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportPreUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
		viewportPostUpdate (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportPostUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
		viewportAdded (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportAdded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
		viewportRemoved (pViewport): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).viewportRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pViewport) : _broadcast[i].listener (_recivier, pViewport) ; } } } ; ;
		postUpdate (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).postUpdate; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ;

		cameraRemoved (pCamera): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).cameraRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pCamera) : _broadcast[i].listener (_recivier, pCamera) ; } } } ; ;
	}
}



module  akra.render {


	export var SShaderPrefixes = {
		k_Sampler    : "A_s_",
		k_Header     : "A_h_",
		k_Attribute  : "A_a_",
		k_Offset     : "A_o_",
		k_Texture    : "TEXTURE",
		k_Texcoord   : "TEXCOORD",
		k_Texmatrix  : "TEXMATRIX",
		k_Temp       : "TEMP_",
		k_BlendType  : "AUTO_BLEND_TYPE_"
	};

	export var ZEROSAMPLER:  number  = 19;

	export var SSystemSemantics = {
		MODEL_MATRIX: 		"MODEL_MATRIX",
		VIEW_MATRIX: 		"VIEW_MATRIX",
		PROJ_MATRIX: 		"PROJ_MATRIX",
		NORMAL_MATRIX: 		"NORMAL_MATRIX",
		BIND_MATRIX: 		"BIND_SHAPE_MATRIX",
		RENDER_OBJECT_ID: 	"RENDER_OBJECT_ID"
	}

	export interface IRenderTargetPriorityMap {
		[index:  number ]: IRenderTarget;
	}

	export class Renderer implements IRenderer {
		/**@protected*/  _isActive: bool = false;
		/**@protected*/  _pEngine: IEngine;
		/**@protected*/  _pRenderTargets: IRenderTarget[] = [];
		/**@protected*/  _pPrioritisedRenderTargets: IRenderTargetPriorityMap;

		constructor (pEngine: IEngine) {
			this._pEngine = pEngine;

			this.connect(pEngine,  "active" ,  "active" );
			this.connect(pEngine,  "inactive" ,  "inactive" );
		}


		inline getEngine(): IEngine { return this. _pEngine; }

	    hasCapability(eCapability: ERenderCapabilities): bool {
	      return false;
	    }


		debug(bValue?: bool, useApiTrace?: bool): bool {
			return false;
		}

		isDebug(): bool {
			return false;
		}

		isValid(): bool {
			return false;
		}

		inline getError(): string {
			return null;
		}

		clearFrameBuffer(iBuffer:  number , cColor: IColor, iDepth:  number ): void {

		}

 		attachRenderTarget(pTarget: IRenderTarget): bool {
 			for(var i:  number  = 0; i < this._pRenderTargets.length; i++){
       			if(this._pRenderTargets[i] === pTarget){
       				return false;
       			}
       		}

 			this._pRenderTargets.push(pTarget);
 			return true;
 		}

        detachRenderTarget(pTarget: IRenderTarget): bool {
       		for(var i:  number  = 0; i < this._pRenderTargets.length; i++){
       			if(this._pRenderTargets[i] === pTarget){
       				this._pRenderTargets.splice(i, 1);
       				return true;
       			}
       		}

       		return false;
        }

        destroyRenderTarget(pTarget: IRenderTarget): void {
        	var hasTarget: bool = this.detachRenderTarget(pTarget);
        	if(hasTarget){
        		pTarget.destroy();
        		pTarget = null;
        	}
        }

        getActiveProgram(): IShaderProgram {
        	logger.setSourceLocation( "render/Renderer.ts" , 133 ); logger.criticalError("Renderer::getActiveProgram() is uncompleted method!"); ;
        	return null;
        }

		inline _disableAllTextureUnits(): void {
			this._disableTextureUnitsFrom(0);
		}

		inline _disableTextureUnitsFrom(iUnit:  number ): void {

		}

		_initRenderTargets(): void {
// Init stats
	        for(var i:  number  = 0; i < this._pRenderTargets.length; ++ i) {
	            this._pRenderTargets[i].resetStatistics();
	        }
		}

		_updateAllRenderTargets(): void {
			var pTarget: IRenderTarget;
			for (var i in this._pPrioritisedRenderTargets) {
				pTarget = this._pPrioritisedRenderTargets[i];

				if (pTarget.isActive() && pTarget.isAutoUpdated()) {
					pTarget.update();
				}
			}
		}

		_setViewport(pViewport: IViewport): void {

		}

		_getViewport(): IViewport {
			return null;
		}

		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return Renderer._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		 active(pEngine: IEngine): void {
			this._isActive = true;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).active; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pEngine) : _broadcast[i].listener (_recivier, pEngine) ; } } ;
		}

		 inactive(pEngine: IEngine): void {
			this._isActive = false;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).inactive; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pEngine) : _broadcast[i].listener (_recivier, pEngine) ; } } ;
		}

	}
};





module akra.webgl {
	export class WebGLRenderer extends render.Renderer {
		private _pCanvas: HTMLCanvasElement;

		private _pWebGLContext: WebGLRenderingContext;
		private _pWebGLFramebufferList: WebGLFramebuffer[];

//real context, if debug context used
		private _pWebGLInternalContext: WebGLRenderingContext = null;

		constructor (pEngine: IEngine);
		constructor (pEngine: IEngine, sCanvas: string);
		constructor (pEngine: IEngine, pCanvas: HTMLCanvasElement);
		constructor (pEngine: IEngine, pCanvas?: any) {
			super(pEngine);

			if (isDef(pCanvas)) {

//get HTMLCanvasElement by id
				if (isString(pCanvas)) {
					this._pCanvas = <HTMLCanvasElement>document.getElementById(pCanvas);
				}
				else {
					this._pCanvas = <HTMLCanvasElement>pCanvas;
				}
			}
			else {
				this._pCanvas = <HTMLCanvasElement>document.createElement('canvas');
			}

			this._pWebGLContext = createContext(this._pCanvas);

			this._pWebGLFramebufferList = new Array( 32 );


			for (var i:  number  = 0; i < this._pWebGLFramebufferList.length; ++ i) {
				this._pWebGLFramebufferList[i] = this._pWebGLContext.createFramebuffer();
			}
		}

		debug(bValue: bool = true, useApiTrace: bool = false): bool {
			var pWebGLInternalContext: WebGLRenderingContext = this._pWebGLContext;

			if (bValue) {
				if (isDef((<any>window).WebGLDebugUtils) && !isNull(pWebGLInternalContext)) {

		            this._pWebGLContext = WebGLDebugUtils.makeDebugContext(pWebGLInternalContext,
		                (err:  number , funcName: string, args: IArguments): void => {
		                    throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName;
		                },
		                useApiTrace?
		                (funcName: string, args: IArguments): void => {
		                   logger.setSourceLocation( "WebGLRenderer.ts" , 61 ); logger.log("gl." + funcName + "(" + WebGLDebugUtils.glFunctionArgsToString(funcName, args) + ")"); ;
		                }: null);

		            this._pWebGLInternalContext = pWebGLInternalContext;

		            return true;
		        }
	        }
	        else if (this.isDebug()) {
	        	this._pWebGLContext = this._pWebGLInternalContext;
	        	this._pWebGLInternalContext = null;

	        	return true;
	        }

			return false;
		}



		isDebug(): bool {
			return !isNull(this._pWebGLInternalContext);
		}

		inline getHTMLCanvas(): HTMLCanvasElement {
			return this._pCanvas;
		}

		inline getWebGLContext(): WebGLRenderingContext {
			return this._pWebGLContext;
		}


/** Buffer Objects. */

		inline bindWebGLBuffer(eTarget:  number , pBuffer: WebGLBuffer): void {
			this._pWebGLContext.bindBuffer(eTarget, pBuffer);
		}

		inline createWebGLBuffer(): WebGLBuffer {
			return this._pWebGLContext.createBuffer();
		}

		inline deleteWebGLBuffer(pBuffer: WebGLBuffer): void {
			this._pWebGLContext.deleteBuffer(pBuffer);
		}

/** Texture Objects. */

		inline bindWebGLTexture(eTarget:  number , pTexture: WebGLTexture): void {
			this._pWebGLContext.bindTexture(eTarget, pTexture);
		}

		inline activateWebGLTexture(iSlot:  number ): void {
			this._pWebGLContext.activeTexture(iSlot);
		}

		inline createWebGLTexture(): WebGLTexture {
			return this._pWebGLContext.createTexture();
		}

		inline deleteWebGLTexture(pTexture: WebGLTexture): void {
			this._pWebGLContext.deleteTexture(pTexture);
		}

/** Framebuffer Objects */

		inline createWebGLFramebuffer(): WebGLFramebuffer {

			if (this._pWebGLFramebufferList.length === 0) {
				logger.setSourceLocation( "WebGLRenderer.ts" , 128 ); logger.criticalError("WebGL framebuffer limit exidit"); ;
			}

			return this._pWebGLFramebufferList.pop();
		}

		inline bindWebGLFramebuffer(eTarget:  number , pBuffer: WebGLFramebuffer): void {
			this._pWebGLContext.bindFramebuffer(eTarget, pBuffer);
		}

		inline deleteWebGLFramebuffer(pBuffer: WebGLFramebuffer): void {
			this._pWebGLFramebufferList.push(pBuffer);
		}

/** Renderbuffer Objects */

		inline createWebGLRenderbuffer(): WebGLRenderbuffer {
			return this._pWebGLContext.createRenderbuffer();
		}

		inline bindWebGLRenderbuffer(eTarget:  number , pBuffer: WebGLRenderbuffer): void {
			this._pWebGLContext.bindRenderbuffer(eTarget, pBuffer);
		}

		inline deleteWebGLRenderbuffer(pBuffer: WebGLRenderbuffer): void {
			this._pWebGLContext.deleteRenderbuffer(pBuffer);
		}


		inline createWebGLProgram(): WebGLProgram {
			return this._pWebGLContext.createProgram();
		}

		inline deleteWebGLProgram(pProgram: WebGLProgram): void {
			this._pWebGLContext.deleteProgram(pProgram);
		}

		inline useWebGLProgram(pProgram: WebGLProgram): void {
			this._pWebGLContext.useProgram(pProgram);
		}

		disableAllWebGLVertexAttribs(): void {

//TODO: check attrib array from last shader program
			var i: number  = 0;
			for(i = 0; i < maxVertexAttributes; i++) {
				this._pWebGLContext.disableVertexAttribArray(i);
			}

		}
	}
}











module akra.webgl {

	export function computeLog(iValue:  number ):  number  {
	    var i:  number  = 0;
/* Error! */

	    if (iValue === 0) return -1;

	    for (;;) {
	        if (iValue & 1) {
/* Error! */

	            if (iValue !== 1) return -1;
	                return i;
	        }
	        iValue = iValue >> 1;
	        i++;
	    }
	}

	export class WebGLTextureBuffer extends WebGLPixelBuffer implements IPixelBuffer {
		/**@protected*/  _eTarget:  number  = null;
		/**@protected*/  _eFaceTarget:  number  = null;
		/**@protected*/  _pWebGLTexture: WebGLTexture = null;
		/**@protected*/  _iFace:  number  = 0;
		/**@protected*/  _iLevel:  number  = 0;
		/**@protected*/  _bSoftwareMipmap: bool = false;
		/**@protected*/  _pRTTList: IRenderTexture[] = null;

		constructor () {
			super();
		}

		_clearRTT(iZOffset:  number ): void {
			this._pRTTList[iZOffset] = null;
		}

		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(eTarget:  number , pTexture: WebGLTexture, iWidth:  number , iHeight:  number , iInternalFormat:  number , iFormat:  number ,
			   iFace:  number , iLevel:  number , iFlags:  number , bSoftwareMipmap: bool): bool;
		create(): bool {
			if(arguments.length < 6) {
				logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 53 ); logger.criticalError("Invalid number of params. For WebGLTextureBuffer"); ;
			}

			var eTarget:  number  = arguments[0];
			var pTexture: WebGLTexture = arguments[1];
			var iWidth:  number  = arguments[2];
			var iHeight:  number  = arguments[3];
			var iInternalFormat:  number  = arguments[4];
			var iFormat:  number  = arguments[5];
			var iFace:  number  = arguments[6];
			var iLevel:  number  = arguments[7];
			var iFlags:  number  = arguments[8];
			var bSoftwareMipmap: bool = arguments[9];

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();

			pWebGLRenderer.bindWebGLTexture(eTarget, pTexture);

			this._eTarget = eTarget;
			this._pWebGLTexture = pTexture;
			this._iFace = iFace;
			this._iLevel = iLevel;
			this._bSoftwareMipmap = bSoftwareMipmap;

			this._eFaceTarget = eTarget;

			if(eTarget ===  0x8513 ){
				this._eFaceTarget =  0x8515  + iFace;
			}

			this._iWidth = iLevel === 0 ? iWidth : iWidth / Math.pow(2.0, iLevel);
			this._iHeight = iLevel === 0 ? iHeight : iHeight / Math.pow(2.0, iLevel);
			this._iDepth = 1;

			this._iWebGLInternalFormat = iInternalFormat;
			this._eFormat = webgl.getClosestAkraFormat(iInternalFormat, iFormat);


			this._iRowPitch = this._iWidth;
			this._iSlicePitch = this._iHeight * this._iWidth;
			this.byteLength = pixelUtil.getMemorySize(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

			this._pBuffer = new pixelUtil.PixelBox(this._iWidth, this._iHeight, this._iDepth, this._eFormat);

			if(this._iWidth === 0 || this._iHeight === 0 || this._iDepth === 0){
// We are invalid, do not allocate a buffer
				return false;
			}

// Is this a render target?
	        if ( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ) {
// Create render target for each slice
	            this._pRTTList = new WebGLRenderTexture[];
	            for(var iZOffset:  number  = 0; iZOffset < this._iDepth; ++iZOffset) {
	                var pRenderTexture: WebGLRenderTexture = new WebGLRenderTexture(pWebGLRenderer, this);
	                this._pRTTList.push(pRenderTexture);
	                pWebGLRenderer.attachRenderTarget(pRenderTexture);
	            }
	        }

	        var pProgram: IShaderProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_blit_texture_buffer");

	        if(isNull(pProgram)){
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_blit_texture_buffer");
	        	pProgram.create(
	        	"																									\n	        	attribute vec2 POSITION;																			\n				attribute vec3 TEXCOORD;																			\n				                      																				\n				varying vec3 texcoord;																				\n				                   																					\n				void main(void){																					\n				    texcoord = TEXCOORD;																			\n				    gl_Position = vec4(POSITION, 0., 1.);															\n				}																									\n				",
				"													\n				#ifdef GL_ES                        				\n				    precision highp float;          				\n				#endif												\n				varying vec3 texcoord;              				\n				uniform sampler2D uSampler;        					\n																	\n				void main(void) {  									\n					vec4 color;										\n					color = texture2D(uSampler, texcoord.xy);      	\n				    gl_FragColor = color;           				\n				}                                   				\n				");
	        }

			return true;
		}

		destroy(): void {
			if ( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ) {
// Delete all render targets that are not yet deleted via _clearSliceRTT because the rendertarget
// was deleted by the user.
	            var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
	            for (var i:  number  = 0; i < this._pRTTList.length; i++) {
	                pWebGLRenderer.destroyRenderTarget(this._pRTTList[i]);
	            }
	        }
    	}

//upload(download) data to(from) videocard.
		/**@protected*/  upload(pData: IPixelBox, pDestBox: IBox): void {
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

			if(pixelUtil.isCompressed(pData.format)) {
				if(pData.format !== this._eFormat || !pData.isConsecutive()){
					logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 167 ); logger.criticalError("Compressed images must be consecutive, in the source format"); ;
				}

				var iWebGLFormat:  number  = webgl.getClosestWebGLInternalFormat(this._eFormat);
// Data must be consecutive and at beginning of buffer as PixelStorei not allowed
// for compressed formats
            	if (pDestBox.left === 0 && pDestBox.top === 0) {
	                pWebGLContext.compressedTexImage2D(this._eFaceTarget, this._iLevel,
	                                       			   iWebGLFormat,
	                                       			   pDestBox.width,
	                                       			   pDestBox.height,
	                                       			   0,
	                                       			   pData.data);
	            }
	            else {
	                pWebGLContext.compressedTexSubImage2D(this._eFaceTarget, this._iLevel,
	                                          			  pDestBox.left, pDestBox.top,
	                                          			  pDestBox.width, pDestBox.height,
	                                          			  iWebGLFormat, pData.data);

	            }
			}
			else if(this._bSoftwareMipmap) {
				if (pData.width !== pData.rowPitch) {
// TODO
	                logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 192 ); logger.criticalError("Unsupported texture format"); ;
	            }

	            if (pData.height * pData.width !== pData.slicePitch) {
// TODO
	                logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 197 ); logger.criticalError("Unsupported texture format"); ;
	            }

	            pWebGLContext.pixelStorei( 0x0CF5 , 1);
	            this.buildMipmaps(pData);
			}
			else {
				if(pData.width !== pData.rowPitch) {
// TODO
	                logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 206 ); logger.criticalError("Unsupported texture format"); ;
	            }

	            if(pData.height * pData.width !== pData.slicePitch) {
// TODO
	                logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 211 ); logger.criticalError("Unsupported texture format"); ;
	            }

	            if ((pData.width * pixelUtil.getNumElemBytes(pData.format)) & 3) {
// Standard alignment of 4 is not right
	                pWebGLContext.pixelStorei( 0x0CF5 , 1);
	            }
	            if (pDestBox.left === 0 && pDestBox.top === 0) {
	            		pWebGLContext.texImage2D(this._eFaceTarget,
	                            			this._iLevel,
	                            			webgl.getWebGLFormat(pData.format),
	                            			pDestBox.width, pDestBox.height,0,
	                            			webgl.getWebGLFormat(pData.format),
	                            			webgl.getWebGLDataType(pData.format),
	                            			new Uint8Array(pData.data));
	            }
	            else
	            {
            		pWebGLContext.texSubImage2D(this._eFaceTarget,
                            			this._iLevel,
                            			pDestBox.left, pDestBox.top,
                            			pDestBox.width, pDestBox.height,
                            			webgl.getWebGLFormat(pData.format),
                            			webgl.getWebGLDataType(pData.format),
                            			pData.data);
	            }
	        }

	        if ( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0)  && !this._bSoftwareMipmap && (this._iLevel === 0)) {
	            pWebGLContext.generateMipmap(this._eFaceTarget);
	        }

	        pWebGLContext.pixelStorei( 0x0CF5 , 4);

	        this.notifyAltered();
		}

		/**@protected*/  download(pData: IPixelBox): void {
// if(data.getWidth() != getWidth() ||
//     data.getHeight() != getHeight() ||
//     data.getDepth() != getDepth())
//     OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, "only download of entire buffer is supported by GL",
//         "GLTextureBuffer::download");
// glBindTexture( mTarget, mTextureID );
// if(PixelUtil::isCompressed(data.format))
// {
//     if(data.format != mFormat || !data.isConsecutive())
//         OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, 
//         "Compressed images must be consecutive, in the source format",
//         "GLTextureBuffer::download");
//     // Data must be consecutive and at beginning of buffer as PixelStorei not allowed
//     // for compressed formate
//     glGetCompressedTexImageNV(mFaceTarget, mLevel, data.data);
// } 
// else
// {
//     if((data.getWidth()*PixelUtil::getNumElemBytes(data.format)) & 3) {
//         // Standard alignment of 4 is not right
//         glPixelStorei(GL_PACK_ALIGNMENT, 1);
//     }
//     // We can only get the entire texture
//     glGetTexImageNV(mFaceTarget, mLevel, 
//         GLES2PixelUtil::getGLOriginFormat(data.format), GLES2PixelUtil::getGLOriginDataType(data.format),
//         data.data);
//     // Restore defaults
//     glPixelStorei(GL_PACK_ALIGNMENT, 4);
// }
			logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 278 ); logger.criticalError("Downloading texture buffers is not supported by OpenGL ES"); ;
		}

		/**@protected*/  buildMipmaps(pData: IPixelBox): void {
			var iWidth:  number  = 0;
	        var iHeight:  number  = 0;
	        var iLogW:  number  = 0;
	        var iLogH:  number  = 0;
	        var iLevel:  number  = 0;
	        var pScaled: IPixelBox = new pixelUtil.PixelBox();

	        pScaled.data = pData.data;
	        pScaled.left = pData.left;
	        pScaled.right = pData.right;
	        pScaled.top = pData.top;
	        pScaled.bottom = pData.bottom;
	        pScaled.front = pData.front;
	        pScaled.back = pData.back;

	        iWidth = pData.width;
	        iHeight = pData.height;

	        iLogW = computeLog(iWidth);
	        iLogH = computeLog(iHeight);
	        iLevel = (iLogW > iLogH ? iLogW : iLogH);

	        var mip:  number  = 0;
	        var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

	        for (mip = 0; mip <= iLevel; mip++) {
	           	var iWebGLFormat:  number  = webgl.getWebGLFormat(pScaled.format);
	            var iWebGLDataType:  number  = webgl.getWebGLDataType(pScaled.format);

	            pWebGLContext.texImage2D(this._eFaceTarget,
	            						 mip,
	            						 iWebGLFormat,
	            						 iWidth, iHeight,
                         				 0,
	                         			 iWebGLFormat,
	                        			 iWebGLDataType,
	                        			 pScaled.data);

	            if (mip !== 0) {
	                pScaled.data = null;
	            }

	            if (iWidth > 1) {
	                iWidth = iWidth / 2;
	            }

	            if (iHeight > 1) {
	                iHeight = iHeight / 2;
	            }

	            var iSizeInBytes:  number  = pixelUtil.getMemorySize(iWidth, iHeight, 1, pData.format);
	            pScaled = new pixelUtil.PixelBox(iWidth, iHeight, 1, pData.format);
	            pScaled.data = new Uint8Array(iSizeInBytes);
	            pData.scale(pScaled, EFilters.LINEAR);
        	}

// Delete the scaled data for the last level

	        if (iLevel > 0) {
	            pScaled.data = null;
	        }
		}

		_bindToFramebuffer(iAttachment:  number , iZOffset:  number ): void {
			logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 347 ); logger.assert(iZOffset < this._iDepth); ;
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
			pWebGLContext.framebufferTexture2D( 0x8D40 , iAttachment, this._eFaceTarget, this._pWebGLTexture, this._iLevel);
		}

		_copyFromFramebuffer(iZOffset:  number ): void {
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
			pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel, 0, 0, 0, 0, this._iWidth, this._iHeight);
		}

		inline _getTarget():  number  {
			return this._eTarget;
		}

		inline _getWebGLTexture(): WebGLTexture {
			return this._pWebGLTexture;
		}

		blit(pSource: IPixelBuffer): bool;
		blit(pSource: IPixelBuffer, pSrcBox: IBox, pDestBox: IBox): bool;
		blit(pSource: IPixelBuffer, pSrcBox?: IBox, pDestBox?: IBox): bool {
			if (arguments.length == 1) {
				return this.blit(pSource,
		            new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth),
		            new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth)
		        );
			}
			else {
				var pSourceTexture: WebGLTextureBuffer = <WebGLTextureBuffer>pSource;
// TODO: Check for FBO support first
// Destination texture must be 2D or Cube
// Source texture must be 2D
				if (! (((pSourceTexture.getFlags()) & (ETextureFlags.RENDERTARGET)) != 0)  &&
					pSourceTexture._getTarget() ===  0x0DE1 ) {

					return this.blitFromTexture(pSourceTexture, pSrcBox, pDestBox);
				}
				else {
					return super.blit(pSource, pSrcBox, pDestBox);
				}
			}
		}

//-----------------------------------------------------------------------------  
// Very fast texture-to-texture blitter and hardware bi/trilinear scaling implementation using FBO
// Destination texture must be 1D, 2D, 3D, or Cube
// Source texture must be 1D, 2D or 3D
// Supports compressed formats as both source and destination format, it will use the hardware DXT compressor
// if available.
	    blitFromTexture(pSource: WebGLTextureBuffer, pSrcBox: IBox, pDestBox: IBox): bool {
	    	var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer._disableTextureUnitsFrom(0);
			pWebGLRenderer.activateWebGLTexture( 0x84C0 );

// Disable alpha, depth and scissor testing, disable blending, 
// and disable culling
        	pWebGLContext.disable( 0x0B71 );
	        pWebGLContext.disable( 0x0C11 );
	        pWebGLContext.disable( 0x0BE2 );
	        pWebGLContext.disable( 0x0B44 );

// Set up source texture
        	pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());

// Set filtering modes depending on the dimensions and source
	        if(pSrcBox.width === pDestBox.width &&
	           pSrcBox.height === pDestBox.height &&
	           pSrcBox.depth === pDestBox.depth) {
// Dimensions match -- use nearest filtering (fastest and pixel correct)
	            pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2600 );
	            pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2600 );
	        }
	        else {
// Dimensions don't match -- use bi or trilinear filtering depending on the
// source texture.
	            if( (((pSource.getFlags()) & (ETextureFlags.AUTOMIPMAP)) != 0) ) {
// Automatic mipmaps, we can safely use trilinear filter which
// brings greatly improved quality for minimisation.
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2703 );
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2601 );
	            }
	            else {
// Manual mipmaps, stay safe with bilinear filtering so that no
// intermipmap leakage occurs.
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2801 ,  0x2601 );
	                pWebGLContext.texParameteri(pSource._getTarget(),  0x2800 ,  0x2601 );
	            }
	        }
// Clamp to edge (fastest)
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2802 ,  0x812F );
	        pWebGLContext.texParameteri(pSource._getTarget(),  0x2803 ,  0x812F );

//Store old binding so it can be restored later
	        var pOldFramebuffer: WebGLFramebuffer = pWebGLContext.getParameter( 0x8CA6 );

	        var pFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
	        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pFramebuffer);

	        var pTempWebGLTexture: WebGLTexture = null;

	        if(!webgl.checkFBOAttachmentFormat(this._eFormat) || pSource === this){
// If target format not directly supported, create intermediate texture
	        	var iGLTempFormat:  number  = webgl.getClosestWebGLInternalFormat(webgl.getSupportedAlternative(this._eFormat));

	        	pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();
	        	pWebGLRenderer.bindWebGLTexture( 0x0DE1 , pTempWebGLTexture);
// Allocate temporary texture of the size of the destination area
	        	pWebGLContext.texImage2D( 0x0DE1 , 0, iGLTempFormat,
                         				 math.ceilingPowerOfTwo(pDestBox.width),
                         				 math.ceilingPowerOfTwo(pDestBox.height),
             				             0,  0x1908 ,  0x1401 , null);

	        	pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
                                      			   0x0DE1 , pTempWebGLTexture, 0);
// Set viewport to size of destination slice
	        	pWebGLContext.viewport(0, 0, pDestBox.width, pDestBox.height);
	        }
	        else {
// We are going to bind directly, so set viewport to size and position of destination slice
	        	pWebGLContext.viewport(pDestBox.left, pDestBox.top, pDestBox.width, pDestBox.height);
	        }

//Get WebGL program
	        var pWebGLShaderProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_blit_texture_buffer");
	        pWebGLRenderer.disableAllWebGLVertexAttribs();
	        pWebGLRenderer.useWebGLProgram(pWebGLShaderProgram);

	        var iPosAttrIndex:  number  = 0;
	        var iTexAttrIndex:  number  = 0;

	        iPosAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("POSITION");
	        iTexAttrIndex = pWebGLShaderProgram.getWebGLAttributeLocation("TEXCOORD");

	        pWebGLContext.enableVertexAttribArray(iPosAttrIndex);
	        pWebGLContext.enableVertexAttribArray(iTexAttrIndex);

	        var pSquareVertices: Float32Array = new Float32Array([ -1.0, -1.0,
											                		1.0, -1.0,
											               		   -1.0,  1.0,
											                		1.0,  1.0 ]);
	        var pTexCoords: Float32Array = new Float32Array(12);

	        var pPositionBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();
	        var pTexCoordsBuffer: WebGLBuffer = pWebGLRenderer.createWebGLBuffer();

	        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pPositionBuffer);
	        pWebGLContext.bufferData( 0x8892 , pSquareVertices,  0x88E0 );
            pWebGLContext.vertexAttribPointer(iPosAttrIndex, 2,  0x1406 , false, 0, 0);

            pWebGLShaderProgram.setInt("uSampler", 0);

// Process each destination slice
	        var iSlice:  number  = 0;
	        for(iSlice = pDestBox.front; iSlice < pDestBox.back; ++iSlice) {
	            if(isNull(pTempWebGLTexture)) {
// Bind directly
	                this._bindToFramebuffer( 0x8CE0 , iSlice);
	            }

/// Calculate source texture coordinates
	            var u1:  number  = < number >pSrcBox.left / < number >pSource.width;
	            var v1:  number  = < number >pSrcBox.top / < number >pSource.height;
	            var u2:  number  = < number >pSrcBox.right / < number >pSource.width;
	            var v2:  number  = < number >pSrcBox.bottom / < number >pSource.height;
/// Calculate source slice for this destination slice
	            var w:  number  = < number >(iSlice - pDestBox.front) / < number >pDestBox.depth;
/// Get slice # in source
	            w = w * < number >pSrcBox.depth + pSrcBox.front;
/// Normalise to texture coordinate in 0.0 .. 1.0
	            w = (w + 0.5) / < number >pSource.depth;

	            pTexCoords[0] = u1;
	            pTexCoords[1] = v1;
	            pTexCoords[2] = w;

	            pTexCoords[3] = u2;
	            pTexCoords[4] = v1;
	            pTexCoords[5] = w;

	            pTexCoords[6] = u2;
	            pTexCoords[7] = v2;
	            pTexCoords[8] = w;

  	            pTexCoords[9]  = u1;
	            pTexCoords[10] = v2;
	            pTexCoords[11] = w;

/// Finally we're ready to rumble	
	            pWebGLRenderer.bindWebGLTexture(pSource._getTarget(), pSource._getWebGLTexture());

	            pWebGLContext.enable(pSource._getTarget());

	            pWebGLRenderer.bindWebGLBuffer( 0x8892 , pTexCoordsBuffer);
		        pWebGLContext.bufferData( 0x8892 , pTexCoords,  0x88E0 );
	            pWebGLContext.vertexAttribPointer(iTexAttrIndex, 3,  0x1406 , false, 0, 0);

	            pWebGLContext.drawArrays( 0x0005 , 0, 4);
	            pWebGLContext.disable(pSource._getTarget());


	            if(!isNull(pTempWebGLTexture)) {
	            	if(pSource === this) {
//set width, height and _pWebGLTexture
	            		pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

	            		this._pWebGLTexture = pTempWebGLTexture;
	            		this._iWidth = math.ceilingPowerOfTwo(pDestBox.width);
	            		this._iHeight = math.ceilingPowerOfTwo(pDestBox.height);
	            	}
	            	else {
// Copy temporary texture
		                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

		                switch(this._eTarget) {
		                    case  0x0DE1 :
		                    case  0x8513 :
		                        pWebGLContext.copyTexSubImage2D(this._eFaceTarget, this._iLevel,
		                                            			pDestBox.left, pDestBox.top,
		                                           				0, 0, pDestBox.width, pDestBox.height);
		                        break;
		                }
	            	}
	            }
	        }

	        pWebGLContext.disableVertexAttribArray(iPosAttrIndex);
	        pWebGLContext.disableVertexAttribArray(iTexAttrIndex);

	        pWebGLRenderer.deleteWebGLBuffer(pPositionBuffer);
	        pWebGLRenderer.deleteWebGLBuffer(pTexCoordsBuffer);

// Finish up 
	        if(!isNull(pTempWebGLTexture)) {
// Generate mipmaps
	            if( (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0) ) {
	                pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);
	                pWebGLContext.generateMipmap(this._eTarget);
	            }
	        }

// Reset source texture to sane state
	        pWebGLRenderer.bindWebGLTexture(this._eTarget, this._pWebGLTexture);

// Detach texture from temporary framebuffer
	        pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8CE0 ,
	                                  			  0x8D41 , null);
// Restore old framebuffer
	        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pOldFramebuffer);
	        if(pSource !== this) {
	        	pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
	    	}
	        pWebGLRenderer.deleteWebGLFramebuffer(pFramebuffer);

	        pTempWebGLTexture = null;
	        this.notifyAltered();

	    	return true;
	    }

		blitFromMemory(pSource: IPixelBox): bool;
		blitFromMemory(pSource: IPixelBox, pDestBox?: IBox): bool;
		blitFromMemory(): bool {
			if(arguments.length === 1){
				return super.blitFromMemory(arguments[0]);
			}

// Fall back to normal GLHardwarePixelBuffer::blitFromMemory in case 
// - FBO is not supported
// - Either source or target is luminance due doesn't looks like supported by hardware
// - the source dimensions match the destination ones, in which case no scaling is needed
// TODO: Check that extension is NOT available

			var pSourceOrigin: IPixelBox = arguments[0];
			var pDestBox: IBox = arguments[1];

			if(pixelUtil.isLuminance(pSourceOrigin.format) ||
	           pixelUtil.isLuminance(this._eFormat) ||
	           (pSourceOrigin.width === pDestBox.width &&
	            pSourceOrigin.height === pDestBox.height &&
	            pSourceOrigin.depth === pDestBox.depth)) {

	            return super.blitFromMemory(pSourceOrigin, pDestBox);
	        }

	        if(!this._pBuffer.contains(pDestBox)) {
	            logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 638 ); logger.criticalError("Destination box out of range"); ;
	        }

		    var pSource: IPixelBox;
// First, convert the srcbox to a OpenGL compatible pixel format
	        if(getWebGLFormat(pSourceOrigin.format) === 0){
// Convert to buffer internal format
	        	var iSizeInBytes:  number  = pixelUtil.getMemorySize(pSourceOrigin.width, pSourceOrigin.height,
	        													pSourceOrigin.depth, this._eFormat);
	        	pSource = new pixelUtil.PixelBox(pSourceOrigin.width, pSourceOrigin.height,
	        									 pSourceOrigin.depth, this._eFormat, new Uint8Array(iSizeInBytes));

	        	pixelUtil.bulkPixelConversion(pSourceOrigin, pSource);
	        }
	        else {
// No conversion needed
	        	pSource = pSourceOrigin;
	        }

	        var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

// Create temporary texture to store source data
	        var pTempWebGLTexture: WebGLTexture = null;
	        var eTarget:  number  =  0x0DE1 ;
	        var iWidth:  number  = math.ceilingPowerOfTwo(pSource.width);
	        var iHeight:  number  = math.ceilingPowerOfTwo(pSource.height);
	        var iWebGLFormat: number  = getClosestWebGLInternalFormat(pSource.format);
	        var iWebGLDataType:  number  = getWebGLDataType(pSource.format);

	        pTempWebGLTexture = pWebGLRenderer.createWebGLTexture();

	        if(isNull(pTempWebGLTexture)){
	        	logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 671 ); logger.error("Can not create WebGL texture"); ;
	        	return false;
	        }

	        pWebGLRenderer.bindWebGLTexture(eTarget, pTempWebGLTexture);
	        pWebGLContext.texImage2D(eTarget, 0, iWebGLFormat, iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);

	        var pTextureBufferPool: IResourcePool = this.getManager().textureBufferPool;
	        var pTempTexBuffer: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(".temp");

	        pTempTexBuffer.create(eTarget, pTempWebGLTexture, iWidth, iHeight,
								  iWebGLFormat, pSource.format, 0, 0,
								  ETextureFlags.AUTOMIPMAP | EHardwareBufferFlags.STATIC,
								  false);

// Upload data to 0,0,0 in temporary texture
	        var pTempBoxTarget: IBox = new geometry.Box(0, 0, 0, pSource.width, pSource.height, pSource.depth);
	        pTempTexBuffer.upload(pSource, pTempBoxTarget);

//Blit
	        this.blitFromTexture(pTempTexBuffer, pTempBoxTarget, pDestBox);

//Delete temp data
	        pTextureBufferPool.destroyResource(pTempTexBuffer);

	        pWebGLRenderer.deleteWebGLTexture(pTempWebGLTexture);
	        pTempWebGLTexture = null;
	        pTempBoxTarget = null;

			return true;
		}

		getRenderTarget(): IRenderTarget;
		getRenderTarget(iZOffest:  number ): IRenderTarget;
		getRenderTarget(iZOffest?:  number  = 0): IRenderTarget {
			logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 706 ); logger.assert( (((this._iFlags) & (ETextureFlags.RENDERTARGET)) != 0) ); ;
        	logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 707 ); logger.assert(iZOffest < this._iDepth); ;
        	return this._pRTTList[iZOffest];
		}

		resize(iSize:  number ): bool;
		resize(iWidth:  number , iHeight?:  number ): bool {
			if(arguments.length === 1){
				logger.setSourceLocation( "webgl/WebGLTextureBuffer.ts" , 714 ); logger.criticalError("resize with one parametr not available for WebGLTextureBuffer"); ;
				return false;
			}
			var pSrcBox: IBox = new geometry.Box(0, 0, 0, this._iWidth, this._iHeight, this._iDepth);
			var pDestBox: IBox = new geometry.Box(0, 0, 0, iWidth, iHeight, this._iDepth);

			return this.blitFromTexture(this, pSrcBox, pDestBox);
		}

	}
}





module akra.webgl {
	export class WebGLInternalTexture extends core.pool.resources.Texture {
		private _pSurfaceList: WebGLTextureBuffer[] = null;
		private _pWebGLTexture: WebGLTexture = null;

		constructor () {
            super();
        }

        private _getWebGLTextureTarget():  number  {
        	switch(this._eTextureType) {
        		case ETextureTypes.TEXTURE_2D:
        			return  0x0DE1 ;
        		case ETextureTypes.TEXTURE_CUBE_MAP:
        			return  0x8513 ;
        		default:
        			return 0;
        	}
        }

        private _getWebGLTextureParameter(eParam: ETextureParameters): number
        {
        	switch(eParam) {
        		case ETextureParameters.MAG_FILTER:
        			return  0x2800 ;
        		case ETextureParameters.MIN_FILTER:
        			return  0x2801 ;
        		case ETextureParameters.WRAP_S:
        			return  0x2802 ;
        		case ETextureParameters.WRAP_T:
        			return  0x2803 ;
        		default:
        			return 0;
        	}
        }


        private _getWebGLTextureParameterValue(eValue: ETextureFilters): number ;
        private _getWebGLTextureParameterValue(eValue: ETextureWrapModes): number ;
        private _getWebGLTextureParameterValue(eValue: any): number
        {
        	switch(eValue) {
        		case ETextureFilters.NEAREST:
        			return  0x2600 ;
        		case ETextureFilters.LINEAR:
        			return  0x2601 ;
        		case ETextureFilters.NEAREST_MIPMAP_NEAREST:
        			return  0x2700 ;
        		case ETextureFilters.LINEAR_MIPMAP_NEAREST:
        			return  0x2701 ;
        		case ETextureFilters.NEAREST_MIPMAP_LINEAR:
        			return  0x2702 ;
        		case ETextureFilters.LINEAR_MIPMAP_LINEAR:
        			return  0x2703 ;


        		case ETextureWrapModes.REPEAT:
        			return  0x2901 ;
        		case ETextureWrapModes.CLAMP_TO_EDGE:
        			return  0x812F ;
        		case ETextureWrapModes.MIRRORED_REPEAT:
        			return  0x8370 ;
        		default:
        			return 0;
        	}
        }




        /**@protected*/  _setFilterInternalTexture(eParam: ETextureParameters, eValue: ETextureFilters): bool{
             if (!this.isValid()) {
                return false;
            }
            var iWebGLTarget:  number  = this._getWebGLTextureTarget();
            var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
            pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(eParam), this._getWebGLTextureParameterValue(eValue));
            return true;
        }
        /**@protected*/  _setWrapModeInternalTexture(eParam: ETextureParameters, eValue: ETextureWrapModes): bool{
             if (!this.isValid()) {
                return false;
            }
            var iWebGLTarget:  number  = this._getWebGLTextureTarget();
            var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
            pWebGLContext.texParameteri(iWebGLTarget, this._getWebGLTextureParameter(eParam), this._getWebGLTextureParameterValue(eValue));
            return true;
        }

        /**@protected*/  _getFilterInternalTexture(eParam: ETextureParameters): ETextureFilters{
            if (!this.isValid()) {
                return 0;
            }
            var iWebGLTarget:  number  = this._getWebGLTextureTarget();
            var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
            return pWebGLContext.getTexParameter(iWebGLTarget, this._getWebGLTextureParameter(eParam));
        }

        /**@protected*/  _getWrapModeInternalTexture(eParam: ETextureParameters): ETextureWrapModes{
            if (!this.isValid()) {
                return 0;
            }
            var iWebGLTarget:  number  = this._getWebGLTextureTarget();
            var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();
            var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
            pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);
            return pWebGLContext.getTexParameter(iWebGLTarget, this._getWebGLTextureParameter(eParam));
        }


        /**@protected*/  _createInternalTextureImpl(cFillColor?: IColor = null): bool
        {
        	if(!isNull(cFillColor))
        	{
        		logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 134 ); logger.warning("Texture can create with filled only by default(black) color"); ;
//TODO: must implement filling by color
        	}


        	var pWebGLRenderer: webgl.WebGLRenderer = <webgl.WebGLRenderer>this.getManager().getEngine().getRenderer();

			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();


            if(this._eTextureType==ETextureTypes.TEXTURE_2D)
            {
                if(this._iWidth>webgl.maxTextureSize)
                {
                	logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 148 ); logger.warning("Заданная ширина не поддерживается("+this._iWidth+")"); ;
                	this._iWidth=webgl.maxTextureSize;
                }
                if(this._iHeight>webgl.maxTextureSize)
                {
                    logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 153 ); logger.warning("Заданная высота не поддерживается("+this._iHeight+")"); ;
                    this._iHeight=webgl.maxTextureSize;

                }
            }
            else if( this._eTextureType==ETextureTypes.TEXTURE_CUBE_MAP)
            {
                if(this._iWidth>webgl.maxCubeMapTextureSize)
                {
                	logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 162 ); logger.warning("Заданная ширина не поддерживается("+this._iWidth+")"); ;
                	this._iWidth=webgl.maxCubeMapTextureSize;
                }
                if(this._iHeight>webgl.maxCubeMapTextureSize)
                {
                    logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 167 ); logger.warning("Заданная высота не поддерживается("+this._iHeight+")"); ;
                    this._iHeight=webgl.maxCubeMapTextureSize;

                }
            }

            if(this._iWidth==0)
            {
            	logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 175 ); logger.warning("Заданная ширина не поддерживается("+this._iWidth+")"); ;
                this._iWidth=1;

            }
            if(this._iHeight==0)
            {
                logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 181 ); logger.warning("Заданная высота не поддерживается("+this._iHeight+")"); ;
                this._iHeight=1;
            }
            if(this._iDepth!=1)
            {
            	this._iDepth=1;
                logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 187 ); logger.warning("Трехмерные текстуры не поддерживаются, сброс глубины в 1"); ;
            }
            if(!webgl.hasExtension( "EXT_texture_npot_2D_mipmap" ) &&(!math.isPowerOfTwo(this._iDepth)||!math.isPowerOfTwo(this._iHeight)||!math.isPowerOfTwo(this._iWidth)))
            {
                logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 191 ); logger.warning("Мип мапы у текстуры не стпени двойки не поддерживаются, сброс мипмапов в 0"); ;
                this._nMipLevels=0;
                ((this._iFlags) &= ~(ETextureFlags.AUTOMIPMAP)) ;
            }






            if(!webgl.isWebGLFormatSupport(this._eFormat))
            {
                logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 203 ); logger.warning("Данный тип текстуры не поддерживается"); ;
                this._eFormat=EPixelFormats.A8B8G8R8;
            }


            if (this._nMipLevels!=0 && this._nMipLevels!=akra.core.pool.resources.Img.getMaxMipmaps(this._iWidth, this._iHeight, this._iDepth, this._eFormat))
            {
                logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 210 ); logger.warning("Нехватает мипмапов, сброс в 0"); ;
                this._nMipLevels=0;
            }


// Convert to nearest power-of-two size if required
//this._iWidth = math.ceilingPowerOfTwo(this._iWidth);
//this._iHeight = math.ceilingPowerOfTwo(this._iHeight);
//this._iDepth = math.ceilingPowerOfTwo(this._iDepth);


            var iWebGLTarget:  number  = this._getWebGLTextureTarget();

	        this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();

	        pWebGLRenderer.bindWebGLTexture(iWebGLTarget, this._pWebGLTexture);

	        this._isMipmapsHardwareGenerated = pWebGLRenderer.hasCapability(ERenderCapabilities.AUTOMIPMAP);

// Set some misc default parameters, these can of course be changed later
	        this.setFilter(ETextureParameters.MIN_FILTER, ETextureFilters.NEAREST);
	        this.setFilter(ETextureParameters.MAG_FILTER, ETextureFilters.NEAREST);
	        this.setWrapMode(ETextureParameters.WRAP_S, ETextureWrapModes.CLAMP_TO_EDGE);
	        this.setWrapMode(ETextureParameters.WRAP_T, ETextureWrapModes.CLAMP_TO_EDGE);

	        var iWebGLFormat:  number  = webgl.getWebGLFormat(this._eFormat);
	        var iWebGLDataType:  number  = webgl.getWebGLDataType(this._eFormat);
	        var iWidth:  number  = this._iWidth;
	        var iHeight:  number  = this._iHeight;
	        var iDepth:  number  = this._iDepth;

	        if (pixelUtil.isCompressed(this._eFormat))
	        {
// Compressed formats
	            var iSize:  number  = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);

// Provide temporary buffer filled with zeroes as glCompressedTexImageXD does not
// accept a 0 pointer like normal glTexImageXD
// Run through this process for every mipmap to pregenerate mipmap pyramid


	            var pTmpData: Uint8Array = new Uint8Array(iSize);
	            var pEmptyData: Uint8Array;
	            var mip:  number  = 0;

	            for (mip = 0; mip <= this._nMipLevels; mip++) {

	                iSize = pixelUtil.getMemorySize(iWidth, iHeight, iDepth, this._eFormat);
//console.log(iSize,iWidth, iHeight, iDepth, this._eFormat);
	                pEmptyData = pTmpData.subarray(0, iSize);
					switch(this._eTextureType)
                    {

						case ETextureTypes.TEXTURE_2D:
	                        pWebGLContext.compressedTexImage2D( 0x0DE1 , mip, iWebGLFormat,
	                        								   iWidth, iHeight, 0, pEmptyData);
	                        break;
						case ETextureTypes.TEXTURE_CUBE_MAP:
							var iFace:  number  = 0;
							for(iFace = 0; iFace < 6; iFace++) {
								pWebGLContext.compressedTexImage2D( 0x8515  + iFace, mip, iWebGLFormat,
																   iWidth, iHeight, 0, pEmptyData);
							}
							break;
	                    default:
	                        break;

	                };
	                if(iWidth > 1) iWidth = iWidth / 2;
	                if(iHeight > 1) iHeight = iHeight / 2;
	                if(iDepth > 1) iDepth = iDepth / 2;

	            }
	            pTmpData = null;
	            pEmptyData = null;
	        }
	        else {
	        	var mip:  number  = 0;
// Run through this process to pregenerate mipmap pyramid
	            for (mip = 0; mip <= this._nMipLevels; mip++) {
// Normal formats
					switch(this._eTextureType){
						case ETextureTypes.TEXTURE_2D:
//console.log(mip,iWidth, iHeight);
	                        pWebGLContext.texImage2D( 0x0DE1 , mip, iWebGLFormat,
	                                     			 iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
	                        break;
						case ETextureTypes.TEXTURE_CUBE_MAP:
							var iFace:  number  = 0;
							for(iFace = 0; iFace < 6; iFace++) {
								pWebGLContext.texImage2D( 0x8515  + iFace, mip, iWebGLFormat,
	                                     			 	 iWidth, iHeight, 0, iWebGLFormat, iWebGLDataType, null);
							}
							break;
	                    default:
	                        break;
	                }

	                if(iWidth > 1) iWidth = iWidth >>> 1;
	                if(iHeight > 1) iHeight = iHeight >>> 1;
	                if(iDepth > 1) iDepth = iDepth >>> 1;
	            }
	        }
	        this._createSurfaceList();

            return true;
        }

        /**@protected*/  freeInternalTextureImpl(): bool {
        	var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);
			this._pWebGLTexture = null;

			for(var i:  number  = 0; i < this._pSurfaceList.length; i++) {
				this._pSurfaceList[i].release();
			}

			this._pSurfaceList = null;

            return true;
        }

        private _createSurfaceList(): void {
        	this._pSurfaceList = new Array();

// For all faces and mipmaps, store surfaces as IPixelBuffer
        	var bWantGeneratedMips: bool =  (((this._iFlags) & (ETextureFlags.AUTOMIPMAP)) != 0) ;

// Do mipmapping in software? (uses GLU) For some cards, this is still needed. Of course,
// only when mipmap generation is desired.
        	var bDoSoftware: bool = bWantGeneratedMips && !this._isMipmapsHardwareGenerated && this._nMipLevels !== 0;

        	var iFace:  number  = 0;
        	var mip:  number  = 0;
        	var pTextureBufferPool: IResourcePool = this.getManager().textureBufferPool;
        	var sResourceName: string = this.findResourceName();

        	for(iFace = 0; iFace < this.getNumFaces(); iFace++) {
        		var iWidth:  number  = this._iWidth;
        		var iHeight:  number  = this._iHeight;



        		for(mip = 0; mip <= this._nMipLevels; mip++) {
        			var pBuf: WebGLTextureBuffer = <WebGLTextureBuffer>pTextureBufferPool.createResource(sResourceName + "_" + iFace + "_" + mip);


                    pBuf.create(this._getWebGLTextureTarget(),
        						this._pWebGLTexture,
        						iWidth, iHeight,
        						webgl.getClosestWebGLInternalFormat(this._eFormat),
        						webgl.getWebGLDataType(this._eFormat),
        						iFace,
        						mip,
        						this._iFlags,
        						bDoSoftware && mip === 0);

        			this._pSurfaceList.push(pBuf);

//check error
        			if(pBuf.width === 0 ||
        			   pBuf.height === 0 ||
        			   pBuf.depth === 0) {
        				logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 378 ); logger.criticalError("Zero sized texture surface on texture " + sResourceName + " face " + iFace + " mipmap " + mip + ". The GL driver probably refused to create the texture.");
                                                                                        ;
        			}

        		}
        	}
        }

        getBuffer(iFace?:  number  = 1, iMipmap?:  number  = 0): IPixelBuffer {
            if (iFace >= this.getNumFaces()) {
	            logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 387 ); logger.criticalError("Face index out of range",iFace,this.getNumFaces()); ;
	        }

	        if (iMipmap > this._nMipLevels) {
	            logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 391 ); logger.criticalError("Mipmap index out of range",iMipmap,this._nMipLevels); ;
	        }

	        var idx:  number  = iFace * (this._nMipLevels + 1) + iMipmap;
	        logger.setSourceLocation( "webgl/WebGLInternalTexture.ts" , 395 ); logger.assert(idx < this._pSurfaceList.length,"smth"); ;

	        return this._pSurfaceList[idx];
        }


        createRenderTexture(): bool {
// Create the GL texture
// This already does everything necessary
            return this.createInternalTexture();
        }

	}
}


































module akra {
	export interface IBufferDataModifier {
		(pData: ArrayBufferView): void;
	}
}







module akra.data {

	enum EVertexDataLimits {
		k_MaxElementsSize = 256
	};

	export class VertexData implements IVertexData {
		private _pVertexBuffer: IVertexBuffer;
		private _iOffset:  number ;
		private _iStride:  number ;
		private _iLength:  number ;
		private _pVertexDeclaration: VertexDeclaration;
		private _iId:  number ;

		inline get id():  number  { return this._iId; }
		inline get length():  number  { return this._iLength; };
		inline get byteOffset():  number  { return this._iOffset; };
		inline get byteLength():  number  { return this._iLength * this._iStride; };
		inline get buffer(): IVertexBuffer { return this._pVertexBuffer; };
		inline get stride():  number  { return this._iStride; };
		inline get startIndex():  number  {
			var iIndex:  number  = this.byteOffset / this.stride;
    		logger.setSourceLocation( "data/VertexData.ts" , 34 ); logger.assert(iIndex % 1 == 0, "cannot calc first element index"); ;
   			return iIndex;
   		};


		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , nSize:  number );
		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , pDecl: IVertexDeclaration);
		constructor (pVertexBuffer: IVertexBuffer, id:  number , iOffset:  number , iCount:  number , pDecl: any) {

			this._pVertexBuffer = pVertexBuffer;
			this._iOffset = iOffset;
			this._iLength = iCount;
			this._iId = id;
			this._pVertexDeclaration = null;
			this._iStride = 0;

			if (isInt(pDecl)) {
				this._iStride = < number >pDecl;
			}
			else {
				this._iStride = pDecl.stride;
				this.setVertexDeclaration(pDecl);
			}

			logger.setSourceLocation( "data/VertexData.ts" , 59 ); logger.assert(pVertexBuffer.byteLength >= this.byteLength + this.byteOffset, "vertex data out of array linits");
                                      ;
		}


		getVertexDeclaration(): VertexDeclaration {
			return this._pVertexDeclaration;
		}

		setVertexDeclaration(pDecl: IVertexDeclaration): bool {
			if (this._pVertexDeclaration) {
				logger.setSourceLocation( "data/VertexData.ts" , 69 ); logger.error("vertex declaration already exists"); ;

				return false;
			}

			var iStride:  number  = pDecl.stride;

		    this._pVertexDeclaration = <VertexDeclaration>pDecl.clone();


		    logger.setSourceLocation( "data/VertexData.ts" , 80 ); logger.assert(iStride < <number>EVertexDataLimits.k_MaxElementsSize, "stride max is 255 bytes");
                                 ;
		    logger.setSourceLocation( "data/VertexData.ts" , 82 ); logger.assert(iStride <= this.stride, "stride in VertexDeclaration grather than stride in construtor");
                                                                       ;

		    return true;
		}

		inline getVertexElementCount():  number  {
			return this._pVertexDeclaration.length;
		}

		hasSemantics(sUsage: string): bool {
			if (this._pVertexDeclaration != null) {
		        return this._pVertexDeclaration.hasSemantics(sUsage);
		    }

		    return false;
		}

		destroy(): void {
			this._pVertexDeclaration = null;
    		this._iLength = 0;
		}

		extend(pDecl: IVertexDeclaration, pData: ArrayBufferView = null): bool {
			pDecl = createVertexDeclaration(pDecl);

			if (isNull(pData)) {
				pData = new Uint8Array(this.length * pDecl.stride);
			}
			else {
				pData = new Uint8Array(pData.buffer);
			}

		    logger.setSourceLocation( "data/VertexData.ts" , 114 ); logger.assert(this.length === pData.byteLength / pDecl.stride, 'invalid data size for extending'); ;

		    var nCount:  number  = this._iLength;
//strides modifications
		    var nStrideNew:  number  = pDecl.stride;
		    var nStridePrev:  number  = this.stride;
		    var nStrideNext:  number  = nStridePrev + nStrideNew;
//total bytes after extending
		    var nTotalSize:  number  = nStrideNext * this.length;
		    var pDeclNew: IVertexDeclaration = this.getVertexDeclaration().clone();

//data migration
		    var pDataPrev: Uint8Array = new Uint8Array(<ArrayBuffer>this.getData());
		    var pDataNext: Uint8Array = new Uint8Array(nTotalSize);

		    for (var i:  number  = 0, iOffset:  number ; i < nCount; ++i) {
		        iOffset = i * nStrideNext;
		        pDataNext.set(pDataPrev.subarray(i * nStridePrev, (i + 1) * nStridePrev), iOffset);
		        pDataNext.set((<Uint8Array>pData).subarray(i * nStrideNew, (i + 1) * nStrideNew), iOffset + nStridePrev);
		    }

		    if (!pDeclNew.extend(pDecl)) {
		        return false;
		    }

		    if (!this.resize(nCount, pDeclNew)) {
		        return false;
		    }

		    return this.setData(pDataNext, 0, nStrideNext);
		}


		resize(nCount:  number , pDecl?: IVertexDeclaration): bool;
		resize(nCount:  number , iStride?:  number ): bool;
		resize(nCount:  number , pDecl?: any) {
			var iStride:  number  = 0;
		    var iOldOffset:  number  = this.byteOffset;
		    var pOldVertexBuffer: IVertexBuffer;
		    var pOldVertexDeclaration: IVertexDeclaration;
		    var iOldStride:  number

//debug_print("VertexData (offset: " + this.byteOffset + ") resized from " + this.byteLength + " to ", arguments);

		    if (arguments.length == 2) {
		        if (isInt(pDecl)) {
		            iStride = < number >pDecl;
		        }
		        else {
		            iStride = (<IVertexDeclaration>pDecl).stride;
		        }

		        if (nCount * iStride <= this.byteLength) {
		            this._iLength = nCount;
		            this._iStride = iStride;
		            this._pVertexDeclaration = null;

		            if (!isInt(pDecl)) {
		                this.setVertexDeclaration(pDecl);
		            }

		            return true;
		        }
		        else {
		            pOldVertexBuffer = this.buffer;

		            pOldVertexBuffer.freeVertexData(this);

		            if (pOldVertexBuffer.getEmptyVertexData(nCount, pDecl, this) !== this) {
		                return false;
		            }

		            if (this.byteOffset != iOldOffset) {
		                logger.setSourceLocation( "data/VertexData.ts" , 187 ); logger.warning("vertex data moved from " + iOldOffset + " ---> " + this.byteOffset); ;
		                this.relocation(this, iOldOffset, this.byteOffset);
		            }

		            return true;
		        }
		    }
		    else if (arguments.length == 1) {
		        if (nCount <= this.length) {
		            this._iLength = nCount;
		            return true;
		        }
		        else {
		            pOldVertexBuffer = this.buffer;
		            pOldVertexDeclaration = this.getVertexDeclaration();
		            iOldStride = this.stride;

		            pOldVertexBuffer.freeVertexData(this);

		            if (pOldVertexBuffer.getEmptyVertexData(nCount, iOldStride, this) == null) {
		                return false;
		            }

		            this.setVertexDeclaration(pOldVertexDeclaration);

		            if (this.byteOffset != iOldOffset) {
		                logger.setSourceLocation( "data/VertexData.ts" , 213 ); logger.warning("vertex data moved from " + iOldOffset + " ---> " + this.byteOffset); ;
		                this.relocation(this, iOldOffset, this.byteOffset);
		            }

		            return true;
		        }
		    }

		    return false;
		}

		applyModifier(sUsage: string, fnModifier: IBufferDataModifier): bool {
			var pData = this.getTypedData(sUsage);
		    fnModifier(pData);
		    return this.setData(pData, sUsage);
		}

//FIX ME:
//если известно sUsage, зачем нужет iSize?
		setData(pData: ArrayBufferView, iOffset:  number , iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView, sUsage?: string, iSize?:  number , nCountStart?:  number , nCount?:  number ): bool;
		setData(pData: ArrayBufferView, iOffset?: any, iSize?:  number , nCountStart?:  number , nCount?:  number ): bool {
			var iStride:  number ;
			var pVertexBuffer: IVertexBuffer = this._pVertexBuffer;
			var pBackupBuf: Uint8Array;
			var pDataU8: Uint8Array;
			var k:  number ;
			var iOffsetBuffer:  number ;
			var pDeclaration: IVertexDeclaration = this._pVertexDeclaration;
			var pElement: IVertexElement;

			switch (arguments.length) {
		        case 5:
		        	if(isString(arguments[1])){
		        		iOffset = this._pVertexDeclaration.findElement(arguments[1]).offset;
		        	}

		            iStride = this.stride;
		            pDataU8 = new Uint8Array(pData.buffer);
		            if (iStride != iSize) {
//FIXME: очень тормознутое место, крайне медленно работает...
						if(pVertexBuffer.isBackupPresent() && nCount > 1) {
// console.log(pVertexBuffer.byteLength);
							pBackupBuf = new Uint8Array(pVertexBuffer.byteLength);
							pVertexBuffer.readData(pBackupBuf);

							iOffsetBuffer = this.byteOffset;

							for (var i = nCountStart; i < nCount + nCountStart; i++) {
								for(k = 0; k < iSize; k++) {
									pBackupBuf[iStride * i + iOffset + iOffsetBuffer + k] =
										pDataU8[iSize * (i - nCountStart) + k];
								}
							}

							pVertexBuffer.writeData(pBackupBuf, 0, pVertexBuffer.byteLength);
						}
						else {
							for (var i:  number  = 0; i < nCount; i++) {
								var iCurrent:  number  = i + nCountStart;

								pVertexBuffer.writeData(
/*pData.buffer.slice*/

										pDataU8.subarray( iSize * i, iSize * (i + 1)),
										iStride * iCurrent + iOffset + this.byteOffset,
										iSize);
							}
						}
		            }
		            else {

		                pVertexBuffer.writeData(
/*pData.buffer.slice*/

//stride == size => iOffset = 0;
		                	pDataU8.subarray(0 ,
		                		iStride * nCount),
/*iOffset + */
		                	              this.byteOffset + iStride * nCountStart,
		                    iStride * nCount);
		            }
		            return true;
		        case 4:
		            pElement = null;

		            if (isString(arguments[1])) {
		                pElement = pDeclaration.findElement(arguments[1]);

		                if (pElement) {
		                    return this.setData(
		                        pData,
		                        pElement.offset,
		                        pElement.size,
		                        arguments[2],
		                        arguments[3]);
		                }

		                return false;
		            }

		            nCountStart = nCountStart || 0;

		            if (!nCount) {
		                nCount = pData.byteLength / iSize;
		            }

		            return this.setData(pData, iOffset, iSize, nCountStart, nCount);


		        case 2:
		        case 3:
		            var pDeclaration: VertexDeclaration = this._pVertexDeclaration,
		                pElement: VertexElement = null;

		            if (isString(arguments[1])) {
		                pElement = pDeclaration.findElement(arguments[1]);

		                if (pElement) {
		                    arguments[2] = arguments[2] || 0;

		                    if (!arguments[3]) {
		                        arguments[3] = pData.buffer.byteLength / pElement.size;
		                    }

		                    return this.setData(
		                    	pData,
		                        pElement.offset,
		                        pElement.size,
		                        arguments[2],
		                        arguments[3]);
		                }
		                return false
		            }
		            else if (arguments.length === 3) {

		                nCountStart = nCountStart || 0;

		                if (!nCount) {
		                    nCount = pData.byteLength / iSize;
		                }

		                return this.setData(pData, iOffset, iSize, nCountStart, nCount);
		            }

		            return false;
		        case 1:
		            return this.setData(pData, this._pVertexDeclaration.element(0).usage);
		        default:
		            return false;
		    }
		}


		getData(): ArrayBuffer;
		getData(iOffset:  number , iSize:  number , iFrom?:  number , iCount?:  number ): ArrayBuffer;
		getData(sUsage: string): ArrayBuffer;
		getData(sUsage: string, iFrom:  number , iCount:  number ): ArrayBuffer;
		getData(iOffset?: any, iSize?: any, iFrom?: any, iCount?: any): ArrayBuffer {
			switch (arguments.length) {
		        case 4:
		        case 2:
		            if (isString(arguments[0])) {
						return null;
		            }

		            iFrom = iFrom || 0;
		            iCount = iCount || this._iLength;
		            iCount = math.min(iCount, this._iLength);

		            var iStride:  number  = this.stride;
		            var pBufferData: Uint8Array = new Uint8Array(iSize * iCount);
	            	for (var i:  number  = 0; i < iCount; i++) {
	            		var iCurrent:  number  = iFrom + i;
		            	logger.setSourceLocation( "data/VertexData.ts" , 385 ); logger.assert(this._pVertexBuffer.readData(iStride * iCurrent + iOffset + this.byteOffset, iSize, pBufferData.subarray(i * iSize, (i + 1) * iSize)),"cannot read buffer");
                                                                                       ;

//pBufferData.set(new Uint8Array(), i * iSize);
		            }
		            return pBufferData.buffer;
		        case 3:
		        case 1:
		            var pDeclaration: IVertexDeclaration = this._pVertexDeclaration,
		                pElement: IVertexElement = null;

		            if (isString("string")) {
		                pElement = pDeclaration.findElement(arguments[0]);

		                if (isDefAndNotNull(pElement)) {

		                    return this.getData(
		                        pElement.offset,
		                        pElement.size,
		                        arguments[1],
		                        arguments[2]
		                        );
		                }
		                return null;
		            }

		            return null;

		        case 0:
		            return this.getData(0, this._pVertexDeclaration.stride);
		        default:
		            return null;
		    }
		}

		getTypedData(sUsage: string, iFrom?:  number , iCount?:  number ): ArrayBufferView {
		    var pVertexElement: IVertexElement = this._pVertexDeclaration.findElement(sUsage);

		    if (pVertexElement) {
		        return util.abtota(this.getData(sUsage, iFrom, iCount), pVertexElement.type);
		    }

		    return null;
		}

		inline getBufferHandle():  number  {
			return this._pVertexBuffer.resourceHandle;
		}

		toString(): string {
		    if ( DEBUG ) {

			    var s: string = "";

			    s += "          VERTEX DATA  #" + this.id + "\n";
			    s += "---------------+-----------------------\n";
			    s += "        BUFFER : " + this.getBufferHandle() + "\n";
			    s += "          SIZE : " + this.byteLength + " b.\n";
			    s += "        OFFSET : " + this.byteOffset + " b.\n";
			    s += "---------------+-----------------------\n";
			    s += " MEMBERS COUNT : " + this.length + " \n";
			    s += "        STRIDE : " + this.stride + " \n";
			    s += "---------------+-----------------------\n";
			    s += this.getVertexDeclaration().toString();

			    return s;
		    }

		    return null;
		}



		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return VertexData._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		relocation (pTarget, iFrom, iTo): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).relocation; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pTarget, iFrom, iTo) : _broadcast[i].listener (_recivier, pTarget, iFrom, iTo) ; } } } ; ;
	}

}











module akra.core.pool.resources {
	export class MemoryBuffer extends HardwareBuffer {

		/**@protected*/  _pData: Uint8Array;

		inline get byteLength():  number  {
			return this._pData.byteLength;
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.DYNAMIC): bool {

			((iFlags) &= ~(EHardwareBufferFlags.BACKUP_COPY | EHardwareBufferFlags.DISCARDABLE | EHardwareBufferFlags.ALIGNMENT))
                                   ;

			var isCreated: bool = super.create(0, iFlags | EHardwareBufferFlags.SOFTWARE);

			this._pData = new Uint8Array(iByteSize);

			return isCreated;
		}

		destroy(): void {
			super.destroy();
			this._pData = null;
		}

		resize(iSize:  number ): bool {
			var pData: Uint8Array = new Uint8Array(iSize);

			if(iSize >= this.byteLength){
				pData.set(this._pData);
			}
			else{
				pData.set(this._pData.subarray(0, iSize));
			}

			this._pData = pData;
			this.notifyAltered();

			return true;
		}

		lockImpl(iOffset:  number , iLength:  number , iLockFlags:  number ): Uint8Array {
			return this._pData.subarray(iOffset, iOffset + iLength);
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			if (arguments.length < 3) {
				ppDest = arguments[0];
				iOffset = 0;
				iSize = ppDest.byteLength;
			}

			logger.setSourceLocation( "MemoryBuffer.ts" , 62 ); logger.assert((iOffset + iSize) <= this.byteLength); ;
			memcpy((<ArrayBufferView>ppDest).buffer, (<ArrayBufferView>ppDest).byteOffset, this._pData.buffer, iOffset, iSize);

			return true;
		}

// writeData(pData: Uint8Array, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool{
// writeData(pData: any, iOffset?: uint, iSize?: uint, bDiscardWholeBuffer: bool = false): bool { 

			if(arguments.length < 3){
				iSize = pData.byteLength;
			}

			if (arguments.length < 2) {
				iOffset = 0;
			}

			logger.setSourceLocation( "MemoryBuffer.ts" , 80 ); logger.assert((iOffset + iSize) <= this.byteLength); ;

			if(isDefAndNotNull(pData)){
				memcpy(this._pData.buffer, iOffset, (<ArrayBufferView>pData).buffer, (<ArrayBufferView>pData).byteOffset, iSize);
			}
			this.notifyAltered();

			return true;
		}
	}
}



module akra.core.pool.resources {
	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class VertexBuffer extends HardwareBuffer implements IVertexBuffer {
		/**@protected*/  _pVertexDataArray: IVertexData[] = [];
		/**@protected*/  _iDataCounter:  number  = 0;

		inline get type(): EVertexBufferTypes { return EVertexBufferTypes.UNKNOWN; }
		inline get length():  number  { return this._pVertexDataArray.length; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

// create(iByteSize: uint, iFlags?: uint, pData?: Uint8Array): bool;
		create(iByteSize:  number , iFlags?:  number , pData?: ArrayBufferView): bool{
// create(iByteSize: uint, iFlags?: uint, pData?: any): bool {
			super.create(0, iFlags || 0);

			if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
				this._pBackupCopy = new MemoryBuffer();
				this._pBackupCopy.create(iByteSize);
				this._pBackupCopy.writeData(pData, 0, iByteSize);
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			this._pBackupCopy.destroy();
			this.freeVertexData();

			this._iDataCounter = 0;
		}

		getVertexData(i:  number ): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pElements: IVertexElement[]): IVertexData;
		getVertexData(iOffset:  number , iCount:  number , pDecl: IVertexDeclaration): IVertexData;
		getVertexData(iOffset:  number , iCount?:  number , pData?: any): IVertexData {
			if (arguments.length < 2) {
				return this._pVertexDataArray[< number >arguments[0]];
			}

			var pDecl: IVertexDeclaration = createVertexDeclaration(pData);
			var pVertexData: IVertexData = new data.VertexData(this, this._iDataCounter ++, iOffset, iCount, pDecl);

			this._pVertexDataArray.push(pVertexData);
			this.notifyAltered();

			return pVertexData;
		}


		getEmptyVertexData(iCount:  number , pElements: IVertexElement[], ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDecl: IVertexDeclaration, ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pSize:  number , ppVertexDataIn?: IVertexData): IVertexData;
		getEmptyVertexData(iCount:  number , pDeclData: any, ppVertexDataIn?: IVertexData): IVertexData {
			var pDecl: IVertexDeclaration = null;
			var pHole: IBufferHole[] = [];
			var i:  number ;
			var pVertexData: IVertexData;
			var iTemp:  number ;
			var iStride:  number  = 0;
			var iAligStart:  number ;
			var iNewSize:  number  = 0;

			while(true) {

				pHole[0] = {start:0, end: this.byteLength};

				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					pVertexData = this._pVertexDataArray[k];

					for(i = 0; i < pHole.length; i++) {
//Полностью попадает внутрь
						if(pVertexData.byteOffset > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							iTemp = pHole[i].end;
							pHole[i].end=pVertexData.byteOffset;
							pHole.splice(i + 1, 0, {start: pVertexData.byteOffset + pVertexData.byteLength, end: iTemp});
							i--;
						}
						else if(pVertexData.byteOffset == pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
						}
						else if(pVertexData.byteOffset > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {

						}
						else if(pVertexData.byteOffset == pHole[i].start &&
							pVertexData.byteLength == (pHole[i].end - pHole[i].start)) {
							pHole.splice(i, 1);
							i--;
						}
//Перекрывает снизу
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength < pHole[i].end) {
							pHole[i].start = pVertexData.byteOffset + pVertexData.byteLength;
						}
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength == pHole[i].end) {
							pHole.splice(i,1);
							i--;
						}
//Перекрывается сверху
						else if(pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end &&
							pVertexData.byteOffset > pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
							pHole[i].end=pVertexData.byteOffset;
						}
						else if(pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end &&
							pVertexData.byteOffset == pHole[i].start && pVertexData.byteOffset < pHole[i].end) {
							pHole.splice(i,1);
							i--;
						}
//полнстью перекрывает
						else if(pVertexData.byteOffset < pHole[i].start &&
							pVertexData.byteOffset + pVertexData.byteLength > pHole[i].end) {
							i--;
						}
					}
				}


				pHole.sort((a: IBufferHole, b: IBufferHole): number => ((a.end - a.start) - (b.end - b.start)));


				if(!isInt(pDeclData)) {
					pDecl = createVertexDeclaration(pDeclData);
					iStride = pDecl.stride;
				}
				else {
					iStride = pDeclData;
				}
// console.log(arguments[0], arguments[1].toString());
// console.log("Buffer size >", this.byteLength, iCount * iStride)

				for (i = 0; i < pHole.length; i++) {
					iAligStart = this.isAligned() ?
						math.alignUp(pHole[i].start, math.nok(iStride,4)):
						math.alignUp(pHole[i].start, iStride);

					if((pHole[i].end - iAligStart) >= iCount * iStride) {
						if(arguments.length == 2) {
							pVertexData = new data.VertexData(this, this._iDataCounter ++, iAligStart, iCount, pDeclData);
							this._pVertexDataArray.push(pVertexData);

							this.notifyAltered();
							return pVertexData;
						}
						else if(arguments.length == 3) {
							((<any>ppVertexDataIn).constructor).call(ppVertexDataIn, this, ppVertexDataIn.id, iAligStart, iCount, pDeclData);
							this._pVertexDataArray.push(ppVertexDataIn);

							this.notifyAltered();
							return ppVertexDataIn;
						}

						return null;
					}
				}

				iNewSize = math.max(this.byteLength * 2, this.byteLength + iCount * iStride);
				if (this.resize(iNewSize) == false) {
					logger.setSourceLocation( "core/pool/resources/VertexBuffer.ts" , 181 ); logger.warning("cannot resize buffer from " + this.byteLength + " bytes to " + iNewSize + " bytes ");
                                                            ;
					break;
				}
			}

			return null;
		}


		freeVertexData(): bool;
		freeVertexData(pVertexData?: IVertexData): bool {
			if(arguments.length == 0) {
				for(var i:  number  = 0; i < this._pVertexDataArray.length; i ++) {
					this._pVertexDataArray[Number(i)].destroy();
				}

				this._pVertexDataArray = null;
			}
			else {
				for(var i:  number  = 0; i < this._pVertexDataArray.length; i ++) {
					if(this._pVertexDataArray[i] == pVertexData) {
						pVertexData.destroy();

						this._pVertexDataArray.splice(i, 1);
						this.notifyAltered();
						return true;
					}
				}

				return false;
			}

			this.notifyAltered();
			return true;
		}

		allocateData(pElements: IVertexElementInterface[], pData: ArrayBufferView): IVertexData;
		allocateData(pDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
		allocateData(pDeclData: any, pData: ArrayBufferView): IVertexData {
			var pDecl: IVertexDeclaration = createVertexDeclaration(pDeclData);

			var pVertexData: IVertexData;
		    var iCount:  number  = pData.byteLength / pDecl.stride;

		    logger.setSourceLocation( "core/pool/resources/VertexBuffer.ts" , 225 ); logger.assert(iCount === math.floor(iCount), 'Data size should be a multiple of the vertex declaration.'); ;

		    pVertexData = this.getEmptyVertexData(iCount, pDecl);

		    logger.setSourceLocation( "core/pool/resources/VertexBuffer.ts" , 229 ); logger.assert(!isNull(pVertexData), "Could not allocate vertex data!"); ;

		    pVertexData.setData(pData, 0, pDecl.stride);

		    return pVertexData;
		}

	}
}







module akra.webgl {

	export class WebGLVertexBuffer extends core.pool.resources.VertexBuffer implements IVertexBuffer {
		/**@protected*/  _iByteSize:  number ;

		/**@protected*/  _pWebGLBuffer: WebGLBuffer;

		private _pLockData: Uint8Array = null;
		/**@protected*/  _sCS: string = null;

		inline get type(): EVertexBufferTypes { return EVertexBufferTypes.VBO; }
		inline get byteLength():  number  { return this._iByteSize; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

// create(iByteSize: uint, iFlags: uint = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool{
// create(iByteSize: uint, iFlags: uint = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			iByteSize = math.max(iByteSize,  1024 );

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 45 ); logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated"); ;

			this._iByteSize = iByteSize;
		    this._iFlags = iFlags;
		    pWebGLContext = pWebGLRenderer.getWebGLContext();

		    logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 51 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); ;

//Софтварного рендеринга буфера у нас нет
		    logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 54 ); logger.assert(!this.isSoftware(), "no sftware rendering"); ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 62 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                                                                                                                         ;


		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 68 ); logger.criticalError("Не удалось создать буфер"); ;

		        this.destroy();
		        return false;
		    }

		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);
		    pWebGLContext.bufferData( 0x8892 , this._iByteSize, getWebGLUsage(this._iFlags));

		    if (isDefAndNotNull(pData)) {
/*pWebGLContext.bufferSubData(
		        	GL_ARRAY_BUFFER, 0, isArrayBuffer(pData)? <ArrayBuffer>pData: (<Uint8Array>pData).buffer);*/


				pWebGLContext.bufferSubData( 0x8892 , 0, pData.buffer);

		    }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);

			this._pWebGLBuffer = null;
			this._iByteSize = 0;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 102 ); logger.assert(!isNull(this._pWebGLBuffer), "Буффер еще не создан"); ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {

			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 122 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); ;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);

			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 129 ); logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера"); ;
			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 130 ); logger.assert(this.byteLength >= iOffset + iSize, "Данные выйдут за предел буфера"); ;

			var pU8Data: Uint8Array = null;

			if (isArrayBuffer(pData)) {
				pU8Data = new Uint8Array(pData);
			}
			else {
				pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
			}

			pU8Data = pU8Data.subarray(0, iSize);

			pWebGLContext.bufferSubData( 0x8892 , iOffset, pU8Data);

			if (this.isBackupPresent()) {
		        this._pBackupCopy.writeData(pU8Data, iOffset);
		    }

		    this.notifyAltered();

			return true;
		}

		resize(iSize:  number ): bool {
			var eUsage:  number ;
			var pData: Uint8Array;
			var iMax:  number  = 0;
			var pVertexData: IVertexData;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if(!this.isBackupPresent()) {
				logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 164 ); logger.log("Not resized, because backup not present!"); ;
				return false;
			}

			logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 168 ); logger.log("WebGLVertexBuffer resized from " + this.byteLength + " to " + iSize); ;


			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					pVertexData = this._pVertexDataArray[k];

					if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
						iMax = pVertexData.byteOffset + pVertexData.byteLength;
					}
				}

				logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 181 ); logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                                                                                                                                         ;
			}

			if(pWebGLContext.isBuffer(this._pWebGLBuffer)) {
				pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
			}

			eUsage = getWebGLUsage(this._iFlags);

		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 193 ); logger.criticalError("Не удалось создать буфер"); ;

		        this.destroy();
		        return false;
		    }


		    pWebGLRenderer.bindWebGLBuffer( 0x8892 , this._pWebGLBuffer);
			pWebGLContext.bufferData( 0x8892 , iSize, eUsage);

			pData = new Uint8Array(this._iByteSize);

			if (!this.readData(pData)) {
				logger.setSourceLocation( "webgl/WebGLVertexBuffer.ts" , 206 ); logger.warning("cannot read data from buffer"); ;
				return false;
			}


			this.writeData(pData, 0, this._iByteSize);
			this._pBackupCopy.resize(iSize);
			this._iByteSize = iSize;

			this.notifyAltered();

			return true;
		}

		inline getWebGLBuffer(): WebGLBuffer {
			return this._pWebGLBuffer;
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		/**@protected*/  unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		/**@protected*/  copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}
	}
}
























module akra {
	export interface ITexture {} ;

	export interface ISampler2d {
		TEXTURE: string;
	}
}











module akra.webgl {

    export interface WebGLUniformLocationMap {
        [index: string]: WebGLUniformLocation;
    }

	export class WebGLShaderProgram extends core.pool.ResourcePoolItem implements IShaderProgram {
		/**@protected*/  _pWebGLProgram: WebGLProgram;
		/**@protected*/  _pWebGLUniformLocations: WebGLUniformLocationMap;
		/**@protected*/  _pWebGLAttributeLocations: IntMap;

		/**@protected*/  _pWebGLAttributesInfo: WebGLActiveInfo[];

		create(csVertex?: string, csPixel?: string): bool {
			if (arguments.length > 0) {
				return this.compile(csVertex ||  "void main(void){gl_Position = vec4(0., 0., 0., 1.);}" , csPixel ||  "void main(void){}" );
			}

            return false;
		}

        destroy(): void {
            var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();

            pWebGLRenderer.deleteWebGLProgram(this._pWebGLProgram);

            this._pWebGLUniformLocations = null;
            this._pWebGLAttributeLocations = null;
            this._pWebGLAttributesInfo = null;

            this.notifyDestroyed();
            this.notifyDisabled();
        }

    	compile(csVertex: string =  "void main(void){gl_Position = vec4(0., 0., 0., 1.);}" , csPixel: string =  "void main(void){}" ): bool {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
			var pWebGLProgram: WebGLProgram = this._pWebGLProgram = pWebGLRenderer.createWebGLProgram();

			var pWebGLVs: WebGLShader = this.createWebGLShader( 0x8B31 , csVertex);
			var pWebGLFs: WebGLShader = this.createWebGLShader( 0x8B30 , csPixel);

/** because, if not all units correctly activated, can obtained wronf link status */

			pWebGLRenderer._disableAllTextureUnits();

			pWebGLContext.attachShader(pWebGLProgram, pWebGLVs);
			pWebGLContext.attachShader(pWebGLProgram, pWebGLFs);

			pWebGLContext.linkProgram(pWebGLProgram);

			if (!this.isLinked()) {
				logger.setSourceLocation( "WebGLShaderProgram.ts" , 67 ); logger.error("cannot link GLSL program(guid: %d)", this.getGuid()); ;


				if (hasExtension( "WEBGL_debug_shaders" )) {
					logger.setSourceLocation( "WebGLShaderProgram.ts" , 73 ); logger.log("translated(from GLSL) VS shader: \n %s\ntranslated(from GLSL) PS shader: \n%s", pWebGLContext.getTranslatedShaderSource(pWebGLVs), pWebGLContext.getTranslatedShaderSource(pWebGLFs));
                                                        ;
				}

				var sInfo: string = pWebGLContext.getProgramInfoLog(pWebGLProgram);

				logger.setSourceLocation( "WebGLShaderProgram.ts" , 78 ); logger.log("shader program errors: \n %s\n\nvertex code:\n %s\n\n pixel code: %s", sInfo, csVertex, csPixel); ;


				return false;
			}

			pWebGLContext.validateProgram(pWebGLProgram);

			if (!this.isValid()) {
				logger.setSourceLocation( "WebGLShaderProgram.ts" , 87 ); logger.warning("GLSL program not valid(guid: %d)", this.getGuid()); ;

				logger.setSourceLocation( "WebGLShaderProgram.ts" , 89 ); logger.log(pWebGLContext.getProgramInfoLog(pWebGLProgram)); ;
			}

			this.obtainWebGLUniforms();
			this.obtainWebGLAttributes();

            this.notifyCreated();
            this.notifyRestored();

			return true;
    	}

    	isLinked(): bool {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		return isDefAndNotNull(this._pWebGLProgram) &&
    			<bool>pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B82 );
    	}

    	isValid(): bool {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		return isDefAndNotNull(this._pWebGLProgram) &&
    			<bool>pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B83 );
    	}

    	isActive(): bool {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		return (isDefAndNotNull(this._pWebGLProgram) &&
    			<WebGLProgram>pWebGLContext.getParameter( 0x8B8D ) === this._pWebGLProgram);
    	}

    	setFloat(sName: string, fValue:  number ): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		pWebGLContext.uniform1f(iLoc, fValue);
    		return true;
    	}

    	setInt(sName: string, iValue:  number ): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;
    		pWebGLContext.uniform1i(iLoc, iValue);

    		return true;
    	}

    	setVec2(sName: string, v2fValue: IVec2): bool;
    	setVec2(sName: string, x:  number , y:  number ): bool;
    	inline setVec2(sName: string, x?, y?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform2f(iLoc, arguments[1].x, arguments[1].y);
    		}
    		else {
    			pWebGLContext.uniform2f(iLoc, arguments[1], arguments[2]);
    		}

    		return true;
    	}


    	setVec2i(sName: string, v2iValue: IVec2): bool;
    	setVec2i(sName: string, x:  number , y:  number ): bool;
    	inline setVec2i(sName: string, x?, y?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform2i(iLoc, arguments[1].x, arguments[1].y);
    		}
    		else {
    			pWebGLContext.uniform2i(iLoc, arguments[1], arguments[2]);
    		}

    		return true;
    	}

    	setVec3(sName: string, v3fValue: IVec3): bool;
    	setVec3(sName: string, x:  number , y:  number , z:  number ): bool;
    	inline setVec3(sName: string, x?, y?, z?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform3f(iLoc, arguments[1].x, arguments[1].y, arguments[1].z);
    		}
    		else {
    			pWebGLContext.uniform3f(iLoc, arguments[1], arguments[2], arguments[3]);
    		}

    		return true;
    	}

    	setVec3i(sName: string, v3iValue: IVec3): bool;
    	setVec3i(sName: string, x:  number , y:  number , z:  number ): bool;
    	inline setVec3i(sName: string, x?, y?, z?): bool {
			var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform3i(iLoc, arguments[1].x, arguments[1].y, arguments[1].z);
    		}
    		else {
    			pWebGLContext.uniform3i(iLoc, arguments[1], arguments[2], arguments[3]);
    		}

    		return true;
    	}

    	setVec4(sName: string, v4fValue: IVec4): bool;
    	setVec4(sName: string, x:  number , y:  number , z:  number , w:  number ): bool;
    	inline setVec4(sName: string, x?, y?, z?, w?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform4f(iLoc, arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
    		}
    		else {
    			pWebGLContext.uniform4f(iLoc, arguments[1], arguments[2], arguments[3], arguments[3]);
    		}

    		return true;
    	}

    	setVec4i(sName: string, v4iValue: IVec4): bool;
    	setVec4i(sName: string, x:  number , y:  number , z:  number , w:  number ): bool;
    	inline setVec4i(sName: string, x?, y?, z?, w?): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		if (arguments.length == 2) {
    			pWebGLContext.uniform4i(iLoc, arguments[1].x, arguments[1].y, arguments[1].z, arguments[1].w);
    		}
    		else {
    			pWebGLContext.uniform4i(iLoc, arguments[1], arguments[2], arguments[3], arguments[3]);
    		}

    		return true;
    	}


    	inline setMat3(sName: string, m3fValue: IMat3): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		pWebGLContext.uniformMatrix3fv(iLoc, false, m3fValue.data);

    		return true;
    	}

    	setMat4(sName: string, m4fValue: IMat4): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		pWebGLContext.uniformMatrix4fv(iLoc, false, m4fValue.data);

    		return true;
    	}

    	inline setFloat32Array(sName: string, pValue: Float32Array): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		pWebGLContext.uniform1fv(iLoc, pValue);

    		return true;
    	}

    	inline setInt32Array(sName: string, pValue: Int32Array): bool {
    		var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName]; if (!isDef(iLoc)) { return false; } ;
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		pWebGLContext.uniform1iv(iLoc, pValue);

    		return true;
    	}

    	inline setVec2Array(sName: string, pValue: IVec2[]): bool {
    		return false;
    	}

    	inline setVec2iArray(sName: string, pValue: IVec2[]): bool {
    		return false;
    	}

    	inline setVec3Array(sName: string, pValue: IVec3[]): bool {
    		return false;
    	}

    	inline setVec3iArray(sName: string, pValue: IVec3[]): bool {
    		return false;
    	}

    	inline setVec4Array(sName: string, pValue: IVec4[]): bool {
    		return false;
    	}

    	inline setVec4iArray(sName: string, pValue: IVec4[]): bool {
    		return false;
    	}



    	inline setMat3Array(sName: string, pValue: IMat3[]): bool {
    		return false;
    	}

    	inline setMat4Array(sName: string, pValue: IMat4[]): bool {
    		return false;
    	}

    	inline setStruct(sName: string, pData: Object): bool {
    		return false;
    	}

    	inline setSampler2D(sName: string, pData: ISampler2d): bool {
    		return false;
    	}

    	inline setSampler2DToStruct(sName: string, pData: ISampler2d): bool {
    		return false;
    	}

    	inline setTexture(sName: string, pData: ITexture): bool {
    		return false;
    	}

//applyVertexBuffer(sName: string, pBuffer: IVertexBuffer);
    	applyVertexData(sName: string, pData: IVertexData): bool {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var pVertexBuffer: IVertexBuffer = <IVertexBuffer>pData.buffer;
    		var iStride:  number  = pData.stride;

    		if (pVertexBuffer.type !== EVertexBufferTypes.VBO) {
    			return false
    		}

    		var pVertexDecl: IVertexDeclaration = pData.getVertexDeclaration();
    		var pVertexElement: IVertexElement;
    		var iLoc:  number ;

    		for (var i:  number  = 0; i < pVertexDecl.length; ++ i) {
    			pVertexElement = pVertexDecl[i];
    			iLoc = this.getWebGLAttributeLocation(pVertexElement.usage);

    			if (iLoc < 0) {
    				logger.setSourceLocation( "WebGLShaderProgram.ts" , 353 ); logger.warning("founded invalid GLSL attribute location(guid: %s): %s", this.getGuid(), pVertexElement.usage);
                              ;
    				continue;
    			}

    			pWebGLRenderer.bindWebGLBuffer( 0x8892 , (<WebGLVertexBuffer>pVertexBuffer).getWebGLBuffer());
    			pWebGLContext.vertexAttribPointer(iLoc,
    											  pVertexElement.count,
    											  pVertexElement.type,
    											  false,
    											  iStride,
    											  pVertexElement.offset);
    		}

    		return true;
    	}


        inline applyBufferMap(pMap: IBufferMap): void {
            logger.setSourceLocation( "WebGLShaderProgram.ts" , 371 ); logger.criticalError("WebGLShaderProgram::applyBufferMap() is uncompleted method!"); ;
        }


    	inline getWebGLAttributeLocation(sName: string):  number  {
    		return isDef(this._pWebGLAttributeLocations[sName]) ? this._pWebGLAttributeLocations[sName] : -1;
    	}

    	inline getWebGLUniformLocation(sName: string): WebGLUniformLocation {

			var iLoc: WebGLUniformLocation = this._pWebGLUniformLocations[sName];

			if (!isDef(iLoc)) {
				logger.setSourceLocation( "WebGLShaderProgram.ts" , 384 ); logger.warning("could not find location for GLSL attribute(guid: %s): %s", this.getGuid(), sName); ;
			}

			return null;

    	}

    	inline getWebGLProgram(): WebGLProgram {
    		return this._pWebGLProgram;
    	}

    	/**@protected*/  createWebGLShader(eType:  number , csCode: string): WebGLShader {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
			var pWebGLShader: WebGLShader = pWebGLContext.createShader(eType);

			pWebGLContext.shaderSource(pWebGLShader, csCode);
			pWebGLContext.compileShader(pWebGLShader);

			if (!pWebGLContext.getShaderParameter(pWebGLShader,  0x8B81 )) {
				logger.setSourceLocation( "WebGLShaderProgram.ts" , 406 ); logger.error("cannot compile GLSL shader(guid: %d)", this.getGuid()); ;

				var sInfo: string = pWebGLContext.getShaderInfoLog(pWebGLShader);
				var sCode: string = pWebGLContext.getShaderSource(pWebGLShader) || csCode;

				logger.setSourceLocation( "WebGLShaderProgram.ts" , 411 ); logger.log("shader errors: \n %s \n----------\n %s", sInfo, sCode); ;

				return null;
			}

			return pWebGLShader;
    	}

    	/**@protected*/  obtainWebGLUniforms(): void {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var nUniforms:  number  = pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B86 );
    		var pUniformLocations: WebGLUniformLocationMap = {};
    		var iLoc: WebGLUniformLocation;
    		var pUniformInfo: WebGLActiveInfo;

    		for (var i:  number  = 0; i < nUniforms; ++ i) {
    			pUniformInfo = pWebGLContext. getActiveUniform(this._pWebGLProgram, i);
				iLoc = pWebGLContext.getUniformLocation(this._pWebGLProgram, pUniformInfo.name);
				pUniformLocations[pUniformInfo.name] = iLoc;
    		}

    		this._pWebGLUniformLocations = pUniformLocations;
    	}

    	/**@protected*/  obtainWebGLAttributes(): void {
    		var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer(); var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext(); ;

    		var nAttributes:  number  = pWebGLContext.getProgramParameter(this._pWebGLProgram,  0x8B89 );
    		var pAttributeLocations: IntMap = <IntMap>{};
    		var pAttributesInfo: WebGLActiveInfo[] = [];
    		var iLoc:  number ;
    		var pAttributeInfo: WebGLActiveInfo;

    		for (var i:  number  = 0; i < nAttributes; ++ i) {
    			pAttributeInfo = pWebGLContext.getActiveAttrib(this._pWebGLProgram, i);
				iLoc = pWebGLContext.getAttribLocation(this._pWebGLProgram, pAttributeInfo.name);

				if (iLoc < 0 || !isDef(iLoc)) {
					logger.setSourceLocation( "WebGLShaderProgram.ts" , 450 ); logger.warning("could not get GLSL attribute location(guid: %s): %s", this.getGuid(), pAttributeInfo.name); ;
				}


				pAttributeLocations[pAttributeInfo.name] = iLoc;
				pAttributesInfo[iLoc] = pAttributeInfo;
    		}

    		this._pWebGLAttributeLocations = pAttributeLocations;
    		this._pWebGLAttributesInfo = pAttributesInfo;
    	}
	}
}
















module akra.webgl {
	export class WebGLVertexTexture extends core.pool.resources.VertexBuffer implements IVertexBuffer {
		/**@protected*/  _iWidth:  number  = 0;
		/**@protected*/  _iHeight:  number  = 0;

		/**@protected*/  _pWebGLTexture: WebGLTexture = null;
		/**@protected*/  _eWebGLFormat:  number ;
		/**@protected*/  _eWebGLType:  number ;

		/**@protected*/  _ePixelFormat: EPixelFormats = EPixelFormats.FLOAT32_RGBA;
//переменная нужна, чтобы проигнорировать обновление копии, обычно, это не требуется
		/**@protected*/  _bForceUpdateBackupCopy: bool = true;

/*vertex data for header updating*/

		/**@protected*/  _pHeader: IVertexData = null;

		private _pLockData: Uint8Array = null;

		inline get type(): EVertexBufferTypes { return EVertexBufferTypes.TBO; }
		inline get byteLength():  number  { return pixelUtil.getMemorySize(this._iWidth, this._iHeight, 1, this._ePixelFormat); }


/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			var iMinWidth:  number  =  32 ;
			var iWidth:  number , iHeight:  number ;
			var pTextureData: Uint8Array = null;
			var pDataU8: Uint8Array = pData;

/*header size*/
			var iAdditionalHeaderSize:  number  = (isDefAndNotNull(pData)) ? 32                 : 0;

			iByteSize = math.max(iByteSize + iAdditionalHeaderSize, pixelUtil.getMemorySize(iMinWidth, iMinWidth, 1, this._ePixelFormat));

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pPOTSize:  number [] = math.calcPOTtextureSize(math.ceil(iByteSize / pixelUtil.getNumElemBytes(this._ePixelFormat)));
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    iWidth = pPOTSize[0];
		    iHeight = pPOTSize[1];

		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 74 ); logger.assert(this._pWebGLTexture == null, "webgl texture already allocated"); ;

			this._iWidth = iWidth;
			this._iHeight = iHeight;
		    this._iFlags = iFlags;

		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 80 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); ;

//Софтварного рендеринга буфера у нас нет
		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 83 ); logger.assert(!this.isSoftware(), "no software rendering"); ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 91 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                                                                                                                         ;

			logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 94 ); logger.assert(loadExtension(pWebGLContext, "OES_texture_float"), "OES_texture_float extension is necessary for correct work.");
                                                                 ;

		    this._pWebGLTexture = pWebGLRenderer.createWebGLTexture();
		    this._eWebGLFormat = getWebGLFormat(this._ePixelFormat);
		    this._eWebGLType = getWebGLDataType(this._ePixelFormat);

		    if (!this._pWebGLTexture) {
		        logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 101 ); logger.criticalError("Не удалось создать буфер"); ;

		        this.destroy();
		        return false;
		    }

		    if (isDefAndNotNull(pData)) {

		    	if (pData.BYTES_PER_ELEMENT > 1) {
		    		pDataU8 = new Uint8Array(pData, pData.byteOffset, pData.byteLength);
		    	}

		    	pTextureData = new Uint8Array(this.byteLength);
		    	pTextureData.set(pDataU8);
		    }

		    pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);
		    pWebGLContext.texImage2D( 0x0DE1 , 0, this._eWebGLFormat,
		    	this._iWidth, this._iHeight, 0,  this._eWebGLFormat, this._eWebGLType, pTextureData);

		    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MAG_FILTER, pWebGLContext.NEAREST);
		    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MIN_FILTER, pWebGLContext.NEAREST);
		    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_S, pWebGLContext.CLAMP_TO_EDGE);
		    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_T, pWebGLContext.CLAMP_TO_EDGE);

//create header
		    this._pHeader = this.allocateData([VE_VEC2(DeclarationUsages.TEXTURE_HEADER)], this._header());


/**
		    * update program
		    **/


		    var pProgram: IShaderProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_vertex_texture_update");

	        if (isNull(pProgram)) {
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_vertex_texture_update");
	        	pProgram.create(
	        	"																									\n	        	uniform sampler2D sourceTexture;																	\n				attribute vec4  VALUE;																				\n				attribute float INDEX;																				\n				attribute float SHIFT;																				\n				                      																				\n				uniform vec2 size;																					\n				varying vec4 color;																					\n				                   																					\n				void main(void){																					\n				    vec4 value = VALUE;																				\n				    float  serial = INDEX;																			\n				                          																			\n				    int shift = int(SHIFT);																			\n				    if (shift != 0) {																				\n				        color = texture2D(sourceTexture,                                        					\n				            vec2((mod(serial, size.x) +.5 ) / size.x, (floor(serial / size.x) + .5) / size.y)		\n				            );																						\n																													\n																													\n				        if (shift == 1) {																			\n				            color = vec4(color.r, value.gba);														\n				        }																							\n				        else if (shift == 2) {																		\n				            color = vec4(color.rg, value.ba);														\n				        }																							\n				        else if (shift == 3) {																		\n				            color = vec4(color.rgb, value.a);														\n				        }																							\n				        else if (shift == -1) {																		\n				            color = vec4(value.r, color.gba);														\n				        }																							\n				        else if (shift == -2) {																		\n				            color = vec4(value.rg, color.ba);														\n				        }																							\n				        else {																						\n				            color = vec4(value.rgb, color.a);														\n				        }																							\n				    }																								\n				    else {																							\n				        color = value;																				\n				    }																								\n				    gl_PointSize = 1.;																				\n				    gl_Position = vec4(2. * (mod(serial, size.x) + .5) / size.x - 1.,								\n				                    2. * (floor(serial / size.x)  + .5) / size.y - 1., 0., 1.);						\n				}																									\n				",
				"									\n				#ifdef GL_ES                        \n				    precision highp float;          \n				#endif								\n				varying vec4 color;                 \n				                                    \n				void main(void) {                   \n				    gl_FragColor = color;           \n				}                                   \n				");
	        }

/**
		    * resize program
		    **/


	        pProgram = <IShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_vertex_texture_resize");

	        if (isNull(pProgram)) {
	        	pProgram = <IShaderProgram>this.getManager().shaderProgramPool.createResource("WEBGL_vertex_texture_resize");
	        	pProgram.create(
	        	"																									\n	        	attribute float INDEX;																				\n	        																										\n	        	uniform sampler2D sourceTexture;																	\n				                      																				\n				uniform vec2 v2fSrcTexSize;																			\n				uniform vec2 v2fDstTexSize;																			\n																													\n				varying vec4 v4fValue;																				\n				                   																					\n				void main(void){																					\n					                       																			\n				    vec2 v2fSrcPosition = vec2((mod(INDEX, v2fSrcTexSize.x) + 0.5)/v2fSrcTexSize.x,					\n				    						   (floor(INDEX/v2fSrcTexSize.x) + 0.5)/v2fSrcTexSize.y);				\n	        																										\n	        		vec2 v2fDstPosition = vec2((mod(INDEX, v2fDstTexSize.x) + 0.5)/v2fDstTexSize.x,					\n				    						   (floor(INDEX/v2fDstTexSize.x) + 0.5)/v2fDstTexSize.y);				\n	        																										\n	        		v4fValue = texture2D(sourceTexture, v2fSrcPosition);											\n	        																										\n	        		gl_PointSize = 1.;																				\n	        		gl_Position = vec4(v2fDstPosition*2. - 1., 0., 1.);												\n				}																									\n				",
				"									\n				#ifdef GL_ES                        \n				    precision highp float;          \n				#endif								\n				varying vec4 v4fValue;              \n				                                    \n				void main(void) {                   \n				    gl_FragColor = v4fValue;        \n				}                                   \n				");
	        }

	        if(isNull(WebGLVertexTexture._pWebGLBuffer1)){
		        	WebGLVertexTexture._pWebGLBuffer1 = pWebGLRenderer.createWebGLBuffer();
	        }
	        if(isNull(WebGLVertexTexture._pWebGLBuffer2)){
	        	WebGLVertexTexture._pWebGLBuffer2 = pWebGLRenderer.createWebGLBuffer();
	        }
	        if(isNull(WebGLVertexTexture._pWebGLBuffer3)){
	        	WebGLVertexTexture._pWebGLBuffer3 = pWebGLRenderer.createWebGLBuffer();
	        }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

			this._pWebGLTexture = null;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 268 ); logger.assert(!isNull(this._pWebGLTexture), "Буффер еще не создан"); ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer: bool = false): bool {

/*предпологается, что float*/
			var iTypeSize:  number  		= pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8,
/*число float'ов в пикселе*/
		        nElementsPerPix:  number  	= pixelUtil.getComponentCount(this._ePixelFormat),
/*номер float'a с которого начинается обновление*/
		        iFrom:  number ,
/*исло float'ов для обновления*/
		        iCount:  number ;
/*данные для обновления*/
			var pBufferData: Float32Array;

/*смещение внутри первого пикселя*/
		    var iLeftShift:  number ,
/*смещение внутри последнего пикселя*/
		        iRightShift:  number ,
/*пиксель с которого начинается обновление*/
		        iBeginPix:  number ,
/*пиксель на котором заканчивается обновление*/
		        iEndPix:  number ,
/*число пикселей*/
		        nPixels:  number ,
		        nElements:  number ;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    var pDataU8: Uint8Array = pData;

		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 306 ); logger.assert(bDiscardWholeBuffer === false, "Discard option temporary unsupported."); ;

		    if (pData.BYTES_PER_ELEMENT > 1) {
		    	pDataU8 = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
		    }

		    iOffset = iOffset || 0;
		    iSize = iSize || pData.byteLength;

		    pDataU8 = pDataU8.subarray(0, iSize);

		    if (this.byteLength < iOffset + iSize) {
		        this.resize(iOffset + iSize);
		    }

		    if (this.isBackupPresent() && this._bForceUpdateBackupCopy) {
		        this._pBackupCopy.writeData(pDataU8, iOffset);
		    }

		    this._bForceUpdateBackupCopy = true;

		    logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 327 ); logger.assert(iOffset % iTypeSize === 0 && iSize % iTypeSize === 0, "Incorrect data size or offset"); ;

		    iFrom 	= iOffset / iTypeSize;
		    iCount 	= iSize / iTypeSize;

		    iLeftShift 	= iFrom % nElementsPerPix;
		    iRightShift = ((iFrom + iCount) % nElementsPerPix);
		    iBeginPix 	= Math.floor(iFrom / nElementsPerPix);
		    iEndPix 	= Math.floor((iFrom + iCount) / nElementsPerPix);
		    nPixels 	= Math.ceil((iFrom + iCount) / nElementsPerPix) - Math.floor(iFrom / nElementsPerPix);
		    nElements 	= nPixels * nElementsPerPix;

		    pBufferData = new Float32Array(pDataU8.buffer, pDataU8.byteOffset);

		    if (iLeftShift === 0 && iRightShift === 0) {
		        var iWidth:  number  	= this._iWidth;
		        var iYmin:  number  		= Math.floor(iBeginPix / iWidth);
		        var iYmax:  number  		= Math.ceil(iEndPix / iWidth);
		        var iXbegin:  number  	= iBeginPix % iWidth;
		        var iXend:  number  		= iEndPix % iWidth;
		        var iHeight:  number  	= iYmax - iYmin;

		        var iBeginElement:  number  	= 0,
		        	iEndElement:  number  	= 0;

//hack: if iEndPixel is first pixel from next row

		        iXend = (iXend === 0 ? iWidth : iXend);

//FIX THIS, move this function from here...
		        var me = this;
		        function updatePixelRect(iX:  number , iY:  number , iW:  number , iH:  number ): void {
		            iBeginElement = iEndElement;
		            iEndElement = iW * iH * nElementsPerPix + iEndElement;

		            pWebGLRenderer.bindWebGLTexture( 0x0DE1 , me._pWebGLTexture);

		            pWebGLContext.texSubImage2D( 0x0DE1 , 0, iX, iY, iW, iH,
		            	me._eWebGLFormat, me._eWebGLType, pBufferData.subarray(iBeginElement, iEndElement));
		        };

		        if (iHeight === 1) {
		            updatePixelRect(iXbegin, iYmin, iXend - iXbegin, 1);
		        }
		        else {

		            updatePixelRect(iXbegin, iYmin, iWidth - iXbegin, 1);

		            if (iHeight > 2) {
		                updatePixelRect(0, iYmin + 1, iWidth, iHeight - 2);
		            }

		            updatePixelRect(0, iYmax - 1, iXend, 1);
		        }
		    }
		    else if (this.isBackupPresent()) {
		        var iRealOffset:  number  	= iBeginPix * nElementsPerPix * iTypeSize;
		        var iRealSize:  number  	= nElements * iTypeSize;
		        var pTempData: Uint8Array = <Uint8Array>this._pBackupCopy.lock(iRealOffset, iRealSize);
//var iTotalSize: uint 	= iRealOffset + iRealSize;

//FIX ME:
		        this._pBackupCopy.unlock();

		        this._bForceUpdateBackupCopy = false;

		        return this.writeData(pTempData, iRealOffset, iRealSize);
		    }
		    else {
//console.error(this);

		        var pMarkupDataIndex: Float32Array = new Float32Array(nPixels);
		        var pMarkupDataShift: Float32Array = new Float32Array(nPixels);
		        var pRealData: Float32Array = new Float32Array(nElements);

		        pMarkupDataIndex[0] = iBeginPix;
		        pMarkupDataShift[0] = iLeftShift;

		        pMarkupDataIndex[nPixels - 1] = iBeginPix + nPixels - 1;
		        pMarkupDataShift[nPixels - 1] = -iRightShift;

		        for (var i:  number  = 1; i < nPixels - 1; ++i) {
		            pMarkupDataIndex[i] = iBeginPix + i;
		        }

		        for (var i:  number  = 0; i < iCount; i++) {
		            pRealData[iLeftShift + i] = pBufferData[i];
		        }

		        var pWebGLFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
		        var pWebGLProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_vertex_texture_update");

		        var pValueBuffer: WebGLBuffer 		= WebGLVertexTexture._pWebGLBuffer1;
		        var pMarkupIndexBuffer: WebGLBuffer = WebGLVertexTexture._pWebGLBuffer2;
		        var pMarkupShiftBuffer: WebGLBuffer = WebGLVertexTexture._pWebGLBuffer3;

		        logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 423 ); logger.assert(isDef(pWebGLProgram), "cound not find WEBGL_vertex_texture_update program"); ;

		        pWebGLRenderer.disableAllWebGLVertexAttribs();

		        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pWebGLFramebuffer);
		        pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

		        pWebGLContext.disable( 0x0B71 );
		        pWebGLContext.disable( 0x0C11 );
		        pWebGLContext.disable( 0x0BE2 );
		        pWebGLContext.disable( 0x0B44 );

		        var iValueAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("VALUE");
		        var iIndexAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("INDEX");
		        var iShiftAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("SHIFT");

		        pWebGLContext.enableVertexAttribArray(iValueAttribLocation);
		        pWebGLContext.enableVertexAttribArray(iIndexAttribLocation);
		        pWebGLContext.enableVertexAttribArray(iShiftAttribLocation);

		        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
		        	0x0DE1 , this._pWebGLTexture, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pValueBuffer);
		        pWebGLContext.bufferData( 0x8892 , pRealData,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(iValueAttribLocation, 4,  0x1406 , false, 0, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pMarkupIndexBuffer);
		        pWebGLContext.bufferData( 0x8892 , pMarkupDataIndex,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(iIndexAttribLocation, 1,  0x1406 , false, 0, 0);


		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pMarkupShiftBuffer);
		        pWebGLContext.bufferData( 0x8892 , pMarkupDataShift,  0x88E0 );
		        pWebGLContext.vertexAttribPointer(iShiftAttribLocation, 1,  0x1406 , false, 0, 0);

		        pWebGLRenderer.activateWebGLTexture( 0x84C0 );
		        pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);

		        pWebGLProgram.setInt("sourceTexture", 0);
		        pWebGLProgram.setVec2("size", this._iWidth, this._iHeight);

		        pWebGLContext.viewport(0, 0, this._iWidth, this._iHeight);
		        pWebGLContext.drawArrays( 0x0000 , 0, nPixels);
		        pWebGLContext.flush();

		        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,  0x0DE1 , null, 0);

		        pWebGLRenderer.bindWebGLBuffer( 0x8892 , null);

		        pWebGLContext.disableVertexAttribArray(iValueAttribLocation);
		        pWebGLContext.disableVertexAttribArray(iIndexAttribLocation);
		        pWebGLContext.disableVertexAttribArray(iShiftAttribLocation);

//pWebGLRenderer.deleteWebGLBuffer(pValueBuffer);
//pWebGLRenderer.deleteWebGLBuffer(pMarkupShiftBuffer);
//pWebGLRenderer.deleteWebGLBuffer(pMarkupIndexBuffer);

		        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , null);
		        pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);
		    }

		    return true;
		}

		resize(iSize:  number ): bool {

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			var iMax:  number  = 0;
			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
					var pVertexData: IVertexData = this._pVertexDataArray[k];

					if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
						iMax = pVertexData.byteOffset + pVertexData.byteLength;
					}
				}

				if(iMax > iSize){
					logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 505 ); logger.assert(false, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                                                                                                                                          ;
					return false;
				}
			}

			var pPOTSize:  number [] = math.calcPOTtextureSize(math.ceil(iSize / pixelUtil.getNumElemBytes(this._ePixelFormat)));

			pPOTSize[0] = (pPOTSize[0] <  32 ) ?  32  : pPOTSize[0];
			pPOTSize[1] = (pPOTSize[1] <  32 ) ?  32  : pPOTSize[1];

			if(pPOTSize[0] !== this._iWidth || pPOTSize[1] !== this._iHeight){
				if(this.isBackupPresent()){
					this._iWidth = pPOTSize[0];
					this._iHeight = pPOTSize[1];

					pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);
				    pWebGLContext.texImage2D( 0x0DE1 , 0, this._eWebGLFormat,
				    	this._iWidth, this._iHeight, 0,  this._eWebGLFormat, this._eWebGLType, null);


				    var iByteLength:  number  = this.byteLength;

/*resing backup copy don't cause data loss*/

				    this._pBackupCopy.resize(iByteLength);

					var pData: Uint8Array = new Uint8Array(iByteLength);

					if (!this.readData(pData)) {
						logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 533 ); logger.warning("cannot read data from buffer"); ;
						return false;
					}

					this.writeData(pData, 0, iByteLength);
				}
				else{
			        var pWebGLProgram: WebGLShaderProgram = <WebGLShaderProgram>this.getManager().shaderProgramPool.findResource("WEBGL_vertex_texture_resize");

			        logger.setSourceLocation( "webgl/WebGLVertexTexture.ts" , 542 ); logger.assert(isDef(pWebGLProgram), "cound not find WEBGL_vertex_texture_resize program"); ;

			        pWebGLRenderer.useWebGLProgram(pWebGLProgram.getWebGLProgram());

//create new texture for resize
					var pTexture : WebGLTexture = pWebGLRenderer.createWebGLTexture();
					pWebGLRenderer.activateWebGLTexture( 0x84C1 );
					pWebGLRenderer.bindWebGLTexture( 0x0DE1 , pTexture);
				    pWebGLContext.texImage2D( 0x0DE1 , 0, this._eWebGLFormat,
				    	pPOTSize[0], pPOTSize[1], 0,  this._eWebGLFormat, this._eWebGLType, null);

				    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MAG_FILTER, pWebGLContext.NEAREST);
				    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_MIN_FILTER, pWebGLContext.NEAREST);
				    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_S, pWebGLContext.CLAMP_TO_EDGE);
				    pWebGLContext.texParameterf(pWebGLContext.TEXTURE_2D, pWebGLContext.TEXTURE_WRAP_T, pWebGLContext.CLAMP_TO_EDGE);

			        var pWebGLFramebuffer: WebGLFramebuffer = pWebGLRenderer.createWebGLFramebuffer();
			        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , pWebGLFramebuffer);
			        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,
			        	0x0DE1 , pTexture, 0);

			        if(iSize >= this.byteLength) {
/*in other case we already have iMax*/

						for(var k:  number  = 0; k < this._pVertexDataArray.length; ++ k) {
							var pVertexData: IVertexData = this._pVertexDataArray[k];

							if(pVertexData.byteOffset + pVertexData.byteLength > iMax) {
								iMax = pVertexData.byteOffset + pVertexData.byteLength;
							}
						}
					}

/*предпологается, что float*/
			        var iTypeSize:  number  		= pixelUtil.getComponentTypeBits(this._ePixelFormat) / 8;
/*число float'ов в пикселе*/
		        	var nElementsPerPix:  number  	= pixelUtil.getComponentCount(this._ePixelFormat);
		        	var nPixels:  number  = math.ceil(iMax/iTypeSize/nElementsPerPix);

		        	var pIndexBufferData: Float32Array = new Float32Array(nPixels);
		        	for(var i: number  = 0; i < nPixels; i++){
		        		pIndexBufferData[i] = i;
		        	}

		        	pWebGLRenderer.disableAllWebGLVertexAttribs();

		        	var iIndexAttribLocation:  number  = pWebGLProgram.getWebGLAttributeLocation("INDEX");

		        	pWebGLContext.enableVertexAttribArray(iIndexAttribLocation);

		        	if(isNull(WebGLVertexTexture._pWebGLBuffer1)){
		        		WebGLVertexTexture._pWebGLBuffer1 = pWebGLRenderer.createWebGLBuffer();
		        	}

			        var pIndexBuffer: WebGLBuffer = WebGLVertexTexture._pWebGLBuffer1;

			        pWebGLRenderer.bindWebGLBuffer( 0x8892 , pIndexBuffer);
			        pWebGLContext.bufferData( 0x8892 , pIndexBufferData,  0x88E0 );
			        pWebGLContext.vertexAttribPointer(iIndexAttribLocation, 1,  0x1406 , false, 0, 0);

			        pWebGLContext.disable( 0x0B71 );
			        pWebGLContext.disable( 0x0C11 );
			        pWebGLContext.disable( 0x0BE2 );
			        pWebGLContext.disable( 0x0B44 );

			        pWebGLRenderer.activateWebGLTexture( 0x84C0 );
			        pWebGLRenderer.bindWebGLTexture( 0x0DE1 , this._pWebGLTexture);

			        pWebGLProgram.setInt("sourceTexture", 0);
		        	pWebGLProgram.setVec2("v2fSrcTexSize", this._iWidth, this._iHeight);
		        	pWebGLProgram.setVec2("v2fDstTexSize", pPOTSize[0], pPOTSize[1]);

			        pWebGLContext.viewport(0, 0, pPOTSize[0], pPOTSize[1]);
			        pWebGLContext.drawArrays( 0x0000 , 0, nPixels);
			        pWebGLContext.flush();

			        pWebGLContext.framebufferTexture2D( 0x8D40 ,  0x8CE0 ,  0x0DE1 , null, 0);

			        pWebGLContext.disableVertexAttribArray(iIndexAttribLocation);
			        pWebGLRenderer.bindWebGLBuffer( 0x8892 , null);
//pWebGLRenderer.deleteWebGLBuffer(pIndexBuffer);

			        pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , null);
			        pWebGLRenderer.deleteWebGLFramebuffer(pWebGLFramebuffer);

			        pWebGLRenderer.deleteWebGLTexture(this._pWebGLTexture);

			        this._pWebGLTexture = pTexture;
			        this._iWidth = pPOTSize[0];
			        this._iHeight = pPOTSize[1];
				}
			}

			this._pHeader.setData(this._header());

			this.notifyAltered();

			return true;
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		/**@protected*/  unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		/**@protected*/  copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}

		/**@protected*/  _header(iTextureSizeX:  number  = this._iWidth, iTextureSizeY:  number  = this._iHeight){
			var pHeader: Float32Array = new Float32Array(8);

			pHeader[ 0 ] = iTextureSizeX;
			pHeader[ 1 ] = iTextureSizeY;
			pHeader[ 2 ] = 1/iTextureSizeX;
			pHeader[ 3 ] = 1/iTextureSizeY;
			pHeader[ 4 ] = iTextureSizeX * iTextureSizeY;
			pHeader[ 5 ] = pHeader[ 4 ] * pixelUtil.getNumElemBytes(this._ePixelFormat);

			return pHeader;
		};

		static _pWebGLBuffer1: WebGLBuffer = null;
		static _pWebGLBuffer2: WebGLBuffer = null;
		static _pWebGLBuffer3: WebGLBuffer = null;
	}


}





















module akra {
	export interface IIndexData extends IBufferData, IBuffer {
		 type: EDataTypes;
		 length:  number ;
		 bytesPerIndex:  number ;
		 id:  number ;

		getData(iOffset:  number , iSize:  number ): ArrayBuffer;
		getTypedData(iStart:  number , iCount:  number ): ArrayBufferView;

		setData(pData: ArrayBufferView): bool;
		setData(pData: ArrayBufferView, iOffset:  number ): bool;
		setData(pData: ArrayBufferView, iOffset:  number , iCount:  number ): bool;

		destroy(): void;

		getPrimitiveType(): EPrimitiveTypes;
		getPrimitiveCount():  number ;
		getBufferHandle():  number ;
	}
}






















module akra.data {
	export class IndexData implements IIndexData {
		private _pIndexBuffer: IIndexBuffer;
		private _iOffset:  number ;
		private _iLength:  number ;
		private _ePrimitiveType: EPrimitiveTypes;
		private _eElementsType: EDataTypes;
		private _iId:  number ;

		inline get id():  number  { return this._iId; }
		inline get type():  number  { return this._eElementsType; };
		inline get length():  number  { return this._iLength; };
		inline get bytesPerIndex():  number  { return getTypeSize(this._eElementsType); };
		inline get byteOffset():  number  { return this._iOffset; };
		inline get byteLength():  number  { return this._iLength * this.bytesPerIndex; };
		inline get buffer(): IIndexBuffer { return this._pIndexBuffer; };

		constructor (
			pIndexBuffer: IIndexBuffer,
			id:  number ,
			iOffset:  number ,
			iCount:  number ,
			ePrimitiveType: EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST,
			eElementsType: EDataTypes = EDataTypes.UNSIGNED_SHORT) {

			logger.setSourceLocation( "data/IndexData.ts" , 36 ); logger.assert(eElementsType == EDataTypes.UNSIGNED_SHORT || eElementsType == EDataTypes.UNSIGNED_BYTE || eElementsType == EDataTypes.UNSIGNED_INT, "supported only short, byte, uint data types.");
                                                                                             ;

			this._pIndexBuffer = pIndexBuffer;
			this._iOffset = iOffset;
			this._iLength = iCount;
			this._iId = id;

			this._ePrimitiveType = ePrimitiveType;
			this._eElementsType = eElementsType;

			logger.setSourceLocation( "data/IndexData.ts" , 46 ); logger.assert(pIndexBuffer.byteLength >= this.byteLength + this.byteOffset, "out of buffer limits."); ;
		}


		getData(iOffset:  number , iSize:  number ): ArrayBuffer {
			logger.setSourceLocation( "data/IndexData.ts" , 51 ); logger.assert(iOffset + iSize <= this.byteLength, "out of buffer limits"); ;
			var pBuffer: Uint8Array = new Uint8Array(iSize);

			if (this._pIndexBuffer.readData(this.byteOffset + iOffset, iSize, pBuffer)) {
				return pBuffer.buffer;
			}

			logger.setSourceLocation( "data/IndexData.ts" , 58 ); logger.error("cannot read data from index buffer"); ;

			return null;
		};

		getTypedData(iStart:  number , iCount:  number ): ArrayBufferView{
			logger.setSourceLocation( "data/IndexData.ts" , 64 ); logger.assert((iStart + iCount) <= this._iLength, "out of buffer limits"); ;

			var iTypeSize:  number  = getTypeSize(this._eElementsType);

			var iOffset:  number  = iStart * iTypeSize;
			var iSize:  number  = iCount * iTypeSize;

			var pBuffer: Uint8Array = new Uint8Array(iSize);

			if (this._pIndexBuffer.readData(this.byteOffset + iOffset, iSize, pBuffer)){
				switch(this._eElementsType){
					case EDataTypes.UNSIGNED_BYTE:
						return pBuffer;
					case EDataTypes.UNSIGNED_SHORT:
						return new Uint16Array(pBuffer.buffer);
					case EDataTypes.UNSIGNED_INT:
						return new Uint32Array(pBuffer.buffer);
					default:
						return null;
				}
			}

			return null;
		};

		setData(pData: ArrayBufferView, iOffset:  number  = 0, iCount:  number  = pData.byteLength / this.bytesPerIndex): bool {
			logger.setSourceLocation( "data/IndexData.ts" , 90 ); logger.assert((iOffset + iCount) * this.bytesPerIndex <= this.byteLength, "out of buffer limits."); ;

			return this._pIndexBuffer.writeData(
				pData,
				this.byteOffset + iOffset * this.bytesPerIndex,
				iCount * this.bytesPerIndex);
		}

		destroy(): void {
			this._pIndexBuffer = null;
			this._iOffset = undefined;
			this._iLength = undefined;
			this._eElementsType = undefined;
			this._eElementsType = undefined;
		}

		inline getPrimitiveType(): EPrimitiveTypes {
			return this._ePrimitiveType;
		}

		inline getPrimitiveCount(iIndexCount:  number  = this.length):  number  {
			return IndexData.getPrimitiveCount(this._ePrimitiveType, iIndexCount);
		}

		inline getBufferHandle():  number  {
			return this._pIndexBuffer.resourceHandle;
		}

		static getPrimitiveCount(eType: EPrimitiveTypes, nVertices:  number ):  number  {
			switch (eType) {
	            case EPrimitiveTypes.POINTLIST:
	                return nVertices;
	            case EPrimitiveTypes.LINELIST:
	            	return nVertices / 2;
	            case EPrimitiveTypes.LINESTRIP:
	            	return nVertices - 1;
	            case EPrimitiveTypes.LINELOOP:
	            	return nVertices;
	            case EPrimitiveTypes.TRIANGLELIST:
	                return nVertices / 3;
	            case EPrimitiveTypes.TRIANGLEFAN:
	            case EPrimitiveTypes.TRIANGLESTRIP:
	            	return nVertices - 2;
	        }

	        logger.setSourceLocation( "data/IndexData.ts" , 135 ); logger.error("unhandled case detected.."); ;

	        return 0;
		}
	}
}



module akra.core.pool.resources {

	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class IndexBuffer extends HardwareBuffer implements IIndexBuffer {
		/**@protected*/  _pIndexDataArray: IIndexData[] = [];
		/**@protected*/  _iDataCounter:  number  = 0;

		inline get length():  number  {
			return this._pIndexDataArray.length;
		}

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );

		}

//create(iByteSize: uint, iFlags?: uint, pData?: Uint8Array): bool;
		create(iByteSize:  number , iFlags?:  number , pData?: ArrayBufferView): bool{
//create(iByteSize: uint, iFlags?: uint, pData?: ArrayBufferView): bool {
			super.create(0, iFlags || 0);

			if ( (((iFlags) & (EHardwareBufferFlags.BACKUP_COPY)) != 0) ) {
				this._pBackupCopy = new MemoryBuffer();
				this._pBackupCopy.create(iByteSize);
				this._pBackupCopy.writeData(pData, 0, iByteSize);
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			this._pBackupCopy.destroy();
			this.freeIndexData();

			this._iDataCounter = 0;
		}

		getIndexData(iOffset:  number , iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData {
			var pIndexData: IIndexData = new data.IndexData(this, this._iDataCounter ++, iOffset, iCount, ePrimitiveType, eElementsType);
			this._pIndexDataArray.push(pIndexData);
			return pIndexData;
		}

		getEmptyIndexData(iCount:  number , ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes): IIndexData {
			var pHole: IBufferHole[] = new Array();
			var i:  number ;
			var pIndexData: IIndexData;

			pHole[0] = {start: 0, end: this.byteLength};

//console.log(pHole[0].end);
			for(var k:  number  = 0; k < this._pIndexDataArray.length; ++ k) {

				pIndexData = this._pIndexDataArray[k];

				for (i = 0; i < pHole.length; i ++) {
//console.log("pHole:",pHole[i].start,pHole[i].end);
//Полностью попадает внутрь
					if (pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						var iTemp:  number  = pHole[i].end;

						pHole[i].end = pIndexData.byteOffset;
						pHole.splice(i + 1, 0, {start: pIndexData.byteOffset + pIndexData.byteLength, end: iTemp});

						i--;
					}
					else if(pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
					}
					else if(pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {

					}
					else if(pIndexData.byteOffset == pHole[i].start && pIndexData.byteLength == (pHole[i].end - pHole[i].start)) {
						pHole.splice(i, 1);
						i--;
					}
//Перекрывает снизу
					else if(pIndexData.byteOffset<pHole[i].start &&
						pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength < pHole[i].end) {
						pHole[i].start = pIndexData.byteOffset + pIndexData.byteLength;
					}
					else if(pIndexData.byteOffset < pHole[i].start &&
						pIndexData.byteOffset + pIndexData.byteLength > pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength == pHole[i].end) {
						pHole.splice(i, 1);
						i--;
					}
//Перекрывается сверху
					else if(pIndexData.byteOffset + pIndexData.byteLength>pHole[i].end &&
						pIndexData.byteOffset > pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
						pHole[i].end = pIndexData.byteOffset;
					}
					else if(pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end &&
						pIndexData.byteOffset == pHole[i].start && pIndexData.byteOffset < pHole[i].end) {
						pHole.splice(i, 1);
						i--;
					}
//полнстью перекрывает
					else if(pIndexData.byteOffset < pHole[i].start && pIndexData.byteOffset + pIndexData.byteLength > pHole[i].end) {
						i--;
					}
				}
			}

			pHole.sort((a: IBufferHole, b: IBufferHole): number => ((a.end - a.start) - (b.end - b.start)));

			for (i = 0; i < pHole.length; i ++) {
				if((pHole[i].end - pHole[i].start) >= iCount * getTypeSize(eElementsType)) {
					pIndexData = new data.IndexData(this, this._iDataCounter ++, pHole[i].start, iCount, ePrimitiveType, eElementsType);

					this._pIndexDataArray.push(pIndexData);

					return pIndexData;
				}
			}

			return null;
		}

		freeIndexData(): bool;
		freeIndexData(pIndexData?: IIndexData): bool {
			if(arguments.length == 0) {
				for(var i:  number  = 0; i < this._pIndexDataArray.length; i ++) {
					this._pIndexDataArray[Number(i)].destroy();
				}

				this._pIndexDataArray = null;
			}
			else {
				for (var i:  number  = 0; i < this._pIndexDataArray.length; i ++) {
					if(this._pIndexDataArray[i] == pIndexData) {
						pIndexData.destroy();

						this._pIndexDataArray.splice(i,1);
						this.notifyAltered();
						return true;
					}
				}

				return false;
			}

			this.notifyAltered();
			return true;
		}

		allocateData(ePrimitiveType: EPrimitiveTypes, eElementsType: EDataTypes, pData: ArrayBufferView): IIndexData {
			var pIndexData: IIndexData;
		    var iCount:  number  = pData.byteLength / getTypeSize(eElementsType);

		    logger.setSourceLocation( "core/pool/resources/IndexBuffer.ts" , 164 ); logger.assert(iCount === math.floor(iCount), "data size should be a multiple of the vertex declaration"); ;

		    pIndexData = this.getEmptyIndexData(iCount, ePrimitiveType, eElementsType);
		    pIndexData.setData(pData);

		    return pIndexData;
		}

	}
}







module akra.webgl {

	interface IBufferHole {
		start:  number ;
		end:  number ;
	}

	export class WebGLIndexBuffer extends core.pool.resources.IndexBuffer implements IIndexBuffer {
		/**@protected*/  _iByteSize:  number ;
		/**@protected*/  _pWebGLBuffer: WebGLBuffer;

		private _pLockData: Uint8Array = null;

		inline get byteLength():  number  { return this._iByteSize; }

/*pManager: IResourcePoolManager*/
		constructor (                                  ) {
/*pManager*/
			super(            );
		}

		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: Uint8Array = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: ArrayBufferView = null): bool;
		create(iByteSize:  number , iFlags:  number  = EHardwareBufferFlags.STATIC, pData: any = null): bool {

			iByteSize = math.max(iByteSize,  1024 );

			if ( (((iFlags) & (EHardwareBufferFlags.READABLE)) != 0) ) {
	            ((iFlags) |= (EHardwareBufferFlags.BACKUP_COPY)) ;
	        }

			super.create(iByteSize, iFlags, pData);

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();
		    var i:  number ;

		    logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 45 ); logger.assert(this._pWebGLBuffer == null, "webgl buffer already allocated"); ;

			this._iByteSize = iByteSize;
		    this._iFlags = iFlags;
		    pWebGLContext = pWebGLRenderer.getWebGLContext();

		    logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 51 ); logger.assert(pWebGLContext !== null, "cannot grab webgl context"); ;

//Софтварного рендеринга буфера у нас нет
		    logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 54 ); logger.assert(!this.isSoftware(), "no sftware rendering"); ;

//Если есть локальная копия то буфер можно читать
		    if (this.isBackupPresent()) {
		        ((this._iFlags) |= (EHardwareBufferFlags.READABLE)) ;
		    }

			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 62 ); logger.assert(!pData || pData.byteLength <= iByteSize, "Размер переданного массива больше переданного размера буфера");
                                                                                                                         ;


		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 68 ); logger.criticalError("cannot create WebGL index buffer"); ;

		        this.destroy();
		        return false;
		    }

		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);
		    pWebGLContext.bufferData( 0x8893 , this._iByteSize, getWebGLUsage(this._iFlags));

		    if (pData) {
		        pWebGLContext.bufferSubData(
		        	0x8893 , 0,  <ArrayBufferView>(isArrayBuffer(pData) ?pData: (pData).buffer ));
		    }

		    return true;
		}

		destroy(): void {
			super.destroy();

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);

			this._pWebGLBuffer = null;
			this._iByteSize = 0;
		}

		readData(ppDest: ArrayBufferView): bool;
		readData(iOffset:  number , iSize:  number , ppDest: ArrayBufferView): bool;
		readData(iOffset: any, iSize?: any, ppDest?: any): bool {
			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 99 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); ;

		    if (!this.isBackupPresent()) {
		    	return false;
		    }

			if (arguments.length === 1) {
				this._pBackupCopy.readData(arguments[0]);
			}
			else {
				this._pBackupCopy.readData(iOffset, iSize, ppDest);
			}

		    return true;
		}

		writeData(pData: Uint8Array, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool = false): bool;
		writeData(pData: ArrayBufferView, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool = false): bool;
		writeData(pData: any, iOffset?:  number , iSize?:  number , bDiscardWholeBuffer?: bool = false): bool {

			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 119 ); logger.assert(!isNull(this._pWebGLBuffer), "WebGL buffer not exists"); ;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);

			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 126 ); logger.assert(pData.byteLength <= iSize, "Размер переданного массива больше переданного размера"); ;
			logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 127 ); logger.assert(this.byteLength >= iOffset + iSize, "Данные выйдут за предел буфера"); ;

			var pU8Data: Uint8Array = null;

			if (isArrayBuffer(pData)) {
				pU8Data = new Uint8Array(pData);
			}
			else {
				pU8Data = new Uint8Array(pData.buffer, pData.byteOffset, pData.byteLength);
			}

			pU8Data = pU8Data.subarray(0, iSize);

			pWebGLContext.bufferSubData( 0x8893 , iOffset, pU8Data);

			if (this.isBackupPresent()) {
		        this._pBackupCopy.writeData(pU8Data, iOffset);
		    }

		    this.notifyAltered();

			return true;
		}

		resize(iSize:  number ): bool {
			var eUsage:  number ;
			var pData: Uint8Array;
			var iMax:  number  = 0;
			var pIndexData: IIndexData;

		    var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getEngine().getRenderer();
		    var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			if(this.isBackupPresent()) {
				return false;
			}

			if(iSize < this.byteLength) {
				for(var k:  number  = 0; k < this._pIndexDataArray.length; ++ k) {
					pIndexData = this._pIndexDataArray[k];

					if(pIndexData.byteOffset + pIndexData.byteLength > iMax) {
						iMax = pIndexData.byteOffset + pIndexData.byteLength;
					}
				}

				logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 174 ); logger.assert(iMax <= iSize, "Уменьшение невозможно. Страая разметка не укладывается в новый размер");
                                                                                                                                         ;
			}

			if(pWebGLContext.isBuffer(this._pWebGLBuffer)) {
				pWebGLRenderer.deleteWebGLBuffer(this._pWebGLBuffer);
			}

			eUsage = getWebGLUsage(this._iFlags);

		    this._pWebGLBuffer = pWebGLRenderer.createWebGLBuffer();

		    if (!this._pWebGLBuffer) {
		        logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 186 ); logger.criticalError("cannot create WebGL index buffer"); ;

		        this.destroy();
		        return false;
		    }


		    pWebGLRenderer.bindWebGLBuffer( 0x8893 , this._pWebGLBuffer);
			pWebGLContext.bufferData( 0x8893 , iSize, eUsage);

			pData = new Uint8Array(this._iByteSize);

			if (this.readData(pData)) {
				logger.setSourceLocation( "webgl/WebGLIndexBuffer.ts" , 199 ); logger.warning("cannot read data from buffer"); ;
				return false;
			}


			this.writeData(pData, 0, this._iByteSize);
			this._pBackupCopy.resize(iSize);
			this._iByteSize = iSize;

			this.notifyAltered();

			return true;
		}

		inline getWebGLBuffer(): WebGLBuffer {
			return this._pWebGLBuffer;
		}

		/**@protected*/  lockImpl(iOffset:  number , iSize:  number , iLockFlags:  number ): any {
	        var pRetData: Uint8Array = new Uint8Array(iSize);

            this.readData(iOffset, iSize, pRetData);

            this._pLockData = pRetData;

	        return pRetData;
		}

		/**@protected*/  unlockImpl(): void {
			this.writeData(this._pLockData, this._iLockStart, this._iLockSize);
		}

		/**@protected*/  copyBackupToRealImpl(pRealData: Uint8Array, pBackupData: Uint8Array, iLockFlags:  number ): void {
			pRealData.set(pBackupData);
		}
	}
}













module akra.webgl {
	export class WebGLInternalRenderBuffer extends WebGLPixelBuffer {
		/**@protected*/  _pWebGLRenderbuffer: WebGLRenderbuffer = null;

		constructor() {
			super();
		}
		create(iFlags:  number ): bool;
		create(iWidth:  number , iHeight:  number , iDepth:  number , eFormat: EPixelFormats, iFlags:  number ): bool;
		create(iWebGLFormat:  number , iWidth:  number , iHeight:  number , bCreateStorage: bool): bool;
		create(): bool {
			if(arguments.length !== 4){
				logger.setSourceLocation( "webgl/WebGLInternalRenderbuffer.ts" , 20 ); logger.criticalError("Invalid number of arguments. For PixelBuffer it must be four"); ;
			}

			var iWebGLFormat:  number  = arguments[0];
			var iWidth:  number  = arguments[1];
			var iHeight:  number  = arguments[2];
			var bCreateStorage: bool = arguments[3];

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			super.create(iWidth, iHeight, 1, webgl.getClosestAkraFormat(iWebGLFormat, EPixelFormats.A8R8G8B8), 0);

			this._iWebGLInternalFormat = iWebGLFormat;
			this._pWebGLRenderbuffer = pWebGLRenderer.createWebGLRenderbuffer();

			pWebGLRenderer.bindWebGLRenderbuffer( 0x8D41 , this._pWebGLRenderbuffer);

			if(bCreateStorage) {
				pWebGLContext.renderbufferStorage( 0x8D41 , iWebGLFormat, iWidth, iHeight);
			}

			this.notifyCreated();
			return true;
		}

		destroy(): void {
			super.destroy();
			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();

			pWebGLRenderer.deleteWebGLRenderbuffer(this._pWebGLRenderbuffer);
			this._pWebGLRenderbuffer = null;
		}

		_bindToFramebuffer(iAttachment:  number , iZOffset:  number ): void {
			logger.setSourceLocation( "webgl/WebGLInternalRenderbuffer.ts" , 55 ); logger.assert(iZOffset < this._iDepth); ;

			var pWebGLRenderer: WebGLRenderer = <WebGLRenderer>this.getManager().getEngine().getRenderer();
			var pWebGLContext: WebGLRenderingContext = pWebGLRenderer.getWebGLContext();

			pWebGLContext.framebufferRenderbuffer( 0x8D40 , iAttachment,  0x8D41 , this._pWebGLRenderbuffer);
		}
	}

}

















module akra.core.pool.resources {
	export class DepthBuffer extends ResourcePoolItem implements IDepthBuffer {
		/**@protected*/  _iBitDepth:  number  = 0;
		/**@protected*/  _iWidth:  number  = 0;
		/**@protected*/  _iHeight:  number  = 0;
		/**@protected*/  _isManual: bool = false;
		/**@protected*/  _pAttachedRenderTargetsList: IRenderTarget[] = null;

		constructor() {
            super();
        }

        inline get bitDepth():  number  {
			return this._iBitDepth;
		}

		inline get width():  number  {
			return this._iWidth;
		}

		inline get height():  number  {
			return this._iHeight;
		}

        create(iBitDepth:  number , iWidth:  number , iHeight:  number , isManual: bool): bool {
        	this._iBitDepth = iBitDepth;
        	this._iWidth = iWidth;
        	this._iHeight = iHeight;
        	this._isManual = isManual;
        	this._pAttachedRenderTargetsList = [];

        	this.notifyCreated();

        	return true;
        }

        destroy(): void {
        	this.detachFromAllRenderTargets();
        	this._pAttachedRenderTargetsList = null;
        }

        destroyResource(): bool {
			this.destroy();
			this.notifyDestroyed();
			return true;
		}

        isManual(): bool{
        	return this._isManual;
        }

		isCompatible(pTarget: IRenderTarget): bool {
			if( this._iWidth >= pTarget.width &&
				this._iHeight >= pTarget.height ){
				return true;
			}

			return false;
		}

		_notifyRenderTargetAttached(pTarget: IRenderTarget): void {
			logger.setSourceLocation( "core/pool/resources/DepthBuffer.ts" , 70 ); logger.assert(this._pAttachedRenderTargetsList.indexOf(pTarget) === -1, "RenderTarget alrady has been attached to this DepthBuffer");
                                                                   ;

			this._pAttachedRenderTargetsList.push(pTarget);
		}

		_notifyRenderTargetDetached(pTarget: IRenderTarget): void {
			var index:  number  = this._pAttachedRenderTargetsList.indexOf(pTarget);
			logger.setSourceLocation( "core/pool/resources/DepthBuffer.ts" , 78 ); logger.assert(index !== -1, "Can not detach RenderTarget from DepthBuffer beacuse it hasn`t been attached to it");
                                                                                            ;

			this._pAttachedRenderTargetsList.splice(index, 1);
		}

		/**@protected*/  detachFromAllRenderTargets(): void {
			var i:  number  = 0;
			for(i = 0; i < this._pAttachedRenderTargetsList.length; i++) {
//If we call, detachDepthBuffer, we'll invalidate the iterators
				this._pAttachedRenderTargetsList[i].detachDepthBuffer();
			}

			this._pAttachedRenderTargetsList.clear();
		}
	}
}




































module akra.render {
	export class RenderTexture extends RenderTarget implements IRenderTexture {
		/**@protected*/  _pBuffer: IPixelBuffer = null;
		/**@protected*/  _iZOffset:  number  = 0;

		constructor(pRenderer: IRenderer, pBuffer: IPixelBuffer, iZOffset:  number ){
			super(pRenderer);
			this._pBuffer = pBuffer;
			this._iZOffset = iZOffset;
			this._iWidth = pBuffer.width;
			this._iHeight = pBuffer.height;
			this._iColorDepth = pixelUtil.getNumElemBits(pBuffer.format);
		}

		destroy(): void {
			this._pBuffer._clearRTT(this._iZOffset);
			this._pBuffer = null;
		}

		inline suggestPixelFormat(): EPixelFormats {
			return this._pBuffer.format;
		}

		copyContentsToMemory(pDest: IPixelBox, eBuffer: EFramebuffer): void {
			if(eBuffer === EFramebuffer.AUTO){
				eBuffer = EFramebuffer.FRONT;
			}

			if(eBuffer !== EFramebuffer.FRONT) {
				logger.setSourceLocation( "render/RenderTexture.ts" , 41 ); logger.criticalError("Invalid buffer."); ;
			}

			this._pBuffer.blitToMemory(pDest);
		}
	}
}













module akra.webgl {
	export class WebGLRenderTexture extends render.RenderTexture {
		/**@protected*/  _pFrameBuffer: WebGLInternalFrameBuffer = null;

		constructor(pRenderer: IRenderer, pTarget: IPixelBuffer){
			super(pRenderer, pTarget, 0);
			this._pFrameBuffer = new WebGLInternalFrameBuffer(pRenderer);

			this._pFrameBuffer.bindSurface( 0x8CE0 , pTarget);

			this._iWidth = this._pFrameBuffer.width;
			this._iHeight = this._pFrameBuffer.height;

		}

		destroy(): void {
			super.destroy();
		}

		requiresTextureFlipping(): bool {
			return true;
		}

		getCustomAttribute(sName: string): any {
			if(sName === "FBO") {
				return this._pFrameBuffer;
			}
		}

		swapBuffers(): void {
			this._pFrameBuffer.swapBuffers();
		}

		attachDepthBuffer(pDepthBuffer: IDepthBuffer): bool {
			var bResult: bool = false;
			bResult = super.attachDepthBuffer(pDepthBuffer);

			if(bResult){
				this._pFrameBuffer.attachDepthBuffer(pDepthBuffer);
			}

			return bResult;
		}

		attachDepthPixelBuffer(pBuffer: IPixelBuffer): bool {
			var bResult: bool = false;

			bResult = super.attachDepthPixelBuffer(pBuffer);
			if(bResult) {
				if(pBuffer.format !== EPixelFormats.DEPTH8){
					this.detachDepthPixelBuffer();
					return false;
				}

				this._pFrameBuffer.bindSurface( 0x8D00 , pBuffer);
				(<WebGLPixelBuffer>pBuffer).addRef();
			}

			return bResult;

		}

		detachDepthPixelBuffer(): void {
			this._pFrameBuffer.unbindSurface( 0x8D00 );
			(<WebGLPixelBuffer>this._pDepthPixelBuffer).release();
			super.detachDepthPixelBuffer();
		}

		detachDepthBuffer(): void {
			this._pFrameBuffer.detachDepthBuffer();
			super.detachDepthBuffer();
		}
	}
}















module akra.webgl {
	export interface IWebGLAttachments {
		[webGLAttachment:  number ] : WebGLPixelBuffer;
	}

	export class WebGLInternalFrameBuffer {
		private _pWebGLRenderer: WebGLRenderer = null;
		private _pWebGLFramebuffer: WebGLFramebuffer = null;
		private _pAttachments: IWebGLAttachments = null;

		constructor(pWebGLRenderer: IRenderer) {
			this._pWebGLRenderer = <WebGLRenderer>pWebGLRenderer;

			this._pWebGLFramebuffer = this._pWebGLRenderer.createWebGLFramebuffer();
			this._pAttachments = <IWebGLAttachments>{};

			for(var i:  number  = 0; i < webgl.maxColorAttachments; i++) {
				this._pAttachments[ 0x8CE0  + i] = null;
			}

			this._pAttachments[ 0x8D00 ] = null;
			this._pAttachments[ 0x8D20 ] = null;
			this._pAttachments[ 0x821A ] = null;
		}

		destroy(): void {
			this._pWebGLRenderer.deleteWebGLFramebuffer(this._pWebGLFramebuffer);
			this._pWebGLFramebuffer = null;
		}

		inline get width():  number  {
        	return this._pAttachments[ 0x8CE0 ].width;
		}

		inline get height():  number  {
			return this._pAttachments[ 0x8CE0 ].height;
		}

		inline get format():  number  {
			return this._pAttachments[ 0x8CE0 ].format;
		}

		inline getColorAttachment(iAttachment:  number ): WebGLPixelBuffer {
			return this._pAttachments[ 0x8CE0  + iAttachment];
		}

		inline getAttachment(iWebGLAttachment:  number ): WebGLPixelBuffer {
			return this._pAttachments[iWebGLAttachment];
		}

		bindSurface(iWebGLAttachment:  number , pSurface: IPixelBuffer): void {
			if(!isDef(this._pAttachments[iWebGLAttachment])){
				return;
			}
			this.releaseAttachment(iWebGLAttachment);
			this._pAttachments[iWebGLAttachment] = <WebGLPixelBuffer>pSurface;
			if(this.checkAttachment(iWebGLAttachment)){
				this.bind();
				(<WebGLPixelBuffer>pSurface)._bindToFramebuffer(iWebGLAttachment, 0);
				(<WebGLPixelBuffer>pSurface).addRef();
			}
		}

		unbindSurface(iWebGLAttachment:  number ): void {
			if(!isDef(this._pAttachments[iWebGLAttachment])){
				return;
			}
			var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();
			this.releaseAttachment(iWebGLAttachment);
			this._pAttachments[iWebGLAttachment] = null;
			pWebGLContext.framebufferRenderbuffer( 0x8D40 , iWebGLAttachment,
									  			  0x8D41 , null);
		}

		inline bindColorSurface(iAttachment:  number , pSurface: IPixelBuffer): void {
			this.bindSurface( 0x8CE0  + iAttachment, pSurface);
		}

		inline bind(): void {
			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , this._pWebGLFramebuffer);
		}

		attachDepthBuffer(pDepthBuffer: IDepthBuffer): void {
			if(!isNull(pDepthBuffer)) {
				var pDepthRenderBuffer: WebGLInternalRenderBuffer = (<WebGLDepthBuffer>pDepthBuffer).depthBuffer;
				var pStencilRenderBuffer: WebGLInternalRenderBuffer = (<WebGLDepthBuffer>pDepthBuffer).stencilBuffer;

				if(!isNull(pDepthRenderBuffer)){
					pDepthRenderBuffer._bindToFramebuffer( 0x8D00 , 0);
					this.releaseAttachment( 0x8D00 );
					this._pAttachments[ 0x8D00 ] = pDepthRenderBuffer;
					pDepthRenderBuffer.addRef();
				}

				if(!isNull(pStencilRenderBuffer)){
					pStencilRenderBuffer._bindToFramebuffer( 0x8D20 , 0);
					this.releaseAttachment( 0x8D20 );
					this._pAttachments[ 0x8D20 ] = pStencilRenderBuffer;
					pDepthRenderBuffer.addRef();
				}

				if( !this.checkAttachment( 0x8D00 ) ||
					!this.checkAttachment( 0x8D20 ) ) {
					logger.setSourceLocation( "webgl/WebGLInternalFrameBuffer.ts" , 117 ); logger.error("Invalid frame buffer depthbuffer attachment. Wrong size."); ;
					return;
				}

			}
			else {
				var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();

				pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D00 ,
										  			  0x8D41 , null);

				pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D20 ,
										  			  0x8D41 , null);

				this.releaseAttachment( 0x8D00 );
				this.releaseAttachment( 0x8D20 );
				this._pAttachments[ 0x8D00 ] = null;
				this._pAttachments[ 0x8D20 ] = null;
			}
		}

		detachDepthBuffer(): void {
			var pWebGLContext: WebGLRenderingContext = this._pWebGLRenderer.getWebGLContext();

			this._pWebGLRenderer.bindWebGLFramebuffer( 0x8D40 , this._pWebGLFramebuffer);

			pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D00 ,
									  			  0x8D41 , null);

			pWebGLContext.framebufferRenderbuffer( 0x8D40 ,  0x8D20 ,
									  			  0x8D41 , null);

			this.releaseAttachment( 0x8D00 );
			this.releaseAttachment( 0x8D20 );
			this._pAttachments[ 0x8D00 ] = null;
			this._pAttachments[ 0x8D20 ] = null;
		}

		swapBuffers(): void {

		}

		private checkAttachment(iWebGLAttachment:  number ): bool{
			if(iWebGLAttachment ===  0x8CE0 ){
				var isOk: bool = true;

				for(var i:  number  = 1; i < webgl.maxColorAttachments; i++) {
					isOk = this.checkAttachment( 0x8CE0  + i);
					if(!isOk) return false;
				}

				isOk = this.checkAttachment( 0x8D00 );
				if(!isOk) return false;
				isOk = this.checkAttachment( 0x8D20 );
				if(!isOk) return false;
				isOk = this.checkAttachment( 0x821A );
				if(!isOk) return false;

				return true;
			}
			else {
				var pBuffer: IPixelBuffer = this._pAttachments[iWebGLAttachment];
				if(isNull(pBuffer)) return true;

				if(this.width === 0 && this.height === 0) return true;

				if(this.width !== pBuffer.width && this.height !== pBuffer.height) return false;

				if(iWebGLAttachment >  0x8CE0  &&
				   iWebGLAttachment <  0x8CE0  + webgl.maxColorAttachments) {

					if (!isNull(this._pAttachments[ 0x8CE0 ]) &&
						this.format !== pBuffer.format) return false;
				}

				return true;
			}
		}

		private inline releaseAttachment(iWebGLAttachment): void {
			if(!isNull(this._pAttachments[iWebGLAttachment])){
				this._pAttachments[iWebGLAttachment].release();
			}
		}
	}
}



module akra.webgl {
	export class WebGLDepthBuffer extends core.pool.resources.DepthBuffer {
		/**@protected*/  _pDepthBuffer: WebGLInternalRenderBuffer = null;
		/**@protected*/  _pStencilBuffer: WebGLInternalRenderBuffer = null;

		constructor() {
			super();
		}

		inline get depthBuffer(): WebGLInternalRenderBuffer {
			return this._pDepthBuffer;
		}

		inline get stencilBuffer(): WebGLInternalRenderBuffer {
			return this._pStencilBuffer;
		}

		create(iBitDepth:  number , iWidth:  number , iHeight:  number , bManual: bool): bool;
		create(pDepth: WebGLInternalRenderBuffer, pStencil: WebGLInternalRenderBuffer,
			   iWidth:  number , iHeight:  number , isManual: bool): bool;
		create(): bool {
			if(arguments.length !== 5){
				logger.setSourceLocation( "webgl/WebGLDepthBuffer.ts" , 30 ); logger.criticalError("Invalid number of arguments. For WebGLDepthBuffer it must be five"); ;
			}

			super.create(0, arguments[2], arguments[3], arguments[4]);
			var pDepth: WebGLInternalRenderBuffer = arguments[0];
			var pStencil: WebGLInternalRenderBuffer = arguments[1];

			this._pDepthBuffer = pDepth;
			this._pStencilBuffer = pStencil;

			if(!isNull(pDepth)) {
				switch(pDepth._getWebGLFormat()) {
					case  0x81A5 :
						this._iBitDepth = 16;
						break;
					case  0x81A6 :
		            case  0x81A7 :
	            	case  0x88F0 :
	            		if (webgl.hasExtension( "OES_depth24" ) ||
	            			webgl.hasExtension( "OES_depth32" ) ||
	            			webgl.hasExtension( "OES_packed_depth_stencil" )){

	            			this._iBitDepth = 32;
	            		}
	            		break;
				}
			}

			return true;
		}

		destroy(): void {
			super.destroy();

			if(!isNull(this._pStencilBuffer) && this._pStencilBuffer !== this._pDepthBuffer){
				this._pStencilBuffer.release();
			}

			if(!isNull(this._pDepthBuffer)){
				this._pDepthBuffer.release();
			}

			this._pStencilBuffer = null;
			this._pDepthBuffer = null;
		}

		isCompatible(pTarget: IRenderTarget): bool {
			if( this._iWidth >= pTarget.width &&
				this._iHeight >= pTarget.height ){
				return true;
			}

			return false;
		}


	}
}







module akra.core.pool {
//is this class really singleton??
    export class ResourcePoolManager implements IResourcePoolManager {
//all predefined pools
        private pSurfaceMaterialPool: IResourcePool;
        private pEffectPool: IResourcePool;
        private pRenderMethodPool: IResourcePool;
        private pVertexBufferPool: IResourcePool;
        private pIndexBufferPool: IResourcePool;
        private pColladaPool: IResourcePool;
        private pImagePool: IResourcePool;
        private pTexturePool: IResourcePool;
        private pVideoBufferPool: IResourcePool;
        private pShaderProgramPool: IResourcePool;
        private pComponentPool: IResourcePool;
        private pTextureBufferPool: IResourcePool;
        private pRenderBufferPool: IResourcePool;
        private pDepthBufferPool: IResourcePool;
        private pEffectDataPool: IResourcePool;

/** Списки пулов по семействам ресурсов */

    	private pResourceFamilyList: IResourcePool[][] = null;
/** Карта пулов по коду ресурса */

    	private pResourceTypeMap: IResourcePool[] = null;
/** Ресурс для ожидания остальных */

    	private pWaiterResource: IResourcePoolItem = null;

        private pEngine: Engine;

        get surfaceMaterialPool(): IResourcePool { return this.pSurfaceMaterialPool; }
        get effectPool(): IResourcePool { return this.pEffectPool; }
        get renderMethodPool(): IResourcePool { return this.pRenderMethodPool; }
        get vertexBufferPool(): IResourcePool { return this.pVertexBufferPool; }
        get indexBufferPool(): IResourcePool { return this.pIndexBufferPool; }
        get colladaPool(): IResourcePool { return this.pColladaPool; }
        get imagePool(): IResourcePool { return this.pImagePool; }
        get texturePool(): IResourcePool { return this.pTexturePool; }
        get videoBufferPool(): IResourcePool { return this.pVideoBufferPool; }
        get shaderProgramPool(): IResourcePool { return this.pShaderProgramPool; }
        get componentPool(): IResourcePool { return this.pComponentPool; }
        get textureBufferPool(): IResourcePool {return this.pTextureBufferPool; }
        get renderBufferPool(): IResourcePool {return this.pRenderBufferPool; }
        get depthBufferPool(): IResourcePool {return this.pDepthBufferPool; }
        get effectDataPool(): IResourcePool {return this.pEffectDataPool; }

    	constructor(pEngine: IEngine) {
//super();

            this.pEngine = <Engine>pEngine;

    		this.pResourceFamilyList = new Array(EResourceFamilies.TOTAL_RESOURCE_FAMILIES);

    		for (var i = 0; i < EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i++) {
		        this.pResourceFamilyList[i] = new Array();
		    }

		    this.pResourceTypeMap = new Array();
/*this*/
		    this.pWaiterResource = new pool.ResourcePoolItem(        );

            this.createDeviceResource();
    	}

        initialize(): bool {
            this.registerDeviceResources();
            return true;
        }

        destroy(): void {
            this.unregisterDeviceResources();
        }

        registerResourcePool(pCode: IResourceCode, pPool: IResourcePool): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 115 ); logger.assert(pCode.family >= 0 && pCode.family < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid code familyi index");
                                             ;

            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 117 ); logger.assert(!isDef(this.pResourceTypeMap[pCode.toNumber()]), "Resource type code already registered"); ;

            this.pResourceTypeMap[pCode.toNumber()] = pPool;
            this.pResourceFamilyList[pCode.family].push(pPool);
        }

    	unregisterResourcePool(pCode: IResourceCode): IResourcePool {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 124 ); logger.assert(pCode.family >= 0, "invalid family index"); ;
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 125 ); logger.assert(pCode.family < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;

            var iCode = pCode.toNumber();
            var pPool = null;
            if (this.pResourceTypeMap[iCode] != undefined) {
                pPool = this.pResourceTypeMap[iCode];
                delete this.pResourceTypeMap[iCode];
            }

            if (pPool != null) {
                for (var i in this.pResourceFamilyList[pCode.family]) {
                    if (this.pResourceFamilyList[pCode.family][i] == pPool) {
                        delete this.pResourceFamilyList[pCode.family][i];
                        return pPool;
                    }
                }
            }

            return pPool;
        }


        destroyResourceFamily(eFamily: EResourceFamilies): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 148 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;


            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].destroyAll();
            }
        }

        restoreResourceFamily(eFamily: EResourceFamilies): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 157 ); logger.assert(eFamily >= 0, "invalid family index"); ;
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 158 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].restoreAll();
            }
        }

        disableResourceFamily(eFamily: EResourceFamilies): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 166 ); logger.assert(eFamily >= 0, "invalid family index"); ;
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 167 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].disableAll();
            }
        }

        cleanResourceFamily(eFamily: EResourceFamilies): void  {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 175 ); logger.assert(eFamily >= 0, "invalid family index"); ;
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 176 ); logger.assert(eFamily < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES, "invalid family index"); ;

            for (var i in this.pResourceFamilyList[eFamily]) {
                this.pResourceFamilyList[eFamily][i].clean();
            }
        }

        destroyResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].destroyAll();
            }
        }

        restoreResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].restoreAll();
            }
        }

        disableResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].disableAll();
            }
        }

        cleanResourceType(pCode: IResourceCode): void {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                this.pResourceTypeMap[pCode.toNumber()].clean();
            }
        }

        findResourcePool(pCode: IResourceCode): IResourcePool {
            if (isDef(this.pResourceTypeMap[pCode.toNumber()])) {
                return this.pResourceTypeMap[pCode.toNumber()];
            }

            return null;
        }

        findResourceHandle(pCode: IResourceCode, sName: string):  number  {
            var pPool: IResourcePool = this.findResourcePool(pCode);
            var iHandle:  number  = INVALID_INDEX;

            if (!isNull(pPool)) {
                iHandle = pPool.findResourceHandle(sName);
            }

            return iHandle;
        }

        findResource(pCode: IResourceCode, sName: string): IResourcePoolItem;
        findResource(pCode: IResourceCode, iHandle:  number ): IResourcePoolItem;
        findResource(pCode, sName): IResourcePoolItem {
            var pPool: IResourcePool = this.findResourcePool(pCode);
            var pResult: IResourcePoolItem = null;
            var iHandle:  number  = 0;

            if (isString(arguments[1])) {
                iHandle = pPool.findResourceHandle(sName);
            }
            else if (isInt(arguments[1])) {
                iHandle = arguments[1];
            }

            if (pPool != null && iHandle != INVALID_INDEX) {
                pResult = pPool.getResource(iHandle);
            }

            return pResult;
        }

        monitorInitResources(fnMonitor: IResourceWatcherFunc): void {
            var me: IResourcePoolManager = this;

            this.pWaiterResource.setStateWatcher(EResourceItemEvents.LOADED, function () {
                fnMonitor.apply(me, arguments);
            });
        }

        setLoadedAllRoutine(fnCallback: Function): void {
            var pPool: IResourcePool;
            var pResource: IResourcePoolItem;
            var iHandleResource:  number ;
            var pWaiterResouse: IResourcePoolItem = this.pWaiterResource;

            var fnResCallback = function (iFlagBit?:  number , iResourceFlags?:  number , isSetting?: bool) {
                if (iFlagBit == <number>EResourceItemEvents.LOADED && isSetting) {
                    fnCallback();
                }
            };

            pWaiterResouse.notifyLoaded();

            for (var n:  number  = 0; n < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; n ++) {
                for (var i:  number  = 0; i < ResourcePoolManager.pTypedResourseTotal[n]; i ++) {
                    pPool = this.findResourcePool(new ResourceCode(n, i));

                    if (pPool) {
                        var pResources: IResourcePoolItem[] = pPool.getResources();
                        var pResource: IResourcePoolItem;

                        for (var i:  number  = 0; i < pResources.length; ++ i) {
                            pResource = pResources[i];
                            pWaiterResouse.sync(pResource, EResourceItemEvents.LOADED);
                        }
                    }

                }
            }

            if (pWaiterResouse.isResourceLoaded()) {
                fnCallback();
            }
            else {
                pWaiterResouse.setChangesNotifyRoutine(fnResCallback);
            }
        }

        destroyAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.destroyResourceFamily(<EResourceFamilies><number>i);
            }
        }

        restoreAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.restoreResourceFamily(<EResourceFamilies><number>i);
            }
        }

        disableAll(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.disableResourceFamily(<EResourceFamilies><number>i);
            }
        }


        clean(): void {
            for (var i:  number  = 0; i < <number>EResourceFamilies.TOTAL_RESOURCE_FAMILIES; i ++) {
                this.cleanResourceFamily(<EResourceFamilies><number>i);
            }
        }

        createDeviceResources(): bool {
            return true;
        }

        destroyDeviceResources(): bool {
            this.disableDeviceResources();

// then destroy...
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 327 ); logger.log("Destroying Video Device Resources\n"); ;

            this.destroyResourceFamily(EResourceFamilies.VIDEO_RESOURCE);

            return true;
        }

        restoreDeviceResources(): bool {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 335 ); logger.log("Restoring Video Device Resources\n"); ;
            this.restoreResourceFamily(EResourceFamilies.VIDEO_RESOURCE);
            return true;
        }

        disableDeviceResources(): bool {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 341 ); logger.log("Disabling Video Device Resources\n"); ;
            this.disableResourceFamily(EResourceFamilies.VIDEO_RESOURCE);
            return true;
        }

        inline getEngine(): Engine { return this.pEngine; }

        inline createRenderMethod(sResourceName: string): IRenderMethod {
            return <IRenderMethod>this.renderMethodPool.createResource(sResourceName);
        }

        inline createTexture(sResourceName: string): ITexture {
            return <ITexture>this.texturePool.createResource(sResourceName);
        }

        inline createEffect(sResourceName: string): IEffect {
            return <IEffect>this.effectPool.createResource(sResourceName);
        }

        inline createSurfaceMaterial(sResourceName: string): ISurfaceMaterial {
            return <ISurfaceMaterial>this.surfaceMaterialPool.createResource(sResourceName);
        }

        inline createVertexBuffer(sResourceName: string): IVertexBuffer {
            return <IVertexBuffer>this.vertexBufferPool.createResource(sResourceName);
        }

        inline createVideoBuffer(sResourceName: string): IVertexBuffer {
            return <IVertexBuffer>this.videoBufferPool.createResource(sResourceName);
        }

        inline createIndexBuffer(sResourceName: string): IIndexBuffer {
            return <IIndexBuffer>this.indexBufferPool.createResource(sResourceName);
        };

        inline createModel(sResourceName: string): IModel {
            return <IModel>this.colladaPool.createResource(sResourceName);
        }

        inline createImg(sResourceName: string): IImg {
            return <IImg>this.imagePool.createResource(sResourceName);
        }

        inline loadModel(sFilename: string, pOptions: any = null): IModel {
            if (util.pathinfo(sFilename).ext.toLowerCase() === "dae") {
                var pCollada: ICollada = <ICollada>this.colladaPool.findResource(sFilename);

                if (isNull(pCollada)) {
                    pCollada = <ICollada>this.colladaPool.createResource(sFilename);
                }

                if (!pCollada.isResourceLoaded()) {
                    pCollada.loadResource(sFilename, <IColladaLoadOptions>pOptions);
                }

                return pCollada;
            }

            return null;
        }



        private createDeviceResource(): void {
            this.pSurfaceMaterialPool = new ResourcePool(this, resources.SurfaceMaterial);
            this.pSurfaceMaterialPool.initialize(16);

            this.pEffectPool = new ResourcePool(this, resources.Effect);
            this.pEffectPool.initialize(16);

            this.pRenderMethodPool = new ResourcePool(this, resources.RenderMethod);
            this.pRenderMethodPool.initialize(16);


            this.pColladaPool = new ResourcePool(this, resources.Collada);
            this.pColladaPool.initialize(0);

            this.pImagePool = new ResourcePool(this, resources.Img);
            this.pImagePool.initialize(16);


            this.pTexturePool = new ResourcePool(this, webgl.WebGLInternalTexture);
            this.pTexturePool.initialize(16);

            this.pIndexBufferPool = new ResourcePool(this, webgl.WebGLIndexBuffer);
            this.pIndexBufferPool.initialize(16);

            this.pVertexBufferPool = new ResourcePool(this, webgl.WebGLVertexBuffer);
            this.pVertexBufferPool.initialize(16);

            this.pVideoBufferPool = new ResourcePool(this, webgl.WebGLVertexTexture);
            this.pVideoBufferPool.initialize(16);

            this.pTextureBufferPool = new ResourcePool(this, webgl.WebGLTextureBuffer);
            this.pTextureBufferPool.initialize(16);

            this.pShaderProgramPool = new ResourcePool(this, webgl.WebGLShaderProgram);
            this.pShaderProgramPool.initialize(16);

            this.pRenderBufferPool = new ResourcePool(this, webgl.WebGLInternalRenderBuffer);
            this.pRenderBufferPool.initialize(16);

            this.pDepthBufferPool = new ResourcePool(this, webgl.WebGLDepthBuffer);
            this.pDepthBufferPool.initialize(16);


            this.pEffectDataPool = new ResourcePool(this, resources.EffectData);
            this.pEffectDataPool.initialize(8);


            this.pComponentPool = new ResourcePool(this, resources.Component);
            this.pComponentPool.initialize(16);
        }

        private registerDeviceResources(): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 458 ); logger.log("Registering Video Device Resources\n"); ;
            this.pTexturePool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.TEXTURE_RESOURCE));
            this.pVertexBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.VERTEXBUFFER_RESOURCE));
            this.pIndexBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.INDEXBUFFER_RESOURCE));
            this.pEffectPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.EFFECT_RESOURCE));
            this.pRenderMethodPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.RENDERMETHOD_RESOURCE));
            this.pColladaPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.MODEL_RESOURCE));
            this.pImagePool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.IMAGE_RESOURCE));
            this.pSurfaceMaterialPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.SURFACEMATERIAL_RESOURCE));
            this.pVideoBufferPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.VIDEOBUFFER_RESOURCE));
            this.pShaderProgramPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.SHADERPROGRAM_RESOURCE));
            this.pComponentPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.COMPONENT_RESOURCE));
            this.pEffectDataPool.registerResourcePool(
                new ResourceCode(
                    <number>EResourceFamilies.VIDEO_RESOURCE,
                    <number>EVideoResources.EFFECTDATA_RESOURCE));
        }

        private unregisterDeviceResources(): void {
            logger.setSourceLocation( "pool/ResourcePoolManager.ts" , 510 ); logger.log("Unregistering Video Device Resources"); ;

            this.pTexturePool.unregisterResourcePool();
            this.pVertexBufferPool.unregisterResourcePool();
            this.pIndexBufferPool.unregisterResourcePool();
            this.pEffectPool.unregisterResourcePool();
            this.pRenderMethodPool.unregisterResourcePool();
            this.pColladaPool.unregisterResourcePool();
            this.pImagePool.unregisterResourcePool();
            this.pSurfaceMaterialPool.unregisterResourcePool();
            this.pVideoBufferPool.unregisterResourcePool();
            this.pShaderProgramPool.unregisterResourcePool();
            this.pComponentPool.unregisterResourcePool();
        }

    	static private pTypedResourseTotal:  number [] = [
	        <number>EVideoResources.TOTAL_VIDEO_RESOURCES,
	        <number>EAudioResources.TOTAL_AUDIO_RESOURCES,
	        <number>EGameResources.TOTAL_GAME_RESOURCES
	    ];
    }
}



















module akra {
	export interface IScene2d extends IScene {

	}
}























































module akra {

	export interface IVec3 {} ;
	export interface ICircle {} ;

	export interface ISphere {

		center: IVec3;
		radius:  number ;

		circle: ICircle;
		z:  number ;

		set(): ISphere;
		set(pSphere: ISphere): ISphere;
		set(v3fCenter: IVec3, fRadius:  number ): ISphere;
		set(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number ): ISphere;

		clear(): ISphere;

		isEqual(pSphere: ISphere): bool;
		isClear(): bool;
		isValid(): bool;

		offset(v3fOffset: IVec3): ISphere;
		expand(fInc:  number ): ISphere;
		normalize(): ISphere;

		transform(m4fMatrix: IMat4): ISphere;
	};
};





module akra.geometry{
	export class Sphere implements ISphere{
		center: IVec3;
		radius:  number ;

		constructor();
		constructor(pSphere: ISphere);
		constructor(v3fCenter: IVec3, fRadius:  number );
		constructor(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number );
		constructor(fCenterX?, fCenterY?, fCenterZ?, fRadius?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pSphere = arguments[0];

					this.center = new Vec3(pSphere.v3fCenter);
					this.radius = pSphere.fRadius;
					break;
				case 2:
					var v3fCenter: IVec3 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center = new Vec3(v3fCenter);
					this.radius = fRadius;
					break;
				case 4:
					this.center = new Vec3(arguments[0], arguments[1], arguments[2]);
					this.radius = arguments[3];
					break;
				default:
					this.center = new Vec3();
					this.radius = 0.;
					break;
			}
		};

		get circle(): ICircle{
			var v3fCenter: IVec3 = this.center;
			return new Circle(v3fCenter.x, v3fCenter.y, this.radius);
		};
		set circle(pCircle: ICircle){
			var v3fCenter: IVec3 = this.center;
			var v2fCircleCenter: IVec2 = pCircle.center;
			v3fCenter.x = v2fCircleCenter.x;
			v3fCenter.y = v2fCircleCenter.y;
			this.radius = pCircle.radius;
		};

		get z():  number {
			return this.center.z;
		};
		set z(fZ:  number ){
			this.center.z = fZ;
		};

		set(): ISphere;
		set(pSphere: ISphere): ISphere;
		set(v3fCenter: IVec3, fRadius:  number ): ISphere;
		set(fCenterX:  number , fCenterY:  number , fCenterZ:  number , fRadius:  number ): ISphere;
		set(fCenterX?, fCenterY?, fCenterZ?, fRadius?): ISphere{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pSphere = arguments[0];

					this.center.set(pSphere.center);
					this.radius = pSphere.radius;
					break;
				case 2:
					var v3fCenter: IVec3 = arguments[0];
					var fRadius:  number  = arguments[1];

					this.center.set(v3fCenter);
					this.radius = fRadius;
					break;
				case 4:
					this.center.set(arguments[0], arguments[1], arguments[2]);
					this.radius = arguments[3];
					break;
				default:
					this.center.set(0.);
					this.radius = 0.;
					break;
			}

			return this;
		};

		inline clear(): ISphere{
			this.center.clear();
			this.radius = 0.;

			return this;
		};

		inline isEqual(pSphere: ISphere): bool{
			return this.center.isEqual(pSphere.center) && (this.radius == pSphere.radius);
		};

		inline isClear(): bool{
			return this.center.isClear() && (this.radius === 0.);
		};

		inline isValid(): bool{
			return (this.radius >= 0.);
		};

		inline offset(v3fOffset: IVec3): ISphere{
			this.center.add(v3fOffset);
			return this;
		};

		inline expand(fInc:  number ): ISphere{
			this.radius += fInc;
			return this;
		};

		inline normalize(): ISphere{
			this.radius = math.abs(this.radius);
			return this;
		};

		transform(m4fMatrix: IMat4): ISphere {
			logger.setSourceLocation( "Sphere.ts" , 133 ); logger.criticalError("TODO: transform() for Sphere similar to Rect3d::transform();"); ;

			return this;
		}
	};
}








module akra {

	export interface IRect2d {} ;
	export interface IVec3 {} ;

	export interface IRect3d {
		x0:  number ;
		x1:  number ;
		y0:  number ;
		y1:  number ;
		z0:  number ;
		z1:  number ;

		rect2d: IRect2d;

		set(): IRect3d;
		set(pRect: IRect3d): IRect3d;
		set(v3fSize: IVec3): IRect3d;
		set(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		set(v3fMinPoint: IVec3, v3fMaxPoint: IVec3): IRect3d;
		set(fX0:  number , fX1:  number , fY0:  number ,
			fY1:  number , fZ0:  number , fZ1:  number ): IRect3d;

		setFloor(pRect: IRect3d): IRect3d;
		setCeil(pRect: IRect3d): IRect3d;

		clear(): IRect3d;

		addSelf(fValue:  number ): IRect3d;
		addSelf(v3fVec: IVec3): IRect3d;

		subSelf(fValue:  number ): IRect3d;
		subSelf(v3fVec: IVec3): IRect3d;

		multSelf(fValue:  number ): IRect3d;
		multSelf(v3fVec: IVec3): IRect3d;

		divSelf(fValue:  number ): IRect3d;
		divSelf(v3fVec: IVec3): IRect3d;

		offset(v3fOffset: IVec3): IRect3d;
		offset(fOffsetX:  number , fOffsetY:  number , fOffsetZ:  number ): IRect3d;

		expand(fValue:  number ): IRect3d;
		expand(v3fVec: IVec3): IRect3d;
		expand(fValueX:  number , fValueY:  number , fValueZ:  number ): IRect3d;

		expandX(fValue:  number ): IRect3d;
		expandY(fValue:  number ): IRect3d;
		expandZ(fValue:  number ): IRect3d;

		resize(v3fSize: IVec3): IRect3d;
		resize(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;

		resizeX(fSize:  number ): IRect3d;
		resizeY(fSize:  number ): IRect3d;
		resizeZ(fSize:  number ): IRect3d;

		resizeMax(v3fSpan: IVec3): IRect3d;
		resizeMax(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;

		resizeMaxX(fSpan:  number ): IRect3d;
		resizeMaxY(fSpan:  number ): IRect3d;
		resizeMaxZ(fSpan:  number ): IRect3d;

		resizeMin(v3fSpan: IVec3): IRect3d;
		resizeMin(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;

		resizeMinX(fSpan:  number ): IRect3d;
		resizeMinY(fSpan:  number ): IRect3d;
		resizeMinZ(fSpan:  number ): IRect3d;

		unionPoint(v3fPoint: IVec3): IRect3d;
		unionPoint(fX:  number , fY:  number , fZ:  number ): IRect3d;
		unionRect(pRect: IRect3d): IRect3d;

		negate(pDestination?: IRect3d): IRect3d;
		normalize(): IRect3d;

		transform(m4fMatrix: IMat4): IRect3d;

		isEqual(pRect: IRect3d): bool;
		isClear(): bool;
		isValid(): bool;
		isPointInRect(v3fPoint: IVec3): bool;

		midPoint(v3fDestination?: IVec3): IVec3;
		midX():  number ;
		midY():  number ;
		midZ():  number ;

		size(v3fDestination: IVec3): IVec3;
		sizeX():  number ;
		sizeY():  number ;
		sizeZ():  number ;

		minPoint(v3fDestination?: IVec3): IVec3;
		maxPoint(v3fDestination?: IVec3): IVec3;

		volume():  number ;

		corner(iIndex:  number , v3fDestination?: IVec3): IVec3;

		createBoundingSphere(pSphere?: ISphere): ISphere;

		toString(): string;
	}
}





module akra.geometry {
    export class Rect3d implements IRect3d{
    	x0:  number ;
    	x1:  number ;
		y0:  number ;
		y1:  number ;
		z0:  number ;
		z1:  number ;

		constructor();
		constructor(pRect: IRect3d);
		constructor(v3fSize: IVec3);
		constructor(fSizeX:  number , fSizeY:  number , fSizeZ:  number );
		constructor(v3fMinPoint: IVec3, v3fMaxPoint: IVec3);
		constructor(fX0:  number , fX1:  number , fY0:  number ,
					fY1:  number , fZ0:  number , fZ1:  number );
		constructor(fX0?, fX1?, fY0?, fY1?, fZ0?, fZ1?){
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				case 6:
					this.set(arguments[0], arguments[1], arguments[2],
							arguments[3], arguments[4], arguments[5]);
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
					break;
			}
		};

		get rect2d(): IRect2d{
			return new Rect2d(this.x0, this.x1, this.y0, this.y1);
		};

		set rect2d(pRect: IRect2d){
			this.x0 = pRect.x0;
			this.x1 = pRect.x1;
			this.y0 = pRect.y0;
			this.y1 = pRect.y1;
		};

		set(): IRect3d;
		set(pRect: IRect3d): IRect3d;
		set(v3fSize: IVec3): IRect3d;
		set(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		set(v3fMinPoint: IVec3, v3fMaxPoint: IVec3): IRect3d;
		set(fX0:  number , fX1:  number , fY0:  number ,
			fY1:  number , fZ0:  number , fZ1:  number ): IRect3d;
		set(fX0?, fX1?, fY0?, fY1?, fZ0?, fZ1?): IRect3d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					if(arguments[0] instanceof Rect3d){
						var pRect: IRect3d = arguments[0];

						this.x0 = pRect.x0;
						this.x1 = pRect.x1;
						this.y0 = pRect.y0;
						this.y1 = pRect.y1;
						this.z0 = pRect.z0;
						this.z1 = pRect.z1;
					}
					else{
						var v3fSize: IVec3 = arguments[0];

						this.x1 = v3fSize.x*0.5;
						this.x0 = -this.x1;

						this.y1 = v3fSize.y*0.5;
						this.y0 = -this.y1;

						this.z1 = v3fSize.z*0.5;
						this.z0 = -this.z1;
					}
					break;
				case 2:
					var v3fMinPoint: IVec3 = arguments[0];
					var v3fMaxPoint: IVec3 = arguments[1];

					this.x0 = v3fMinPoint.x;
					this.y0 = v3fMinPoint.y;
					this.z0 = v3fMinPoint.z;

					this.x1 = v3fMaxPoint.x;
					this.y1 = v3fMaxPoint.y;
					this.z1 = v3fMaxPoint.z;
					break;
				case 3:
					var fSizeX:  number  = arguments[0];
					var fSizeY:  number  = arguments[1];
					var fSizeZ:  number  = arguments[2];

					this.x1 = fSizeX*0.5;
					this.x0 = -this.x1;

					this.y1 = fSizeY*0.5;
					this.y0 = -this.y1;

					this.z1 = fSizeZ*0.5;
					this.z0 = -this.z1;
					break;
				case 6:
					this.x0 = arguments[0];
					this.x1 = arguments[1];

					this.y0 = arguments[2];
					this.y1 = arguments[3];

					this.z0 = arguments[4];
					this.z1 = arguments[5];
					break;
				default:
					this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
					break;
			}
			return this;
		};

		setFloor(pRect: IRect3d): IRect3d{
			this.x0 = math.floor(pRect.x0);
			this.x1 = math.floor(pRect.x1);
			this.y0 = math.floor(pRect.y0);
			this.y1 = math.floor(pRect.y1);
			this.z0 = math.floor(pRect.z0);
			this.z1 = math.floor(pRect.z1);

			return this;
		};

		setCeil(pRect: IRect3d): IRect3d{
			this.x0 = math.ceil(pRect.x0);
			this.x1 = math.ceil(pRect.x1);
			this.y0 = math.ceil(pRect.y0);
			this.y1 = math.ceil(pRect.y1);
			this.z0 = math.ceil(pRect.z0);
			this.z1 = math.ceil(pRect.z1);

			return this;
		};

		inline clear(): IRect3d{
			this.x0 = this.x1 = this.y0 = this.y1 = this.z0 = this.z1 = 0.;
			return this;
		};

		addSelf(fValue:  number ): IRect3d;
		addSelf(v3fVec: IVec3): IRect3d;
		addSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 += fValue;
				this.x1 += fValue;
				this.y0 += fValue;
				this.y1 += fValue;
				this.z0 += fValue;
				this.z1 += fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 += v3fVec.x;
				this.x1 += v3fVec.x;

				this.y0 += v3fVec.y;
				this.y1 += v3fVec.y;

				this.z0 += v3fVec.z;
				this.z1 += v3fVec.z;
			}

			return this;
		};


		subSelf(fValue:  number ): IRect3d;
		subSelf(v3fVec: IVec3): IRect3d;
		subSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 -= fValue;
				this.x1 -= fValue;
				this.y0 -= fValue;
				this.y1 -= fValue;
				this.z0 -= fValue;
				this.z1 -= fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 -= v3fVec.x;
				this.x1 -= v3fVec.x;

				this.y0 -= v3fVec.y;
				this.y1 -= v3fVec.y;

				this.z0 -= v3fVec.z;
				this.z1 -= v3fVec.z;
			}

			return this;
		};

		multSelf(fValue:  number ): IRect3d;
		multSelf(v3fVec: IVec3): IRect3d;
		multSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				this.x0 *= fValue;
				this.x1 *= fValue;
				this.y0 *= fValue;
				this.y1 *= fValue;
				this.z0 *= fValue;
				this.z1 *= fValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				this.x0 *= v3fVec.x;
				this.x1 *= v3fVec.x;

				this.y0 *= v3fVec.y;
				this.y1 *= v3fVec.y;

				this.z0 *= v3fVec.z;
				this.z1 *= v3fVec.z;
			}

			return this;
		};

		divSelf(fValue:  number ): IRect3d;
		divSelf(v3fVec: IVec3): IRect3d;
		divSelf(v3fVec?): IRect3d{
			if(isFloat(arguments[0])){
				var fValue:  number  = arguments[0];

				logger.setSourceLocation( "geometry/Rect3d.ts" , 261 ); logger.assert(fValue != 0.0, "divide by zero error"); ;

				var fInvValue:  number  = 1./fValue;

				this.x0 *= fInvValue;
				this.x1 *= fInvValue;
				this.y0 *= fInvValue;
				this.y1 *= fInvValue;
				this.z0 *= fInvValue;
				this.z1 *= fInvValue;
			}
			else{
				var v3fVec: IVec3 = arguments[0];

				logger.setSourceLocation( "geometry/Rect3d.ts" , 275 ); logger.assert(v3fVec.x != 0.0, "divide by zero error"); ;
				logger.setSourceLocation( "geometry/Rect3d.ts" , 276 ); logger.assert(v3fVec.y != 0.0, "divide by zero error"); ;
				logger.setSourceLocation( "geometry/Rect3d.ts" , 277 ); logger.assert(v3fVec.z != 0.0, "divide by zero error"); ;

				var fInvX:  number  = 1./v3fVec.x;
				var fInvY:  number  = 1./v3fVec.y;
				var fInvZ:  number  = 1./v3fVec.z;

				this.x0 *= fInvX;
				this.x1 *= fInvX;

				this.y0 *= fInvY;
				this.y1 *= fInvY;

				this.z0 *= fInvZ;
				this.z1 *= fInvZ;
			}

			return this;
		};

		offset(v3fOffset: IVec3): IRect3d;
		offset(fOffsetX:  number , fOffsetY:  number , fOffsetZ:  number ): IRect3d;
		offset(fOffsetX?, fOffsetY?, fOffsetZ?): IRect3d{
			if(arguments.length === 1){
				var v3fOffset: IVec3 = arguments[0];

				this.x0 += v3fOffset.x;
				this.x1 += v3fOffset.x;

				this.y0 += v3fOffset.y;
				this.y1 += v3fOffset.y;

				this.z0 += v3fOffset.z;
				this.z1 += v3fOffset.z;
			}
			else{
				this.x0 += arguments[0];
				this.x1 += arguments[0];

				this.y0 += arguments[1];
				this.y1 += arguments[1];

				this.z0 += arguments[2];
				this.z1 += arguments[2];
			}

			return this;
		};

		expand(fValue:  number ): IRect3d;
		expand(v3fVec: IVec3): IRect3d;
		expand(fValueX:  number , fValueY:  number , fValueZ:  number ): IRect3d;
		expand(fValueX?, fValueY?, fValueZ?): IRect3d{
			if(arguments.length === 1){
				if(isFloat(arguments[0])){
					var fValue:  number  = arguments[0];

					this.x0 -= fValue;
					this.x1 += fValue;

					this.y0 -= fValue;
					this.y1 += fValue;

					this.z0 -= fValue;
					this.z1 += fValue;
				}
				else{
					var v3fVec: IVec3 = arguments[0];

					this.x0 -= v3fVec.x;
					this.x1 += v3fVec.x;

					this.y0 -= v3fVec.y;
					this.y1 += v3fVec.y;

					this.z0 -= v3fVec.z;
					this.z1 += v3fVec.z;
				}
			}
			else{
//arguments.length === 3

				this.x0 -= arguments[0];
				this.x1 += arguments[0];

				this.y0 -= arguments[1];
				this.y1 += arguments[1];

				this.z0 -= arguments[2];
				this.z1 += arguments[2];
			}

			return this;
		};

		inline expandX(fValue:  number ): IRect3d{
			this.x0 -= fValue;
			this.x1 += fValue;

			return this;
		};

		inline expandY(fValue:  number ): IRect3d{
			this.y0 -= fValue;
			this.y1 += fValue;

			return this;
		};

		inline expandZ(fValue:  number ): IRect3d{
			this.z0 -= fValue;
			this.z1 += fValue;

			return this;
		};

		resize(v3fSize: IVec3): IRect3d;
		resize(fSizeX:  number , fSizeY:  number , fSizeZ:  number ): IRect3d;
		resize(fSizeX?, fSizeY?, fSizeZ?): IRect3d{
			var fSizeX:  number , fSizeY:  number , fSizeZ:  number ;

			if(arguments.length === 1){
				var v3fSize: IVec3 = arguments[0];

				fSizeX = v3fSize.x;
				fSizeY = v3fSize.y;
				fSizeZ = v3fSize.z;
			}
			else{
				fSizeX = arguments[0];
				fSizeY = arguments[1];
				fSizeZ = arguments[2];
			}

			this.x1 = (this.x0 + this.x1 + fSizeX)*0.5;
			this.x0 = this.x1 - fSizeX;

			this.y1 = (this.y0 + this.y1 + fSizeY)*0.5;
			this.y0 = this.y1 - fSizeY;

			this.z1 = (this.z0 + this.z1 + fSizeZ)*0.5;
			this.z0 = this.z1 - fSizeZ;

			return this;
		};

		inline resizeX(fSize:  number ): IRect3d{
			this.x1 = (this.x0 + this.x1 + fSize)*0.5;
			this.x0 = this.x1 - fSize;

			return this;
		};

		inline resizeY(fSize:  number ): IRect3d{
			this.y1 = (this.y0 + this.y1 + fSize)*0.5;
			this.y0 = this.y1 - fSize;

			return this;
		};

		inline resizeZ(fSize:  number ): IRect3d{
			this.z1 = (this.z0 + this.z1 + fSize)*0.5;
			this.z0 = this.z1 - fSize;

			return this;
		};

		resizeMax(v3fSpan: IVec3): IRect3d;
		resizeMax(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;
		resizeMax(fSpanX?, fSpanY?, fSpanZ?): IRect3d{
			if(arguments.length === 1){
				var v3fSpan: IVec3 = arguments[0];

				this.x1 = this.x0 + v3fSpan.x;
				this.y1 = this.y0 + v3fSpan.y;
				this.z1 = this.z0 + v3fSpan.z;
			}
			else{
//arguments.length === 3
				this.x1 = this.x0 + arguments[0];
				this.y1 = this.y0 + arguments[1];
				this.z1 = this.z0 + arguments[2];
			}

			return this;
		};

		inline resizeMaxX(fSpan:  number ): IRect3d{
			this.x1 = this.x0 + fSpan;
			return this;
		};

		inline resizeMaxY(fSpan:  number ): IRect3d{
			this.y1 = this.y0 + fSpan;
			return this;
		};

		inline resizeMaxZ(fSpan:  number ): IRect3d{
			this.z1 = this.z0 + fSpan;
			return this;
		};

		resizeMin(v3fSpan: IVec3): IRect3d;
		resizeMin(fSpanX:  number , fSpanY:  number , fSpanZ:  number ): IRect3d;
		resizeMin(fSpanX?, fSpanY?, fSpanZ?): IRect3d{
			if(arguments.length === 1){
				var v3fSpan: IVec3 = arguments[0];

				this.x0 = this.x1 - v3fSpan.x;
				this.y0 = this.y1 - v3fSpan.y;
				this.z0 = this.z1 - v3fSpan.z;
			}
			else{
//arguments.length === 3
				this.x0 = this.x1 - arguments[0];
				this.y0 = this.y1 - arguments[1];
				this.z0 = this.z1 - arguments[2];
			}

			return this;
		};

		inline resizeMinX(fSpan:  number ): IRect3d{
			this.x0 = this.x1 - fSpan;
			return this;
		};

		inline resizeMinY(fSpan:  number ): IRect3d{
			this.y0 = this.y1 - fSpan;
			return this;
		};

		inline resizeMinZ(fSpan:  number ): IRect3d{
			this.z0 = this.z1 - fSpan;
			return this;
		};

		unionPoint(v3fPoint: IVec3): IRect3d;
		unionPoint(fX:  number , fY:  number , fZ:  number ): IRect3d;
		unionPoint(fX?, fY?, fZ?): IRect3d{
			if(arguments.length === 1){
				var v3fPoint: IVec3 = arguments[0];

				this.x0 = math.min(this.x0, v3fPoint.x);
				this.x1 = math.max(this.x1, v3fPoint.x);

				this.y0 = math.min(this.y0, v3fPoint.y);
				this.y1 = math.max(this.y1, v3fPoint.y);

				this.z0 = math.min(this.z0, v3fPoint.z);
				this.z1 = math.max(this.z1, v3fPoint.z);
			}
			else{
//arguments.length === 3

				this.x0 = math.min(this.x0, arguments[0]);
				this.x1 = math.max(this.x1, arguments[0]);

				this.y0 = math.min(this.y0, arguments[1]);
				this.y1 = math.max(this.y1, arguments[1]);

				this.z0 = math.min(this.z0, arguments[2]);
				this.z1 = math.max(this.z1, arguments[2]);
			}

			return this;
		};

		unionRect(pRect: IRect3d): IRect3d{
			this.normalize();
			pRect.normalize();

			this.x0 = math.min(this.x0, pRect.x0);
			this.x1 = math.max(this.x1, pRect.x1);

			this.y0 = math.min(this.y0, pRect.y0);
			this.y1 = math.max(this.y1, pRect.y1);

			this.z0 = math.min(this.z0, pRect.z0);
			this.z1 = math.max(this.z1, pRect.z1);

			return this;
		};

		negate(pDestination?: IRect3d): IRect3d{
			if(!isDef(pDestination)){
				pDestination = this;
			}

			return pDestination.set(-this.x1, -this.x0,
							 -this.y1, -this.y0,
							 -this.z1, -this.z0);
		};

		normalize(): IRect3d{
			var fTmp:  number ;
			if(this.x0 > this.x1){
				fTmp = this.x0;
				this.x0 = this.x1;
				this.x1 = fTmp;
			}
			if(this.y0 > this.y1){
				fTmp = this.y0;
				this.y0 = this.y1;
				this.y1 = fTmp;
			}
			if(this.z0 > this.z1){
				fTmp = this.z0;
				this.z0 = this.z1;
				this.z1 = fTmp;
			}

			return this;
		};

		transform(m4fMatrix: IMat4): IRect3d{
			var pData: Float32Array = m4fMatrix.data;

			var a11:  number  = pData[ 0 ], a12:  number  = pData[ 4 ],
				a13:  number  = pData[ 8 ], a14:  number  = pData[ 12 ];
			var a21:  number  = pData[ 1 ], a22:  number  = pData[ 5 ],
				a23:  number  = pData[ 9 ], a24:  number  = pData[ 13 ];
			var a31:  number  = pData[ 2 ], a32:  number  = pData[ 6 ],
				a33:  number  = pData[ 10 ], a34:  number  = pData[ 14 ];

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;
			var fZ0:  number  = this.z0, fZ1:  number  = this.z1;

//base point

			var fBaseX:  number  = a11*fX0 + a12*fY0 + a13*fZ0 + a14;
			var fBaseY:  number  = a21*fX0 + a22*fY0 + a23*fZ0 + a24;
			var fBaseZ:  number  = a31*fX0 + a32*fY0 + a33*fZ0 + a34;

//new x vector

			var fXNewX:  number  = a11*(fX1 - fX0);
			var fXNewY:  number  = a21*(fX1 - fX0);
			var fXNewZ:  number  = a31*(fX1 - fX0);

//new y vector

			var fYNewX:  number  = a12*(fY1 - fY0);
			var fYNewY:  number  = a22*(fY1 - fY0);
			var fYNewZ:  number  = a32*(fY1 - fY0);

//new z vector

			var fZNewX:  number  = a13*(fZ1 - fZ0);
			var fZNewY:  number  = a23*(fZ1 - fZ0);
			var fZNewZ:  number  = a33*(fZ1 - fZ0);

			var fXMultX:  number  = (fXNewX > 0.) ? 1. : 0.;
			var fYMultX:  number  = (fYNewX > 0.) ? 1. : 0.;
			var fZMultX:  number  = (fZNewX > 0.) ? 1. : 0.;

			var fXMultY:  number  = (fXNewY > 0.) ? 1. : 0.;
			var fYMultY:  number  = (fYNewY > 0.) ? 1. : 0.;
			var fZMultY:  number  = (fZNewY > 0.) ? 1. : 0.;

			var fXMultZ:  number  = (fXNewZ > 0.) ? 1. : 0.;
			var fYMultZ:  number  = (fYNewZ > 0.) ? 1. : 0.;
			var fZMultZ:  number  = (fZNewZ > 0.) ? 1. : 0.;

			this.x1 = fBaseX + fXMultX*fXNewX + fYMultX*fYNewX + fZMultX*fZNewX;
			this.y1 = fBaseY + fXMultY*fXNewY + fYMultY*fYNewY + fZMultY*fZNewY;
			this.z1 = fBaseZ + fXMultZ*fXNewZ + fYMultZ*fYNewZ + fZMultZ*fZNewZ;

			this.x0 = fBaseX + (1. - fXMultX)*fXNewX + (1. - fYMultX)*fYNewX + (1. - fZMultX)*fZNewX;
			this.y0 = fBaseY + (1. - fXMultY)*fXNewY + (1. - fYMultY)*fYNewY + (1. - fZMultY)*fZNewY;
			this.z0 = fBaseZ + (1. - fXMultZ)*fXNewZ + (1. - fYMultZ)*fYNewZ + (1. - fZMultZ)*fZNewZ;

			return this;
		};

		inline isEqual(pRect: IRect3d): bool{
			return this.x0 == pRect.x0 && this.x1 == pRect.x1
					&& this.y0 == pRect.y0 && this.y1 == pRect.y1
					&& this.z0 == pRect.z0 && this.z1 == pRect.z1;
		};

		inline isClear(): bool{
			return this.x0 == 0. && this.x1 == 0.
					&& this.y0 == 0. && this.y1 == 0.
					&& this.z0 == 0. && this.z1 == 0.;
		};

		inline isValid(): bool{
			return this.x0 <= this.x1
					&& this.y0 <= this.y1
					&& this.z0 <= this.z1;
		};

		inline isPointInRect(v3fPoint: IVec3): bool{
			var x:  number  = v3fPoint.x;
			var y:  number  = v3fPoint.y;
			var z:  number  = v3fPoint.z;

			return (this.x0 <= x && x <= this.x1)
					&& (this.y0 <= y && y <= this.y1)
					&& (this.z0 <= z && z <= this.z1);
		};

		midPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set((this.x0 + this.x1)*0.5,
									  (this.y0 + this.y1)*0.5,
									  (this.z0 + this.z1)*0.5);
		};

		inline midX():  number {
			return (this.x0 + this.x1)*0.5;
		};

		inline midY():  number {
			return (this.y0 + this.y1)*0.5;
		};

		inline midZ():  number {
			return (this.z0 + this.z1)*0.5;
		}

		size(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x1 - this.x0, this.y1 - this.y0, this.z1 - this.z0);
		};

		inline sizeX():  number {
			return this.x1 - this.x0;
		};

		inline sizeY():  number {
			return this.y1 - this.y0;
		};

		inline sizeZ():  number {
			return this.z1 - this.z0;
		};

		minPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x0, this.y0, this.z0);
		};

		maxPoint(v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			return v3fDestination.set(this.x1, this.y1, this.z1);
		};

		inline volume():  number {
			return (this.x1 - this.x0)*(this.y1 - this.y0)*(this.z1 - this.z0);
		};

/**
		 * counter-clockwise and from bottom
		 * x0,y0,z0 -> x1,y0,z0 -> x1,y1,z0 -> x0,y1,z0 ->
		 * x0,y0,z1 -> x1,y0,z1 -> x1,y1,z1 -> x0,y1,z1
		 */

		corner(iIndex:  number , v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			logger.setSourceLocation( "geometry/Rect3d.ts" , 752 ); logger.assert(0 <= iIndex && iIndex < 8, "invalid index"); ;

			switch(iIndex){
				case 0:
					v3fDestination.set(this.x0, this.y0, this.z0);
					break;
				case 1:
					v3fDestination.set(this.x1, this.y0, this.z0);
					break;
				case 2:
					v3fDestination.set(this.x1, this.y1, this.z0);
					break;
				case 3:
					v3fDestination.set(this.x0, this.y1, this.z0);
					break;
				case 4:
					v3fDestination.set(this.x0, this.y0, this.z1);
					break;
				case 5:
					v3fDestination.set(this.x1, this.y0, this.z1);
					break;
				case 6:
					v3fDestination.set(this.x1, this.y1, this.z1);
					break;
				case 7:
					v3fDestination.set(this.x0, this.y1, this.z1);
					break;
			}
			return v3fDestination;
		};

		createBoundingSphere(pSphere?: ISphere): ISphere{
			if(!isDef(pSphere)){
				pSphere = new Sphere();
			}

			var fX0:  number  = this.x0, fX1:  number  = this.x1;
			var fY0:  number  = this.y0, fY1:  number  = this.y1;
			var fZ0:  number  = this.z0, fZ1:  number  = this.z1;

			var fHalfSizeX:  number  = (fX1 - fX0)*0.5;
			var fHalfSizeY:  number  = (fY1 - fY0)*0.5;
			var fHalfSizeZ:  number  = (fZ1 - fZ0)*0.5;

			pSphere.set((fX0 + fX1)*0.5, (fY0 + fY1)*0.5, (fZ0 + fZ1)*0.5,
				math.sqrt(fHalfSizeX*fHalfSizeX + fHalfSizeY*fHalfSizeY + fHalfSizeZ*fHalfSizeZ));

			return pSphere;
		};

		toString(): string{
			return "(" + this.x0 + ", " + this.y0 + ", " + this.z0 + ") --> (" +
					this.x1 + ", " + this.y1 + ", " + this.z1 +")";
		};

		static get stackCeil(): Rect3d { Rect3d.stackPosition = Rect3d.stackPosition === Rect3d.stackSize - 1? 0: Rect3d.stackPosition; return Rect3d.stack[Rect3d.stackPosition ++]; } static stackSize: number = 128; static stackPosition: number = 0; static stack: Rect3d[] = (function(): Rect3d[]{ var pStack: Rect3d[] = new Array(Rect3d.stackSize); for(var i: number = 0; i<Rect3d.stackSize; i++){ pStack[i] = new Rect3d(); } return pStack})(); ;
    }
}





module akra.scene {

	export enum ESceneObjectFlags {
		k_NewLocalBounds = 0,
		k_NewWorldBounds
	};

	export class SceneObject extends SceneNode implements ISceneObject {
		/**@protected*/  _iObjectFlags:  number  = 0;
		/**@protected*/  _pLocalBounds: IRect3d = new geometry.Rect3d();
		/**@protected*/  _pWorldBounds: IRect3d = new geometry.Rect3d();
		/**@protected*/  _hasShadows: bool = false;

		inline get totalRenderable():  number  { return 0; }

		inline get worldBounds(): IRect3d {
			return this._pWorldBounds;
		}

		inline set worldBounds(pBox: IRect3d) {
			this._pWorldBounds = pBox;
		}

		inline get localBounds(): IRect3d {
			return this._pLocalBounds;
		}


		constructor (pScene: IScene3d, eType: EEntityTypes = EEntityTypes.SCENE_OBJECT) {
			super(pScene, eType);
		}

		inline getRenderable(i?:  number ): IRenderableObject {
			return null;
		}

		accessLocalBounds(): IRect3d {
			((this._iObjectFlags) |= (1 << ((ESceneObjectFlags.k_NewLocalBounds))) ) ;
			return this._pLocalBounds;
		}

		inline isWorldBoundsNew(): bool {
			return  ((this._iObjectFlags & (1 << (ESceneObjectFlags.k_NewLocalBounds)) ) != 0) ;
		}

		destroy(): void {
			super.destroy();
		}

		prepareForUpdate(): void {
			super.prepareForUpdate();

			((this._iObjectFlags) &= ~( (1 << (ESceneObjectFlags.k_NewLocalBounds)) | (1 << (ESceneObjectFlags.k_NewWorldBounds)) ))
                                                                                        ;
		}

		update(): bool {
//если, обновится мировая матрица узла, то и AABB обновится 
			super.update();
// do we need to update our local matrix?
// derived classes update the local matrix
// then call this base function to complete
// the update
		    return this.recalcWorldBounds();
		}

		private recalcWorldBounds(): bool {
// nodes only get their bounds updated
// as nessesary
		    if ( ((this._iObjectFlags & (1 << (ESceneObjectFlags.k_NewLocalBounds)) ) != 0)
		        || this.isWorldMatrixNew()) {
// transform our local rectangle 
// by the current world matrix
		        this._pWorldBounds.set(this._pLocalBounds);
// make sure we have some degree of thickness
		        if (true) {
		            this._pWorldBounds.x1 = Math.max(this._pWorldBounds.x1, this._pWorldBounds.x0 + 0.01);
		            this._pWorldBounds.y1 = Math.max(this._pWorldBounds.y1, this._pWorldBounds.y0 + 0.01);
		            this._pWorldBounds.z1 = Math.max(this._pWorldBounds.z1, this._pWorldBounds.z0 + 0.01);
		        }
		        this._pWorldBounds.transform(this.worldMatrix);

// set the flag that our bounding box has changed
		        ((this._iObjectFlags) |= (1 << ((ESceneObjectFlags.k_NewWorldBounds))) ) ;

		        this.worldBoundsUpdated();

		        return true;
		    }

		    return false;
		}

    	inline get hasShadows(): bool {
    		return this._hasShadows;
    	};

    	inline set hasShadows(bValue: bool){
    		this._hasShadows = bValue;
    	};

    	getObjectFlags():  number  {
    		return this._iObjectFlags;
    	}

    	toString(isRecursive: bool = false, iDepth:  number  = 0): string {

			if (!isRecursive) {
		        return "<scene_object" + (this._sName ? " " + this._sName : "") + ">";
		    }

		    return super.toString(isRecursive, iDepth);

    	}

		worldBoundsUpdated (): void { var _recivier: any = this; this._pUnicastSlotMap = this._pUnicastSlotMap || (<events.EventTable>this.getEventTable()).findUnicastList(this._iGuid); var _unicast: IEventSlot = (<any>this._pUnicastSlotMap).worldBoundsUpdated; if(isDef(_unicast)){ _unicast.target? _unicast.target[_unicast.callback] (_recivier) : _unicast.listener (_recivier) ; } } ; ;
	}

	export inline function isSceneObject(pEntity: IEntity): bool {
		return pEntity.type >= EEntityTypes.SCENE_OBJECT && pEntity.type < EEntityTypes.OBJECTS_LIMIT;
	}
}




















module akra{

	export interface IVec3 {} ;

	export interface IPlane3d{
		normal: IVec3;
		distance:  number ;

		set(): IPlane3d;
		set(pPlane: IPlane3d): IPlane3d;
		set(v3fNormal: IVec3, fDistance:  number ): IPlane3d;
		set(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3): IPlane3d;

		clear(): IPlane3d;

		negate(): IPlane3d;

		normalize(): IPlane3d;

		isEqual(pPlane: IPlane3d): bool;

		projectPointToPlane(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3;

		solveForX(fY:  number , fZ:  number ):  number ;
		solveForY(fX:  number , fZ:  number ):  number ;
		solveForZ(fX:  number , fY:  number ):  number ;

		signedDistance(v3fPoint: IVec3):  number ;
	};
}



module akra.geometry{
	export class Plane3d implements IPlane3d{
		normal: IVec3;
		distance:  number ;

		constructor();
		constructor(pPlane: IPlane3d);
		constructor(v3fNormal: IVec3, fDistance:  number );
		constructor(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3);
		constructor(v3fPoint1?, v3fPoint2?, v3fPoint3?){

			this.normal = new Vec3();
			this.distance = 0.;

			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				case 3:
					this.set(arguments[0], arguments[1], arguments[2]);
					break;
				default:
					break;
			}
		};

		set(): IPlane3d;
		set(pPlane: IPlane3d): IPlane3d;
		set(v3fNormal: IVec3, fDistance:  number ): IPlane3d;
		set(v3fPoint1: IVec3, v3fPoint2: IVec3, v3fPoint3: IVec3): IPlane3d;
		set(v3fPoint1?, v3fPoint2?, v3fPoint3?): IPlane3d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pPlane: IPlane3d = arguments[0];

					this.normal.set(pPlane.normal);
					this.distance = pPlane.distance;
					break;
				case 2:
					this.normal.set(arguments[0]);
					this.distance = arguments[1];
					break;
				case 3:
					var v3fPoint1: IVec3 = arguments[0];
					var v3fPoint2: IVec3 = arguments[1];
					var v3fPoint3: IVec3 = arguments[2];

					var x1:  number  = v3fPoint2.x - v3fPoint1.x;
					var y1:  number  = v3fPoint2.y - v3fPoint1.y;
					var z1:  number  = v3fPoint2.z - v3fPoint1.z;

					var x2:  number  = v3fPoint3.x - v3fPoint1.x;
					var y2:  number  = v3fPoint3.y - v3fPoint1.y;
					var z2:  number  = v3fPoint3.z - v3fPoint1.z;

					var x:  number  = y1*z2 - y2*z1;
					var y:  number  = z1*x2 - z2*x1;
					var z:  number  = x1*y2 - x2*y1;

					this.distance = -(x*v3fPoint1.x + y*v3fPoint1.y + z*v3fPoint1.z);
					this.normal.set(x,y,z);

					break;
				default:
					this.normal.clear();
					this.distance = 0.;
					break;
			}

			return this.normalize();
		};

		inline clear(): IPlane3d{
			this.normal.clear();
			this.distance = 0.;
			return this;
		};

		inline negate(): IPlane3d{
			this.normal.negate();
			this.distance = -this.distance;
			return this;
		};

		normalize(): IPlane3d{
			var v3fNormal: IVec3 = this.normal;
			var x:  number  = v3fNormal.x, y:  number  = v3fNormal.y, z:  number  = v3fNormal.z;

			var fLength:  number  = math.sqrt(x*x + y*y + z*z);

			if(fLength !== 0.){
				var fInvLength = 1./fLength;

				v3fNormal.x = x*fInvLength;
				v3fNormal.y = y*fInvLength;
				v3fNormal.z = z*fInvLength;

				this.distance *= fInvLength;
			}

			return this;
		};

		isEqual(pPlane: IPlane3d): bool{
			return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
		};

/*предполагается работа только с нормализованной плоскостью*/

		projectPointToPlane(v3fPoint: IVec3, v3fDestination?: IVec3): IVec3{
			if(!isDef(v3fDestination)){
				v3fDestination = new Vec3();
			}

			var v3fNormal: IVec3 = this.normal;
			var fDistance:  number  = this.distance + v3fNormal.dot(v3fPoint);

			v3fDestination.x = v3fPoint.x - fDistance*v3fNormal.x;
			v3fDestination.y = v3fPoint.y - fDistance*v3fNormal.y;
			v3fDestination.z = v3fPoint.z - fDistance*v3fNormal.z;

			return v3fDestination;
		};

		solveForX(fY:  number , fZ:  number ):  number {
/*Ax+By+Cz+D=0;
			x = -(D+By+Cz)/A;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.x !== 0.){
				return -(this.distance + v3fNormal.y*fY + v3fNormal.z*fZ)/v3fNormal.x;
			}
			return 0.;
		};

		solveForY(fX:  number , fZ:  number ):  number {
/*Ax+By+Cz+D=0;
			y = -(D+Ax+Cz)/B;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.y !== 0.){
				return -(this.distance + v3fNormal.x*fX + v3fNormal.z*fZ)/v3fNormal.y;
			}
			return 0.;
		};

		solveForZ(fX:  number , fY:  number ):  number {
/*Ax+By+Cz+D=0;
			z = -(D+Ax+By)/C;*/


			var v3fNormal: IVec3 = this.normal;

			if(v3fNormal.z !== 0.){
				return -(this.distance + v3fNormal.x*fX + v3fNormal.y*fY)/v3fNormal.z;
			}

			return 0.;
		};

		signedDistance(v3fPoint: IVec3):  number {
			return this.distance + this.normal.dot(v3fPoint);
		};
	};
};




















module akra{

	export interface IVec2 {} ;
	export interface ICircle {} ;

	export interface IPlane2d{
		normal: IVec2;
		distance:  number ;

		set(): IPlane2d;
		set(pPlane: IPlane2d): IPlane2d;
		set(v2fNormal: IVec2, fDistance:  number ): IPlane2d;
		set(v2fPoint1: IVec2, v2fPoint2: IVec2): IPlane2d;

		clear(): IPlane2d;

		negate(): IPlane2d;

		normalize(): IPlane2d;

		isEqual(pPlane: IPlane2d): bool;

		projectPointToPlane(v2fPoint: IVec2, v2fDestination?: IVec2): IVec2;

		solveForX(fY:  number ):  number ;
		solveForY(fX:  number ):  number ;

		signedDistance(v2fPoint):  number ;
	}
}



module akra.geometry{
	export class Plane2d implements IPlane2d{
		normal: IVec2;
		distance:  number ;

		constructor();
		constructor(pPlane: IPlane2d);
		constructor(v2fNormal: IVec2, fDistance:  number );
		constructor(v2fPoint1: IVec2, v2fPoint2: IVec2);
		constructor(v2fPoint1?, v2fPoint2?){

			this.normal = new Vec2();
			this.distance = 0.;

			var nArgumentsLength = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 2:
					this.set(arguments[0], arguments[1]);
					break;
				default:
					break;
			}
		};

		set(): IPlane2d;
		set(pPlane: IPlane2d): IPlane2d;
		set(v2fNormal: IVec2, fDistance:  number ): IPlane2d;
		set(v2fPoint1: IVec2, v2fPoint2: IVec2): IPlane2d;
		set(v2fPoint1?, v2fPoint2?): IPlane2d{
			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					var pPlane: IPlane2d = arguments[0];

					this.normal.set(pPlane.normal);
					this.distance = pPlane.distance;
					break;
				case 2:
					if(isFloat(arguments[1])){
						this.normal.set(arguments[0]);
						this.distance = arguments[1];
					}
					else{
						var v2fLine: IVec2 = vec2(<IVec2>arguments[1]).subtract(arguments[0]);
						var v2fNormal: IVec2 = this.normal;

						v2fNormal.set(-v2fLine.y, v2fLine.x);
						this.distance = -v2fNormal.dot(arguments[0]);
					}
					break;
				default:
					this.normal.clear();
					this.distance = 0.;
					break;
			}

			return this.normalize();
		};

		inline clear(): IPlane2d{
			this.normal.clear();
			this.distance = 0.;
			return this;
		};

		inline negate(): IPlane2d{
			this.normal.negate();
			this.distance = -this.distance;
			return this;
		};

		normalize(): IPlane2d{
			var v2fNormal: IVec2 = this.normal;

			var x:  number  = v2fNormal.x;
			var y:  number  = v2fNormal.y

			var fLength:  number  = math.sqrt(x*x + y*y);

			if(fLength !== 0.){
				var fInvLength:  number  = 1./fLength;

				v2fNormal.x = x*fInvLength;
				v2fNormal.y = y*fInvLength;

				this.distance = this.distance*fInvLength;
			}

			return this;
		};

		inline isEqual(pPlane: IPlane2d): bool{
			return this.normal.isEqual(pPlane.normal) && (this.distance == pPlane.distance);
		};

/*предполагается работа только с нормализованной плоскостью*/

		projectPointToPlane(v2fPoint: IVec2, v2fDestination?: IVec2): IVec2{
			if(!isDef(v2fDestination)){
				v2fDestination = new Vec2();
			}

			var v2fNormal: IVec2 = this.normal;
			var fDistance:  number  = this.distance + v2fNormal.dot(v2fPoint);

			v2fDestination.x = v2fPoint.x - fDistance*v2fNormal.x;
			v2fDestination.y = v2fPoint.y - fDistance*v2fNormal.y;

			return v2fDestination;
		};

		solveForX(fY:  number ):  number {
/*Ax+By+d=0;
			x=-(d+By)/A;*/


			var v2fNormal: IVec2 = this.normal;

			if(v2fNormal.x !== 0.){
				return -(this.distance + v2fNormal.y*fY)/v2fNormal.x;
			}
			return 0.;
		};

		solveForY(fX:  number ):  number {
/*Ax+By+d=0;
			y=-(d+Ax)/B;*/


			var v2fNormal: IVec2 = this.normal;

			if(v2fNormal.y !== 0.){
				return -(this.distance + v2fNormal.x*fX)/v2fNormal.y;
			}
			return 0.;
		};

/*предполагается работа только с нормализованной плоскостью*/

		inline signedDistance(v2fPoint: IVec2):  number {
			return this.distance + this.normal.dot(v2fPoint);
		};
	};
}







module akra{
	export enum EVolumeClassifications{
		NO_RELATION = 0,
		EQUAL,
		A_CONTAINS_B,
		B_CONTAINS_A,
		INTERSECTING
	};

	export enum EPlaneClassifications{
/**
		 * ax+by+cz+d=0
		 * PLANE_FRONT - объект находится перед плоскостью, то есть по направлению нормали
		 * PLANE_BACK - объект находится за плостостью, то есть против направления нормали
		 */

		PLANE_FRONT = 0,
		PLANE_BACK,
		PLANE_INTERSECT
	};
}

module akra.geometry{

	export function planeClassifyCircle(pPlane: IPlane2d, pCircle: ICircle): EPlaneClassifications{
		var fDistance:  number  = pPlane.signedDistance(pCircle.center);
		var fRadius:  number  = pCircle.radius;

		if(fDistance > fRadius){
			return EPlaneClassifications.PLANE_FRONT;
		}
		else if(fDistance < -fRadius){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_INTERSECT;
		}
	};

	export function planeClassifySphere(pPlane: IPlane3d, pSphere: ISphere): EPlaneClassifications{
		var fDistance:  number  = pPlane.signedDistance(pSphere.center);
		var fRadius:  number  = pSphere.radius;

		if(fDistance > fRadius){
			return EPlaneClassifications.PLANE_FRONT;
		}
		else if(fDistance < -fRadius){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_INTERSECT;
		}
	};

	export function planeClassifyRect2d(pPlane: IPlane2d, pRect: IRect2d): EPlaneClassifications{
		var v2fMinPoint: IVec2 = vec2();
		var v2fMaxPoint: IVec2 = vec2();

		var v2fNormal: IVec2 = pPlane.normal;

		if(v2fNormal.x > 0.){
			v2fMinPoint.x = pRect.x0;
			v2fMaxPoint.x = pRect.x1;
		}
		else{
			v2fMinPoint.x = pRect.x1;
			v2fMaxPoint.x = pRect.x0;
		}

		if(v2fNormal.y > 0.){
			v2fMinPoint.y = pRect.y0;
			v2fMaxPoint.y = pRect.y1;
		}
		else{
			v2fMinPoint.y = pRect.y1;
			v2fMaxPoint.y = pRect.y0;
		}

		var fMinDistance:  number  = pPlane.signedDistance(v2fMinPoint);
		var fMaxDistance:  number  = pPlane.signedDistance(v2fMaxPoint);

		if(fMinDistance*fMaxDistance <= 0.){
			return EPlaneClassifications.PLANE_INTERSECT;
		}
		else if (fMaxDistance < 0.){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_FRONT;
		}
	};

	export function planeClassifyRect3d(pPlane: IPlane3d, pRect: IRect3d): EPlaneClassifications{
		var v3fMinPoint: IVec3 = vec3();
		var v3fMaxPoint: IVec3 = vec3();

		var v3fNormal: IVec3 = pPlane.normal;

		if(v3fNormal.x > 0.){
			v3fMinPoint.x = pRect.x0;
			v3fMaxPoint.x = pRect.x1;
		}
		else{
			v3fMinPoint.x = pRect.x1;
			v3fMaxPoint.x = pRect.x0;
		}

		if(v3fNormal.y > 0.){
			v3fMinPoint.y = pRect.y0;
			v3fMaxPoint.y = pRect.y1;
		}
		else{
			v3fMinPoint.y = pRect.y1;
			v3fMaxPoint.y = pRect.y0;
		}

		if(v3fNormal.z > 0.){
			v3fMinPoint.z = pRect.z0;
			v3fMaxPoint.z = pRect.z1;
		}
		else{
			v3fMinPoint.z = pRect.z1;
			v3fMaxPoint.z = pRect.z0;
		}

		var fMinDistance:  number  = pPlane.signedDistance(v3fMinPoint);
		var fMaxDistance:  number  = pPlane.signedDistance(v3fMaxPoint);

		if(fMinDistance*fMaxDistance <= 0.){
			return EPlaneClassifications.PLANE_INTERSECT;
		}
		else if (fMaxDistance < 0.){
			return EPlaneClassifications.PLANE_BACK;
		}
		else{
			return EPlaneClassifications.PLANE_FRONT;
		}
	};

	export function planeClassify(pPlane: IPlane2d, pCircle: ICircle): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane3d, pSphere: ISphere): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane2d, pRect: IRect2d): EPlaneClassifications;
	export function planeClassify(pPlane: IPlane3d, pRect: IRect3d): EPlaneClassifications;
	export function planeClassify(pPlane?, pRect?): EPlaneClassifications{
		var pArg0: any = arguments[0];
		var pArg1: any = arguments[1];

		if(pArg0 instanceof Plane2d){
			if(pArg1 instanceof Circle){
				return planeClassifyCircle(pArg0, pArg1);
			}
			else{
				return planeClassifyRect2d(pArg0, pArg1);
			}
		}
		else{
			if(pArg1 instanceof Sphere){
				return planeClassifySphere(pArg0, pArg1);
			}
			else{
				return planeClassifyRect3d(pArg0, pArg1);
			}
		}
	};

	export function classifyRect2d(pRectA: IRect2d, pRectB: IRect2d): EVolumeClassifications{
		var fRectAX0:  number  = pRectA.x0, fRectAX1:  number  = pRectA.x1;
		var fRectAY0:  number  = pRectA.y0, fRectAY1:  number  = pRectA.y1;

		var fRectBX0:  number  = pRectB.x0, fRectBX1:  number  = pRectB.x1;
		var fRectBY0:  number  = pRectB.y0, fRectBY1:  number  = pRectB.y1;

		if((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0)
			|| (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)){

			return EVolumeClassifications.NO_RELATION;
		}

		if((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1)
			&& (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)){

			return EVolumeClassifications.EQUAL;
		}

		if((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1)
			 && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)){

			return EVolumeClassifications.A_CONTAINS_B;
		}

		if((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1)
			&& (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)){

			return EVolumeClassifications.B_CONTAINS_A;
		}

		return EVolumeClassifications.INTERSECTING;
	};

	export function classifyRect3d(pRectA: IRect3d, pRectB: IRect3d): EVolumeClassifications{
		var fRectAX0:  number  = pRectA.x0, fRectAX1:  number  = pRectA.x1;
		var fRectAY0:  number  = pRectA.y0, fRectAY1:  number  = pRectA.y1;
		var fRectAZ0:  number  = pRectA.z0, fRectAZ1:  number  = pRectA.z1;

		var fRectBX0:  number  = pRectB.x0, fRectBX1:  number  = pRectB.x1;
		var fRectBY0:  number  = pRectB.y0, fRectBY1:  number  = pRectB.y1;
		var fRectBZ0:  number  = pRectB.z0, fRectBZ1:  number  = pRectB.z1;

		if((fRectAX1 < fRectBX0 || fRectBX1 < fRectAX0)
			|| (fRectAY1 < fRectBY0 || fRectAY1 < fRectBY0)
			|| (fRectAZ1 < fRectBZ0 || fRectAZ1 < fRectBZ0)){

			return EVolumeClassifications.NO_RELATION;
		}

		if((fRectAX0 == fRectBX0 && fRectAX1 == fRectBX1)
			&& (fRectAY0 == fRectBY0 && fRectAY1 == fRectBY1)
			&& (fRectAZ0 == fRectBZ0 && fRectAZ1 == fRectBZ1)){

			return EVolumeClassifications.EQUAL;
		}

		if((fRectAX0 <= fRectBX0 && fRectBX1 <= fRectAX1)
			 && (fRectAY0 <= fRectBY0 && fRectBY1 <= fRectAY1)
			 && (fRectAZ0 <= fRectBZ0 && fRectBZ1 <= fRectAZ1)){

			return EVolumeClassifications.A_CONTAINS_B;
		}

		if((fRectBX0 <= fRectAX0 && fRectAX1 <= fRectBX1)
			&& (fRectBY0 <= fRectAY0 && fRectAY1 <= fRectBY1)
			&& (fRectBZ0 <= fRectAZ0 && fRectAZ1 <= fRectBZ1)){

			return EVolumeClassifications.B_CONTAINS_A;
		}

		return EVolumeClassifications.INTERSECTING;
	};

	export function classifyFrustumRect3d(pFrustum: IFrustum, pRect: IRect3d){
		var kClassification: EPlaneClassifications;
		var isIntersect: bool = false;

		kClassification = planeClassifyRect3d(pFrustum.leftPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.rightPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.topPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.bottomPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.nearPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		kClassification = planeClassifyRect3d(pFrustum.farPlane, pRect);
		if(kClassification == EPlaneClassifications.PLANE_FRONT){
			return EVolumeClassifications.NO_RELATION;
		}
		else if(kClassification == EPlaneClassifications.PLANE_INTERSECT){
			isIntersect = true;
		}

		if(isIntersect){
			return EVolumeClassifications.INTERSECTING;
		}
		else{
			return EVolumeClassifications.A_CONTAINS_B;
		}
	};

}






module akra{

	export interface IMat4 {} ;
	export interface IVec3 {} ;
	export interface IRect3 {} ;
	export interface ISphere {} ;
	export interface IRect3d {} ;

	export interface IFrustum{
		leftPlane: IPlane3d;
		rightPlane: IPlane3d;
		topPlane: IPlane3d;
		bottomPlane: IPlane3d;
		nearPlane: IPlane3d;
		farPlane: IPlane3d;

		 frustumVertices: IVec3[];

		set(): IFrustum;
		set(pFrustum: IFrustum): IFrustum;
		set(pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
			pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
			pNearPlane: IPlane3d, pFarPlane: IPlane3d): IFrustum;

		calculateFrustumVertices(): IVec3[];
		extractFromMatrix(m4fProjection: IMat4, m4fWorld?: IMat4, pSearchRect?: IRect3d): IFrustum;

		isEqual(pFrustum: IFrustum): bool;

		getPlanePoints(sPlaneKey: string, pDestination?: IVec3[]): IVec3[];

		testPoint(v3fPoint: IVec3): bool;
		testRect(pRect: IRect3): bool;
		testSphere(pSphere: ISphere): bool;
		testFrustum(pFrustum: IFrustum): bool;
	};
};



module akra.geometry{
	export class Frustum implements IFrustum {
		leftPlane: IPlane3d;
		rightPlane: IPlane3d;
		topPlane: IPlane3d;
		bottomPlane: IPlane3d;
		nearPlane: IPlane3d;
		farPlane: IPlane3d;

		_pFrustumVertices: IVec3[] = null;

		constructor ();
		constructor (pFrustum: IFrustum);
		constructor (pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
					pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
					pNearPlane: IPlane3d, pFarPlane: IPlane3d);
		constructor (pLeftPlane?,pRightPlane?,pTopPlane?,
					pBottomPlane?, pNearPlane?, pFarPlane?) {

			this.leftPlane = new Plane3d();
			this.rightPlane = new Plane3d();
			this.topPlane = new Plane3d();
			this.bottomPlane = new Plane3d();
			this.nearPlane = new Plane3d();
			this.farPlane = new Plane3d();

			var nArgumentsLength:  number  = arguments.length;

			switch(nArgumentsLength){
				case 1:
					this.set(arguments[0]);
					break;
				case 6:
					this.set(arguments[0], arguments[1], arguments[2],
							 arguments[3], arguments[4], arguments[5]);
					break;
				default:
					break;
			}
		};

		inline get frustumVertices(): IVec3[]{
			return this._pFrustumVertices;
		};

		set(): IFrustum;
		set(pFrustum: IFrustum): IFrustum;
		set(pLeftPlane: IPlane3d, pRightPlane: IPlane3d,
			pTopPlane: IPlane3d, pBottomPlane: IPlane3d,
			pNearPlane: IPlane3d, pFarPlane: IPlane3d): IFrustum;
		set(pLeftPlane?, pRightPlane?, pTopPlane?,
			pBottomPlane?, pNearPlane?, pFarPlane?): IFrustum {

			var nArgumentsLength = arguments.length;

			switch(nArgumentsLength) {
				case 1:
					var pFrustum: IFrustum = arguments[0];

					this.leftPlane.set(pFrustum.leftPlane);
					this.rightPlane.set(pFrustum.rightPlane);
					this.topPlane.set(pFrustum.topPlane);
					this.bottomPlane.set(pFrustum.bottomPlane);
					this.nearPlane.set(pFrustum.nearPlane);
					this.farPlane.set(pFrustum.farPlane);
					break;
				case 6:
					this.leftPlane.set(arguments[0]);
					this.rightPlane.set(arguments[1]);
					this.topPlane.set(arguments[2]);
					this.bottomPlane.set(arguments[3]);
					this.nearPlane.set(arguments[4]);
					this.farPlane.set(arguments[5]);
					break;
				default:
					this.leftPlane.clear();
					this.rightPlane.clear();
					this.topPlane.clear();
					this.bottomPlane.clear();
					this.nearPlane.clear();
					this.farPlane.clear();
					break;
			}

			return this;
		};

		calculateFrustumVertices(): IVec3[]{
			if(this._pFrustumVertices == null){
				this._pFrustumVertices = new Array(8);

				for(var i: number  = 0; i < 8; i++){
					this._pFrustumVertices[i] = new Vec3();
				}
			}

			var v3fLeftNormal: IVec3 = this.leftPlane.normal;
			var v3fRightNormal: IVec3 = this.rightPlane.normal;
			var v3fTopNormal: IVec3 = this.topPlane.normal;
			var v3fBottomNormal: IVec3 = this.bottomPlane.normal;
			var v3fNearNormal: IVec3 = this.nearPlane.normal;
			var v3fFarNormal: IVec3 = this.farPlane.normal;

			var fLeft:  number  = -this.leftPlane.distance;
			var fRight:  number  = -this.rightPlane.distance;
			var fTop:  number  = -this.topPlane.distance;
			var fBottom:  number  = -this.bottomPlane.distance;
			var fNear:  number  = -this.nearPlane.distance;
			var fFar:  number  = -this.farPlane.distance;

			var m3fTemp: IMat3 = mat3();
			var pFrustumVertices: IVec3[] = this._pFrustumVertices;

//first left-bottom-near
			pFrustumVertices[0].set(fLeft, fBottom, fNear);
/*first colomn, not row*/
			m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fNearNormal.x,
						v3fLeftNormal.y, v3fBottomNormal.y, v3fNearNormal.y,
						v3fLeftNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[0]);

//second right-bottom-near
			pFrustumVertices[1].set(fRight, fBottom, fNear);
/*first colomn, not row*/
			m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fNearNormal.x,
						v3fRightNormal.y, v3fBottomNormal.y, v3fNearNormal.y,
						v3fRightNormal.z, v3fBottomNormal.z, v3fNearNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[1]);

//third left-top-near
			pFrustumVertices[2].set(fLeft, fTop, fNear);
/*first colomn, not row*/
			m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fNearNormal.x,
						v3fLeftNormal.y, v3fTopNormal.y, v3fNearNormal.y,
						v3fLeftNormal.z, v3fTopNormal.z, v3fNearNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[2]);

//forth right-top-near
			pFrustumVertices[3].set(fRight, fTop, fNear);
/*first colomn, not row*/
			m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fNearNormal.x,
						v3fRightNormal.y, v3fTopNormal.y, v3fNearNormal.y,
						v3fRightNormal.z, v3fTopNormal.z, v3fNearNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[3]);

//fifth left-bottom-far
			pFrustumVertices[4].set(fLeft, fBottom, fFar);
/*first colomn, not row*/
			m3fTemp.set(v3fLeftNormal.x, v3fBottomNormal.x, v3fFarNormal.x,
						v3fLeftNormal.y, v3fBottomNormal.y, v3fFarNormal.y,
						v3fLeftNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[4]);

//sixth right-bottom-far
			pFrustumVertices[5].set(fRight, fBottom, fFar);
/*first colomn, not row*/
			m3fTemp.set(v3fRightNormal.x, v3fBottomNormal.x, v3fFarNormal.x,
						v3fRightNormal.y, v3fBottomNormal.y, v3fFarNormal.y,
						v3fRightNormal.z, v3fBottomNormal.z, v3fFarNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[5]);

//seventh left-top-far
			pFrustumVertices[6].set(fLeft, fTop, fFar);
/*first colomn, not row*/
			m3fTemp.set(v3fLeftNormal.x, v3fTopNormal.x, v3fFarNormal.x,
						v3fLeftNormal.y, v3fTopNormal.y, v3fFarNormal.y,
						v3fLeftNormal.z, v3fTopNormal.z, v3fFarNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[6]);

//eighth right-top-far
			pFrustumVertices[7].set(fRight, fTop, fFar);
/*first colomn, not row*/
			m3fTemp.set(v3fRightNormal.x, v3fTopNormal.x, v3fFarNormal.x,
						v3fRightNormal.y, v3fTopNormal.y, v3fFarNormal.y,
						v3fRightNormal.z, v3fTopNormal.z, v3fFarNormal.z);
			m3fTemp.inverse().multiplyVec3(pFrustumVertices[7]);

			return pFrustumVertices;
		};

		extractFromMatrix(m4fProjection: IMat4, m4fWorld?: IMat4, pSearchRect?: IRect3d): IFrustum{

			if(this._pFrustumVertices == null){
				this._pFrustumVertices = new Array(8);

				for(var i: number  = 0; i < 8; i++){
					this._pFrustumVertices[i] = new Vec3();
				}
			}

			var pFrustumVertices: IVec3[] = this._pFrustumVertices;

			var v4fLeftBottomNear: IVec4 = vec4();
			var v4fRightBottomNear: IVec4 = vec4();
			var v4fLeftTopNear: IVec4 = vec4();
			var v4fRightTopNear: IVec4 = vec4();

			var v4fLeftBottomFar: IVec4 = vec4();
			var v4fRightBottomFar: IVec4 = vec4();
			var v4fLeftTopFar: IVec4 = vec4();
			var v4fRightTopFar: IVec4 = vec4();

			m4fProjection.unproj(vec3(-1,-1,-1), v4fLeftBottomNear);
		    m4fProjection.unproj(vec3(1,-1,-1), v4fRightBottomNear);
		    m4fProjection.unproj(vec3(-1,1,-1), v4fLeftTopNear);
		    m4fProjection.unproj(vec3(1,1,-1), v4fRightTopNear);

		    m4fProjection.unproj(vec3(-1,-1,1), v4fLeftBottomFar);
		    m4fProjection.unproj(vec3(1,-1,1), v4fRightBottomFar);
		    m4fProjection.unproj(vec3(-1,1,1), v4fLeftTopFar);
		    m4fProjection.unproj(vec3(1,1,1), v4fRightTopFar);

		    if(isDef(m4fWorld)){
		    	m4fWorld.multiplyVec4(v4fLeftBottomNear);
		    	m4fWorld.multiplyVec4(v4fRightBottomNear);
		    	m4fWorld.multiplyVec4(v4fLeftTopNear);
		    	m4fWorld.multiplyVec4(v4fRightTopNear);

		    	m4fWorld.multiplyVec4(v4fLeftBottomFar);
		    	m4fWorld.multiplyVec4(v4fRightBottomFar);
		    	m4fWorld.multiplyVec4(v4fLeftTopFar);
		    	m4fWorld.multiplyVec4(v4fRightTopFar);
		    }

		    var v3fLeftBottomNear: IVec3 = pFrustumVertices[0].set(v4fLeftBottomNear.xyz);
		    var v3fRightBottomNear: IVec3 = pFrustumVertices[1].set(v4fRightBottomNear.xyz);
		    var v3fLeftTopNear: IVec3 = pFrustumVertices[2].set(v4fLeftTopNear.xyz);
		    var v3fRightTopNear: IVec3 = pFrustumVertices[3].set(v4fRightTopNear.xyz);

		    var v3fLeftBottomFar: IVec3 = pFrustumVertices[4].set(v4fLeftBottomFar.xyz);
		    var v3fRightBottomFar: IVec3 = pFrustumVertices[5].set(v4fRightBottomFar.xyz);
		    var v3fLeftTopFar: IVec3 = pFrustumVertices[6].set(v4fLeftTopFar.xyz);
		    var v3fRightTopFar: IVec3 = pFrustumVertices[7].set(v4fRightTopFar.xyz);

//filling search rectangle

		    if(isDef(pSearchRect)){
		    	pSearchRect.set(v3fLeftBottomNear, v3fLeftBottomNear);

		    	pSearchRect.unionPoint(v3fRightBottomNear);
		    	pSearchRect.unionPoint(v3fLeftTopNear);
		    	pSearchRect.unionPoint(v3fRightTopNear);

		    	pSearchRect.unionPoint(v3fLeftBottomFar);
		    	pSearchRect.unionPoint(v3fRightBottomFar);
		    	pSearchRect.unionPoint(v3fLeftTopFar);
		    	pSearchRect.unionPoint(v3fRightTopFar);
		    }

//calculating planes

		    this.leftPlane.set(v3fLeftTopNear, v3fLeftTopFar, v3fLeftBottomNear);
			this.rightPlane.set(v3fRightBottomFar, v3fRightTopFar, v3fRightBottomNear);
			this.topPlane.set(v3fLeftTopNear, v3fRightTopNear, v3fLeftTopFar);
			this.bottomPlane.set(v3fRightBottomFar, v3fRightBottomNear, v3fLeftBottomFar);
			this.nearPlane.set(v3fLeftTopNear, v3fLeftBottomNear, v3fRightTopNear);
			this.farPlane.set(v3fRightBottomFar, v3fLeftBottomFar, v3fRightTopFar);

			return this;
		};

		inline isEqual(pFrustum: IFrustum): bool{
			return (this.leftPlane.isEqual(pFrustum.leftPlane)
				&& this.rightPlane.isEqual(pFrustum.rightPlane)
				&& this.topPlane.isEqual(pFrustum.topPlane)
				&& this.bottomPlane.isEqual(pFrustum.bottomPlane)
				&& this.nearPlane.isEqual(pFrustum.nearPlane)
				&& this.farPlane.isEqual(pFrustum.farPlane));
		};

//output - array of vertices in counterclockwise order (around plane normal as axis)
		getPlanePoints(sPlaneKey: string, pDestination: IVec3[] = new Array(4)): IVec3[]{
			var pFrustumVertices: IVec3[] = this.frustumVertices;
			if(pFrustumVertices === null){
				pFrustumVertices = this.calculateFrustumVertices();
			}

			switch(sPlaneKey){
				case "leftPlane":
					pDestination[0] = pFrustumVertices[6];
					pDestination[1] = pFrustumVertices[4];
					pDestination[2] = pFrustumVertices[0];
					pDestination[3] = pFrustumVertices[2];
					break;
				case "rightPlane":
					pDestination[0] = pFrustumVertices[7];
					pDestination[1] = pFrustumVertices[3];
					pDestination[2] = pFrustumVertices[1];
					pDestination[3] = pFrustumVertices[5];
					break;
				case "topPlane":
					pDestination[0] = pFrustumVertices[7];
					pDestination[1] = pFrustumVertices[6];
					pDestination[2] = pFrustumVertices[2];
					pDestination[3] = pFrustumVertices[3];
					break;
				case "bottomPlane":
					pDestination[0] = pFrustumVertices[5];
					pDestination[1] = pFrustumVertices[1];
					pDestination[2] = pFrustumVertices[0];
					pDestination[3] = pFrustumVertices[4];
					break;
				case "nearPlane":
					pDestination[0] = pFrustumVertices[3];
					pDestination[1] = pFrustumVertices[2];
					pDestination[2] = pFrustumVertices[0];
					pDestination[3] = pFrustumVertices[1];
					break;
				case "farPlane":
					pDestination[0] = pFrustumVertices[7];
					pDestination[1] = pFrustumVertices[5];
					pDestination[2] = pFrustumVertices[4];
					pDestination[3] = pFrustumVertices[6];
					break;
				default:
					logger.setSourceLocation( "geometry/Frustum.ts" , 319 ); logger.assert(false, "invalid plane key"); ;
					break;
			}
			return pDestination;
		};

		testPoint(v3fPoint: IVec3): bool{
			if(	   this.leftPlane.signedDistance(v3fPoint) > 0.
				|| this.rightPlane.signedDistance(v3fPoint) > 0.
				|| this.topPlane.signedDistance(v3fPoint) > 0.
				|| this.bottomPlane.signedDistance(v3fPoint) > 0.
				|| this.nearPlane.signedDistance(v3fPoint) > 0.
				|| this.farPlane.signedDistance(v3fPoint) > 0.){

				return false;
			}
			return true;
		};

		testRect(pRect: IRect3d): bool{

			if(planeClassifyRect3d(this.leftPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.rightPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.topPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.bottomPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.nearPlane, pRect) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifyRect3d(this.farPlane, pRect) == EPlaneClassifications.PLANE_FRONT){

				return false;
			}
			return true;
		};

		testSphere(pSphere: ISphere): bool{
			if(	   planeClassifySphere(this.leftPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.rightPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.topPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.bottomPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.nearPlane, pSphere) == EPlaneClassifications.PLANE_FRONT
				|| planeClassifySphere(this.farPlane, pSphere) == EPlaneClassifications.PLANE_FRONT){

				return false;
			}
			return true;
		};

		testFrustum(pFrustum: IFrustum): bool{

			var pFrustumVertices1: IVec3[] = this.frustumVertices;
			var pFrustumVertices2: IVec3[] = pFrustum.frustumVertices;

			if(pFrustumVertices1 == null){
				pFrustumVertices1 = this.calculateFrustumVertices();
			}
			if(pFrustumVertices2 == null){
				pFrustumVertices2 = pFrustum.calculateFrustumVertices();
			}

			var pFrustumPlanes: string[] = Frustum.frustumPlanesKeys;

			var nTest:  number ;

			for(var i:  number  = 0; i < 6; i++){
				var pPlane: IPlane3d = this[pFrustumPlanes[i]];

				nTest = 0;

				for(var j:  number  = 0; j < 8; j++){
					if(pPlane.signedDistance(pFrustumVertices2[j]) > 0){
						nTest++;
					}
				}

				if(nTest == 8){
//frustums don't intersecting
					return false;
				}
			}

//second batch of test for minimizing possible error
			for(var i:  number  = 0; i < 6; i++){
				var pPlane: IPlane3d = pFrustum[pFrustumPlanes[i]];

				nTest = 0;

				for(var j:  number  = 0; j < 8; j++){
					if(pPlane.signedDistance(pFrustumVertices1[j]) > 0){
						nTest++;
					}
				}

				if(nTest == 8){
//frustums don't intersecting
					return false;
				}
			}

			return true;
		};

		static frustumPlanesKeys: string[] = ["leftPlane", "rightPlane", "topPlane",
											  "bottomPlane", "nearPlane", "farPlane"];
	};
}





module akra.scene.objects {
	export enum ECameraFlags {
		k_NewProjectionMatrix = 0
	}

	export interface ICameraCache {
		[displayList: string]: ISceneObject[];
	};

	export class DLTechnique {
		list: IDisplayList;
		camera: ICamera;

		private _pPrevResult: IObjectArray = null;

		constructor (pList: IDisplayList, pCamera: ICamera) {
			this.list = pList;
			this.camera = pCamera;
		}

		inline findObjects(pResultArray: IObjectArray, bQuickSearch: bool = false): IObjectArray {
			var pResult: IObjectArray = this.list._findObjects(this.camera, pResultArray,
					bQuickSearch && isDefAndNotNull(this._pPrevResult));

			if (isNull(this._pPrevResult)) {
				this._pPrevResult = pResult;
			}

			return this._pPrevResult;
		}
	}

	export class Camera extends SceneNode implements ICamera {
/** camera type */

		/**@protected*/  _eCameraType: ECameraTypes = ECameraTypes.PERSPECTIVE;
/** camera options */

		/**@protected*/  _iCameraOptions:  number  = 0;
/** update projection bit flag */

		/**@protected*/  _iUpdateProjectionFlags:  number  = 0;

/** View matrix */

		/**@protected*/  _m4fView: IMat4 = new Mat4;
/** internal, un-biased projection matrix */

		/**@protected*/  _m4fProj: IMat4 = new Mat4;
		/**@protected*/  _m4fUnitProj: IMat4 = new Mat4;
/** internal, un-biased projection+view matrix */

		/**@protected*/  _m4fProjView: IMat4 = new Mat4;

/** Biased for use during current render stage */

		/**@protected*/  _m4fRenderStageProj: IMat4 = new Mat4;
		/**@protected*/  _m4fRenderStageProjView: IMat4 = new Mat4;

/** Search rect for scene culling */

		/**@protected*/  _pSearchRect: IRect3d = new geometry.Rect3d();
/** Position */

		/**@protected*/  _v3fTargetPos: IVec3 = new Vec3;

/** Attributes for projection matrix */

		/**@protected*/  _fFOV:  number  = math.PI / 5.;
		/**@protected*/  _fAspect:  number  = 4. / 3.;
		/**@protected*/  _fNearPlane:  number  = 0.1;
		/**@protected*/  _fFarPlane:  number  = 500.;
		/**@protected*/  _fWidth:  number  = 0.;
		/**@protected*/  _fHeight:  number  = 0.;
		/**@protected*/  _fMinX:  number  = 0.;
		/**@protected*/  _fMaxX:  number  = 0.;
		/**@protected*/  _fMinY:  number  = 0.;
		/**@protected*/  _fMaxY:  number  = 0.;

		/**@protected*/  _pFrustum: IFrustum = new geometry.Frustum;

		/**@protected*/  _pLastViewport: IViewport = null;

		/**@protected*/  _pDLTechniques: DLTechnique[] = [];
		/**@protected*/  _pDLResultStorage: IObjectArray[] = [];

// protected _pPrevObjects: ISceneNode[] = null;
// protected _p

		inline get viewMatrix(): IMat4 { return this._m4fView; }

    	inline get projectionMatrix(): IMat4 { return this._m4fRenderStageProj; }

    	inline get projViewMatrix(): IMat4 { return this._m4fRenderStageProjView; }

    	inline get internalProjectionMatrix(): IMat4 { return this._m4fProj; }

    	inline get internalViewProjMatrix(): IMat4 { return this._m4fProjView; }

    	inline get targetPos(): IVec3 { return this._v3fTargetPos; }

    	inline get fov():  number  { return this._fFOV; }
    	inline set fov(fFOV:  number ) { this._fFOV = fFOV; };

    	inline get aspect():  number  { return this._fAspect; }
    	inline set aspect(fAspect:  number ) { this._fAspect = fAspect; }

    	inline get nearPlane():  number  { return this._fNearPlane; }
    	inline set nearPlane(fNearPlane:  number ) { this._fNearPlane = fNearPlane; }

    	inline get farPlane():  number  { return this._fFarPlane; }
    	inline set farPlane(fFarPlane:  number ) { this._fFarPlane = fFarPlane; }

    	inline get viewDistance():  number  { return this._fFarPlane - this._fNearPlane; }
    	inline get searchRect(): IRect3d { return this._pSearchRect; }
    	inline get frustum(): IFrustum { return this._pFrustum; }

		constructor (pScene: IScene3d, eType: EEntityTypes = EEntityTypes.CAMERA) {
			super(pScene, eType);

		};

		create(): bool {
			var isOK: bool = super.create();

			if (isOK) {
				this._v3fTargetPos.set(
					this._m4fLocalMatrix.data[ 8 ],
					this._m4fLocalMatrix.data[ 9 ],
					this._m4fLocalMatrix.data[ 10 ]);
				this._v3fTargetPos.negate();

				this.setProjParams(this._fFOV, this._fAspect, this._fNearPlane, this._fFarPlane);
				this.recalcMatrices();

				var pScene: IScene3d = this._pScene;

				this.connect(pScene,  "displayListAdded" ,  "_addDisplayList" );
				this.connect(pScene,  "displayListRemoved" ,  "_removeDisplayList" );

				for (var i:  number  = 0; i < pScene.totalDL; ++ i) {
					var pList: IDisplayList = pScene.getDisplayList(i);

					if (!isNull(pList)) {
						this._addDisplayList(pScene, pList, i);
					}
				}
			}

			return isOK;
		};

		prepareForUpdate(): void {
			super.prepareForUpdate();

//reset culling cache for all display lists
// for (var i: int = 0; i < this._pDLTechniques.length; ++ i) {
// 	if (this._pDLTechniques[i] != null) {
// 		this._pDLTechniques.reset();
// 	}
// }
		}




/*DL_DEFAULT*/
		display(iList:  number  =               0): IObjectArray {
			var pObjects: IObjectArray = this._pDLTechniques[iList].
								findObjects(this._pDLResultStorage[iList], !this.isUpdated());

			return pObjects;
		}

		setParameter(eParam: ECameraParameters, pValue: any): void {
			if (eParam === ECameraParameters.CONST_ASPECT && <bool>pValue) {
				((this._iCameraOptions) |= (< number >eParam)) ;
			}
		}

		isConstantAspect(): bool {
			return  (((this._iCameraOptions) & (ECameraParameters.CONST_ASPECT)) != 0) ;
		}

    	setProjParams(fFOV:  number , fAspect:  number , fNearPlane:  number , fFarPlane:  number ): void {
// Set attributes for the projection matrix
		    this._fFOV = fFOV;
		    this._fAspect = fAspect;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.PERSPECTIVE;

// create the regular projection matrix
		    Mat4.perspective(fFOV, fAspect, fNearPlane, fFarPlane, this._m4fProj);

// create a unit-space matrix 
// for sky box geometry.
// this ensures that the 
// near and far plane enclose 
// the unit space around the camera
		    Mat4.perspective(fFOV, fAspect, 0.01, 2.0, this._m4fUnitProj);

		    ((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
    	}

    	setOrthoParams(fWidth:  number , fHeight:  number , fNearPlane:  number , fFarPlane:  number ): void {
		    logger.setSourceLocation( "objects/Camera.ts" , 207 ); logger.criticalError("TODO: setOrthoParams();"); ;
/*
		    
		    this._fWidth = fWidth;
		    this._fHeight = fHeight;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.ORTHO;

		    // create the regular projection matrix
		    Mat4.matrixOrthoRH(fWidth, fHeight, fNearPlane, fFarPlane, this._m4fProj);

		    // create a unit-space matrix 
		    // for sky box geometry.
		    // this ensures that the 
		    // near and far plane enclose 
		    // the unit space around the camera
		    Mat4.matrixOrthoRH(fWidth, fHeight, 0.01, 2.0, this._m4fUnitProj);

		    TRUE_BIT(this._iUpdateProjectionFlags, ECameraFlags.k_NewProjectionMatrix);

		    */

    	}

    	setOffsetOrthoParams(fMinX:  number , fMaxX:  number , fMinY:  number , fMaxY:  number , fNearPlane:  number , fFarPlane:  number ): void {
    		this._fMinX = fMinX;
		    this._fMaxX = fMaxX;
		    this._fMinY = fMinY;
		    this._fMaxY = fMaxY;
		    this._fNearPlane = fNearPlane;
		    this._fFarPlane = fFarPlane;
		    this._eCameraType = ECameraTypes.OFFSET_ORTHO;

// create the regular projection matrix
/*orthogonalProjection*/
		    Mat4.                        orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY,
		                                fNearPlane, fFarPlane, this._m4fProj);

// create a unit-space matrix 
// for sky box geometry.
// this ensures that the 
// near and far plane enclose 
// the unit space around the camera
/*orthogonalProjection*/
		    Mat4.                        orthogonalProjectionAsymmetric(fMinX, fMaxX, fMinY, fMaxY,
		                                0.01, 2.0, this._m4fUnitProj);

		    ((this._iUpdateProjectionFlags) |= (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
    	}

    	private recalcMatrices(): void {
    		this._v3fTargetPos.set(
	        this._m4fLocalMatrix.data[ 8 ],
	        this._m4fLocalMatrix.data[ 9 ],
	        this._m4fLocalMatrix.data[ 10 ]);

		    this._v3fTargetPos.negate();

// the camera view matrix is the
// inverse of the world matrix
		    this._m4fView.set(this.inverseWorldMatrix);
// sky boxes use the inverse 
// world matrix of the camera (the
// camera view matrix) without 
// any translation information.

//this.m4fSkyBox.set(this.m4fView);
// this.m4fSkyBox.data[__14] = 0.0;
// this.m4fSkyBox.data[__24] = 0.0;
// this.m4fSkyBox.data[__34] = 0.0;

// this is combined with the unit
// space projection matrix to form
// the sky box viewing matrix
//this.m4fSkyBox.multiply(this.m4fUnitProj, this.m4fSkyBox);


// billboard objects use our world matrix
// without translation
// this.m4fBillboard.set(this.worldMatrix());
// this.m4fBillboard.data[__14] = 0.0;
// this.m4fBillboard.data[__24] = 0.0;
// this.m4fBillboard.data[__34] = 0.0;
    	}

    	update(): bool {
    		var isUpdated: bool = super.update();

		    if (this.isWorldMatrixNew() ||  ((this._iUpdateProjectionFlags & (1 << (ECameraFlags.k_NewProjectionMatrix)) ) != 0) ) {
		    	this._pFrustum.extractFromMatrix(this._m4fProj, this._m4fWorldMatrix, this._pSearchRect);

// our projView matrix is the projection 
//matrix multiplied by the inverse of our world matrix  
		        this._m4fProj.multiply(this._m4fView, this._m4fRenderStageProjView);

		        isUpdated = true;

		        ((this._iUpdateProjectionFlags) &= ~ (1 << ((ECameraFlags.k_NewProjectionMatrix))) ) ;
		    }

		    return isUpdated;
    	}

		applyRenderStageBias(iStage:  number ): void {
	    	var fZ_bias = iStage > 1 ? 0.001 : 0.0;

		    this._m4fRenderStageProj.set(this._m4fProj);
		    this._m4fRenderStageProjView.set(this._m4fProjView);

		    this._m4fRenderStageProj[ 14 ] -= fZ_bias;
		    this._m4fRenderStageProjView[ 14 ] -= fZ_bias;
	    }

    	lookAt(v3fFrom: IVec3, v3fCenter: IVec3, v3fUp?: IVec3): void;
    	lookAt(v3fCenter: IVec3, v3fUp?: IVec3): void;
    	lookAt(v3f?): void {
    		var v3fFrom: IVec3, v3fCenter: IVec3, v3fUp: IVec3;

		    if (arguments.length < 3) {
		        v3fFrom = this.worldPosition;
		        v3fCenter = <IVec3>arguments[0];
		        v3fUp = <IVec3>arguments[1];
		    }
		    else {
		        v3fFrom = <IVec3>arguments[0];
		        v3fCenter = <IVec3>arguments[1];
		        v3fUp = <IVec3>arguments[2];
		    }

		    v3fUp = v3fUp || vec3(0., 1., 0.);

		    var v3fParentPos: IVec3 = (<Node>this.parent).worldPosition;
		    var m4fTemp: IMat4 = Mat4.lookAt(v3fFrom, v3fCenter, v3fUp, mat4()).inverse();
		    var pData: Float32Array = m4fTemp.data;

		    switch (this._eInheritance) {
		        case ENodeInheritance.ALL :
		            (<Node>this._pParent).inverseWorldMatrix.multiply(m4fTemp, m4fTemp);
		            m4fTemp.toQuat4(this._qRotation);
		            this.setPosition(pData[ 12 ], pData[ 13 ], pData[ 14 ]);
		            break;
		        case ENodeInheritance.ROTSCALE :
		            var m3fTemp = m4fTemp.toMat3();
		            m3fTemp = (<Node>this._pParent).inverseWorldMatrix.toMat3().multiply(m3fTemp, mat3());
		            m3fTemp.toQuat4(this._qRotation);
		            this.setPosition(pData[ 12 ], pData[ 13 ], pData[ 14 ]);
		            break;
		        default :
		            m4fTemp.toQuat4(this._qRotation);
		            this.setPosition(
		            	pData[ 12 ] - v3fParentPos.x,
		            	pData[ 13 ] - v3fParentPos.y,
		                pData[ 14 ] - v3fParentPos.z);
		    }
    	}

    	_renderScene(pViewport: IViewport): void {
//update the pixel display ratio
// if (this._eCameraType == ECameraTypes.PERSPECTIVE) {
// 	mPixelDisplayRatio = (2. * math.tan(this._fFOV * 0.5)) / pViewport.actualHeight;
// }
// else {
// 	mPixelDisplayRatio = (mTop - mBottom) / vp->getActualHeight();
// }

//notify prerender scene
			this.preRenderScene();


			pViewport.update();

//notify postrender scene
			this.postRenderScene();
    	};


    	_keepLastViewport(pViewport: IViewport): void { this._pLastViewport = pViewport; }
    	_getLastViewport(): IViewport { return this._pLastViewport; }
    	_getNumRenderedFaces():  number  { return 0; }
    	_notifyRenderedFaces(nFaces:  number ): void {}

    	toString(isRecursive: bool = false, iDepth:  number  = 0): string {
		    if (!isRecursive) {
		        return "<camera" + (this._sName? " " + this._sName: "") + ">";
		    }

		    return super.toString(isRecursive, iDepth);
    	};

    	_addDisplayList(pScene: IScene3d, pList: IDisplayList, index:  number ): void {
    		this._pDLTechniques[index] = new DLTechnique(pList, this);
    		this._pDLResultStorage[index] = new util.ObjectArray();
    	};

    	_removeDisplayList(pScene: IScene3d, pList: IDisplayList, index:  number ): void {
    		this._pDLTechniques[index] = null;
    		this._pDLResultStorage[index] = null;
    	};

		preRenderScene (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).preRenderScene; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
		postRenderScene (): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).postRenderScene; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier) : _broadcast[i].listener (_recivier) ; } } } ; ;
	}

	export inline function isCamera(pNode: IEntity): bool {
		return pNode.type >= EEntityTypes.CAMERA && pNode.type <= EEntityTypes.SHADOW_CASTER;
	}
}






module akra {

	export interface IObjectArray {} ;

	export interface IDisplayList extends IEventProvider {
		 name: string;
//если используется <quick search>, то в случае если узлы сцены не были изменены, выдается null.
		_findObjects(pCamera: ICamera, pResultArray?: IObjectArray, bQuickSearch?: bool): IObjectArray;
		_setup(pScene: IScene3d): void;
	}
}


// #include "OcTree.ts"
// #include "LightGraph.ts"












module akra {
	export interface IMesh {} ;

	export interface ISceneModel extends ISceneObject {
		mesh: IMesh;

	}
}






























module akra {

	export interface IRect3d {} ;
	export interface IMesh {} ;
	export interface ISkin {} ;
	export interface IRenderData {} ;

	export interface IMeshSubset extends IEventProvider, IRenderableObject {
		name: string;

		 mesh: IMesh;
		 skin: ISkin;
		 data: IRenderData;
		 boundingBox: IRect3d;
         boundingSphere: ISphere;

		createBoundingBox(): bool;
		deleteBoundingBox(): bool;
		showBoundingBox(): bool;
		hideBoundingBox(): bool;

		createBoundingSphere(): bool;
		deleteBoundingSphere(): bool;
		showBoundingSphere(): bool;
		hideBoundingSphere(): bool;

		computeNormals(): void;
		computeTangents(): void;
		computeBinormals(): void;

		isSkinned(): bool;
		getSkin(): ISkin;
		setSkin(pSkin: ISkin): bool;

/** @deprecated */

		applyFlexMaterial(csMaterial: string, pMaterial?: IMaterial): bool;
/** @deprecated */

		getFlexMaterial(iMaterial:  number ): IMaterial;
/** @deprecated */

		getFlexMaterial(csName: string): IMaterial;
/** @deprecated */

		setFlexMaterial(iMaterial:  number ): bool;
/** @deprecated */

		setFlexMaterial(csName: string): bool;

		show(): void;
		hide(): void;

		destroy(): void;
	}
}






module akra {
	export interface ISkeleton {} ;
	export interface INode {} ;
	export interface IMesh {} ;
	export interface IEngine {} ;
	export interface INodeMap {} ;
	export interface IMat4 {} ;
	export interface IVertexData {} ;

// export interface INodeMap {
// 	[index: string]: INode;
// }

	export interface ISkin {
		 data: IRenderDataCollection;
		 skeleton: ISkeleton;
		 totalBones:  number ;

/**
		 * Set binding matrix. 
		 * @see <bind_shape_matrix> in Collada.
		 */

		setBindMatrix(m4fMatrix: IMat4): void;

/**
		 * @see <bind_shape_matrix> in Collada.
		 */

		getBindMatrix(): IMat4;

/**
		 * Bone offset matrices.
		 * @see Bone offset matrices in Collada.
		 */

		getBoneOffsetMatrices(): IMat4[];
		getBoneOffsetMatrix(sBoneName: string): IMat4;
		setBoneOffsetMatrices(pMatrices: IMat4[]): void;

		setSkeleton(pSkeleton: ISkeleton): bool;

/**
		 * Make a skin dependent on scene node whose names match the
		 * names of the bones that affect the skin.
		 */

		attachToScene(pRootNode: ISceneNode): bool;

// /**
//  * Bind skin to skeleton or scene.
//  */
// bind(pSkeleton: ISkeleton): bool;
// bind(pNode: ISceneNode): bool;

/**
		 * Set names of bones, that affect to skin.
		 */

		setBoneNames(pNames: string[]): bool;


/**
		 * Weights.
		 */

		setWeights(pWeights: Float32Array): bool;
		getWeights(): IVertexData;

/**
		 * разметка влияний на вершины
		 * пары: {число влияний, адресс индексов влияний}
		 */

		getInfluenceMetaData(): IVertexData;
/**
		 * инф. о вляиниях на вершины
		 * пары: {индекс матрицы кости, индекс веса}
		 */

		getInfluences(): IVertexData;
		setInfluences(pInfluencesCount:  number [], pInfluences: Float32Array): bool;

/**
		 * Short way to call setWeights() && setIfluences();
		 */

		setVertexWeights(pInfluencesCount:  number [], pInfluences: Float32Array, pWeights: Float32Array): bool;

/**
		 * Recalculate skin matrices and fill it to video memory.
		 */

		applyBoneMatrices(bForce?: bool): bool;

/**
		 * Is skin ready to use?
		 */

		isReady(): bool;

/**
		 * Data with result matrices.
		 */

		getBoneTransforms(): IVertexData;

/**
		 * Check, is this skin affect to data?
		 */

		isAffect(pData: IVertexData): bool;

/**
		 * Add skin info to data with vertices.
		 */

		attach(pData: IVertexData): void;
	}
}





























module akra.model {

	export class Skin implements ISkin {
		private _pMesh: IMesh;

		private _pSkeleton: ISkeleton = null;

// name of bones/nodes
		private _pNodeNames: string[] = null;

//bind matrix from collada
		private _m4fBindMatrix: IMat4 = new Mat4(1);

//BONE_MATRIX = WORLD_MATRIX x OFFSET_MATRIX
		private _pBoneTransformMatrices: IMat4[]  = null;

/**
		 * Common buffer for all transform matrices.
		 * _pBoneOffsetMatrixBuffer = [_pBoneTransformMatrices[0], ..., _pBoneTransformMatrices[N]]
		 */

		private _pBoneOffsetMatrixBuffer: Float32Array = null;

// bone offset matrices from collada
		private _pBoneOffsetMatrices: IMat4[] = null;

/**
		 * Pointers to nodes, that affect to this skin.
		 */

		private _pAffectingNodes: ISceneNode[] = null;

/**
		 * Format:
		 * BONE_INF_COUNT - number of bones, that influence to the vertex.
		 * BONE_INF_LOC - address of influence, pointer to InfData structire list.
		 * ..., [BONE_INF_COUNT: float, BONE_INF_LOC: float], ...
		 * 
		 */

		private _pInfMetaData: IVertexData = null;

/**
		 * Format:
		 * BONE_INF_DATA - bone matrix address, pointer to BONE_MATRIX list
		 * BONE_WEIGHT_IND - bone weight address, pointer to BONE_WEIGHT list
		 * ..., [BONE_INF_DATA: float, BONE_WEIGHT_IND: float], ...
		 */

		private _pInfData: IVertexData = null;

/**
		 * Format:
		 * ..., [BONE_MATRIX: matrix4], ...
		 */

		private _pBoneTransformMatrixData: IVertexData = null;

/**
		 * Format:
		 * ..., [BONE_WEIGHT: float], ...
		 */

		private _pWeightData: IVertexData = null;

/**
		 * Links to VertexData, that contain meta from this skin.
		 */

		private _pTiedData: IVertexData[] = [];



		inline get data(): IRenderDataCollection {
			return this._pMesh.data;
		}

		inline get skeleton(): ISkeleton{
			return this._pSkeleton;
		}

		inline set skeleton(pSkeleton: ISkeleton) {
			if (isNull(pSkeleton) || pSkeleton.totalBones < this.totalBones) {
				logger.setSourceLocation( "Skin.ts" , 88 ); logger.warning("cannnot set skeletonm because skeleton has to little bones"); ;
		        return;
		    }

		    for (var i:  number  = 0, nMatrices:  number  = this.totalBones; i < nMatrices; i++) {
		        this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
		        logger.setSourceLocation( "Skin.ts" , 94 ); logger.assert(isDefAndNotNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists..."); ;
		    }


		    this._pSkeleton = pSkeleton;
		}

		inline get totalBones():  number  {
			return this._pNodeNames.length;
		}

		constructor(pMesh: IMesh) {
		    logger.setSourceLocation( "Skin.ts" , 106 ); logger.assert(isDefAndNotNull(pMesh), "you must specify mesh for skin"); ;

		    this._pMesh = pMesh;
		}

		setBindMatrix(m4fMatrix: IMat4): void {
			this._m4fBindMatrix.set(m4fMatrix);
		}

		getBindMatrix(): IMat4 {
			return this._m4fBindMatrix;
		}

		getBoneOffsetMatrices(): IMat4[] {
			return this._pBoneOffsetMatrices;
		}

		getBoneOffsetMatrix(sBoneName: string): IMat4 {
			var pBoneNames: string[] = this._pNodeNames;

			for (var i = 0; i < pBoneNames.length; i++) {
			    if (pBoneNames[i] === sBoneName) {
			        return this._pBoneOffsetMatrices[i];
			    }
			};

			return null;
		}

		setSkeleton(pSkeleton: ISkeleton): bool {
			if (!pSkeleton || pSkeleton.totalBones < this.totalBones) {
				logger.setSourceLocation( "Skin.ts" , 138 ); logger.warning("number of bones in skeleton (" + pSkeleton.totalBones + ") less then number of bones in skin (" + this.totalBones + ").");
                                                                      ;
			    return false;
			}

			for (var i:  number  = 0, nMatrices = this.totalBones; i < nMatrices; i++) {
			    this._pAffectingNodes[i] = pSkeleton.findJoint(this._pNodeNames[i]);
			    logger.setSourceLocation( "Skin.ts" , 144 ); logger.assert(!isNull(this._pAffectingNodes[i]), "joint<" + this._pNodeNames[i] + "> must exists..."); ;
			}

			this._pSkeleton = pSkeleton;

			return true;
		}

		attachToScene(pRootNode: ISceneNode): bool {
			for (var i:  number  = 0, nMatrices:  number  = this.totalBones; i < nMatrices; i++) {
			    this._pAffectingNodes[i] = <ISceneNode>pRootNode.findEntity(this._pNodeNames[i]);
			    logger.setSourceLocation( "Skin.ts" , 155 ); logger.assert(isDefAndNotNull(this._pAffectingNodes[i]), "node<" + this._pNodeNames[i] + "> must exists..."); ;
			}

			return true;
		}

		setBoneNames(pNames: string[]): bool {
			if (isNull(pNames)) {
				return false;
			}

			this._pNodeNames = pNames;
			this._pAffectingNodes = new Array(pNames.length);

			return true;
		}

		setBoneOffsetMatrices(pMatrices: IMat4[]): void {
			var pMatrixNames: string[] = this._pNodeNames;

			logger.setSourceLocation( "Skin.ts" , 178 ); logger.assert(isDefAndNotNull(pMatrices) && isDefAndNotNull(pMatrixNames) && pMatrixNames.length === pMatrices.length, "number of matrix names must equal matrices data length:\n" + pMatrixNames.length + " / " + pMatrices.length);
                                ;

			var nMatrices:  number  = pMatrixNames.length;
			var pData: IRenderDataCollection = this.data;
			var pMatrixData: Float32Array = new Float32Array(nMatrices * 16);

//FIXME: правильно положить матрицы...
			this._pBoneOffsetMatrices = pMatrices;
			this._pBoneTransformMatrixData = pData._allocateData([VE_MAT4("BONE_MATRIX")], pMatrixData);
			this._pBoneTransformMatrices = new Array(nMatrices);

			for (var i:  number  = 0; i < nMatrices; i++) {
			    this._pBoneTransformMatrices[i] = new Mat4(pMatrixData.subarray(i * 16, (i + 1) * 16), true);
			}


			this._pBoneOffsetMatrixBuffer = pMatrixData;
		}

		setWeights(pWeights: Float32Array): bool {
			this._pWeightData = this.data._allocateData([VE_FLOAT("BONE_WEIGHT")], pWeights);

			return this._pWeightData !== null;
		}

		getWeights(): IVertexData {
			return this._pWeightData;
		}

		getInfluenceMetaData(): IVertexData {
			return this._pInfMetaData;
		}

		getInfluences(): IVertexData {
			return this._pInfData;
		}

		setInfluences(pInfluencesCount:  number [], pInfluences: Float32Array): bool {
			logger.setSourceLocation( "Skin.ts" , 216 ); logger.assert(this._pInfMetaData == null && this._pInfData == null, "vertex weights already setuped."); ;
			logger.setSourceLocation( "Skin.ts" , 217 ); logger.assert(!isNull(this.getWeights()), "you must set weight data before setup influences"); ;

			var pData: IRenderDataCollection = this.data;
			var pInfluencesMeta: Float32Array = new Float32Array(pInfluencesCount.length * 2);

			var iInfLoc:  number  = 0;
			var iTransformLoc:  number  = 0;
			var iWeightsLoc:  number  = 0;

//получаем копию массива влияний
			pInfluences = new Float32Array(pInfluences);

//вычисляем адресса матриц транфсормации и весов
			iTransformLoc = this._pBoneTransformMatrixData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;
			iWeightsLoc = this._pWeightData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;


			for (var i:  number  = 0, n:  number  = pInfluences.length; i < n; i += 2) {
			    pInfluences[i] = pInfluences[i] * 16 + iTransformLoc;
			    pInfluences[i + 1] += iWeightsLoc;
			}

//запоминаем модифицированную информацию о влияниях
			this._pInfData = pData._allocateData([
/*адрес матрицы кости*/
			                                         VE_FLOAT('BONE_INF_DATA'),
/*адрес весового коэффициента*/
			                                         VE_FLOAT('BONE_WEIGHT_IND')
			                                     ],
			                                     pInfluences);

			iInfLoc = this._pInfData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;

//подсчет мета данных, которые укажут, где взять влияния на кость..
			for (var i:  number  = 0, j:  number  = 0, n:  number  = iInfLoc; i < pInfluencesMeta.length; i += 2) {
			    var iCount:  number  = pInfluencesCount[j++];
/*число влияний на вершину*/
			    pInfluencesMeta[i] = iCount;
/*адрес начала информации о влияниях */
			    pInfluencesMeta[i + 1] = n;
//(пары индекс коэф. веса и индекс матрицы)
			    n += 2 * iCount;
			}

//influences meta: разметка влияний
			this._pInfMetaData = pData._allocateData([
/*число костей и весов, влияющих на вершину*/
			                                             VE_FLOAT('BONE_INF_COUNT'),
/*адресс начала влияний на вершину*/
			                                             VE_FLOAT('BONE_INF_LOC'),
			                                         ], pInfluencesMeta);

			return this._pInfMetaData !== null &&
			       this._pInfData !== null;
		}

		setVertexWeights(pInfluencesCount:  number [], pInfluences: Float32Array, pWeights: Float32Array): bool {
			logger.setSourceLocation( "Skin.ts" , 268 ); logger.assert(arguments.length > 1, 'you must specify all parameters'); ;

//загружаем веса 
			if (pWeights) {
			    this.setWeights(pWeights);
			}

			return this.setInfluences(pInfluencesCount, pInfluences);
		}

		applyBoneMatrices(bForce: bool = false): bool {
			var pData: Float32Array;
			var bResult: bool;
			var pNode: ISceneNode;
			var isUpdated: bool = false;

			for (var i:  number  = 0, nMatrices = this.totalBones; i < nMatrices; ++i) {
			    pNode = this._pAffectingNodes[i];

			    if (pNode.isWorldMatrixNew() || bForce) {
			        pNode.worldMatrix.multiply(this._pBoneOffsetMatrices[i], this._pBoneTransformMatrices[i]);
			        isUpdated = true;
			    }
			}

			if (isUpdated) {
			    pData = this._pBoneOffsetMatrixBuffer;
			    return this._pBoneTransformMatrixData.setData(pData, 0, pData.byteLength);
			}

			return false;
		}

		isReady(): bool {
			return !(isNull(this._pInfMetaData) || isNull(this._pInfData) || isNull(this._pWeightData) ||
			         isNull(this._pBoneOffsetMatrixBuffer) || isNull(this._pBoneOffsetMatrices) ||
			         isNull(this._pNodeNames) ||
			         isNull(this._m4fBindMatrix));
		}

		getBoneTransforms(): IVertexData {
			return this._pBoneTransformMatrixData;
		}

		isAffect(pData: IVertexData): bool {
			if (isDefAndNotNull(pData)) {
			    for (var i:  number  = 0; i < this._pTiedData.length; i++) {
			        if (this._pTiedData[i] === pData) {
			            return true;
			        }
			    }
			}

			return false;
		}

		attach(pData: IVertexData): void {
			logger.setSourceLocation( "Skin.ts" , 326 ); logger.assert(pData.stride === 16, "you cannot add skin to mesh with POSITION: {x, y, z}" + "\nyou need POSITION: {x, y, z, w}");
                                                                         ;

			pData.getVertexDeclaration().append(VE_FLOAT(DeclUsages.BLENDMETA, 12));

			this._pTiedData.push(pData);
		}



		static debugMeshSubset(pSubMesh: IMeshSubset) {
			var pMesh: IMesh = pSubMesh.mesh;
			var pSkin: ISkin = pSubMesh.skin;
			var pMatData: IVertexData = pSkin.getBoneTransforms();
			var pPosData: Float32Array;
			var pEngine: IEngine = pMesh.getEngine();

			pPosData = <Float32Array>(pSubMesh.data._getData("POSITION")).getTypedData(DeclUsages.BLENDMETA);

			var pVideoBuffer: IVertexBuffer = pSubMesh.mesh.data.buffer;
			var iFrom:  number  = 2618, iTo:  number  = 2619;
			var pWeights: Float32Array = <Float32Array>pSkin.getWeights().getTypedData('BONE_WEIGHT');

			logger.setSourceLocation( "Skin.ts" , 348 ); logger.log('===== debug vertices from ', iFrom, 'to', iTo, ' ======'); ;
			logger.setSourceLocation( "Skin.ts" , 349 ); logger.log('transformation data location:', pMatData.byteOffset / 4.); ;
			logger.setSourceLocation( "Skin.ts" , 350 ); logger.log('155 weight: ', pSkin.getWeights().getTypedData('BONE_WEIGHT')[155]); ;
			logger.setSourceLocation( "Skin.ts" , 351 ); logger.log('vertices info ===================>'); ;

			for (var i:  number  = iFrom; i < iTo; i++) {
			    logger.setSourceLocation( "Skin.ts" , 354 ); logger.log(pPosData[i], '<< inf meta location'); ;

			    var pMetaData: Float32Array = new Float32Array(8);
			    if (!pVideoBuffer.readData(4 * pPosData[i], 8, pMetaData)) {
			    	logger.setSourceLocation( "Skin.ts" , 358 ); logger.error("cannot read back meta data"); ;
			    }

			    logger.setSourceLocation( "Skin.ts" , 361 ); logger.log(pMetaData[0], '<< count'); ;
			    logger.setSourceLocation( "Skin.ts" , 362 ); logger.log(pMetaData[1], '<< inf. location'); ;

			    for (var j:  number  = 0; j < pMetaData[0]; ++j) {
			        var pInfData = new Float32Array(8);
			        if (!pVideoBuffer.readData(4 * (pMetaData[1] + 2 * j), 8, pInfData)) {
			        	logger.setSourceLocation( "Skin.ts" , 367 ); logger.error("cannot read influence data"); ;
			        }

			        logger.setSourceLocation( "Skin.ts" , 370 ); logger.log(pInfData[0], '<< matrix location'); ;
			        logger.setSourceLocation( "Skin.ts" , 371 ); logger.log(pInfData[1], '/', pInfData[1] - 30432, '<< weight location / index'); ;

			        var pWeightData = new Float32Array(4);

			        if (!pVideoBuffer.readData(4 * (pInfData[1]), 4, pWeightData)) {
			        	logger.setSourceLocation( "Skin.ts" , 376 ); logger.error("cannot read weight data"); ;
			        }

			        logger.setSourceLocation( "Skin.ts" , 379 ); logger.log(pWeightData[0], '<< weight'); ;

			        var pMatrixData = new Float32Array(4 * 16);
			        if (!pVideoBuffer.readData(4 * (pInfData[0]), 4 * 16, pMatrixData)) {
			        	logger.setSourceLocation( "Skin.ts" , 383 ); logger.error("cannot read matrix data"); ;
			        }

			        logger.setSourceLocation( "Skin.ts" , 386 ); logger.log(pMatrixData.toString()); ;
			    }
			}

			logger.setSourceLocation( "Skin.ts" , 390 ); logger.log('#############################################'); ;

			for (var i:  number  = 0; i < pPosData.length; i++) {
			    var pMetaData: Float32Array = new Float32Array(8);
			    if(!pVideoBuffer.readData(4 * pPosData[i], 8, pMetaData)) {
			    	logger.setSourceLocation( "Skin.ts" , 395 ); logger.error("cannot read meta data"); ;
			    }

			    for (var j:  number  = 0; j < pMetaData[0]; ++j) {
			        var pInfData: Float32Array = new Float32Array(8);

			        if (!pVideoBuffer.readData(4 * (pMetaData[1] + 2 * j), 8, pInfData)) {
			        	logger.setSourceLocation( "Skin.ts" , 402 ); logger.error("cannot read influence data"); ;
			        }

			        var iWeightsIndex:  number  = pInfData[1] - 30432;

			        var fWeightOrigin:  number  = pWeights[iWeightsIndex];
			        var pWeightData:  number  = new Float32Array(4);
			        if (!pVideoBuffer.readData(4 * (pInfData[1]), 4, pWeightData)) {
			        	logger.setSourceLocation( "Skin.ts" , 410 ); logger.error("cannot read weight data"); ;
			        }
			        var fWeight:  number  = pWeightData[0];

			        if (Math.abs(fWeight - fWeightOrigin) > 0.001) {
			            alert("1");
			            logger.setSourceLocation( "Skin.ts" , 416 ); logger.log("weight with index", iWeightsIndex, "has wrong weight", fWeightOrigin, "/", fWeightOrigin); ;
			        }

//var pWeightData: Float32Array = new Float32Array(pVideoBuffer.getData(4 * (pInfData[1]), 4));
//var pMatrixData: Float32Array = new Float32Array(pVideoBuffer.getData(4 * (pInfData[0]), 4 * 16));
			    }
			}

			logger.setSourceLocation( "Skin.ts" , 424 ); logger.log('##############################################'); ;
// var pBoneTransformMatrices = pSkin._pBoneTransformMatrixData;
// var pBonetmData = pBoneTransformMatrices.getTypedData('BONE_MATRIX');

// for (var i = 0; i < pBonetmData.length; i += 16) {
//     LOG('bone transform matrix data >>> ');
//     LOG(Mat4.str(pBonetmData.subarray(i, i + 16)));
// };


//for (var i = 0; i < pMesh.length; i++) {
// var i = pMesh.length - 1;
//     var pPosData = pMesh[i].data.getData('POSITION').getTypedData('POSITION');
//     var pIndData = pMesh[i].data._pIndexData.getTypedData('INDEX0');

//     var j = pIndData[pIndData.length - 1];
//     var j0 = pMesh[i].data.getData('POSITION').byteOffset/4;

//     j -= j0;
//     j/=4;

//     LOG('last index >> ', j);
//     LOG('pos data size', pPosData.length);

//     var pVertex = pPosData.subarray(j * 3, j * 3 + 3);

//     LOG('last vertex in submesh >> ', pVertex[0], pVertex[1], pVertex[2]);

//         var pSceneNode = pEngine.appendMesh(
//             pEngine.pCubeMesh.clone(a.Mesh.GEOMETRY_ONLY|a.Mesh.SHARED_GEOMETRY),
//             pEngine.getRootNode());

//         pSceneNode.setPosition(pVertex);
//         pSceneNode.setScale(0.1);
//     var pMeta = pSkin.getInfluenceMetaData().getTypedData('BONE_INF_COUNT');
//     LOG(pMeta[j], 'count << ');

//};
		}

	}



	export function createSkin(pMesh: IMesh): ISkin {
		return new Skin(pMesh);
	}
}




































module akra {

	export interface IVec2 {} ;

	export interface IRay2d {
		point: IVec2;
		normal: IVec2;
	};
}



module akra.geometry{
	export  class  Ray2d implements IRay2d{
		point: IVec2;
		normal: IVec2;

		constructor(){
			this.point = new Vec2();
			this.normal = new Vec2();
		};
	};
}












module akra {

	export interface IVec3 {} ;

	export interface IRay3d {
		point: IVec3;
		normal: IVec3;
	};
}



module akra.geometry{
	export  class  Ray3d implements IRay3d{
		point: IVec3;
		normal: IVec3;

		constructor(){
			this.point = new Vec3();
			this.normal = new Vec3();
		};
	};
}













module akra {

	export interface IRay2d {} ;

	export interface ISegment2d{
		ray: IRay2d;
		distance:  number ;

		point: IVec2;
		normal: IVec2;
	};
}



module akra.geometry{
	export class Segment2d implements ISegment2d{
		ray: IRay2d;
		distance:  number ;

		constructor(){
			this.ray = new Ray2d();
			this.distance = 0.;
		};

		get point(): IVec2{
			return this.ray.point;
		};
		set point(v2fPoint: IVec2){
			this.ray.point.set(v2fPoint);
		};

		get normal(): IVec2{
			return this.ray.normal;
		};
		set normal(v2fNormal: IVec2){
			this.ray.normal.set(v2fNormal);
		};
	};
}












module akra {

	export interface IRay3d {} ;

	export interface ISegment3d{
		ray: IRay3d;
		distance:  number ;

		point: IVec3;
		normal: IVec3;
	};
}



module akra.geometry{
	export class Segment3d implements ISegment3d{
		ray: IRay3d;
		distance:  number ;

		constructor(){
			this.ray = new Ray3d();
			this.distance = 0.;
		};

		get point(): IVec3{
			return this.ray.point;
		};
		set point(v3fPoint: IVec3){
			this.ray.point.set(v3fPoint);
		};

		get normal(): IVec3{
			return this.ray.normal;
		};
		set normal(v3fNormal: IVec3){
			this.ray.normal.set(v3fNormal);
		};
	};
}












































module akra.geometry{

	export function intersectPlane2dRay2d(pPlane: IPlane2d, pRay: IRay2d): bool{
		var fDistance:  number  = pPlane.signedDistance(pRay.point);
		var fNdotV:  number  = pPlane.normal.dot(pRay.normal);

		if(fDistance == 0.){
			return true;
		}
		else{
			if(fNdotV == 0.){
				return false;
			}
			else{
				if(fDistance/fNdotV < 0.){
					return true;
				}
				else{
					return false;
				}
			}
		}
	};

	export function intersectPlane3dRay3d(pPlane: IPlane3d, pRay: IRay3d): bool{
		var fDistance:  number  = pPlane.signedDistance(pRay.point);
		var fNdotV:  number  = pPlane.normal.dot(pRay.normal);

		if(fDistance == 0.){
			return true;
		}
		else{
			if(fNdotV == 0.){
				return false;
			}
			else{
				if(fDistance/fNdotV < 0.){
					return true;
				}
				else{
					return false;
				}
			}
		}
	};

	export function intersectCircleRay2d(pCircle: ICircle, pRay: IRay2d): bool{
		var v2fCenterToPoint: IVec2 = pRay.point.subtract(pCircle.center, vec2());

		var v2fNormal: IVec2 = pRay.normal;

//a*t^2+ 2b*t + c = 0;

		var fA:  number  = v2fNormal.lengthSquare();
		var fB:  number  = v2fCenterToPoint.dot(v2fNormal);
		var fC:  number  = v2fCenterToPoint.lengthSquare() - pCircle.radius*pCircle.radius;

/*b^2/4 - a*c*/
		var fDiscriminant:  number  = fB*fB - fA*fC;

		if(fDiscriminant < 0.){
			return false;
		}

		var fSqrtDiscriminant:  number  = math.sqrt(fDiscriminant);

		var fT1:  number  = (-fB + fSqrtDiscriminant)/fA;
//var fT2: float = (-fB - fSqrtDiscriminant)/fA;
//fT2 don't needed because fT2 < fT1 always
//since fA > 0

		if(fT1 < 0.){
			return false;
		}
		else{
			return true;
		}
	};

	export function intersectSphereRay3d(pSphere: ISphere, pRay: IRay3d): bool{
		var v3fCenterToPoint: IVec3 = pRay.point.subtract(pSphere.center, vec3());

		var v3fNormal: IVec3 = pRay.normal;

//a*t^2+ 2b*t + c = 0;

		var fA:  number  = v3fNormal.lengthSquare();
		var fB:  number  = v3fCenterToPoint.dot(v3fNormal);
		var fC:  number  = v3fCenterToPoint.lengthSquare() - pSphere.radius*pSphere.radius;

/*b^2/4 - a*c*/
		var fDiscriminant:  number  = fB*fB - fA*fC;

		if(fDiscriminant < 0.){
			return false;
		}

		var fSqrtDiscriminant:  number  = math.sqrt(fDiscriminant);

		var fT1:  number  = (-fB + fSqrtDiscriminant)/fA;
//var fT2: float = (-fB - fSqrtDiscriminant)/fA;
//fT2 don't needed because fT2 < fT1 always
//since fA > 0

		if(fT1 < 0.){
			return false;
		}
		else{
			return true;
		}
	};

	export function intersectRect2dRay2d(pRect: IRect2d, pRay: IRay2d): bool{
		var v2fNormal: IVec2 = pRay.normal;
		var v2fPoint: IVec2 = pRay.point;

		var fT1:  number , fT2:  number ;

		var fX1:  number , fX2:  number ;
		var fY1:  number , fY2:  number ;

		if(v2fNormal.x != 0.){
			fT1 = (pRect.x0 - v2fPoint.x)/v2fNormal.x;
			fT2 = (pRect.x1 - v2fPoint.x)/v2fNormal.x;
		}
		else{
			fT1 = (pRect.y0 - v2fPoint.y)/v2fNormal.y;
			fT2 = (pRect.y1 - v2fPoint.y)/v2fNormal.y;
		}

		if(fT1 < 0 && fT2 < 0){
			return false;
		}

		fT1 = math.max(fT1,0.);
		fT2 = math.max(fT2,0.);

		fX1 = v2fPoint.x + fT1*v2fNormal.x;
		fX2 = v2fPoint.x + fT2*v2fNormal.x;

		fY1 = v2fPoint.y + fT1*v2fNormal.y;
		fY2 = v2fPoint.y + fT2*v2fNormal.y;

		if(		(fX1 < pRect.x0 && fX2 < pRect.x0)
			||  (fX1 > pRect.x1 && fX2 > pRect.x1)

			||  (fY1 < pRect.y0 && fY2 < pRect.y0)
			||  (fY1 > pRect.y1 && fY2 > pRect.y1)){

			return false;
		}

		return true;
	};

	export function intersectRect3dRay3d(pRect: IRect3d, pRay: IRay3d): bool{
		var v3fNormal: IVec3 = pRay.normal;
		var v3fPoint: IVec3 = pRay.point;

		var fT1:  number , fT2:  number ;

		var fX1:  number , fX2:  number ;
		var fY1:  number , fY2:  number ;
		var fZ1:  number , fZ2:  number ;

		if(v3fNormal.x != 0.){
			fT1 = (pRect.x0 - v3fPoint.x)/v3fNormal.x;
			fT2 = (pRect.x1 - v3fPoint.x)/v3fNormal.x;
		}
		else if(v3fNormal.y != 0.){
			fT1 = (pRect.y0 - v3fPoint.y)/v3fNormal.y;
			fT2 = (pRect.y1 - v3fPoint.y)/v3fNormal.y;
		}
		else{
			fT1 = (pRect.z0 - v3fPoint.z)/v3fNormal.z;
			fT2 = (pRect.z1 - v3fPoint.z)/v3fNormal.z;
		}

		if(fT1 < 0 && fT2 < 0){
			return false;
		}

		fT1 = math.max(fT1,0.);
		fT2 = math.max(fT2,0.);

		fX1 = v3fPoint.x + fT1*v3fNormal.x;
		fX2 = v3fPoint.x + fT2*v3fNormal.x;

		fY1 = v3fPoint.y + fT1*v3fNormal.y;
		fY2 = v3fPoint.y + fT2*v3fNormal.y;

		fZ1 = v3fPoint.z + fT1*v3fNormal.z;
		fZ2 = v3fPoint.z + fT2*v3fNormal.z;

		if(		(fX1 < pRect.x0 && fX2 < pRect.x0)
			||  (fX1 > pRect.x1 && fX2 > pRect.x1)

			||  (fY1 < pRect.y0 && fY2 < pRect.y0)
			||  (fY1 > pRect.y1 && fY2 > pRect.y1)

			||	(fZ1 < pRect.z0 && fZ2 < pRect.z0)
			||  (fZ1 > pRect.z1 && fZ2 > pRect.z1)){

			return false;
		}

		return true;
	};

	export function intersectCircleCircle(pCircle1: ICircle, pCircle2: ICircle): bool{
		var v2fCenter1: IVec2 = pCircle1.center;
		var v2fCenter2: IVec2 = pCircle2.center;

		var fX:  number  = v2fCenter2.x - v2fCenter1.x;
		var fY:  number  = v2fCenter2.y - v2fCenter1.y;

		var fContactRadius:  number  = pCircle1.radius + pCircle2.radius;

		if((fX*fX + fY*fY) > fContactRadius*fContactRadius){
			return false;
		}
		return true;
	};

	export function intersectSphereSphere(pSphere1: ISphere, pSphere2: ISphere): bool{
		var v3fCenter1: IVec3 = pSphere1.center;
		var v3fCenter2: IVec3 = pSphere2.center;

		var fX:  number  = v3fCenter2.x - v3fCenter1.x;
		var fY:  number  = v3fCenter2.y - v3fCenter1.y;
		var fZ:  number  = v3fCenter2.z - v3fCenter1.z;

		var fContactRadius:  number  = pSphere1.radius + pSphere2.radius;

		if((fX*fX + fY*fY + fZ*fZ) > fContactRadius*fContactRadius){
			return false;
		}
		return true;
	};

	export function intersectRect2dCircle(pRect: IRect2d, pCircle: ICircle){
		var v2fCenter: IVec2 = pCircle.center;
		var fOffsetX:  number  = 0., fOffsetY:  number  = 0.;
		var nInside:  number  = 0;

		if(v2fCenter.x < pRect.x0){
			fOffsetX = pRect.x0 - v2fCenter.x;
		}
		else if(v2fCenter.x > pRect.x1){
			fOffsetX = v2fCenter.x - pRect.x1;
		}
		else{
			nInside++;
		}

		if(v2fCenter.y < pRect.y0){
			fOffsetY = pRect.y0 - v2fCenter.y;
		}
		else if(v2fCenter.y > pRect.y1){
			fOffsetY = v2fCenter.y - pRect.y1;
		}
		else{
			nInside++;
		}

//if nInside == 2 then circle inside rect
		if(nInside === 2){
			return true;
		}

		var fOffsetLengthSquare:  number  = fOffsetX*fOffsetX + fOffsetY*fOffsetY;
		var fRadius:  number  = pCircle.radius;

		if(fOffsetLengthSquare > fRadius*fRadius){
			return false;
		}
		return true;
	};

	export function intersectRect3dSphere(pRect: IRect3d, pSphere: ISphere){
		var v3fCenter: IVec3 = pSphere.center;
		var fOffsetX:  number  = 0., fOffsetY:  number  = 0., fOffsetZ:  number  = 0.;
		var nInside:  number  = 0;

		if(v3fCenter.x < pRect.x0){
			fOffsetX = pRect.x0 - v3fCenter.x;
		}
		else if(v3fCenter.x > pRect.x1){
			fOffsetX = v3fCenter.x - pRect.x1;
		}
		else{
			nInside++;
		}

		if(v3fCenter.y < pRect.y0){
			fOffsetY = pRect.y0 - v3fCenter.y;
		}
		else if(v3fCenter.y > pRect.y1){
			fOffsetY = v3fCenter.y - pRect.y1;
		}
		else{
			nInside++;
		}

		if(v3fCenter.z < pRect.z0){
			fOffsetZ = pRect.z0 - v3fCenter.z;
		}
		else if(v3fCenter.z > pRect.z1){
			fOffsetZ = v3fCenter.z - pRect.z1;
		}
		else{
			nInside++;
		}

//if nInside == 3 then sphere inside rect
		if(nInside === 3){
			return true;
		}

		var fOffsetLengthSquare:  number  = fOffsetX*fOffsetX + fOffsetY*fOffsetY + fOffsetZ*fOffsetZ;
		var fRadius:  number  = pSphere.radius;

		if(fOffsetLengthSquare > fRadius*fRadius){
			return false;
		}
		return true;
	};

	export function intersectRect2dRect2d(pRect1: IRect2d, pRect2: IRect2d, pResult?: IRect2d): bool{
		if(!isDef(pResult)){
			var fX0:  number  = math.max(pRect1.x0, pRect2.x0);
			var fX1:  number  = math.min(pRect1.x1, pRect2.x1);
			if(fX0 <= fX1){
				var fY0:  number  = math.max(pRect1.y0, pRect2.y0);
				var fY1:  number  = math.min(pRect1.y1, pRect2.y1);
				if(fY0 <= fY1){
					return true;
				}
			}
			return false;
		}
		else{
			pResult.x0 = math.max(pRect1.x0, pRect2.x0);
			pResult.x1 = math.min(pRect1.x1, pRect2.x1);

			pResult.y0 = math.max(pRect1.y0, pRect2.y0);
			pResult.y1 = math.min(pRect1.y1, pRect2.y1);

			return pResult.isValid();
		}
	};

	export function intersectRect3dRect3d(pRect1: IRect3d, pRect2: IRect3d, pResult?: IRect3d): bool{
		if(!isDef(pResult)){
			var fX0:  number  = math.max(pRect1.x0, pRect2.x0);
			var fX1:  number  = math.min(pRect1.x1, pRect2.x1);
			if(fX0 <= fX1){
				var fY0:  number  = math.max(pRect1.y0, pRect2.y0);
				var fY1:  number  = math.min(pRect1.y1, pRect2.y1);
				if(fY0 <= fY1){
					var fZ0:  number  = math.max(pRect1.z0, pRect2.z0);
					var fZ1:  number  = math.min(pRect1.z1, pRect2.z1);
					if(fZ0 <= fZ1){
						return true;
					}
				}
			}
			return false;
		}
		else{
			pResult.x0 = math.max(pRect1.x0, pRect2.x0);
			pResult.x1 = math.min(pRect1.x1, pRect2.x1);

			pResult.y0 = math.max(pRect1.y0, pRect2.y0);
			pResult.y1 = math.min(pRect1.y1, pRect2.y1);

			pResult.z0 = math.max(pRect1.z0, pRect2.z0);
			pResult.z1 = math.min(pRect1.z1, pRect2.z1);

			return pResult.isValid();
		}
	};

	export function intersect(pPlane: IPlane2d, pRay: IRay2d): bool;
	export function intersect(pPlane: IPlane3d, pRay: IRay3d): bool;
	export function intersect(pCircle: ICircle, pRay: IRay2d): bool;
	export function intersect(pSphere: ISphere, pRay: IRay3d): bool;
	export function intersect(pRect: IRect2d, pRay: IRay2d): bool;
	export function intersect(pRect: IRect3d, pRay: IRay3d): bool;
	export function intersect(pCircle1: ICircle, pCircle2: ICircle): bool;
	export function intersect(pSphere1: ISphere, pSphere2: ISphere): bool;
	export function intersect(pRect: IRect2d, pCircle: ICircle): bool;
	export function intersect(pRect: IRect3d, pSphere: ISphere): bool;
	export function intersect(pRect1: IRect2d, pRect2: IRect2d, pResult?: IRect2d): bool;
	export function intersect(pRect1: IRect3d, pRect2: IRect3d, pResult?: IRect3d): bool;
	export function intersect(pRect1?, pRect2?, pResult?): bool{
		var nArgumentsLength:  number  = arguments.length;

		if(nArgumentsLength === 3){
			if(arguments[2] instanceof Rect2d){
				return intersectRect2dRect2d(arguments[0], arguments[1], arguments[2]);
			}
			else{
				return intersectRect3dRect3d(arguments[0], arguments[1], arguments[2]);
			}
		}
		else{
			var pArg0: any = arguments[0];
			var pArg1: any = arguments[1];

			if(pArg1 instanceof Ray2d){
				if(pArg0 instanceof Plane2d){
					return intersectPlane2dRay2d(pArg0, pArg1);
				}
				else if(pArg0 instanceof Circle){
					return intersectCircleRay2d(pArg0, pArg1);
				}
				else{
					return intersectRect2dRay2d(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Ray3d){
				if(pArg0 instanceof Plane3d){
					return intersectPlane3dRay3d(pArg0, pArg1);
				}
				else if(pArg0 instanceof Sphere){
					return intersectSphereRay3d(pArg0, pArg1);
				}
				else{
					return intersectRect3dRay3d(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Circle){
				if(pArg0 instanceof Circle){
					return intersectCircleCircle(pArg0, pArg1);
				}
				else{
					return intersectRect2dCircle(pArg0, pArg1);
				}
			}
			else if(pArg1 instanceof Sphere){
				if(pArg0 instanceof Sphere){
					return intersectSphereSphere(pArg0, pArg1);
				}
				else{
					return intersectRect3dSphere(pArg0, pArg1);
				}
			}
			else{
				if(pArg0 instanceof Rect2d){
					return intersectRect2dRect2d(pArg0, pArg1);
				}
				else{
					return intersectRect3dRect3d(pArg0, pArg1);
				}
			}
		}
	};
};










module akra.geometry {
	export function computeBoundingBox(pVertexData: IVertexData, pBoundingBox: IRect3d): bool;
	export function computeDataForCascadeBoundingBox(pBoundingBox: IRect3d, ppVertexes:  number [], ppIndexes:  number [], fMinSize?:  number ): bool;
	export function computeBoundingSphere(pVertexData: IVertexData, pSphere: ISphere, bFastMethod?: bool, pBoundingBox?: IRect3d): bool;
	export function computeBoundingSphereFast(pVertexData: IVertexData, pSphere: ISphere, pBoundingBox: IRect3d = null): bool;
	export function computeBoundingSphereMinimal(pVertexData: IVertexData, pSphere: ISphere): bool;
	export function computeGeneralizingSphere(pSphereA: ISphere, pSphereB: ISphere, pSphereDest?: ISphere): bool;
	export function computeDataForCascadeBoundingSphere(pBoundingSphere: ISphere, ppVertexes:  number [], ppIndexes:  number [], fMinSize?:  number ): bool;

/**
	 * Computes a coordinate-axis oriented bounding box.
	 */

	export function computeBoundingBox (pVertexData, pBoundingBox): bool {
		var fX0:  number  = 0, fY0:  number  = 0, fZ0:  number  = 0,
			fX1:  number  = 0, fY1:  number  = 0, fZ1:  number  = 0;
		var fTemp:  number , pTempData: Float32Array;
		var i:  number  = 0;
		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement, pData: ArrayBuffer;
		var nStride:  number , nCount:  number ;


		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if(isNull(pVertexDeclaration))
			return false;

		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION, 3);

		if(isNull(pVertexElement))
			return false;

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (isNull(pData))
			return false;

		pTempData = new Float32Array(pData, 0, 3);
		fX0 = fX1 = pTempData[0];
		fY0 = fY1 = pTempData[1];
		fZ0 = fZ1 = pTempData[2];

		for (i = nStride; i < nStride * nCount; i += nStride) {

			pTempData = new Float32Array(pData, i, 3);
			fTemp = pTempData[0];
/*Min*/
			fX0 = fX0 > fTemp ? fTemp : fX0;
/*Max*/
			fX1 = fX1 > fTemp ? fX1 : fTemp;

			fTemp = pTempData[1];
/*Min*/
			fY0 = fY0 > fTemp ? fTemp : fY0;
/*Max*/
			fY1 = fY1 > fTemp ? fY1 : fTemp;

			fTemp = pTempData[2];
/*Min*/
			fZ0 = fZ0 > fTemp ? fTemp : fZ0;
/*Max*/
			fZ1 = fZ1 > fTemp ? fZ1 : fTemp;
		}

		pBoundingBox.set(fX0,fX1,fY0,fY1,fZ0,fZ1);

	    return true;
	};

/** расчет данных для отрисовки бокса */

	export function computeDataForCascadeBoundingBox(pBoundingBox: IRect3d, ppVertexes:  number [], ppIndexes:  number [], fMinSize:  number  = .25): bool {

		var pInd:  number [];
		var pPoints: IVec3[][];
		var i:  number , j:  number , k:  number ;

		pPoints = new Array(8);

		for(i = 0; i < 8; i ++) {
			pPoints[i] = new Array(4);
			for(j = 0; j < 4; j++)
				pPoints[i][j] = new Vec3(0);
		}

//Выставление точек Rect3d
		pPoints[0][0].set([pBoundingBox.x0,pBoundingBox.y0,pBoundingBox.z0]);
		pPoints[1][0].set([pBoundingBox.x0,pBoundingBox.y1,pBoundingBox.z0]);
		pPoints[2][0].set([pBoundingBox.x0,pBoundingBox.y0,pBoundingBox.z1]);
		pPoints[3][0].set([pBoundingBox.x0,pBoundingBox.y1,pBoundingBox.z1]);
		pPoints[4][0].set([pBoundingBox.x1,pBoundingBox.y0,pBoundingBox.z0]);
		pPoints[5][0].set([pBoundingBox.x1,pBoundingBox.y1,pBoundingBox.z0]);
		pPoints[6][0].set([pBoundingBox.x1,pBoundingBox.y0,pBoundingBox.z1]);
		pPoints[7][0].set([pBoundingBox.x1,pBoundingBox.y1,pBoundingBox.z1]);

		var fTempFunc = function(pPoints: IVec3[][], iPoint:  number , iToPoint1:  number , iToPoint2:  number , iToPoint3:  number ): void {
			for(var i = 0;i < 3; i ++) {
				pPoints[arguments[i + 2]][0].subtract(pPoints[iPoint][0], pPoints[iPoint][i+1]);

				if(pPoints[iPoint][i + 1].length() > fMinSize) {
					pPoints[iPoint][i + 1].scale(0.1);
				}

				pPoints[iPoint][i + 1].add(pPoints[iPoint][0]);
			}
		}

		fTempFunc(pPoints,0,1,2,4);
		fTempFunc(pPoints,1,0,3,5);
		fTempFunc(pPoints,2,0,3,6);
		fTempFunc(pPoints,3,1,2,7);
		fTempFunc(pPoints,4,0,5,6);
		fTempFunc(pPoints,5,1,4,7);
		fTempFunc(pPoints,6,2,4,7);
		fTempFunc(pPoints,7,3,5,6);

		for(i = 0; i < 8; i++) {
			for(j = 0; j < 4; j++) {
				ppVertexes[i * 12 + j * 3 + 0] = pPoints[i][j].x;
				ppVertexes[i * 12 + j * 3 + 1] = pPoints[i][j].y;
				ppVertexes[i * 12 + j * 3 + 2] = pPoints[i][j].z;
			}
		}

		pInd = [
			0, 1, 0, 2, 0, 3,
			4, 5, 4, 6, 4, 7,
			8, 9, 8,10, 8,11,
			12,13,12,14,12,15,
			16,17,16,18,16,19,
			20,21,20,22,20,23,
			24,25,24,26,24,27,
			28,29,28,30,28,31
		];

		for(var i:  number  = 0; i < pInd.length; ++ i) {
			ppIndexes[i] = pInd[i];
		}

		return true;
	}


/** подсчет обобщающей сферы над двумя сферами */

	export function computeGeneralizingSphere (pSphereA: ISphere, pSphereB: ISphere, pSphereDest?: ISphere): bool {
	    if (!isDef(pSphereDest)) {
	        pSphereDest = pSphereA;
	    }

	    var fR1:  number  = pSphereA.radius;
	    var fR2:  number  = pSphereB.radius;
	    var v3fC1: IVec3 = pSphereA.center;
	    var v3fC2: IVec3 = pSphereB.center;

	    var v3fD: IVec3 = new Vec3;

	    v3fC1.subtract(v3fC2, v3fD);

	    var fD:  number  = v3fD.length();

	    if (fD < fR1 && fR1 > fR2) {
	        pSphereDest.set(pSphereA);
	        return false;
	    }

	    if (fD < fR2) {
	        pSphereDest.set(pSphereB);
	        return false;
	    }

	    var v3fN: IVec3 = new Vec3;
	    v3fD.normalize(v3fN);

	    pSphereDest.radius = v3fD.add(v3fN.scale(fR1 + fR2)).length() / 2.0;

	    var v3fTemp: IVec3 = v3fD;
	    pSphereDest.center = v3fC1.add(v3fC2, v3fTemp).add(v3fN.scale((fR1 - fR2) / (fR1 + fR2))).scale(.5);

	    return true;
	}

/** расчет данных для отрисовки сферы */

	export function computeDataForCascadeBoundingSphere(
		pBoundingSphere: ISphere,
		ppVertexes:  number [],
		ppIndexes:  number [],
		fMinSize:  number  = 0.25): bool {

		var fTheta:  number , fDelta:  number , fAlpha:  number ;
		var nCount:  number  = 10;
		var i:  number , j:  number , k:  number , a;

		fDelta = 2 * Math.PI / nCount;

		for(i = 0; i <= nCount / 2; i ++) {
			fTheta=-Math.PI+(i*fDelta);
			for(j = 0; j <= nCount; j++) {
				fAlpha = j * fDelta;
				ppVertexes[(i*(nCount+1)+j)*3+0] = pBoundingSphere.center.x + pBoundingSphere.radius * Math.sin(fTheta) * Math.cos(fAlpha);
				ppVertexes[(i*(nCount+1)+j)*3+1] = pBoundingSphere.center.y + pBoundingSphere.radius * Math.sin(fTheta) * Math.sin(fAlpha);
				ppVertexes[(i*(nCount+1)+j)*3+2] = pBoundingSphere.center.z + pBoundingSphere.radius * Math.cos(fTheta);
			}
		}

		for(i = 0; i < nCount / 2; i++) {
			for(j = 0; j < nCount; j++) {
				ppIndexes[(i * (nCount) + j) * 12 + 0] = i * (nCount + 1) + j;
				ppIndexes[(i * (nCount) + j) * 12 + 1] = i * (nCount + 1) + j + 1;

				ppIndexes[(i * (nCount) + j) * 12 + 2] = i * (nCount + 1) + j + 2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 3] = i * (nCount + 1) + j;

				ppIndexes[(i * (nCount) + j) * 12 + 4] = i * (nCount + 1) + j + 1;
				ppIndexes[(i * (nCount) + j) * 12 + 5] = i * (nCount + 1) + j + 2 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 6] = i * (nCount + 1) + j;
				ppIndexes[(i * (nCount) + j) * 12 + 7] = i * (nCount + 1) + j + 1 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 8] = i * (nCount + 1) + j +2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 9] = i * (nCount + 1) + j +1 + nCount;

				ppIndexes[(i * (nCount) + j) * 12 + 10 ] = i *(nCount + 1) + j +2 + nCount;
				ppIndexes[(i * (nCount) + j) * 12 + 11 ] = i *(nCount + 1) + j;
			}
		}

		return true;
	}

/** 
	 * Computes a bounding sphere.
	 * При использование быстрого вычисления, опционально можно получить баундинг бокс. 
	 */

	export function computeBoundingSphere(pVertexData: IVertexData, pSphere: ISphere, bFastMethod: bool = true, pBoundingBox: IRect3d = null) {
		if(bFastMethod) {
			return computeBoundingSphereFast(pVertexData, pSphere, pBoundingBox);
		}
		else {
			return computeBoundingSphereMinimal(pVertexData, pSphere);
		}

	}

/**
	 * Computes a bounding sphere - not minimal. Also if it need compute dounding box
	 */

	export function computeBoundingSphereFast(pVertexData: IVertexData, pSphere: ISphere, pBoundingBox: IRect3d = null): bool {
	    var i:  number ;
		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement;
		var nCount:  number , nStride:  number ;
		var pData: ArrayBuffer, pTempData: Float32Array;

		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if(isNull(pVertexDeclaration)) {
			return false;
		}


		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION, 3);

		if(isNull(pVertexElement)) {
			return false;
		}

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (isNull(pData)) {
			return false;
		}

		if (isNull(pBoundingBox)) {
			pBoundingBox =  Rect3d.stackCeil ;
		}

		if (pBoundingBox.isClear()) {
			if(!computeBoundingBox(pVertexData, pBoundingBox)) {
				return false;
			}
	    }

	    var fCenterX:  number  = (pBoundingBox.x0 + pBoundingBox.x1) / 2;
	    var fCenterY:  number  = (pBoundingBox.y0 + pBoundingBox.y1) / 2;
	    var fCenterZ:  number  = (pBoundingBox.z0 + pBoundingBox.z1) / 2;
	    var fRadius:  number  = 0;
	    var fDistance:  number  = 0;

	    for (i = 0; i < nStride * nCount; i += nStride) {
			pTempData = new Float32Array(pData, i, 3);
	        fDistance = (pTempData[0] - fCenterX) * (pTempData[0] - fCenterX) +
	            (pTempData[1] - fCenterY) * (pTempData[1] - fCenterY) +
	            (pTempData[2] - fCenterZ) * (pTempData[2] - fCenterZ);
	        fRadius = fDistance > fRadius ? fDistance : fRadius;
	    }

		pSphere.set(fCenterX, fCenterY, fCenterZ ,Math.sqrt(fRadius));

	    return true;
	}



/**
	 * Computes a bounding sphere - minimal.
	 */

	export function computeBoundingSphereMinimal (pVertexData: IVertexData, pSphere: ISphere): bool {
	    var i:  number  = 0, j:  number  = 0, k:  number  = 0;
	    var points:  number [] = [];
	    var length:  number  = 0;
	    var isAdd: bool = false;
	    var isNew: bool = true;
	    var fDiametr:  number  = 0;
	    var fDistance:  number  = 0;

		var pVertexDeclaration: IVertexDeclaration, pVertexElement: IVertexElement;
		var nCount:  number , nStride:  number ;
		var pData: ArrayBuffer, pTempData1: Float32Array, pTempData2: Float32Array;

		pVertexDeclaration = pVertexData.getVertexDeclaration();

		if (isNull(pVertexData)) {
			return false;
		}

		if(isNull(pVertexDeclaration)) {
			return false;
		}

		pVertexElement = pVertexDeclaration.findElement(DeclUsages.POSITION,3);

		if(isNull(pVertexElement))
			return false;

		nCount = pVertexData.length;
		nStride = pVertexElement.size;

		pData = pVertexData.getData(pVertexElement.offset, pVertexElement.size);

		if (!pData)
			return false;


	    for (i = 0; i < nStride * nCount; i += nStride) {
	        isNew = true;
	        isAdd = false;
	        pTempData1 = new Float32Array(pData, i, 3);

	        for (k = 0; k < points.length; k += 3) {
	            if (points[k] == pTempData1[0] &&
	                points[k + 1] == pTempData1[1] &&
	                points[k + 2] == pTempData1[2]) {
	                isNew = false;
	                break;
	            }
	        }

	        if (isNew) {
	            for (j = i + nStride; j < nStride * nCount; j += nStride) {
	                pTempData2 = new Float32Array(pData, j, 3);
	                fDistance = (pTempData1[0] - pTempData2[0]) * (pTempData1[0] - pTempData2[0]) +
	                    (pTempData1[1] - pTempData2[1]) * (pTempData1[1] - pTempData2[1]) +
	                    (pTempData1[2] - pTempData2[2]) * (pTempData1[2] - pTempData2[2]);
	                if (fDistance > fDiametr) {
	                    fDiametr = fDistance;
	                    isAdd = true;
	                    points[0] = pTempData2[0];
	                    points[1] = pTempData2[1];
	                    points[2] = pTempData2[2];
	                    length = 3;
	                }
	                else if (fDistance.toFixed(7) == fDiametr.toFixed(7)) {
	                    isAdd = true;
	                    for (k = 0; k < points.length; k += 3) {
	                        if (points[k] == pTempData2[0] &&
	                            points[k + 1] == pTempData2[1] &&
	                            points[k + 2] == pTempData2[2]) {
	                            isNew = false;
	                            break;
	                        }
	                    }
	                    if (isNew) {
	                        points[length] = pTempData2[0];
	                        points[length + 1] = pTempData2[1];
	                        points[length + 2] = pTempData2[2];
	                        length += 3;
	                    }
	                }
	            }
	            if (isAdd) {
	                points[length] = pTempData1[0];
	                points[length + 1] = pTempData1[1];
	                points[length + 2] = pTempData1[2];
	                length += 3
	            }
	        }
	    }

	    var fX:  number  = 0, fY:  number  = 0, fZ:  number  = 0;

	    for (i = 0; i < points.length; i += 3) {
	        fX += points[i];
	        fY += points[i + 1];
	        fZ += points[i + 2];
	    }

	    var x:  number  = pSphere.center.x = fX / points.length * 3;
	    var y:  number  = pSphere.center.y = fY / points.length * 3;
	    var z:  number  = pSphere.center.z = fZ / points.length * 3;

	    pSphere.radius = Math.sqrt((points[0] - x) * (points[0] - x) +
	                                    (points[1] - y) * (points[1] - y) +
	                                    (points[2] - z) * (points[2] - z));
	    return true;
	}

}





module akra.model {
	export class MeshSubset extends render.RenderableObject implements IMeshSubset {
		/**@protected*/  _pRenderData: IRenderData = null;
		/**@protected*/  _sName: string = null;
		/**@protected*/  _pMesh: IMesh = null;
		/**@protected*/  _pSkin: ISkin = null;
		/**@protected*/  _pBoundingBox: IRect3d = null;
		/**@protected*/  _pBoundingSphere: ISphere = null;

		inline get boundingBox(): IRect3d { return this._pBoundingBox; }
		inline get boundingSphere(): ISphere { return this._pBoundingSphere; }
		inline get data(): IRenderData { return this._pRenderData; }
		inline get skin(): ISkin { return this._pSkin; }
		inline get name(): string { return this._sName; }
		inline get mesh(): IMesh { return this._pMesh; }


		constructor (pMesh: IMesh, pRenderData: IRenderData, sName: string = null) {
			super();
			this.setup(pMesh, pRenderData, sName);
		}

		/**@protected*/  setup(pMesh: IMesh, pRenderData: IRenderData, sName: string): void {
			logger.setSourceLocation( "MeshSubset.ts" , 38 ); logger.assert(this._pMesh === null, "mesh subset already prepared"); ;

			this._pMesh = pMesh;
			this._pRenderData = pRenderData;
			this._sName = sName;

			super._setup(pMesh.getEngine().getRenderer());
		}

		createBoundingBox(): bool {
			var pVertexData: IVertexData;
			var pNewBoundingBox: IRect3d;

			pNewBoundingBox = new geometry.Rect3d();
			pVertexData = this.data._getData(DeclUsages.POSITION);

			if(isNull(pVertexData))
				return false;

			if(geometry.computeBoundingBox(pVertexData, pNewBoundingBox) == false)
				return false;

			this._pBoundingBox = pNewBoundingBox;

			return true;
		}

		deleteBoundingBox(): bool {
			this._pBoundingBox = null;

			return true;
		}

		showBoundingBox(): bool {
			var pMaterial: IMaterial;
			var iData:  number ;
			var iCurrentIndexSet:  number ;
			var pPoints:  number [],
				pIndexes:  number  [];

			if (isNull(this._pBoundingBox)) {
				return false;
			}

			pPoints = new Array();
			pIndexes = new Array();

			geometry.computeDataForCascadeBoundingBox(this._pBoundingBox, pPoints, pIndexes, 10.0);

			iCurrentIndexSet = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingBox")) {
				this.data.addIndexSet(true, EPrimitiveTypes.LINELIST, ".BoundingBox");

				iData = this.data.allocateData(
						[VE_FLOAT3(DeclUsages.POSITION)],
						new Float32Array(pPoints));

				this.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));

				this.data.index(iData,DeclUsages.INDEX0);

				this.applyFlexMaterial(".MaterialBoundingBox");

//TODO: некорректно задавать так boundingBox, т.к. надо рендерится со своим рендер методом, а его никто не выбирает. 
				pMaterial = this.getFlexMaterial(".MaterialBoundingBox");
				pMaterial.emissive = new Color(0.0, 0.0, 1.0, 1.0);
				pMaterial.diffuse  = new Color(0.0, 0.0, 1.0, 1.0);
			}
			else {
				this.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints),DeclUsages.POSITION);
			}

			this.data.setRenderable(this.data.getIndexSet(), true);
			this.data.selectIndexSet(iCurrentIndexSet);

			return true;
		}

		hideBoundingBox(): bool {
			var iCurrentIndexSet:  number ;
			iCurrentIndexSet = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingBox")) {
				return false;
			}
			else {
				this.data.setRenderable(this.data.getIndexSet(), false);
			}

			return this.data.selectIndexSet(iCurrentIndexSet);
		}

		createBoundingSphere(): bool {
			var pVertexData: IVertexData;
			var pNewBoundingSphere: ISphere;

			pNewBoundingSphere = new geometry.Sphere();
			pVertexData = this.data._getData(DeclUsages.POSITION);

			if(!pVertexData) {
				return false;
			}

			if(!geometry.computeBoundingSphere(pVertexData, pNewBoundingSphere, false, this._pBoundingBox)) {
				return false;
			}

			this._pBoundingSphere = pNewBoundingSphere;

			return true;
		}


		deleteBoundingSphere(): bool {
			this._pBoundingSphere = null;
			return true;
		}



		showBoundingSphere(): bool {
			var pMaterial: IMaterial;
			var iData:  number ;
			var iCurrentIndexSet:  number ;
			var pPoints:  number [], pIndexes:  number [];

			if(isNull(this._pBoundingSphere)) {
				return false;
			}

			pPoints = new Array();
			pIndexes = new Array();
			geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere, pPoints, pIndexes);

			iCurrentIndexSet = this.data.getIndexSet();
			if(!this.data.selectIndexSet(".BoundingSphere")) {
				this.data.addIndexSet(false, EPrimitiveTypes.LINELIST, ".BoundingSphere");

				iData = this.data.allocateData([VE_FLOAT3(DeclUsages.POSITION)], new Float32Array(pPoints));

				this.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));
				this.data.index(iData,DeclUsages.INDEX0);

				this.applyFlexMaterial(".MaterialBoundingSphere");

				pMaterial = this.getFlexMaterial(".MaterialBoundingSphere");
				pMaterial.emissive = new Color(0.0, 0.0, 1.0, 1.0);
				pMaterial.diffuse  = new Color(0.0, 0.0, 1.0, 1.0);
			}
			else {
				this.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
			}

			this.data.setRenderable(this.data.getIndexSet(), true);
			this.data.selectIndexSet(iCurrentIndexSet);

			return true;
		}

		hideBoundingSphere(): bool{
			var iCurrentIndexSet:  number  = this.data.getIndexSet();

			if(!this.data.selectIndexSet(".BoundingSphere")) {
				return false;
			}
			else {
				this.data.setRenderable(this.data.getIndexSet(), false);
			}

			return this.data.selectIndexSet(iCurrentIndexSet);
		}


		computeNormals () {
//TODO: calc normals
		}

		computeTangents () {
//TODO: compute normals
		}

		computeBinormals () {
//TODO: calc binormals
		}

		isSkinned() {
		    return this._pSkin !== null;
		}

		getSkin() {
		    return this._pSkin;
		}

		applyFlexMaterial(sMaterial: string, pMaterialData: IMaterial = null): bool {
		    if (this._pMesh.addFlexMaterial(sMaterial, pMaterialData)) {
		        return this.setFlexMaterial(sMaterial);
		    }

		    return false;
		}

		getFlexMaterial(csName: string): IMaterial;
		getFlexMaterial(iMaterial:  number ): IMaterial;
		getFlexMaterial(iMaterial): IMaterial {
		    return this._pMesh.getFlexMaterial(< number >iMaterial);
		}

		hasFlexMaterial (): bool {
		    return this._pRenderData.hasSemantics(DeclUsages.MATERIAL);
		}

		setFlexMaterial (iMaterial:  number ): bool;
		setFlexMaterial (csName: string): bool;
		setFlexMaterial (iMaterial): bool {
		    var pMaterial: IMaterial = this._pMesh.getFlexMaterial(iMaterial);

		    if (isNull(pMaterial)) {
		    	logger.setSourceLocation( "MeshSubset.ts" , 256 ); logger.warning("could not find material <" + iMaterial + "> in sub mesh <" + this.name + ">"); ;
		        return false;
		    }

		    var pRenderData: IRenderData = this._pRenderData;
		    var pIndexData: IBufferData = pRenderData.getIndices();
		    var pMatFlow: IDataFlow = pRenderData._getFlow(DeclUsages.MATERIAL);
		    var eSemantics: string = DeclUsages.INDEX10;
		    var pIndexDecl: IVertexDeclaration, pFloatArray: Float32Array;
		    var iMatFlow:  number ;
			var iMat:  number  = (<IFlexMaterial>pMaterial).data.byteOffset;

		    if (pMatFlow) {
		        iMatFlow = pMatFlow.flow;
		        eSemantics = pMatFlow.mapper.semantics;
		        pIndexData = pMatFlow.mapper.data;

		        pRenderData._addData((<IFlexMaterial>pMaterial).data, iMatFlow);

		        return pRenderData.index(iMat, eSemantics, true);
		    }

		    pIndexDecl = createVertexDeclaration([VE_FLOAT(eSemantics)]);
		    pFloatArray = new Float32Array((<IVertexData>pIndexData).length);
		    iMatFlow = pRenderData._addData((<IFlexMaterial>pMaterial).data);

		    logger.setSourceLocation( "MeshSubset.ts" , 282 ); logger.assert(iMatFlow >= 0, "cannot add data flow with material for mesh subsset"); ;

		    if (!pRenderData.allocateIndex(pIndexDecl, pFloatArray)) {
		        logger.setSourceLocation( "MeshSubset.ts" , 285 ); logger.warning("cannot allocate index for material!!!"); ;
		        return false;
		    }

		    return pRenderData.index(iMat, eSemantics, true);
		}

		_draw (): void {
		    this._pRenderData._draw();
		}

		show(): void {
		    this.data.setRenderable(true);
		}

		hide(): void {
		    this.data.setRenderable(false);
		}


//исходим из того, что данные скина 1:1 соотносятся с вершинами.
		setSkin(pSkin: ISkin): bool {
		    var pPosData: IVertexData;
		    var pPositionFlow: IDataFlow;
		    var pMetaData: Float32Array;
//мета данные разметки
		    var pInfMetaData: IVertexData;
//адресс мета данных во флотах
		    var iInfMetaDataLoc:  number ;
//шаг мета данных во флотах
		    var iInfMetaDataStride:  number ;

/*
		     Получаем данные вершин, чтобы проложить в {W} компоненту адерсс мета информации,
		     о влиянии на данную вершины.
		     */


//получаем поток данных с вершиными
		    pPositionFlow = this.data._getFlow(DeclUsages.POSITION);
		    logger.setSourceLocation( "MeshSubset.ts" , 324 ); logger.assert(isDefAndNotNull(pPositionFlow), "skin require position with indices in mesh subset"); ;

		    pPosData = pPositionFlow.data;

//проверяем, что данные еще не подвязаны к другому Skin'у
		    if (pPosData.hasSemantics(DeclUsages.BLENDMETA)) {
//тоже самый skin?
		        if (pSkin.isAffect(pPosData)) {
		            this._pSkin = pSkin;
		            return true;
		        }

		        logger.setSourceLocation( "MeshSubset.ts" , 336 ); logger.error("mesh subset already has another skin"); ;
		        return false;
		    }

//проверяем, что текущий подмеш пренадлежит мешу, на который натягивается skin,
//или его клону.
		    logger.setSourceLocation( "MeshSubset.ts" , 343 ); logger.assert(this.data.buffer == pSkin.data, "can not bind to skin mesh subset that does not belong skin's mesh.");

//подвязывем скин, к данным с вершинами текущего подмеша.
//т.е. добавляем разметку в конец каждого пикселя
		    pSkin.attach(pPosData);

/*
		    //получаем данные разметки
		    pMetaData = <Float32Array>pPosData.getTypedData(DeclUsages.BLENDMETA);

		    //если по каким то причинам нет разметки...
		    debug_assert(isDefAndNotNull(pMetaData), "you must specify location for storage blending data");

		    //выставляем разметку мета данных вершин, так чтобы они адрессовали сразу на данные
		    pInfMetaData = pSkin.getInfluenceMetaData();
		    iInfMetaDataLoc = pInfMetaData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;
		    iInfMetaDataStride = pInfMetaData.stride / EDataTypeSizes.BYTES_PER_FLOAT;

		    for (var i: int = 0; i < pMetaData.length; ++ i) {
		        pMetaData[i] = iInfMetaDataLoc + i * iInfMetaDataStride;
		    }

		    //обновляем адреса мета данных вершин
		    pPosData.setData(pMetaData, DeclUsages.BLENDMETA);

		    //trace(this.data.toString());
		    this._pSkin = pSkin;*/


		    var pDeclaration: IVertexDeclaration = pPosData.getVertexDeclaration();
		    var pVEMeta: IVertexElement = pDeclaration.findElement(DeclUsages.BLENDMETA);
//if BLENDMETA not found
		    logger.setSourceLocation( "MeshSubset.ts" , 374 ); logger.assert(isDefAndNotNull(pVEMeta), "you must specify location for storage blending data"); ;

//read all data for acceleration
		    pMetaData = new Float32Array(pPosData.getData(0, pDeclaration.stride));

//выставляем разметку мета данных вершин, так чтобы они адрессовали сразу на данные
		    pInfMetaData = pSkin.getInfluenceMetaData();
		    iInfMetaDataLoc = pInfMetaData.byteOffset / EDataTypeSizes.BYTES_PER_FLOAT;
		    iInfMetaDataStride = pInfMetaData.stride / EDataTypeSizes.BYTES_PER_FLOAT;

		    var iCount:  number  = pMetaData.byteLength/pDeclaration.stride;
		    var iOffset:  number  = pVEMeta.offset/EDataTypeSizes.BYTES_PER_FLOAT;
		    var iStride:  number  = pDeclaration.stride/EDataTypeSizes.BYTES_PER_FLOAT;

		    for (var i:  number  = 0; i < iCount; ++ i) {
		        pMetaData[iOffset + i*iStride] = iInfMetaDataLoc + i * iInfMetaDataStride;
		    }

		    pPosData.setData(pMetaData, 0, pDeclaration.stride);

		    this._pSkin = pSkin;

		    return true;
		}
	}
}










module akra.model {

	class Mesh implements IMesh extends util.ReferenceCounter {
        private _sName: string;
        private _pFlexMaterials: IMaterial[] = null;
        private _pBuffer: IRenderDataCollection = null;
        private _pEngine: IEngine;
        private _eOptions:  number  = 0;
        private _pSkeleton: ISkeleton = null;
        private _pBoundingBox: IRect3d = null;
        private _pBoundingSphere: ISphere = null;
        private _pSubMeshes: IMeshSubset[] = [];
        private _bShadow: bool = false;

        inline get length():  number  {
            return this._pSubMeshes.length;
        }

        inline get flexMaterials(): IMaterial[] {
            return this._pFlexMaterials;
        }

        inline get name(): string{
            return this._sName;
        }

        inline get data(): IRenderDataCollection {
            return this._pBuffer;
        }

        inline get skeleton(): ISkeleton {
            return this._pSkeleton;
        }

        inline set skeleton(pSkeleton: ISkeleton){
            this._pSkeleton = pSkeleton;
        }

        inline get boundingBox(): IRect3d {
            if (isNull(this._pBoundingBox)) {
                if (!this.createBoundingBox()) {
                    logger.setSourceLocation( "model/Mesh.ts" , 66 ); logger.warning("could not compute bounding box fo mesh"); ;
                }
            }

            return this._pBoundingBox;
        }

        inline get boundingSphere(): ISphere {
            if (isNull(this._pBoundingSphere)) {
                if (!this.createBoundingSphere()) {
                    logger.setSourceLocation( "model/Mesh.ts" , 76 ); logger.warning("could not compute bounding sphere for mesh"); ;
                }
            }

            return this._pBoundingSphere;
        }

        constructor(pEngine: IEngine, eOptions:  number , sName: string, pDataBuffer: IRenderDataCollection) {
            super();

            this._sName = sName || null;
            this._pEngine = pEngine;
            this.setup(sName, eOptions, pDataBuffer);
        }

        setSkeleton(pSkeleton: ISkeleton): void {
            this.skeleton = pSkeleton;
        }

        getOptions():  number  {
            return this._eOptions;
        }

        getEngine(): IEngine {
            return this._pEngine;
        }

        _drawSubset(iSubset:  number ): void {
            this._pBuffer._draw(iSubset);
        }

        _draw(): void {
            for (var i:  number  = 0; i < this.length; i++) {
                this._pSubMeshes[i]._draw();
            };
        }

        isReadyForRender(): bool {
            for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                if (!this._pSubMeshes[i].isReadyForRender()) {
                    return false;
                }
            }

            return true;
        }

        private setup(sName: string, eOptions:  number , pDataCollection?: IRenderDataCollection): bool {
            logger.setSourceLocation( "model/Mesh.ts" , 124 ); logger.assert(this._pBuffer === null, "mesh already setuped."); ;

            if (isNull(pDataCollection)) {
                this._pBuffer = this._pEngine.createRenderDataCollection(eOptions);
            }
            else {
                logger.setSourceLocation( "model/Mesh.ts" , 131 ); logger.assert(pDataCollection.getEngine() === this.getEngine(), "you can not use a buffer with a different context");
                                                                        ;

                this._pBuffer = pDataCollection;
                eOptions |= pDataCollection.getOptions();
            }

            this._pBuffer.addRef();
            this._eOptions = eOptions || 0;
            this._sName = sName ||  "unknown" ;

            return true;
        }

        createSubset(sName: string, ePrimType: EPrimitiveTypes, eOptions:  number  = 0): IMeshSubset {
            var pData: IRenderData;
//TODO: modify options and create options for data dactory.
            pData = this._pBuffer.getEmptyRenderData(ePrimType, eOptions);
            pData.addRef();

            if (isNull(pData)) {
                return null;
            }

            return this.appendSubset(sName, pData);
        }

        appendSubset(sName: string, pData: IRenderData): IMeshSubset {
            logger.setSourceLocation( "model/Mesh.ts" , 158 ); logger.assert(pData.buffer === this._pBuffer, "invalid data used"); ;

            var pSubMesh: IMeshSubset = new MeshSubset(this, pData, sName);
            this._pSubMeshes.push(pSubMesh);

            this.connect(pSubMesh,  "shadow" ,  "shadow" , EEventTypes.UNICAST);

            return pSubMesh;
        }

        replaceFlexMaterials(pFlexMaterials: IMaterial[]): void {
            this._pFlexMaterials = pFlexMaterials;
        }

        freeSubset(sName: string): bool {
            logger.setSourceLocation( "model/Mesh.ts" , 173 ); logger.error("Метод freeSubset не реализован"); ;
            return false;
        }

        getFlexMaterial(iMaterial:  number ): IMaterial;
        getFlexMaterial(sName: string): IMaterial;
        getFlexMaterial(arg) {
            if (!this._pFlexMaterials) {
                return null;
            }

            if (typeof arguments[0] === 'number') {
                return this._pFlexMaterials[arguments[0]] || null;
            }
            else {
                for (var i = 0, pMaterials = this._pFlexMaterials; i < pMaterials.length; ++ i) {
                    if (pMaterials[i].name === <string>arguments[0]) {
                        return pMaterials[i];
                    }
                }
            }

            return null;
        }

        addFlexMaterial(sName: string = 'unknown', pMaterialData: IMaterial = null): bool {
            var pMaterial: IMaterial;
            var pMaterialId:  number ;

            logger.setSourceLocation( "model/Mesh.ts" , 202 ); logger.assert(arguments.length < 7, "only base material supported now..."); ;
//debug_assert(this.getFlexMaterial(sName) === null, 'material with name <' + sName + '> already exists');

            pMaterial = this.getFlexMaterial(sName);

            if (pMaterial) {
                if (pMaterialData) {
                   pMaterial.set(pMaterialData);
                }
                return true;
            }

            if (!this._pFlexMaterials) {
                this._pFlexMaterials = [];
            }

            pMaterialId = this._pFlexMaterials.length;
            pMaterial = material._createFlex(
                sName,
                this._pBuffer._allocateData(material.VERTEX_DECL, null)
            );

            if (!pMaterialData) {
                pMaterialData = material.create(null, material.DEFAULT)
            }

            pMaterial.set(pMaterialData);
//pMaterial.id = pMaterialId;
            this._pFlexMaterials.push(pMaterial);

            return true;
        }

        setFlexMaterial(iMaterial:  number ): bool;
        setFlexMaterial(csName: string): bool;
        setFlexMaterial(iMaterial): bool {
            var bResult: bool = true;
            for (var i:  number  = 0; i < this.length; ++ i) {
                if (!this._pSubMeshes[i].setFlexMaterial(< number >iMaterial)) {
                    logger.setSourceLocation( "model/Mesh.ts" , 242 ); logger.warning("cannot set material<" + iMaterial + "> for mesh<" + this.name + "> subset<" + this._pSubMeshes[i].name + ">");
                                                                     ;
                    bResult = false;
                }
            }

            return bResult;
        }

        destroy(): void {
            this._pFlexMaterials = null;
            this._pSubMeshes = null;
/*this*/
            this._pBuffer.destroy(        );
        }

        getSubset(sName: string): IMeshSubset;
        getSubset(i:  number ): IMeshSubset;
        getSubset(i: any): IMeshSubset {
            if (isInt(arguments[0])) {
                return this._pSubMeshes[arguments[0]];
            }
            else {
                for (var i = 0; i < this.length; ++ i) {
                    if (this._pSubMeshes[i].name === <string>arguments[0]) {
                        return this._pSubMeshes[i];
                    }
                }
            }
            return null;
        }

        setSkin(pSkin: ISkin): void {
            for (var i = 0; i < this.length; ++ i) {
                this._pSubMeshes[i].setSkin(pSkin);
            };
        }

        createSkin(): ISkin {
            var pSkin: ISkin = createSkin(this);
            return pSkin;
        }

        clone(iCloneOptions:  number ): IMesh {
            var pClone: IMesh = null;
            var pRenderData: IRenderData;
            var pSubMesh: IMeshSubset;

            if (iCloneOptions & EMeshCloneOptions.SHARED_GEOMETRY) {
                pClone = this.getEngine().createMesh(this.name, this.getOptions(), this.data);

                for (var i = 0; i < this.length; ++ i) {
                    pRenderData = this._pSubMeshes[i].data;
                    pRenderData.addRef();
                    pClone.appendSubset(this._pSubMeshes[i].name, pRenderData);
                }

                pClone.replaceFlexMaterials(this.flexMaterials);

//trace('created clone', pClone);
            }
            else {
//TODO: clone mesh data.
            }

            if (iCloneOptions & EMeshCloneOptions.GEOMETRY_ONLY) {
                return pClone;
            }
            else {
//TODO: clone mesh shading
            }

            return pClone;
        }

        createAndShowSubBoundingBox(): void {
            for(var i = 0; i < this.length; i++) {
                var pSubMesh: IMeshSubset = this.getSubset(i);
                pSubMesh.createBoundingBox();
                pSubMesh.showBoundingBox();
//console.log("SubMesh" + i);
            }
        }

        createAndShowSubBoundingSphere(): void {
            for(var i = 0; i < this.length; i ++) {
                var pSubMesh: IMeshSubset = this.getSubset(i);
                pSubMesh.createBoundingSphere();
                pSubMesh.showBoundingSphere();
//console.log("SubMesh" + i);
            }
        }

        createBoundingBox(): bool {
            var pVertexData: IVertexData;
            var pSubMesh: IMeshSubset;
            var pNewBoundingBox: IRect3d;
            var pTempBoundingBox: IRect3d;
            var i:  number ;

            pNewBoundingBox = new geometry.Rect3d();
            pTempBoundingBox = new geometry.Rect3d();

            pSubMesh = this.getSubset(0);
            pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

            if(isNull(pVertexData)) {
                return false;

            }

            if(geometry.computeBoundingBox(pVertexData, pNewBoundingBox)== false)
                return false;

            if (pSubMesh.isSkinned()) {
                pNewBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                pNewBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
            }

            for(i = 1; i < this.length; i++) {

                pSubMesh = this.getSubset(i);
                pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);
//trace(pSubMesh.name);

                if(!pVertexData) {
                    return false;
                }

                if(geometry.computeBoundingBox(pVertexData, pTempBoundingBox) == false) {
                    return false;
                }

//trace('>>> before box >>');
                if (pSubMesh.isSkinned()) {
//trace('calc skinned box');
                    pTempBoundingBox.transform(pSubMesh.skin.getBindMatrix());
                    pTempBoundingBox.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
                }
// trace('<<< after box <<');

                pNewBoundingBox.x0 = Math.min(pNewBoundingBox.x0, pTempBoundingBox.x0);
                pNewBoundingBox.y0 = Math.min(pNewBoundingBox.y0, pTempBoundingBox.y0);
                pNewBoundingBox.z0 = Math.min(pNewBoundingBox.z0, pTempBoundingBox.z0);

                pNewBoundingBox.x1 = Math.max(pNewBoundingBox.x1, pTempBoundingBox.x1);
                pNewBoundingBox.y1 = Math.max(pNewBoundingBox.y1, pTempBoundingBox.y1);
                pNewBoundingBox.z1 = Math.max(pNewBoundingBox.z1, pTempBoundingBox.z1);
            }

            this._pBoundingBox = pNewBoundingBox;
            return true;
        }

        deleteBoundingBox(): bool {
            this._pBoundingBox = null;
            return true;
        }

        showBoundingBox(): bool {
            var pSubMesh: IMeshSubset;
            var pMaterial: IMaterial;
            var iData:  number ;
            var pPoints:  number [], pIndexes:  number [];

            if(isNull(this._pBoundingBox)) {
                return false;
            }

            pPoints = new Array();
            pIndexes = new Array();

            geometry.computeDataForCascadeBoundingBox(this._pBoundingBox,pPoints,pIndexes,0.1);

            pSubMesh = this.getSubset(".BoundingBox");

            if(!pSubMesh) {
                pSubMesh = this.createSubset(".BoundingBox", EPrimitiveTypes.LINELIST, EHardwareBufferFlags.STATIC);

                if(isNull(pSubMesh)) {
                    return false;
                }

                iData = pSubMesh.data.allocateData([VE_FLOAT3(DeclUsages.POSITION)], new Float32Array(pPoints));

                pSubMesh.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));

                pSubMesh.data.index(iData, DeclUsages.INDEX0);

// pSubMesh.applyFlexMaterial(".MaterialBoundingBox");
/*getFlexMaterial(".MaterialBoundingBox");*/
                pMaterial = pSubMesh.material;
                pMaterial.emissive = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.diffuse = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.ambient = new Color(1.0, 1.0, 1.0, 1.0);
                pMaterial.specular = new Color(1.0, 1.0, 1.0, 1.0);

                pSubMesh.effect.addComponent("akra.system.mesh_texture");
                pSubMesh.effect.addComponent("akra.system.prepareForDeferredShading");
            }
            else {
                pSubMesh.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints), DeclUsages.POSITION);
            }

            pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
            return true;
        }

        hideBoundingBox(): bool {
            var pSubMesh: IMeshSubset = this.getSubset(".BoundingBox");

            if(!pSubMesh) {
                return false;
            }

//TODO: hide bounding box!!
            return false;
//return pSubMesh.data.setRenderable(this.data.getIndexSet(), false);
        }

        createBoundingSphere(): bool {
            var pVertexData: IVertexData;
            var pSubMesh: IMeshSubset;
            var pNewBoundingSphere: ISphere,
                pTempBoundingSphere: ISphere;
            var i:  number ;

            pNewBoundingSphere = new geometry.Sphere();
            pTempBoundingSphere = new geometry.Sphere();


            pSubMesh = this.getSubset(0);
            pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

            if(!pVertexData) {
                return false;
            }


            if(geometry.computeBoundingSphere(pVertexData,pNewBoundingSphere) == false) {
                return false;
            }

            if (pSubMesh.isSkinned()) {
                pNewBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                pNewBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
            }

            for(i = 1; i < this.length; i++) {

                pSubMesh = this.getSubset(i);
                pVertexData = pSubMesh.data._getData(DeclUsages.POSITION);

                if(isNull(pVertexData))
                    return false;

                if(geometry.computeBoundingSphere(pVertexData, pTempBoundingSphere)== false)
                    return false;


                if (pSubMesh.isSkinned()) {
                    pTempBoundingSphere.transform(pSubMesh.skin.getBindMatrix());
                    pTempBoundingSphere.transform(pSubMesh.skin.getBoneOffsetMatrix(pSubMesh.skin.skeleton.root.boneName));
// trace(pTempBoundingSphere.fRadius, '<<<');
                }


                geometry.computeGeneralizingSphere(pNewBoundingSphere, pTempBoundingSphere)
            }
// trace(pNewBoundingSphere, '<<<<<<<<<<<<<<<<<<<<<<<<<')
            this._pBoundingSphere = pNewBoundingSphere;

            return true;
        }

        deleteBoundingSphere(): bool {
            this._pBoundingSphere = null;
            return true;
        }

        showBoundingSphere(): bool {
            var pSubMesh : IMeshSubset, pMaterial: IMaterial;
            var iData:  number ;
            var pPoints:  number [], pIndexes:  number [];

            if(!this._pBoundingSphere) {
                return false;
            }

            pPoints = new Array();
            pIndexes = new Array();

            geometry.computeDataForCascadeBoundingSphere(this._pBoundingSphere,pPoints,pIndexes);

            pSubMesh = this.getSubset(".BoundingSphere");

            if(!pSubMesh) {
                pSubMesh = this.createSubset(".BoundingSphere", EPrimitiveTypes.LINELIST, EHardwareBufferFlags.STATIC);

                if(isNull(pSubMesh))
                    return false;

                iData=pSubMesh.data.allocateData(
                    [VE_FLOAT3(DeclUsages.POSITION)],
                    new Float32Array(pPoints));

                pSubMesh.data.allocateIndex([VE_FLOAT(DeclUsages.INDEX0)], new Float32Array(pIndexes));
                pSubMesh.data.index(iData, DeclUsages.INDEX0);

// pSubMesh.applyFlexMaterial(".MaterialBoundingSphere");
// //pSubMesh.getFlexMaterial(".MaterialBoundingSphere");
                pMaterial = pSubMesh.material;
                pMaterial.emissive = new Color(1.0, 0.0, 0.0, 1.0);
                pMaterial.diffuse  = new Color(1.0, 0.0, 0.0, 1.0);
                pMaterial.ambient  = new Color(1.0, 0.0, 0.0, 1.0);
                pMaterial.specular = new Color(1.0, 0.0, 0.0, 1.0);
            }
            else {
                pSubMesh.data._getData(DeclUsages.POSITION).setData(new Float32Array(pPoints),DeclUsages.POSITION);
            }

            pSubMesh.data.setRenderable(pSubMesh.data.getIndexSet(), true);
            return true;
        }

        hideBoundingSphere(): bool {
            var pSubMesh: IMeshSubset;

            pSubMesh = this.getSubset(".BoundingSphere");

            if(!pSubMesh) {
                return false;
            }

//TODO: hide bounding sphere
            return false;
//return pSubMeshs.data.setRenderable(this.data.getIndexSet(),false);
        }

        inline hasShadow(): bool {
            return this._bShadow;
        }

        setShadow(bValue: bool = true): void {
            for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                this._pSubMeshes[i].setShadow(bValue);
            }
        }

        toSceneModel(pParent: ISceneNode, sName: string = null): ISceneModel {
            if (isNull(pParent)) {
                return null;
            }

            var pSceneModel: ISceneModel = pParent.scene.createModel(sName);

            if (!pSceneModel.create()) {
                return null;
            }

            pSceneModel.mesh = this;
            pSceneModel.attachToParent(pParent);

            return pSceneModel;
        }

        /**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return Mesh._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
         shadow(pSubMesh: IMeshSubset, bShadow: bool): void {

            this._bShadow = bShadow;

            if (!bShadow) {
                for (var i:  number  = 0; i < this._pSubMeshes.length; ++ i) {
                    if (this._pSubMeshes[i].hasShadow()) {
                        this._bShadow = true;
                        break;
                    }
                }
            }

            this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).shadow; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pSubMesh, bShadow) : _broadcast[i].listener (_recivier, pSubMesh, bShadow) ; } } ;
        }

	}

    export function createMesh(pEngine: IEngine, sName: string = null, eOptions:  number  = 0, pDataBuffer: IRenderDataCollection = null): IMesh {
        return new Mesh(pEngine, eOptions, sName, pDataBuffer);
    }
}










module akra.scene {
	export class SceneModel extends SceneObject implements ISceneModel {
		private _pMesh: IMesh;

		constructor (pScene: IScene3d) {
			super(pScene, EEntityTypes.MODEL);
		}

		inline get mesh(): IMesh {
			return this._pMesh;
		}

		inline set mesh(pMesh: IMesh) {
			if (!isNull(this._pMesh)) {
				this.accessLocalBounds().set(0.01, 0.01, 0.01);
				this._pMesh = null;
			}

			if (!isNull(pMesh)) {
				this.accessLocalBounds().set(pMesh.boundingBox);
				this._pMesh = pMesh;
			}
		}

		inline get totalRenderable():  number  {
			return isNull(this._pMesh)? 0: this._pMesh.length;
		}

		inline getRenderable(i:  number  = 0): IRenderableObject {
			return this._pMesh.getSubset(i);
		}

		inline hasShadow(): bool {
			return this._pMesh.hasShadow();
		}

		inline setShadow(bValue: bool = true): void {
			this._pMesh.setShadow(bValue);
		}

		toString(isRecursive: bool = false, iDepth:  number  = 0): string {

		    if (!isRecursive) {
		        var sData: string = "<model" + (this.name? " " + this.name: "") + "(" + String(isNull(this._pMesh)) + ")" +  '>';

		        if (!isNull(this._pMesh)) {
		            sData += "( " + this._pMesh.name + " )";
		        }

		        return sData;
		    }

		    return super.toString(isRecursive, iDepth);

		};

	}

	export inline function isModel(pEntity: IEntity): bool {
		return pEntity.type === EEntityTypes.MODEL;
	}
}







module akra.scene {

	export class Scene3d implements IScene3d {
		/**@protected*/  _pRootNode: ISceneNode;
		/**@protected*/  _pSceneManager: ISceneManager;
// protected _pNodeList: ISceneNode[];
// protected _pObjectList: ISceneObject[];

		/**@protected*/  _pDisplayLists: IDisplayList[] = [];
		/**@protected*/  _pDisplayListsCount:  number  = 0;
		/**@protected*/  _isUpdated: bool = false;

		inline get type(): ESceneTypes {
			return ESceneTypes.TYPE_3D;
		}

		inline get totalDL():  number  {
			return this._pDisplayListsCount;
		}

		constructor (pSceneManager: ISceneManager) {
			this._pSceneManager = pSceneManager;
			this._pRootNode = this.createNode("root-node");
			this._pRootNode.create();

			var i:  number ;

// this._pNodeList = [];
// this._pObjectList = [];

//TODO передача пользовательских параметров в OcTree

// i = this.addDisplayList(new OcTree);
// debug_assert(i == DL_DEFAULT, "invalid default list index");

//TODO передача пользовательских параметров в LightGraph

// i = this.addDisplayList(new LightGraph);
// debug_assert(i == DL_LIGHTING, "invalid lighting list index");

		}

		inline getManager(): ISceneManager{
			return this._pSceneManager;
		}

		inline isUpdated(): bool {
			return this._isUpdated;
		}

		inline getRootNode(): ISceneNode {
			return this._pRootNode;
		}

		recursivePreUpdate(): void {
			this._isUpdated = false;
			this._pRootNode.recursivePreUpdate();
		}

		recursiveUpdate(): void {
			this._isUpdated = this._pRootNode.recursiveUpdate();
		}

		updateCamera(): bool {
			return false;
		}

		updateScene(): bool {
			return false;
		}



		createObject(sName: string = null): ISceneObject {
			var pNode: ISceneNode = new SceneObject(this);

			if (!pNode.create()) {
				logger.setSourceLocation( "Scene3d.ts" , 95 ); logger.error("cannot create scene node.."); ;
				return null;
			}

			return <ISceneObject>this.setupNode(pNode, sName);
		}



		createNode(sName: string = null): ISceneNode {
			var pNode: ISceneNode = new SceneNode(this);

			if (!pNode.create()) {
				logger.setSourceLocation( "Scene3d.ts" , 108 ); logger.error("cannot create scene node.."); ;
				return null;
			}

			return this.setupNode(pNode, sName);
		}

		createModel(sName: string = null): ISceneModel {
			var pNode: ISceneModel = new SceneModel(this);

			if (!pNode.create()) {
				logger.setSourceLocation( "Scene3d.ts" , 119 ); logger.error("cannot create model.."); ;
				return null;
			}

			return <ISceneModel>this.setupNode(pNode, sName);
		}

		createCamera(sName: string = null): ICamera {
			var pCamera: ICamera = new objects.Camera(this);

			if (!pCamera.create()) {
				logger.setSourceLocation( "Scene3d.ts" , 130 ); logger.error("cannot create camera.."); ;
				return null;
			}

			return <ICamera>this.setupNode(pCamera, sName);
		}

		createLightPoint(sName: string = null): ILightPoint {
			return null;
		}

		createSprite(sName: string = null): ISprite {
			return null;
		}

		createJoint(sName: string = null): IJoint {
			return <IJoint>this.setupNode(new Joint(this), sName);
		}

		createText3d(sName: string = null): IText3d {
			return null;
		}

// inline getAllNodes(): ISceneNode[] {
// 	return this._pNodeList;
// }

// inline getAllObjects(): ISceneObject[] {
// 	return this._pObjectList;
// }

		inline getDisplayList(i:  number ): IDisplayList {
			logger.setSourceLocation( "Scene3d.ts" , 162 ); logger.assert(isDefAndNotNull(this._pDisplayLists[i]), "display list not defined"); ;
			return this._pDisplayLists[i];
		}

		getDisplayListByName(csName: string):  number  {
			for (var i:  number  = 0; i < this._pDisplayLists.length; ++ i) {
				if (this._pDisplayLists[i].name === csName) {
					return i;
				}
			}

			return -1;
		}


// _findObjects(pCamera: ICamera, csList: string = null): ISceneObject[] {
// 	var pList: IDisplayList = this._pDisplayListMap[csList || DEFAULT_DLIST];

// 	debug_assert(!isNull(pList), "display list not founded.");

// 	return pList.findObjects(pCamera);
// }

		_render(pCamera: ICamera, pViewport: IViewport): void {

		}

		private setupNode(pNode: ISceneNode, sName: string = null): ISceneNode {
			pNode.name = sName;

			this.connect(pNode,  "attached" ,  "nodeAttachment" , EEventTypes.UNICAST);
			this.connect(pNode,  "detached" ,  "nodeDetachment" , EEventTypes.UNICAST);

			return pNode;
		}

		delDisplayList(index:  number ): bool {
			var pLists: IDisplayList[] = this._pDisplayLists;

			for (var i:  number  = 0; i < pLists.length; ++ i) {
				if (i === index && isDefAndNotNull(pLists[i])) {
					pLists[i] = null;
					this._pDisplayListsCount --;

					this.displayListRemoved(pLists[i], i);

					return true;
				}
			};

			return false;
		}

		inline addDisplayList(pList: IDisplayList):  number  {
			logger.setSourceLocation( "Scene3d.ts" , 217 ); logger.assert(isDefAndNotNull(this.getDisplayListByName(pList.name)), "DL with name <" + pList.name + "> already exists");
                                                       ;


			var pLists: IDisplayList[] = this._pDisplayLists;
			var iIndex:  number  = this._pDisplayLists.length;

			for (var i:  number  = 0; i < pLists.length; ++ i) {
				if (pLists[i] === null) {
					pLists[i] = pList;
					iIndex = i;
					break;
				}
			};

			if (iIndex == this._pDisplayLists.length) {
				this._pDisplayLists.push(pList);
			}

			pList._setup(this);

			this.displayListAdded(pList, iIndex);

			this._pDisplayListsCount ++;

			return iIndex;
		}

		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return Scene3d._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;

		nodeAttachment (pNode: ISceneNode): void {
// this._pNodeList.push(pNode);

// if (SceneObject.isSceneObject(pNode)) {
// 	this._pObjectList.push(<ISceneObject>pNode);
// }
// console.warn("------>here");
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).nodeAttachment; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pNode) : _broadcast[i].listener (_recivier, pNode) ; } } ;
		}

		nodeDetachment (pNode: ISceneNode): void {

// for (var i: int = 0; i < this._pNodeList.length; ++ i) {
// 	if (pNode == this._pNodeList[i]) {
// 		this._pNodeList.splice(i, 1);
// 		break;
// 	}
// };

// if (SceneObject.isSceneObject(pNode)) {
// 	for (var i: int = 0; i < this._pObjectList.length; ++ i) {
// 		if (<ISceneObject>pNode == this._pObjectList[i]) {
// 			this._pObjectList.splice(i, 1);
// 			break;
// 		}
// 	};
// }


			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).nodeDetachment; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pNode) : _broadcast[i].listener (_recivier, pNode) ; } } ;
		}


		displayListAdded (list, index): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).displayListAdded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, list, index) : _broadcast[i].listener (_recivier, list, index) ; } } } ; ;
		displayListRemoved (list, index): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).displayListRemoved; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, list, index) : _broadcast[i].listener (_recivier, list, index) ; } } } ; ;

// BROADCAST(nodeAttachment, CALL(pNode));
// BROADCAST(nodeDetachment, CALL(pNode));
	}
}



module akra.scene {
    export class SceneManager implements ISceneManager {
        private _pEngine: IEngine = null;
        private _pSceneList: IScene[] = [];

        private _fUpdateTimeCount:  number  = 0.;
        private _fMillisecondsPerTick:  number  = 0.0333;


        constructor (pEngine: IEngine) {
            this._pEngine = pEngine;
        }

        getEngine(): IEngine{
            return this._pEngine;
        }

        update(): void {
            var isSceneUpdated: bool = false;
// add the real time elapsed to our
// internal delay counter
            this._fUpdateTimeCount += this._pEngine.getTimer().elapsedTime;
// is there an update ready to happen?

            var fUpdateTime:  number  = this._fUpdateTimeCount;

            while (this._fUpdateTimeCount > this._fMillisecondsPerTick) {
// update the scene
                this.notifyUpdateScene();

// subtract the time interval
// emulated with each tick
                this._fUpdateTimeCount -= this._fMillisecondsPerTick;
            }

            if (fUpdateTime !== this._fUpdateTimeCount) {
                this.notifyPreUpdateScene();
            }
        }

        notifyUpdateScene(): void {

// update the scene attached to the root node
            for (var i = 0; i < this._pSceneList.length; ++ i) {
                var pScene: IScene = this._pSceneList[i];

                if (pScene.type != ESceneTypes.TYPE_3D) {
                    continue;
                }

                (<IScene3d>pScene).recursiveUpdate();
            }
        }

        notifyPreUpdateScene(): void {
            for (var i = 0; i < this._pSceneList.length; ++ i) {
                var pScene: IScene = this._pSceneList[i];

                if (pScene.type != ESceneTypes.TYPE_3D) {
                    continue;
                }

                (<IScene3d>pScene).recursivePreUpdate();
            }
        }

        createScene3D(): IScene3d {
            var pScene: IScene3d = new Scene3d(this);
            this._pSceneList.push(pScene);

            return pScene;
        }

        createScene2D(): IScene2d {
            return null;
        }

        getScene3D(iScene:  number  = 0): IScene3d {
            var pScene: IScene;

            if (iScene === 0 && this._pSceneList.length === 0) {
                this.createScene3D();
                logger.setSourceLocation( "scene/SceneManager.ts" , 94 ); logger.log("Default scene automatically created."); ;
            }

            pScene = this._pSceneList[iScene];

            if (pScene && pScene.type === ESceneTypes.TYPE_3D) {
                return <IScene3d>pScene;
            }

            return null;
        }

        getScene2D(IScene?:  number ): IScene2d {
            var pScene: IScene = this._pSceneList[IScene];

            if (pScene && pScene.type === ESceneTypes.TYPE_2D) {
                return pScene;
            }

            return null;
        }

        getScene(IScene?:  number , eType?: ESceneTypes): IScene {
            return this._pSceneList[IScene] || null;
        }


        initialize(): bool {
//this.initText2Dlayer();
            return true;
        }

        destroy(): void {

        }
    }
}





/** @inline */
/*
        draw2DText(iX: int = 0, iY: int = 0, sText: string = "", pFont: IFont2d = new util.Font2d()): IString2d {
            return (new a.String2D(iX, iY, pFont, sStr, this.pTextLayer));
        }

        

        private initText2Dlayer(): void {
            var pCanvas: HTMLCanvasElement = this.pEngine.canvas;
            var x: int = findPosX(pCanvas);
            var y: int = findPosY(pCanvas);

            var pDiv: HTMLDivElement = <HTMLDivElement>document.createElement('div');
            var pStyle: CSSStyleDeclaration = pDiv.style;
            var pScreen: IScreenInfo = info.screen;

            var iBorder: int = 0;

            pDiv.setAttribute("id", "akra-canvas-overlay");

            pStyle.width = String(pScreen.width) + "px";
            pStyle.height = String(pScreen.height) + "px";
            
            if (pCanvas.style.border != "none") {
                iBorder = parseInt(pCanvas.style.border);
            }

            pStyle.position = 'absolute';
            pStyle.left = String(x) + 'px';
            pStyle.top = String(y) + 'px';

            pStyle.overflow = 'hidden';
            pStyle.whiteSpace = 'nowrap';

            if (pCanvas.style.zIndex) {
                pStyle.zIndex = pCanvas.style.zIndex + 1;
            }
            else {
                pStyle.zIndex = 2;
            }

            document.body.appendChild(pDiv);

            this.pTextLayer = pDiv;
        }
*/









module akra.util {

	export class UtilTimer implements IUtilTimer {
		private isTimerInitialized: bool = false;
		private isTimerStopped: bool = false;
		private fTicksPerSec:  number  = 0.;
		private iStopTime:  number  = 0;
		private iLastElapsedTime:  number  = 0;
		private iBaseTime:  number  = 0;

		get absoluteTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME);
		}

		get appTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_APP_TIME);
		}

		get elapsedTime():  number  {
			return this.execCommand(EUtilTimerCommands.TIMER_GET_ELAPSED_TIME);
		}

		start(): bool {
			return this.execCommand(EUtilTimerCommands.TIMER_START) === 0;
		}
        stop(): bool {
        	return this.execCommand(EUtilTimerCommands.TIMER_STOP) === 0;
        }

        reset(): bool {
        	return this.execCommand(EUtilTimerCommands.TIMER_RESET) === 0;
        }

        execCommand(eCommand: EUtilTimerCommands):  number  {
		    var fTime:  number  = 0.;
		    var fElapsedTime:  number  = 0.;
		    var iTime:  number ;

		    if (this.isTimerInitialized == false) {
		        this.isTimerInitialized = true;
		        this.fTicksPerSec = 1000;
		    }

// Get either the current time or the stop time, depending
// on whether we're stopped and what command was sent
		    if (this.iStopTime != 0 && eCommand != EUtilTimerCommands.TIMER_START &&
		    	eCommand != EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME) {
		        iTime = this.iStopTime;
		    }
		    else {
		        iTime = (new Date()).getTime();
		    }

// Return the elapsed time
		    if (eCommand == EUtilTimerCommands.TIMER_GET_ELAPSED_TIME) {
		        fElapsedTime = (iTime - this.iLastElapsedTime) / this.fTicksPerSec;
		        this.iLastElapsedTime = iTime;
		        return fElapsedTime;
		    }

// Return the current time
		    if (eCommand == EUtilTimerCommands.TIMER_GET_APP_TIME) {
		        var fAppTime = ( iTime - this.iBaseTime ) / this.fTicksPerSec;
		        return fAppTime;
		    }

// Reset the timer
		    if (eCommand == EUtilTimerCommands.TIMER_RESET) {
		        this.iBaseTime = iTime;
		        this.iLastElapsedTime = iTime;
		        this.iStopTime = 0;
		        this.isTimerStopped = false;
		        return 0;
		    }

// Start the timer
		    if (eCommand == EUtilTimerCommands.TIMER_START) {
		        if (this.isTimerStopped) {
		            this.iBaseTime += iTime - this.iStopTime;
		        }
		        this.iStopTime = 0;
		        this.iLastElapsedTime = iTime;
		        this.isTimerStopped = false;
		        return 0;
		    }

// Stop the timer
		    if (eCommand == EUtilTimerCommands.TIMER_STOP) {
		        if (!this.isTimerStopped) {
		            this.iStopTime = iTime;
		            this.iLastElapsedTime = iTime;
		            this.isTimerStopped = true;
		        }
		        return 0;
		    }

// Advance the timer by 1/10th second
		    if (eCommand == EUtilTimerCommands.TIMER_ADVANCE) {
		        this.iStopTime += this.fTicksPerSec / 10;
		        return 0;
		    }

		    if (eCommand == EUtilTimerCommands.TIMER_GET_ABSOLUTE_TIME) {
		        fTime = iTime / this.fTicksPerSec;
		        return  fTime;
		    }
// Invalid command specified
		    return -1;
        }

        static start(): UtilTimer {
        	var pTimer: UtilTimer = new UtilTimer;

        	if (pTimer.start()) {
        		return pTimer;
        	}

        	logger.setSourceLocation( "util/UtilTimer.ts" , 123 ); logger.error('cannot start util timer'); ;

        	return null;
        }
	}
}













// #ifndef IAFXEFFECT_TS
// #define IAFXEFFECT_TS

// #include "IResourcePoolItem.ts"

// module akra {
// 	export interface IAFXEffect extends IResourcePoolItem {

// 	}
// }

// #endif








// #ifndef IAFXEFFECT_TS
// #define IAFXEFFECT_TS

// #include "IResourcePoolItem.ts"

// module akra {
// 	export interface IAFXEffect extends IResourcePoolItem {

// 	}
// }

// #endif






















module akra.fx {
//Errors























































































    akra.logger.registerCode( 2201 ,
    						 "You trying to redefine system type: {typeName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2202 ,
    	 					 "You trying to redefine type: {typeName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2203 ,
    						 "You try to use unssuported type declaration. We implement it soon. In line: {line}.");
    akra.logger.registerCode( 2204 ,
    						 "You try to use unssuported expr: {exprName}. We implement it soon. In line: {line}.");
    akra.logger.registerCode( 2205 ,
    						 "Unknown variable name: {varName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2206 ,
    						 "Invalid arithmetic operation!. There no operator '{operator}'    						  for left-type '{leftTypeName}'     						 and right-type '{rightTypeName}'. In line: {line}.");
    akra.logger.registerCode( 2207 ,
    						 "Invalid arithmetic-assignment operation!.     						 There no operator {operator} for left-type '{leftTypeName}'     						 and right-type '{rightTypeName}'. In line: {line}.");
    akra.logger.registerCode( 2208 ,
    						 "Invalid assignment operation!. It`s no possible to do assignment     						 between left-type '{leftTypeName}'     						 and right-type '{rightTypeName}'. In line: {line}.");
    akra.logger.registerCode( 2209 ,
    						 "Invalid relational operation!. There no operator {operator}     						 for left-type '{leftTypeName}'     						 and right-type '{rightTypeName}'. In line: {line}.");
    akra.logger.registerCode( 2210 ,
    						 "Invalid logical operation!. In operator: {operator}.     						 Cannot convert type '{typeName}' to 'bool'. In line: {line}.");
    akra.logger.registerCode( 2211 ,
    						 "Invalid conditional expression!. Cannot convert type '{typeName}' to 'bool'.     						 In line: {line}.");
    akra.logger.registerCode( 2212 ,
    						 "Invalid conditional expression!. Type '{leftTypeName}' and type '{rightTypeName}'    						  are not equal. In line: {line}.");
	akra.logger.registerCode( 2213 ,
    						 "Invalid type cast!. Bad type casting. Only base types without usages are supported.     						 WebGL don`t support so casting. In line: {line}.");
	akra.logger.registerCode( 2214 ,
    						 "Invalid type cast!. Bad type for casting '{typeName}'.     						 WebGL support only base-type casting. In line: {line}.");
	akra.logger.registerCode( 2216 ,
    						 "Invalid unary expression!. Bad type: '{typeName}'     						 for operator '{opeator}'. In line: {line}.");
	akra.logger.registerCode( 2217 ,
    						 "Invalid postfix-array expression!.     						 Type of expression is not array: '{typeName}'. In line: {line}.");
	akra.logger.registerCode( 2218 ,
    						 "Invalid postfix-array expression!. Bad type of index: '{typeName}'.     						 Must be 'int'. In line: {line}.");
	akra.logger.registerCode( 2219 ,
    						 "Invalid postfix-point expression!. Type '{typeName}' has no field '{fieldName}'.     						 In line: {line}.");
	akra.logger.registerCode( 2220 ,
    						 "Invalid postfix-point expression!. Type '{typeName}' is not pointer.     						 In line: {line}.");
	akra.logger.registerCode( 2221 ,
    						 "Invalid postfix-arithmetic expression!. Bad type '{typeName}'     						 for operator {operator}. In line: {line}.");
	akra.logger.registerCode( 2222 ,
    						 "Invalid primary expression!. Bad type '{typeName}'.    						 It`s not pointer. In line: {line}.");
	akra.logger.registerCode( 2223 ,
    						 "Invalid function call expression!. Could not find function-signature     						 with name {funcName} and so types. In line: {line}.");
	akra.logger.registerCode( 2224 ,
    						 "Invalid constructor call!. There are not so type. In line: {line}.");
	akra.logger.registerCode( 2225 ,
    						 "Invalid constructor call!. Could not find constructor-signature     						 with name {typeName} and so types. In line: {line}.");
	akra.logger.registerCode( 2226 ,
    						 "Invalid compile expression!. Could not find function-signature     						 with name {funcName} and so types. In line: {line}.");
	akra.logger.registerCode( 2227 ,
    						 "You try to redefine function. With name {funcName}. In line: {line}.");
	akra.logger.registerCode( 2228 ,
							 "Bad type of while-condition. Must be 'bool' but it is '{typeName}'. 							 In line: {line}.");
	akra.logger.registerCode( 2229 ,
							 "Bad type of do-while-condition. Must be 'bool' but it is '{typeName}'. 							 In line: {line}.");
	akra.logger.registerCode( 2230 ,
							 "Bad type of if-condition. Must be 'bool' but it is '{typeName}'. 							 In line: {line}.");
	akra.logger.registerCode( 2231 ,
							 "Bad for-init expression. WebGL support only VariableDecl as for-init expression, 							 like \"int i = 0;\" or \"float i = 0.0;\". 							 In line: {line}.");
	akra.logger.registerCode( 2232 ,
							 "Bad for-init expression. WebGL support only VariableDecl as for-init expression, 							 like \"int i = 0;\" or \"float i = 0.0;\". 							 In line: {line}.");
	akra.logger.registerCode( 2233 ,
							 "Bad for-cond expression. WebGL does not support empty conditional expression in for-loop. 							 In line: {line}.");
	akra.logger.registerCode( 2238 ,
							 "Bad for-cond expression. WebGL support only relational expression for condition in for-loop. 							 In line: {line}.");
	akra.logger.registerCode( 2239 ,
							 "Bad for-step expression. WebGL does not support empty step expression. 							 In line: {line}.");
	akra.logger.registerCode( 2240 ,
							 "Bad for-step expression. WebGL does not support operator '{operator}' in step expression. 							 In line: {line}.");
	akra.logger.registerCode( 2241 ,
							 "Bad for-step expression. WebGL support only unary and assignment expression in for-step. 							 In line: {line}.");
	akra.logger.registerCode( 2235 ,
    						 "You trying to redefine system variable: {varName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2234 ,
    	 					 "You trying to redefine variable: {varName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2237 ,
    						 "You trying to redefine system function: {funcName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2236 ,
    	 					 "You trying to redefine function: {funcName}. In line: {line}. In column: {column}");
    akra.logger.registerCode( 2242 ,
    						 "You trying to add field to struct with name '{varName}', but it`s already in it.     						 In line: {line}. In column: {column}");
    akra.logger.registerCode( 2243 ,
    	 					 "You trying to add field to struct with semantic '{semanticName}',    	 					  but struct already has this semantic.    	 					  In line: {line}. In column: {column}");
    akra.logger.registerCode( 2244 ,
       					     "Bad variable name '{varName}'. Annotation already has variable with that name.    	 					  In line: {line}. In column: {column}");
    akra.logger.registerCode( 2245 ,
                             "Bad parameter '{varName}' in function '{funcName}'. Need default value.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2246 ,
                             "Bad function call. There are two or more call signatures for function '{funcName}'.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2247 ,
                             "Bad function definition. There are two or more different retturn type signatures for function '{funcName}'.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2248 ,
                             "Bad system function '{funcName}'. Already have this function.");
    akra.logger.registerCode( 2250 ,
                             "Bad type. Could not find type with name '{typeName}'.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2251 ,
                             "Bad type. We don`t support vector and matrix typename.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2252 ,
                             "Bad technique name '{techName}'. Effect already have technique with that name.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2253 ,
                             "Bad 'memof'-operator argument. Literal for its argument is bad idea.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2254 ,
                             "Bad 'memof'-operator argument. No buffer for argument.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2255 ,
                             "Bad function '{funcDef}'. It is recursion.");
    akra.logger.registerCode( 2256 ,
                             "Bad function '{funcDef}'. It use bad-function with recursion.");
    akra.logger.registerCode( 2257 ,
                             "Bad function '{funcDef}'. Can not use in vertex-shader.");
    akra.logger.registerCode( 2258 ,
                             "Bad function '{funcDef}'. Can not use in pixel-shader.");
    akra.logger.registerCode( 2259 ,
                             "Bad function with defenition '{funcDef}'. Can not be used as vertex-shader.");
    akra.logger.registerCode( 2260 ,
                             "Bad function with defenition '{funcDef}'. Can not be used as pixel-shader.");
    akra.logger.registerCode( 2261 ,
                             "Bad return stmt. You try to return something in void-function.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2262 ,
                             "Bad return stmt. You can not call empty return in non-void-function.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2263 ,
                             "Bad return stmt. Types of return expression and return type of function are not equal.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2264 ,
                             "Bad return type for '{funcName}'. Return type for function can not contain or be sampler/pointer.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2265 ,
                             "Bad parameter '{varName}' in function '{funcName}'. Bad usage.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2266 ,
                             "Bad variable with name 'Out'. It is sytem for used like return variable in shaders.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2267 ,
                             "Variable type is not writable.                               In line: {line}. In column: {column}");
    akra.logger.registerCode( 2268 ,
                             "Variable type is not readable.                               In line: {line}. In column: {column}");
    akra.logger.registerCode( 2269 ,
                             "Bad init expr for variable '{varName}'.                               In line: {line}. In column: {column}");
    akra.logger.registerCode( 2270 ,
                             "Don`t supported construction '[uint]' in sampler_state.                               In line: {line}. In column: {column}");
    akra.logger.registerCode( 2271 ,
                             "Incorrect texture setup for sampler.                               In line: {line}. In column: {column}");
    akra.logger.registerCode( 2272 ,
                             "Can not calculate padding for type '{typeName}'.");
    akra.logger.registerCode( 2273 ,
                             "Can not extract type '{typeName}'.");
    akra.logger.registerCode( 2274 ,
                             "Bad extract exrpression.");
    akra.logger.registerCode( 2275 ,
                             "Bad imports in technique '{techniqueName}'.");
    akra.logger.registerCode( 2276 ,
                             "You try use 'engine' variable in out of pass.                             In line: {line}. In column: {column}.");
    akra.logger.registerCode( 2277 ,
                             "You try to import not exuisted component '{componentName}'");



    akra.logger.registerCode( 2300 ,
                             "We don`t support array of pinters now. Only pointe to array.                              In line: {line}. In column: {column}");
    akra.logger.registerCode( 2301 ,
                             "We don`t support using complex shader input like functions params.                             Shader: '{funcName}'");
    akra.logger.registerCode( 2302 ,
                             "We don`t support using complex shader output like functions params.                             Shader: '{funcName}'");
    akra.logger.registerCode( 2303 ,
                             "We don`t support 'provide ... as' operator now.");


    function sourceLocationToString(pLocation: ISourceLocation): string {
        var sLocation:string = "[" + pLocation.file + ":" + pLocation.line.toString() + "]: ";
        return sLocation;
    }

    function syntaxErrorLogRoutine(pLogEntity: ILoggerEntity): void{
        var sPosition:string = sourceLocationToString(pLogEntity.location);
        var sError: string = "Code: " + pLogEntity.code.toString() + ". ";
        var pParseMessage: string[] = pLogEntity.message.split(/\{(\w+)\}/);
        var pInfo:any = pLogEntity.info;

        for(var i = 0; i < pParseMessage.length; i++){
            if(isDef(pInfo[pParseMessage[i]])){
                pParseMessage[i] = <string><any>pInfo[pParseMessage[i]];
            }
        }

        var sMessage = sPosition + sError + pParseMessage.join("");

        console["error"].call(console, sMessage);
    }

    akra.logger.setCodeFamilyRoutine("EffectSyntaxErrors", syntaxErrorLogRoutine, ELogLevel.ERROR);

    export interface IEffectErrorInfo{

    	typeName?: string;
        techName?: string;
   		exprName?: string;
   		varName?: string;
   		operator?: string;
   		leftTypeName?: string;
   		rirgtTypeName?: string;
   		fieldName?: string;
   		funcName?: string;
        funcDef?: string;
   		semanticName?: string;
        techniqueName?: string;
        componentName?: string;

    	line?:  number ;
    	column?:  number ;
    }

}











module akra.fx {



	export enum EScopeType{
		k_Default,
		k_Struct,
		k_Annotation
	}

	export interface IAFXFunctionDeclListMap {
		[functionName: string] : IAFXFunctionDeclInstruction[];
	}

	export interface IScope {
		parent : IScope;
		index:  number ;
		type: EScopeType;
		isStrictMode: bool;

		variableMap : IAFXVariableDeclMap;
		typeMap : IAFXTypeDeclMap;
		functionMap : IAFXFunctionDeclListMap;
	}

	export interface IScopeMap {
		[scopeIndex:  number ] : IScope;
	}

	export class ProgramScope {

		private _pScopeMap: IScopeMap;
		private _iCurrentScope:  number ;
		private _nScope:  number ;

		constructor() {
			this._pScopeMap = <IScopeMap>{};
			this._iCurrentScope = null;
			this._nScope = 0;
		}

		isStrictMode(iScope?:  number  = this._iCurrentScope): bool {
			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				if(pScope.isStrictMode){
					return true;
				}

				pScope = pScope.parent;
			}

			return false;
		}

		setStrictModeOn(iScope?:  number  = this._iCurrentScope): void {
			this._pScopeMap[iScope].isStrictMode = true;
		}

		newScope(eType: EScopeType): void {
			var isFirstScope: bool = false;
			var pParentScope: IScope;

			if(isNull(this._iCurrentScope)){
				pParentScope = null;
			}
			else {
				pParentScope = this._pScopeMap[this._iCurrentScope];
			}

			this._iCurrentScope = this._nScope++;

			var pNewScope: IScope = <IScope> {
										parent: pParentScope,
										index: this._iCurrentScope,
										type: eType,
										isStrictMode: false,
										variableMap: null,
										typeMap: null,
										functionMap: null
									};

			this._pScopeMap[this._iCurrentScope] = pNewScope;
		}

		resumeScope(): void {
			if(this._nScope === 0) {
				return;
			}

			this._iCurrentScope = this._nScope - 1;
		}

		setScope(iScope:  number ): void {
			this._iCurrentScope = iScope;
		}

		getScope():  number  {
			return this._iCurrentScope;
		}

		endScope(): void {
			if(isNull(this._iCurrentScope)){
				return;
			}

			var pOldScope: IScope = this._pScopeMap[this._iCurrentScope];
			var pNewScope: IScope = pOldScope.parent;

			if(isNull(pNewScope)){
				this._iCurrentScope = null;
			}
			else {
				this._iCurrentScope = pNewScope.index;
			}
		}

		inline getScopeType(): EScopeType {
			return this._pScopeMap[this._iCurrentScope].type;
		}

		getVariable(sVariableName: string, iScope?:  number  = this._iCurrentScope): IAFXVariableDeclInstruction {
			if(isNull(iScope)){
				return null;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pVariableMap: IAFXVariableDeclMap = pScope.variableMap;

				if(!isNull(pVariableMap)){
					var pVariable: IAFXVariableDeclInstruction = pVariableMap[sVariableName];

					if(isDef(pVariable)){
						return pVariable;
					}
				}

				pScope = pScope.parent;
			}

			return null;
		}

		getType(sTypeName: string, iScope?:  number  = this._iCurrentScope): IAFXTypeInstruction {
			var pTypeDecl: IAFXTypeDeclInstruction = this.getTypeDecl(sTypeName, iScope);

			if(!isNull(pTypeDecl)){
				return pTypeDecl.getType();
			}
			else {
				return null;
			}
		}

		getTypeDecl(sTypeName: string, iScope?:  number  = this._iCurrentScope): IAFXTypeDeclInstruction {
			if(isNull(iScope)){
				return null;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pTypeMap: IAFXTypeDeclMap = pScope.typeMap;

				if(!isNull(pTypeMap)){
					var pType: IAFXTypeDeclInstruction = pTypeMap[sTypeName];

					if(isDef(pType)){
						return pType;
					}
				}

				pScope = pScope.parent;
			}

			return null;
		}

/**
		 * get function by name and list of types
		 * return null - if threre are not function; undefined - if there more then one function; function - if all ok
		 */

		getFunction(sFuncName: string, pArgumentTypes: IAFXTypedInstruction[], iScope?:  number  =  0 ): IAFXFunctionDeclInstruction {
			if(isNull(iScope)){
				return null;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pFunction: IAFXFunctionDeclInstruction = null;

			while(!isNull(pScope)){
				var pFunctionListMap: IAFXFunctionDeclListMap = pScope.functionMap;

				if(!isNull(pFunctionListMap)){
					var pFunctionList: IAFXFunctionDeclInstruction[] = pFunctionListMap[sFuncName];

					if(isDef(pFunctionList)){

						for(var i:  number  = 0; i < pFunctionList.length; i++){
							var pTestedFunction: IAFXFunctionDeclInstruction  = pFunctionList[i];
							var pTestedArguments: IAFXTypedInstruction[] = pTestedFunction.getArguments();

							if(pArgumentTypes.length > pTestedArguments.length ||
							   pArgumentTypes.length < pTestedFunction.getNumNeededArguments()){
								continue;
							}

							var isParamsEqual: bool = true;

							for(var j:  number  = 0; j < pArgumentTypes.length; j++){
								isParamsEqual = false;

								if(!pArgumentTypes[j].getType().isEqual(pTestedArguments[j].getType())){
									break;
								}

								isParamsEqual = true;
							}

							if(isParamsEqual){
								if(!isNull(pFunction)){
									return undefined;
								}
								pFunction = pTestedFunction;
							}
						}
					}

				}

				pScope = pScope.parent;
			}

			return pFunction;
		}

/**
		 * get shader function by name and list of types
		 * return null - if threre are not function; undefined - if there more then one function; function - if all ok
		 */

		getShaderFunction(sFuncName: string, pArgumentTypes: IAFXTypedInstruction[], iScope?:  number  =  0 ): IAFXFunctionDeclInstruction {
			if(isNull(iScope)){
				return null;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pFunction: IAFXFunctionDeclInstruction = null;

			while(!isNull(pScope)){
				var pFunctionListMap: IAFXFunctionDeclListMap = pScope.functionMap;

				if(!isNull(pFunctionListMap)){
					var pFunctionList: IAFXFunctionDeclInstruction[] = pFunctionListMap[sFuncName];

					if(isDef(pFunctionList)){

						for(var i:  number  = 0; i < pFunctionList.length; i++){
							var pTestedFunction: IAFXFunctionDeclInstruction  = pFunctionList[i];
							var pTestedArguments: IAFXVariableDeclInstruction[] = <IAFXVariableDeclInstruction[]>pTestedFunction.getArguments();

							if(pArgumentTypes.length > pTestedArguments.length){
								continue;
							}

							var isParamsEqual: bool = true;
							var iArg:  number  = 0;

							if(pArgumentTypes.length === 0){
								if(!isNull(pFunction)){
									return undefined;
								}

								pFunction = pTestedFunction;
								continue;
							}

							for(var j:  number  = 0; j < pTestedArguments.length; j++){
								isParamsEqual = false;

								if(iArg >= pArgumentTypes.length) {
									if(pTestedArguments[j].isUniform()){
										break;
									}
									else {
										isParamsEqual = true;
									}
								}
								else if(pTestedArguments[j].isUniform()){
									if(!pArgumentTypes[iArg].getType().isEqual(pTestedArguments[j].getType())){
										break;
									}
									else{
										iArg++;
										isParamsEqual = true;
									}
								}
							}

							if(isParamsEqual){
								if(!isNull(pFunction)){
									return undefined;
								}
								pFunction = pTestedFunction;
							}
						}
					}

				}

				pScope = pScope.parent;
			}

			return pFunction;
		}

		addVariable(pVariable: IAFXVariableDeclInstruction, iScope?:  number  = this._iCurrentScope): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pVariableMap: IAFXVariableDeclMap = pScope.variableMap;

			if(isNull(pVariableMap)){
				pVariableMap = pScope.variableMap = <IAFXVariableDeclMap>{};
			}

			var sVariableName: string = pVariable.getName();

			if(!pVariable.getType().isShared()){
				if(this.hasVariableInScope(sVariableName, iScope)){
					return false;
				}

				pVariableMap[sVariableName] = pVariable;
				pVariable._setScope(iScope);
			}
			else {
				if(!this.hasVariableInScope(sVariableName, iScope)){
					pVariableMap[sVariableName] = pVariable;
					pVariable._setScope(iScope);
				}
				else {
					var pBlendVariable: IAFXVariableDeclInstruction = pVariableMap[sVariableName].blend(pVariable, EAFXBlendMode.k_Shared);
					if(isNull(pBlendVariable)){
						return false;
					}
					pVariableMap[sVariableName] = pBlendVariable;
					pBlendVariable._setScope(iScope);
				}
			}

			return true;
		}

		addType(pType: IAFXTypeDeclInstruction, iScope?:  number  = this._iCurrentScope): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pTypeMap: IAFXTypeDeclMap = pScope.typeMap;

			if(isNull(pTypeMap)){
				pTypeMap = pScope.typeMap = <IAFXTypeDeclMap>{};
			}

			var sTypeName: string = pType.getName();

			if(this.hasTypeInScope(sTypeName, iScope)){
				return false;
			}

			pTypeMap[sTypeName] = pType;
			pType._setScope(iScope);

			return true;
		}

		addFunction(pFunction: IAFXFunctionDeclInstruction, iScope?:  number  =  0 ): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pFunctionMap: IAFXFunctionDeclListMap = pScope.functionMap;

			if(isNull(pFunctionMap)){
				pFunctionMap = pScope.functionMap = <IAFXFunctionDeclListMap>{};
			}

			var sFuncName: string = pFunction.getName();

			if(this.hasFunctionInScope(pFunction, iScope)){
				return false;
			}

			if(!isDef(pFunctionMap[sFuncName])){
				pFunctionMap[sFuncName] = [];
			}

			pFunctionMap[sFuncName].push(pFunction);
			pFunction._setScope(iScope);

			return true;
		}

		hasVariable(sVariableName: string, iScope?:  number  = this._iCurrentScope): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pVariableMap: IAFXVariableDeclMap = pScope.variableMap;

				if(!isNull(pVariableMap)){
					var pVariable: IAFXVariableDeclInstruction = pVariableMap[sVariableName];

					if(isDef(pVariable)){
						return true;
					}
				}

				pScope = pScope.parent;
			}

			return false;
		}

		hasType(sTypeName: string, iScope?:  number  = this._iCurrentScope): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pTypeMap: IAFXTypeDeclMap = pScope.typeMap;

				if(!isNull(pTypeMap)){
					var pType: IAFXTypeDeclInstruction = pTypeMap[sTypeName];

					if(isDef(pType)){
						return true;
					}
				}

				pScope = pScope.parent;
			}

			return false;
		}

		hasFunction(sFuncName: string, pArgumentTypes: IAFXTypedInstruction[], iScope?:  number  =  0 ): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];

			while(!isNull(pScope)){
				var pFunctionListMap: IAFXFunctionDeclListMap = pScope.functionMap;

				if(!isNull(pFunctionListMap)){
					var pFunctionList: IAFXFunctionDeclInstruction[] = pFunctionListMap[sFuncName];

					if(isDef(pFunctionList)){
						var pFunction: IAFXFunctionDeclInstruction = null;

						for(var i:  number  = 0; i < pFunctionList.length; i++){
							var pTestedFunction: IAFXFunctionDeclInstruction  = pFunctionList[i];
							var pTestedArguments: IAFXTypedInstruction[] = pTestedFunction.getArguments();

							if(pArgumentTypes.length > pTestedArguments.length ||
							   pArgumentTypes.length < pTestedFunction.getNumNeededArguments()){
								continue;
							}

							var isParamsEqual: bool = true;

							for(var j:  number  = 0; j < pArgumentTypes.length; j++){
								isParamsEqual = false;

								if(!pArgumentTypes[j].getType().isEqual(pTestedArguments[j].getType())){
									break;
								}

								isParamsEqual = true;
							}

							if(isParamsEqual){
								return true;
							}
						}
					}

				}

				pScope = pScope.parent;
			}

			return false;
		}

		private inline hasVariableInScope(sVariableName: string, iScope:  number ): bool {
			return isDef(this._pScopeMap[iScope].variableMap[sVariableName]);
		}

		private inline hasTypeInScope(sTypeName: string, iScope:  number ): bool {
			return isDef(this._pScopeMap[iScope].typeMap[sTypeName]);
		}

		private hasFunctionInScope(pFunction: IAFXFunctionDeclInstruction, iScope:  number ): bool {
			if(isNull(iScope)){
				return false;
			}

			var pScope: IScope = this._pScopeMap[iScope];
			var pFunctionListMap:IAFXFunctionDeclListMap = pScope.functionMap;
			var pFunctionList: IAFXFunctionDeclInstruction[] = pFunctionListMap[pFunction.getName()];

			if(!isDef(pFunctionList)){
				return false;
			}

			var pFunctionArguments: IAFXTypedInstruction[] = <IAFXTypedInstruction[]>pFunction.getArguments();
			var hasFunction: bool = false;

			for(var i:  number  = 0; i < pFunctionList.length; i++){
				var pTestedArguments: IAFXTypedInstruction[] = <IAFXTypedInstruction[]>pFunctionList[i].getArguments();

				if(pTestedArguments.length !== pFunctionArguments.length){
					continue;
				}

				var isParamsEqual: bool = true;

				for(var j:  number  = 0; j < pFunctionArguments.length; j++){
					isParamsEqual = false;

					if(!pTestedArguments[j].getType().isEqual(pFunctionArguments[j].getType())){
						break;
					}

					isParamsEqual = true;
				}

				if(isParamsEqual){
					hasFunction = true;
					break;
				}
			}

			return hasFunction;
		}

	}



	export class ExprTemplateTranslator {
		private _pInToOutArgsMap: IntMap = null;
	    private _pExprPart: IAFXSimpleInstruction[] = null;

	    constructor(sExprTemplate: string){
	    	this._pInToOutArgsMap = <IntMap>{};
	    	this._pExprPart = <IAFXSimpleInstruction[]>[];

	    	var pSplitTemplate: string[] = sExprTemplate.split(/(\$\d+)/);

	    	for(var i:  number  = 0; i < pSplitTemplate.length; i++){
	    		if (pSplitTemplate[i]) {
		            if (pSplitTemplate[i][0] !== '$') {
		                this._pExprPart.push(new SimpleInstruction(pSplitTemplate[i]));
		            }
		            else {
		                this._pExprPart.push(null);
		                this._pInToOutArgsMap[this._pExprPart.length - 1] = ((<number><any>(pSplitTemplate[i].substr(1))) * 1 - 1);
		            }
	        	}
	    	}
	    }

	    toInstructionList(pArguments: IAFXInstruction[]): IAFXInstruction[] {
			var pOutputInstructionList: IAFXInstruction[] = <IAFXInstruction[]>[];

	    	for(var i:  number  = 0; i < this._pExprPart.length; i++){
	    		if(isNull(this._pExprPart[i])){
	    			pOutputInstructionList.push(pArguments[this._pInToOutArgsMap[i]]);
	    		}
	    		else {
	    			pOutputInstructionList.push(this._pExprPart[i]);
	    		}
	    	}

	    	return pOutputInstructionList;
		}
	}

}









module akra.fx {
    export function getEffectBaseType(sTypeName: string): SystemTypeInstruction {
    	return !isNull(Effect.pSystemTypes[sTypeName]) ? (Effect.pSystemTypes[sTypeName] || null) : null;
    }

    export function isSamplerType(pType: IAFXVariableTypeInstruction): bool {
    	return pType.isEqual(getEffectBaseType("sampler")) ||
    		   pType.isEqual(getEffectBaseType("sampler2D")) ||
    		   pType.isEqual(getEffectBaseType("samplerCUBE")) ||
    		   pType.isEqual(getEffectBaseType("video_buffer"));
    }







	export class Instruction implements IAFXInstruction{
		/**@protected*/  _pParentInstruction: IAFXInstruction = null;
		/**@protected*/  _sOperatorName: string = null;
		/**@protected*/  _pInstructionList: IAFXInstruction[] = null;
		/**@protected*/  _nInstructions:  number  = 0;
		/**@protected*/    _eInstructionType: EAFXInstructionTypes = 0;
		/**@protected*/  _pLastError: IAFXInstructionError = null;
		/**@protected*/  _bErrorOccured: bool = false;
		/**@protected*/  _iInstructionID:  number  = 0;
		/**@protected*/  _iScope:  number  =  0xffffff ;
		private static _nInstructionCounter:  number  = 0;

		private _isVisible: bool = true;

		inline getGuid():  number  {
			return this._getInstructionID();
		}

		inline getParent(): IAFXInstruction{
			return this._pParentInstruction;
		}

		inline setParent(pParentInstruction: IAFXInstruction): void {
			this._pParentInstruction = pParentInstruction;
		}

		inline getOperator(): string {
			return this._sOperatorName;
		}

		inline setOperator(sOperator: string): void {
			this._sOperatorName = sOperator;
		}

		inline getInstructions(): IAFXInstruction[] {
			return this._pInstructionList;
		}

		inline setInstructions(pInstructionList: IAFXInstruction[]): void{
			this._pInstructionList = pInstructionList;
		}

		inline _getInstructionType(): EAFXInstructionTypes {
			return this._eInstructionType;
		}

		inline _getInstructionID():  number  {
			return this._iInstructionID;
		}

		_getScope():  number  {
			return this._iScope !==  0xffffff  ? this._iScope :
						!isNull(this.getParent()) ? this.getParent()._getScope() :  0xffffff ;
		}

        inline _setScope(iScope:  number ): void {
        	this._iScope = iScope;
        }

        inline _isInGlobalScope(): bool{
        	return this._getScope() === 0;
        }

		inline getLastError(): IAFXInstructionError {
			return this._pLastError;
		}

		inline setError(eCode:  number , pInfo?: any = null): void {
			this._pLastError.code = eCode;
			this._pLastError.info = pInfo;
			this._bErrorOccured = true;
		}

		inline clearError(): void {
			this._bErrorOccured = false;
			this._pLastError.code = 0;
			this._pLastError.info = null;
		}

		inline isErrorOccured(): bool {
			return this._bErrorOccured;
		}

		inline setVisible(isVisible: bool): void {
            this._isVisible = isVisible;
        }

        inline isVisible(): bool {
            return this._isVisible;
        }

        inline initEmptyInstructions(): void {
        	this._pInstructionList = [];
        }

		constructor(){
			this._iInstructionID = Instruction._nInstructionCounter++;
			this._pParentInstruction = null;
			this._sOperatorName = null;
			this._pInstructionList = null;
			this._nInstructions = 0;
			this._eInstructionType = EAFXInstructionTypes.k_Instruction;
			this._pLastError = {code: 0, info: null};
		}

		push(pInstruction: IAFXInstruction, isSetParent?: bool = false): void {
			if(!isNull(this._pInstructionList)){
				this._pInstructionList[this._nInstructions] = pInstruction;
				this._nInstructions += 1;
			}
			if(isSetParent && !isNull(pInstruction)){
				pInstruction.setParent(this);
			}
		}

    	addRoutine(fnRoutine: IAFXInstructionRoutine, iPriority?:  number ): void {
//TODO
    	}

    	prepareFor(eUsedType: EFunctionType): void {
    		if(!isNull(this._pInstructionList) && this._nInstructions > 0) {
    			for(var i:  number  = 0; i < this._nInstructions; i++){
    				this._pInstructionList[i].prepareFor(eUsedType);
    			}
    		}
    	}
/**
    	 * Проверка валидности инструкции
    	 */

    	check(eStage: ECheckStage, pInfo: any = null): bool {
    		if(this._bErrorOccured){
    			return false;
    		}
    		else {
    			return true;
    		}
    	}

/**
    	 * Подготовка интсрукции к дальнейшему анализу
    	 */

    	prepare(): bool {
    		return true;
    	}

    	toString(): string {
    		return null;
    	}

    	toFinalCode(): string {
    		return "";
    	}

    	clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXInstruction {
    		if(isDef(pRelationMap[this._getInstructionID()])){
    			return pRelationMap[this._getInstructionID()];
    		}

    		var pNewInstruction: IAFXInstruction = new this["constructor"]();
    		var pParent: IAFXInstruction = this.getParent() || null;

    		if(!isNull(pParent) && isDef(pRelationMap[pParent._getInstructionID()])){
    			pParent = pRelationMap[pParent._getInstructionID()];
    		}

    		pNewInstruction.setParent(pParent);
    		pRelationMap[this._getInstructionID()] = pNewInstruction;

    		if(!isNull(this._pInstructionList) && isNull(pNewInstruction.getInstructions())){
    			pNewInstruction.initEmptyInstructions();
    		}

    		for(var i:  number  = 0; i < this._nInstructions; i++){
    			pNewInstruction.push(this._pInstructionList[i].clone(pRelationMap));
    		}

    		pNewInstruction.setOperator(this.getOperator());

    		return pNewInstruction;
    	}
	}

	export class InstructionCollector extends Instruction {
		constructor(){
			super();
			this._pInstructionList = [];
			this._eInstructionType = EAFXInstructionTypes.k_InstructionCollector;
		}

		toFinalCode(): string {
    		var sCode: string = "";
    		for(var i:  number  = 0; i < this._nInstructions; i++){
    			sCode += this.getInstructions()[i].toFinalCode();
    		}

    		return sCode;
    	}
	}

	export class SimpleInstruction extends Instruction implements IAFXSimpleInstruction{
		private _sValue: string = "";

		constructor(sValue: string){
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_SimpleInstruction;

			this._sValue = sValue;
		}

		inline setValue(sValue: string): void {
			this._sValue = sValue;
		}

		inline isValue(sValue: string): bool {
			return (this._sValue === sValue);
		}

		toString(): string{
			return this._sValue;
		}

		toFinalCode(): string{
			return this._sValue;
		}

		clone(pRelationMap?: IAFXInstructionMap): SimpleInstruction {
			var pClone: SimpleInstruction = <SimpleInstruction>super.clone(pRelationMap);
			pClone.setValue(this._sValue);
			return pClone;
		}
	}



	export class TypedInstruction extends Instruction implements IAFXTypedInstruction {
		/**@protected*/  _pType: IAFXTypeInstruction;

		constructor(){
			super();
			this._pType = null;
			this._eInstructionType = EAFXInstructionTypes.k_TypedInstruction;
		}

		getType(): IAFXTypeInstruction {
			return this._pType;
		}

		setType(pType: IAFXTypeInstruction): void {
			this._pType = pType;
		}

		clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXTypedInstruction {
			var pClonedInstruction: IAFXTypedInstruction = <IAFXTypedInstruction>(super.clone(pRelationMap));
			if(!isNull(this.getType())) {
				pClonedInstruction.setType(this.getType().clone(pRelationMap));
			}
			return pClonedInstruction;
		}
	}



	export class DeclInstruction extends TypedInstruction implements IAFXDeclInstruction {
		/**@protected*/  _sSemantic: string = "";
		/**@protected*/  _pAnnotation: IAFXAnnotationInstruction = null;
		/**@protected*/  _bForPixel: bool = true;
		/**@protected*/  _bForVertex: bool = true;
		/**@protected*/  _isBuiltIn: bool = false;

		constructor(){
			super();
			this._eInstructionType = EAFXInstructionTypes.k_DeclInstruction;
		}

		setSemantic(sSemantic: string): void {
			this._sSemantic = sSemantic;
		}

		setAnnotation(pAnnotation: IAFXAnnotationInstruction): void {
			this._pAnnotation = pAnnotation;
		}

		getName(): string {
			return "";
		}

		getRealName(): string {
			return "";
		}

		getNameId(): IAFXIdInstruction {
			return null;
		}

		inline getSemantic(): string {
			return this._sSemantic;
		}

		isBuiltIn(): bool {
			return this._isBuiltIn;
		}

		setBuiltIn(isBuiltIn: bool): void {
			this._isBuiltIn = isBuiltIn;
		}

		inline _isForAll(): bool{
			return this._bForVertex && this._bForPixel;
		}
        inline _isForPixel(): bool{
        	return this._bForPixel;
        }
        inline _isForVertex(): bool{
        	return this._bForVertex;
        }

        inline _setForAll(canUse: bool): void{
        	this._bForVertex = canUse;
        	this._bForPixel = canUse;
        }
        inline _setForPixel(canUse: bool): void{
    	    this._bForPixel = canUse;
    	}
        inline _setForVertex(canUse: bool): void{
        	this._bForVertex = canUse;
        }

		clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXDeclInstruction {
			var pClonedInstruction: IAFXDeclInstruction = <IAFXDeclInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setSemantic(this._sSemantic);
			pClonedInstruction.setAnnotation(this._pAnnotation);
			return pClonedInstruction;
		}
	}



	export class IdInstruction extends Instruction implements IAFXIdInstruction {
		private _sName: string;
		private _sRealName: string;

		inline isVisible(): bool {
			return this.getParent().isVisible();
		}
/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._sName = "";
			this._sRealName = "";
			this._eInstructionType = EAFXInstructionTypes.k_IdInstruction;
		}

		inline getName(): string{
			return this._sName;
		}

		inline getRealName(): string{
			return this._sRealName;
		}

		inline setName(sName: string): void{
			this._sName = sName;
			this._sRealName = sName + "R";
		}

		inline setRealName(sRealName: string): void{
			this._sRealName = sRealName;
		}

		toString(): string {
			return this._sRealName;
		}

		toFinalCode(): string {
			return this._sRealName;
		}

		clone(pRelationMap?: IAFXInstructionMap): IdInstruction {
			var pClonedInstruction: IdInstruction = <IdInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setName(this._sName);
			pClonedInstruction.setRealName(this._sRealName);
			return pClonedInstruction;
		}

	}

	export class KeywordInstruction extends Instruction implements IAFXKeywordInstruction {
		private _sValue: string;

/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._sValue = "";
			this._eInstructionType = EAFXInstructionTypes.k_KeywordInstruction;
		}

		inline setValue(sValue: string): void {
			this._sValue = sValue;
		}

		inline isValue(sTestValue: string): bool {
			return this._sValue === sTestValue;
		}

		toString(): string {
			return this._sValue;
		}

		toFinalCode(): string{
			return this._sValue;
		}
	}


	export class AnnotationInstruction extends Instruction implements IAFXAnnotationInstruction {
		constructor() {
			super();
			this._eInstructionType = EAFXInstructionTypes.k_AnnotationInstruction;
		}
	}

	export class PassInstruction extends DeclInstruction implements IAFXPassInstruction {
		private _pTempNodeList: IParseNode[] = null;
		private _pTempFoundedFuncList: IAFXFunctionDeclInstruction[] = null;
		private _pTempFoundedFuncTypeList: EFunctionType[] = null;
		private _pParseNode: IParseNode = null;

		private _sFunctionCode: string = "";

		private _isComlexPass: bool = false;
		private _pShadersMap: IAFXFunctionDeclMap = null;
		private _fnPassFunction: {(engine: any, foreigtn: any, uniforms: any): void;} = null;

		private _pVertexShader: IAFXFunctionDeclInstruction = null;
		private _pPixelShader: IAFXFunctionDeclInstruction = null;
		private _pPassStateMap: StringMap = null;


		private _pSharedVariableMapV: IAFXVariableDeclMap = null;
		private _pGlobalVariableMapV: IAFXVariableDeclMap = null;
		private _pUniformVariableMapV: IAFXVariableDeclMap = null;
		private _pForeignVariableMapV: IAFXVariableDeclMap = null;
		private _pTextureVariableMapV: IAFXVariableDeclMap = null;
		private _pUsedComplexTypeMapV: IAFXTypeMap = null;

		private _pSharedVariableMapP: IAFXVariableDeclMap = null;
		private _pGlobalVariableMapP: IAFXVariableDeclMap = null;
		private _pUniformVariableMapP: IAFXVariableDeclMap = null;
		private _pForeignVariableMapP: IAFXVariableDeclMap = null;
		private _pTextureVariableMapP: IAFXVariableDeclMap = null;
		private _pUsedComplexTypeMapP: IAFXTypeMap = null;

		private _pFullUniformVariableMap: IAFXVariableDeclMap = null;
		private _pFullForeignVariableMap: IAFXVariableDeclMap = null;
		private _pFullTextureVariableMap: IAFXVariableDeclMap = null;


		constructor(){
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_PassInstruction;
		}

		_addFoundFunction(pNode: IParseNode, pShader: IAFXFunctionDeclInstruction, eType: EFunctionType): void{
			if(isNull(this._pTempNodeList)){
				this._pTempNodeList = [];
				this._pTempFoundedFuncList = [];
				this._pTempFoundedFuncTypeList = [];
			}

			this._pTempNodeList.push(pNode);
			this._pTempFoundedFuncList.push(pShader);
			this._pTempFoundedFuncTypeList.push(eType);
		}

		_getFoundedFunction(pNode: IParseNode): IAFXFunctionDeclInstruction {
			if(isNull(this._pTempNodeList)){
				return null;
			}

			for(var i:  number  = 0; i < this._pTempNodeList.length; i++){
				if(this._pTempNodeList[i] === pNode){
					return this._pTempFoundedFuncList[i];
				}
			}

			return null;
		}

		_getFoundedFunctionType(pNode: IParseNode): EFunctionType {
			if(isNull(this._pTempNodeList)){
				return null;
			}

			for(var i:  number  = 0; i < this._pTempNodeList.length; i++){
				if(this._pTempNodeList[i] === pNode){
					return this._pTempFoundedFuncTypeList[i];
				}
			}

			return null;
		}

		_setParseNode(pNode: IParseNode): void {
        	this._pParseNode = pNode;
        }

        _getParseNode(): IParseNode{
        	return this._pParseNode;
        }

        _addCodeFragment(sCode: string): void {
        	if(this.isComplexPass()){
        		this._sFunctionCode += sCode;
        	}
        }

        inline _markAsComplex(isComplex: bool): void{
        	this._isComlexPass = isComplex;
        }

        inline _getSharedVariableMapV(): IAFXVariableDeclMap{
        	return this._pSharedVariableMapV;
        }

        inline _getGlobalVariableMapV(): IAFXVariableDeclMap{
        	return this._pGlobalVariableMapV;
        }

        inline _getUniformVariableMapV(): IAFXVariableDeclMap{
        	return this._pUniformVariableMapV;
        }

        inline _getForeignVariableMapV(): IAFXVariableDeclMap{
        	return this._pForeignVariableMapV;
        }

        inline _getTextureVariableMapV(): IAFXVariableDeclMap{
        	return this._pTextureVariableMapV;
        }

        inline _getUsedComplexTypeMapV(): IAFXTypeMap{
        	return this._pUsedComplexTypeMapV;
        }

        inline _getSharedVariableMapP(): IAFXVariableDeclMap{
        	return this._pSharedVariableMapP;
        }

        inline _getGlobalVariableMapP(): IAFXVariableDeclMap{
        	return this._pGlobalVariableMapP;
        }

        inline _getUniformVariableMapP(): IAFXVariableDeclMap{
        	return this._pUniformVariableMapP;
        }

        inline _getForeignVariableMapP(): IAFXVariableDeclMap{
        	return this._pForeignVariableMapP;
        }

        inline _getTextureVariableMapP(): IAFXVariableDeclMap{
        	return this._pTextureVariableMapP;
        }

        inline _getUsedComplexTypeMapP(): IAFXTypeMap{
        	return this._pUsedComplexTypeMapP;
        }

        inline _getFullUniformMap(): IAFXVariableDeclMap {
        	return this._pFullUniformVariableMap;
        }

        inline _getFullForeignMap(): IAFXVariableDeclMap {
        	return this._pFullForeignVariableMap;
        }

        inline _getFullTextureMap(): IAFXVariableDeclMap {
        	return this._pFullTextureVariableMap;
        }


        inline isComplexPass(): bool {
        	return this._isComlexPass;
        }

        inline getVertexShader(): IAFXFunctionDeclInstruction {
			return this._pVertexShader;
		}

		inline getPixelShader(): IAFXFunctionDeclInstruction {
			return this._pPixelShader;
		}

        addShader(pShader: IAFXFunctionDeclInstruction): void {
        	var isVertex: bool = pShader.getFunctionType() === EFunctionType.k_Vertex;

        	if(this.isComplexPass()){
        		if(isNull(this._pShadersMap)){
        			this._pShadersMap = <IAFXFunctionDeclMap>{};
        		}
        		var iShader:  number  = pShader._getInstructionID();
        		this._pShadersMap[iShader] = pShader;

        		var sCode: string = isVertex ? "this._pVertexShader=" : "this._pPixelShader=";
        		sCode += "this._pShadersMap["+ iShader.toString() +"];"
        		this._addCodeFragment(sCode);
        	}
        	else {
        		if(isVertex){
        			this._pVertexShader = pShader;
        		}
        		else {
        			this._pPixelShader = pShader;
        		}
        	}
        }

        setState(sType: string, sValue: string): void {
        	if(isNull(this._pPassStateMap)){
        		this._pPassStateMap = <StringMap>{};
        	}

        	if(this.isComplexPass()){
        		this._addCodeFragment("this._pPassStateMap[" + sType + "]=" + sValue+ ";");
        	}
        	else {
        		this._pPassStateMap[sType] = sValue;
        	}
        }

        finalizePass(): void {
        	if(this.isComplexPass()){
        		this._fnPassFunction = <any>(new Function("engine", "foreigns", "uniforms", this._sFunctionCode));
        	}

        	this.generateInfoAboutUsedVaraibles();

        	this._pTempNodeList = null;
			this._pTempFoundedFuncList = null;
			this._pTempFoundedFuncTypeList = null;
			this._pParseNode= null;
			this._sFunctionCode = "";
        }

        evaluate(pEngineStates: any, pForeigns: any, pUniforms: any): bool {
        	if(this.isComplexPass()){
        		this._pVertexShader = null;
        		this._pPixelShader = null;

        		this._fnPassFunction.call(this, pEngineStates, pForeigns, pUniforms);
        	}

        	return true;
        }

        private generateInfoAboutUsedVaraibles(): void {
        	if(isNull(this._pSharedVariableMapV)){
	        	this._pSharedVariableMapV = <IAFXVariableDeclMap>{};
				this._pGlobalVariableMapV = <IAFXVariableDeclMap>{};
				this._pUniformVariableMapV = <IAFXVariableDeclMap>{};
				this._pForeignVariableMapV = <IAFXVariableDeclMap>{};
				this._pTextureVariableMapV = <IAFXVariableDeclMap>{};
				this._pUsedComplexTypeMapV = <IAFXTypeMap>{};

				this._pSharedVariableMapP = <IAFXVariableDeclMap>{};
				this._pGlobalVariableMapP = <IAFXVariableDeclMap>{};
				this._pUniformVariableMapP = <IAFXVariableDeclMap>{};
				this._pForeignVariableMapP = <IAFXVariableDeclMap>{};
				this._pTextureVariableMapP = <IAFXVariableDeclMap>{};
				this._pUsedComplexTypeMapP = <IAFXTypeMap>{};

				this._pFullUniformVariableMap = <IAFXVariableDeclMap>{};
				this._pFullForeignVariableMap = <IAFXVariableDeclMap>{};
				this._pFullTextureVariableMap = <IAFXVariableDeclMap>{};
			}

        	if(this.isComplexPass()){
        		for(var i in this._pShadersMap){
        			this.addInfoAbouUsedVariablesFromFunction(this._pShadersMap[i]);
        		}
        	}
        	else {
        		if(!isNull(this._pVertexShader)){
        			this.addInfoAbouUsedVariablesFromFunction(this._pVertexShader);
        		}
        		if(!isNull(this._pPixelShader)){
        			this.addInfoAbouUsedVariablesFromFunction(this._pPixelShader);
        		}
        	}
        }

        private addInfoAbouUsedVariablesFromFunction(pFunction: IAFXFunctionDeclInstruction): void {
        	var pSharedVars: IAFXVariableDeclMap = pFunction._getSharedVariableMap();
        	var pGlobalVars: IAFXVariableDeclMap = pFunction._getGlobalVariableMap();
        	var pUniformVars: IAFXVariableDeclMap = pFunction._getUniformVariableMap();
        	var pForeignVars: IAFXVariableDeclMap = pFunction._getForeignVariableMap();
        	var pTextureVars: IAFXVariableDeclMap = pFunction._getTextureVariableMap();
        	var pTypes: IAFXTypeMap = pFunction._getUsedComplexTypeMap();


        	var pSharedVarsTo: IAFXVariableDeclMap = null;
        	var pGlobalVarsTo: IAFXVariableDeclMap = null;
        	var pUniformVarsTo: IAFXVariableDeclMap = null;
        	var pForeignVarsTo: IAFXVariableDeclMap = null;
        	var pTextureVarsTo: IAFXVariableDeclMap = null;
        	var pTypesTo: IAFXTypeMap = null;

        	if(pFunction.getFunctionType() === EFunctionType.k_Vertex){
        		pSharedVarsTo = this._pSharedVariableMapV;
	        	pGlobalVarsTo = this._pGlobalVariableMapV;
	        	pUniformVarsTo = this._pUniformVariableMapV;
	        	pForeignVarsTo = this._pForeignVariableMapV;
	        	pTextureVarsTo = this._pTextureVariableMapV;
	        	pTypesTo = this._pUsedComplexTypeMapV;
        	}
        	else {
        		pSharedVarsTo = this._pSharedVariableMapP;
	        	pGlobalVarsTo = this._pGlobalVariableMapP;
	        	pUniformVarsTo = this._pUniformVariableMapP;
	        	pForeignVarsTo = this._pForeignVariableMapP;
	        	pTextureVarsTo = this._pTextureVariableMapP;
	        	pTypesTo = this._pUsedComplexTypeMapP;
        	}

        	for(var i in pSharedVars){
        		if(!isNull(pSharedVars[i]) && !pSharedVars[i].isField()){
        			pSharedVarsTo[i] = pSharedVars[i];
        		}
        	}
        	for(var i in pGlobalVars){
        		if(!isNull(pGlobalVars[i])){
        			pGlobalVarsTo[i] = pGlobalVars[i];
        		}
        	}
        	for(var i in pUniformVars){
        		if(!isNull(pUniformVars[i])){
        			pUniformVarsTo[i] = pUniformVars[i];
        			this._pFullUniformVariableMap[i] = pUniformVars[i];
        		}
        	}
        	for(var i in pForeignVars){
        		if(!isNull(pForeignVars[i])){
        			pForeignVarsTo[i] = pForeignVars[i];
        			this._pFullForeignVariableMap[i] = pForeignVars[i];
        		}
        	}
        	for(var i in pTextureVars){
        		if(!isNull(pTextureVars[i])){
        			pTextureVarsTo[i] = pTextureVars[i];
        			this._pFullTextureVariableMap[i] = pTextureVars[i];
        		}
        	}
        	for(var i in pTypes){
        		if(!isNull(pTypes[i])){
        			pTypesTo[i] = pTypes[i];
        		}
        	}
        }
	}



	export class TechniqueInstruction extends DeclInstruction implements IAFXTechniqueInstruction {
		private _sName: string = "";
		private _hasComplexName: bool = false;
		private _pParseNode: IParseNode = null;
		private _pSharedVariableListV: IAFXVariableDeclInstruction[] = null;
		private _pSharedVariableListP: IAFXVariableDeclInstruction[] = null;
		private _pPassList: IAFXPassInstruction[] = null;
		private _pComponentList: IAFXComponent[] = null;
		private _pComponentShiftList:  number [] = null;
		private _pFullComponentList: IAFXComponent[] = null;
		private _pFullComponentShiftList:  number [] = null;
		private _nTotalPasses:  number  = 0;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_TechniqueInstruction;
		}

		setName(sName: string, isComplexName: bool): void {
			this._sName = sName;
			this._hasComplexName = isComplexName;
		}

		getName(): string {
			return this._sName;
		}

        hasComplexName(): bool{
        	return this._hasComplexName;
        }

        getSharedVariablesForVertex(): IAFXVariableDeclInstruction[] {
        	return this._pSharedVariableListV;
        }

        getSharedVariablesForPixel(): IAFXVariableDeclInstruction[] {
        	return this._pSharedVariableListP;
        }

		addPass(pPass: IAFXPassInstruction): void {
			if(isNull(this._pPassList)){
				this._pPassList = [];
			}

			this._pPassList.push(pPass);
		}

		getPassList(): IAFXPassInstruction[]{
			return this._pPassList;
		}

		getPass(iPass:  number ): IAFXPassInstruction{
			return iPass < this._pPassList.length ? this._pPassList[iPass] : null;
		}

		totalOwnPasses():  number {
			return this._pPassList.length;
		}

        totalPasses():  number {
        	return this._nTotalPasses;
        }

		addComponent(pComponent: IAFXComponent, iShift:  number ): void{
			if(isNull(this._pComponentList)){
				this._pComponentList = [];
				this._pComponentShiftList = [];
			}

			this._pComponentList.push(pComponent);
			this._pComponentShiftList.push(iShift);
		}

		inline getComponentList(): IAFXComponent[]{
			return this._pComponentList;
		}

        inline getComponentListShift():  number []{
        	return this._pComponentShiftList;
        }

        getFullComponentList(): IAFXComponent[]{
        	return this._pFullComponentList;
        }

        getFullComponentShiftList():  number []{
        	return this._pFullComponentShiftList;
        }

		checkForCorrectImports(): bool {
			return true;
		}

		finalizeTechnique(sProvideNameSpace: string,
                          pGloabalComponentList: IAFXComponent[],
                          pGloabalComponentShiftList:  number []): void {
			this.generateListOfSharedVariables();

			if(!this.hasComplexName() && sProvideNameSpace !== ""){
				this._sName = sProvideNameSpace + "." + this._sName;
			}

			if(!isNull(pGloabalComponentList)){
				if(!isNull(this._pComponentList)){
					this._pComponentList = pGloabalComponentList.concat(this._pComponentList);
					this._pComponentShiftList = pGloabalComponentShiftList.concat(this._pComponentShiftList);
				}
				else {
					this._pComponentList = pGloabalComponentList.concat();
					this._pComponentShiftList = pGloabalComponentShiftList.concat();
				}
			}

			this.generateFullListOfComponent();
		}

		private generateListOfSharedVariables(): void {
			this._pSharedVariableListV = [];
			this._pSharedVariableListP = [];

			for(var i:  number  = 0; i < this._pPassList.length; i++){
				var pSharedV: IAFXVariableDeclMap = this._pPassList[i]._getSharedVariableMapV();
				var pSharedP: IAFXVariableDeclMap = this._pPassList[i]._getSharedVariableMapP();

				for(var j in pSharedV){
					this.addSharedVariable(pSharedV[j], EFunctionType.k_Vertex);
				}

				for(var j in pSharedP){
					this.addSharedVariable(pSharedP[j], EFunctionType.k_Pixel);
				}
			}
		}

		private addSharedVariable(pVar: IAFXVariableDeclInstruction, eType: EFunctionType): void {
			var pAddTo: IAFXVariableDeclInstruction[] = null;

			if(eType === EFunctionType.k_Vertex){
				pAddTo = this._pSharedVariableListV;
			}
			else {
				pAddTo = this._pSharedVariableListP;
			}

			for(var i:  number  = 0; i < pAddTo.length; i++) {
				if(pAddTo[i] === pVar){
					return;
				}
			}

			pAddTo.push(pVar);
		}

		private generateFullListOfComponent(): void {
			this._nTotalPasses = this.totalOwnPasses();

			if(isNull(this._pComponentList)){
				return;
			}

			this._pFullComponentList = [];
			this._pFullComponentShiftList = [];

			for(var i:  number  = 0; i < this._pComponentList.length; i++){
				var pTechnique: IAFXTechniqueInstruction = this._pComponentList[i].getTechnique();
				var iMainShift:  number  = this._pComponentShiftList[i];
				var pAddComponentList: IAFXComponent[] = pTechnique.getFullComponentList();
				var pAddComponentShiftList:  number [] = pTechnique.getFullComponentShiftList();

				if(!isNull(pAddComponentList)){
					for(var j:  number  = 0; j < pAddComponentList.length; i++){
						this._pFullComponentList.push(pAddComponentList[j]);
						this._pFullComponentShiftList.push(pAddComponentShiftList[j] + iMainShift);
					}
				}

				this._pFullComponentList.push(this._pComponentList[i]);
				this._pFullComponentShiftList.push(iMainShift);

				if(this._nTotalPasses < iMainShift + pTechnique.totalPasses()) {
					this._nTotalPasses = iMainShift + pTechnique.totalPasses();
				}
			}
		}
	}

}













module akra.fx {
	export class TypeDeclInstruction extends DeclInstruction implements IAFXTypeDeclInstruction {
// EMPTY_OPERATOR VariableTypeInstruction

		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_TypeDeclInstruction;
		}

		inline getType(): IAFXTypeInstruction {
			return <IAFXTypeInstruction>this._pInstructionList[0];
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXTypeDeclInstruction {
        	return <IAFXTypeDeclInstruction>super.clone(pRelationMap);
        }

        toFinalCode(): string {
			return this.getType()._toDeclString() + ";";
		}

        inline getName(): string {
        	return this.getType().getName();
        }

        inline getRealName(): string {
        	return this.getType().getRealName();
        }

        blend(pDecl: IAFXTypeDeclInstruction, eBlendMode: EAFXBlendMode): IAFXTypeDeclInstruction {
        	if(pDecl !== this){
        		return null;
        	}

        	return this;
        }
	}

	export class VariableTypeInstruction extends Instruction implements IAFXVariableTypeInstruction {
		private _pSubType: IAFXTypeInstruction = null;
		private _pUsageList: string[] = null;

		private _sName: string = "";
		private _isWritable: bool = null;
		private _isReadable: bool = null;

		private _bUsedForWrite: bool = false;
		private _bUsedForRead: bool = false;

		private _sHash: string = "";
		private _sStrongHash: string = "";
		private _isArray: bool = false;
		private _isPointer: bool = false;
		private _isStrictPointer: bool = false;
		private _isPointIndex: bool = null;
		private _isUniform: bool = null;
		private _isGlobal: bool = null;
		private _isConst: bool = null;
		private _isShared: bool = null;
		private _isForeign: bool = null;
		private _iLength:  number  =  0xffffff ;

		private _isFromVariableDecl: bool = null;
		private _isFromTypeDecl: bool = null;
		private _isField: bool = false;

		private _pArrayIndexExpr: IAFXExprInstruction = null;
		private _pArrayElementType: IAFXVariableTypeInstruction = null;

		private _pFieldDeclMap: IAFXVariableDeclMap = null;
		private _pFieldDeclBySemanticMap: IAFXVariableDeclMap = null;
		private _pFieldIdMap: IAFXIdExprMap = null;
		private _pUsedFieldMap: IAFXVarUsedModeMap = null;

		private _pVideoBuffer: IAFXVariableDeclInstruction = null;
		private _pMainPointIndex: IAFXVariableDeclInstruction = null;
		private _pUpPointIndex: IAFXVariableDeclInstruction = null;
		private _pDownPointIndex: IAFXVariableDeclInstruction = null;
		private _nPointDim:  number  = 0;
		private _pPointerList: IAFXVariableDeclInstruction[] = null;
		private _iPadding:  number  =  0xffffff ;

		private _pSubDeclList: IAFXVariableDeclInstruction[] = null;

		private _bUnverifiable: bool = false;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_VariableTypeInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			if(!isNull(this._pUsageList)){
				for(var i:  number  = 0; i < this._pUsageList.length; i++){
					sCode += this._pUsageList[i];
				}
			}

			sCode += this.getSubType().toFinalCode();

			return sCode;
		}

		_toDeclString(): string {
			return this.getSubType()._toDeclString();
		}

		isBuiltIn(): bool {
			return false;
		}

        setBuiltIn(isBuiltIn: bool): void {
        }

//-----------------------------------------------------------------//
//----------------------------SIMPLE TESTS-------------------------//
//-----------------------------------------------------------------//

		inline isBase(): bool {
			return this.getSubType().isBase() && this._isArray === false;
		}

		inline isArray(): bool {
			return this._isArray ||
				   (this.getSubType().isArray());
		}

		inline isNotBaseArray(): bool {
			return this._isArray || (this.getSubType().isNotBaseArray());
		}

		inline isComplex(): bool {
			return this.getSubType().isComplex();
		}

		isEqual(pType: IAFXTypeInstruction): bool {
			if(this._isUnverifiable()){
				return true;
			}

			if (this.isNotBaseArray() && pType.isNotBaseArray() &&
				(this.getLength() !== pType.getLength() ||
				 this.getLength() ===  0xffffff  ||
				 pType.getLength() ===  0xffffff )){
				return false;
			}

			if(this.getHash() !== pType.getHash()){
				return false;
			}

			return true;
		}

		isStrongEqual(pType: IAFXTypeInstruction): bool {
			if(!this.isEqual(pType) || this.getStrongHash() !== pType.getStrongHash()){
				return false;
			}

			return true;
		}

		isSampler(): bool {
			return this.getSubType().isSampler();
		}

		isWritable(): bool {
			if(!isNull(this._isWritable)){
				return this._isWritable;
			}

			if ((this.isArray() && !this.isBase()) ||
				this.isForeign() || this.isUniform()){
				this._isWritable = false;
			}
			else {
				this._isWritable = this.getSubType().isWritable();
			}

			return this._isWritable;
		}

		isReadable(): bool {
			if(!isNull(this._isReadable)){
				return this._isReadable;
			}

			if(this.hasUsage("out")){
				this._isReadable = false;
			}
			else{
				this._isReadable = this.getSubType().isReadable();
			}

			return this._isReadable;
		}

		_containArray(): bool {
			return this.getSubType()._containArray();
		}

        _containSampler(): bool {
        	return this.getSubType()._containSampler();
        }

        _containPointer(): bool {
        	return this.getSubType()._containSampler();
        }

        _containComplexType(): bool {
        	return this.getSubType()._containComplexType();
        }

		isPointer(): bool {
			return this._isPointer ||
				   (this.getSubType()._getInstructionType() === EAFXInstructionTypes.k_VariableTypeInstruction &&
				   	(<IAFXVariableTypeInstruction>this.getSubType()).isPointer());
		}

		isStrictPointer(): bool {
			return this._isStrictPointer ||
					(this.getSubType()._getInstructionType() === EAFXInstructionTypes.k_VariableTypeInstruction &&
				   	(<IAFXVariableTypeInstruction>this.getSubType()).isStrictPointer());
		}

		isPointIndex(): bool{
			if(isNull(this._isPointIndex)){
				this._isPointIndex = this.isStrongEqual(getEffectBaseType("ptr"));
			}

			return this._isPointIndex;
		}

		isFromVariableDecl(): bool {
			if(!isNull(this._isFromVariableDecl)){
				return this._isFromVariableDecl;
			}

			if(isNull(this.getParent())){
				this._isFromVariableDecl = false;
			}
			else {
				var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

				if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
					this._isFromVariableDecl = true;
				}
				else if(eParentType === EAFXInstructionTypes.k_VariableTypeInstruction){
					this._isFromVariableDecl = (<IAFXVariableTypeInstruction>this.getParent()).isFromVariableDecl();
				}
				else {
					this._isFromVariableDecl = false;
				}
			}

			return this._isFromVariableDecl;
		}

        isFromTypeDecl(): bool {
        	if(!isNull(this._isFromTypeDecl)){
				return this._isFromTypeDecl;
			}

        	if(isNull(this.getParent())){
				this._isFromTypeDecl = false;
			}
			else {
	        	var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

				if(eParentType === EAFXInstructionTypes.k_TypeDeclInstruction){
					this._isFromTypeDecl = true;
				}
				else if(eParentType === EAFXInstructionTypes.k_VariableTypeInstruction){
					this._isFromTypeDecl = (<IAFXVariableTypeInstruction>this.getParent()).isFromVariableDecl();
				}
				else {
					this._isFromTypeDecl = false;
				}
			}

			return this._isFromTypeDecl;
        }

        isUniform(): bool {
        	if(isNull(this._isUniform)){
				this._isUniform = this.hasUsage("uniform");
			}

			return this._isUniform;
        }

        isGlobal(): bool {
        	if(isNull(this._isGlobal)){
				this._isGlobal = this._getScope() === 0;
			}

			return this._isGlobal;
        }

        isConst(): bool {
			if(isNull(this._isConst)){
				this._isConst = this.hasUsage("const");
			}

			return this._isConst;
		}

        isShared(): bool {
        	if(isNull(this._isShared)){
				this._isShared = this.hasUsage("shared");
			}

			return this._isShared;
        }

        isForeign(): bool {
        	if(isNull(this._isForeign)){
				this._isForeign = this.hasUsage("foreign");
			}

			return this._isForeign;
        }

        _isTypeOfField(): bool {
        	if(isNull(this.getParent())){
        		return false;
        	}

        	if(this.getParent()._getInstructionType() === EAFXInstructionTypes.k_VariableDeclInstruction){
        		var pParentDecl: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getParent();
        		return pParentDecl.isField();
        	}

        	return false;
        }

        inline _isUnverifiable(): bool {
        	return this._bUnverifiable;
        }

//-----------------------------------------------------------------//
//----------------------------SET TYPE INFO------------------------//
//-----------------------------------------------------------------//

		setName(sName: string): void {
			this._sName = sName;
		}

		inline _canWrite(isWritable: bool): void {
			this._isWritable = isWritable;
		}

		inline _canRead(isReadable: bool): void {
			this._isReadable = isReadable;
		}

//-----------------------------------------------------------------//
//----------------------------INIT API-----------------------------//
//-----------------------------------------------------------------//
		inline setPadding(iPadding:  number ): void {
			this._iPadding = iPadding;
		}

		pushType(pType: IAFXTypeInstruction): void {
			var eType: EAFXInstructionTypes = pType._getInstructionType();

			if (eType === EAFXInstructionTypes.k_SystemTypeInstruction ||
				eType === EAFXInstructionTypes.k_ComplexTypeInstruction){
				this._pSubType = pType;
			}
			else {
				var pVarType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pType;
				if(!pVarType.isNotBaseArray() && !pVarType.isPointer()){
					var pUsageList: string[] = pVarType.getUsageList();
					if(!isNull(pUsageList)){
						for(var i:  number  = 0; i < pUsageList.length; i++){
							this.addUsage(pUsageList[i]);
						}
					}

					this._pSubType = pVarType.getSubType();
				}
				else{
					this._pSubType = pType;
				}
			}

		}

		addUsage(sUsage: string): void {
			if(isNull(this._pUsageList)){
				this._pUsageList = [];
			}

			if(!this.hasUsage(sUsage)){
				this._pUsageList.push(sUsage);
			}
		}

		addArrayIndex(pExpr: IAFXExprInstruction): void {
//TODO: add support for v[][10]

			this._pArrayElementType = new VariableTypeInstruction();
			this._pArrayElementType.pushType(this.getSubType());
			if(!isNull(this._pUsageList)){
				for(var i:  number  = 0; i < this._pUsageList.length; i++){
					this._pArrayElementType.addUsage(this._pUsageList[i]);
				}
			}
			this._pArrayElementType.setParent(this);

			this._pArrayIndexExpr = pExpr;

			this._iLength = this._pArrayIndexExpr.evaluate() ? this._pArrayIndexExpr.getEvalValue() :  0xffffff ;

			this._isArray = true;
		}

		addPointIndex(isStrict?: bool = true): void {
			this._nPointDim++;
			this._isPointer = true;
			if(isStrict){
				this._isStrictPointer = true;
			}
		}

		setVideoBuffer(pBuffer: IAFXVariableDeclInstruction): void {
			if(this.isPointIndex()){
				(<IAFXVariableDeclInstruction>this.getParent().getParent()).getType().setVideoBuffer(pBuffer);
				return;
			}

			this._pVideoBuffer = pBuffer;

			if(!this.isComplex()){
				return;
			}

			var pFieldNameList: string[] = this.getFieldNameList();

			for(var i:  number  = 0; i < pFieldNameList.length; i++){
				var pFieldType: IAFXVariableTypeInstruction = this.getFieldType(pFieldNameList[i]);

				if(pFieldType.isPointer()){
					pFieldType.setVideoBuffer(pBuffer);
				}
			}
		}

		initializePointers(): void {
			this._pPointerList = [];
			var pDownPointer: IAFXVariableDeclInstruction = this._getParentVarDecl();

			for(var i: number  = 0; i < this.getPointDim(); i++){
				var pPointer: IAFXVariableDeclInstruction = new VariableDeclInstruction();
				var pPointerType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
				var pPointerId: IAFXIdInstruction = new IdInstruction();

				pPointer.push(pPointerType, true);
				pPointer.push(pPointerId, true);

				pPointerType.pushType(getEffectBaseType("ptr"));
				pPointerId.setName( "undef" );
				pPointerId.setName(this._getParentVarDecl().getName() + "_pointer_" + i.toString());

				if(i > 0) {
					(this._pPointerList[i - 1].getType())._setUpDownPointers(pPointer, pDownPointer);
					pDownPointer = this._pPointerList[i - 1];
				}
				else{
					pPointerType._setUpDownPointers(null, pDownPointer);
				}

				pPointer.setParent(this._getParentVarDecl());
				this._pPointerList.push(pPointer);
			}

			this._pPointerList[this._pPointerList.length - 1].getType()._setUpDownPointers(null, pDownPointer);
			this._pUpPointIndex = this._pPointerList[0];
			this._pMainPointIndex = this._pPointerList[this._pPointerList.length - 1];
		}

		_setPointerToStrict(): void {
			this._isStrictPointer = true;
		}

		_addPointIndexInDepth(): void {
			if(!this.isComplex()){
				return;
			}

			var pFieldNameList: string[] = this.getFieldNameList();

			for(var i:  number  = 0; i < pFieldNameList.length; i++){
				var pFieldType: IAFXVariableTypeInstruction = this.getFieldType(pFieldNameList[i]);
				if(!pFieldType.isPointer()){
					pFieldType.addPointIndex(false);
					pFieldType._setVideoBufferInDepth();
				}
			}
		}

		_setVideoBufferInDepth(): void {
			if(this.isPointer()){
				this.setVideoBuffer(Effect.createVideoBufferVariable());
			}
			else if(this.isComplex() && this._containPointer()){
				var pFieldNameList: string[] = this.getFieldNameList();

				for(var i:  number  = 0; i < pFieldNameList.length; i++){
					var pFieldType: IAFXVariableTypeInstruction = this.getFieldType(pFieldNameList[i]);

					pFieldType._setVideoBufferInDepth();
				}
			}
		}

		inline _markAsUnverifiable(isUnverifiable: bool): void {
        	this._bUnverifiable = true;
        }

//-----------------------------------------------------------------//
//----------------------------GET TYPE INFO------------------------//
//-----------------------------------------------------------------//	

		getName(): string {
			return this._sName;
		}

		inline getRealName(): string {
			return this.getBaseType().getRealName();
		}

		getHash(): string {
			if(this._sHash === ""){
				this.calcHash();
			}

			return this._sHash;
		}

		getStrongHash(): string {
			if(this._sStrongHash === "") {
				this.calcStrongHash();
			}

			return this._sStrongHash;
		}

		getSize():  number  {
			if(this.isPointer() || this.isPointIndex()){
				return 1;
			}

			if(this._isArray){
				var iSize:  number  = this._pArrayElementType.getSize();
				if (this._iLength ===  0xffffff  ||
					iSize ===  0xffffff ){
					return  0xffffff ;
				}
				else{
					return iSize * this._iLength;
				}
			}
			else {
				return this.getSubType().getSize();
			}
		}

		getBaseType(): IAFXTypeInstruction{
 			return this.getSubType().getBaseType();
 		}

		getLength():  number  {
			if(!this.isNotBaseArray()){
				this._iLength = 0;
				return 0;
			}

			if(this.isNotBaseArray() && !this._isArray){
				this._iLength = this.getSubType().getLength();
			}
			else if(this._iLength ===  0xffffff ){
				var isEval: bool = this._pArrayIndexExpr.evaluate();

				if(isEval) {
					this._iLength = < number >this._pArrayIndexExpr.getEvalValue();
				}
			}

			return this._iLength;
		}

		getPadding():  number  {
			return this.isPointIndex() ? this._getDownPointer().getType().getPadding() : this._iPadding;
		}

		getArrayElementType(): IAFXVariableTypeInstruction {
			if(this._isUnverifiable()){
				return this;
			}

			if(!this.isArray()){
				return null;
			}

			if(isNull(this._pArrayElementType)){
				this._pArrayElementType = new VariableTypeInstruction();
				this._pArrayElementType.pushType(this.getSubType().getArrayElementType());
				if(!isNull(this._pUsageList)){
					for(var i:  number  = 0; i <  this._pUsageList.length; i++){
						this._pArrayElementType.addUsage(this._pUsageList[i]);
					}
				}
				this._pArrayElementType.setParent(this);
			}

			return this._pArrayElementType;
		}

		getTypeDecl(): IAFXTypeDeclInstruction {
			if(!this.isFromTypeDecl()){
				return null;
			}

			var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

			if(eParentType === EAFXInstructionTypes.k_TypeDeclInstruction){
				return <IAFXTypeDeclInstruction>this.getParent();
			}
			else {
				return (<IAFXTypeInstruction>this.getParent()).getTypeDecl();
			}
		}

		hasField(sFieldName: string): bool {
			return this._isUnverifiable() ? true : this.getSubType().hasField(sFieldName);
		}

		hasFieldWithSematic(sSemantic: string): bool {
			if(!this.isComplex()){
				return false;
			}

			return this.getSubType().hasFieldWithSematic(sSemantic);
		}

		hasAllUniqueSemantics(): bool {
			if(!this.isComplex()){
				return false;
			}

			return this.getSubType().hasAllUniqueSemantics();
		}

		hasFieldWithoutSemantic(): bool {
			if(!this.isComplex()){
				return false;
			}

			return this.getSubType().hasFieldWithoutSemantic();
		}

		getField(sFieldName: string): IAFXVariableDeclInstruction {
			if(!this.hasField(sFieldName)){
				return null;
			}

			if(isNull(this._pFieldDeclMap)) {
				this._pFieldDeclMap = <IAFXVariableDeclMap>{};
			}

			if(isDef(this._pFieldDeclMap[sFieldName])){
				return this._pFieldDeclMap[sFieldName];
			}

			var pField: IAFXVariableDeclInstruction = new VariableDeclInstruction();

			if(!this._isUnverifiable()){
				var pSubField: IAFXVariableDeclInstruction = this.getSubType().getField(sFieldName);

				var pFieldType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
				pFieldType.pushType(pSubField.getType());
				if(!this.isBase()){
					pFieldType.setPadding(pSubField.getType().getPadding());
				}
				pField.push(pFieldType, true);
				pField.push(pSubField.getNameId(), false);
			}
			else {
				var pFieldName: IAFXIdInstruction = new IdInstruction();

				pFieldName.setName(sFieldName);
				pFieldName.setRealName(sFieldName);

				pField.push(this, false);
				pField.push(pFieldName, true);
			}

			pField.setParent(this);

			this._pFieldDeclMap[sFieldName] = pField;

			return pField;
		}

		inline getFieldBySemantic(sSemantic: string): IAFXVariableDeclInstruction {
			if(this.hasFieldWithSematic(sSemantic)){
				return null;
			}

			if(isNull(this._pFieldDeclBySemanticMap)) {
				this._pFieldDeclBySemanticMap = <IAFXVariableDeclMap>{};
			}

			if(isDef(this._pFieldDeclBySemanticMap[sSemantic])){
				return this._pFieldDeclBySemanticMap[sSemantic];
			}

			var pField: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pSubField: IAFXVariableDeclInstruction = this.getSubType().getFieldBySemantic(sSemantic);

			var pFieldType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			pFieldType.pushType(pSubField.getType());
			if(!this.isBase()){
				pFieldType.setPadding(pSubField.getType().getPadding());
			}
			pField.push(pFieldType, true);
			pField.push(pSubField.getNameId(), false);


			pField.setParent(this);

			this._pFieldDeclBySemanticMap[sSemantic] = pField;

			return pField;
		}

		getFieldType(sFieldName: string): IAFXVariableTypeInstruction {
			return <IAFXVariableTypeInstruction>this.getField(sFieldName).getType();
		}

 		getFieldNameList(): string[] {
 			return this.getSubType().getFieldNameList();
 		}


 		inline getUsageList(): string[] {
 			return this._pUsageList;
 		}

		inline getSubType(): IAFXTypeInstruction {
			return this._pSubType;
		}

		hasUsage(sUsageName: string): bool {
			if(isNull(this._pUsageList)){
				return false;
			}

			for(var i:  number  = 0; i < this._pUsageList.length; i++){
				if(this._pUsageList[i] === sUsageName){
					return true;
				}
			}

			if(!isNull(this.getSubType()) && this.getSubType()._getInstructionType() === EAFXInstructionTypes.k_VariableTypeInstruction){
				return (<IAFXVariableTypeInstruction>this.getSubType()).hasUsage(sUsageName);
			}

			return false;
		}

		hasVideoBuffer(): bool {
			return !isNull(this.getVideoBuffer());
		}

		getPointDim():  number  {
			return this._nPointDim ||
				   ((this.getSubType()._getInstructionType() === EAFXInstructionTypes.k_VariableTypeInstruction) ?
				   (<IAFXVariableTypeInstruction>this.getSubType()).getPointDim() : 0);
		}

		getPointer(): IAFXVariableDeclInstruction {
			if (!this.isFromVariableDecl() ||
				!(this.isPointer() || this.isPointIndex()) || !this.hasVideoBuffer()){
				return null;
			}

			if(!isNull(this._pUpPointIndex)){
				return this._pUpPointIndex;
			}

			if(this.isPointIndex()){
				return null;
			}

			this.initializePointers();

			return this._pUpPointIndex;
		}

		getVideoBuffer(): IAFXVariableDeclInstruction {
			if(this.isPointIndex()) {
				return (<IAFXVariableDeclInstruction>this.getParent().getParent()).getType().getVideoBuffer();
			}

			return this._pVideoBuffer;
		}

		getFieldExpr(sFieldName: string): IAFXIdExprInstruction {
			if(!this.hasField(sFieldName)){
				return null;
			}
			var pField: IAFXVariableDeclInstruction = this.getField(sFieldName);
			var pExpr: IAFXIdExprInstruction = new IdExprInstruction();
			pExpr.push(pField.getNameId(), false);
			pExpr.setType(pField.getType());

			return pExpr;
		}

		getFieldIfExist(sFieldName: string): IAFXVariableDeclInstruction {
			if(isNull(this._pFieldDeclMap) && isDef(this._pFieldDeclMap[sFieldName])){
				return this._pFieldDeclMap[sFieldName];
			}
			else {
				return null;
			}
		}

		getSubVarDecls(): IAFXVariableDeclInstruction[] {
			if(!this.isComplex() && !this.isPointer()){
				return null;
			}

			if(isNull(this._pSubDeclList)){
				this.generateSubDeclList();
			}
			return this._pSubDeclList;
		}

		_getFullName(): string {
			if(!this.isFromVariableDecl()){
				return "Not from variable decl";
			}

			var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

			if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
				return (<IAFXVariableDeclInstruction>this.getParent())._getFullName();
			}
			else{
				return (<IAFXVariableTypeInstruction>this.getParent())._getFullName();
			}
		}

        _getVarDeclName(): string {
        	if(!this.isFromVariableDecl()){
        		return "";
        	}

        	var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

			if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
				return (<IAFXVariableDeclInstruction>this.getParent()).getName();
			}
			else{
				return (<IAFXVariableTypeInstruction>this.getParent())._getVarDeclName();
			}
        }

        _getTypeDeclName(): string {
        	if(!this.isFromVariableDecl()){
        		return "";
        	}

        	var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

			if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
				return (<IAFXTypeDeclInstruction>this.getParent()).getName();
			}
			else{
				return (<IAFXVariableTypeInstruction>this.getParent())._getTypeDeclName();
			}
        }

        _getParentVarDecl(): IAFXVariableDeclInstruction {
        	if(!this.isFromVariableDecl()){
        		return null;
        	}

        	var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

        	if(eParentType === EAFXInstructionTypes.k_VariableDeclInstruction){
        		return <IAFXVariableDeclInstruction>this.getParent();
        	}
        	else {
        		return (<IAFXVariableTypeInstruction>this.getParent())._getParentVarDecl();
        	}
        }

        _getParentContainer(): IAFXVariableDeclInstruction {
        	if(!this.isFromVariableDecl() || !this._isTypeOfField()){
        		return null;
        	}

        	var pContainerType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>this._getParentVarDecl().getParent();
        	if(!pContainerType.isFromVariableDecl()){
        		return null;
        	}

        	return pContainerType._getParentVarDecl();
        }

        _getMainVariable(): IAFXVariableDeclInstruction{
        	if(!this.isFromVariableDecl()){
        		return null;
        	}

        	if(this._isTypeOfField()){
        		return (<IAFXVariableTypeInstruction>this.getParent().getParent())._getMainVariable();
        	}
        	else {
        		return (<IAFXVariableDeclInstruction>this._getParentVarDecl());
        	}
        }

        _getMainPointer(): IAFXVariableDeclInstruction{
        	if(isNull(this._pMainPointIndex)){
        		if(isNull(this.getPointer())){
        			this._pMainPointIndex = this._getParentVarDecl()
        		}
        		else{
        			this._pMainPointIndex = this._getUpPointer().getType()._getMainPointer();
        		}
        	}

        	return this._pMainPointIndex;
        }

        _getUpPointer(): IAFXVariableDeclInstruction {
        	return this._pUpPointIndex;
        }

        _getDownPointer(): IAFXVariableDeclInstruction {
        	return this._pDownPointIndex;
        }

//-----------------------------------------------------------------//
//----------------------------SYSTEM-------------------------------//
//-----------------------------------------------------------------//		

		wrap(): IAFXVariableTypeInstruction {
			var pCloneType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			pCloneType.pushType(this);

			return pCloneType;
		}

		clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXVariableTypeInstruction {
			if(isDef(pRelationMap[this._getInstructionID()])){
    			return <IAFXVariableTypeInstruction>pRelationMap[this._getInstructionID()];
    		}

    		if(this._pParentInstruction === null ||
    		   !isDef(pRelationMap[this._pParentInstruction._getInstructionID()]) ||
    		   pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction) {
//pRelationMap[this._getInstructionID()] = this;
    			return this;
    		}

			var pClone: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>super.clone(pRelationMap);

			pClone.pushType(this._pSubType.clone(pRelationMap));
			if(!isNull(this._pUsageList)){
				for(var i:  number  = 0; i < this._pUsageList.length; i++){
					pClone.addUsage(this._pUsageList[i]);
				}
			}

			pClone._canWrite(this._isWritable);
			pClone._canRead(this._isReadable);
			pClone._setCloneHash(this._sHash, this._sStrongHash);
			pClone.setPadding(this.getPadding());

			if(this._isArray){
				this._setCloneArrayIndex(this._pArrayElementType.clone(pRelationMap),
										 this._pArrayIndexExpr.clone(pRelationMap),
										 this._iLength);
			}

			if(this._isPointer){
				var pClonePointerList: IAFXVariableDeclInstruction[] = null;
				if(!isNull(this._pPointerList)){
					pClonePointerList = new Array(this._pPointerList.length);
					var pDownPointer: IAFXVariableDeclInstruction = pClone._getParentVarDecl();

					for(var i:  number  = 0; i < this._pPointerList.length; i++){
						pClonePointerList[i] = this._pPointerList[i].clone(pRelationMap);

						if(i > 0) {
							(pClonePointerList[i - 1].getType())._setUpDownPointers(pClonePointerList[i], pDownPointer);
							pDownPointer = pClonePointerList[i - 1];
						}
						else{
							pClonePointerList[0].getType()._setUpDownPointers(null, pDownPointer);
						}
					}

					pClonePointerList[pClonePointerList.length - 1].getType()._setUpDownPointers(null, pDownPointer);
				}

				this._setClonePointeIndexes(this.getPointDim(), pClonePointerList);
			}

			if(!isNull(this._pFieldDeclMap)){
				var sFieldName: string = "";
				var pCloneFieldMap: IAFXVariableDeclMap= <IAFXVariableDeclMap>{};

				for(sFieldName in this._pFieldDeclMap){
					pCloneFieldMap[sFieldName] = this._pFieldDeclMap[sFieldName].clone(pRelationMap);
				}

				this._setCloneFields(pCloneFieldMap);
			}

			return pClone;
		}

		blend(pType: IAFXVariableTypeInstruction, eMode: EAFXBlendMode): IAFXVariableTypeInstruction {
			if(this === pType){
				return this;
			}

			if(eMode === EAFXBlendMode.k_Global){
				return null;
			}

			if (this.isComplex() !== pType.isComplex() ||
				(this.isNotBaseArray() !== pType.isNotBaseArray()) ||
				(this.isPointer() !== pType.isPointer())) {
				return null;
			}

			if (this.isNotBaseArray() || this.getLength() ===  0xffffff  ||
				this.getLength() !== pType.getLength()){
				return null;
			}

			var pBlendBaseType: IAFXTypeInstruction = this.getBaseType().blend(pType.getBaseType(), eMode);
			if(isNull(pBlendBaseType)){
				return null;
			}

			var pBlendType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			pBlendType.pushType(pBlendBaseType);

			if(this.isNotBaseArray()){
				var iLength:  number  = this.getLength();
				var pLengthExpr: IntInstruction = new IntInstruction();
				pLengthExpr.setValue(iLength);
				pBlendType.addArrayIndex(pLengthExpr);
			}

			return pBlendType;

		}

		_setCloneHash(sHash: string, sStrongHash: string): void {
			this._sHash = sHash;
			this._sStrongHash = sStrongHash;
		}

        _setCloneArrayIndex(pElementType: IAFXVariableTypeInstruction,
                            pIndexExpr: IAFXExprInstruction, iLength:  number ): void {
        	this._isArray = true;
        	this._pArrayElementType = pElementType;
        	this._pArrayIndexExpr = pIndexExpr;
        	this._iLength = iLength;
        }

        _setClonePointeIndexes(nDim:  number , pPointerList: IAFXVariableDeclInstruction[]): void {
        	this._isPointer = true;
        	this._nPointDim = nDim;
        	this._pPointerList = pPointerList;
        	if(!isNull(this._pPointerList)){
        		this._pUpPointIndex = this._pPointerList[0];
        	}
        }

        _setCloneFields(pFieldMap: IAFXVariableDeclMap): void {
        	this._pFieldDeclMap = pFieldMap;
        }

        inline _setUpDownPointers(pUpPointIndex: IAFXVariableDeclInstruction,
        						  pDownPointIndex: IAFXVariableDeclInstruction ): void {
			this._pUpPointIndex = pUpPointIndex;
			this._pDownPointIndex = pDownPointIndex;
		}

		private calcHash(): void {
			var sHash: string = this.getSubType().getHash();

			if(this._isArray){
				sHash += "[";

				var iLength:  number  = this.getLength();

				if(iLength ===  0xffffff ){
					sHash += "undef"
				}
				else{
					sHash += iLength.toString();
				}

				sHash += "]";
			}

			this._sHash = sHash;
		}

		private calcStrongHash(): void {
			var sStrongHash: string = this.getSubType().getStrongHash();

			if(this._isArray){
				sStrongHash += "[";

				var iLength:  number  = this.getLength();

				if(iLength ===  0xffffff ){
					sStrongHash += "undef"
				}
				else{
					sStrongHash += iLength.toString();
				}

				sStrongHash += "]";
			}
			if(this.isPointer()){
				for(var i:  number  = 0; i < this.getPointDim(); i++){
					sStrongHash = "@" + sStrongHash;
				}
			}


			this._sStrongHash = sStrongHash;
		}

		private generateSubDeclList(): void {
			if(!this.isComplex() && !this.isPointer()){
				return;
			}

			var pDeclList: IAFXVariableDeclInstruction[] = [];
			var i:  number  = 0;

			if(this.isPointer()){
				if(isNull(this._getUpPointer())){
					this.initializePointers();
				}

				for(i = 0; i < this._pPointerList.length; i++){
					pDeclList.push(this._pPointerList[i]);
				}
			}

			if(this.isComplex()){
				var pFieldNameList: string[] = this.getFieldNameList();

				for(i = 0; i < pFieldNameList.length; i++){
					var pField: IAFXVariableDeclInstruction = this.getField(pFieldNameList[i]);
					var pFieldSubDeclList: IAFXVariableDeclInstruction[] = pField.getSubVarDecls();

					if(!isNull(pFieldSubDeclList)){
						for(var j:  number  = 0; j < pFieldSubDeclList.length; j++){
							pDeclList.push(pFieldSubDeclList[j]);
						}
					}
				}
			}

			this._pSubDeclList = pDeclList;
		}
	}

	export class SystemTypeInstruction extends Instruction implements IAFXTypeInstruction {
		private _sName: string = "";
		private _sRealName: string = "";
		private _pElementType: IAFXTypeInstruction = null;
		private _iLength:  number  = 1;
		private _iSize:  number  = null;
		private _pFieldDeclMap: IAFXVariableDeclMap = null;
		private _isArray: bool = false;
		private _isWritable: bool = true;
		private _isReadable: bool = true;
		private _pFieldNameList: string[] = null;
		private _pWrapVariableType: IAFXVariableTypeInstruction = null;
		private _isBuiltIn: bool = true;
		private _sDeclString: string = "";

		constructor() {
			super();
			this._eInstructionType = EAFXInstructionTypes.k_SystemTypeInstruction;
			this._pWrapVariableType = new VariableTypeInstruction();
			this._pWrapVariableType.pushType(this);
		}

		_toDeclString(): string {
			return this._sDeclString;
		}

		toFinalCode(): string {
			return this._sRealName;
		}

		isBuiltIn(): bool {
			return this._isBuiltIn;
		}

        setBuiltIn(isBuiltIn: bool): void {
        	this._isBuiltIn = isBuiltIn;
        }

        setDeclString(sDecl: string): void {
        	this._sDeclString = sDecl;
        }

//-----------------------------------------------------------------//
//----------------------------SIMPLE TESTS-------------------------//
//-----------------------------------------------------------------//

		inline isBase(): bool {
			return true;
		}

		inline isArray(): bool {
			return this._isArray;
		}

		inline isNotBaseArray(): bool {
			return false;
		}

		inline isComplex(): bool {
			return false;
		}

		inline isEqual(pType: IAFXTypeInstruction): bool {
			return this.getHash() === pType.getHash();
		}

		inline isStrongEqual(pType: IAFXTypeInstruction): bool{
			return this.getStrongHash() === pType.getStrongHash();
		}

		inline isConst(): bool {
			return false;
		}

		isSampler(): bool{
			return this.getName() === "sampler" ||
				   this.getName() === "sampler2D" ||
				   this.getName() === "samplerCUBE";
		}


		inline isWritable(): bool {
			return this._isWritable;
		}

		inline isReadable(): bool {
			return this._isReadable;
		}

		_containArray(): bool {
			return false;
		}

        _containSampler(): bool {
        	return false;
        }

        _containPointer(): bool {
        	return false;
        }

        _containComplexType(): bool {
        	return false;
        }

//-----------------------------------------------------------------//
//----------------------------SET BASE TYPE INFO-------------------//
//-----------------------------------------------------------------//

		inline setName(sName: string): void {
			this._sName = sName;
		}

		inline setRealName(sRealName: string): void {
			this._sRealName = sRealName;
		}

		inline setSize(iSize:  number ): void {
			this._iSize = iSize;
		}

		inline _canWrite(isWritable: bool): void {
			this._isWritable = isWritable;
		}

		inline _canRead(isReadable: bool): void {
			this._isReadable = isReadable;
		}

//-----------------------------------------------------------------//
//---------------------------INIT API------------------------------//
//-----------------------------------------------------------------//

		addIndex(pType: IAFXTypeInstruction, iLength:  number ): void {
			this._pElementType = pType;
			this._iLength = iLength;
			this._iSize = iLength * pType.getSize();
			this._isArray = true;
		}

		addField(sFieldName: string, pType: IAFXTypeInstruction, isWrite?: bool = true,
				 sRealFieldName?: string = sFieldName): void {

			var pField: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pFieldType: VariableTypeInstruction = new VariableTypeInstruction();
			var pFieldId: IAFXIdInstruction = new IdInstruction();

			pFieldType.pushType(pType);
			pFieldType._canWrite(isWrite);

			pFieldId.setName(sFieldName);
			pFieldId.setRealName(sRealFieldName);

			pField.push(pFieldType, true);
			pField.push(pFieldId, true);

			if(isNull(this._pFieldDeclMap)){
				this._pFieldDeclMap = <IAFXVariableDeclMap>{};
			}

			this._pFieldDeclMap[sFieldName] = pField;

			if(isNull(this._pFieldNameList)){
				this._pFieldNameList = [];
			}

			this._pFieldNameList.push(sFieldName);
		}

//-----------------------------------------------------------------//
//----------------------------GET TYPE INFO------------------------//
//-----------------------------------------------------------------//

		inline getName(): string {
			return this._sName;
		}

		inline getRealName(): string {
			return this._sRealName;
		}

		inline getHash(): string {
			return this._sRealName;
		}

		inline getStrongHash(): string {
			return this._sName;
		}

		inline getSize():  number  {
			return this._iSize;
		}

		inline getBaseType(): IAFXTypeInstruction {
			return this;
		}

		inline getVariableType(): IAFXVariableTypeInstruction {
			return this._pWrapVariableType;
		}

		inline getArrayElementType(): IAFXTypeInstruction {
			return this._pElementType;
		}

		getTypeDecl(): IAFXTypeDeclInstruction {
			if(this.isBuiltIn()){
				return null;
			}

			return <IAFXTypeDeclInstruction>this.getParent();
		}


		inline getLength():  number  {
			return this._iLength;
		}

		inline hasField(sFieldName: string): bool {
			return isDef(this._pFieldDeclMap[sFieldName]);
		}

		hasFieldWithSematic(sSemantic: string): bool {
			return false;
		}

		hasAllUniqueSemantics(): bool {
			return false;
		}

		hasFieldWithoutSemantic(): bool {
			return false;
		}

		inline getField(sFieldName: string): IAFXVariableDeclInstruction {
			return isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName] : null;
		}

		inline getFieldBySemantic(sSemantic: string): IAFXVariableDeclInstruction {
			return null;
		}

		inline getFieldType(sFieldName: string): IAFXVariableTypeInstruction {
			return isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName].getType() : null;
		}

		inline getFieldNameList(): string[] {
			return this._pFieldNameList;
		}

//-----------------------------------------------------------------//
//----------------------------SYSTEM-------------------------------//
//-----------------------------------------------------------------//

		inline clone(pRelationMap?: IAFXInstructionMap): SystemTypeInstruction {
			return this;
		}

		inline blend(pType: IAFXTypeInstruction, eMode: EAFXBlendMode): IAFXTypeInstruction {
			if(this.isStrongEqual(pType)){
				return this;
			}

			return null;
		}
	}

	export class ComplexTypeInstruction extends Instruction implements IAFXTypeInstruction {
		private _sName: string = "";
		private _sRealName: string = "";

		private _sHash: string = "";
		private _sStrongHash: string = "";

		private _iSize:  number  = 0;

		private _pFieldDeclMap: IAFXVariableDeclMap = null;
		private _pFieldDeclList: IAFXVariableDeclInstruction[] = null;
		private _pFieldNameList: string[] = null;

		private _pFieldDeclBySemanticMap: IAFXVariableDeclMap = null;
		private _hasAllUniqueSemantics: bool = true;
		private _hasFieldWithoutSemantic: bool = false;

		private _isContainArray: bool = false;
		private _isContainSampler: bool = false;
		private _isContainPointer: bool = false;
		private _isContainComplexType: bool = false;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_ComplexTypeInstruction;
		}

		_toDeclString(): string {
			var sCode: string = "struct " + this._sRealName + "{";

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
				sCode += "\t" + this._pFieldDeclList[i].toFinalCode() + ";\n";
			}

			sCode += "}";

			return sCode;
		}

		toFinalCode(): string {
			return this._sRealName;
		}

		isBuiltIn(): bool {
			return false;
		}

        setBuiltIn(isBuiltIn: bool): void {
        }

//-----------------------------------------------------------------//
//----------------------------SIMPLE TESTS-------------------------//
//-----------------------------------------------------------------//

		inline isBase(): bool {
			return false;
		}

		inline isArray(): bool {
			return false;
		}

		inline isNotBaseArray(): bool {
			return false;
		}

		inline isComplex(): bool {
			return true;
		}

		inline isEqual(pType: IAFXTypeInstruction): bool {
			return this.getHash() === pType.getHash();
		}

		inline isStrongEqual(pType: IAFXTypeInstruction): bool {
			return this.getStrongHash() === pType.getStrongHash();
		}

		inline isConst(): bool {
			return false;
		}

		isSampler(): bool{
			return false;
		}

		inline isWritable(): bool {
			return true;
		}

		inline isReadable(): bool {
			return true;
		}

		inline _containArray(): bool {
			return this._isContainArray;
		}

		inline _containSampler(): bool {
			return this._isContainSampler;
		}

		inline _containPointer(): bool {
			return this._isContainPointer;
		}

		inline _containComplexType(): bool {
			return this._isContainComplexType;
		}

//-----------------------------------------------------------------//
//----------------------------SET BASE TYPE INFO-------------------//
//-----------------------------------------------------------------//

		inline setName(sName: string): void {
			this._sName = sName;
			this._sRealName = sName + "R";
		}

		inline setRealName(sRealName: string): void {
			this._sRealName = sRealName;
		}

		inline setSize(iSize:  number ): void {
			this._iSize = iSize;
		}

		inline _canWrite(isWritable: bool): void {
		}

		inline _canRead(isWritable: bool): void {
		}

//-----------------------------------------------------------------//
//----------------------------INIT API-----------------------------//
//-----------------------------------------------------------------//

		addField(pVariable: IAFXVariableDeclInstruction): void {
			if(isNull(this._pFieldDeclMap)){
				this._pFieldDeclMap = <IAFXVariableDeclMap>{};
				this._pFieldNameList = [];
			}

			if(isNull(this._pFieldDeclList)){
				this._pFieldDeclList = [];
			}

			var sVarName: string = pVariable.getName();
			this._pFieldDeclMap[sVarName] = pVariable;

			if(this._iSize !==  0xffffff ){
				var iSize:  number  = pVariable.getType().getSize();
				if(iSize !==  0xffffff ){
					this._iSize += iSize;
				}
				else{
					this._iSize =  0xffffff ;
				}
			}

			this._pFieldNameList.push(sVarName);

			if(this._pFieldDeclList.length < this._pFieldNameList.length){
				this._pFieldDeclList.push(pVariable);
			}

			var pType: IAFXVariableTypeInstruction = pVariable.getType();
//pType._markAsField();

			if(pType.isNotBaseArray() || pType._containArray()){
				this._isContainArray = true;
			}

			if(isSamplerType(pType) || pType._containSampler()){
				this._isContainSampler = true;
			}

			if(pType.isPointer() || pType._containPointer()){
				this._isContainPointer = true;
			}

			if(pType.isComplex()){
				this._isContainComplexType = true;
			}
		}

		addFields(pFieldCollector: IAFXInstruction, isSetParent?: bool = true): void {
			this._pFieldDeclList = <IAFXVariableDeclInstruction[]>(pFieldCollector.getInstructions());

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
		    	this.addField(this._pFieldDeclList[i]);
		    	this._pFieldDeclList[i].setParent(this);
		    }

		    this.calculatePaddings();
		}

//-----------------------------------------------------------------//
//----------------------------GET TYPE INFO------------------------//
//-----------------------------------------------------------------//

		inline getName(): string {
			return this._sName;
		}

		inline getRealName(): string {
			return this._sRealName;
		}

		getHash(): string {
			if(this._sHash === ""){
				this.calcHash();
			}

			return this._sHash;
		}

		getStrongHash(): string {
			if(this._sStrongHash === ""){
				this.calcStrongHash();
			}

			return this._sStrongHash;
		}

		inline hasField(sFieldName: string): bool {
			return isDef(this._pFieldDeclMap[sFieldName]);
		}

		hasFieldWithSematic(sSemantic: string): bool {
			if(isNull(this._pFieldDeclBySemanticMap)) {
				this.analyzeSemantics();
			}

			return isDef(this._pFieldDeclBySemanticMap[sSemantic]);
		}

		hasAllUniqueSemantics(): bool {
			if(isNull(this._pFieldDeclBySemanticMap)) {
				this.analyzeSemantics();
			}
			return this._hasAllUniqueSemantics;
		}

		hasFieldWithoutSemantic(): bool {
			if(isNull(this._pFieldDeclBySemanticMap)) {
				this.analyzeSemantics();
			}
			return this._hasFieldWithoutSemantic;
		}

		inline getField(sFieldName: string): IAFXVariableDeclInstruction {
			if(!this.hasField(sFieldName)){
				return null;
			}

			return this._pFieldDeclMap[sFieldName];
		}

		getFieldBySemantic(sSemantic: string): IAFXVariableDeclInstruction {
			if(!this.hasFieldWithSematic(sSemantic)){
				return null;
			}

			return this._pFieldDeclBySemanticMap[sSemantic];
		}

		inline getFieldType(sFieldName: string): IAFXVariableTypeInstruction {
			return isDef(this._pFieldDeclMap[sFieldName]) ? this._pFieldDeclMap[sFieldName].getType() : null;
		}

		inline getFieldNameList(): string[] {
			return this._pFieldNameList;
		}

		inline getSize():  number  {
			if(this._iSize ===  0xffffff ){
				this._iSize = this._calcSize();
			}
			return this._iSize;
		}

		inline getBaseType(): IAFXTypeInstruction {
			return this;
		}

		inline getArrayElementType(): IAFXTypeInstruction {
			return null;
		}

		getTypeDecl(): IAFXTypeDeclInstruction {
			return <IAFXTypeDeclInstruction>this.getParent();
		}

		inline getLength():  number  {
			return 0;
		}

		_getFieldDeclList(): IAFXVariableDeclInstruction[] {
			return this._pFieldDeclList;
		}

//-----------------------------------------------------------------//
//----------------------------SYSTEM-------------------------------//
//-----------------------------------------------------------------//

		inline clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): ComplexTypeInstruction {
			if(this._pParentInstruction === null ||
    		   !isDef(pRelationMap[this._pParentInstruction._getInstructionID()]) ||
    		   pRelationMap[this._pParentInstruction._getInstructionID()] === this._pParentInstruction){
//pRelationMap[this._getInstructionID()] = this;
    			return this;
    		}

    		var pClone: ComplexTypeInstruction = <ComplexTypeInstruction>super.clone(pRelationMap);

    		pClone._setCloneName(this._sName, this._sRealName);
    		pClone._setCloneHash(this._sHash, this._sStrongHash);
    		pClone._setCloneContain(this._isContainArray, this._isContainSampler);

    		var pFieldDeclList: IAFXVariableDeclInstruction[] = new Array(this._pFieldDeclList.length);
    		var pFieldNameList: string[] = new Array(this._pFieldNameList.length);
    		var pFieldDeclMap: IAFXVariableDeclMap = <IAFXVariableDeclMap>{};

    		for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
    			var pCloneVar: IAFXVariableDeclInstruction = this._pFieldDeclList[i].clone(pRelationMap);
    			var sVarName: string = pCloneVar.getName();

    			pFieldDeclList[i] = pCloneVar;
    			pFieldNameList[i] = sVarName;
    			pFieldDeclMap[sVarName] = pCloneVar;
    		}

    		pClone._setCloneFields(pFieldDeclList, pFieldNameList,
				   				   pFieldDeclMap);
    		pClone.setSize(this._iSize);

			return pClone;
		}

		blend(pType: IAFXTypeInstruction, eMode: EAFXBlendMode): IAFXTypeInstruction {
			if(pType === this){
				return this;
			}

			if(eMode === EAFXBlendMode.k_TypeDecl){
				return null;
			}

			if(eMode === EAFXBlendMode.k_Uniform || eMode === EAFXBlendMode.k_Attribute){
				if(this.hasFieldWithoutSemantic() || pType.hasFieldWithoutSemantic()){
					return null;
				}
			}

			var pFieldList: IAFXVariableDeclInstruction[] = this._pFieldDeclList;
			var pBlendType: ComplexTypeInstruction = new ComplexTypeInstruction();
			var pRelationMap: IAFXInstructionMap = <IAFXInstructionMap>{};

			if(isNull(pFieldList)){
				logger.setSourceLocation( "fx/TypeInstruction.ts" , 1825 ); logger.log(this, pType); ;
			}

			for(var i:  number  = 0; i < pFieldList.length; i++){
				var pField: IAFXVariableDeclInstruction = pFieldList[i];
				var pBlendField: IAFXVariableDeclInstruction = null;
				var sFieldName: string = pField.getName();
				var sFieldSemantic: string = pField.getSemantic();

				if(eMode === EAFXBlendMode.k_Shared){
					if(pType.hasField(sFieldName)){
						pBlendField = pField.blend(pType.getField(sFieldName), eMode);
					}
					else {
						pBlendField = pField.clone(pRelationMap);
					}
				}
				else if(eMode === EAFXBlendMode.k_Attribute ||
						eMode === EAFXBlendMode.k_Uniform ||
						eMode === EAFXBlendMode.k_VertexOut) {

					if(pType.hasFieldWithSematic(sFieldSemantic)){
						pBlendField = pField.blend(pType.getFieldBySemantic(sFieldSemantic), eMode);
					}
					else {
						pBlendField = pField.clone(pRelationMap);
					}

					if(!isNull(pBlendField)){
						pBlendField.getNameId().setName(sFieldSemantic);
						pBlendField.getNameId().setRealName(sFieldSemantic);
					}
				}

				if(isNull(pBlendField)){
					return null;
				}

				pBlendType.addField(pBlendField);
			}

			pFieldList = (<ComplexTypeInstruction>pType)._getFieldDeclList();

			for(var i:  number  = 0; i < pFieldList.length; i++){
				var pField: IAFXVariableDeclInstruction = pFieldList[i];
				var pBlendField: IAFXVariableDeclInstruction = null;
				var sFieldName: string = pField.getName();
				var sFieldSemantic: string = pField.getSemantic();

				if(eMode === EAFXBlendMode.k_Shared){
					if(!this.hasField(sFieldName)){
						pBlendField = pField.clone(pRelationMap);
					}
				}
				else if(eMode === EAFXBlendMode.k_Attribute ||
						eMode === EAFXBlendMode.k_Uniform ||
						eMode === EAFXBlendMode.k_VertexOut) {

					if(!this.hasFieldWithSematic(sFieldSemantic)){
						pBlendField = pField.clone(pRelationMap);
						pBlendField.getNameId().setName(sFieldSemantic);
						pBlendField.getNameId().setRealName(sFieldSemantic);
					}
				}

				if(!isNull(pBlendField)){
					pBlendType.addField(pBlendField);
				}
			}

			pBlendType.setName(this.getName());
			pBlendType.setRealName(this.getRealName());

			return pBlendType;
		}

		_setCloneName(sName: string, sRealName: string): void {
			this._sName = sName;
			this._sRealName = sRealName;
		}

		_setCloneHash(sHash: string, sStrongHash: string): void {
			this._sHash = sHash;
			this._sStrongHash = sStrongHash;
		}

		_setCloneContain(isContainArray: bool, isContainSampler: bool): void{
			this._isContainArray = isContainArray;
			this._isContainSampler = isContainSampler;
		}

		_setCloneFields(pFieldDeclList: IAFXVariableDeclInstruction[], pFieldNameList: string[],
				   		pFieldDeclMap: IAFXVariableDeclMap): void{
			this._pFieldDeclList = pFieldDeclList;
			this._pFieldNameList = pFieldNameList;
			this._pFieldDeclMap = pFieldDeclMap;
		}

		_calcSize():  number  {
			var iSize:  number  = 0;

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
				var iFieldSize:  number  = this._pFieldDeclList[i].getType().getSize();

				if(iFieldSize ===  0xffffff ){
					iSize =  0xffffff ;
					break;
				}
				else{
					iSize += iFieldSize;
				}
			}

			return iSize;
		}

		private calcHash(): void {
			var sHash: string = "{";

			for(var i: number  = 0; i < this._pFieldDeclList.length; i++){
				sHash += this._pFieldDeclList[i].getType().getHash() + ";";
			}

			sHash += "}";

			this._sHash = sHash;
		}

		private calcStrongHash(): void {
			var sStrongHash: string = "{";

			for(var i: number  = 0; i < this._pFieldDeclList.length; i++){
				sStrongHash += this._pFieldDeclList[i].getType().getStrongHash() + ";";
			}

			sStrongHash += "}";

			this._sStrongHash = sStrongHash;
		}

		private analyzeSemantics(): void {
			this._pFieldDeclBySemanticMap = <IAFXVariableDeclMap>{};

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
				var pVar: IAFXVariableDeclInstruction = this._pFieldDeclList[i];
				var sSemantic: string = pVar.getSemantic();

				if(sSemantic === ""){
					this._hasFieldWithoutSemantic = true;
				}

				if(isDef(this._pFieldDeclBySemanticMap[sSemantic])){
					this._hasAllUniqueSemantics = false;
				}

				this._pFieldDeclBySemanticMap[sSemantic] = pVar;

				this._hasFieldWithoutSemantic = this._hasFieldWithoutSemantic || pVar.getType().hasFieldWithoutSemantic();
				if(this._hasAllUniqueSemantics && pVar.getType().isComplex()){
					this._hasAllUniqueSemantics = pVar.getType().hasAllUniqueSemantics();
				}
			}

		}

		private calculatePaddings(): void {
			var iPadding:  number  = 0;

			for(var i:  number  = 0; i < this._pFieldDeclList.length; i++){
				var pVarType: IAFXVariableTypeInstruction = this._pFieldDeclList[i].getType();
				var iVarSize:  number  = pVarType.getSize();

				if(iVarSize ===  0xffffff ){
					this.setError( 2272 , {typeName: this.getName()});
					return;
				}

				pVarType.setPadding(iPadding);
				iPadding += iVarSize;
			}
		}
	}
}























module akra.fx {
	export class ExprInstruction extends TypedInstruction implements IAFXExprInstruction {
		/**@protected*/  _pLastEvalResult: any = null;

/**
		 * Respresent all kind of instruction
		 */

		constructor(){
			super();
			this._eInstructionType = EAFXInstructionTypes.k_ExprInstruction;
		}

		evaluate(): bool {
			return false;
		}

		simplify(): bool {
			return false;
		}

		getEvalValue(): any {
			return this._pLastEvalResult;
		}

		isConst(): bool {
			return false;
		}

		getType(): IAFXVariableTypeInstruction{
			return <IAFXVariableTypeInstruction>super.getType();
		}

		clone(pRelationMap?:IAFXInstructionMap): IAFXExprInstruction {
			return <IAFXExprInstruction>super.clone(pRelationMap);
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pInstructionList: IAFXAnalyzedInstruction[] = <IAFXAnalyzedInstruction[]>this.getInstructions();

			if(isNull(pInstructionList)){
				return;
			}

			for(var i:  number  = 0; i < this._nInstructions; i++){
				pInstructionList[i].addUsedData(pUsedDataCollector, eUsedMode);
			}
		}
	}

	export class IntInstruction extends ExprInstruction implements IAFXLiteralInstruction {
		private _iValue:  number ;
/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._iValue = 0;
			this._pType = getEffectBaseType("int").getVariableType();
			this._eInstructionType = EAFXInstructionTypes.k_IntInstruction;
		}

		inline setValue(iValue:  number ): void{
			this._iValue = iValue;
		}

		toString(): string {
			return <string><any>this._iValue;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this._iValue.toString();
			return sCode;
		}

		evaluate(): bool {
			this._pLastEvalResult = this._iValue;
			return true;
		}

		inline isConst(): bool {
			return true;
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction {
			var pClonedInstruction: IAFXLiteralInstruction = <IAFXLiteralInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setValue(this._iValue);
			return pClonedInstruction;
		}
	}

	export class FloatInstruction extends ExprInstruction implements IAFXLiteralInstruction {
		private _fValue:  number ;
/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._fValue = 0.0;
			this._pType = getEffectBaseType("float").getVariableType();
			this._eInstructionType = EAFXInstructionTypes.k_FloatInstruction;
		}

		inline setValue(fValue:  number ): void{
			this._fValue = fValue;
		}

		toString(): string {
			return <string><any>this._fValue;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this._fValue.toString();
			if(this._fValue % 1 === 0){
				sCode += ".";
			}
			return sCode;
		}

		evaluate(): bool {
			this._pLastEvalResult = this._fValue;
			return true;
		}

		inline isConst(): bool {
			return true;
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction {
			var pClonedInstruction: IAFXLiteralInstruction = <IAFXLiteralInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setValue(this._fValue);
			return pClonedInstruction;
		}
	}

	export class BoolInstruction extends ExprInstruction implements IAFXLiteralInstruction {
		private _bValue: bool;
		static private _pBoolType: IAFXVariableTypeInstruction = null;
/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._bValue = true;
			this._pType = getEffectBaseType("bool").getVariableType();
			this._eInstructionType = EAFXInstructionTypes.k_BoolInstruction;
		}

		inline setValue(bValue: bool): void{
			this._bValue = bValue;
		}

		toString(): string {
			return <string><any>this._bValue;
		}

		toFinalCode(): string {
			if(this._bValue){
				return "true";
			}
			else {
				return "false";
			}
		}

		evaluate(): bool {
			this._pLastEvalResult = this._bValue;
			return true;
		}

		inline isConst(): bool {
			return true;
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction {
			var pClonedInstruction: IAFXLiteralInstruction = <IAFXLiteralInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setValue(this._bValue);
			return pClonedInstruction;
		}
	}

	export class StringInstruction extends ExprInstruction implements IAFXLiteralInstruction {
		private _sValue: string;
		static private _pStringType: IAFXVariableTypeInstruction = null;

/**
		 * EMPTY_OPERATOR EMPTY_ARGUMENTS
		 */

		constructor() {
			super();
			this._sValue = "";
			this._pType = getEffectBaseType("string").getVariableType();
			this._eInstructionType = EAFXInstructionTypes.k_StringInstruction;
		}

		inline setValue(sValue: string): void{
			this._sValue = sValue;
		}

		toString(): string {
			return this._sValue;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this._sValue;
			return sCode;
		}

		evaluate(): bool {
			this._pLastEvalResult = this._sValue;
			return true;
		}

		inline isConst(): bool {
			return true;
		}

		clone(pRelationMap?: IAFXInstructionMap): IAFXLiteralInstruction {
			var pClonedInstruction: IAFXLiteralInstruction = <IAFXLiteralInstruction>(super.clone(pRelationMap));
			pClonedInstruction.setValue(this._sValue);
			return pClonedInstruction;
		}
	}

	export class IdExprInstruction extends ExprInstruction implements IAFXIdExprInstruction {
		private _pType: IAFXVariableTypeInstruction = null;
		private _bToFinalCode: bool = true;
		private _isInPassUnifoms: bool = false;
		private _isInPassForeigns: bool = false;

		inline isVisible(): bool {
			return this._pInstructionList[0].isVisible();
		}

		constructor(){
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_IdExprInstruction;
		}

		getType(): IAFXVariableTypeInstruction {
			if(!isNull(this._pType)){
				return this._pType;
			}
			else{
				var pVar: IdInstruction = <IdInstruction>this._pInstructionList[0];
				this._pType = (<IAFXVariableDeclInstruction>pVar.getParent()).getType();
				return this._pType;
			}
		}

		isConst(): bool {
			return this.getType().isConst();
		}

		evaluate(): bool {
			return false;
		}

		prepareFor(eUsedMode: EFunctionType): void {
			if(!this.isVisible()){
				this._bToFinalCode = false;
			}

			if(eUsedMode === EFunctionType.k_PassFunction){
				var pVarDecl: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getInstructions()[0].getParent();
				if(!this.getType()._isUnverifiable() && isNull(pVarDecl.getParent())){
					if(pVarDecl.getType().isForeign()){
						this._isInPassForeigns = true;
					}
					else {
						this._isInPassUnifoms = true;
					}
				}
			}
		}

		toFinalCode(): string {
			var sCode: string = "";
			if(this._bToFinalCode){
				if(this._isInPassForeigns){
					sCode += "foreigns[" + this.getInstructions()[0].toFinalCode() + "]";
				}
				else if(this._isInPassUnifoms){
					sCode += "uniforms[" + this.getInstructions()[0].toFinalCode() + "]";
				}
				else {
					sCode += this.getInstructions()[0].toFinalCode();
				}
			}
			return sCode;
		}

		clone(pRelationMap?:IAFXInstructionMap): IAFXIdExprInstruction {
			return <IAFXIdExprInstruction>super.clone(pRelationMap);
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			if(!this.getType().isFromVariableDecl()) {
				return;
			}

			var pInfo: IAFXTypeUseInfoContainer = null;
			pInfo = pUsedDataCollector[this.getType()._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: this.getType(),
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[this.getType()._getInstructionID()] = pInfo;
			}

			if(eUsedMode !== EVarUsedMode.k_Write && eUsedMode !== EVarUsedMode.k_Undefined){
				pInfo.isRead = true;
				pInfo.numRead++;
			}

			if(eUsedMode === EVarUsedMode.k_Write || eUsedMode === EVarUsedMode.k_ReadWrite) {
				pInfo.isWrite = true;
				pInfo.numWrite++;
			}

			pInfo.numUsed++;
		}
	}

/**
 	 * Represent someExpr + / - * % someExpr
 	 * (+|-|*|/|%) Instruction Instruction
 	 */

	export class ArithmeticExprInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_ArithmeticExprInstruction;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			super.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}

		evaluate(): bool {
			var pOperands: IAFXExprInstruction[] = <IAFXExprInstruction[]>this.getInstructions();
			var pValL: any = pOperands[0].evaluate() ? pOperands[0].getEvalValue() : null;
			var pValR: any = pOperands[1].evaluate() ? pOperands[1].getEvalValue() : null;

			if(isNull(pValL) || isNull(pValR)){
				return false;
			}

			try{
				switch(this.getOperator()){
					case "+":
						this._pLastEvalResult = pValL + pValR;
						break;
					case "-":
						this._pLastEvalResult = pValL - pValR;
						break;
					case "*":
						this._pLastEvalResult = pValL * pValR;
						break;
					case "/":
						this._pLastEvalResult = pValL / pValR;
						break;
					case "%":
						this._pLastEvalResult = pValL % pValR;
						break;
				}
				return true;
			}
			catch(e){
				return false;
			}
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();
			sCode += this.getInstructions()[1].toFinalCode();
			return sCode;
		}
	}
/**
 	 * Represent someExpr = += -= /= *= %= someExpr
 	 * (=|+=|-=|*=|/=|%=) Instruction Instruction
 	 */

	export class AssignmentExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_AssignmentExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();
			sCode += this.getInstructions()[1].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var sOperator: string = this.getOperator();
			var pSubExprLeft: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
			var pSubExprRight: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];

			if(eUsedMode === EVarUsedMode.k_Read || sOperator !== "="){
				pSubExprLeft.addUsedData(pUsedDataCollector, EVarUsedMode.k_ReadWrite);
			}
			else {
				pSubExprLeft.addUsedData(pUsedDataCollector, EVarUsedMode.k_Write);
			}

			pSubExprRight.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}
	}
/**
 	 * Represent someExpr == != < > <= >= someExpr
 	 * (==|!=|<|>|<=|>=) Instruction Instruction
 	 */

	export class RelationalExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_RelationalExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();
			sCode += this.getInstructions()[1].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			super.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}
	}
/**
 	 * Represent boolExpr && || boolExpr
 	 * (&& | ||) Instruction Instruction
 	 */

	export class LogicalExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_LogicalExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();
			sCode += this.getInstructions()[1].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			super.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}
	}
/**
	 * Represen boolExpr ? someExpr : someExpr
	 * EMPTY_OPERATOR Instruction Instruction Instruction 
	 */

	export class ConditionalExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null, null, null];
			this._eInstructionType = EAFXInstructionTypes.k_ConditionalExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "?";
			sCode += this.getInstructions()[1].toFinalCode();
			sCode += ":";
			sCode += this.getInstructions()[2].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			super.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
		}
	}
/**
	 * Represent (type) expr
	 * EMPTY_OPERATOR VariableTypeInstruction Instruction
	 */

	export class CastExprInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_CastExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "(";
			sCode += this.getInstructions()[1].toFinalCode();
			sCode += ")";
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];
			pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);

// pUsedDataCollector[this.getType()._getInstructionID()] = this.getType();
		}
	}

/**
	 * Represent + - ! ++ -- expr
	 * (+|-|!|++|--|) Instruction
	 */

	export class UnaryExprInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_UnaryExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";
			sCode += this.getOperator();
			sCode += this.getInstructions()[0].toFinalCode();
			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			if(this.getOperator() === "++" || this.getOperator() === "--"){
				(<IAFXExprInstruction>this.getInstructions()[0]).addUsedData(pUsedDataCollector, EVarUsedMode.k_ReadWrite);
			}
			else {
				(<IAFXExprInstruction>this.getInstructions()[0]).addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
			}
        }
	}

/**
	 * Represent someExpr[someIndex]
	 * EMPTY_OPERATOR Instruction ExprInstruction
	 */

	export class PostfixIndexInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_PostfixIndexInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "[" + this.getInstructions()[1].toFinalCode() + "]";

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
			var pIndex: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];

			pSubExpr.addUsedData(pUsedDataCollector, eUsedMode);
			pIndex.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
        }
	}

/*
	 * Represent someExpr.id
	 * EMPTY_OPERATOR Instruction IdInstruction
	 */

	export class PostfixPointInstruction extends ExprInstruction {
		private _bToFinalFirst: bool = true;
		private _bToFinalSecond: bool = true;

		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_PostfixPointInstruction;
		}

		prepareFor(eUsedMode: EFunctionType){
			if(!this.getInstructions()[0].isVisible()){
				this._bToFinalFirst = false;
			}

			if(!this.getInstructions()[1].isVisible()){
				this._bToFinalSecond = false;
			}

			this.getInstructions()[0].prepareFor(eUsedMode);
			this.getInstructions()[1].prepareFor(eUsedMode);
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this._bToFinalFirst ? this.getInstructions()[0].toFinalCode() : "";
			sCode += this._bToFinalFirst ? "." : "";
			sCode += this._bToFinalSecond ? this.getInstructions()[1].toFinalCode(): "";

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
			var pPoint: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];

			pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Undefined);
			pPoint.addUsedData(pUsedDataCollector, eUsedMode);
        }
	}

/**
	 * Represent someExpr ++
	 * (-- | ++) Instruction
	 */

	export class PostfixArithmeticInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_PostfixArithmeticInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();
			sCode += this.getOperator();

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
			pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_ReadWrite);
		}
	}

/**
	 * Represent @ Expr
	 * @ Instruction
	 */

	export class PrimaryExprInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_PrimaryExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pPointerType: IAFXVariableTypeInstruction = this.getType();
			var pInfo: IAFXTypeUseInfoContainer = pUsedDataCollector[pPointerType._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: pPointerType,
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[pPointerType._getInstructionID()] = pInfo;
			}

			if(eUsedMode === EVarUsedMode.k_Read){
				pInfo.isRead = true;
				pInfo.numRead++;
			}
			else if(eUsedMode === EVarUsedMode.k_Write){
				pInfo.isWrite = true;
				pInfo.numWrite++;
			}
			else if(eUsedMode === EVarUsedMode.k_ReadWrite){
				pInfo.isRead = true;
				pInfo.isWrite = true;
				pInfo.numRead++;
				pInfo.numWrite++;
			}

			pInfo.numUsed++;
		}
	}

/**
	 * Represent (expr)
	 * EMPTY_OPERATOR ExprInstruction
	 */

	export class ComplexExprInstruction extends ExprInstruction {
		constructor(){
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_ComplexExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += "(" + this.getInstructions()[0].toFinalCode() + ")";

			return sCode;
		}

// addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
//                   eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
// 	var pSubExpr: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];
// 	pSubExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
// }
	}

/**
	 * Respresnt func(arg1,..., argn)
	 * EMPTY_OPERATOR IdExprInstruction ExprInstruction ... ExprInstruction 
	 */

	export class FunctionCallInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_FunctionCallInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "(";
			for(var i:  number  = 1; i < this._nInstructions; i++){
				sCode += this.getInstructions()[1].toFinalCode();
				if(i !== this._nInstructions - 1){
					sCode +=","
				}
			}
			sCode += ")"

			return sCode;
		}

		getFunction(): IAFXFunctionDeclInstruction{
			return <IAFXFunctionDeclInstruction>(<IAFXIdExprInstruction>this._pInstructionList[0]).getType().getParent().getParent();
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pExprList: IAFXExprInstruction[] = <IAFXExprInstruction[]>this.getInstructions();
			var pFunction: IAFXFunctionDeclInstruction = this.getFunction();
			var pArguments: IAFXVariableDeclInstruction[] = <IAFXVariableDeclInstruction[]>pFunction.getArguments();

			pExprList[0].addUsedData(pUsedDataCollector, eUsedMode);

			for(var i: number  = 0; i < pArguments.length; i++){
				if (pArguments[i].getType().hasUsage("out")){
					pExprList[i+1].addUsedData(pUsedDataCollector, EVarUsedMode.k_Write);
				}
				else if(pArguments[i].getType().hasUsage("inout")){
					pExprList[i+1].addUsedData(pUsedDataCollector, EVarUsedMode.k_ReadWrite);
				}
				else {
					pExprList[i+1].addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
				}
			}
		}
	}

/**
	 * Respresnt system_func(arg1,..., argn)
	 * EMPTY_OPERATOR SimpleInstruction ... SimpleInstruction 
	 */

	export class SystemCallInstruction extends ExprInstruction {
		private _pSystemFunction: SystemFunctionInstruction = null;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_SystemCallInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			if(isNull(this.getInstructions())){
				logger.setSourceLocation( "fx/ExprInstruction.ts" , 825 ); logger.log(this); ;
			}
			for(var i:  number  = 0; i < this.getInstructions().length; i++){
				sCode += this.getInstructions()[i].toFinalCode();
			}

			return sCode;
		}

		setSystemCallFunction(pFunction: IAFXFunctionDeclInstruction): void{
			this._pSystemFunction = <SystemFunctionInstruction>pFunction;
			this.setType(pFunction.getType());
		}

		setInstructions(pInstructionList: IAFXInstruction[]): void {
			this._pInstructionList = pInstructionList;
			this._nInstructions = pInstructionList.length;
			for(var i:  number  = 0; i < pInstructionList.length; i++){
				pInstructionList[i].setParent(this);
			}
		}

		fillByArguments(pArguments: IAFXInstruction[]): void{
			this.setInstructions(this._pSystemFunction.closeArguments(pArguments));
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pInstructionList: IAFXAnalyzedInstruction[] = <IAFXAnalyzedInstruction[]>this.getInstructions();
			for(var i:  number  = 0; i < this._nInstructions; i++){
				if(pInstructionList[i]._getInstructionType() !== EAFXInstructionTypes.k_SimpleInstruction){
					pInstructionList[i].addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
				}
			}
		}

		clone(pRelationMap?: IAFXInstructionMap): SystemCallInstruction{
			var pClone: SystemCallInstruction = <SystemCallInstruction>super.clone(pRelationMap);

			pClone.setSystemCallFunction(this._pSystemFunction);

			return pClone;
		}

	}

/**
	 * Respresnt ctor(arg1,..., argn)
	 * EMPTY_OPERATOR IdInstruction ExprInstruction ... ExprInstruction 
	 */

	export class ConstructorCallInstruction extends ExprInstruction {
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_ConstructorCallInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			sCode += this.getInstructions()[0].toFinalCode();
			sCode += "(";

			for(var i:  number  = 1; i < this._nInstructions; i++){
				sCode += this.getInstructions()[i].toFinalCode();

				if(i !== this._nInstructions - 1){
					sCode += ",";
				}
			}

			sCode += ")";

			return sCode;
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pInstructionList: IAFXAnalyzedInstruction[] = <IAFXAnalyzedInstruction[]>this.getInstructions();
			for(var i:  number  = 1; i < this._nInstructions; i++){
				pInstructionList[i].addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
			}
		}
	}

/**
	 * Represetn compile vs_func(...args)
	 * compile IdExprInstruction ExprInstruction ... ExprInstruction
	 */

	export class CompileExprInstruction extends ExprInstruction{
		constructor() {
			super();
			this._pInstructionList = [null];
			this._eInstructionType = EAFXInstructionTypes.k_CompileExprInstruction;
		}

		inline getFunction(): IAFXFunctionDeclInstruction {
			return <IAFXFunctionDeclInstruction>this._pInstructionList[0].getParent().getParent();
		}
	}

	export class MemExprInstruction extends ExprInstruction {
		private _pBuffer: IAFXVariableDeclInstruction = null;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_MemExprInstruction;
		}

		getBuffer(): IAFXVariableDeclInstruction{
			return this._pBuffer;
		}

		setBuffer(pBuffer: IAFXVariableDeclInstruction): void {
			this._pBuffer = pBuffer;
			this.setType(pBuffer.getType());
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
					eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pBufferType: IAFXVariableTypeInstruction = this.getBuffer().getType();
			var pInfo: IAFXTypeUseInfoContainer = pUsedDataCollector[pBufferType._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: pBufferType,
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[pBufferType._getInstructionID()] = pInfo;
			}
			if(eUsedMode !== EVarUsedMode.k_Undefined){
				pInfo.isRead = true;
				pInfo.numRead++;
			}

			pInfo.numUsed++;
		}
	}

	export class InitExprInstruction extends ExprInstruction implements IAFXInitExprInstruction {
		private _pConstructorType: IAFXTypeInstruction = null;

		constructor(){
			super();
			this._pInstructionList = [];
			this._eInstructionType = EAFXInstructionTypes.k_InitExprInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			if(!isNull(this._pConstructorType)) {
				sCode += this._pConstructorType.toFinalCode();
			}
			sCode += "(";

			for(var i:  number  = 0; i < this._nInstructions; i++){
				sCode += this.getInstructions()[i].toFinalCode();

				if(i !== this._nInstructions - 1){
					sCode += ",";
				}
			}

			sCode += ")";

			return sCode;
		}

		optimizeForVariableType(pType: IAFXVariableTypeInstruction): bool {
			if ((pType.isNotBaseArray() && pType._getScope() === 0) ||
				(pType.isArray() && this._nInstructions > 1)){
				if (pType.getLength() ===  0xffffff  ||
					this._nInstructions !== pType.getLength()){
					return false;
				}

				var pArrayElementType: IAFXVariableTypeInstruction = pType.getArrayElementType();
				var pTestedInstruction: IAFXExprInstruction = null;
				var isOk: bool = false;

				for(var i:  number  = 0; i < this._nInstructions; i++){
					pTestedInstruction = (<IAFXExprInstruction>this.getInstructions()[i]);
					if(pTestedInstruction._getInstructionType() === EAFXInstructionTypes.k_InitExprInstruction){
						isOk = (<IAFXInitExprInstruction>pTestedInstruction).optimizeForVariableType(pArrayElementType);
						if(!isOk){
							return false;
						}
					}
					else {
						if(isSamplerType(pArrayElementType)){
							if(pTestedInstruction._getInstructionType() !== EAFXInstructionTypes.k_SamplerStateBlockInstruction){
								return false;
							}
						}
						else {
							isOk = pTestedInstruction.getType().isEqual(pArrayElementType);
							if(!isOk){
								return false;
							}
						}
					}
				}

				this._pConstructorType = pType.getBaseType();
				return true;
			}
			else {

				var pFirstInstruction: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[0];

				if (this._nInstructions === 1 &&
					pFirstInstruction._getInstructionType() !== EAFXInstructionTypes.k_InitExprInstruction){

					if(isSamplerType(pType)){
						if(pFirstInstruction._getInstructionType() === EAFXInstructionTypes.k_SamplerStateBlockInstruction){
							return true;
						}
						else {
							return false;
						}
					}

					if(pFirstInstruction.getType().isEqual(pType)){
						return true;
					}
					else {
						return false;
					}
				}

				var pInstructionList: IAFXInitExprInstruction[] = <IAFXInitExprInstruction[]>this.getInstructions();
				var pFieldNameList: string[] = pType.getFieldNameList();

				for(var i:  number  = 0 ; i < pInstructionList.length; i++){
					var pFieldType: IAFXVariableTypeInstruction = pType.getFieldType(pFieldNameList[i]);
					if(pInstructionList[i].optimizeForVariableType(pFieldType));
				}

				this._pConstructorType = pType.getBaseType();
				return true;
			}
		}
	}
/**
	 * Represetn sampler_state { states }
	 */

	export class SamplerStateBlockInstruction extends ExprInstruction {
		private _pTexture: IAFXVariableDeclInstruction = null;
		private _pSamplerParams: any = null;

		constructor() {
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_SamplerStateBlockInstruction;
		}

		addState(sStateType: string, sStateValue: string): void{
			if(isNull(this._pSamplerParams)){
				this._pSamplerParams = {};
			}

			this._pSamplerParams[sStateType] = sStateValue;

			return;
		}

		setTexture(pTexture: IAFXVariableDeclInstruction): void {
			this._pTexture = pTexture;
		}

		inline getTexture(): IAFXVariableDeclInstruction {
			return this._pTexture;
		}
	}


	export class ExtractExprInstruction extends ExprInstruction {
		private _eExtractExprType: EExtractExprType = 0;
		private _pPointer: IAFXVariableDeclInstruction = null;
        private _pBuffer: IAFXVariableDeclInstruction = null;
        private _sPaddingExpr: string = "";

        private _sExtractFunction: string = "";
        private _bNeedSecondBracket: bool = false;

		constructor(){
			super();
			this._pInstructionList = null;
			this._eInstructionType = EAFXInstructionTypes.k_ExtractExprInstruction;
		}

		getExtractFunction(): IAFXFunctionDeclInstruction {
			var pFunction: IAFXFunctionDeclInstruction = null;

            switch(this._eExtractExprType){
				case EExtractExprType.k_Header:
					pFunction = Effect.findSystemFunction("extractHeader", null);
					break;

				case EExtractExprType.k_Float:
				case EExtractExprType.k_Int:
				case EExtractExprType.k_Bool:
					pFunction = Effect.findSystemFunction("extractFloat", null);
					break;

				case EExtractExprType.k_Float2:
				case EExtractExprType.k_Int2:
				case EExtractExprType.k_Bool2:
					pFunction = Effect.findSystemFunction("extractFloat2", null);
					break;

				case EExtractExprType.k_Float3:
				case EExtractExprType.k_Int3:
				case EExtractExprType.k_Bool3:
					pFunction = Effect.findSystemFunction("extractFloat3", null);
					break;

				case EExtractExprType.k_Float4:
				case EExtractExprType.k_Int4:
				case EExtractExprType.k_Bool4:
					pFunction = Effect.findSystemFunction("extractFloat4", null);
					break;

				case EExtractExprType.k_Float4x4:
					pFunction = Effect.findSystemFunction("extractFloat4x4", null);
					break;
            }

            return pFunction;
        }

		initExtractExpr(pExtractType: IAFXVariableTypeInstruction,
					    pPointer: IAFXVariableDeclInstruction,
					    pBuffer: IAFXVariableDeclInstruction,
					    sPaddingExpr: string): void {

			this._pPointer = pPointer;
			this._pBuffer = pBuffer;
			this._sPaddingExpr = sPaddingExpr;
			this.setType(pExtractType);

            if (pExtractType.isEqual(Effect.getSystemType("float"))) {
            	this._eExtractExprType = EExtractExprType.k_Float;
                this._sExtractFunction += "A_extractFloat(";
            }
            else if(pExtractType.isEqual(Effect.getSystemType("ptr"))){
                this._eExtractExprType = EExtractExprType.k_Float;
                this._sExtractFunction += "A_extractFloat(";
            }
            else if(pExtractType.isEqual(Effect.getSystemType("video_buffer_header"))){
            	this._eExtractExprType = EExtractExprType.k_Header;
            	this._sExtractFunction += "A_extractTextureHeader(";
            }
            else if (pExtractType.isEqual(Effect.getSystemType("bool"))){
                this._eExtractExprType = EExtractExprType.k_Bool;
                this._sExtractFunction += "bool(A_extractFloat(";
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("int"))) {
            	this._eExtractExprType = EExtractExprType.k_Int;
                this._sExtractFunction += ("int(A_extractFloat(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("float2"))) {
            	this._eExtractExprType = EExtractExprType.k_Float2;
                this._sExtractFunction += ("A_extractVec2(");
            }
            else if (pExtractType.isEqual(Effect.getSystemType("float3"))) {
            	this._eExtractExprType = EExtractExprType.k_Float3;
                this._sExtractFunction += ("A_extractVec3(");
            }
            else if (pExtractType.isEqual(Effect.getSystemType("float4"))) {
            	this._eExtractExprType = EExtractExprType.k_Float4;
                this._sExtractFunction += ("A_extractVec4(");
            }
            else if (pExtractType.isEqual(Effect.getSystemType("int2"))) {
            	this._eExtractExprType = EExtractExprType.k_Int2;
                this._sExtractFunction += ("ivec2(A_extractVec2(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("int3"))) {
            	this._eExtractExprType = EExtractExprType.k_Int3;
                this._sExtractFunction += ("ivec3(A_extractVec3(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("int4"))) {
            	this._eExtractExprType = EExtractExprType.k_Int4;
                this._sExtractFunction += ("ivec4(A_extractVec4(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("bool2"))) {
            	this._eExtractExprType = EExtractExprType.k_Bool2;
                this._sExtractFunction += ("bvec2(A_extractVec2(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("bool3"))) {
            	this._eExtractExprType = EExtractExprType.k_Bool3;
                this._sExtractFunction += ("bvec3(A_extractVec3(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("bool4"))) {
            	this._eExtractExprType = EExtractExprType.k_Bool4;
                this._sExtractFunction += ("bvec4(A_extractVec4(");
                this._bNeedSecondBracket = true;
            }
            else if (pExtractType.isEqual(Effect.getSystemType("float4x4"))) {
            	this._eExtractExprType = EExtractExprType.k_Float4x4;
                this._sExtractFunction += ("A_extractMat4(");
            }
            else {
                this.setError( 2273 , { typeName: pExtractType.getHash() });
            }
		}

		addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
			var pPointerType: IAFXVariableTypeInstruction = this._pPointer.getType();
			var pBufferType: IAFXVariableTypeInstruction = this._pBuffer.getType();

			var pInfo: IAFXTypeUseInfoContainer = pUsedDataCollector[pPointerType._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: pPointerType,
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[pPointerType._getInstructionID()] = pInfo;
			}

			pInfo.isRead = true;
			pInfo.numRead++;
			pInfo.numUsed++;

			pInfo = pUsedDataCollector[pBufferType._getInstructionID()];

			if(!isDef(pInfo)){
				pInfo = <IAFXTypeUseInfoContainer>{
					type: pBufferType,
					isRead: false,
					isWrite: false,
					numRead: 0,
					numWrite: 0,
					numUsed: 0
				}

				pUsedDataCollector[pBufferType._getInstructionID()] = pInfo;
			}

			pInfo.isRead = true;
			pInfo.numRead++;
			pInfo.numUsed++;
        }

		toFinalCode(): string {
			var sCode: string = "";

			if(this._pBuffer.isDefinedByZero()){
				switch(this._eExtractExprType){
					case EExtractExprType.k_Header:
						sCode = "A_TextureHeader(0.,0.,0.,0.)";
						break;

					case EExtractExprType.k_Float:
						sCode = "0.";
						break;
					case EExtractExprType.k_Int:
						sCode = "0";
						break;
					case EExtractExprType.k_Bool:
						sCode = "false";
						break;

					case EExtractExprType.k_Float2:
						sCode = "vec2(0.)";
						break;
					case EExtractExprType.k_Int2:
						sCode = "ivec2(0)";
						break;
					case EExtractExprType.k_Bool2:
						sCode = "bvec2(false)";
						break;

					case EExtractExprType.k_Float3:
						sCode = "vec3(0.)";
						break;
					case EExtractExprType.k_Int3:
						sCode = "ivec3(0)";
						break;
					case EExtractExprType.k_Bool3:
						sCode = "bvec3(false)";
						break;

					case EExtractExprType.k_Float4:
						sCode = "vec4(0.)";
						break;
					case EExtractExprType.k_Int4:
						sCode = "ivec4(0)";
						break;
					case EExtractExprType.k_Bool4:
						sCode = "bvec4(false)";
						break;

					case EExtractExprType.k_Float4x4:
						sCode = "mat4(0.)";
						break;
				}
			}
			else {
				sCode = this._sExtractFunction;
				sCode += this._pBuffer._getVideoBufferSampler().getNameId().toFinalCode();
				sCode += "," + this._pBuffer._getVideoBufferHeader().getNameId().toFinalCode();
				if(this._eExtractExprType !== EExtractExprType.k_Header){
					sCode += "," + this._pPointer.getNameId().toFinalCode() + this._sPaddingExpr;
				}
				sCode += ")";
				if(this._bNeedSecondBracket){
					sCode += ")";
				}
			}

			return sCode;
		}

		clone(pRelationMap?: IAFXInstructionMap): ExtractExprInstruction {
			var pClone: ExtractExprInstruction = <ExtractExprInstruction>super.clone(pRelationMap);
			pClone._setCloneParams(this._pPointer.clone(pRelationMap), this._pBuffer, this._eExtractExprType,
								   this._sPaddingExpr, this._sExtractFunction, this._bNeedSecondBracket);
			return pClone;
		}

		_setCloneParams(pPointer: IAFXVariableDeclInstruction,
						pBuffer: IAFXVariableDeclInstruction,
						eExtractExprType: EExtractExprType,
						sPaddingExpr: string,
						sExtractFunction: string,
						bNeedSecondBracket: bool): void {
			this._pPointer = pPointer;
			this._pBuffer = pBuffer;
			this._eExtractExprType = eExtractExprType;
			this._sPaddingExpr = sPaddingExpr;
			this._sExtractFunction = sExtractFunction;
			this._bNeedSecondBracket = bNeedSecondBracket;
		}
	}
}



module akra.fx {
	export class VariableDeclInstruction extends DeclInstruction implements IAFXVariableDeclInstruction {
		private _isVideoBuffer: bool = null;
        private _pVideoBufferSampler: IAFXVariableDeclInstruction = null;
        private _pVideoBufferHeader: IAFXVariableDeclInstruction = null;
        private _pFullNameExpr: IAFXExprInstruction = null;
        private _bDefineByZero: bool = false;
        private _pSubDeclList: IAFXVariableDeclInstruction[] = null;
        private _bShaderOutput: bool = false;

/**
		 * Represent type var_name [= init_expr]
		 * EMPTY_OPERATOR VariableTypeInstruction IdInstruction InitExprInstruction
		 */

		constructor(){
			super();
			this._pInstructionList = [null, null, null];
			this._eInstructionType = EAFXInstructionTypes.k_VariableDeclInstruction;
		}

		inline hasInitializer(): bool {
			return this._nInstructions === 3 && !isNull(this.getInitializeExpr());
		}

		inline getInitializeExpr(): IAFXInitExprInstruction {
			return <IAFXInitExprInstruction>this.getInstructions()[2];
		}

        getDefaultValue(): any {
            return null;
        }

		inline getType(): IAFXVariableTypeInstruction {
			return <IAFXVariableTypeInstruction>this._pInstructionList[0];
		}

        inline setType(pType: IAFXVariableTypeInstruction): void{
        	this._pInstructionList[0] = <IAFXVariableTypeInstruction>pType;
        	pType.setParent(this);

        	if(this._nInstructions === 0){
        		this._nInstructions = 1;
        	}
        }

        setName(sName: string):void {
        	var pName: IAFXIdInstruction = new IdInstruction();
        	pName.setName(sName);
        	pName.setParent(this);

        	this._pInstructionList[1] = <IAFXIdInstruction>pName;

        	if(this._nInstructions < 2) {
        		this._nInstructions = 2;
        	}
        }

        inline getName(): string {
        	return (<IAFXIdInstruction>this._pInstructionList[1]).getName();
        }

        inline getRealName(): string {
            return (<IAFXIdInstruction>this._pInstructionList[1]).getRealName();
        }

        inline getNameId(): IAFXIdInstruction {
                return <IAFXIdInstruction>this._pInstructionList[1];
        }

        inline isUniform(): bool {
        	return this.getType().hasUsage("uniform");
        }

        isField(): bool {
            if(isNull(this.getParent())){
                return false;
            }

            var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();
            if (eParentType === EAFXInstructionTypes.k_VariableTypeInstruction ||
                eParentType === EAFXInstructionTypes.k_ComplexTypeInstruction ||
                eParentType === EAFXInstructionTypes.k_SystemTypeInstruction){
                return true;
            }

            return false;
        }

        inline isPointer(): bool {
            return this.getType().isPointer();
        }

        isVideoBuffer(): bool{
            if(isNull(this._isVideoBuffer)){
                this._isVideoBuffer = this.getType().isEqual(getEffectBaseType("video_buffer"));
            }

            return this._isVideoBuffer;
        }

        inline isSampler(): bool {
            return this.getType().isSampler();
        }

        inline getSubVarDecls(): IAFXVariableDeclInstruction[] {
           return this.getType().getSubVarDecls();
        }

        inline isDefinedByZero(): bool{
            return this._bDefineByZero;
        }

        inline defineByZero(isDefine: bool): void {
            this._bDefineByZero = isDefine;
        }

        toFinalCode(): string {
            if(this._isShaderOutput()){
                return "";
            }

            var sCode: string = this.getType().toFinalCode();
            sCode += " " + this.getNameId().toFinalCode();

            if(this.getType().isNotBaseArray()){
                sCode += "[" + this.getType().getLength() + "]";
            }

            if(this.hasInitializer() && !this.isUniform()){
                sCode += "=" + this.getInitializeExpr().toFinalCode();
            }

            return sCode;
        }

        inline _markAsShaderOutput(isShaderOutput: bool): void {
            this._bShaderOutput = isShaderOutput;
        }

        inline _isShaderOutput(): bool {
            return this._bShaderOutput;
        }

        _getFullNameExpr(): IAFXExprInstruction {
            if(!isNull(this._pFullNameExpr)){
                return this._pFullNameExpr;
            }

            if(!this.isField()){
                this._pFullNameExpr = new IdExprInstruction();
                this._pFullNameExpr.push(this.getNameId(), false);
            }
            else {
                var pMainVar: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getType()._getParentContainer();

                if(isNull(pMainVar)){
                    return null;
                }

                var pMainExpr: IAFXExprInstruction = pMainVar._getFullNameExpr();
                if(isNull(pMainExpr)){
                    return null;
                }
                var pFieldExpr: IAFXExprInstruction = new IdExprInstruction();
                pFieldExpr.push(this.getNameId(), false);

                this._pFullNameExpr = new PostfixPointInstruction();
                this._pFullNameExpr.push(pMainExpr, false);
                this._pFullNameExpr.push(pFieldExpr, false);
                this._pFullNameExpr.setType(this.getType());
            }

            return this._pFullNameExpr;
        }

        _getFullName(): string {
            if(!this.isField()){
                return this.getName();
            }
            else {
                var sName: string = "";
                var eParentType: EAFXInstructionTypes = this.getParent()._getInstructionType();

                if(eParentType === EAFXInstructionTypes.k_VariableTypeInstruction){
                    sName = (<IAFXVariableTypeInstruction>this.getParent())._getFullName();
                }

                sName += "." + this.getName();

                return sName;
            }
        }

        _getVideoBufferSampler(): IAFXVariableDeclInstruction {
            if(!this.isVideoBuffer()){
                return null;
            }

            if(isNull(this._pVideoBufferSampler)){
                this._pVideoBufferSampler = new VariableDeclInstruction();
                var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
                var pId: IAFXIdInstruction = new IdInstruction();

                pType.pushType(getEffectBaseType("sampler2D"));
                pId.setName(this.getName() + "_sampler");

                this._pVideoBufferSampler.push(pType, true);
                this._pVideoBufferSampler.push(pId, true);
            }

            return this._pVideoBufferSampler;
        }

        _getVideoBufferHeader(): IAFXVariableDeclInstruction {
            if(!this.isVideoBuffer()){
                return null;
            }

            if(isNull(this._pVideoBufferHeader)){
                this._pVideoBufferHeader = new VariableDeclInstruction();
                var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
                var pId: IAFXIdInstruction = new IdInstruction();
                var pExtarctExpr: ExtractExprInstruction = new ExtractExprInstruction();

                pType.pushType(getEffectBaseType("video_buffer_header"));
                pId.setName(this.getName() + "_header");
                pExtarctExpr.initExtractExpr(pType, null, this, "");

                this._pVideoBufferHeader.push(pType, true);
                this._pVideoBufferHeader.push(pId, true);
                this._pVideoBufferHeader.push(pExtarctExpr, true);
            }

            return this._pVideoBufferHeader;
        }

        clone(pRelationMap?: IAFXInstructionMap): IAFXVariableDeclInstruction {
        	return <IAFXVariableDeclInstruction>super.clone(pRelationMap);
        }

        blend(pVariableDecl: IAFXVariableDeclInstruction, eMode: EAFXBlendMode): IAFXVariableDeclInstruction{
            var pBlendType: IAFXVariableTypeInstruction = this.getType().blend(pVariableDecl.getType(), eMode);

            if(isNull(pBlendType)){
                return null;
            }

            var pBlendVar: IAFXVariableDeclInstruction = new VariableDeclInstruction();
            var pId: IAFXIdInstruction = new IdInstruction();

            pId.setName(this.getNameId().getName());
            pId.setRealName(this.getNameId().getRealName());

            pBlendVar.setSemantic(this.getSemantic());
            pBlendVar.push(pBlendType, true);
            pBlendVar.push(pId, true);

            return pBlendVar;
        }

	}
}



















module akra.fx {
/**
     * Represent all kind of statements
     */

    export class StmtInstruction extends Instruction  implements IAFXStmtInstruction {
        constructor() {
            super();
            this._eInstructionType = EAFXInstructionTypes.k_StmtInstruction;
        }

        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
            var pInstructionList: IAFXAnalyzedInstruction[] = <IAFXAnalyzedInstruction[]>this.getInstructions();

            if(!isNull(pUsedDataCollector)){
                for(var i:  number  = 0; i < this._nInstructions; i++){
                    pInstructionList[i].addUsedData(pUsedDataCollector, eUsedMode);
                }
            }
        }
    }

/**
     * Represent {stmts}
     * EMPTY_OPERATOR StmtInstruction ... StmtInstruction
     */

    export class StmtBlockInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [];
            this._eInstructionType = EAFXInstructionTypes.k_StmtBlockInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "{" + "\n";

            for(var i:  number  = 0; i < this._nInstructions; i++){
                sCode += "\t" + this._pInstructionList[i].toFinalCode() + "\n";
            }

            sCode += "}";

            return sCode;
        }
    }

/**
     * Represent expr;
     * EMPTY_OPERTOR ExprInstruction 
     */

    export class ExprStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [null];
            this._eInstructionType = EAFXInstructionTypes.k_ExprStmtInstruction;
        }

        toFinalCode(): string {
            return this.getInstructions()[0].toFinalCode() + ";";
        }
    }

/**
     * Reprsernt continue; break; discard;
     * (continue || break || discard) 
     */

    export class BreakStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = null;
            this._eInstructionType = EAFXInstructionTypes.k_BreakStmtInstruction;
        }

        toFinalCode(): string {
            return this.getOperator() + ";";
        }
    }

/**
     * Represent while(expr) stmt
     * ( while || do_while) ExprInstruction StmtInstruction
     */

    export class WhileStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [null, null];
            this._eInstructionType = EAFXInstructionTypes.k_WhileStmtInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "";
            if(this.getOperator() === "while"){
                sCode += "while(";
                sCode += this.getInstructions()[0].toFinalCode();
                sCode += ")";
                sCode += this.getInstructions()[1].toFinalCode();
            }
            else{
                sCode += "do";
                sCode += this.getInstructions()[1].toFinalCode();
                sCode += "while(";
                sCode += this.getInstructions()[0].toFinalCode();
                sCode += ");";
            }
            return sCode;
        }
    }

/**
     * Represent for(forInit forCond ForStep) stmt
     * for ExprInstruction or VarDeclInstruction ExprInstruction ExprInstruction StmtInstruction
     */

    export class ForStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [null, null, null, null];
            this._eInstructionType = EAFXInstructionTypes.k_ForStmtInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "for(";

            sCode += this.getInstructions()[0].toFinalCode() + ";";
            sCode += this.getInstructions()[1].toFinalCode() + ";";
            sCode += this.getInstructions()[2].toFinalCode() + ")";
            sCode += this.getInstructions()[3].toFinalCode();

            return sCode;
        }

        check(eStage: ECheckStage, pInfo: any = null): bool {
            var pInstructionList: IAFXInstruction[] = this.getInstructions();

            if(this._nInstructions !== 4){
                this.setError( 2239 );
                return false;
            }

            if(isNull(pInstructionList[0])){
                this.setError( 2232 );
                return false;
            }

            if(pInstructionList[0]._getInstructionType() !== EAFXInstructionTypes.k_VariableDeclInstruction){
                this.setError( 2231 );
                return false;
            }

            if(isNull(pInstructionList[1])){
                this.setError( 2233 );
                return false;
            }

            if(pInstructionList[1]._getInstructionType() !== EAFXInstructionTypes.k_RelationalExprInstruction){
                this.setError( 2238 );
                return false;
            }

            if(pInstructionList[2]._getInstructionType() === EAFXInstructionTypes.k_UnaryExprInstruction ||
               pInstructionList[2]._getInstructionType() === EAFXInstructionTypes.k_AssignmentExprInstruction ||
               pInstructionList[2]._getInstructionType() === EAFXInstructionTypes.k_PostfixArithmeticInstruction){

                var sOperator: string = pInstructionList[2].getOperator();
                if (sOperator !== "++" && sOperator !== "--" &&
                    sOperator !== "+=" && sOperator !== "-=") {
                    this.setError( 2240 , {operator: sOperator});
                    return false;
                }
            }
            else {
                this.setError( 2241 );
                return false;
            }

            return true;
        }

        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
            var pForInit: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>this.getInstructions()[0];
            var pForCondition: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[1];
            var pForStep: IAFXExprInstruction = <IAFXExprInstruction>this.getInstructions()[2];
            var pForStmt: IAFXStmtInstruction = <IAFXStmtInstruction>this.getInstructions()[3];

            var pIteratorType: IAFXVariableTypeInstruction = pForInit.getType();

            pUsedDataCollector[pIteratorType._getInstructionID()] = <IAFXTypeUseInfoContainer>{
                type: pIteratorType,
                isRead: false,
                isWrite: true,
                numRead: 0,
                numWrite: 1,
                numUsed: 1
            };

            pForCondition.addUsedData(pUsedDataCollector, eUsedMode);
            pForStep.addUsedData(pUsedDataCollector, eUsedMode);
            pForStmt.addUsedData(pUsedDataCollector, eUsedMode);
        }
    }

/**
     * Represent if(expr) stmt or if(expr) stmt else stmt
     * ( if || if_else ) Expr Stmt [Stmt]
     */

    export class IfStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = [null, null, null];
            this._eInstructionType = EAFXInstructionTypes.k_IfStmtInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "";
            if(this.getOperator() === "if"){
                sCode += "if(";
                sCode += this.getInstructions()[0].toFinalCode() + ")";
                sCode += this.getInstructions()[1].toFinalCode();
            }
            else {
                sCode += "if(";
                sCode += this.getInstructions()[0].toFinalCode() + ") ";
                sCode += this.getInstructions()[1].toFinalCode();
                sCode += "else ";
                sCode += this.getInstructions()[2].toFinalCode();
            }

            return sCode;
        }
    }

/**
     * Represent TypeDecl or VariableDecl or VarStructDecl
     * EMPTY DeclInstruction
     */

    export class DeclStmtInstruction extends StmtInstruction {
        constructor () {
            super();
            this._pInstructionList = [null];
            this._eInstructionType = EAFXInstructionTypes.k_DeclStmtInstruction;
        }

        toFinalCode(): string {
            var sCode: string = "";
            var pVariableList: IAFXVariableDeclInstruction[] = <IAFXVariableDeclInstruction[]>this.getInstructions();

            for(var i:  number  = 0; i < this._nInstructions; i++){
                sCode += pVariableList[i].toFinalCode() + ";\n";
            }

            return sCode;
        }

        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
            if(isNull(this.getInstructions()) || this._nInstructions === 0) {
                return;
            }

            if(this.getInstructions()[0]._getInstructionType() === EAFXInstructionTypes.k_TypeDeclInstruction){
                return;
            }

            var pVariableList: IAFXVariableDeclInstruction[] = <IAFXVariableDeclInstruction[]>this.getInstructions();
            for(var i:  number  = 0; i < this._nInstructions; i++){
                var pVarType: IAFXVariableTypeInstruction = pVariableList[i].getType();

                pUsedDataCollector[pVarType._getInstructionID()] = <IAFXTypeUseInfoContainer>{
                    type: pVarType,
                    isRead: false,
                    isWrite: true,
                    numRead: 0,
                    numWrite: 1,
                    numUsed: 1
                };

                if(pVariableList[i].hasInitializer()){
                    pVariableList[i].getInitializeExpr().addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
                }
            }
        }

    }

/**
     * Represent return expr;
     * return ExprInstruction
     */

    export class ReturnStmtInstruction extends StmtInstruction {
        private _pPreparedCode: string = "";
        private _isPositionReturn: bool = false;
        private _isColorReturn: bool = false;
        private _isOnlyReturn: bool = false;

        constructor () {
            super();
            this._pInstructionList = [null];
            this._sOperatorName = "return";
            this._eInstructionType = EAFXInstructionTypes.k_ReturnStmtInstruction;
        }

        prepareFor(eUsedMode: EFunctionType): void {
            var pReturn: IAFXTypedInstruction = <IAFXTypedInstruction>this.getInstructions()[0];
            if(isNull(pReturn)){
                return;
            }

            if(eUsedMode === EFunctionType.k_Vertex){
                if(pReturn.getType().isBase()){
                    this._isPositionReturn = true;
                }
                else {
                    this._isOnlyReturn = true;
                }
            }
            else if(eUsedMode === EFunctionType.k_Pixel){
                this._isColorReturn = true;
            }

            for(var i:  number  = 0; i < this._nInstructions; i++){
                this._pInstructionList[i].prepareFor(eUsedMode);
            }
        }

        toFinalCode(): string {
            if(this._isPositionReturn){
                return "Out.POSITION=" + this._pInstructionList[0].toFinalCode() + ";";
            }
            if(this._isColorReturn){
                return "gl_FragColor=" + this._pInstructionList[0].toFinalCode() + ";";
            }
            if(this._isOnlyReturn){
                return "return;"
            }

            if(this._nInstructions > 0){
                return "return " + this._pInstructionList[0].toFinalCode() + ";";
            }
            else {
                return "return;";
            }
        }
    }

    export class ExtractStmtInstruction extends ExprInstruction {
        private _pExtractInVar: IAFXVariableDeclInstruction = null;
        private _pExtractInExpr: IAFXExprInstruction = null;
        private _pExtactExpr: ExtractExprInstruction = null;

        constructor() {
            super();
            this._pInstructionList = [];
            this._eInstructionType = EAFXInstructionTypes.k_ExtractStmtInstruction;
        }

        generateStmtForBaseType(pVarDecl: IAFXVariableDeclInstruction,
                                pPointer: IAFXVariableDeclInstruction,
                                pBuffer: IAFXVariableDeclInstruction,
                                iPadding:  number ): void {
            var pVarType: IAFXVariableTypeInstruction = pVarDecl.getType();
            var pVarNameExpr: IAFXExprInstruction = pVarDecl._getFullNameExpr();
            if(pVarType.isComplex() || isNull(pVarNameExpr) || pVarType.getSize() ===  0xffffff ) {
                this.setError( 2274 );
                return;
            }

// var pPointer: IAFXVariableDeclInstruction = isDef(pPointer) ? pPointer : pVarType.getPointer();
// var pBuffer: IAFXVariableDeclInstruction = isDef(pBuffer) ?  pBuffer : pVarType.getVideoBuffer();
            var pBufferSampler: IAFXVariableDeclInstruction = pBuffer._getVideoBufferSampler();
            var pBufferHeader: IAFXVariableDeclInstruction = pBuffer._getVideoBufferHeader();

            var isArray: bool = pVarType.isNotBaseArray();
            var iLength:  number  = pVarType.getLength();
            var sCodeFragment: string = "";
            var pExtractType: IAFXVariableTypeInstruction = isArray ? pVarType.getArrayElementType() : pVarType;

            if(isArray){
                if(iLength ===  0xffffff ){
                    this.setError( 2274 );
                    return;
                }

                sCodeFragment = "for(int i=0;i<" + iLength.toString() + ";i++){";
                this.push(new SimpleInstruction(sCodeFragment), true);
            }

            this.push(pVarNameExpr, false);


            if(isArray){
                sCodeFragment = "[i]=";
            }
            else {
                sCodeFragment = "=";
            }

            this.push(new SimpleInstruction(sCodeFragment), true);

            var pExtractType: IAFXVariableTypeInstruction = isArray ? pVarType.getArrayElementType() : pVarType;
            var pExtractExpr: ExtractExprInstruction = new ExtractExprInstruction();
            var sPaddingExpr: string = "";

            if(iPadding > 0){
                sPaddingExpr = "+"+ iPadding.toString() + ".0";
            }
            else{
                sPaddingExpr = "";
            }

            if(isArray){
                sPaddingExpr += "+float(i*" + pExtractType.getSize().toString() + ")";
            }

            pExtractExpr.initExtractExpr(pExtractType, pPointer, pBuffer, sPaddingExpr);

            if(pExtractExpr.isErrorOccured()){
                this.setError(pExtractExpr.getLastError().code,pExtractExpr.getLastError().info);
                return;
            }

            this.push(pExtractExpr, true);

            sCodeFragment = ";";

            if(isArray){
                sCodeFragment += "}";
            }

            this.push(new SimpleInstruction(sCodeFragment), true);

            this._pExtactExpr = pExtractExpr;
            this._pExtractInVar = pVarDecl;
            this._pExtractInExpr = pVarNameExpr;
        }

        toFinalCode(): string {
            var sCode: string = "";

            for(var i:  number  = 0; i < this._nInstructions; i++){
                sCode += this.getInstructions()[i].toFinalCode();
            }

            return sCode;
        }

        addUsedData(pUsedDataCollector: IAFXTypeUseInfoMap,
                    eUsedMode?: EVarUsedMode = EVarUsedMode.k_Undefined): void {
            this._pExtractInExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Write);
            this._pExtactExpr.addUsedData(pUsedDataCollector, EVarUsedMode.k_Read);
        }

        getExtractFunction(): IAFXFunctionDeclInstruction {
            return this._pExtactExpr.getExtractFunction();
        }
    }

/**
     * Represent empty statement only semicolon ;
     * ;
     */

    export class SemicolonStmtInstruction extends StmtInstruction {
        constructor() {
            super();
            this._pInstructionList = null;
            this._eInstructionType = EAFXInstructionTypes.k_SemicolonStmtInstruction;
        }

        toFinalCode(): string {
            return ";";
        }
    }
}



module akra.fx {
/**
	 * Represent type func(...args)[:Semantic] [<Annotation> {stmts}]
	 * EMPTY_OPERTOR FunctionDefInstruction StmtBlockInstruction
	 */

	export class FunctionDeclInstruction extends DeclInstruction implements IAFXFunctionDeclInstruction {
		/**@protected*/  _pFunctionDefenition: FunctionDefInstruction = null;
		/**@protected*/  _pImplementation: StmtBlockInstruction = null;
		/**@protected*/  _eFunctionType: EFunctionType = EFunctionType.k_Function;

		/**@protected*/  _bUsedAsFunction: bool = false;
		/**@protected*/  _bUsedAsVertex: bool = false;
		/**@protected*/  _bUsedAsPixel: bool = false;
		/**@protected*/  _bCanUsedAsFunction: bool = true;

		/**@protected*/  _bUsedInVertex: bool = false;
		/**@protected*/  _bUsedInPixel: bool = false;

		/**@protected*/  _pParseNode: IParseNode = null;
		/**@protected*/  _iImplementationScope:  number  =  0xffffff ;

		/**@protected*/  _isInBlackList: bool = false;

		/**@protected*/  _pOutVariable: IAFXVariableDeclInstruction = null;

//Info about used data
		/**@protected*/  _pUsedFunctionMap: IAFXFunctionDeclMap = null;
		/**@protected*/  _pUsedFunctionList: IAFXFunctionDeclInstruction[] = null;

		/**@protected*/  _pAttributeVariableMap: IAFXVariableDeclMap = null;
		/**@protected*/  _pVaryingVariableMap: IAFXVariableDeclMap = null;

		/**@protected*/  _pUsedVarTypeMap: IAFXTypeUseInfoMap = null;

		/**@protected*/  _pSharedVariableMap: IAFXVariableDeclMap = null;
		/**@protected*/  _pGlobalVariableMap: IAFXVariableDeclMap = null;
		/**@protected*/  _pUniformVariableMap: IAFXVariableDeclMap = null;
		/**@protected*/  _pForeignVariableMap: IAFXVariableDeclMap = null;
		/**@protected*/  _pTextureVariableMap: IAFXVariableDeclMap = null;

// protected _pSharedVariableTypeList: IAFXVariableTypeInstruction[] = null;
// protected _pGlobalVariableTypeList: IAFXVariableTypeInstruction[] = null;
// protected _pUniformVariableTypeList: IAFXVariableTypeInstruction[] = null;
// protected _pForeignVariableTypeList: IAFXVariableTypeInstructionnt[] = null;

		/**@protected*/  _pUsedComplexTypeMap: IAFXTypeMap = null;

		/**@protected*/  _pAttributeVariableKeys:  number [] = null;
		/**@protected*/  _pVaryingVariableKeys:  number [] = null;

		/**@protected*/  _pSharedVariableKeys:  number [] = null;
		/**@protected*/  _pUniformVariableKeys:  number [] = null;
		/**@protected*/  _pForeignVariableKeys:  number [] = null;
		/**@protected*/  _pGlobalVariableKeys:  number [] = null;

		/**@protected*/  _pUsedComplexTypeKeys:  number [] = null;

		/**@protected*/  _pVertexShader: IAFXFunctionDeclInstruction = null;
		/**@protected*/  _pPixelShader: IAFXFunctionDeclInstruction = null;

		private _pExtSystemTypeList: IAFXTypeDeclInstruction[] = null;
		private _pExtSystemFunctionList: IAFXFunctionDeclInstruction[] = null;
		private _pExtSystemMacrosList: IAFXSimpleInstruction[] = null;


		constructor() {
			super();
			this._pInstructionList = [null, null];
			this._eInstructionType = EAFXInstructionTypes.k_FunctionDeclInstruction;
		}

		toFinalCode(): string {
			var sCode = "";

			sCode += this._pFunctionDefenition.toFinalCode();
			sCode += this._pImplementation.toFinalCode();

			return sCode;
		}

		toFinalDefCode(): string {
			return this._pFunctionDefenition.toFinalCode();
		}

		inline getType(): IAFXTypeInstruction {
			return <IAFXTypeInstruction>this.getReturnType();
		}

		inline getName(): string {
			return this._pFunctionDefenition.getName();
		}

		inline getNameId(): IAFXIdInstruction {
			return this._pFunctionDefenition.getNameId();
		}

		getArguments(): IAFXVariableDeclInstruction[] {
			return this._pFunctionDefenition.getArguments();
		}

		inline getNumNeededArguments():  number  {
			return this._pFunctionDefenition.getNumNeededArguments();
		}

		inline hasImplementation(): bool {
			return !isNull(this._pImplementation) || !isNull(this._pParseNode);
		}

		inline getReturnType(): IAFXVariableTypeInstruction {
			return this._pFunctionDefenition.getReturnType();
		}

		inline getFunctionType(): EFunctionType {
			return this._eFunctionType;
		}

		inline setFunctionType(eFunctionType: EFunctionType): void {
        	this._eFunctionType = eFunctionType;
        }

		inline _setImplementationScope(iScope:  number ): void {
			this._iImplementationScope = iScope;
		}

		inline _getImplementationScope():  number  {
			return this._iImplementationScope;
		}

		inline _setParseNode(pNode: IParseNode): void {
			this._pParseNode = pNode;
		}

		inline _getParseNode(): IParseNode {
			return this._pParseNode;
		}

		setFunctionDef(pFunctionDef: IAFXDeclInstruction): void {
			this._pFunctionDefenition = <FunctionDefInstruction>pFunctionDef;
			this._pInstructionList[0] = pFunctionDef;
			pFunctionDef.setParent(this);
			this._nInstructions = this._nInstructions === 0 ? 1 : this._nInstructions;
		}

		setImplementation(pImplementation: IAFXStmtInstruction): void {
			this._pImplementation = <StmtBlockInstruction>pImplementation;
			this._pInstructionList[1] = pImplementation;
			pImplementation.setParent(pImplementation);
			this._nInstructions = 2;

			this._pParseNode = null;
		}

		clone(pRelationMap?: IAFXInstructionMap = <IAFXInstructionMap>{}): IAFXFunctionDeclInstruction {
			var pClone: FunctionDeclInstruction = <FunctionDeclInstruction>super.clone(pRelationMap);

			if(!isNull(this._pOutVariable)){
				pClone._setOutVariable(<IAFXVariableDeclInstruction>pRelationMap[this._pOutVariable._getInstructionID()]);
			}

			var pUsedVarTypeMap: IAFXTypeUseInfoMap = this.cloneVarTypeUsedMap(this._pUsedVarTypeMap, pRelationMap);
			var pSharedVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pSharedVariableMap, pRelationMap);
			var pGlobalVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pGlobalVariableMap, pRelationMap);
			var pUniformVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pUniformVariableMap, pRelationMap);
			var pForeignVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pForeignVariableMap, pRelationMap);
			var pTextureVariableMap: IAFXVariableDeclMap = this.cloneVarDeclMap(this._pTextureVariableMap, pRelationMap);
			var pUsedComplexTypeMap: IAFXTypeMap = this.cloneTypeMap(this._pUsedComplexTypeMap, pRelationMap);

			pClone._setUsedFunctions(this._pUsedFunctionMap, this._pUsedFunctionList);
			pClone._setUsedVariableData(pUsedVarTypeMap,
										pSharedVariableMap,
										pGlobalVariableMap,
										pUniformVariableMap,
										pForeignVariableMap,
										pTextureVariableMap,
										pUsedComplexTypeMap);
			pClone._initAfterClone();

			return pClone;
		}

		_addOutVariable(pVariable: IAFXVariableDeclInstruction): bool {
			if(!isNull(this._pOutVariable)){
				return false;
			}

			if(!pVariable.getType().isEqual(this.getReturnType())){
				return false;
			}

			this._pOutVariable = pVariable;
			return true;
		}

		_getOutVariable(): IAFXVariableDeclInstruction{
			return this._pOutVariable;
		}

		_getVertexShader(): IAFXFunctionDeclInstruction {
			return this._pVertexShader;
		}

		_getPixelShader(): IAFXFunctionDeclInstruction {
			return this._pPixelShader;
		}

		_markUsedAs(eUsedType: EFunctionType): void {
			switch(eUsedType){
				case EFunctionType.k_Vertex:
					this._bUsedInVertex = true;
					this._bUsedAsVertex = true;
					break;
				case EFunctionType.k_Pixel:
					this._bUsedInPixel = true;
					this._bUsedAsPixel = true;
					break;
				case EFunctionType.k_Function:
					this._bUsedAsFunction = true;
					break;
			}
		}

		_isUsedAs(eUsedType: EFunctionType): bool {
			switch(eUsedType){
				case EFunctionType.k_Vertex:
					return this._bUsedAsVertex;
				case EFunctionType.k_Pixel:
					return this._bUsedAsPixel;
				case EFunctionType.k_Function:
					return this._bUsedAsFunction;
			}
		}

		_isUsedAsFunction(): bool {
			return this._bUsedAsFunction;
		}

		_isUsedAsVertex(): bool {
			return this._bUsedAsVertex;
		}

		_isUsedAsPixel(): bool {
			return this._bUsedAsPixel;
		}

		_markUsedInVertex(): void {
			this._bUsedInVertex = true;
		}

		_markUsedInPixel(): void {
			this._bUsedInPixel = true;
		}

		_isUsedInVertex(): bool {
			return this._bUsedInVertex;
		}

		_isUsedInPixel(): bool {
			return this._bUsedInPixel;
		}

		_isUsed(): bool{
			return this._bUsedAsFunction || this._bUsedAsVertex || this._bUsedAsPixel;
		}

		_checkVertexUsage(): bool {
			return this._isUsedInVertex() ? this._isForVertex() : true;
		}

		_checkPixelUsage(): bool {
			return this._isUsedInPixel() ? this._isForPixel() : true;
		}

		_checkDefenitionForVertexUsage(): bool {
			return this._pFunctionDefenition._checkForVertexUsage();
		}

		_checkDefenitionForPixelUsage(): bool {
			return this._pFunctionDefenition._checkForPixelUsage();
		}

		_canUsedAsFunction(): bool {
			return this._bCanUsedAsFunction && this._pFunctionDefenition._canUsedAsFunction();
		}

		_notCanUsedAsFunction(): void {
			this._bCanUsedAsFunction = false;
		}

		_addUsedFunction(pFunction: IAFXFunctionDeclInstruction): bool {
			if (pFunction._getInstructionType() === EAFXInstructionTypes.k_SystemFunctionInstruction &&
				!pFunction.isBuiltIn()) {

				this.addExtSystemFunction(pFunction);
				return true;
			}

			if(isNull(this._pUsedFunctionMap)){
				this._pUsedFunctionMap = <IAFXFunctionDeclMap>{};
				this._pUsedFunctionList = [];
			}

			var iFuncId:  number  = pFunction._getInstructionID();

			if(!isDef(this._pUsedFunctionMap[iFuncId])){
				this._pUsedFunctionMap[iFuncId] = pFunction;
				this._pUsedFunctionList.push(pFunction);
				return true;
			}

			return false;
		}

		_addUsedVariable(pVariable: IAFXVariableDeclInstruction): void {

		}

		_getUsedFunctionList(): IAFXFunctionDeclInstruction[] {
			return this._pUsedFunctionList;
		}

		_isBlackListFunction(): bool {
			return this._isInBlackList;
		}

		_addToBlackList(): void {
			this._isInBlackList = true;
		}

		_getStringDef(): string {
			return this._pFunctionDefenition._getStringDef();
		}

		_convertToVertexShader(): IAFXFunctionDeclInstruction {
			var pShader: FunctionDeclInstruction = null;

			if((!this._canUsedAsFunction() || !this._isUsedAsFunction()) &&
			   (!this._isUsedInPixel())){
			   	pShader = this;
			}
			else {
				pShader = <FunctionDeclInstruction>this.clone();
			}

			pShader._prepareForVertex();
			this._pVertexShader = pShader;

			return pShader;
		}

        _convertToPixelShader(): IAFXFunctionDeclInstruction {
        	var pShader: FunctionDeclInstruction = null;

        	if((!this._canUsedAsFunction() || !this._isUsedAsFunction()) &&
			   (!this._isUsedInVertex())){
			   	pShader = this;
			}
			else {
				pShader = <FunctionDeclInstruction>this.clone();
			}

			pShader._prepareForPixel();
			this._pPixelShader = pShader;

			return pShader;
        }

        _prepareForVertex(): void {
        	this.setFunctionType(EFunctionType.k_Vertex);

        	var pShaderInputParamList: IAFXVariableDeclInstruction[] = this._pFunctionDefenition.getParameListForShaderInput();
        	for(var i:  number  = 0; i < pShaderInputParamList.length; i++){
        		var pParamType: IAFXVariableTypeInstruction = pShaderInputParamList[i].getType();

        		if (pParamType.isComplex() &&
        			isDef(this._pUsedVarTypeMap[pParamType._getInstructionID()]) &&
        			this._pUsedVarTypeMap[pParamType._getInstructionID()].isRead) {

        				this.setError( 2301 , { funcName: this.getName() });
        				return;
        		}
        	}

        	var pOutVariable: IAFXVariableDeclInstruction = this._getOutVariable();

        	if(!isNull(pOutVariable)){
        		if (isDef(this._pUsedVarTypeMap[pOutVariable.getType()._getInstructionID()]) &&
        			this._pUsedVarTypeMap[pOutVariable.getType()._getInstructionID()].isRead) {

        			this.setError( 2302 , { funcName: this.getName() });
        			return;
        		}

        		pOutVariable._markAsShaderOutput(true);
        	}

        	if(this._pFunctionDefenition.isComplexShaderInput()){
        		pShaderInputParamList[0].setVisible(false);
        	}

        	this._pImplementation.prepareFor(EFunctionType.k_Vertex);
        	this._pFunctionDefenition.markAsShaderDef(true);
        	this.generatesVertexAttrubutes();
        	this.generateVertexVaryings();
        }

        _prepareForPixel(): void {
        	this.setFunctionType(EFunctionType.k_Pixel);

        	var pShaderInputParamList: IAFXVariableDeclInstruction[] = this._pFunctionDefenition.getParameListForShaderInput();
        	for(var i:  number  = 0; i < pShaderInputParamList.length; i++){
        		var pParamType: IAFXVariableTypeInstruction = pShaderInputParamList[i].getType();

        		if (pParamType.isComplex() &&
        			isDef(this._pUsedVarTypeMap[pParamType._getInstructionID()]) &&
        			this._pUsedVarTypeMap[pParamType._getInstructionID()].isRead) {

        				this.setError( 2301 , { funcName: this.getName() });
        				return;
        		}
        	}

        	if(this._pFunctionDefenition.isComplexShaderInput()){
        		pShaderInputParamList[0].setVisible(false);
        	}

        	this._pImplementation.prepareFor(EFunctionType.k_Pixel);
        	this._pFunctionDefenition.markAsShaderDef(true);

        	this.generatePixelVaryings();
        }

        _setOutVariable(pVar: IAFXVariableDeclInstruction): void {
        	this._pOutVariable = pVar;
        }

        _setUsedFunctions(pUsedFunctionMap: IAFXFunctionDeclMap,
        				  pUsedFunctionList: IAFXFunctionDeclInstruction[]): void {
        	this._pUsedFunctionMap = pUsedFunctionMap;
        	this._pUsedFunctionList = pUsedFunctionList;
        }

        _setUsedVariableData(pUsedVarTypeMap: IAFXTypeUseInfoMap,
							pSharedVariableMap: IAFXVariableDeclMap,
							pGlobalVariableMap: IAFXVariableDeclMap,
							pUniformVariableMap: IAFXVariableDeclMap,
							pForeignVariableMap: IAFXVariableDeclMap,
							pTextureVariableMap: IAFXVariableDeclMap,
							pUsedComplexTypeMap: IAFXTypeMap): void {
        	this._pUsedVarTypeMap = pUsedVarTypeMap;
        	this._pSharedVariableMap = pSharedVariableMap;
        	this._pGlobalVariableMap = pGlobalVariableMap;
        	this._pUniformVariableMap = pUniformVariableMap;
        	this._pForeignVariableMap = pForeignVariableMap;
        	this._pTextureVariableMap = pTextureVariableMap;
        	this._pUsedComplexTypeMap = pUsedComplexTypeMap;
        }

        _initAfterClone(): void{
        	this._pFunctionDefenition = <FunctionDefInstruction>this._pInstructionList[0];
        	this._pImplementation = <StmtBlockInstruction>this._pInstructionList[1];
        }

        _generateInfoAboutUsedData(): void {
        	if(!isNull(this._pUsedVarTypeMap)){
        		return;
        	}

        	var pUsedData: IAFXTypeUseInfoMap = <IAFXTypeUseInfoMap>{};
        	this._pImplementation.addUsedData(pUsedData);

        	this._pUsedVarTypeMap = pUsedData;

        	if(isNull(this._pUsedComplexTypeMap)){
        		this._pSharedVariableMap = <IAFXVariableDeclMap>{};
				this._pGlobalVariableMap = <IAFXVariableDeclMap>{};
				this._pUniformVariableMap = <IAFXVariableDeclMap>{};
				this._pForeignVariableMap = <IAFXVariableDeclMap>{};
				this._pTextureVariableMap = <IAFXVariableDeclMap>{};
				this._pUsedComplexTypeMap = <IAFXTypeMap>{};
        	}

//this.addUsedComplexType(this.getReturnType().getBaseType());

        	for(var i in pUsedData) {
        		var pAnalyzedInfo: IAFXTypeUseInfoContainer = pUsedData[i];
        		var pAnalyzedType: IAFXVariableTypeInstruction = pAnalyzedInfo.type;

        		if(pAnalyzedType._isInGlobalScope()){
        			this.addGlobalVariableType(pAnalyzedType, pAnalyzedInfo.isWrite, pAnalyzedInfo.isRead);
        		}
        		else if(pAnalyzedType.isUniform()){
        			this.addUniformParameter(pAnalyzedType);
        		}
        		else if(pAnalyzedType._getScope() < this._getImplementationScope()){
        			if(!this._isUsedAsFunction()){
        				if (!isNull(this._getOutVariable()) &&
        					this._getOutVariable().getType() !== pAnalyzedType){

        					this.addUsedComplexType(pAnalyzedType.getBaseType());
        				}
        			}
        		}
        	}
        	if(!isNull(this._pUsedFunctionList)){
	        	for(var j:  number  = 0; j < this._pUsedFunctionList.length; j++){
	        		this.addUsedInfoFromFunction(this._pUsedFunctionList[j]);
	        	}
        	}
        }

        inline _getAttributeVariableMap(): IAFXVariableDeclMap {
        	return this._pAttributeVariableMap;
        }

        inline _getVaryingVariableMap(): IAFXVariableDeclMap {
        	return this._pVaryingVariableMap;
        }

        inline _getSharedVariableMap(): IAFXVariableDeclMap{
        	return this._pSharedVariableMap;
        }

        inline _getGlobalVariableMap(): IAFXVariableDeclMap{
        	return this._pGlobalVariableMap;
        }

        inline _getUniformVariableMap(): IAFXVariableDeclMap{
        	return this._pUniformVariableMap;
        }

        inline _getForeignVariableMap(): IAFXVariableDeclMap{
        	return this._pForeignVariableMap;
        }

        inline _getTextureVariableMap(): IAFXVariableDeclMap{
        	return this._pTextureVariableMap;
        }

        inline _getUsedComplexTypeMap(): IAFXTypeMap{
        	return this._pUsedComplexTypeMap;
        }

        _getAttributeVariableKeys():  number [] {
        	if(isNull(this._pAttributeVariableKeys)){
        		this._pAttributeVariableKeys = < number []><any>Object.keys(this._pAttributeVariableMap);
        	}

        	return this._pAttributeVariableKeys;
        }

        _getVaryingVariableKeys():  number [] {
        	if(isNull(this._pVaryingVariableKeys)){
        		this._pVaryingVariableKeys = < number []><any>Object.keys(this._pVaryingVariableMap);
        	}

        	return this._pVaryingVariableKeys;
        }


        _getSharedVariableKeys():  number [] {
        	if(isNull(this._pSharedVariableKeys)){
        		this._pSharedVariableKeys = < number []><any[]>Object.keys(this._pSharedVariableMap);
        	}

        	return this._pSharedVariableKeys;
        }

        _getUniformVariableKeys():  number [] {
        	if(isNull(this._pUniformVariableKeys)){
        		this._pUniformVariableKeys = < number []><any[]>Object.keys(this._pUniformVariableMap);
        	}

        	return this._pUniformVariableKeys;
        }

        _getForeignVariableKeys():  number [] {
        	if(isNull(this._pForeignVariableKeys)){
        		this._pForeignVariableKeys = < number []><any[]>Object.keys(this._pForeignVariableMap);
        	}

        	return this._pForeignVariableKeys;
        }

        _getGlobalVariableKeys():  number [] {
        	if(isNull(this._pGlobalVariableKeys)){
        		this._pGlobalVariableKeys = < number []><any[]>Object.keys(this._pGlobalVariableMap);
        	}

        	return this._pGlobalVariableKeys;
        }

        _getUsedComplexTypeKeys():  number [] {
        	if(isNull(this._pUsedComplexTypeKeys)){
        		this._pUsedComplexTypeKeys = < number []><any[]>Object.keys(this._pUsedComplexTypeMap);
        	}

        	return this._pUsedComplexTypeKeys;
        }

        _getExtSystemFunctionList(): IAFXFunctionDeclInstruction[] {
        	return this._pExtSystemFunctionList;
        }

        _getExtSystemMacrosList(): IAFXSimpleInstruction[] {
        	return this._pExtSystemMacrosList;
        }

        _getExtSystemTypeList(): IAFXTypeDeclInstruction[] {
        	return this._pExtSystemTypeList;
        }

        private generatesVertexAttrubutes(): void {
        	var pShaderInputParamList: IAFXVariableDeclInstruction[] = this._pFunctionDefenition.getParameListForShaderInput();
        	var isComplexInput: bool = this._pFunctionDefenition.isComplexShaderInput();

        	this._pAttributeVariableMap = <IAFXVariableDeclMap>{};

        	if(isComplexInput){
        		var pContainerVariable: IAFXVariableDeclInstruction = pShaderInputParamList[0];
        		var pContainerType: IAFXVariableTypeInstruction = pContainerVariable.getType();

        		var pAttributeNames: string[] = pContainerType.getFieldNameList();

        		for(var i:  number  = 0; i < pAttributeNames.length; i++){
        			var pAttr: IAFXVariableDeclInstruction = pContainerType.getField(pAttributeNames[i]);

        			if(!this.isVariableTypeUse(pAttr.getType())){
        				continue;
        			}

        			this._pAttributeVariableMap[pAttr._getInstructionID()] = pAttr;
        		}
        	}
        	else {
        		for(var i:  number  = 0; i < pShaderInputParamList.length; i++){
        			var pAttr: IAFXVariableDeclInstruction = pShaderInputParamList[i];

        			if(!this.isVariableTypeUse(pAttr.getType())){
        				continue;
        			}

        			this._pAttributeVariableMap[pAttr._getInstructionID()] = pAttr;
        		}
        	}

        	this._pAttributeVariableKeys = this._getAttributeVariableKeys();
        }

        private generateVertexVaryings(): void {
        	if(isNull(this._getOutVariable())){
        		return;
        	}

        	this._pVaryingVariableMap = <IAFXVariableDeclMap>{};

			var pContainerVariable: IAFXVariableDeclInstruction = this._getOutVariable();
        	var pContainerType: IAFXVariableTypeInstruction = pContainerVariable.getType();


        	var pVaryingNames: string[] = pContainerType.getFieldNameList();

        	for(var i:  number  = 0; i < pVaryingNames.length; i++){
    			var pVarying: IAFXVariableDeclInstruction = pContainerType.getField(pVaryingNames[i]);

    			if(!this.isVariableTypeUse(pVarying.getType())){
    				continue;
    			}

    			this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
    		}

    		this._pVaryingVariableKeys = this._getVaryingVariableKeys();
        }

        private generatePixelVaryings(): void {
        	var pShaderInputParamList: IAFXVariableDeclInstruction[] = this._pFunctionDefenition.getParameListForShaderInput();
        	var isComplexInput: bool = this._pFunctionDefenition.isComplexShaderInput();

        	this._pVaryingVariableMap = <IAFXVariableDeclMap>{};

        	if(isComplexInput){
        		var pContainerVariable: IAFXVariableDeclInstruction = pShaderInputParamList[0];
        		var pContainerType: IAFXVariableTypeInstruction = pContainerVariable.getType();

        		var pVaryingNames: string[] = pContainerType.getFieldNameList();

        		for(var i:  number  = 0; i < pVaryingNames.length; i++){
        			var pVarying: IAFXVariableDeclInstruction = pContainerType.getField(pVaryingNames[i]);

        			if(!this.isVariableTypeUse(pVarying.getType())){
        				continue;
        			}

        			this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
        		}
        	}
        	else {
        		for(var i:  number  = 0; i < pShaderInputParamList.length; i++){
        			var pVarying: IAFXVariableDeclInstruction = pShaderInputParamList[i];

        			if(!this.isVariableTypeUse(pVarying.getType())){
        				continue;
        			}

        			this._pVaryingVariableMap[pVarying._getInstructionID()] = pVarying;
        		}
        	}

        	this._pVaryingVariableKeys = this._getVaryingVariableKeys();
        }

        private cloneVarTypeUsedMap(pMap: IAFXTypeUseInfoMap, pRelationMap: IAFXInstructionMap): IAFXTypeUseInfoMap{
        	var pCloneMap: IAFXTypeUseInfoMap = <IAFXTypeUseInfoMap>{};

        	for(var j in pMap){
        		var pType: IAFXVariableTypeInstruction = isDef(pRelationMap[j]) ? pRelationMap[j] : pMap[j].type;
    			var id:  number  = pType._getInstructionID();
    			pCloneMap[id] = {
    				type: pType,
    				isRead: pMap[j].isRead,
					isWrite: pMap[j].isWrite,
					numRead: pMap[j].numRead,
					numWrite: pMap[j].numWrite,
					numUsed: pMap[j].numUsed
    			}
        	}

        	return pCloneMap;
        }

        private cloneVarDeclMap(pMap: IAFXVariableDeclMap, pRelationMap: IAFXInstructionMap): IAFXVariableDeclMap {
        	var pCloneMap: IAFXVariableDeclMap = <IAFXVariableDeclMap>{};

        	for(var i in pMap){
        		var pVar: IAFXVariableDeclInstruction = isDef(pRelationMap[i]) ? pRelationMap[i] : pMap[i];

        		if(!isNull(pVar)){
        			var id:  number  = pVar._getInstructionID();
        			pCloneMap[id] = pVar;
        		}
        	}

        	return pCloneMap;
        }

        private cloneTypeMap(pMap: IAFXTypeMap, pRelationMap: IAFXInstructionMap): IAFXTypeMap {
        	var pCloneMap: IAFXTypeMap = <IAFXTypeMap>{};

        	for(var i in pMap){
        		var pVar: IAFXTypeInstruction = (isDef(pRelationMap[i]) ? pRelationMap[i] : pMap[i]);
        		var id:  number  = pVar._getInstructionID();
        		pCloneMap[id] = pVar;
        	}

        	return pCloneMap;
        }

        private addGlobalVariableType(pVariableType: IAFXVariableTypeInstruction,
        							  isWrite: bool, isRead: bool): void {
        	if(!pVariableType.isFromVariableDecl()){
        		return;
        	}

        	var pVariable: IAFXVariableDeclInstruction = <IAFXVariableDeclInstruction>pVariableType._getParentVarDecl();
        	var pMainVariable: IAFXVariableDeclInstruction = pVariableType._getMainVariable();
        	var iMainVar:  number  = pMainVariable._getInstructionID();
        	var iVar:  number  = pVariable._getInstructionID();

        	if(pMainVariable.getType().isShared()){
// this._pSharedVariableMap[iVar] = pVariable;
        		this._pSharedVariableMap[iMainVar] = pMainVariable;
        	}
        	else if(pMainVariable.getType().isForeign()){
        		this._pForeignVariableMap[iMainVar] = pMainVariable;
        	}
        	else if(isWrite){
        		this._pGlobalVariableMap[iMainVar] = pMainVariable;
        		if(isDefAndNotNull(this._pUniformVariableMap[iMainVar])){
        			this._pUniformVariableMap[iMainVar] = null;
        		}
        	}
        	else {
        		if(!isDef(this._pGlobalVariableMap[iMainVar])){
        			this._pUniformVariableMap[iMainVar] = pMainVariable;
        		}
        	}

        	if(pVariable.isSampler() && pVariable.hasInitializer()){
        		var pInitExpr: IAFXInitExprInstruction = pVariable.getInitializeExpr();
        		var pTexture: IAFXVariableDeclInstruction = null;
        		var pSamplerStates: SamplerStateBlockInstruction = null;

        		if(pVariableType.isArray()){
        			var pList: IAFXInitExprInstruction[] = <IAFXInitExprInstruction[]>pInitExpr.getInstructions();
        			for(var i:  number  = 0; i < pList.length; i++){
        				pSamplerStates = <SamplerStateBlockInstruction>pList[i].getInstructions()[0];
        				pTexture = pSamplerStates.getTexture();

        				this._pTextureVariableMap[pTexture._getInstructionID()] = pTexture;
        			}
        		}
        		else {
        			pSamplerStates = <SamplerStateBlockInstruction>pInitExpr.getInstructions()[0];
        			pTexture = pSamplerStates.getTexture();

        			this._pTextureVariableMap[pTexture._getInstructionID()] = pTexture;
        		}
        	}

// this.addUsedComplexType(pMainVariable.getType().getBaseType());
        }

        private addUniformParameter(pType: IAFXVariableTypeInstruction): void {
        	var pMainVariable: IAFXVariableDeclInstruction = pType._getMainVariable();
        	var iMainVar:  number  = pMainVariable._getInstructionID();

        	if(isDef(this._pGlobalVariableMap[iMainVar])){
        		logger.setSourceLocation( "fx/FunctionInstruction.ts" , 825 ); logger.error("UNEXPECTED ERROR WITH UNIFORM_PARAMETER"); ;
        	}

        	this._pUniformVariableMap[iMainVar] = pMainVariable;
        	this.addUsedComplexType(pMainVariable.getType().getBaseType());
        }

        private addUsedComplexType(pType: IAFXTypeInstruction): void {
        	if(pType.isBase() || isDef(this._pUsedComplexTypeMap[pType._getInstructionID()])){
        		return;
        	}

        	this._pUsedComplexTypeMap[pType._getInstructionID()] = pType;

        	var pFieldNameList: string[] = pType.getFieldNameList();

        	for(var i:  number  = 0; i < pFieldNameList.length; i++){
        		this.addUsedComplexType(pType.getFieldType(pFieldNameList[i]).getBaseType());
        	}
        }

        private addUsedInfoFromFunction(pFunction: IAFXFunctionDeclInstruction): void {
        	pFunction._generateInfoAboutUsedData();

    		var pSharedVarMap: IAFXVariableDeclMap = pFunction._getSharedVariableMap();
    		var pGlobalVarMap: IAFXVariableDeclMap = pFunction._getGlobalVariableMap();
    		var pUniformVarMap: IAFXVariableDeclMap = pFunction._getUniformVariableMap();
    		var pForeignVarMap: IAFXVariableDeclMap = pFunction._getForeignVariableMap();
    		var pTextureVarMap: IAFXVariableDeclMap = pFunction._getTextureVariableMap();
    		var pUsedComplexTypeMap: IAFXTypeMap = pFunction._getUsedComplexTypeMap();

    		for(var j in pSharedVarMap){
    			this._pSharedVariableMap[pSharedVarMap[j]._getInstructionID()] = pSharedVarMap[j];
    		}

    		for(var j in pForeignVarMap){
    			this._pForeignVariableMap[pForeignVarMap[j]._getInstructionID()] = pForeignVarMap[j];
    		}

    		for(var j in pTextureVarMap){
    			this._pTextureVariableMap[pTextureVarMap[j]._getInstructionID()] = pTextureVarMap[j];
    		}

    		for(var j in pGlobalVarMap){
    			this._pGlobalVariableMap[pGlobalVarMap[j]._getInstructionID()] = pGlobalVarMap[j];

    			if(isDefAndNotNull(this._pUniformVariableMap[pGlobalVarMap[j]._getInstructionID()])){
    				this._pUniformVariableMap[pGlobalVarMap[j]._getInstructionID()] = null;
    			}
    		}

    		for(var j in pUniformVarMap){
    			if(!isDef(this._pGlobalVariableMap[pUniformVarMap[j]._getInstructionID()])){
    				this._pUniformVariableMap[pUniformVarMap[j]._getInstructionID()] = pUniformVarMap[j];
    			}
    		}

    		for(var j in pUsedComplexTypeMap){
    			this._pUsedComplexTypeMap[pUsedComplexTypeMap[j]._getInstructionID()] = pUsedComplexTypeMap[j];
    		}

    		this.addExtSystemFunction(pFunction);
        }

        private addExtSystemFunction(pFunction: IAFXFunctionDeclInstruction): void {
        	if(isNull(this._pExtSystemFunctionList)){
        		this._pExtSystemFunctionList = [];
        		this._pExtSystemTypeList = [];
        		this._pExtSystemMacrosList = [];
        	}

        	if(pFunction._getInstructionType() === EAFXInstructionTypes.k_SystemFunctionInstruction){
	        	if(this._pExtSystemFunctionList.indexOf(pFunction) !== -1){
	        		return;
	        	}

	        	this._pExtSystemFunctionList.push(pFunction);
        	}

        	var pTypes = pFunction._getExtSystemTypeList();
			var pMacroses = pFunction._getExtSystemMacrosList();
			var pFunctions = pFunction._getExtSystemFunctionList();

			if(!isNull(pTypes)){
				for(var j:  number  = 0; j < pTypes.length; j++){
					if(this._pExtSystemTypeList.indexOf(pTypes[j]) === -1){
						this._pExtSystemTypeList.push(pTypes[j]);
					}
				}
			}

			if(!isNull(pMacroses)){
				for(var j:  number  = 0; j < pMacroses.length; j++){
					if(this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1){
						this._pExtSystemMacrosList.push(pMacroses[j]);
					}
				}
			}

			if(!isNull(pFunctions)){
				for(var j:  number  = 0; j < pFunctions.length; j++){
					if(this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1){
						this._pExtSystemFunctionList.push(pFunctions[j]);
					}
				}
			}
        }

        private isVariableTypeUse(pVariableType: IAFXVariableTypeInstruction): bool {
        	var id:  number  = pVariableType._getInstructionID();

        	if(!isDef(this._pUsedVarTypeMap[id])){
        		return false;
        	}

        	if(this._pUsedVarTypeMap[id].numUsed === 0){
        		return false;
        	}

        	return true;
        }
	}

	export class SystemFunctionInstruction extends DeclInstruction implements IAFXFunctionDeclInstruction {
	    private _pExprTranslator: ExprTemplateTranslator = null;
	    private _pName: IAFXIdInstruction = null;
	    private _pReturnType: VariableTypeInstruction = null;
	    private	_pArguments: IAFXTypedInstruction[] = null;

	    private _sDefinition: string = "";
	    private _sImplementation: string = "";

	    private _pExtSystemTypeList: IAFXTypeDeclInstruction[] = null;
	    private _pExtSystemFunctionList: IAFXFunctionDeclInstruction[] = null;
	    private _pExtSystemMacrosList: IAFXSimpleInstruction[] = null;

		constructor(sName: string, pReturnType: IAFXTypeInstruction,
					pExprTranslator: ExprTemplateTranslator,
					pArgumentTypes: IAFXTypeInstruction[]) {
			super();

			this._eInstructionType = EAFXInstructionTypes.k_SystemFunctionInstruction;

			this._pName = new IdInstruction();
			this._pName.setName(sName);
			this._pName.setParent(this);

			this._pReturnType = new VariableTypeInstruction();
			this._pReturnType.pushType(pReturnType);
			this._pReturnType.setParent(this);

			this._pArguments = [];

			if(!isNull(pArgumentTypes)){
				for(var i:  number  = 0; i < pArgumentTypes.length; i++){
					var pArgument: TypedInstruction = new TypedInstruction();
					pArgument.setType(pArgumentTypes[i]);
					pArgument.setParent(this);

					this._pArguments.push(pArgument);
				}
			}

			this._pExprTranslator = pExprTranslator;
		}

		setDeclCode(sDefenition: string, sImplementation: string){
			this._sDefinition = sDefenition;
			this._sImplementation = sImplementation;
		}

		toFinalCode() : string {
			return this._sDefinition + this._sImplementation;
		}

		toFinalDefCode(): string {
			return this._sDefinition;
		}

		setUsedSystemData(pTypeList: IAFXTypeDeclInstruction[],
						  pFunctionList: IAFXFunctionDeclInstruction[],
						  pMacrosList: IAFXSimpleInstruction[]): void {

			this._pExtSystemTypeList = pTypeList;
			this._pExtSystemFunctionList = pFunctionList;
			this._pExtSystemMacrosList = pMacrosList;
		}

		closeSystemDataInfo(): void {
			for(var i:  number  = 0; i < this._pExtSystemFunctionList.length; i++){
				var pFunction: IAFXFunctionDeclInstruction = this._pExtSystemFunctionList[i];

				var pTypes = pFunction._getExtSystemTypeList();
				var pMacroses = pFunction._getExtSystemMacrosList();
				var pFunctions = pFunction._getExtSystemFunctionList();

				for(var j:  number  = 0; j < pTypes.length; j++){
					if(this._pExtSystemTypeList.indexOf(pTypes[j]) === -1){
						this._pExtSystemTypeList.push(pTypes[j]);
					}
				}

				for(var j:  number  = 0; j < pMacroses.length; j++){
					if(this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1){
						this._pExtSystemMacrosList.push(pMacroses[j]);
					}
				}

				for(var j:  number  = 0; j < pFunctions.length; j++){
					if(this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1){
						this._pExtSystemFunctionList.push(pFunctions[j]);
					}
				}
			}
		}

		setExprTranslator(pExprTranslator: ExprTemplateTranslator): void {
			this._pExprTranslator = pExprTranslator;
		}

		getNameId(): IAFXIdInstruction {
			return this._pName;
		}

		getArguments(): IAFXTypedInstruction[] {
			return this._pArguments;
		}

		inline getNumNeededArguments():  number  {
			return this._pArguments.length;
		}

		inline hasImplementation(): bool {
			return true;
		}

		inline getType(): IAFXVariableTypeInstruction {
			return this.getReturnType();
		}

		inline getReturnType(): IAFXVariableTypeInstruction {
			return this._pReturnType;
		}

		inline getFunctionType(): EFunctionType {
			return EFunctionType.k_Function;
		}

		inline setFunctionType(eFunctionType: EFunctionType): void {
        }

		closeArguments(pArguments: IAFXInstruction[]): IAFXInstruction[]{
			return this._pExprTranslator.toInstructionList(pArguments);
		}

		setFunctionDef(pFunctionDef: IAFXDeclInstruction): void {
		}

		setImplementation(pImplementation: IAFXStmtInstruction): void {
		}

		inline clone(pRelationMap?: IAFXInstructionMap): SystemFunctionInstruction {
			return this;
		}

		_addOutVariable(pVariable: IAFXVariableDeclInstruction): bool{
			return false;
		}

		_getOutVariable(): IAFXVariableDeclInstruction{
			return null;
		}

		_getVertexShader(): IAFXFunctionDeclInstruction{
			return null;
		}

		_getPixelShader(): IAFXFunctionDeclInstruction{
			return null;
		}

		_markUsedAs(eUsedType: EFunctionType): void {
		}

		_isUsedAs(eUsedType: EFunctionType): bool{
			return true;
		}

		_isUsedAsFunction(): bool {
			return true;
		}

		_isUsedAsVertex(): bool {
			return true;
		}

		_isUsedAsPixel(): bool {
			return true;
		}

		_markUsedInVertex(): void {
		}

		_markUsedInPixel(): void {
		}

		_isUsedInVertex(): bool {
			return null;
		}

		_isUsedInPixel(): bool {
			return null;
		}

		_isUsed(): bool{
			return null;
		}

		_checkVertexUsage(): bool {
			return this._isForVertex();
		}

		_checkPixelUsage(): bool {
			return this._isForPixel();
		}

		_checkDefenitionForVertexUsage(): bool {
			return false;
		}

		_checkDefenitionForPixelUsage(): bool {
			return false;
		}

		_canUsedAsFunction(): bool{
			return true;
		}

		_notCanUsedAsFunction(): void{}

		_addUsedFunction(pFunction: IAFXFunctionDeclInstruction): bool {
			return false;
		}

		_addUsedVariable(pVariable: IAFXVariableDeclInstruction): void {

		}

		_getUsedFunctionList(): IAFXFunctionDeclInstruction[] {
			return null;
		}

		_isBlackListFunction(): bool {
			return false;
		}

		_addToBlackList(): void {
		}

		_getStringDef(): string {
			return "system_func";
		}

		_convertToVertexShader(): IAFXFunctionDeclInstruction {
			return null;
		}

        _convertToPixelShader(): IAFXFunctionDeclInstruction {
        	return null;
        }

        _prepareForVertex(): void{}
        _prepareForPixel(): void{}

        addUsedVariableType(pType: IAFXVariableTypeInstruction, eUsedMode: EVarUsedMode): bool {
        	return false;
        }

        _generateInfoAboutUsedData(): void{

        }

        inline _getAttributeVariableMap(): IAFXVariableDeclMap {
        	return null;
        }

        inline _getVaryingVariableMap(): IAFXVariableDeclMap {
        	return null;
        }

        inline _getSharedVariableMap(): IAFXVariableDeclMap{
			return null;
        }

        inline _getGlobalVariableMap(): IAFXVariableDeclMap{
        	return null;
        }

        inline _getUniformVariableMap(): IAFXVariableDeclMap{
        	return null;
        }

        inline _getForeignVariableMap(): IAFXVariableDeclMap{
        	return null;
        }

        inline _getTextureVariableMap(): IAFXVariableDeclMap{
        	return null;
        }

        inline _getUsedComplexTypeMap(): IAFXTypeMap{
        	return null;
        }

        inline _getAttributeVariableKeys():  number [] {
        	return null;
        }

        inline _getVaryingVariableKeys():  number [] {
        	return null;
        }

        inline _getSharedVariableKeys():  number [] {
        	return null;
        }

        inline _getUniformVariableKeys():  number [] {
        	return null;
        }

        inline _getForeignVariableKeys():  number [] {
        	return null;
        }

        inline _getGlobalVariableKeys():  number [] {
        	return null;
        }

        inline _getUsedComplexTypeKeys():  number [] {
        	return null;
        }

        _getExtSystemFunctionList(): IAFXFunctionDeclInstruction[] {
        	return this._pExtSystemFunctionList;
        }

        _getExtSystemMacrosList(): IAFXSimpleInstruction[] {
        	return this._pExtSystemMacrosList;
        }

        _getExtSystemTypeList(): IAFXTypeDeclInstruction[] {
        	return this._pExtSystemTypeList;
        }

	}

/**
	 * Represent type func(...args)[:Semantic]
	 * EMPTY_OPERTOR VariableTypeInstruction IdInstruction VarDeclInstruction ... VarDeclInstruction
	 */

	export class FunctionDefInstruction extends DeclInstruction {
		private _pParameterList: IAFXVariableDeclInstruction[] = null;
		private _pParamListForShaderCompile: IAFXVariableDeclInstruction[] = null;
		private _pParamListForShaderInput: IAFXVariableDeclInstruction[] = null;
		private _isComplexShaderInput: bool = false;

		private _pReturnType: IAFXVariableTypeInstruction = null;
		private _pFunctionName: IAFXIdInstruction = null;
		private _nParamsNeeded:  number  = 0;
		private _sDefinition: string = "";
		private _isAnalyzedForVertexUsage: bool = false;
		private _isAnalyzedForPixelUsage: bool = false;
		private _bCanUsedAsFunction: bool = true;

		private _bShaderDef: bool = false;

//private _sHash: string = "";

		constructor() {
			super();
			this._pInstructionList = null;
			this._pParameterList = [];
			this._eInstructionType = EAFXInstructionTypes.k_FunctionDefInstruction;
		}

		toFinalCode(): string {
			var sCode: string = "";

			if(!this.isShaderDef()){

				sCode += this._pReturnType.toFinalCode();
				sCode += " " + this._pFunctionName.toFinalCode();
				sCode += "(";

				for(var i:  number  = 0; i < this._pParameterList.length; i++){
					sCode += this._pParameterList[i].toFinalCode();

					if(i !== this._pParameterList.length - 1){
						sCode += ",";
					}
				}

				sCode += ")";
			}
			else {
				sCode = "void " + this._pFunctionName.toFinalCode() + "()";
			}

			return sCode;
		}

		inline setType(pType: IAFXTypeInstruction): void {
			this.setReturnType(<IAFXVariableTypeInstruction>pType);
		}

		inline getType(): IAFXTypeInstruction {
			return <IAFXTypeInstruction>this.getReturnType();
		}

		inline setReturnType(pReturnType: IAFXVariableTypeInstruction): bool {
			this._pReturnType = pReturnType;
			pReturnType.setParent(this);
			return true;
		}
		inline getReturnType(): IAFXVariableTypeInstruction {
			return this._pReturnType;
		}

		inline setFunctionName(pNameId: IAFXIdInstruction): bool {
			this._pFunctionName = pNameId;
			pNameId.setParent(this);
			return true;
		}

		inline getName(): string {
			return this._pFunctionName.getName();
		}

		inline getNameId(): IAFXIdInstruction {
			return this._pFunctionName;
		}

		inline getArguments(): IAFXVariableDeclInstruction[]{
			return this._pParameterList;
		}

		inline getNumNeededArguments():  number {
			return this._nParamsNeeded;
		}

		inline markAsShaderDef(isShaderDef: bool): void {
			this._bShaderDef = isShaderDef;
		}

		inline isShaderDef(): bool {
			return this._bShaderDef;
		}

		addParameter(pParameter: IAFXVariableDeclInstruction, isStrictModeOn?: bool): bool {
			if (this._pParameterList.length > this._nParamsNeeded &&
				!pParameter.hasInitializer()) {

				this.setError( 2245 ,
							  { funcName: this._pFunctionName.getName(),
							  	varName: pParameter.getName() });
				return false;
			}

			var pParameterType: IAFXVariableTypeInstruction = pParameter.getType();

			if (pParameterType.isPointer() || pParameterType._containPointer()){
				if (pParameterType.hasUsage("uniform") ||
					pParameterType.hasUsage("out") ||
					pParameterType.hasUsage("inout")){

					this.setError( 2265 ,
							  	  { funcName: this._pFunctionName.getName(),
							  	varName: pParameter.getName() });
					return false;
				}

				this._isAnalyzedForVertexUsage = false;
				this._isAnalyzedForPixelUsage = true;

				this._setForPixel(false);
				this._bCanUsedAsFunction = false;
				pParameterType._setVideoBufferInDepth();
			}
			else if(!isStrictModeOn){

				if (pParameterType.isComplex() &&
				    !pParameterType.hasFieldWithoutSemantic() &&
					pParameterType.hasAllUniqueSemantics()){

					if (pParameter.getSemantic() === "" &&
						pParameterType.hasAllUniqueSemantics() &&
						!pParameterType.hasFieldWithoutSemantic()){

						pParameterType._addPointIndexInDepth();
					}
					else {
						pParameterType.addPointIndex(false);
						pParameterType._setVideoBufferInDepth();
					}
				}
				else if(pParameter.getSemantic() !== ""){
					pParameterType.addPointIndex(false);
					pParameterType._setVideoBufferInDepth();
				}
			}

			this._pParameterList.push(pParameter);
			pParameter.setParent(this);

			if(!pParameter.hasInitializer()){
				this._nParamsNeeded++;
			}

			return true;
		}

		inline getParameListForShaderInput(): IAFXVariableDeclInstruction[] {
			return this._pParamListForShaderInput;
		}

		inline isComplexShaderInput(): bool {
			return this._isComplexShaderInput;
		}

		clone(pRelationMap: IAFXInstructionMap = <IAFXInstructionMap>{}): FunctionDefInstruction {
			var pClone: FunctionDefInstruction = <FunctionDefInstruction>super.clone(pRelationMap);

			pClone.setFunctionName(<IAFXIdInstruction>this._pFunctionName.clone(pRelationMap));
			pClone.setReturnType(<IAFXVariableTypeInstruction>this.getReturnType().clone(pRelationMap));

			for(var i:  number  = 0; i < this._pParameterList.length; i++){
				pClone.addParameter(this._pParameterList[i].clone(pRelationMap));
			}

			var pShaderParams: IAFXVariableDeclInstruction[] = [];
			for(var i:  number  = 0; i < this._pParamListForShaderInput.length; i++){
				pShaderParams.push(this._pParamListForShaderInput[i].clone(pRelationMap));
			}

			pClone._setShaderParams(pShaderParams, this._isComplexShaderInput);
			pClone._setAnalyzedInfo(this._isAnalyzedForVertexUsage,
									this._isAnalyzedForPixelUsage,
									this._bCanUsedAsFunction);

			return pClone;
		}

		_setShaderParams(pParamList: IAFXVariableDeclInstruction[], isComplexInput: bool): void {
			this._pParamListForShaderInput = pParamList;
			this._isComplexShaderInput = isComplexInput;
		}

		_setAnalyzedInfo(isAnalyzedForVertexUsage: bool,
						 isAnalyzedForPixelUsage: bool,
						 bCanUsedAsFunction: bool): void {
			this._isAnalyzedForVertexUsage = isAnalyzedForVertexUsage;
			this._isAnalyzedForPixelUsage = isAnalyzedForPixelUsage;
			this._bCanUsedAsFunction = bCanUsedAsFunction;
		}

		_getStringDef(): string {
			if(this._sDefinition === ""){
				this._sDefinition = this._pReturnType.getHash() + " " + this.getName() + "(";

				for(var i:  number  = 0; i < this._pParameterList.length; i++){
					this._sDefinition += this._pParameterList[i].getType().getHash() + ",";
				}

				this._sDefinition += ")";
			}

			return this._sDefinition;
		}

		_canUsedAsFunction(): bool {
			return this._bCanUsedAsFunction;
		}

		_checkForVertexUsage(): bool {
			if(this._isAnalyzedForVertexUsage){
				return this._isForVertex();
			}

			this._isAnalyzedForVertexUsage = true;

			var isGood: bool = true;

			isGood = this.checkReturnTypeForVertexUsage();
			if(!isGood){
				this._setForVertex(false);
				return false;
			}

			isGood = this.checkArgumentsForVertexUsage();
			if(!isGood){
				this._setForVertex(false);
				return false;
			}

			this._setForVertex(true);

			return true;
		}

		_checkForPixelUsage(): bool {
			if(this._isAnalyzedForPixelUsage){
				return this._isForPixel();
			}

			this._isAnalyzedForPixelUsage = true;

			var isGood: bool = true;

			isGood = this.checkReturnTypeForPixelUsage();
			if(!isGood){
				this._setForPixel(false);
				return false;
			}

			isGood = this.checkArgumentsForPixelUsage();
			if(!isGood){
				this._setForPixel(false);
				return false;
			}

			this._setForPixel(true);

			return true;
		}

		private checkReturnTypeForVertexUsage(): bool {
			var pReturnType: IAFXVariableTypeInstruction = this._pReturnType;
			var isGood: bool = true;

			if(pReturnType.isEqual(getEffectBaseType("void"))){
				return true;
			}

			if(pReturnType.isComplex()){
				isGood = !pReturnType.hasFieldWithoutSemantic();
				if(!isGood){
					return false;
				}

				isGood = pReturnType.hasAllUniqueSemantics();
				if(!isGood) {
					return false;
				}

// isGood = pReturnType.hasFieldWithSematic("POSITION");
// if(!isGood){
// 	return false;
// }

				isGood = !pReturnType._containSampler();
				if(!isGood){
					return false;
				}

				isGood = !pReturnType._containPointer() && !pReturnType.isPointer();
				if(!isGood){
					return false;
				}

				isGood = !pReturnType._containComplexType();
				if(!isGood){
					return false;
				}

				return true;
			}
			else {
				isGood = pReturnType.isEqual(getEffectBaseType("float4"));
				if(!isGood){
					return false;
				}

				isGood = (this.getSemantic() === "POSITION");
				if(!isGood){
					return false;
				}

				return true;
			}
		}

		private checkReturnTypeForPixelUsage(): bool {
			var pReturnType: IAFXVariableTypeInstruction = this._pReturnType;
			var isGood: bool = true;

			if(pReturnType.isEqual(getEffectBaseType("void"))){
				return true;
			}

			isGood = pReturnType.isBase();
			if(!isGood){
				return false;
			}

			isGood = pReturnType.isEqual(getEffectBaseType("float4"));
			if(!isGood){
				return false;
			}

			isGood = this.getSemantic() === "COLOR";
			if(!isGood){
				return false;
			}

			return true;
		}

		private checkArgumentsForVertexUsage(): bool {
			var pArguments: IAFXVariableDeclInstruction[] = this._pParameterList;
			var isAttributeByStruct: bool = false;
			var isAttributeByParams: bool = false;
			var isStartAnalyze: bool = false;

			this._pParamListForShaderInput = [];
			this._pParamListForShaderCompile = [];

			for(var i:  number  = 0; i < pArguments.length; i++){
				var pParam: IAFXVariableDeclInstruction = pArguments[i];

				if(pParam.isUniform()){
					this._pParamListForShaderCompile.push(pParam);
					continue;
				}

				if(!isStartAnalyze){
					if(pParam.getSemantic() === ""){
						if (pParam.getType().isBase() ||
							pParam.getType().hasFieldWithoutSemantic() ||
							!pParam.getType().hasAllUniqueSemantics()){
							return false;
						}

						isAttributeByStruct = true;
					}
					else if(pParam.getSemantic() !== ""){
						if (pParam.getType().isComplex() &&
							(pParam.getType().hasFieldWithoutSemantic() ||
							!pParam.getType().hasAllUniqueSemantics())){
							return false;
						}

						isAttributeByParams = true;
					}

					isStartAnalyze = true;
				}
				else if (isAttributeByStruct){
					return false;
				}
				else if (isAttributeByParams){
					if(pParam.getSemantic() === "") {
						return false;
					}

					if (pParam.getType().isComplex() &&
						(pParam.getType().hasFieldWithoutSemantic() ||
						!pParam.getType().hasAllUniqueSemantics())){
						return false;
					}
				}

				this._pParamListForShaderInput.push(pParam);
			}

			if(isAttributeByStruct){
				this._isComplexShaderInput = true;
			}

			return true;
		}

		private checkArgumentsForPixelUsage(): bool {
			var pArguments: IAFXVariableDeclInstruction[] = this._pParameterList;
			var isVaryingsByStruct: bool = false;
			var isVaryingsByParams: bool = false;
			var isStartAnalyze: bool = false;

			this._pParamListForShaderInput = [];
			this._pParamListForShaderCompile = [];

			for(var i:  number  = 0; i < pArguments.length; i++){
				var pParam: IAFXVariableDeclInstruction = pArguments[i];

				if(pParam.isUniform()){
					this._pParamListForShaderCompile.push(pParam);
					continue;
				}

				if(!isStartAnalyze){
					if(pParam.getSemantic() === ""){
						if (pParam.getType().isBase() ||
							pParam.getType().hasFieldWithoutSemantic() ||
							!pParam.getType().hasAllUniqueSemantics() ||
							pParam.getType()._containSampler() ||
							pParam.getType()._containPointer() ||
							pParam.getType().isPointer()){
							return false;
						}

						isVaryingsByStruct = true;
					}
					else if(pParam.getSemantic() !== ""){
						if (pParam.getType().isPointer() ||
						    pParam.getType()._containPointer() ||
						    pParam.getType()._containSampler() ||
						    isSamplerType(pParam.getType())){
							return false;
						}

						if (pParam.getType().isComplex() &&
							(pParam.getType().hasFieldWithoutSemantic() ||
							!pParam.getType().hasAllUniqueSemantics())){
							return false;
						}

						isVaryingsByParams = true;
					}

					isStartAnalyze = true;
				}
				else if (isVaryingsByStruct){
					return false;
				}
				else if (isVaryingsByParams){
					if(pParam.getSemantic() === "") {
						return false;
					}

					if (pParam.getType().isPointer() ||
					    pParam.getType()._containPointer() ||
					    pParam.getType()._containSampler() ||
					    isSamplerType(pParam.getType())){
						return false;
					}

					if (pParam.getType().isComplex() &&
						(pParam.getType().hasFieldWithoutSemantic() ||
						!pParam.getType().hasAllUniqueSemantics())){
						return false;
					}
				}

				this._pParamListForShaderInput.push(pParam);
			}

			if(isVaryingsByStruct){
				this._isComplexShaderInput = true;
			}

			return true;
		}
// getHash(): string {
// 	if(this._sHash === "") {
// 		this.calcHash();
// 	}

// 	return this._sHash;
// }

// private calcHash(): void {
// 	var sHash: string = "";
// 	sHash = this._pFunctionName.getName();
// 	sHash += "(";

// 	for(var i: uint = 0; i < this._pParameterList.length; i++){
// 		sHash += this._pParameterList[i]
// 	}

// }
	}

}















module akra.fx {







	export interface SystemTypeMap {
		[sTypeName: string]: SystemTypeInstruction;
	}

	export interface SystemFunctionMap {
		[sFuncName: string]: SystemFunctionInstruction[];
	}

	export interface TechniqueMap {
		[sTechniqueName: string]: IAFXTechniqueInstruction;
	}

	export class Effect implements IAFXEffect {
		private _pComposer: IAFXComposer = null;

		private _pParseTree: IParseTree = null;
		private _pAnalyzedNode: IParseNode = null;

		private _pEffectScope: ProgramScope = null;
		private _pCurrentInstruction: IAFXInstruction = null;
		private _pCurrentFunction: IAFXFunctionDeclInstruction = null;

		private _pStatistics: IAFXEffectStats = null;

		private _sAnalyzedFileName: string = "";

		private _pSystemMacros: IAFXSimpleInstructionMap = null;
		private _pSystemTypes: SystemTypeMap = null;
		private _pSystemFunctionsMap: SystemFunctionMap = null;
		private _pSystemFunctionHashMap: BoolMap = null;
		private _pSystemVariables: IAFXVariableDeclMap = null;

		private _pPointerForExtractionList: IAFXVariableDeclInstruction[] = null;

		private _pFunctionWithImplementationList: IAFXFunctionDeclInstruction[] = null;

		private _pTechniqueList: IAFXTechniqueInstruction[] = null;
		private _pTechniqueMap: TechniqueMap = null;

		private _isAnalyzeInPass: bool = false;

		private _sProvideNameSpace: string = "";

		private _pGlobalComponentList: IAFXComponent[] = null;
		private _pGlobalComponetShiftList:  number [] = null;

		private _pAddedTechniqueList: IAFXTechniqueInstruction[] = null;

		static pSystemMacros: IAFXSimpleInstructionMap= null;
		static pSystemTypes: SystemTypeMap = null;
		static pSystemFunctions: SystemFunctionMap = null;
		static pSystemVariables: IAFXVariableDeclMap = null;
		static pSystemVertexOut: ComplexTypeInstruction = null;

		constructor(pComposer: IAFXComposer) {
			this._pComposer = pComposer;

			this._pParseTree = null;
			this._pAnalyzedNode = null;

			this._pEffectScope = new ProgramScope();
			this._pCurrentInstruction = null;

			this._pStatistics = null;
			this._sAnalyzedFileName = "";

			this._pPointerForExtractionList = [];

			this._pFunctionWithImplementationList = [];
			this._pTechniqueList = [];
			this._pTechniqueMap = <TechniqueMap>{};

			this.initSystemMacros();
			this.initSystemTypes();
			this.initSystemFunctions();
			this.initSystemVariables();
		}

		analyze(pTree: IParseTree): bool {
			var pRootNode: IParseNode = pTree.root;
			var iParseTime:  number  = akra.now();

// LOG(this);

			this._pParseTree = pTree;
			this._pStatistics = <IAFXEffectStats>{time: 0};

			try{
				this.newScope();
// LOG("ok");
				this.analyzeGlobalUseDecls();
// LOG("ok");
				this.analyzeGlobalProvideDecls();
// LOG("ok");
				this.analyzeGlobalTypeDecls();
// LOG("ok");
				this.analyzeFunctionDefinitions();
// LOG("ok");
				this.analyzeGlobalImports();
// LOG("ok");
				this.analyzeTechniqueImports();
// LOG("ok");

				this.analyzeVariableDecls();
// LOG("ok");
				this.analyzeFunctionDecls();
// LOG("ok");
				this.analyzeTechniques();
// LOG("ok");

// this.analyzeTypes();

// this.preAnalyzeFunctions();
// this.preAnalyzeVariables();
// this.preAnalyzeTechniques();
// this.analyzeDecls();

// this.analyzeEffect();
// this.postAnalyzeEffect();
// this.checkEffect();

				this.endScope();
			}
			catch(e){

				throw e;

			}

//Stats
			iParseTime = akra.now() - iParseTime;
			this._pStatistics.time = iParseTime;

//LOG(this, iParseTime);

			return true;
		}

		getStats(): IAFXEffectStats {
			return this._pStatistics;
		}

		setAnalyzedFileName(sFileName: string): void {
			this._sAnalyzedFileName = sFileName;
		}

		clear(): void {
		}

		inline getTechniqueList(): IAFXTechniqueInstruction[]{
			return this._pTechniqueList;
		}

		static getBaseVertexOutType(): ComplexTypeInstruction {
			return Effect.pSystemVertexOut;
		}
		static getSystemType(sTypeName: string): SystemTypeInstruction {
//bool, string, float and others
        	return isDef(Effect.pSystemTypes[sTypeName]) ? Effect.pSystemTypes[sTypeName] : null;
        }

        static getSystemVariable(sName: string): IAFXVariableDeclInstruction {
        	return isDef(Effect.pSystemVariables[sName]) ? Effect.pSystemVariables[sName] : null;
        }

        static getSystemMacros(sName: string): IAFXSimpleInstruction {
        	return isDef(Effect.pSystemMacros[sName]) ? Effect.pSystemMacros[sName] : null;
        }

        static findSystemFunction(sFunctionName: string,
							 	  pArguments: IAFXTypedInstruction[]): IAFXFunctionDeclInstruction {
			var pSystemFunctions: SystemFunctionInstruction[] = Effect.pSystemFunctions[sFunctionName];

			if(!isDef(pSystemFunctions)){
				return null;
			}

			if(isNull(pArguments)) {
				for(var i:  number  = 0; i < pSystemFunctions.length; i++){
					if(pSystemFunctions[i].getNumNeededArguments() === 0){
						return pSystemFunctions[i];
					}
				}
			}

			for(var i:  number  = 0; i < pSystemFunctions.length; i++){
				if(pArguments.length !== pSystemFunctions[i].getNumNeededArguments()){
					continue;
				}

				var pTestedArguments: IAFXTypedInstruction[] = pSystemFunctions[i].getArguments();

				var isOk: bool = true;

				for(var j:  number  = 0; j < pArguments.length; j++){
					isOk = false;

					if(!pArguments[j].getType().isEqual(pTestedArguments[j].getType())){
						break;
					}

					isOk = true;
				}

				if(isOk){
					return pSystemFunctions[i];
				}
			}
		}

		static createVideoBufferVariable(): IAFXVariableDeclInstruction {
			var pBuffer: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pBufferType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			var pBufferName: IAFXIdInstruction = new IdInstruction();

			pBufferType.pushType(Effect.getSystemType("video_buffer"));

			pBuffer.push(pBufferType, true);
			pBuffer.push(pBufferName, true);

			return pBuffer;
		}

		private generateSuffixLiterals(pLiterals: string[], pOutput: BoolMap, iDepth?:  number  = 0): void {
			if(iDepth >= pLiterals.length){
				return;
			}

			if(iDepth === 0){
				for(var i: number  = 0; i < pLiterals.length; i++) {
					pOutput[pLiterals[i]] = true;
				}

				iDepth = 1;
			}

			var pOutputKeys:string[] = Object.keys(pOutput);

			for(var i: number  = 0; i < pLiterals.length; i++) {
				for(var j: number  = 0; j < pOutputKeys.length; j++) {
					if(pOutputKeys[j].indexOf(pLiterals[i]) !== -1){
						pOutput[pOutputKeys[j] + pLiterals[i]] = false;
					}
					else {
						pOutput[pOutputKeys[j] + pLiterals[i]] = (pOutput[pOutputKeys[j]] === false) ? false : true;
					}
				}
			}

			iDepth++;

			this.generateSuffixLiterals(pLiterals, pOutput, iDepth);
		}

		private initSystemMacros(): void {
			if(isNull(Effect.pSystemMacros)){
				this._pSystemMacros = Effect.pSystemMacros = <IAFXSimpleInstructionMap>{};
				this.addSystemMacros();
			}

			this._pSystemMacros = Effect.pSystemMacros;
		}

		private initSystemTypes(): void {
			if(isNull(Effect.pSystemTypes)){
				this._pSystemTypes = Effect.pSystemTypes = {};
				this.addSystemTypeScalar();
				this.addSystemTypeVector();
				this.addSystemTypeMatrix();

				this.generateBaseVertexOutput();
			}

			this._pSystemTypes = Effect.pSystemTypes;
		}

		private initSystemFunctions(): void {
			if(isNull(Effect.pSystemFunctions)){
				this._pSystemFunctionsMap = Effect.pSystemFunctions = {};
				this.addSystemFunctions();
			}

			this._pSystemFunctionsMap = Effect.pSystemFunctions;
		}

		private initSystemVariables(): void {
			if(isNull(Effect.pSystemVariables)){
				this._pSystemVariables = Effect.pSystemVariables = <IAFXVariableDeclMap>{};
				this.addSystemVariables();
			}

			this._pSystemVariables = Effect.pSystemVariables;
		}

		private addSystemMacros(): void {
			this.generateSystemMacros("ExtractMacros",
									  "\n#ifdef AKRA_FRAGMENT\n" +
									  "//#define texture2D(sampler, ) texture2D\n" +
									  "#else\n" +
									  "#define texture2D(A, B) texture2DLod(A, B, 0.)\n" +
									  "#endif\n" +
									  "#ifndef A_VB_COMPONENT3\n" +
									  "#define A_VB_COMPONENT4\n" +
									  "#endif\n" +
									  "#ifdef A_VB_COMPONENT4\n" +
									  "#define A_VB_ELEMENT_SIZE 4.\n" +
									  "#endif\n" +
									  "#ifdef A_VB_COMPONENT3\n" +
									  "#define A_VB_ELEMENT_SIZE 3.\n" +
									  "#endif\n" +
									  "#define A_tex2D(S, H, X, Y) texture2D(S, vec2(H.stepX * X , H.stepY * Y))\n" +
									  "#define A_tex2Dv(S, H, V) texture2D(S, V)\n");
		}


		private addSystemVariables(): void {
			this.generateSystemVariable("fragCoord", "gl_FragCoord", "float4", false, true, true);
			this.generateSystemVariable("frontFacing", "gl_FrontFacing", "bool", false, true, true);
			this.generateSystemVariable("pointCoord", "gl_PointCoord", "float2", false, true, true);

//Engine variable for passes
			this.generatePassEngineVariable();
		}

		private generateSystemVariable(sName: string, sRealName: string, sTypeName: string,
									   isForVertex: bool, isForPixel: bool, isOnlyRead: bool): void {

			if(isDef(this._pSystemVariables[sName])){
				return;
			}

			var pVariableDecl: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pName: IAFXIdInstruction = new IdInstruction();
			var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

			pName.setName(sName);
			pName.setRealName(sRealName);

			pType.pushType(Effect.getSystemType(sTypeName));

			if(isOnlyRead) {
				pType._canWrite(false);
			}

			pVariableDecl._setForVertex(isForVertex);
			pVariableDecl._setForPixel(isForPixel);

			pVariableDecl.push(pType, true);
			pVariableDecl.push(pName, true);

			this._pSystemVariables[sName] = pVariableDecl;

			pVariableDecl.setBuiltIn(true);
		}

		private generatePassEngineVariable(): void {
			var pVariableDecl: IAFXVariableDeclInstruction = new VariableDeclInstruction();
			var pName: IAFXIdInstruction = new IdInstruction();
			var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

			pType._canWrite(false);

			pType._markAsUnverifiable(true);
			pName.setName("engine");
			pName.setRealName("engine");

			pVariableDecl.push(pType, true);
			pVariableDecl.push(pName, true);

			this._pSystemVariables["engine"] = pVariableDecl;
		}

		private generateBaseVertexOutput(): void {
//TODO: fix defenition of this variables

			var pOutBasetype: ComplexTypeInstruction = new ComplexTypeInstruction();

			var pPosition: VariableDeclInstruction = new VariableDeclInstruction();
			var pPointSize: VariableDeclInstruction = new VariableDeclInstruction();
			var pPositionType: VariableTypeInstruction = new VariableTypeInstruction();
			var pPointSizeType: VariableTypeInstruction = new VariableTypeInstruction();
			var pPositionId: IdInstruction = new IdInstruction();
			var pPointSizeId: IdInstruction = new IdInstruction();

			pPositionType.pushType(Effect.getSystemType("float4"));
			pPointSizeType.pushType(Effect.getSystemType("float"));

			pPositionId.setName("pos");
			pPositionId.setRealName("pos");

			pPointSizeId.setName("psize");
			pPointSizeId.setRealName("psize");

			pPosition.push(pPositionType, true);
			pPosition.push(pPositionId, true);

			pPointSize.push(pPointSizeType, true);
			pPointSize.push(pPointSizeId, true);

			pPosition.setSemantic("POSITION");
			pPointSize.setSemantic("PSIZE");

			var pFieldCollector: IAFXInstruction = new InstructionCollector();
			pFieldCollector.push(pPosition, false);
			pFieldCollector.push(pPointSize, false);

			pOutBasetype.addFields(pFieldCollector, true);

			pOutBasetype.setName("VS_OUT");
			pOutBasetype.setRealName("VS_OUT_S");

			Effect.pSystemVertexOut = pOutBasetype;
		}

		private addSystemFunctions(): void {
			this._pSystemFunctionHashMap = <BoolMap>{};

			this.generateSystemFunction("dot", "dot($1,$2)", "float", [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("mul", "$1*$2",  "template" , [ "template" ,  "template" ], ["float", "int", "float2", "float3", "float4"]);
		    this.generateSystemFunction("mod", "mod($1,$2)", "float", ["float", "float"], null);
		    this.generateSystemFunction("floor", "floor($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("ceil", "ceil($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("fract", "fract($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("abs", "abs($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("normalize", "normalize($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("length", "length($1)", "float", [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("reflect", "reflect($1,$2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("max", "max($1,$2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("max", "max($1,$2)",  "template" , [ "template" , "float"], ["float2", "float3", "float4"]);

		    this.generateSystemFunction("min", "min($1,$2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("min", "min($1,$2)",  "template" , [ "template" , "float"], ["float2", "float3", "float4"]);

		    this.generateSystemFunction("clamp", "clamp($1,$2,$3)",  "template" , [ "template" ,  "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("clamp", "clamp($1,$2,$3)",  "template" , [ "template" , "float", "float"], ["float2", "float3", "float4"]);

		    this.generateSystemFunction("pow", "pow($1,$2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("mod", "mod($1,$2)",  "template" , [ "template" ,  "template" ], ["float2", "float3", "float4"]);
		    this.generateSystemFunction("mod", "mod($1,$2)",  "template" , [ "template" , "float"], ["float2", "float3", "float4"]);
		    this.generateSystemFunction("exp", "exp($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("exp2", "exp2($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("log", "log($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("log2", "log2($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("inversesqrt", "inversesqrt($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("sqrt", "sqrt($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("all", "all($1)", "bool", [ "template" ], ["bool2", "bool3", "bool4"]);
		    this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool2", [ "template" ,  "template" ], ["float2", "int2"]);
		    this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool3", [ "template" ,  "template" ], ["float3", "int3"]);
		    this.generateSystemFunction("lessThanEqual", "lessThanEqual($1,$2)", "bool4", [ "template" ,  "template" ], ["float4", "int4"]);


		    this.generateSystemFunction("radians", "radians($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("degrees", "degrees($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("sin", "sin($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("cos", "cos($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("tan", "tan($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("asin", "asin($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("acos", "acos($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("atan", "atan($1)",  "template" , [ "template" ], ["float", "float2", "float3", "float4"]);
		    this.generateSystemFunction("atan", "atan($1, $2)",  "template" , [ "template" ,  "template" ], ["float", "float2", "float3", "float4"]);

		    this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", ["sampler", "float2"], null);
		    this.generateSystemFunction("tex2D", "texture2D($1,$2)", "float4", ["sampler2D", "float2"], null);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler", "float3"], null);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler2D", "float3"], null);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler", "float4"], null);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2)", "float4", ["sampler2D", "float4"], null);
		    this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", ["sampler", "float3"], null);
		    this.generateSystemFunction("texCUBE", "textureCube($1,$2)", "float4", ["samplerCUBE", "float3"], null);

		    this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", ["sampler", "float2", "float"], null, false, true);
		    this.generateSystemFunction("tex2D", "texture2D($1,$2,$3)", "float4", ["sampler2D", "float2", "float"], null, false, true);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, false, true);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler2D", "float3", "float"], null, false, true);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler", "float4", "float"], null, false, true);
		    this.generateSystemFunction("tex2DProj", "texture2DProj($1,$2,$3)", "float4", ["sampler2D", "float4", "float"], null, false, true);
		    this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, false, true);
		    this.generateSystemFunction("texCUBE", "textureCube($1,$2,$3)", "float4", ["samplerCUBE", "float3", "float"], null, false, true);

		    this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", ["sampler", "float2", "float"], null, true, false);
		    this.generateSystemFunction("tex2DLod", "texture2DLod($1,$2,$3)", "float4", ["sampler2D", "float2", "float"], null, true, false);
		    this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, true, false);
		    this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler2D", "float3", "float"], null, true, false);
		    this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler", "float4", "float"], null, true, false);
		    this.generateSystemFunction("tex2DProjLod", "texture2DProjLod($1,$2,$3)", "float4", ["sampler2D", "float4", "float"], null, true, false);
		    this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", ["sampler", "float3", "float"], null, true, false);
		    this.generateSystemFunction("texCUBELod", "textureCubeLod($1,$2,$3)", "float4", ["samplerCUBE", "float3", "float"], null, true, false);

//Extracts

		    this.generateNotBuiltInSystemFuction("extractHeader",
												 "void A_extractTextureHeader(const sampler2D src, out A_TextureHeader texture)",
												 "{vec4 v = texture2D(src, vec2(0.)); " +
												 "texture = A_TextureHeader(v.r, v.g, v.b, v.a);}",
												 "void",
												 ["video_buffer_header"], null, ["ExtractMacros"]);

		    this.generateNotBuiltInSystemFuction("extractFloat",
												 "float A_extractFloat(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "float y = floor(pixelNumber / header.width) + .5; " +
												 "float x = mod(pixelNumber, header.width) + .5; " +
												 "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " +
												 "\n#ifdef A_VB_COMPONENT4\n" +
												 "if(shift == 0) return A_tex2D(sampler, header, x, y).r; " +
												 "else if(shift == 1) return A_tex2D(sampler, header, x, y).g; " +
												 "else if(shift == 2) return A_tex2D(sampler, header, x, y).b; " +
												 "else if(shift == 3) return A_tex2D(sampler, header, x, y).a; " +
												 "\n#endif\n" +
												 "return 0.;}",
												 "float",
												 ["video_buffer_header"], null, ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("extractFloat2",
												 "vec2 A_extractVec2(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "float y = floor(pixelNumber / header.width) + .5; " +
												 "float x = mod(pixelNumber, header.width) + .5; " +
												 "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " +
												 "\n#ifdef A_VB_COMPONENT4\n" +
												 "if(shift == 0) return A_tex2D(sampler, header, x, y).rg; " +
												 "else if(shift == 1) return A_tex2D(sampler, header, x, y).gb; " +
												 "else if(shift == 2) return A_tex2D(sampler, header, x, y).ba; " +
												 "else if(shift == 3) { " +
												 "if(int(x) == int(header.width - 1.)) " +
												 "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0., (y + 1.)).r); " +
												 "else " +
												 "return vec2(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).r); " +
												 "} " +
												 "\n#endif\n" +
												 "return vec2(0.);}",
												 "float2",
												 ["video_buffer_header"], null, ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("extractFloat3",
												 "vec3 A_extractVec3(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "float y = floor(pixelNumber / header.width) + .5; " +
												 "float x = mod(pixelNumber, header.width) + .5; " +
												 "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " +
												 "\n#ifdef A_VB_COMPONENT4\n" +
												 "if(shift == 0) return A_tex2D(sampler, header, x, y).rgb; " +
												 "else if(shift == 1) return A_tex2D(sampler, header, x, y).gba; " +
												 "else if(shift == 2){ " +
												 "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0., (y + 1.)).r); " +
												 "else return vec3(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).r);} " +
												 "else if(shift == 3){ " +
												 "if(int(x) == int(header.width - 1.))  return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0., (y + 1.)).rg); " +
												 "else return vec3(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rg);} " +
												 "\n#endif\n" +
												 "\n#ifdef A_VB_COMPONENT3\n" +
												 "if(shift == 0) return A_tex2D(sampler, header,vec2(x,header.stepY*y)).rgb; " +
												 "else if(shift == 1){ " +
												 "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, 0., (y + 1.)).r); " +
												 "else return vec3(A_tex2D(sampler, header, x, y).gb, A_tex2D(sampler, header, (x + 1.), y).r);} " +
												 "else if(shift == 3){ " +
												 "if(x == header.width - 1.) return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, 0., (y + 1.)).rg); " +
												 "else return vec3(A_tex2D(sampler, header, x, y).b, A_tex2D(sampler, header, (x + 1)., y).rg);} " +
												 "\n#endif\n" +
												 "return vec3(0);}",
												 "float3",
												 ["video_buffer_header"], null, ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("extractFloat4",
												 "vec4 A_extractVec4(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "float y = floor(pixelNumber / header.width) + .5; " +
												 "float x = mod(pixelNumber, header.width) + .5; " +
												 "int shift = int(mod(offset, A_VB_ELEMENT_SIZE)); " +
												 "\n#ifdef A_VB_COMPONENT4\n" +
												 "if(shift == 0) return A_tex2D(sampler, header, x, y); " +
												 "else if(shift == 1){ " +
												 "if(int(x) == int(header.width - 1.)) " +
												 "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, 0., (y + 1.)).r); " +
												 "else " +
												 "return vec4(A_tex2D(sampler, header, x, y).gba, A_tex2D(sampler, header, (x + 1.), y).r);} " +
												 "else if(shift == 2){ " +
												 "if(int(x) == int(header.width - 1.)) " +
												 "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, 0., (y + 1.)).rg); " +
												 "else " +
												 "return vec4(A_tex2D(sampler, header, x, y).ba, A_tex2D(sampler, header, (x + 1.), y).rg);} " +
												 "else if(shift == 3){ " +
												 "if(int(x) == int(header.width - 1.)) " +
												 "return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, 0., (y + 1.)).rgb); " +
												 "else return vec4(A_tex2D(sampler, header, x, y).a, A_tex2D(sampler, header, (x + 1.), y).rgb);} " +
												 "\n#endif\n" +
												 "\n#ifdef A_VB_COMPONENT3\n" +
												 "\n#endif\n" +
												 "return vec4(0);}",
												 "float4",
												 ["video_buffer_header"], null, ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("findPixel",
												 "vec2 A_findPixel(const A_TextureHeader header, const float offset)",
												 "{float pixelNumber = floor(offset / A_VB_ELEMENT_SIZE); " +
												 "return vec2(header.stepX * (mod(pixelNumber, header.width) + .5), header.stepY * (floor(pixelNumber / header.width) + .5));}",
												 "float2",
												 ["video_buffer_header"], null, ["ExtractMacros"]);

			this.generateNotBuiltInSystemFuction("extractFloat4x4",
												 "mat4 A_extractMat4(const sampler2D sampler, const A_TextureHeader header, const float offset)",
												 "{return mat4(A_tex2Dv(sampler, header, A_findPixel(header, offset))," +
												 "A_tex2Dv(sampler, header, A_findPixel(header, offset + 4.))," +
												 "A_tex2Dv(sampler, header, A_findPixel(header, offset + 8.))," +
												 "A_tex2Dv(sampler, header, A_findPixel(header, offset + 12.)));}",
												 "float4x4",
												 ["video_buffer_header"], ["findPixel"], ["ExtractMacros"]);
		}

		private generateSystemFunction(sName: string, sTranslationExpr: string,
									   sReturnTypeName: string,
									   pArgumentsTypes: string[],
									   pTemplateTypes: string[],
									   isForVertex?: bool = true, isForPixel?: bool = true): void {

			var pExprTranslator: ExprTemplateTranslator = new ExprTemplateTranslator(sTranslationExpr);
			var pSystemFunctions: SystemFunctionMap = this._pSystemFunctionsMap;
			var pTypes: IAFXTypeInstruction[] = null;
			var sFunctionHash: string = "";
			var pReturnType: IAFXTypeInstruction = null;
			var pFunction: SystemFunctionInstruction = null;

			if(!isNull(pTemplateTypes)){
				for(var i:  number  = 0; i < pTemplateTypes.length; i++) {
					pTypes = [];
					sFunctionHash = sName + "(";
					pReturnType = (sReturnTypeName ===  "template" ) ?
																Effect.getSystemType(pTemplateTypes[i]) :
																Effect.getSystemType(sReturnTypeName);


					for(var j:  number  = 0; j < pArgumentsTypes.length; j++) {
						if(pArgumentsTypes[j] ===  "template" ){
							pTypes.push(Effect.getSystemType(pTemplateTypes[i]));
							sFunctionHash += pTemplateTypes[i] + ",";
						}
						else{
							pTypes.push(Effect.getSystemType(pArgumentsTypes[j]));
							sFunctionHash += pArgumentsTypes[j] + ","
						}
					}

					sFunctionHash += ")";

					if(this._pSystemFunctionHashMap[sFunctionHash]){
						this._error( 2248 , {funcName: sFunctionHash});
					}

					pFunction = new SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);

					if(!isDef(pSystemFunctions[sName])){
						pSystemFunctions[sName] = [];
					}

					pFunction._setForVertex(isForVertex);
					pFunction._setForPixel(isForPixel);

					pSystemFunctions[sName].push(pFunction);
					pFunction.setBuiltIn(true);
				}
			}
			else {

				if(sReturnTypeName ===  "template" ){
					akra.logger.criticalError("Bad return type(TEMPLATE_TYPE) for system function '" + sName +  "'.");
				}

				pReturnType = Effect.getSystemType(sReturnTypeName);
				pTypes = [];
				sFunctionHash = sName + "(";

				for(var i:  number  = 0; i < pArgumentsTypes.length; i++){
					if(pArgumentsTypes[i] ===  "template" ){
						akra.logger.criticalError("Bad argument type(TEMPLATE_TYPE) for system function '" + sName +  "'.");
					}
					else{
						pTypes.push(Effect.getSystemType(pArgumentsTypes[i]));
						sFunctionHash += pArgumentsTypes[i] + ",";
					}
				}

				sFunctionHash += ")";

				if(this._pSystemFunctionHashMap[sFunctionHash]){
					this._error( 2248 , {funcName: sFunctionHash});
				}

				pFunction = new SystemFunctionInstruction(sName, pReturnType, pExprTranslator, pTypes);

				pFunction._setForVertex(isForVertex);
				pFunction._setForPixel(isForPixel);

				if(!isDef(pSystemFunctions[sName])){
					pSystemFunctions[sName] = [];
				}

				pSystemFunctions[sName].push(pFunction);
				pFunction.setBuiltIn(true);
			}
		}

		private generateSystemMacros(sMacrosName: string, sMacrosCode: string): void {
			if(isDef(this._pSystemMacros[sMacrosName])){
				return;
			}

			var pMacros: IAFXSimpleInstruction = new SimpleInstruction(sMacrosCode);

			this._pSystemMacros[sMacrosName] = pMacros;
		}

		private generateNotBuiltInSystemFuction(sName: string, sDefenition: string, sImplementation: string,
												sReturnType: string,
												pUsedTypes: string[],
												pUsedFunctions: string[],
												pUsedMacros: string[]): void {

			if(isDef(this._pSystemFunctionsMap[sName])){
				return;
			}

			var pReturnType: IAFXTypeInstruction = Effect.getSystemType(sReturnType);
			var pFunction: SystemFunctionInstruction = new SystemFunctionInstruction(sName, pReturnType, null, null);

			pFunction.setDeclCode(sDefenition, sImplementation);

			var pUsedExtSystemTypes: IAFXTypeDeclInstruction[] = [];
			var pUsedExtSystemFunctions: IAFXFunctionDeclInstruction[] = [];
			var pUsedExtSystemMacros: IAFXSimpleInstruction[] = [];

			if(!isNull(pUsedTypes)){
				for(var i:  number  = 0; i < pUsedTypes.length; i++){
					var pTypeDecl: IAFXTypeDeclInstruction = <IAFXTypeDeclInstruction>Effect.getSystemType(pUsedTypes[i]).getParent();
					if(!isNull(pTypeDecl)){
						pUsedExtSystemTypes.push(pTypeDecl);
					}
				}
			}

			if(!isNull(pUsedMacros)){
				for(var i:  number  = 0; i < pUsedMacros.length; i++) {
					pUsedExtSystemMacros.push(Effect.getSystemMacros(pUsedMacros[i]));
				}
			}

			if(!isNull(pUsedFunctions)){
				for(var i:  number  = 0; i < pUsedFunctions.length; i++) {
					var pFindFunction: IAFXFunctionDeclInstruction = Effect.findSystemFunction(pUsedFunctions[i], null);
					pUsedExtSystemFunctions.push(pFindFunction);
				}
			}

			pFunction.setUsedSystemData(pUsedExtSystemTypes, pUsedExtSystemFunctions, pUsedExtSystemMacros);
			pFunction.closeSystemDataInfo();
			pFunction.setBuiltIn(false);

			this._pSystemFunctionsMap[sName] = [pFunction];
		}

		private generateSystemType(sName: string, sRealName: string,
								   iSize:  number  = 1, isArray: bool = false,
								   pElementType: IAFXTypeInstruction = null, iLength:  number  = 1
								  ): IAFXTypeInstruction {

			if(isDef(this._pSystemTypes[sName])){
				return null;
			}

			var pSystemType: SystemTypeInstruction = new SystemTypeInstruction();

			pSystemType.setName(sName);
			pSystemType.setRealName(sRealName);
			pSystemType.setSize(iSize);
			if(isArray){
				pSystemType.addIndex(pElementType, iLength);
			}

			this._pSystemTypes[sName] = pSystemType;
			pSystemType.setBuiltIn(true);

			return pSystemType;
		}

		private generateNotBuildtInSystemType(sName: string, sRealName: string, sDeclString: string,
											  iSize:  number  = 1, isArray: bool = false,
								  			  pElementType: IAFXTypeInstruction = null, iLength:  number  = 1
								  			 ): IAFXTypeInstruction {

			if(isDef(this._pSystemTypes[sName])){
				return null;
			}

			var pSystemType: SystemTypeInstruction = new SystemTypeInstruction();
			pSystemType.setName(sName);
			pSystemType.setRealName(sRealName);
			pSystemType.setSize(iSize);

			if(isArray){
				pSystemType.addIndex(pElementType, iLength);
			}

			this._pSystemTypes[sName] = pSystemType;
			pSystemType.setBuiltIn(false);

			var pSystemTypeDecl: IAFXTypeDeclInstruction = new TypeDeclInstruction();
			pSystemTypeDecl.push(pSystemType, true);
			pSystemTypeDecl.setBuiltIn(false);

			return pSystemType;
		}

		private addSystemTypeScalar(): void {
			this.generateSystemType("void", "void", 0);
			this.generateSystemType("int", "int", 1);
			this.generateSystemType("bool", "bool", 1);
			this.generateSystemType("float", "float", 1);
			this.generateSystemType("ptr", "float", 1);
			this.generateSystemType("string", "", 0);
			this.generateSystemType("texture", "", 0);
			this.generateSystemType("sampler", "sampler2D", 1);
			this.generateSystemType("sampler2D", "sampler2D", 1);
			this.generateSystemType("samplerCUBE", "samplerCube", 1);
			this.generateSystemType("video_buffer", "sampler2D", 1);


			this.generateNotBuildtInSystemType("video_buffer_header", "A_TextureHeader",
				"struct A_TextureHeader { float width; float height; float stepX; float stepY; }");
		}

		private addSystemTypeVector(): void {
			var pXYSuffix: BoolMap = <BoolMap>{};
			var pXYZSuffix: BoolMap = <BoolMap>{};
			var pXYZWSuffix: BoolMap = <BoolMap>{};

			var pRGSuffix: BoolMap = <BoolMap>{};
			var pRGBSuffix: BoolMap = <BoolMap>{};
			var pRGBASuffix: BoolMap = <BoolMap>{};

			var pSTSuffix: BoolMap = <BoolMap>{};
			var pSTPSuffix: BoolMap = <BoolMap>{};
			var pSTPQSuffix: BoolMap = <BoolMap>{};

			this.generateSuffixLiterals(["x", "y"], pXYSuffix);
			this.generateSuffixLiterals(["x", "y", "z"], pXYZSuffix);
			this.generateSuffixLiterals(["x", "y", "z", "w"], pXYZWSuffix);

			this.generateSuffixLiterals(["r", "g"], pRGSuffix);
			this.generateSuffixLiterals(["r", "g", "b"], pRGBSuffix);
			this.generateSuffixLiterals(["r", "g", "b", "a"], pRGBASuffix);

			this.generateSuffixLiterals(["s", "t"], pSTSuffix);
			this.generateSuffixLiterals(["s", "t", "p"], pSTPSuffix);
			this.generateSuffixLiterals(["s", "t", "p", "q"], pSTPQSuffix);

			var pFloat: IAFXTypeInstruction = Effect.getSystemType("float");
			var pInt: IAFXTypeInstruction = Effect.getSystemType("int");
			var pBool: IAFXTypeInstruction = Effect.getSystemType("bool");

			var pFloat2: IAFXTypeInstruction = this.generateSystemType("float2", "vec2", 0, true, pFloat, 2);
			var pFloat3: IAFXTypeInstruction = this.generateSystemType("float3", "vec3", 0, true, pFloat, 3);
			var pFloat4: IAFXTypeInstruction = this.generateSystemType("float4", "vec4", 0, true, pFloat, 4);

			var pInt2: IAFXTypeInstruction = this.generateSystemType("int2", "ivec2", 0, true, pInt, 2);
			var pInt3: IAFXTypeInstruction = this.generateSystemType("int3", "ivec3", 0, true, pInt, 3);
			var pInt4: IAFXTypeInstruction = this.generateSystemType("int4", "ivec4", 0, true, pInt, 4);

			var pBool2: IAFXTypeInstruction = this.generateSystemType("bool2", "bvec2", 0, true, pBool, 2);
			var pBool3: IAFXTypeInstruction = this.generateSystemType("bool3", "bvec3", 0, true, pBool, 3);
			var pBool4: IAFXTypeInstruction = this.generateSystemType("bool4", "bvec4", 0, true, pBool, 4);

			this.addFieldsToVectorFromSuffixObject(pXYSuffix, pFloat2, "float");
			this.addFieldsToVectorFromSuffixObject(pRGSuffix, pFloat2, "float");
			this.addFieldsToVectorFromSuffixObject(pSTSuffix, pFloat2, "float");

			this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pFloat3, "float");
			this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pFloat3, "float");
			this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pFloat3, "float");

			this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pFloat4, "float");
			this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pFloat4, "float");
			this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pFloat4, "float");

			this.addFieldsToVectorFromSuffixObject(pXYSuffix, pInt2, "int");
			this.addFieldsToVectorFromSuffixObject(pRGSuffix, pInt2, "int");
			this.addFieldsToVectorFromSuffixObject(pSTSuffix, pInt2, "int");

			this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pInt3, "int");
			this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pInt3, "int");
			this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pInt3, "int");

			this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pInt4, "int");
			this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pInt4, "int");
			this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pInt4, "int");

			this.addFieldsToVectorFromSuffixObject(pXYSuffix, pBool2, "bool");
			this.addFieldsToVectorFromSuffixObject(pRGSuffix, pBool2, "bool");
			this.addFieldsToVectorFromSuffixObject(pSTSuffix, pBool2, "bool");

			this.addFieldsToVectorFromSuffixObject(pXYZSuffix, pBool3, "bool");
			this.addFieldsToVectorFromSuffixObject(pRGBSuffix, pBool3, "bool");
			this.addFieldsToVectorFromSuffixObject(pSTPSuffix, pBool3, "bool");

			this.addFieldsToVectorFromSuffixObject(pXYZWSuffix, pBool4, "bool");
			this.addFieldsToVectorFromSuffixObject(pRGBASuffix, pBool4, "bool");
			this.addFieldsToVectorFromSuffixObject(pSTPQSuffix, pBool4, "bool");
		}

		private addSystemTypeMatrix(): void {
			var pFloat2: IAFXTypeInstruction = Effect.getSystemType("float2");
			var pFloat3: IAFXTypeInstruction = Effect.getSystemType("float3");
			var pFloat4: IAFXTypeInstruction = Effect.getSystemType("float4");

			var pInt2: IAFXTypeInstruction = Effect.getSystemType("int2");
			var pInt3: IAFXTypeInstruction = Effect.getSystemType("int3");
			var pInt4: IAFXTypeInstruction = Effect.getSystemType("int4");

			var pBool2: IAFXTypeInstruction = Effect.getSystemType("bool2");
			var pBool3: IAFXTypeInstruction = Effect.getSystemType("bool3");
			var pBool4: IAFXTypeInstruction = Effect.getSystemType("bool4");

			this.generateSystemType("float2x2", "mat2",   0, true, pFloat2, 2);
			this.generateSystemType("float2x3", "mat2x3", 0, true, pFloat2, 3);
			this.generateSystemType("float2x4", "mat2x4", 0, true, pFloat2, 4);

			this.generateSystemType("float3x2", "mat3x2", 0, true, pFloat3, 2);
			this.generateSystemType("float3x3", "mat3",   0, true, pFloat3, 3);
			this.generateSystemType("float3x4", "mat3x4", 0, true, pFloat3, 4);

			this.generateSystemType("float4x2", "mat4x2", 0, true, pFloat4, 2);
			this.generateSystemType("float4x3", "mat4x3", 0, true, pFloat4, 3);
			this.generateSystemType("float4x4", "mat4",   0, true, pFloat4, 4);

			this.generateSystemType("int2x2", "imat2",   0, true, pInt2, 2);
			this.generateSystemType("int2x3", "imat2x3", 0, true, pInt2, 3);
			this.generateSystemType("int2x4", "imat2x4", 0, true, pInt2, 4);

			this.generateSystemType("int3x2", "imat3x2", 0, true, pInt3, 2);
			this.generateSystemType("int3x3", "imat3",   0, true, pInt3, 3);
			this.generateSystemType("int3x4", "imat3x4", 0, true, pInt3, 4);

			this.generateSystemType("int4x2", "imat4x2", 0, true, pInt4, 2);
			this.generateSystemType("int4x3", "imat4x3", 0, true, pInt4, 3);
			this.generateSystemType("int4x4", "imat4",   0, true, pInt4, 4);

			this.generateSystemType("bool2x2", "bmat2",   0, true, pBool2, 2);
			this.generateSystemType("bool2x3", "bmat2x3", 0, true, pBool2, 3);
			this.generateSystemType("bool2x4", "bmat2x4", 0, true, pBool2, 4);

			this.generateSystemType("bool3x2", "bmat3x2", 0, true, pBool3, 2);
			this.generateSystemType("bool3x3", "bmat3",   0, true, pBool3, 3);
			this.generateSystemType("bool3x4", "bmat3x4", 0, true, pBool3, 4);

			this.generateSystemType("bool4x2", "bmat4x2", 0, true, pBool4, 2);
			this.generateSystemType("bool4x3", "bmat4x3", 0, true, pBool4, 3);
			this.generateSystemType("bool4x4", "bmat4",   0, true, pBool4, 4);
		}

		private addFieldsToVectorFromSuffixObject(pSuffixMap: BoolMap, pType: IAFXTypeInstruction, sBaseType: string) {
			var sSuffix: string = null;

			for(sSuffix in pSuffixMap){
				var sFieldTypeName: string = sBaseType + ((sSuffix.length > 1) ? sSuffix.length.toString() : "");
				var pFieldType: IAFXTypeInstruction = Effect.getSystemType(sFieldTypeName);

				(<SystemTypeInstruction>pType).addField(sSuffix, pFieldType, pSuffixMap[sSuffix]);
			}
		}

		private inline getVariable(sName: string): IAFXVariableDeclInstruction {
			return Effect.getSystemVariable(sName) || this._pEffectScope.getVariable(sName);
		}

		private inline hasVariable(sName: string): bool {
			return this._pEffectScope.hasVariable(sName);
		}

		private getType(sTypeName: string): IAFXTypeInstruction {
			return Effect.getSystemType(sTypeName) || this._pEffectScope.getType(sTypeName);
		}

		private isSystemFunction(pFunction: IAFXFunctionDeclInstruction): bool {
			return false;
		}

		private isSystemVariable(pVariable: IAFXVariableDeclInstruction): bool {
			return false;
		}

		private isSystemType(pType: IAFXTypeDeclInstruction): bool {
			return false;
		}

		private inline _errorFromInstruction(pError: IAFXInstructionError): void {
			this._error(pError.code, isNull(pError.info) ? {} : pError.info);
		}

		private _error(eCode:  number , pInfo: IEffectErrorInfo = {}): void {
			var sFileName: string = this._sAnalyzedFileName;

			var pLocation: ISourceLocation = <ISourceLocation>{file: this._sAnalyzedFileName, line: 0};
			var pLineColumn: {line:  number ; column:  number ;} = this.getNodeSourceLocation(this.getAnalyzedNode());

			switch(eCode){
				default:
					pInfo.line = pLineColumn.line + 1;
					pInfo.column = pLineColumn.column + 1;

					pLocation.line = pLineColumn.line + 1;

					break;
			}

			var pLogEntity: ILoggerEntity = <ILoggerEntity>{code: eCode, info: pInfo, location: pLocation};

			akra.logger["error"](pLogEntity);
			throw new Error(eCode.toString());
		}

		private inline setAnalyzedNode(pNode: IParseNode): void {
// if(this._pAnalyzedNode !== pNode){
// 	// debug_print("Analyze node: ", pNode); 
// 	//.name + (pNode.value ?  " --> value: " + pNode.value + "." : "."));
// }
			this._pAnalyzedNode = pNode;
		}

		private inline getAnalyzedNode(): IParseNode {
			return this._pAnalyzedNode;
		}

		private inline isStrictMode(): bool {
			return this._pEffectScope.isStrictMode();
		}

		private inline setStrictModeOn(): void {
			return this._pEffectScope.setStrictModeOn();
		}

		private inline newScope(eScopeType?: EScopeType = EScopeType.k_Default): void {
			this._pEffectScope.newScope(eScopeType);
		}

		private inline resumeScope(): void {
			this._pEffectScope.resumeScope();
		}

		private inline getScope():  number  {
			return this._pEffectScope.getScope();
		}

		private inline setScope(iScope:  number ): void {
			this._pEffectScope.setScope(iScope);
		}

		private inline endScope(): void {
			this._pEffectScope.endScope();
		}

		private inline getScopeType(): EScopeType {
			return this._pEffectScope.getScopeType();
		}

		private inline setCurrentAnalyzedFunction(pFunction: IAFXFunctionDeclInstruction): void {
			this._pCurrentFunction = pFunction;
		}

		private inline getCurrentAnalyzedFunction(): IAFXFunctionDeclInstruction {
			return this._pCurrentFunction;
		}

		private inline isAnalzeInPass(): bool {
			return this._isAnalyzeInPass;
		}

		private inline setAnalyzeInPass(isInPass: bool): void {
			this._isAnalyzeInPass = isInPass;
		}

		private inline setOperator(sOperator: string): void {
			if(!isNull(this._pCurrentInstruction)){
				this._pCurrentInstruction.setOperator(sOperator);
			}
		}

		private inline clearPointersForExtract(): void {
			this._pPointerForExtractionList.length = 0;
		}

		private inline addPointerForExtract(pPointer: IAFXVariableDeclInstruction): void {
			this._pPointerForExtractionList.push(pPointer);
		}

		private inline getPointerForExtractList(): IAFXVariableDeclInstruction[] {
			return this._pPointerForExtractionList;
		}

		private findFunction(sFunctionName: string,
							 pArguments: IAFXExprInstruction[]): IAFXFunctionDeclInstruction;
		private findFunction(sFunctionName: string,
							 pArguments: IAFXVariableDeclInstruction[]): IAFXFunctionDeclInstruction;
		private findFunction(sFunctionName: string,
							 pArguments: IAFXTypedInstruction[]): IAFXFunctionDeclInstruction {
			return Effect.findSystemFunction(sFunctionName, pArguments) ||
				   this._pEffectScope.getFunction(sFunctionName, pArguments);
		}

		private findConstructor(pType: IAFXTypeInstruction,
							    pArguments: IAFXExprInstruction[]): IAFXVariableTypeInstruction {

			var pVariableType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
			pVariableType.pushType(pType);

			return pVariableType;
		}

		private findShaderFunction(sFunctionName: string,
							 	   pArguments: IAFXExprInstruction[]): IAFXFunctionDeclInstruction {
			return this._pEffectScope.getShaderFunction(sFunctionName, pArguments);
		}

		private findFunctionByDef(pDef: FunctionDefInstruction): IAFXFunctionDeclInstruction {
			return this.findFunction(pDef.getName(), pDef.getArguments());
		}

// private addVariable(pVariable: IAFXVariable): void {
// }

		private addVariableDecl(pVariable: IAFXVariableDeclInstruction): void {
			if(this.isSystemVariable(pVariable)){
        		this._error( 2235 , {varName: pVariable.getName()});
        	}

        	var isVarAdded: bool = this._pEffectScope.addVariable(pVariable);

        	if(!isVarAdded) {
        		var eScopeType: EScopeType = this.getScopeType();

        		switch(eScopeType){
        			case EScopeType.k_Default:
        				this._error( 2234 , {varName: pVariable.getName()});
        				break;
        			case EScopeType.k_Struct:
        				this._error( 2242 , {fieldName: pVariable.getName()});
        				break;
        			case EScopeType.k_Annotation:
        				this._error( 2244 , {varName: pVariable.getName()});
        				break;
        		}
			}

			if(pVariable.getName() === "Out" && !isNull(this.getCurrentAnalyzedFunction())){
        		var isOk: bool = this.getCurrentAnalyzedFunction()._addOutVariable(pVariable);
        		if(!isOk){
        			this._error( 2266 );
        		}
        	}
        }

        private addTypeDecl(pType: IAFXTypeDeclInstruction): void {
        	if(this.isSystemType(pType)){
        		this._error( 2201 , {typeName: pType.getName()});
        	}

        	var isTypeAdded: bool = this._pEffectScope.addType(pType);

        	if(!isTypeAdded) {
				this._error( 2202 , {typeName: pType.getName()});
			}
        }

        private addFunctionDecl(pFunction: IAFXFunctionDeclInstruction): void {
        	if(this.isSystemFunction(pFunction)){
        		this._error( 2237 , {funcName: pFunction.getName()});
        	}

        	var isFunctionAdded: bool = this._pEffectScope.addFunction(pFunction);

        	if(!isFunctionAdded) {
				this._error( 2236 , {funcName: pFunction.getName()});
			}
        }

        private addTechnique(pTechnique: IAFXTechniqueInstruction): void {
        	var sName: string = pTechnique.getName();

        	if(isDef(this._pTechniqueMap[sName])){
        		this._error( 2252 , { techName: sName });
        		return;
        	}

        	this._pTechniqueMap[sName] = pTechnique;
        	this._pTechniqueList.push(pTechnique);
        }

        private addExternalSharedVariable(pVariable: IAFXVariableDeclInstruction, eShaderType: EFunctionType): void {
        	var isVarAdded: bool = this._pEffectScope.addVariable(pVariable);

        	if(!isVarAdded) {
   				this._error( 2278 , {varName: pVariable.getName()});
   				return;
			}
        }


        private analyzeGlobalUseDecls(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "UseDecl") {
					this.analyzeUseDecl(pChildren[i]);
				}
			}
        }

        private analyzeGlobalProvideDecls(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "ProvideDecl") {
					this.analyzeProvideDecl(pChildren[i]);
				}
			}
        }

        private analyzeGlobalTypeDecls(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "TypeDecl") {
					this.analyzeTypeDecl(pChildren[i]);
				}
			}
        }

        private analyzeFunctionDefinitions(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "FunctionDecl") {
					this.analyzeFunctionDeclOnlyDefinition(pChildren[i]);
				}
			}
        }

        private analyzeGlobalImports(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "ImportDecl") {
					this.analyzeImportDecl(pChildren[i], null);
				}
			}
        }

        private analyzeTechniqueImports(): void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "TechniqueDecl") {
					this.analyzeTechniqueForImport(pChildren[i]);
				}
			}
        }

        private analyzeVariableDecls() : void {
        	var pChildren: IParseNode[] = this._pParseTree.root.children;
			var i:  number  = 0;

			for(i = pChildren.length - 1; i >=0; i--) {
				if(pChildren[i].name === "VariableDecl") {
					this.analyzeVariableDecl(pChildren[i]);
				}
				else if(pChildren[i].name === "VarStructDecl"){
					this.analyzeVarStructDecl(pChildren[i]);
				}
			}
        }

        private analyzeFunctionDecls(): void {
        	for(var i:  number  = 0; i < this._pFunctionWithImplementationList.length; i++) {
        		this.resumeFunctionAnalysis(this._pFunctionWithImplementationList[i]);
        	}

        	this.checkFunctionsForRecursion();
        	this.checkFunctionForCorrectUsage();
        	this.generateInfoAboutUsedData();
        	this.generateShadersFromFunctions();
        }

        private analyzeTechniques(): void {
        	for(var i:  number  = 0; i < this._pTechniqueList.length; i++) {
        		this.resumeTechniqueAnalysis(this._pTechniqueList[i]);
        	}
        }

        private checkFunctionsForRecursion(): void {
        	var pFunctionList: IAFXFunctionDeclInstruction[] = this._pFunctionWithImplementationList;
        	var isNewAdd: bool = true;
        	var isNewDelete: bool = true;

        	while(isNewAdd || isNewDelete) {
        		isNewAdd = false;
        		isNewDelete = false;

        		mainFor:
        		for(var i:  number  = 0; i < pFunctionList.length; i++){
        			var pTestedFunction: IAFXFunctionDeclInstruction = pFunctionList[i];
        			var pUsedFunctionList: IAFXFunctionDeclInstruction[] = pTestedFunction._getUsedFunctionList();

        			if(!pTestedFunction._isUsed()){
//WARNING("Unused function '" + pTestedFunction._getStringDef() + "'.");
        				continue mainFor;
        			}
        			if(pTestedFunction._isBlackListFunction()){
        				continue mainFor;
        			}

        			if(isNull(pUsedFunctionList)){
        				continue mainFor;
        			}

        			for(var j:  number  = 0; j < pUsedFunctionList.length; j++) {
        				var pAddedUsedFunctionList: IAFXFunctionDeclInstruction[] = pUsedFunctionList[j]._getUsedFunctionList();

        				if(isNull(pAddedUsedFunctionList)){
        					continue mainFor;
        				}

        				for(var k:  number  = 0; k < pAddedUsedFunctionList.length; k++) {
        					var pAddedFunction: IAFXFunctionDeclInstruction = pAddedUsedFunctionList[k];

        					if(pTestedFunction === pAddedFunction){
        						pTestedFunction._addToBlackList();
        						isNewDelete = true;
        						this._error( 2255 , { funcDef: pTestedFunction._getStringDef() });
        						continue mainFor;
        					}

        					if (pAddedFunction._isBlackListFunction() ||
        						!pAddedFunction._canUsedAsFunction()){
        						pTestedFunction._addToBlackList();
        						this._error( 2256 , { funcDef: pTestedFunction._getStringDef() });
        						isNewDelete = true;
        						continue mainFor;
        					}

        					if(pTestedFunction._addUsedFunction(pAddedFunction)){
        						isNewAdd = true;
        					}
        				}
        			}
        		}
        	}
        }

        private checkFunctionForCorrectUsage(): void {
        	var pFunctionList: IAFXFunctionDeclInstruction[] = this._pFunctionWithImplementationList;
        	var isNewUsageSet: bool = true;
        	var isNewDelete: bool = true;

        	while(isNewUsageSet || isNewDelete){
        		isNewUsageSet = false;
        		isNewDelete = false;

        		mainFor:
        		for(var i:  number  = 0; i < pFunctionList.length; i++) {
        			var pTestedFunction: IAFXFunctionDeclInstruction = pFunctionList[i];
        			var pUsedFunctionList: IAFXFunctionDeclInstruction[] = pTestedFunction._getUsedFunctionList();

        			if(!pTestedFunction._isUsed()){
//WARNING("Unused function '" + pTestedFunction._getStringDef() + "'.");
        				continue mainFor;
        			}
        			if(pTestedFunction._isBlackListFunction()){
        				continue mainFor;
        			}

        			if(!pTestedFunction._checkVertexUsage()){
        				this._error( 2257 , { funcDef: pTestedFunction._getStringDef() });
        				pTestedFunction._addToBlackList();
        				isNewDelete = true;
        				continue mainFor;
        			}

        			if(!pTestedFunction._checkPixelUsage()){
        				this._error( 2258 , { funcDef: pTestedFunction._getStringDef() });
        				pTestedFunction._addToBlackList();
        				isNewDelete = true;
        				continue mainFor;
        			}

        			if(isNull(pUsedFunctionList)){
        				continue mainFor;
        			}

        			for(var j:  number  = 0; j < pUsedFunctionList.length; j++) {
        				var pUsedFunction: IAFXFunctionDeclInstruction = pUsedFunctionList[j];

        				if(pTestedFunction._isUsedInVertex()){
        					if(!pUsedFunction._isForVertex()){
        						this._error( 2257 , { funcDef: pTestedFunction._getStringDef() });
		        				pTestedFunction._addToBlackList();
		        				isNewDelete = true;
		        				continue mainFor;
        					}

        					if(!pUsedFunction._isUsedInVertex()){
	        					pUsedFunction._markUsedInVertex();
        						isNewUsageSet = true;
        					}

        				}

        				if(pTestedFunction._isUsedInPixel()){
        					if(!pUsedFunction._isForPixel()){
        						this._error( 2258 , { funcDef: pTestedFunction._getStringDef() });
		        				pTestedFunction._addToBlackList();
		        				isNewDelete = true;
		        				continue mainFor;
        					}

        					if(!pUsedFunction._isUsedInPixel()){
	        					pUsedFunction._markUsedInPixel();
	        					isNewUsageSet = true;
        					}
        				}

        			}
        		}

        	}

        	return;
        }

        private generateInfoAboutUsedData(): void {
        	var pFunctionList: IAFXFunctionDeclInstruction[] = this._pFunctionWithImplementationList;

        	for(var i:  number  = 0; i < pFunctionList.length; i++){
        		pFunctionList[i]._generateInfoAboutUsedData();
        	}
        }

        private generateShadersFromFunctions(): void {
        	var pFunctionList: IAFXFunctionDeclInstruction[] = this._pFunctionWithImplementationList;

        	for(var i:  number  = 0; i < pFunctionList.length; i++){
        		var pShader: IAFXFunctionDeclInstruction = null;

        		if(pFunctionList[i]._isUsedAsVertex()){
        			pShader = pFunctionList[i]._convertToVertexShader();
        		}
        		if(pFunctionList[i]._isUsedAsPixel()){
        			pShader = pFunctionList[i]._convertToPixelShader();
        		}
        	}
        }

		private analyzeVariableDecl(pNode: IParseNode, pInstruction?: IAFXInstruction = null): void {
			this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pGeneralType: IAFXVariableTypeInstruction = null;
        	var pVariable: IAFXVariableDeclInstruction = null;
        	var i:  number  = 0;

        	pGeneralType = this.analyzeUsageType(pChildren[pChildren.length - 1]);

        	for(i = pChildren.length - 2; i >= 1; i--){
        		if(pChildren[i].name === "Variable") {
        			pVariable = this.analyzeVariable(pChildren[i], pGeneralType);

        			if(!isNull(pInstruction)){
        				pInstruction.push(pVariable, true);
        				if(pInstruction._getInstructionType() === EAFXInstructionTypes.k_DeclStmtInstruction) {
	        				var pVariableSubDecls: IAFXVariableDeclInstruction[] = pVariable.getSubVarDecls();
	        				if(!isNull(pVariableSubDecls)){
		        				for(var j:  number  = 0; j < pVariableSubDecls.length; j++) {
		        					pInstruction.push(pVariableSubDecls[j], false);
		        				}
	        				}
	        			}
        			}
        		}
        	}
        }

      	private analyzeUsageType(pNode: IParseNode): IAFXVariableTypeInstruction {
      		this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
		    var i:  number  = 0;
		    var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

		    for (i = pChildren.length - 1; i >= 0; i--) {
		        if (pChildren[i].name === "Type") {
		        	var pMainType: IAFXTypeInstruction = this.analyzeType(pChildren[i]);
		        	pType.pushType(pMainType);
		        }
		        else if (pChildren[i].name === "Usage") {
		        	var sUsage: string = this.analyzeUsage(pChildren[i]);
		        	pType.addUsage(sUsage);
		        }
		    }

		    if(!pType.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pType.getLastError()); } ;

		    return pType;
        }

        private analyzeType(pNode: IParseNode): IAFXTypeInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pType: IAFXTypeInstruction = null;

        	switch(pNode.name){
        		case "T_TYPE_ID":
        			pType = this.getType(pNode.value);

			        if (isNull(pType)) {
			            this._error( 2250 , { typeName: pNode.value });
			        }
			        break;

			    case "Struct":
			    	pType = this.analyzeStruct(pNode);
			    	break;

			   	case "T_KW_VOID":
			   		pType = Effect.getSystemType("void");
			   		break;

			   	case "ScalarType":
			   	case "ObjectType":
			   		pType = this.getType(pChildren[pChildren.length - 1].value);

			   		if (isNull(pType)) {
			            this._error( 2250 , { typeName: pChildren[pChildren.length - 1].value });
			        }

			       	break;

			    case "VectorType":
			    case "MatrixType":
			    	this._error( 2251 );
			    	break;

			   	case "BaseType":
			   	case "Type":
			   		return this.analyzeType(pChildren[0]);
        	}

        	return pType;
        }

        private analyzeUsage(pNode: IParseNode): string {
        	this.setAnalyzedNode(pNode);

        	pNode = pNode.children[0];
        	return pNode.value;
        }

        private analyzeVariable(pNode: IParseNode, pGeneralType: IAFXVariableTypeInstruction): IAFXVariableDeclInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var pVarDecl: IAFXVariableDeclInstruction = new VariableDeclInstruction();
        	var pVariableType: IAFXVariableTypeInstruction = new VariableTypeInstruction();
        	var pAnnotation: IAFXAnnotationInstruction = null;
        	var sSemantic: string = "";
        	var pInitExpr: IAFXInitExprInstruction = null;

        	pVarDecl.push(pVariableType, true);
        	pVariableType.pushType(pGeneralType);

        	this.analyzeVariableDim(pChildren[pChildren.length - 1], pVarDecl);

        	var i:  number  = 0;
        	for(i = pChildren.length - 2; i >= 0; i--){
        		if(pChildren[i].name === "Annotation"){
        			pAnnotation = this.analyzeAnnotation(pChildren[i]);
        			pVarDecl.setAnnotation(pAnnotation);
        		}
        		else if(pChildren[i].name === "Semantic"){
        			sSemantic = this.analyzeSemantic(pChildren[i]);
        			pVarDecl.setSemantic(sSemantic);
        		}
        		else if(pChildren[i].name === "Initializer"){
        			pInitExpr = this.analyzeInitializer(pChildren[i]);
        			if(!pInitExpr.optimizeForVariableType(pVariableType)){
        				this._error( 2269 , { varName: pVarDecl.getName() });
        				return null;
        			}
        			pVarDecl.push(pInitExpr, true);
        		}
        	}

        	if(!pVarDecl.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pVarDecl.getLastError()); } ;

        	this.addVariableDecl(pVarDecl);

        	return pVarDecl;
        }

        private analyzeVariableDim(pNode: IParseNode, pVariableDecl: IAFXVariableDeclInstruction): void {
			this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;
			var pVariableType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pVariableDecl.getType();

			if(pChildren.length === 1) {
				var pName: IAFXIdInstruction = new IdInstruction();
				pName.setName(pChildren[0].value);
				pVariableDecl.push(pName, true);
				return;
			}

			this.analyzeVariableDim(pChildren[pChildren.length - 1], pVariableDecl);

			if(pChildren.length === 3) {
				pVariableType.addPointIndex(true);
			}
			else if(pChildren.length === 4 && pChildren[0].name === "FromExpr"){

				var pBuffer: IAFXVariableDeclInstruction = this.analyzeFromExpr(pChildren[0]);
				pVariableType.addPointIndex(true);
				pVariableType.setVideoBuffer(pBuffer);
			}
			else {
				if(pVariableType.isPointer()){
//TODO: add support for v[][10]
					this._error( 2300 );
				}

				var pIndexExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 3]);
				pVariableType.addArrayIndex(pIndexExpr);
			}
        }

        private analyzeAnnotation(pNode:IParseNode): IAFXAnnotationInstruction {
        	this.setAnalyzedNode(pNode);

        	return null;
        }

        private analyzeSemantic(pNode:IParseNode): string {
        	this.setAnalyzedNode(pNode);

        	var sSemantic: string = pNode.children[0].value;
// var pDecl: IAFXDeclInstruction = <IAFXDeclInstruction>this._pCurrentInstruction;
// pDecl.setSemantic(sSemantic);	
			return sSemantic;
        }

        private analyzeInitializer(pNode:IParseNode): IAFXInitExprInstruction {
        	this.setAnalyzedNode(pNode);

      		var pChildren: IParseNode[] = pNode.children;
      		var pInitExpr: IAFXInitExprInstruction = new InitExprInstruction();

      		if(pChildren.length === 2){
      			pInitExpr.push(this.analyzeExpr(pChildren[0]), true);
      		}
      		else {
	      		for(var i:  number  = pChildren.length - 3; i >=1; i--){
	      			if(pChildren[i].name === "InitExpr"){
	      				pInitExpr.push(this.analyzeInitExpr(pChildren[i]), true);
	      			}
	      		}
	      	}

      		return pInitExpr;
        }

        private analyzeFromExpr(pNode: IParseNode): IAFXVariableDeclInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pBuffer: IAFXVariableDeclInstruction = null;

        	if(pChildren[1].name === "T_NON_TYPE_ID"){
        		pBuffer = this.getVariable(pChildren[1].value);
        	}
        	else {
        		pBuffer = (<MemExprInstruction>this.analyzeMemExpr(pChildren[1])).getBuffer();
        	}

        	return pBuffer;
        }

        private analyzeInitExpr(pNode:IParseNode): IAFXInitExprInstruction {
        	this.setAnalyzedNode(pNode);

      		var pChildren: IParseNode[] = pNode.children;
      		var pInitExpr: IAFXInitExprInstruction = new InitExprInstruction();

      		if(pChildren.length === 1){
      			pInitExpr.push(this.analyzeExpr(pChildren[0]), true);
      		}
      		else{
      			for(var i:  number  = 0; i < pChildren.length; i++){
      				if(pChildren[i].name === "InitExpr"){
      					pInitExpr.push(this.analyzeInitExpr(pChildren[i]), true);
      				}
      			}
      		}

      		return pInitExpr;
      	}

        private analyzeExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);
        	var sName: string = pNode.name;

        	switch(sName){
        		case "ObjectExpr":
        			return this.analyzeObjectExpr(pNode);
        		case "ComplexExpr":
        			return this.analyzeComplexExpr(pNode);
        		case "PrimaryExpr":
        			return this.analyzePrimaryExpr(pNode);
        		case "PostfixExpr":
        			return this.analyzePostfixExpr(pNode);
        		case "UnaryExpr":
        			return this.analyzeUnaryExpr(pNode);
        		case "CastExpr":
        			return this.analyzeCastExpr(pNode);
        		case "ConditionalExpr":
        			return this.analyzeConditionalExpr(pNode);
        		case "MulExpr":
		        case "AddExpr":
		        	return this.analyzeArithmeticExpr(pNode);
		        case "RelationalExpr":
		        case "EqualityExpr":
		        	return this.analyzeRelationExpr(pNode);
		        case "AndExpr":
		        case "OrExpr":
		        	return this.analyzeLogicalExpr(pNode);
		        case "AssignmentExpr":
		        	return this.analyzeAssignmentExpr(pNode);
		        case "T_NON_TYPE_ID":
		        	return this.analyzeIdExpr(pNode);
		        case "T_STRING":
		        case "T_UINT":
		        case "T_FLOAT":
		        case "T_KW_TRUE":
		        case "T_KW_FALSE":
		        	return this.analyzeSimpleExpr(pNode);
		       	case "MemExpr":
		       		return this.analyzeMemExpr(pNode);
		       	default:
		       		this._error( 2204 , { exprName: sName });
		       		break;
        	}

       		return null;
        }

        private analyzeObjectExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var sName: string = pNode.children[pNode.children.length - 1].name;

        	switch(sName){
        		case "T_KW_COMPILE":
        			return this.analyzeCompileExpr(pNode);
        		case "T_KW_SAMPLER_STATE":
        			return this.analyzeSamplerStateBlock(pNode);
        	}
        }

        private analyzeCompileExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: CompileExprInstruction = new CompileExprInstruction();
        	var pExprType: IAFXVariableTypeInstruction;
        	var pArguments: IAFXExprInstruction[] = null;
        	var sShaderFuncName: string = pChildren[pChildren.length - 2].value;
        	var pShaderFunc: IAFXFunctionDeclInstruction = null;
        	var i:  number  = 0;

        	pArguments = [];

        	if(pChildren.length > 4){
        		var pArgumentExpr: IAFXExprInstruction;

        		for(i = pChildren.length - 3; i > 0; i--) {
        			if(pChildren[i].value !== ","){
        				pArgumentExpr = this.analyzeExpr(pChildren[i]);
        				pArguments.push(pArgumentExpr);
        			}
        		}
        	}

        	pShaderFunc = this.findShaderFunction(sShaderFuncName, pArguments);

        	if(isNull(pShaderFunc)){
        		this._error( 2226 , { funcName: sShaderFuncName });
        		return null;
        	}

        	pExprType = (<IAFXVariableTypeInstruction>pShaderFunc.getType()).wrap();

        	pExpr.setType(pExprType);
        	pExpr.setOperator("complile");
        	pExpr.push(pShaderFunc.getNameId(), false);

        	if(!isNull(pArguments)){
        		for(i = 0; i < pArguments.length; i++) {
        			pExpr.push(pArguments[i], true);
        		}
        	}

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeSamplerStateBlock(pNode: IParseNode): IAFXExprInstruction {
        	pNode = pNode.children[0];
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: SamplerStateBlockInstruction = new SamplerStateBlockInstruction();
        	var i:  number  = 0;

        	pExpr.setOperator("sample_state");

        	for(i = pChildren.length - 2; i >= 1; i--){
        		this.analyzeSamplerState(pChildren[i], pExpr);
        	}

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeSamplerState(pNode: IParseNode, pSamplerStates: SamplerStateBlockInstruction): void {
        	this.setAnalyzedNode(pNode);

      		var pChildren: IParseNode[] = pNode.children;
      		if(pChildren[pChildren.length - 2].name === "StateIndex"){
      			this._error( 2270 );
      			return;
      		}

      		var pStateExprNode: IParseNode = pChildren[pChildren.length - 3];
      		var pSubStateExprNode: IParseNode = pStateExprNode.children[pStateExprNode.children.length - 1];
      		var sStateType: string = pChildren[pChildren.length - 1].value.toUpperCase();
      		var sStateValue: string = "";
      		var isTexture: bool = false;

      		if(isNull(pSubStateExprNode.value)){
        		this._error( 2271 );
  				return;
        	}
        	var pTexture: IAFXVariableDeclInstruction = null;

      		switch (sStateType) {
		        case "TEXTURE":
		            var pTexture: IAFXVariableDeclInstruction = null;
	      			if(pStateExprNode.children.length !== 3 || pSubStateExprNode.value === "{"){
	      				this._error( 2271 );
	      				return;
	      			}
	      			var sTextureName: string = pStateExprNode.children[1].value;
	      			if(isNull(sTextureName) || !this.hasVariable(sTextureName)){
	      				this._error( 2271 );
	      				return;
	      			}

	      			pTexture = this.getVariable(sTextureName);
	      			sStateValue = sTextureName;
		            break;

/* WRAP_S */
		        case "ADDRESSU":
/* WRAP_T */
		        case "ADDRESSV":
		        	sStateValue = pSubStateExprNode.value.toUpperCase();
		        	switch (sStateValue) {
		                case "WRAP":
		                case "CLAMP":
		                case "MIRROR":
		                	break;
		                default:
		                    logger.setSourceLocation( "fx/Effect.ts" , 1923 ); logger.warning("Webgl don`t support this wrapmode: " + sStateValue); ;
		                    return;
		            }
		            break;

		        case "MAGFILTER":
		        case "MINFILTER":
		        	sStateValue = pSubStateExprNode.value.toUpperCase();
		        	switch (sStateValue) {
		                case "NEAREST":
		                case "LINEAR":
		                case "NEAREST_MIPMAP_NEAREST":
		                case "LINEAR_MIPMAP_NEAREST":
		                case "NEAREST_MIPMAP_LINEAR":
		                case "LINEAR_MIPMAP_LINEAR":
		                    break;
		                default:
		                    logger.setSourceLocation( "fx/Effect.ts" , 1940 ); logger.warning("Webgl don`t support this texture filter: " + sStateValue); ;
		                    return;
		            }
            		break;

		        default:
		            logger.setSourceLocation( "fx/Effect.ts" , 1946 ); logger.warning("Don`t support this texture param: " + sStateType); ;
		            return;
		    }

		    if(sStateType !== "TEXTURE") {
		    	pSamplerStates.addState(sStateType, sStateValue);
		    }
		    else {
		    	pSamplerStates.setTexture(pTexture);
		    }
        }

        private analyzeComplexExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

        	switch(sFirstNodeName){
        		case "T_NON_TYPE_ID":
        			return this.analyzeFunctionCallExpr(pNode);
        		case "BaseType":
        		case "T_TYPE_ID":
        			return this.analyzeConstructorCallExpr(pNode);
        		default:
        			return this.analyzeSimpleComplexExpr(pNode);
        	}
        }

        private analyzeFunctionCallExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: IAFXExprInstruction = null;
        	var pExprType: IAFXVariableTypeInstruction = null;
        	var pArguments: IAFXExprInstruction[] = null;
        	var sFuncName: string = pChildren[pChildren.length - 1].value;
        	var pFunction: IAFXFunctionDeclInstruction = null;
        	var pFunctionId: IAFXIdExprInstruction = null;
        	var i:  number  = 0;
        	var pCurrentAnalyzedFunction: IAFXFunctionDeclInstruction = this.getCurrentAnalyzedFunction();

        	if(pChildren.length > 3){
        		var pArgumentExpr: IAFXExprInstruction;

        		pArguments = [];

        		for(i = pChildren.length - 3; i > 0; i--) {
        			if(pChildren[i].value !== ","){
        				pArgumentExpr = this.analyzeExpr(pChildren[i]);
        				pArguments.push(pArgumentExpr);
        			}
        		}
        	}

        	pFunction = this.findFunction(sFuncName, pArguments);

        	if(isNull(pFunction)){
        		this._error( 2223 , { funcName: sFuncName });
        		return null;
        	}

        	if(!isDef(pFunction)){
        		this._error( 2246 , {funcName: sFuncName });
        		return null;
        	}

        	if(!isNull(pCurrentAnalyzedFunction)){
        		if(!pFunction._isForPixel()) {
        			pCurrentAnalyzedFunction._setForPixel(false);
        		}

        		if(!pFunction._isForVertex()) {
        			pCurrentAnalyzedFunction._setForVertex(false);
        		}
        	}

        	if(pFunction._getInstructionType() === EAFXInstructionTypes.k_FunctionDeclInstruction){
        		var pFunctionCallExpr: FunctionCallInstruction = new FunctionCallInstruction();

	        	pFunctionId = new IdExprInstruction();
	        	pFunctionId.push(pFunction.getNameId(), false);

	        	pExprType = (<IAFXVariableTypeInstruction>pFunction.getType()).wrap();

	        	pFunctionCallExpr.setType(pExprType);
	        	pFunctionCallExpr.push(pFunctionId, true);

	        	if(!isNull(pArguments)){
	        		for(i = 0; i < pArguments.length; i++) {
	        			pFunctionCallExpr.push(pArguments[i], true);
	        		}

	        		var pFunctionArguments: IAFXVariableDeclInstruction[] = (<FunctionDeclInstruction>pFunction).getArguments();
		        	for(i = 0; i < pArguments.length; i++){
	        			if(pFunctionArguments[i].getType().hasUsage("out")){
	        				if(!pArguments[i].getType().isWritable()){
	        					this._error( 2267 );
	        					return null;
	        				}

	        				if(pArguments[i].getType().isStrongEqual(Effect.getSystemType("ptr"))){
	        					this.addPointerForExtract(pArguments[i].getType()._getParentVarDecl());
	        				}
	        			}
	        			else if(pFunctionArguments[i].getType().hasUsage("inout")){
	        				if(!pArguments[i].getType().isWritable()){
	        					this._error( 2267 );
	        					return null;
	        				}

							if(!pArguments[i].getType().isReadable()){
	        					this._error( 2268 );
	        					return null;
	        				}

	        				if(pArguments[i].getType().isStrongEqual(Effect.getSystemType("ptr"))){
	        					this.addPointerForExtract(pArguments[i].getType()._getParentVarDecl());
	        				}
	        			}
	        			else {
	        				if(!pArguments[i].getType().isReadable()){
	        					this._error( 2268 );
	        					return null;
	        				}
	        			}
	        		}

	        		for(i = pArguments.length; i < pFunctionArguments.length; i++){
	        			pFunctionCallExpr.push(pFunctionArguments[i].getInitializeExpr(), false);
	        		}

	        	}

	        	if(!isNull(pCurrentAnalyzedFunction)){
	        		pCurrentAnalyzedFunction._addUsedFunction(pFunction);
	        	}

	        	pFunction._markUsedAs(EFunctionType.k_Function);

	        	pExpr = pFunctionCallExpr;
        	}
        	else {
        		var pSystemCallExpr: SystemCallInstruction = new SystemCallInstruction();

        		pSystemCallExpr.setSystemCallFunction(pFunction);
        		pSystemCallExpr.fillByArguments(pArguments);

        		if(!isNull(pCurrentAnalyzedFunction)){
        			for(i = 0; i < pArguments.length; i++){
        				if(!pArguments[i].getType().isReadable()) {
        					this._error( 2268 );
        					return null;
        				}
        			}
        		}

        		pExpr = pSystemCallExpr;

        		if(!pFunction.isBuiltIn() && !isNull(pCurrentAnalyzedFunction)){
        			pCurrentAnalyzedFunction._addUsedFunction(pFunction);
        		}
        	}

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeConstructorCallExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: ConstructorCallInstruction = new ConstructorCallInstruction();
        	var pExprType: IAFXVariableTypeInstruction = null;
        	var pArguments: IAFXExprInstruction[] = null;
        	var pConstructorType: IAFXTypeInstruction = null;
        	var i:  number  = 0;

        	pConstructorType = this.analyzeType(pChildren[pChildren.length - 1]);

        	if(isNull(pConstructorType)){
        		this._error( 2224 );
        		return null;
        	}

        	if(pChildren.length > 3){
        		var pArgumentExpr: IAFXExprInstruction = null;

        		pArguments = [];

        		for(i = pChildren.length - 3; i > 0; i--) {
        			if(pChildren[i].value !== ","){
        				pArgumentExpr = this.analyzeExpr(pChildren[i]);
        				pArguments.push(pArgumentExpr);
        			}
        		}
        	}

        	pExprType = this.findConstructor(pConstructorType, pArguments);

        	if(isNull(pExprType)){
        		this._error( 2225 , { typeName: pConstructorType.toString() });
        		return null;
        	}

        	pExpr.setType(pExprType);
        	pExpr.push(pConstructorType, false);

        	if(!isNull(pArguments)){
        		for(i = 0; i < pArguments.length; i++) {
        			if(!pArguments[i].getType().isReadable()){
        				this._error( 2268 );
        				return null;
        			}

        			pExpr.push(pArguments[i], true);
        		}
        	}

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeSimpleComplexExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: ComplexExprInstruction = new ComplexExprInstruction();
        	var pComplexExpr: IAFXExprInstruction;
        	var pExprType: IAFXVariableTypeInstruction;

        	pComplexExpr = this.analyzeExpr(pChildren[1]);
        	pExprType = <IAFXVariableTypeInstruction>pComplexExpr.getType();

        	pExpr.setType(pExprType);
        	pExpr.push(pComplexExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzePrimaryExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: PrimaryExprInstruction = new PrimaryExprInstruction();
        	var pPrimaryExpr: IAFXExprInstruction;
        	var pPointer: IAFXVariableDeclInstruction = null;
        	var pPrimaryExprType: IAFXVariableTypeInstruction;

        	pPrimaryExpr = this.analyzeExpr(pChildren[0]);
        	pPrimaryExprType = <IAFXVariableTypeInstruction>pPrimaryExpr.getType();

        	pPointer = pPrimaryExprType.getPointer();

        	if(isNull(pPointer)){
        		this._error( 2222 , { typeName: pPrimaryExprType.getHash() });
        		return null;
        	}

        	var pPointerVarType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pPrimaryExprType.getParent();
        	if(!pPrimaryExprType.isStrictPointer()){
        		this.getCurrentAnalyzedFunction()._setForPixel(false);
        		this.getCurrentAnalyzedFunction()._notCanUsedAsFunction();
        		pPrimaryExprType._setPointerToStrict();
        	}

        	pExpr.setType(pPointer.getType());
        	pExpr.setOperator("@");
        	pExpr.push(pPointer.getNameId(), false);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzePostfixExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sSymbol: string = pChildren[pChildren.length - 2].value;

        	switch(sSymbol){
        		case "[":
        			return this.analyzePostfixIndex(pNode);
        		case ".":
        			return this.analyzePostfixPoint(pNode);
        		case "++":
        		case "--":
        			return this.analyzePostfixArithmetic(pNode);
        	}
        }

        private analyzePostfixIndex(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: PostfixIndexInstruction = new PostfixIndexInstruction();
        	var pPostfixExpr: IAFXExprInstruction = null;
        	var pIndexExpr:IAFXExprInstruction = null;
        	var pExprType: IAFXVariableTypeInstruction = null;
        	var pPostfixExprType: IAFXVariableTypeInstruction = null;
        	var pIndexExprType: IAFXVariableTypeInstruction = null;
        	var pIntType: IAFXTypeInstruction = null;

        	pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pPostfixExprType = <IAFXVariableTypeInstruction>pPostfixExpr.getType();

        	if(!pPostfixExprType.isArray()){
        		this._error( 2217 , { typeName: pPostfixExprType.toString() });
        		return null;
        	}

        	pIndexExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	pIndexExprType = <IAFXVariableTypeInstruction>pIndexExpr.getType();

        	pIntType = Effect.getSystemType("int");

        	if(!pIndexExprType.isEqual(pIntType)){
        		this._error( 2218 , { typeName: pIndexExprType.toString() });
        		return null;
        	}

        	pExprType = <IAFXVariableTypeInstruction>(pPostfixExprType.getArrayElementType());

        	pExpr.setType(pExprType);
        	pExpr.push(pPostfixExpr, true);
        	pExpr.push(pIndexExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzePostfixPoint(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: PostfixPointInstruction = new PostfixPointInstruction();
        	var pPostfixExpr: IAFXExprInstruction = null;
        	var sFieldName: string = "";
        	var pFieldNameExpr: IAFXIdExprInstruction = null;
        	var pExprType: IAFXVariableTypeInstruction = null;
        	var pPostfixExprType: IAFXVariableTypeInstruction = null;

        	pPostfixExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pPostfixExprType = <IAFXVariableTypeInstruction>pPostfixExpr.getType();

        	sFieldName = pChildren[pChildren.length - 3].value;

        	pFieldNameExpr = pPostfixExprType.getFieldExpr(sFieldName);

        	if(isNull(pFieldNameExpr)){
        		this._error( 2219 , { typeName: pPostfixExprType.toString(),
        												   fieldName: sFieldName });
        		return null;
        	}

        	pExprType = <IAFXVariableTypeInstruction>pFieldNameExpr.getType();

        	if(pChildren.length === 4){
        		if(!pExprType.isPointer()){
        			this._error( 2220 , { typeName: pExprType.toString() });
        			return null;
        		}

        		var pBuffer: IAFXVariableDeclInstruction = this.analyzeFromExpr(pChildren[0]);
        		pExprType.setVideoBuffer(pBuffer);
        	}

        	pExpr.setType(pExprType);
        	pExpr.push(pPostfixExpr, true);
        	pExpr.push(pFieldNameExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzePostfixArithmetic(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pChildren[0].value;
        	var pExpr: PostfixArithmeticInstruction = new PostfixArithmeticInstruction();
        	var pPostfixExpr: IAFXExprInstruction;
        	var pExprType: IAFXVariableTypeInstruction;
        	var pPostfixExprType: IAFXVariableTypeInstruction;

        	pPostfixExpr = this.analyzeExpr(pChildren[1]);
        	pPostfixExprType = <IAFXVariableTypeInstruction>pPostfixExpr.getType();

        	pExprType = this.checkOneOperandExprType(sOperator, pPostfixExprType);

        	if(isNull(pExprType)){
        		this._error( 2221 , { operator: sOperator,
        													typeName: pPostfixExprType.toString()});
        		return null;
        	}

        	pExpr.setType(pExprType);
        	pExpr.setOperator(sOperator);
        	pExpr.push(pPostfixExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeUnaryExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pChildren[1].value;
        	var pExpr: UnaryExprInstruction = new UnaryExprInstruction();
        	var pUnaryExpr: IAFXExprInstruction;
        	var pExprType: IAFXVariableTypeInstruction;
        	var pUnaryExprType: IAFXVariableTypeInstruction;

        	pUnaryExpr = this.analyzeExpr(pChildren[0]);
        	pUnaryExprType = <IAFXVariableTypeInstruction>pUnaryExpr.getType();

        	pExprType = this.checkOneOperandExprType(sOperator, pUnaryExprType);

        	if(isNull(pExprType)){
        		this._error( 2216 , { operator: sOperator,
        												  tyepName: pUnaryExprType.toString()});
        		return null;
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pExprType);
        	pExpr.push(pUnaryExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeCastExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: CastExprInstruction = new CastExprInstruction();
        	var pExprType: IAFXVariableTypeInstruction;
        	var pCastedExpr: IAFXExprInstruction;

        	pExprType = this.analyzeConstTypeDim(pChildren[2]);
        	pCastedExpr = this.analyzeExpr(pChildren[0]);

        	if(!(<IAFXVariableTypeInstruction>pCastedExpr.getType()).isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	pExpr.setType(pExprType);
        	pExpr.push(pExprType, true);
        	pExpr.push(pCastedExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeConditionalExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExpr: ConditionalExprInstruction = new ConditionalExprInstruction();
        	var pConditionExpr: IAFXExprInstruction;
        	var pTrueExpr: IAFXExprInstruction;
        	var pFalseExpr: IAFXExprInstruction;
        	var pConditionType: IAFXVariableTypeInstruction;
			var pTrueExprType: IAFXVariableTypeInstruction;
        	var pFalseExprType: IAFXVariableTypeInstruction;
        	var pExprType: IAFXVariableTypeInstruction;
        	var pBoolType: IAFXTypeInstruction;

        	pConditionExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pTrueExpr = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	pFalseExpr = this.analyzeExpr(pChildren[0]);

        	pConditionType = <IAFXVariableTypeInstruction>pConditionExpr.getType();
        	pTrueExprType = <IAFXVariableTypeInstruction>pTrueExpr.getType();
        	pFalseExprType = <IAFXVariableTypeInstruction>pFalseExpr.getType();

        	pBoolType = Effect.getSystemType("bool");

        	if(!pConditionType.isEqual(pBoolType)){
        		this._error( 2211 , { typeName: pConditionType.toString()});
        		return null;
        	}

        	if(!pTrueExprType.isEqual(pFalseExprType)){
        		this._error( 2212 , { leftTypeName: pTrueExprType.toString(),
        														rightTypeName: pFalseExprType.toString()});
        		return null;
        	}

        	if(!pConditionType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	if(!pTrueExprType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	if(!pFalseExprType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	pExpr.setType(pTrueExprType);
        	pExpr.push(pConditionExpr, true);
        	pExpr.push(pTrueExpr, true);
        	pExpr.push(pFalseExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeArithmeticExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pNode.children[1].value;
        	var pExpr: ArithmeticExprInstruction = new ArithmeticExprInstruction();
        	var pLeftExpr: IAFXExprInstruction = null;
        	var pRightExpr: IAFXExprInstruction = null;
			var pLeftType: IAFXVariableTypeInstruction = null;
        	var pRightType: IAFXVariableTypeInstruction = null;
        	var pExprType: IAFXVariableTypeInstruction = null;

        	pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pRightExpr = this.analyzeExpr(pChildren[0]);

        	pLeftType = <IAFXVariableTypeInstruction>pLeftExpr.getType();
        	pRightType = <IAFXVariableTypeInstruction>pRightExpr.getType();

        	pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);

        	if(isNull(pExprType)){
        		this._error( 2206 , { operator: sOperator,
        													   leftTypeName: pLeftType.toString(),
        													   rightTypeName: pRightType.toString()});
        		return null;
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pExprType);
        	pExpr.push(pLeftExpr, true);
        	pExpr.push(pRightExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeRelationExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pNode.children[1].value;
        	var pExpr: RelationalExprInstruction = new RelationalExprInstruction();
        	var pLeftExpr: IAFXExprInstruction;
        	var pRightExpr: IAFXExprInstruction;
			var pLeftType: IAFXVariableTypeInstruction;
        	var pRightType: IAFXVariableTypeInstruction;
        	var pExprType: IAFXVariableTypeInstruction;

        	pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pRightExpr = this.analyzeExpr(pChildren[0]);

        	pLeftType = <IAFXVariableTypeInstruction>pLeftExpr.getType();
        	pRightType = <IAFXVariableTypeInstruction>pRightExpr.getType();

        	pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);

        	if(isNull(pExprType)){
        		this._error( 2209 , { operator: sOperator,
        													   leftTypeName: pLeftType.toString(),
        													   rightTypeName: pRightType.toString() });
        		return null;
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pExprType);
        	pExpr.push(pLeftExpr, true);
        	pExpr.push(pRightExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeLogicalExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pNode.children[1].value;
        	var pExpr: LogicalExprInstruction = new LogicalExprInstruction();
        	var pLeftExpr: IAFXExprInstruction;
        	var pRightExpr: IAFXExprInstruction;
			var pLeftType: IAFXVariableTypeInstruction;
        	var pRightType: IAFXVariableTypeInstruction;
			var pBoolType: IAFXTypeInstruction;

        	pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pRightExpr = this.analyzeExpr(pChildren[0]);

        	pLeftType = <IAFXVariableTypeInstruction>pLeftExpr.getType();
        	pRightType = <IAFXVariableTypeInstruction>pRightExpr.getType();

        	pBoolType = Effect.getSystemType("bool");

        	if(!pLeftType.isEqual(pBoolType)){
        		this._error( 2210 , { operator: sOperator,
    													    typeName: pLeftType.toString()});
        		return null;
        	}
        	if(!pRightType.isEqual(pBoolType)){
        		this._error( 2210 , { operator: sOperator,
    													    typeName: pRightType.toString()});
        		return null;
        	}

        	if(!pLeftType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	if(!pRightType.isReadable()){
        		this._error( 2268 );
        		return null;
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pBoolType);
        	pExpr.push(pLeftExpr, true);
        	pExpr.push(pRightExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeAssignmentExpr(pNode: IParseNode): IAFXExprInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sOperator: string = pChildren[1].value;
        	var pExpr: AssignmentExprInstruction = new AssignmentExprInstruction();
        	var pLeftExpr: IAFXExprInstruction;
        	var pRightExpr: IAFXExprInstruction;
			var pLeftType: IAFXVariableTypeInstruction;
        	var pRightType: IAFXVariableTypeInstruction;
        	var pExprType: IAFXVariableTypeInstruction;

        	pLeftExpr = this.analyzeExpr(pChildren[pChildren.length - 1]);
        	pRightExpr = this.analyzeExpr(pChildren[0]);

        	pLeftType = <IAFXVariableTypeInstruction>pLeftExpr.getType();
        	pRightType = <IAFXVariableTypeInstruction>pRightExpr.getType();

        	if(sOperator !== "="){
        		pExprType = this.checkTwoOperandExprTypes(sOperator, pLeftType, pRightType);
        	  	if(isNull(pExprType)){
        			this._error( 2207 , { operator: sOperator,
        													  			  	  leftTypeName: pLeftType.getHash(),
        													  			  	  rightTypeName: pRightType.getHash()});
        		}
        	}
        	else {
        		pExprType = pRightType;
        	}

        	pExprType = this.checkTwoOperandExprTypes("=", pLeftType, pExprType);

        	if(isNull(pExprType)){
        		this._error( 2208 , { leftTypeName: pLeftType.getHash(),
        													   rightTypeName: pRightType.getHash()});
        	}

        	pExpr.setOperator(sOperator);
        	pExpr.setType(pExprType);
        	pExpr.push(pLeftExpr, true);
        	pExpr.push(pRightExpr, true);

        	if(!pExpr.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExpr.getLastError()); } ;

        	return pExpr;
        }

        private analyzeIdExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var sName: string = pNode.value;
        	var pVariable: IAFXVariableDeclInstruction = this.getVariable(sName);

        	if(pVariable.getType()._isUnverifiable() && !this.isAnalzeInPass()){
        		this._error( 2276 );
        		return null;
        	}

        	if(isNull(pVariable)){
        		this._error( 2205 , {varName: sName});
        		return null;
        	}

        	if(!isNull(this.getCurrentAnalyzedFunction())){
        		if(!pVariable._isForPixel()){
        			this.getCurrentAnalyzedFunction()._setForPixel(false);
        		}
        		if(!pVariable._isForVertex()){
        			this.getCurrentAnalyzedFunction()._setForVertex(false);
        		}
        	}

        	var pVarId: IdExprInstruction = new IdExprInstruction();
        	pVarId.push(pVariable.getNameId(), false);

        	if(!pVarId.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pVarId.getLastError()); } ;

        	return pVarId;
        }

        private analyzeSimpleExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pInstruction: IAFXLiteralInstruction = null;
        	var sName: string = pNode.name;
        	var sValue: string = pNode.value;

        	switch(sName) {
        	 	case "T_UINT":
    	 		pInstruction = new IntInstruction();
        	 		pInstruction.setValue((< number ><any>sValue) * 1);
        	 		break;
        	 	case "T_FLOAT":
        	 		pInstruction = new FloatInstruction();
        	 		pInstruction.setValue((< number ><any>sValue) * 1.0);
        	 		break;
        	 	case "T_STRING":
        	 		pInstruction = new StringInstruction();
        	 		pInstruction.setValue(sValue);
        	 		break;
        	 	case "T_KW_TRUE":
        	 		pInstruction = new BoolInstruction();
        	 		pInstruction.setValue(true);
        	 		break;
        	 	case "T_KW_FALSE":
        	 		pInstruction = new BoolInstruction();
        	 		pInstruction.setValue(false);
        	 		break;
			}

        	return pInstruction;
        }

        private analyzeMemExpr(pNode: IParseNode): IAFXExprInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pMemExpr: MemExprInstruction = new MemExprInstruction();

        	var pPostfixExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[0]);
        	var pPostfixExprType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pPostfixExpr.getType();

        	if(!pPostfixExprType.isFromVariableDecl()){
        		this._error( 2253 );
        		return null;
        	}

        	var pBuffer: IAFXVariableDeclInstruction = pPostfixExprType.getVideoBuffer();

        	if(isNull(pBuffer)){
        		this._error( 2254 );
        	}

        	if(!pPostfixExprType.isStrictPointer() && !isNull(this.getCurrentAnalyzedFunction())){
        		this.getCurrentAnalyzedFunction()._setForPixel(false);
        		this.getCurrentAnalyzedFunction()._notCanUsedAsFunction();
        		pPostfixExprType._setPointerToStrict();
        	}

        	pMemExpr.setBuffer(pBuffer);

        	return pMemExpr;
        }

        private analyzeConstTypeDim(pNode: IParseNode): IAFXVariableTypeInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if(pChildren.length > 1) {
        		this._error( 2213 );
        		return null;
        	}

        	var pType: IAFXVariableTypeInstruction;

        	pType = <IAFXVariableTypeInstruction>(this.analyzeType(pChildren[0]));

        	if(!pType.isBase()){
        		this._error( 2214 , { typeName: pType.toString()});
        	}

        	if(!pType.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pType.getLastError()); } ;

        	return pType;
        }

        private analyzeVarStructDecl(pNode: IParseNode, pInstruction?: IAFXInstruction = null): void {
			this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pUsageType: IAFXVariableTypeInstruction = null;
        	var pVariable: IAFXVariableDeclInstruction = null;
        	var i:  number  = 0;

        	pUsageType = this.analyzeUsageStructDecl(pChildren[pChildren.length - 1]);

        	for(i = pChildren.length - 2; i >= 1; i--){
        		if(pChildren[i].name === "Variable") {
        			pVariable = this.analyzeVariable(pChildren[i], pUsageType);

        			if(!isNull(pInstruction)){
        				pInstruction.push(pVariable, true);
        			}
        		}
        	}
        }

        private analyzeUsageStructDecl(pNode: IParseNode): IAFXVariableTypeInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
		    var i:  number  = 0;
		    var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

		    for (i = pChildren.length - 1; i >= 0; i--) {
		        if (pChildren[i].name === "StructDecl") {
		        	var pMainType: IAFXTypeInstruction = this.analyzeStructDecl(pChildren[i]);
		        	pType.pushType(pMainType);

		        	var pTypeDecl: IAFXTypeDeclInstruction = new TypeDeclInstruction();
		        	pTypeDecl.push(pMainType, true);

		        	this.addTypeDecl(pTypeDecl);
		        }
		        else if (pChildren[i].name === "Usage") {
		        	var sUsage: string = this.analyzeUsage(pChildren[i]);
		        	pType.addUsage(sUsage);
		        }
		    }

		    if(!pType.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pType.getLastError()); } ;

		    return pType;
        }

		private analyzeTypeDecl(pNode: IParseNode, pParentInstruction: IAFXInstruction = null): IAFXTypeDeclInstruction {
			this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;

			var pTypeDeclInstruction: IAFXTypeDeclInstruction = new TypeDeclInstruction();

 			if(pChildren.length === 2) {
				var pStructInstruction: ComplexTypeInstruction = <ComplexTypeInstruction>this.analyzeStructDecl(pChildren[1]);
				pTypeDeclInstruction.push(pStructInstruction, true);
			}
			else {
				this._error( 2203 );
			}

			if(!pTypeDeclInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pTypeDeclInstruction.getLastError()); } ;

			this.addTypeDecl(pTypeDeclInstruction);

			pNode.isAnalyzed = true;

			if(!isNull(pParentInstruction)){
				pParentInstruction.push(pTypeDeclInstruction, true);
			}

			return pTypeDeclInstruction;
		}

        private analyzeStructDecl(pNode: IParseNode): IAFXTypeInstruction {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;

        	var pStruct: ComplexTypeInstruction = new ComplexTypeInstruction();
        	var pFieldCollector: IAFXInstruction = new InstructionCollector();

        	var sName: string = pChildren[pChildren.length - 2].value;

        	pStruct.setName(sName);

        	this.newScope(EScopeType.k_Struct);

        	var i:  number  = 0;
        	for (i = pChildren.length - 4; i >= 1; i--) {
		        if (pChildren[i].name === "VariableDecl") {
		            this.analyzeVariableDecl(pChildren[i], pFieldCollector);
		        }
		    }

		    this.endScope();

		    pStruct.addFields(pFieldCollector, true);

		    if(!pStruct.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pStruct.getLastError()); } ;

        	return pStruct;
        }

        private analyzeStruct(pNode: IParseNode): IAFXTypeInstruction {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;

        	var pStruct: ComplexTypeInstruction = new ComplexTypeInstruction();
        	var pFieldCollector: IAFXInstruction = new InstructionCollector();

        	this.newScope(EScopeType.k_Struct);

        	var i:  number  = 0;
        	for (i = pChildren.length - 4; i >= 1; i--) {
		        if (pChildren[i].name === "VariableDecl") {
		            this.analyzeVariableDecl(pChildren[i], pFieldCollector);
		        }
		    }

		    this.endScope();

		    pStruct.addFields(pFieldCollector, true);

		    if(!pStruct.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pStruct.getLastError()); } ;

        	return pStruct;
        }

        private analyzeFunctionDeclOnlyDefinition(pNode: IParseNode): IAFXFunctionDeclInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pFunction: FunctionDeclInstruction = null;
        	var pFunctionDef: FunctionDefInstruction = null;
        	var pStmtBlock: StmtBlockInstruction = null;
        	var pAnnotation: IAFXAnnotationInstruction = null;
        	var sLastNodeValue: string = pChildren[0].value;
        	var bNeedAddFunction: bool = false;

        	pFunctionDef = this.analyzeFunctionDef(pChildren[pChildren.length - 1]);

        	pFunction = <FunctionDeclInstruction>this.findFunctionByDef(pFunctionDef);

        	if(!isDef(pFunction)){
        		this._error( 2246 , {funcName: pFunction.getNameId().toString() });
        		return null;
        	}

        	if(!isNull(pFunction) && pFunction.hasImplementation()){
        		this._error( 2227 , { funcName: pFunction.getNameId().toString() });
        		return null;
        	}

        	if(isNull(pFunction)){
        		pFunction = new FunctionDeclInstruction();
        		bNeedAddFunction = true;
        	}
        	else {
        		if(!pFunction.getReturnType().isEqual(pFunctionDef.getReturnType())){
        			this._error( 2247 , {funcName: pFunction.getNameId().toString() });
        			return null;
        		}

        		bNeedAddFunction = false;
        	}

    		pFunction.setFunctionDef(<IAFXDeclInstruction>pFunctionDef);

    		this.resumeScope();

    		if(pChildren.length === 3) {
        		pAnnotation = this.analyzeAnnotation(pChildren[1]);
        		pFunction.setAnnotation(pAnnotation);
        	}

        	if(sLastNodeValue !== ";") {
        		pFunction._setParseNode(pNode);
        		pFunction._setImplementationScope(this.getScope());
        		this._pFunctionWithImplementationList.push(pFunction);
        	}

        	this.endScope();

        	if(bNeedAddFunction){
        		this.addFunctionDecl(pFunction);
       	 	}

        }

        private resumeFunctionAnalysis(pAnalzedFunction: IAFXFunctionDeclInstruction): void {
        	var pFunction: FunctionDeclInstruction = <FunctionDeclInstruction>pAnalzedFunction;
        	var pNode: IParseNode = pFunction._getParseNode();

        	this.setAnalyzedNode(pNode);
        	this.setScope(pFunction._getImplementationScope());

        	var pChildren: IParseNode[] = pNode.children;
        	var pStmtBlock: StmtBlockInstruction = null;

        	this.setCurrentAnalyzedFunction(pFunction);

// LOG("-----Analyze function '" + pFunction.getName() + "'------");

        	pStmtBlock = <StmtBlockInstruction>this.analyzeStmtBlock(pChildren[0]);
 			pFunction.setImplementation(<IAFXStmtInstruction>pStmtBlock);

 			this.setCurrentAnalyzedFunction(null);

 			this.endScope();

 			if(!pFunction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pFunction.getLastError()); } ;
        }

        private analyzeFunctionDef(pNode: IParseNode): FunctionDefInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pFunctionDef: FunctionDefInstruction = new FunctionDefInstruction();
        	var pReturnType: IAFXVariableTypeInstruction = null;
        	var pFuncName: IAFXIdInstruction = null;
        	var pArguments: IAFXVariableDeclInstruction[] = null;
        	var sFuncName: string = pChildren[pChildren.length - 2].value;

        	pReturnType = this.analyzeUsageType(pChildren[pChildren.length - 1]);

        	if(pReturnType.isPointer() || pReturnType._containSampler() || pReturnType._containPointer()){
        		this._error( 2264 , { funcName: sFuncName });
        		return null;
        	}

        	pFuncName = new IdInstruction();
        	pFuncName.setName(sFuncName);

        	pFunctionDef.setReturnType(pReturnType);
        	pFunctionDef.setFunctionName(pFuncName);

        	if(pChildren.length === 4){
        		var sSemantic: string = this.analyzeSemantic(pChildren[0]);
        		pFunctionDef.setSemantic(sSemantic);
        	}

        	this.newScope();

        	this.analyzeParamList(pChildren[pChildren.length - 3], pFunctionDef);

        	this.endScope();

        	if(!pFunctionDef.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pFunctionDef.getLastError()); } ;

        	return pFunctionDef;
        }

        private analyzeParamList(pNode:IParseNode, pFunctionDef: FunctionDefInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pParameter: IAFXVariableDeclInstruction;

        	var i:  number  = 0;

        	for (i = pChildren.length - 2; i >= 1; i--) {
        		if (pChildren[i].name === "ParameterDecl") {
		            pParameter = this.analyzeParameterDecl(pChildren[i]);
		            pParameter._setScope(this.getScope());
		            pFunctionDef.addParameter(pParameter, this.isStrictMode());
		        }
        	}
        }

        private analyzeParameterDecl(pNode: IParseNode): IAFXVariableDeclInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pType: IAFXVariableTypeInstruction = null;
        	var pParameter: IAFXVariableDeclInstruction = null;

        	pType = this.analyzeParamUsageType(pChildren[1]);
        	pParameter = this.analyzeVariable(pChildren[0], pType);

        	return pParameter;
        }

        private analyzeParamUsageType(pNode: IParseNode): IAFXVariableTypeInstruction {
        	var pChildren: IParseNode[] = pNode.children;
		    var i:  number  = 0;
		    var pType: IAFXVariableTypeInstruction = new VariableTypeInstruction();

		    for (i = pChildren.length - 1; i >= 0; i--) {
		        if (pChildren[i].name === "Type") {
		        	var pMainType: IAFXTypeInstruction = this.analyzeType(pChildren[i]);
		        	pType.pushType(pMainType);
		        }
		        else if (pChildren[i].name === "ParamUsage") {
		        	var sUsage: string = this.analyzeUsage(pChildren[i]);
		        	pType.addUsage(sUsage);
		        }
		    }

		    if(!pType.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pType.getLastError()); } ;

		    return pType;
        }

        private analyzeStmtBlock(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pStmtBlock: StmtBlockInstruction = new StmtBlockInstruction();
        	var pStmt: IAFXStmtInstruction;
        	var i:  number  = 0;

        	pStmtBlock._setScope(this.getScope());

        	this.newScope();

        	for(i = pChildren.length - 2; i > 0; i--){
        		pStmt = this.analyzeStmt(pChildren[i]);
        		if(!isNull(pStmt)){
        			pStmtBlock.push(pStmt);
        		}

        		this.addExtactionStmts(pStmtBlock);
        	}

        	this.endScope();

        	if(!pStmtBlock.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pStmtBlock.getLastError()); } ;

        	return pStmtBlock;
        }

        private analyzeStmt(pNode:IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

        	switch(sFirstNodeName){
        		case "SimpleStmt":
        			return this.analyzeSimpleStmt(pChildren[0]);
        		case "UseDecl":
        			this.analyzeUseDecl(pChildren[0]);
        			return null;
        		case "T_KW_WHILE":
        			return this.analyzeWhileStmt(pNode);
        		case "T_KW_FOR":
        			return this.analyzeForStmt(pNode);
        		case "T_KW_IF":
        			return this.analyzeIfStmt(pNode);
        	}
        }

        private analyzeSimpleStmt(pNode: IParseNode): IAFXStmtInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

        	switch(sFirstNodeName){
        		case "T_KW_RETURN":
        			return this.analyzeReturnStmt(pNode);

        		case "T_KW_DO":
        			return this.analyzeWhileStmt(pNode);

        		case "StmtBlock":
        			return this.analyzeStmtBlock(pChildren[0]);

        		case "T_KW_DISCARD":
        		case "T_KW_BREAK":
        		case "T_KW_CONTINUE":
        			return this.analyzeBreakStmt(pNode);

        		case "TypeDecl":
        		case "VariableDecl":
        		case "VarStructDecl":
        			return this.analyzeDeclStmt(pChildren[0]);

        		default:
        			if(pChildren.length === 2) {
        				return this.analyzeExprStmt(pNode);
        			}
        			else {
        				return (new SemicolonStmtInstruction());
        			}
        	}
        }

        private analyzeReturnStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pReturnStmtInstruction: ReturnStmtInstruction = new ReturnStmtInstruction();

        	var pFunctionReturnType: IAFXVariableTypeInstruction = this.getCurrentAnalyzedFunction().getReturnType();

        	if(pFunctionReturnType.isEqual(Effect.getSystemType("void")) && pChildren.length === 3){
        		this._error( 2261 );
        		return null;
        	}
        	else if(!pFunctionReturnType.isEqual(Effect.getSystemType("void")) && pChildren.length === 2){
        		this._error( 2262 );
        		return null;
        	}

        	if(pChildren.length === 3) {
        		var pExprInstruction: IAFXExprInstruction = this.analyzeExpr(pChildren[1]);
        		var pOutVar: IAFXVariableDeclInstruction = this.getCurrentAnalyzedFunction()._getOutVariable();

        		if(!isNull(pOutVar) && pOutVar.getType() !== pExprInstruction.getType()){
        			this._error( 2263 );
        			return null;
        		}

        		if(!pFunctionReturnType.isEqual(pExprInstruction.getType())){
        			this._error( 2263 );
        			return null;
        		}
        		pReturnStmtInstruction.push(pExprInstruction, true);
        	}

        	if(!pReturnStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pReturnStmtInstruction.getLastError()); } ;

        	return pReturnStmtInstruction;
        }

        private analyzeBreakStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pBreakStmtInstruction: BreakStmtInstruction = new BreakStmtInstruction();
        	var sOperatorName: string = pChildren[1].value;

        	pBreakStmtInstruction.setOperator(sOperatorName);

        	if(sOperatorName === "discard" && !isNull(this.getCurrentAnalyzedFunction())){
        		this.getCurrentAnalyzedFunction()._setForVertex(false);
        	}

        	if(!pBreakStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pBreakStmtInstruction.getLastError()); } ;

        	return pBreakStmtInstruction;
        }

        private analyzeDeclStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sNodeName: string = pNode.name;
        	var pDeclStmtInstruction: DeclStmtInstruction = new DeclStmtInstruction();

        	switch(sNodeName){
        		case "TypeDecl":
        			this.analyzeTypeDecl(pNode, pDeclStmtInstruction);
        			break;
        		case "VariableDecl":
        			this.analyzeVariableDecl(pNode, pDeclStmtInstruction);
        			break;
    			case "VarStructDecl":
    				this.analyzeVarStructDecl(pNode,  pDeclStmtInstruction);
    				break;
        	}

        	if(!pDeclStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pDeclStmtInstruction.getLastError()); } ;

        	return pDeclStmtInstruction;
        }

       	private analyzeExprStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pExprStmtInstruction: ExprStmtInstruction = new ExprStmtInstruction();
        	var pExprInstruction: IAFXExprInstruction = this.analyzeExpr(pChildren[1]);

        	pExprStmtInstruction.push(pExprInstruction, true);

        	if(!pExprStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pExprStmtInstruction.getLastError()); } ;

        	return pExprStmtInstruction;
        }

        private analyzeWhileStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var isDoWhile: bool = (pChildren[pChildren.length - 1].value === "do");
        	var isNonIfStmt: bool = (pNode.name === "NonIfStmt") ? true : false;

        	var pWhileStmt: WhileStmtInstruction = new WhileStmtInstruction();
        	var pCondition: IAFXExprInstruction = null;
        	var pConditionType: IAFXVariableTypeInstruction = null;
        	var pBoolType: IAFXTypeInstruction = Effect.getSystemType("bool");
        	var pStmt: IAFXStmtInstruction = null;

        	if(isDoWhile) {
        		pWhileStmt.setOperator("do_while");
        		pCondition = this.analyzeExpr(pChildren[2]);
        		pConditionType = <IAFXVariableTypeInstruction>pCondition.getType();

        		if(!pConditionType.isEqual(pBoolType)){
	        		this._error( 2229 , { typeName: pConditionType.toString() });
	        		return null;
	        	}

	        	pStmt = this.analyzeStmt(pChildren[0]);
        	}
        	else {
        		pWhileStmt.setOperator("while");
        		pCondition = this.analyzeExpr(pChildren[2]);
        		pConditionType = <IAFXVariableTypeInstruction>pCondition.getType();

        		if(!pConditionType.isEqual(pBoolType)){
	        		this._error( 2228 , { typeName: pConditionType.toString() });
	        		return null;
	        	}

	        	if(isNonIfStmt){
	        		pStmt = this.analyzeNonIfStmt(pChildren[0]);
	        	}
	        	else {
	        		pStmt = this.analyzeStmt(pChildren[0]);
	        	}

	        	pWhileStmt.push(pCondition, true);
	        	pWhileStmt.push(pStmt, true);
	        }

	        if(!pWhileStmt.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pWhileStmt.getLastError()); } ;

        	return pWhileStmt;
        }

        private analyzeIfStmt(pNode: IParseNode): IAFXStmtInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var isIfElse: bool = (pChildren.length === 7);

        	var pIfStmtInstruction: IfStmtInstruction = new IfStmtInstruction();
        	var pCondition: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	var pConditionType: IAFXVariableTypeInstruction = <IAFXVariableTypeInstruction>pCondition.getType();
        	var pBoolType: IAFXTypeInstruction = Effect.getSystemType("bool");

        	var pIfStmt: IAFXStmtInstruction = null;
        	var pElseStmt: IAFXStmtInstruction = null;

        	if(!pConditionType.isEqual(pBoolType)){
        		this._error( 2230 , { typeName: pConditionType.toString() });
        		return null;
        	}

        	pIfStmtInstruction.push(pCondition, true);

        	if(isIfElse){
        		pIfStmtInstruction.setOperator("if_else");
        		pIfStmt = this.analyzeNonIfStmt(pChildren[2]);
        		pElseStmt = this.analyzeStmt(pChildren[0]);

        		pIfStmtInstruction.push(pIfStmt, true);
        		pIfStmtInstruction.push(pElseStmt, true);
        	}
        	else {
        		pIfStmtInstruction.setOperator("if");
        		pIfStmt = this.analyzeNonIfStmt(pChildren[0]);

        		pIfStmtInstruction.push(pIfStmt, true);
        	}

        	if(!pIfStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pIfStmtInstruction.getLastError()); } ;

        	return pIfStmtInstruction;
        }

        private analyzeNonIfStmt(pNode: IParseNode): IAFXStmtInstruction{
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

        	switch(sFirstNodeName){
        		case "SimpleStmt":
        			return this.analyzeSimpleStmt(pChildren[0]);
        		case "T_KW_WHILE":
        			return this.analyzeWhileStmt(pNode);
        		case "T_KW_FOR":
        			return this.analyzeForStmt(pNode);
        	}
        }

        private analyzeForStmt(pNode: IParseNode): IAFXStmtInstruction {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;
        	var isNonIfStmt: bool = (pNode.name === "NonIfStmt");
        	var pForStmtInstruction: ForStmtInstruction = new ForStmtInstruction();
        	var pStmt: IAFXStmtInstruction = null;

        	this.newScope();

        	this.analyzeForInit(pChildren[pChildren.length - 3], pForStmtInstruction);
        	this.analyzeForCond(pChildren[pChildren.length - 4], pForStmtInstruction);

        	if(pChildren.length === 7) {
        		this.analyzeForStep(pChildren[2], pForStmtInstruction);
        	}
        	else {
        		pForStmtInstruction.push(null);
        	}


        	if(isNonIfStmt) {
        		pStmt = this.analyzeNonIfStmt(pChildren[0]);
        	}
        	else {
        		pStmt = this.analyzeStmt(pChildren[0]);
        	}

        	pForStmtInstruction.push(pStmt, true);

        	this.endScope();

        	if(!pForStmtInstruction.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pForStmtInstruction.getLastError()); } ;

        	return pForStmtInstruction;
        }

        private analyzeForInit(pNode: IParseNode, pForStmtInstruction: ForStmtInstruction): void {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;
			var sFirstNodeName: string = pChildren[pChildren.length - 1].name;

			switch(sFirstNodeName){
				case "VariableDecl":
					this.analyzeVariableDecl(pChildren[0], pForStmtInstruction);
					break;
				case "Expr":
					var pExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[0]);
					pForStmtInstruction.push(pExpr, true);
					break;
				default:
// ForInit : ';'
					pForStmtInstruction.push(null);
					break;
			}

        	return;
        }

        private analyzeForCond(pNode: IParseNode, pForStmtInstruction: ForStmtInstruction): void {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;

			if(pChildren.length === 1){
				pForStmtInstruction.push(null);
				return;
			}

			var pConditionExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[1]);

			pForStmtInstruction.push(pConditionExpr, true);
			return;
        }

        private analyzeForStep(pNode: IParseNode, pForStmtInstruction: ForStmtInstruction): void {
        	this.setAnalyzedNode(pNode);

			var pChildren: IParseNode[] = pNode.children;
			var pStepExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[0]);

			pForStmtInstruction.push(pStepExpr, true);

        	return;
        }


        private analyzeUseDecl(pNode: IParseNode): void {
        	this.setAnalyzedNode(pNode);
        	this.setStrictModeOn();
        }

        private analyzeTechniqueForImport(pNode: IParseNode): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var pTechnique: IAFXTechniqueInstruction = new TechniqueInstruction();
        	var sTechniqueName: string = this.analyzeComplexName(pChildren[pChildren.length - 2]);
        	var isComplexName: bool = pChildren[pChildren.length - 2].children.length !== 1;

        	pTechnique.setName(sTechniqueName, isComplexName);

        	for (var i:  number  = pChildren.length - 3; i >= 0; i--) {
		        if (pChildren[i].name === "Annotation") {
		            var pAnnotation: IAFXAnnotationInstruction = this.analyzeAnnotation(pChildren[i]);
		            pTechnique.setAnnotation(pAnnotation);
		        }
		        else if (pChildren[i].name === "Semantic") {
		            var sSemantic: string = this.analyzeSemantic(pChildren[i]);
		            pTechnique.setSemantic(sSemantic);
		        }
		        else {
	            	this.analyzeTechniqueBodyForImports(pChildren[i], pTechnique);
	       		}
	    	}

	    	this.addTechnique(pTechnique);
        }

        private analyzeComplexName(pNode: IParseNode): string {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
        	var sName: string = "";

        	for(var i:  number  = pChildren.length - 1; i >= 0; i--){
        		sName += pChildren[i].value;
        	}

        	return sName;
        }

        private analyzeTechniqueBodyForImports(pNode: IParseNode, pTechnique: IAFXTechniqueInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for (var i:  number  = pChildren.length - 2; i >= 1; i--) {
        		this.analyzePassDeclForImports(pChildren[i], pTechnique);
        	}
        }

        private analyzePassDeclForImports(pNode: IParseNode, pTechnique: IAFXTechniqueInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if(pChildren[0].name === "ImportDecl"){
        		this.analyzeImportDecl(pChildren[0], pTechnique);
        	}
        	else if(pChildren.length > 1) {
        		var pPass: IAFXPassInstruction = new PassInstruction();
//TODO: add annotation and id
        		this.analyzePassStateBlockForShaders(pChildren[0], pPass);

        		pPass._setParseNode(pNode);

        		pTechnique.addPass(pPass);
        	}
        }

        private analyzePassStateBlockForShaders(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for (var i:  number  = pChildren.length - 2; i >= 1; i--) {
		        this.analyzePassStateForShader(pChildren[i], pPass);
		    }
        }

        private analyzePassStateForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if(pChildren.length === 1){
        		pPass._markAsComplex(true);

        		if(pChildren[0].name === "StateIf"){
        			this.analyzePassStateIfForShader(pChildren[0], pPass);
        		}
        		else if(pChildren[0].name === "StateSwitch"){
        			this.analyzePassStateSwitchForShader(pChildren[0], pPass);
        		}

        		return;
        	}

        	var sType: string = pChildren[pChildren.length - 1].value.toUpperCase();
        	var eShaderType: EFunctionType = EFunctionType.k_Vertex;

        	if(sType === "VERTEXSHADER"){
        		eShaderType = EFunctionType.k_Vertex
        	}
        	else if(sType === "PIXELSHADER"){
        		eShaderType = EFunctionType.k_Pixel;
        	}
        	else {
        		return;
        	}

        	pNode.isAnalyzed = true;

        	var pStateExprNode: IParseNode = pChildren[pChildren.length - 3];
        	var pExprNode: IParseNode = pStateExprNode.children[pStateExprNode.children.length - 1];
        	var pCompileExpr: CompileExprInstruction = <CompileExprInstruction>this.analyzeExpr(pExprNode);
        	var pShaderFunc: IAFXFunctionDeclInstruction = pCompileExpr.getFunction();

        	if(eShaderType === EFunctionType.k_Vertex){
        		if(!pShaderFunc._checkDefenitionForVertexUsage()){
        			this._error( 2259 , {funcDef: pShaderFunc._getStringDef()});
        		}
        	}
        	else{
        		if(!pShaderFunc._checkDefenitionForPixelUsage()){
        			this._error( 2260 , {funcDef: pShaderFunc._getStringDef()});
        		}
        	}

        	pShaderFunc._markUsedAs(eShaderType);

        	pPass._addFoundFunction(pNode, pShaderFunc, eShaderType);
        }

        private analyzePassStateIfForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if (pChildren.length === 5){
        		this.analyzePassStateBlockForShaders(pChildren[0], pPass);
        	}
        	else if(pChildren.length === 7 && pChildren[0].name === "PassStateBlock"){
        		this.analyzePassStateBlockForShaders(pChildren[2], pPass);
        		this.analyzePassStateBlockForShaders(pChildren[0], pPass);
        	}
        	else {
        		this.analyzePassStateBlockForShaders(pChildren[2], pPass);
        		this.analyzePassStateIfForShader(pChildren[0], pPass);
        	}
        }

        private analyzePassStateSwitchForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	this.analyzePassCaseBlockForShader(pChildren[0], pPass);
        }

        private analyzePassCaseBlockForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for(var i:  number  = pChildren.length - 2; i >= 1; i--){
        		if(pChildren[i].name === "CaseState"){
        			this.analyzePassCaseStateForShader(pChildren[i], pPass);
        		}
        		else if(pChildren[i].name === "DefaultState"){
        			this.analyzePassDefaultStateForShader(pChildren[i], pPass);
        		}
        	}
        }

        private analyzePassCaseStateForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for(var i:  number  = pChildren.length - 4; i >= 0; i--){
        		if(pChildren[i].name === "PassState"){
        			this.analyzePassStateForShader(pChildren[i], pPass);
        		}
        	}
        }

        private analyzePassDefaultStateForShader(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	for(var i:  number  = pChildren.length - 3; i >= 0; i--){
        		if(pChildren[i].name === "PassState"){
        			this.analyzePassStateForShader(pChildren[i], pPass);
        		}
        	}
        }

        private resumeTechniqueAnalysis(pTechnique: IAFXTechniqueInstruction): void {
        	var pPassList: IAFXPassInstruction[] = pTechnique.getPassList();

        	for(var i:  number  = 0; i < pPassList.length; i++){
        		this.resumePassAnalysis(pPassList[i]);
        	}

			if(!pTechnique.checkForCorrectImports()){
				this._error( 2275 , { techniqueName: pTechnique.getName() });
				return;
			}

			pTechnique.finalizeTechnique(this._sProvideNameSpace,
										 this._pGlobalComponentList,
										 this._pGlobalComponetShiftList);
        }

        private resumePassAnalysis(pPass: IAFXPassInstruction): void {
         	var pNode: IParseNode = pPass._getParseNode();

        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	this.setAnalyzeInPass(true);
        	this.analyzePassStateBlock(pChildren[0], pPass);
        	this.setAnalyzeInPass(false);

        	pPass.finalizePass();
        }

        private analyzePassStateBlock(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	pPass._addCodeFragment("{");

        	for (var i:  number  = pChildren.length - 2; i >= 1; i--) {
		        this.analyzePassState(pChildren[i], pPass);
		    }

		    pPass._addCodeFragment("}");
        }

        private analyzePassState(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if(pChildren.length === 1){
        		if(pChildren[0].name === "StateIf"){
        			this.analyzePassStateIf(pChildren[0], pPass);
        		}
        		else if(pChildren[0].name === "StateSwitch"){
        			this.analyzePassStateSwitch(pChildren[0], pPass);
        		}

        		return;
        	}

        	if(pNode.isAnalyzed) {
        		var pFunc: IAFXFunctionDeclInstruction = pPass._getFoundedFunction(pNode);
        		var eShaderType: EFunctionType = pPass._getFoundedFunctionType(pNode);
        		var pShader: IAFXFunctionDeclInstruction = null;

	        	if(eShaderType === EFunctionType.k_Vertex){
	        		pShader = pFunc._getVertexShader();
	        	}
	        	else {
	        		pShader = pFunc._getPixelShader();
	        	}

	        	pPass.addShader(pShader);
        	}
        	else {
        		var sType: string = pChildren[pChildren.length - 1].value.toUpperCase();
        		var pStateExprNode: IParseNode = pChildren[pChildren.length - 3];
        		var pExprNode: IParseNode = pStateExprNode.children[pStateExprNode.children.length - 1];

        		switch (sType) {
			        case "ZENABLE":
			        case "ZWRITEENABLE":
			        case "SRCBLEND":
			        case "DESTBLEND":
			        case "CULLMODE":
			        case "ZFUNC":
			        case "DITHERENABLE":
			        case "ALPHABLENDENABLE":
			        case "ALPHATESTENABLE":
			            break;

			        default:
			            logger.setSourceLocation( "fx/Effect.ts" , 3744 ); logger.warning("Unsupported render state type used: " + sType + ". WebGl..."); ;
			            return;
			    }

			    if (pExprNode.value === "{" || pExprNode.value === "<" ||
			        isNull(pExprNode.value)) {
			        logger.setSourceLocation( "fx/Effect.ts" , 3750 ); logger.warning("So pass state are incorrect"); ;
			        return;
			    }

			    var sValue: string = pExprNode.value.toUpperCase();
			    switch (sType) {
			        case "ALPHABLENDENABLE":
			        case "ALPHATESTENABLE":
			            logger.setSourceLocation( "fx/Effect.ts" , 3758 ); logger.warning("ALPHABLENDENABLE/ALPHATESTENABLE not supported in WebGL."); ;
			            return;

			        case "DITHERENABLE":
			        case "ZENABLE":
			        case "ZWRITEENABLE":
			            switch (sValue) {
			                case "TRUE":
			                case "FALSE":
			                    break;

			                default:
			                    logger.setSourceLocation( "fx/Effect.ts" , 3771 ); logger.warning("Unsupported render state ALPHABLENDENABLE/ZENABLE/ZWRITEENABLE/DITHERENABLE value used: " + sValue + ".");
                                                ;
								return;
			            }
			            break;

			        case "SRCBLEND":
			        case "DESTBLEND":
			            switch (sValue) {
			                case "ZERO":
			                case "ONE":
			                case "SRCCOLOR":
			                case "INVSRCCOLOR":
			                case "SRCALPHA":
			                case "INVSRCALPHA":
			                case "DESTALPHA":
			                case "INVDESTALPHA":
			                case "DESTCOLOR":
			                case "INVDESTCOLOR":
			                case "SRCALPHASAT":
			                	break;

			                default:
			                    logger.setSourceLocation( "fx/Effect.ts" , 3793 ); logger.warning("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue + "."); ;
			                    return;
			            }
			            break;

			        case "CULLMODE":
			            switch (sValue) {
			                case "NONE":
			                case "CW":
			                case "CCW":
			                case "FRONT_AND_BACK":
			                    break;
			                default:
			                    logger.setSourceLocation( "fx/Effect.ts" , 3806 ); logger.warning("Unsupported render state SRCBLEND/DESTBLEND value used: " + sValue + "."); ;
			                    return;
			            }
			            break;

			        case "ZFUNC":
			            switch (sValue) {
			                case "NEVER":
			                case "LESS":
			                case "EQUAL":
			                case "LESSEQUAL":
			                case "GREATER":
			                case "NOTEQUAL":
			                case "GREATEREQUAL":
			                case "ALWAYS":
			                	break;
			                default:
			                    logger.setSourceLocation( "fx/Effect.ts" , 3824 ); logger.warning("Unsupported render state ZFUNC value used: " + sValue + ".");
                                          ;
			                   return;
			            }
			            break;
			    }

			    pPass.setState(sType, sValue);
        	}

        }

        private analyzePassStateIf(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var pIfExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	pIfExpr.prepareFor(EFunctionType.k_PassFunction);

        	pPass._addCodeFragment("if("+ pIfExpr.toFinalCode() + ")");

        	this.analyzePassStateBlock(pChildren[pChildren.length - 5], pPass);

        	if(pChildren.length > 5){
        		pPass._addCodeFragment("else");

        		if(pChildren[0].name === "PassStateBlock"){
        			this.analyzePassStateBlock(pChildren[0], pPass);
        		}
        		else {
        			pPass._addCodeFragment(" ");
        			this.analyzePassStateIf(pChildren[0], pPass);
        		}
        	}
        }

        private analyzePassStateSwitch(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var sCodeFragment: string = "switch";
        	var pSwitchExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 3]);
        	pSwitchExpr.prepareFor(EFunctionType.k_PassFunction);

        	pPass._addCodeFragment("(" + pSwitchExpr.toFinalCode() + ")");

        	this.analyzePassCaseBlock(pChildren[0], pPass);
        }

        private analyzePassCaseBlock(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	pPass._addCodeFragment("{");

        	for(var i:  number  = pChildren.length - 2; i >= 1; i--){
        		if(pChildren[i].name === "CaseState"){
        			this.analyzePassCaseState(pChildren[i], pPass);
        		}
        		else if(pChildren[i].name === "DefaultState"){
        			this.analyzePassDefault(pChildren[i], pPass);
        		}
        	}

        	pPass._addCodeFragment("}");
        }

        private analyzePassCaseState(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var pCaseStateExpr: IAFXExprInstruction = this.analyzeExpr(pChildren[pChildren.length - 2]);
        	pCaseStateExpr.prepareFor(EFunctionType.k_PassFunction);

        	pPass._addCodeFragment("case " + pCaseStateExpr.toFinalCode() + ": ");

        	for(var i:  number  = pChildren.length - 4; i >= 0; i--){
        		if(pChildren[i].name === "PassState"){
        			this.analyzePassStateForShader(pChildren[i], pPass);
        		}
        		else{
        			pPass._addCodeFragment(pChildren[i].value);
        		}
        	}
        }

        private analyzePassDefault(pNode: IParseNode, pPass: IAFXPassInstruction): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	pPass._addCodeFragment("default: ");

        	for(var i:  number  = pChildren.length - 3; i >= 0; i--){
        		if(pChildren[i].name === "PassState"){
        			this.analyzePassStateForShader(pChildren[i], pPass);
        		}
        		else {
        			pPass._addCodeFragment(pChildren[i].value);
        		}
        	}
        }

        private analyzeImportDecl(pNode: IParseNode, pTechnique?: IAFXTechniqueInstruction = null): void {
      		this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;
		    var sComponentName: string = this.analyzeComplexName(pChildren[pChildren.length - 2]);
		    var iShift:  number  = 0;

		    if(pChildren[0].name === "ExtOpt"){
		    	logger.setSourceLocation( "fx/Effect.ts" , 3938 ); logger.warning("We don`t suppor ext-commands for import"); ;
		    }
		    if (pChildren.length !== 2) {
		        iShift = this.analyzeShiftOpt(pChildren[0]);
		    }

		    var pComponent: IAFXComponent = this._pComposer.getComponentByName(sComponentName);
		    if (!pComponent) {
		        this._error( 2277 , { componentName: sComponentName });
		        return;
		    }

		    this.addComponent(pComponent, iShift, pTechnique);
        }

        private analyzeProvideDecl(pNode: IParseNode): void {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	if (pChildren.length === 2) {
		        this._sProvideNameSpace = this.analyzeComplexName(pChildren[0]);
		    }
		    else {
		        this._error( 2303 );
		        return;
		    }
        }

        private analyzeShiftOpt(pNode: IParseNode):  number  {
        	this.setAnalyzedNode(pNode);

        	var pChildren: IParseNode[] = pNode.children;

        	var iShift:  number  = < number ><any>(pChildren[0].value);

		    if (pChildren.length === 2) {
		        iShift *= 1;
		    }
		    else {
		        iShift *= -1;
		    }

		    return iShift;
        }

        private addComponent(pComponent: IAFXComponent, iShift:  number , pTechnique: IAFXTechniqueInstruction): void {
        	if(!isNull(pTechnique)){
        		pTechnique.addComponent(pComponent, iShift);
        	}
        	else {
        		if(isNull(this._pGlobalComponentList)){
        			this._pGlobalComponentList = [];
        			this._pGlobalComponetShiftList = [];
        		}

        		this._pGlobalComponentList.push(pComponent);
        		this._pGlobalComponetShiftList.push(iShift);
        	}

//TODO: add correct add of compnent, not global

        	var pComponentTechnique: IAFXTechniqueInstruction = pComponent.getTechnique();
        	if(this.isAddedTechnique(pComponentTechnique)){
        		return;
        	}

        	var pSharedListV: IAFXVariableDeclInstruction[] = pComponentTechnique.getSharedVariablesForVertex();
        	var pSharedListP: IAFXVariableDeclInstruction[] = pComponentTechnique.getSharedVariablesForPixel();

        	for(var i:  number  = 0; i < pSharedListV.length; i++){
        		this.addExternalSharedVariable(pSharedListV[i], EFunctionType.k_Vertex);
        	}

        	for(var i:  number  = 0; i < pSharedListP.length; i++){
        		this.addExternalSharedVariable(pSharedListP[i], EFunctionType.k_Pixel);
        	}

        	if(isNull(this._pAddedTechniqueList)){
        		this._pAddedTechniqueList = [];
        	}

        	this._pAddedTechniqueList.push(pTechnique);
        }

        private isAddedTechnique(pTechnique: IAFXTechniqueInstruction): bool {
        	if(isNull(this._pAddedTechniqueList)){
        		return false;
        	}

        	for(var i:  number  = 0; i < this._pAddedTechniqueList.length; i++){
        		if(this._pAddedTechniqueList[i] === pTechnique){
        			return true;
        		}
        	}

        	return false;
        }



/**
         * Проверят возможность использования оператора между двумя типами.
         * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
         * 
         * @sOperator {string} Один из операторов: + - * / % += -= *= /= %= = < > <= >= == != =
         * @pLeftType {IAFXVariableTypeInstruction} Тип левой части выражения
         * @pRightType {IAFXVariableTypeInstruction} Тип правой части выражения
         */

        private checkTwoOperandExprTypes(sOperator: string,
        								 pLeftType: IAFXVariableTypeInstruction,
        								 pRightType: IAFXVariableTypeInstruction): IAFXVariableTypeInstruction {
        	if(pLeftType._isUnverifiable()){
        		return pLeftType;
        	}

        	if(pRightType._isUnverifiable()){
        		return pRightType;
        	}

        	var isComplex: bool = pLeftType.isComplex() || pRightType.isComplex();
			var isArray: bool = pLeftType.isNotBaseArray() || pRightType.isNotBaseArray();
			var isSampler: bool = this.isSamplerType(pLeftType) || this.isSamplerType(pRightType);
        	var pBoolType: IAFXVariableTypeInstruction = Effect.getSystemType("bool").getVariableType();

        	if(isArray || isSampler) {
        		return null;
        	}

        	if(sOperator === "%" || sOperator === "%=") {
        		return null;
        	}

        	if(this.isAssignmentOperator(sOperator)){
        		if(!pLeftType.isWritable()){
        			this._error( 2267 );
        			return null;
        		}

        		if(pLeftType.isStrongEqual(Effect.getSystemType("ptr"))){
					this.addPointerForExtract(pLeftType._getParentVarDecl());
				}

        		if(!pRightType.isReadable()){
        			this._error( 2268 );
        			return null;
        		}

        		if(sOperator !== "=" && !pLeftType.isReadable()){
        			this._error( 2268 )
        		}
        	}
        	else {
        		if(!pLeftType.isReadable()){
        			this._error( 2268 );
        			return null;
        		}

        		if(!pRightType.isReadable()){
        			this._error( 2268 );
        			return null;
        		}
        	}

        	if(isComplex){
        		if(sOperator === "=" && pLeftType.isEqual(pRightType)){
        			return <IAFXVariableTypeInstruction>pLeftType;
        		}
        		else if(this.isEqualOperator(sOperator) && !pLeftType._containArray() && !pLeftType._containSampler()) {
        			return pBoolType;
        		}
        		else {
        			return null;
        		}
        	}

        	var pReturnType: IAFXVariableTypeInstruction = null;
        	var pLeftBaseType: IAFXVariableTypeInstruction = (<SystemTypeInstruction>pLeftType.getBaseType()).getVariableType();
        	var pRightBaseType: IAFXVariableTypeInstruction = (<SystemTypeInstruction>pRightType.getBaseType()).getVariableType();


        	if(pLeftType.isConst() && this.isAssignmentOperator(sOperator)){
        		return null;
        	}

        	if(pLeftType.isEqual(pRightType)){
        		if(this.isArithmeticalOperator(sOperator)){
        			if(!this.isMatrixType(pLeftType) || (sOperator !== "/" && sOperator !== "/=")){
        				return pLeftBaseType;
        			}
        			else {
        				return null;
        			}
        		}
        		else if(this.isRelationalOperator(sOperator)){
        			if(this.isScalarType(pLeftType)){
        				return pBoolType;
        			}
        			else {
        				return null;
        			}
        		}
        		else if(this.isEqualOperator(sOperator)){
        			return pBoolType;
        		}
        		else if(sOperator === "="){
        			return pLeftBaseType;
        		}
        		else {
        			return null;
        		}

        	}

        	if(this.isArithmeticalOperator(sOperator)){
        		if (this.isBoolBasedType(pLeftType) || this.isBoolBasedType(pRightType) ||
        		    this.isFloatBasedType(pLeftType) !== this.isFloatBasedType(pRightType) ||
        		    this.isIntBasedType(pLeftType) !== this.isIntBasedType(pRightType)) {
        			return null;
        		}

        		if(this.isScalarType(pLeftType)){
        			return pRightBaseType;
        		}

        		if(this.isScalarType(pRightType)){
        			return pLeftBaseType;
        		}

        		if(sOperator === "*" || sOperator === "*="){
        			if(this.isMatrixType(pLeftType) && this.isVectorType(pRightType) &&
        			   pLeftType.getLength() === pRightType.getLength()){
        				return pRightBaseType;
        			}
        			else if(this.isMatrixType(pRightType) && this.isVectorType(pLeftType) &&
        			   pLeftType.getLength() === pRightType.getLength()){
        				return pLeftBaseType;
        			}
        			else {
        				return null;
        			}
        		}
        	}

        	return null;
        }

/**
         * Проверят возможность использования оператора к типу данных.
         * Возращает тип получаемый в результате приминения опрератора, или, если применить его невозможно - null.
         * 
         * @sOperator {string} Один из операторов: + - ! ++ --
         * @pLeftType {IAFXVariableTypeInstruction} Тип операнда
         */

        private checkOneOperandExprType(sOperator: string,
        								pType: IAFXVariableTypeInstruction): IAFXVariableTypeInstruction {

        	if(pType._isUnverifiable()){
        		return pType;
        	}

        	var isComplex: bool = pType.isComplex();
			var isArray: bool = pType.isNotBaseArray();
			var isSampler: bool = this.isSamplerType(pType);

			if(isComplex || isArray || isSampler){
				return null;
			}

			if(!pType.isReadable()){
       			this._error( 2268 );
       			return null;
       		}


			if(sOperator === "++" || sOperator === "--"){
				if(!pType.isWritable()){
					this._error( 2267 );
					return null;
				}

				if(pType.isStrongEqual(Effect.getSystemType("ptr"))){
					this.addPointerForExtract(pType._getParentVarDecl());
				}

				return pType;
			}

        	if(sOperator === "!"){
        		var pBoolType: IAFXVariableTypeInstruction = Effect.getSystemType("bool").getVariableType();

        		if(pType.isEqual(pBoolType)){
        			return pBoolType;
        		}
        		else{
        			return null;
        		}
        	}
        	else {
        		if(this.isBoolBasedType(pType)){
        			return null;
        		}
        		else{
        			return (<SystemTypeInstruction>pType.getBaseType()).getVariableType();
        		}
        	}

//return null;
        }

        private isAssignmentOperator(sOperator: string): bool {
        	return sOperator === "+=" || sOperator === "-=" ||
        		   sOperator === "*=" || sOperator === "/=" ||
        		   sOperator === "%=" || sOperator === "=";
        }

        private isArithmeticalOperator(sOperator: string): bool{
        	return sOperator === "+" || sOperator === "+=" ||
        		   sOperator === "-" || sOperator === "-=" ||
        		   sOperator === "*" || sOperator === "*=" ||
        		   sOperator === "/" || sOperator === "/=";
        }

        private isRelationalOperator(sOperator: string): bool {
        	return sOperator === ">" || sOperator === ">=" ||
        		   sOperator === "<" || sOperator === "<=";
        }

        private isEqualOperator(sOperator: string): bool {
        	return sOperator === "==" || sOperator === "!=";
        }

        private isMatrixType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("float2x2")) ||
        		   pType.isEqual(Effect.getSystemType("float3x3")) ||
        		   pType.isEqual(Effect.getSystemType("float4x4")) ||
        		   pType.isEqual(Effect.getSystemType("int2x2")) ||
        		   pType.isEqual(Effect.getSystemType("int3x3")) ||
        		   pType.isEqual(Effect.getSystemType("int4x4")) ||
        		   pType.isEqual(Effect.getSystemType("bool2x2")) ||
        		   pType.isEqual(Effect.getSystemType("bool3x3")) ||
        		   pType.isEqual(Effect.getSystemType("bool4x4"));
        }

        private isVectorType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("float2")) ||
        		   pType.isEqual(Effect.getSystemType("float3")) ||
        		   pType.isEqual(Effect.getSystemType("float4")) ||
        		   pType.isEqual(Effect.getSystemType("bool2")) ||
        		   pType.isEqual(Effect.getSystemType("bool3")) ||
        		   pType.isEqual(Effect.getSystemType("bool4")) ||
        		   pType.isEqual(Effect.getSystemType("int2")) ||
        		   pType.isEqual(Effect.getSystemType("int3")) ||
        		   pType.isEqual(Effect.getSystemType("int4"));
        }

        private isScalarType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("bool")) ||
        		   pType.isEqual(Effect.getSystemType("int")) ||
        		   pType.isEqual(Effect.getSystemType("ptr")) ||
        		   pType.isEqual(Effect.getSystemType("float"));
        }

        private isFloatBasedType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("float")) ||
        		   pType.isEqual(Effect.getSystemType("float2")) ||
        		   pType.isEqual(Effect.getSystemType("float3")) ||
        		   pType.isEqual(Effect.getSystemType("float4")) ||
        		   pType.isEqual(Effect.getSystemType("float2x2")) ||
        		   pType.isEqual(Effect.getSystemType("float3x3")) ||
        		   pType.isEqual(Effect.getSystemType("float4x4")) ||
        		   pType.isEqual(Effect.getSystemType("ptr"));
        }

        private isIntBasedType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("int")) ||
        		   pType.isEqual(Effect.getSystemType("int2")) ||
        		   pType.isEqual(Effect.getSystemType("int3")) ||
        		   pType.isEqual(Effect.getSystemType("int4")) ||
        		   pType.isEqual(Effect.getSystemType("int2x2")) ||
        		   pType.isEqual(Effect.getSystemType("int3x3")) ||
        		   pType.isEqual(Effect.getSystemType("int4x4"));
        }

        private isBoolBasedType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("bool")) ||
        		   pType.isEqual(Effect.getSystemType("bool2")) ||
        		   pType.isEqual(Effect.getSystemType("bool3")) ||
        		   pType.isEqual(Effect.getSystemType("bool4")) ||
        		   pType.isEqual(Effect.getSystemType("bool2x2")) ||
        		   pType.isEqual(Effect.getSystemType("bool3x3")) ||
        		   pType.isEqual(Effect.getSystemType("bool4x4"));
        }

        private isSamplerType(pType: IAFXTypeInstruction): bool {
        	return pType.isEqual(Effect.getSystemType("sampler")) ||
    		   	   pType.isEqual(Effect.getSystemType("sampler2D")) ||
    		       pType.isEqual(Effect.getSystemType("samplerCUBE")) ||
    		       pType.isEqual(Effect.getSystemType("video_buffer"));
        }

        private addExtactionStmts(pStmt: IAFXStmtInstruction): void {
        	var pPointerList: IAFXVariableDeclInstruction[] = this.getPointerForExtractList();

        	for(var i:  number  = 0; i < pPointerList.length; i++) {
        		this.generateExtractStmtFromPointer(pPointerList[i], pStmt);
        	}

        	this.clearPointersForExtract();
        }

        private generateExtractStmtFromPointer(pPointer: IAFXVariableDeclInstruction, pParentStmt: IAFXStmtInstruction): IAFXStmtInstruction {
        	var pPointerType: IAFXVariableTypeInstruction = pPointer.getType();
        	var pWhatExtracted: IAFXVariableDeclInstruction = pPointerType._getDownPointer();
        	var pWhatExtractedType: IAFXVariableTypeInstruction = null;

        	var pFunction: IAFXFunctionDeclInstruction = this.getCurrentAnalyzedFunction();

        	while(!isNull(pWhatExtracted)){
        		pWhatExtractedType = pWhatExtracted.getType();

        		if(!pWhatExtractedType.isComplex()){
        			var pSingleExtract: ExtractStmtInstruction = new ExtractStmtInstruction();
        			pSingleExtract.generateStmtForBaseType(
        									pWhatExtracted,
        									pWhatExtractedType.getPointer(),
        									pWhatExtractedType.getVideoBuffer(), 0);

        			if(!pSingleExtract.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pSingleExtract.getLastError()); } ;

        			pParentStmt.push(pSingleExtract, true);

        			if(!isNull(pFunction)){
        				pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
        			}
        		}
        		else {
        			this.generateExtractStmtForComplexVar(
        									pWhatExtracted, pParentStmt,
        									pWhatExtractedType.getPointer(),
        									pWhatExtractedType.getVideoBuffer(), 0);
        		}

        		pWhatExtracted = pWhatExtractedType._getDownPointer();
        	}

        	return pParentStmt;
        }

        private generateExtractStmtForComplexVar(pVarDecl: IAFXVariableDeclInstruction,
        										 pParentStmt: IAFXStmtInstruction,
        										 pPointer: IAFXVariableDeclInstruction,
        										 pBuffer: IAFXVariableDeclInstruction,
        										 iPadding:  number ): void {
        	var pVarType: IAFXVariableTypeInstruction = pVarDecl.getType();
        	var pFieldNameList: string[] = pVarType.getFieldNameList();
        	var pField: IAFXVariableDeclInstruction = null;
        	var pFieldType: IAFXVariableTypeInstruction = null;
        	var pSingleExtract: ExtractStmtInstruction = null;

        	var pFunction: IAFXFunctionDeclInstruction = this.getCurrentAnalyzedFunction();

        	for(var i:  number  = 0; i < pFieldNameList.length; i++){
        		pField = pVarType.getField(pFieldNameList[i]);

        		if(isNull(pField)){
        			continue;
				}

 				pFieldType = pField.getType();

 				if(pFieldType.isPointer()){
 					var pFieldPointer: IAFXVariableDeclInstruction = pFieldType._getMainPointer();
 					pSingleExtract = new ExtractStmtInstruction();
 					pSingleExtract.generateStmtForBaseType(pFieldPointer, pPointer, pFieldType.getVideoBuffer(), iPadding + pFieldType.getPadding());

 					if(!pSingleExtract.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pSingleExtract.getLastError()); } ;

 					pParentStmt.push(pSingleExtract, true);
 					this.generateExtractStmtFromPointer(pFieldPointer, pParentStmt);

 					if(!isNull(pFunction)){
        				pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
        			}
 				}
 				else if(pFieldType.isComplex()) {
 					this.generateExtractStmtForComplexVar(pField, pParentStmt, pPointer, pBuffer, iPadding + pFieldType.getPadding());
 				}
 				else {
 					pSingleExtract = new ExtractStmtInstruction();
        			pSingleExtract.generateStmtForBaseType(pField, pPointer, pBuffer, iPadding + pFieldType.getPadding());

        			if(!pSingleExtract.check(ECheckStage.CODE_TARGET_SUPPORT)) { this._errorFromInstruction(pSingleExtract.getLastError()); } ;

        			pParentStmt.push(pSingleExtract, true);

        			if(!isNull(pFunction)){
        				pFunction._addUsedFunction(pSingleExtract.getExtractFunction());
        			}
 				}
 	       	}
        }


		private getNodeSourceLocation(pNode: IParseNode): {line:  number ; column:  number ;} {
			if(isDef(pNode.line)){
				return {line: pNode.line, column: pNode.start};
			}
			else{
				return this.getNodeSourceLocation(pNode.children[pNode.children.length - 1]);
			}
		}
	}
}

































module akra {
	export interface IAFXBlender {

//Component and component blend
		addComponentToBlend(pComponentBlend: IAFXComponentBlend,
						    pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentBlend;

		removeComponentFromBlend(pComponentBlend: IAFXComponentBlend,
								 pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentBlend;

		addBlendToBlend(pComponentBlend: IAFXComponentBlend,
						pAddBlend: IAFXComponentBlend, iShift:  number ): IAFXComponentBlend;

//Pass blend

		generatePassBlend(pPassList: IAFXPassInstruction[],
						  pStates: any, pForeigns: any, pUniforms: any): IAFXPassBlend;

		getPassBlendById(id:  number ): IAFXPassBlend;
	}
}















module akra.fx {
	export class VariableBlendContainer {

		private _pVarListMap: IAFXVariableDeclListMap = null;
		private _pVarKeys: string[] = null;

		private _pVarBlendTypeMap: IAFXVariableTypeMap = null;

		inline get keys(): string[] {
			return this._pVarKeys;
		}

		inline getVarList(sKey: string): IAFXVariableDeclInstruction[] {
			return this._pVarListMap[sKey];
		}

		inline getBlendType(sKey: string): IAFXVariableTypeInstruction {
			return this._pVarBlendTypeMap[sKey];
		}

		constructor() {
			this._pVarListMap = <IAFXVariableDeclListMap>{};
			this._pVarKeys = [];

			this._pVarBlendTypeMap = <IAFXVariableTypeMap>{};
		}

		addVariable(pVariable: IAFXVariableDeclInstruction, eBlendMode: EAFXBlendMode): bool {
			var sName: string = pVariable.getRealName();

			if(!isDef(this._pVarListMap[sName])){
				this._pVarListMap[sName] = [pVariable];
				this._pVarKeys.push(sName);

				this._pVarBlendTypeMap[sName] = pVariable.getType();

				return true;
			}

			var pBlendType: IAFXVariableTypeInstruction = this._pVarBlendTypeMap[sName].blend(pVariable.getType(), eBlendMode);
			if(isNull(pBlendType)){
				logger.setSourceLocation( "fx/PassBlend.ts" , 49 ); logger.error("Could not blend type for variable '" + sName + "'"); ;
				return false;
			}

			this._pVarListMap[sName].push(pVariable);
			this._pVarBlendTypeMap[sName] = pBlendType;

			return true;
		}
	}

	export class ComplexTypeBlendContainer {

		private _pTypeListMap: IAFXTypeMap = null;
		private _pTypeKeys: string[] = null;

		constructor() {
			this._pTypeListMap = <IAFXTypeMap>{};
			this._pTypeKeys = [];
		}

		addComplexType(pComplexType: IAFXTypeInstruction): bool {
			var sName: string = pComplexType.getRealName();

			if(!isDef(this._pTypeListMap[sName])){
				this._pTypeListMap[sName] = pComplexType;
				this._pTypeKeys.push(sName);

				return true;
			}

			var pBlendType: IAFXTypeInstruction = this._pTypeListMap[sName].blend(pComplexType, EAFXBlendMode.k_TypeDecl);
			if(isNull(pBlendType)){
				logger.setSourceLocation( "fx/PassBlend.ts" , 82 ); logger.error("Could not blend type declaration '" + sName + "'"); ;
				return false;
			}

			this._pTypeListMap[sName]= pBlendType;

			return true;
		}

		addFromVarConatiner(pContainer: VariableBlendContainer): bool {
			if(isNull(pContainer)){
				return true;
			}

			var pKeys: string[] = pContainer.keys;

			for(var i:  number  = 0; i < pKeys.length; i++){
				var pType: IAFXTypeInstruction = pContainer.getBlendType(pKeys[i]).getBaseType();

				if(pType.isComplex()){
					if(!this.addComplexType(pType)){
						return false;
					}
				}
			}

			return true;
		}
	}

	export class ExtSystemDataContainer {
		private _pExtSystemMacrosList: IAFXSimpleInstruction[] = null;
		private _pExtSystemTypeList: IAFXTypeDeclInstruction[] = null;
		private _pExtSystemFunctionList: IAFXFunctionDeclInstruction[] = null;

		constructor(){
			this._pExtSystemMacrosList = [];
			this._pExtSystemTypeList = [];
			this._pExtSystemFunctionList = [];
		}

		addFromFunction(pFunction: IAFXFunctionDeclInstruction): void {
			var pTypes = pFunction._getExtSystemTypeList();
			var pMacroses = pFunction._getExtSystemMacrosList();
			var pFunctions = pFunction._getExtSystemFunctionList();

			if(!isNull(pTypes)){
				for(var j:  number  = 0; j < pTypes.length; j++){
					if(this._pExtSystemTypeList.indexOf(pTypes[j]) === -1){
						this._pExtSystemTypeList.push(pTypes[j]);
					}
				}
			}

			if(!isNull(pMacroses)){
				for(var j:  number  = 0; j < pMacroses.length; j++){
					if(this._pExtSystemMacrosList.indexOf(pMacroses[j]) === -1){
						this._pExtSystemMacrosList.push(pMacroses[j]);
					}
				}
			}

			if(!isNull(pFunctions)){
				for(var j:  number  = 0; j < pFunctions.length; j++){
					if(this._pExtSystemFunctionList.indexOf(pFunctions[j]) === -1){
						this._pExtSystemFunctionList.push(pFunctions[j]);
					}
				}
			}
		}
	}

	export class PassBlend implements IAFXPassBlend {
		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } ;

		private _pComposer: IAFXComposer = null;

		private _pExtSystemDataV: ExtSystemDataContainer = null;
		private _pComplexTypeContainerV: ComplexTypeBlendContainer = null;
		private _pForeignContainerV: VariableBlendContainer = null;
		private _pUniformContainerV: VariableBlendContainer = null;
		private _pSharedContainerV: VariableBlendContainer = null;
		private _pGlobalContainerV: VariableBlendContainer = null;
		private _pAttributeContainerV: VariableBlendContainer = null;
		private _pVaryingContainerV: VariableBlendContainer = null;
		private _pVertexOutType: IAFXTypeInstruction = null;
		private _pUsedFunctionListV: IAFXFunctionDeclInstruction[] = null;

		private _pExtSystemDataP: ExtSystemDataContainer = null;
		private _pComplexTypeContainerP: ComplexTypeBlendContainer = null;
		private _pForeignContainerP: VariableBlendContainer = null;
		private _pUniformContainerP: VariableBlendContainer = null;
		private _pSharedContainerP: VariableBlendContainer = null;
		private _pGlobalContainerP: VariableBlendContainer = null;
		private _pVaryingContainerP: VariableBlendContainer = null;

		private _pUsedFunctionListP: IAFXFunctionDeclInstruction[] = null;

		private _hasEmptyVertex: bool = true;
		private _hasEmptyPixel: bool = true;

		constructor(pComposer: IAFXComposer){
			this._pComposer = pComposer;

			this._pExtSystemDataV = new ExtSystemDataContainer();
			this._pComplexTypeContainerV = new ComplexTypeBlendContainer();
			this._pForeignContainerV = new VariableBlendContainer();
			this._pUniformContainerV = new VariableBlendContainer();
			this._pSharedContainerV = new VariableBlendContainer();
			this._pGlobalContainerV = new VariableBlendContainer();
			this._pAttributeContainerV = new VariableBlendContainer();
			this._pVaryingContainerV = new VariableBlendContainer();
			this._pVertexOutType = Effect.getBaseVertexOutType();
			this._pUsedFunctionListV = [];

			this._pExtSystemDataP = new ExtSystemDataContainer();
			this._pComplexTypeContainerP = new ComplexTypeBlendContainer();
			this._pForeignContainerP = new VariableBlendContainer();
			this._pUniformContainerP = new VariableBlendContainer();
			this._pSharedContainerP = new VariableBlendContainer();
			this._pGlobalContainerP = new VariableBlendContainer();
			this._pVaryingContainerP = new VariableBlendContainer();
			this._pUsedFunctionListP = [];
		}

		initFromPassList(pPassList: IAFXPassInstruction[]): bool {
			for(var i:  number  = 0; i < pPassList.length; i++){
				if(!this.addPass(pPassList[i])) {
					return false;
				}
			}

			if(!this.finalizeBlend()){
				return false;
			}

			return true;
		}

		private finalizeBlend(): bool {
			if(!this.finalizeBlendForVertex()) {
				return false;
			}

			if(!this.finalizeBlendForPixel()) {
				return false;
			}

			return true;
		}

		private addPass(pPass: IAFXPassInstruction): bool {
			var pVertex: IAFXFunctionDeclInstruction = pPass.getVertexShader();
			var pPixel: IAFXFunctionDeclInstruction = pPass.getPixelShader();

			var pForeignMap: IAFXVariableDeclMap = null;
			var pGlobalMap: IAFXVariableDeclMap = null;
			var pSharedMap: IAFXVariableDeclMap = null;
			var pUniformMap: IAFXVariableDeclMap = null;
			var pAttributeMap: IAFXVariableDeclMap = null;
			var pVaryingMap: IAFXVariableDeclMap = null;
			var pComplexTypeMap: IAFXTypeMap = null;


			var pForeignKeys:  number [] = null;
			var pGlobalKeys:  number [] = null;
			var pSharedKeys:  number [] = null;
			var pUniformKeys:  number [] = null;
			var pAttributeKeys:  number [] = null;
			var pVaryingKeys:  number [] = null;
			var pComplexTypeKeys:  number [] = null;

			var pForeign: IAFXVariableDeclInstruction = null;
			var pGlobal: IAFXVariableDeclInstruction = null;
			var pShared: IAFXVariableDeclInstruction = null;
			var pUniform: IAFXVariableDeclInstruction = null;
			var pAttribute: IAFXVariableDeclInstruction = null;
			var pVarying: IAFXVariableDeclInstruction = null;
			var pComplexType: IAFXTypeInstruction = null;

			var pUsedFunctionList: IAFXFunctionDeclInstruction[] = null;
			var pUsedFunction: IAFXFunctionDeclInstruction = null;

			if(!isNull(pVertex)) {
				this._hasEmptyVertex = false;

//blend system data
				this._pExtSystemDataV.addFromFunction(pVertex);

//blend foreigns
				pForeignMap = pVertex._getForeignVariableMap();
				pForeignKeys = pVertex._getForeignVariableKeys();

				if(!isNull(pForeignKeys)){
					for(var i:  number  = 0; i < pForeignKeys.length; i++){
						pForeign = pForeignMap[pForeignKeys[i]];

						if(!this._pForeignContainerV.addVariable(pForeign, EAFXBlendMode.k_Foreign)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 280 ); logger.error("Could not add foreign variable"); ;
							return false;
						}
					}
				}

//blend globals
				pGlobalMap = pVertex._getGlobalVariableMap();
				pGlobalKeys = pVertex._getGlobalVariableKeys();

				if(!isNull(pGlobalKeys)){
					for(var i:  number  = 0; i < pGlobalKeys.length; i++){
						pGlobal = pGlobalMap[pGlobalKeys[i]];

						if(!this._pGlobalContainerV.addVariable(pGlobal, EAFXBlendMode.k_Global)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 295 ); logger.error("Could not add global variable"); ;
							return false;
						}
					}
				}

//blend shareds
				pSharedMap = pVertex._getSharedVariableMap();
				pSharedKeys = pVertex._getSharedVariableKeys();

				if(!isNull(pSharedKeys)){
					for(var i:  number  = 0; i < pSharedKeys.length; i++){
						pShared = pSharedMap[pSharedKeys[i]];

						if(!this._pSharedContainerV.addVariable(pShared, EAFXBlendMode.k_Shared)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 310 ); logger.error("Could not add shared variable"); ;
							return false;
						}
					}
				}

//TODO: blend uniforms
				pUniformMap = pVertex._getUniformVariableMap();
				pUniformKeys = pVertex._getUniformVariableKeys();

				if(!isNull(pUniformKeys)){
					for(var i:  number  = 0; i < pUniformKeys.length; i++){
						pUniform = pUniformMap[pUniformKeys[i]];

						if(isNull(pUniform)){
							continue;
						}

						if(!this._pUniformContainerV.addVariable(pUniform, EAFXBlendMode.k_Uniform)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 329 ); logger.error("Could not add uniform variable"); ;
							return false;
						}
					}
				}

//TODO: blend attributes
				pAttributeMap = pVertex._getAttributeVariableMap();
				pAttributeKeys = pVertex._getAttributeVariableKeys();

				if(!isNull(pAttributeKeys)){
					for(var i:  number  = 0; i < pAttributeKeys.length; i++){
						pAttribute = pAttributeMap[pAttributeKeys[i]];

						if(!this._pAttributeContainerV.addVariable(pAttribute, EAFXBlendMode.k_Attribute)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 344 ); logger.error("Could not add attribute variable"); ;
							return false;
						}
					}
				}

//TODO: blend varyings
				pVaryingMap = pVertex._getVaryingVariableMap();
				pVaryingKeys = pVertex._getVaryingVariableKeys();

				if(!isNull(pVaryingKeys)){
					for(var i:  number  = 0; i < pVaryingKeys.length; i++){
						pVarying = pVaryingMap[pVaryingKeys[i]];

						if(!this._pVaryingContainerV.addVariable(pVarying, EAFXBlendMode.k_Varying)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 359 ); logger.error("Could not add varying variable"); ;
							return false;
						}
					}
				}

//blend used type
				pComplexTypeMap = pVertex._getUsedComplexTypeMap();
				pComplexTypeKeys = pVertex._getUsedComplexTypeKeys();

				if(!isNull(pComplexTypeKeys)){
					for(var i:  number  = 0; i < pComplexTypeKeys.length; i++){
						pComplexType = pComplexTypeMap[pComplexTypeKeys[i]];

						if(!this._pComplexTypeContainerV.addComplexType(pComplexType)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 374 ); logger.error("Could not add type declaration"); ;
							return false;
						}
					}
				}

//blend used functions
				pUsedFunctionList = pVertex._getUsedFunctionList();

				if(!isNull(pUsedFunctionList)){
					for(var i:  number  = 0; i < pUsedFunctionList.length; i++) {
						pUsedFunction = pUsedFunctionList[i];

						if(this._pUsedFunctionListV.indexOf(pUsedFunction) === -1){
							this._pUsedFunctionListV.push(pUsedFunction);
						}
					}
				}

				var pVertexOut: IAFXTypeInstruction = pVertex.getReturnType().getBaseType();

				this._pVertexOutType = this._pVertexOutType.blend(pVertexOut, EAFXBlendMode.k_VertexOut);
			}

			if(!isNull(pPixel)) {
				this._hasEmptyPixel = false;
//blend system data
				this._pExtSystemDataP.addFromFunction(pPixel);

//blend foreigns
				pForeignMap = pPixel._getForeignVariableMap();
				pForeignKeys = pPixel._getForeignVariableKeys();

				if(!isNull(pForeignKeys)){
					for(var i:  number  = 0; i < pForeignKeys.length; i++){
						pForeign = pForeignMap[pForeignKeys[i]];

						if(!this._pForeignContainerP.addVariable(pForeign, EAFXBlendMode.k_Foreign)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 412 ); logger.error("Could not add foreign variable"); ;
							return false;
						}
					}
				}

//blend globals
				pGlobalMap = pPixel._getGlobalVariableMap();
				pGlobalKeys = pPixel._getGlobalVariableKeys();

				if(!isNull(pGlobalKeys)){
					for(var i:  number  = 0; i < pGlobalKeys.length; i++){
						pGlobal = pGlobalMap[pGlobalKeys[i]];

						if(!this._pGlobalContainerP.addVariable(pGlobal, EAFXBlendMode.k_Global)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 427 ); logger.error("Could not add global variable"); ;
							return false;
						}
					}
				}

//blend shareds
				pSharedMap = pPixel._getSharedVariableMap();
				pSharedKeys = pPixel._getSharedVariableKeys();

				if(!isNull(pSharedKeys)){
					for(var i:  number  = 0; i < pSharedKeys.length; i++){
						pShared = pSharedMap[pSharedKeys[i]];

						if(!this._pSharedContainerP.addVariable(pShared, EAFXBlendMode.k_Shared)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 442 ); logger.error("Could not add shared variable"); ;
							return false;
						}
					}
				}

//TODO: blend uniforms
				pUniformMap = pPixel._getUniformVariableMap();
				pUniformKeys = pPixel._getUniformVariableKeys();

				if(!isNull(pUniformKeys)){
					for(var i:  number  = 0; i < pUniformKeys.length; i++){
						pUniform = pUniformMap[pUniformKeys[i]];

						if(isNull(pUniform)){
							continue;
						}

						if(!this._pUniformContainerP.addVariable(pUniform, EAFXBlendMode.k_Uniform)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 461 ); logger.error("Could not add uniform variable"); ;
							return false;
						}
					}
				}

//TODO: blend varyings
				pVaryingMap = pPixel._getVaryingVariableMap();
				pVaryingKeys = pPixel._getVaryingVariableKeys();

				if(!isNull(pVaryingKeys)){
					for(var i:  number  = 0; i < pVaryingKeys.length; i++){
						pVarying = pVaryingMap[pVaryingKeys[i]];

						if(!this._pVaryingContainerP.addVariable(pVarying, EAFXBlendMode.k_Varying)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 476 ); logger.error("Could not add varying variable"); ;
							return false;
						}
					}
				}

//blend used type
				pComplexTypeMap = pPixel._getUsedComplexTypeMap();
				pComplexTypeKeys = pPixel._getUsedComplexTypeKeys();

				if(!isNull(pComplexTypeKeys)){
					for(var i:  number  = 0; i < pComplexTypeKeys.length; i++){
						pComplexType = pComplexTypeMap[pComplexTypeKeys[i]];

						if(!this._pComplexTypeContainerP.addComplexType(pComplexType)){
							logger.setSourceLocation( "fx/PassBlend.ts" , 491 ); logger.error("Could not add type declaration"); ;
							return false;
						}
					}
				}

//blend used functions
				pUsedFunctionList = pPixel._getUsedFunctionList();

				if(!isNull(pUsedFunctionList)){
					for(var i:  number  = 0; i < pUsedFunctionList.length; i++) {
						pUsedFunction = pUsedFunctionList[i];

						if(this._pUsedFunctionListP.indexOf(pUsedFunction) === -1){
							this._pUsedFunctionListP.push(pUsedFunction);
						}
					}
				}
			}

			return true;
		}

		private finalizeBlendForVertex(): bool {
			if(this._hasEmptyVertex){
				return true;
			}

			if(!this.finalizeComplexTypeFor(EFunctionType.k_Vertex)){
				return false;
			}

			return true;
		}

		private finalizeBlendForPixel(): bool {
			if(this._hasEmptyPixel){
				return true;
			}

			if(!this.finalizeComplexTypeFor(EFunctionType.k_Pixel)){
				return false;
			}

			return true;
		}

		private finalizeComplexTypeFor(eType: EFunctionType): bool {
			var pTypeContainer: ComplexTypeBlendContainer = null;

			var pUniformContainer: VariableBlendContainer = null;
			var pGlobalContainer: VariableBlendContainer = null;
			var pSharedContainer: VariableBlendContainer = null;
			var pUsedFunctions: IAFXFunctionDeclInstruction[] = null;

			var pAttributeContainer: VariableBlendContainer = null;


			if(eType === EFunctionType.k_Vertex){
				pTypeContainer = this._pComplexTypeContainerV;
				pUniformContainer = this._pUniformContainerV;
				pGlobalContainer = this._pGlobalContainerV;
				pSharedContainer = this._pSharedContainerV;
				pUsedFunctions = this._pUsedFunctionListV;
				pAttributeContainer = this._pAttributeContainerV;
			}
			else if(eType === EFunctionType.k_Pixel){
				pTypeContainer = this._pComplexTypeContainerP;
				pUniformContainer = this._pUniformContainerP;
				pGlobalContainer = this._pGlobalContainerP;
				pSharedContainer = this._pSharedContainerP;
				pUsedFunctions = this._pUsedFunctionListP;
			}

			if (!pTypeContainer.addFromVarConatiner(pUniformContainer) ||
				!pTypeContainer.addFromVarConatiner(pGlobalContainer) ||
				!pTypeContainer.addFromVarConatiner(pSharedContainer) ||
				!pTypeContainer.addFromVarConatiner(pAttributeContainer)){
				return false;
			}

			if(eType === EFunctionType.k_Vertex){
				pTypeContainer.addComplexType(this._pVertexOutType);
			}

			for(var i:  number  = 0; i < pUsedFunctions.length; i++){
				var pReturnBaseType: IAFXTypeInstruction = pUsedFunctions[i].getReturnType().getBaseType();
				if(pReturnBaseType.isComplex()){
					if(!pTypeContainer.addComplexType(pReturnBaseType)){
						return false;
					}
				}
			}

			return true;

		}



	}
}


















module akra.fx {

	export class PassInputBlend implements IAFXPassInputBlend {
		private _isFirstInit: bool = true;
		private _pCreator: IAFXComponentPassInputBlend = null;
		private _pHasUniformName: BoolMap = null;
		private _pHasForeignName: BoolMap = null;
		private _pHasTextureName: BoolMap = null;

		private _bNeedToCalcBlend: bool = false;
		private _bNeedToCalcShader: bool = false;

		private _iLastPassBlendId:  number  = 0;
		private _iLastShaderId:  number  = 0;

		uniforms: any = null;
		foreigns: any = null;
		textures: any = null;

		uniformsDefault: any = null;

		uniformKeys: string[] = null;
		foreignKeys: string[] = null;
		textureKeys: string[] = null;

		constructor(pCreator: IAFXComponentPassInputBlend){
			this._pCreator = pCreator;
		}

		setUniform(sName: string, pValue: any): void {
			if(!this._pHasUniformName[sName]){
				this._pHasUniformName[sName] = false;
				return;
			}

//Check type

			this.uniforms[sName] = pValue;
		}

		setForeign(sName: string, pValue: any): void {
			if(!this._pHasForeignName[sName]){
				this._pHasForeignName[sName] = false;
				return;
			}

//Check type

			var pOldValue: any = this.foreigns[sName];

			if(pOldValue !== pValue) {
				this._bNeedToCalcBlend = true;
				this._bNeedToCalcShader = true;
			}

			this.foreigns[sName] = pOldValue;
		}


		setTexture(sName: string, pValue: any): void {
			if(!this._pHasTextureName[sName]){
				this._pHasTextureName[sName] = false;
				return;
			}

//Check type

			this.textures[sName] = pValue;
		}

		setSamplerTexture(sName: string, pTexture: any): void{
			if(!this._pHasUniformName[sName]){
				this._pHasUniformName[sName] = false;
				return;
			}

			var pOldValue: any =  this.uniforms[sName].texture;

			if(pOldValue !== pTexture) {
				this._bNeedToCalcShader = true;
			}

			this.uniforms[sName].texture = pTexture;
		}

		_init(): void {
			if(this._isFirstInit){
// this.uniformKeys = Object.keys(this.uniforms);
// this.foreignKeys = Object.keys(this.foreigns);
// this.textureKeys = Object.keys(this.textures);

				this.uniforms = {};
				this.foreigns = {};
				this.textures = {};

				this._pHasUniformName = <BoolMap>{};
				this._pHasTextureName = <BoolMap>{};
				this._pHasForeignName = <BoolMap>{};

				for(var i:  number  = 0; i < this.uniformKeys.length; i++){
					this._pHasUniformName[this.uniformKeys[i]] = true;
					this.uniforms[this.uniformKeys[i]] = this.uniformsDefault[this.uniformKeys[i]];
				}

				for(var i:  number  = 0; i < this.foreignKeys.length; i++){
					this._pHasForeignName[this.foreignKeys[i]] = true;
					this.foreigns[this.foreignKeys[i]] = null;
				}

				for(var i:  number  = 0; i < this.textureKeys.length; i++){
					this._pHasTextureName[this.textureKeys[i]] = true;
					this.textures[this.textureKeys[i]] = null;
				}

				this._isFirstInit = false;
			}

			this._bNeedToCalcBlend = true;
			this._bNeedToCalcShader = true;
		}

		_release(): void {
			for(var i:  number  = 0; i < this.uniformKeys.length; i++){
				this.uniforms[this.uniformKeys[i]] = this.uniformsDefault[this.uniformKeys[i]];
			}

			for(var i:  number  = 0; i < this.foreignKeys.length; i++){
				this.foreigns[this.foreignKeys[i]] = null;
			}

			for(var i:  number  = 0; i < this.textureKeys.length; i++){
				this.textures[this.textureKeys[i]] = null;
			}

			this._pCreator.releasePassInput(this);
		}


		inline _isNeedToCalcBlend(): bool {
			return this._bNeedToCalcBlend;
		}

		inline _isNeedToCalcShader(): bool {
			return this._bNeedToCalcBlend || this._bNeedToCalcShader;
		}

		inline _getLastPassBlendId():  number  {
			return this._iLastPassBlendId;
		}

		inline _getLastShaderId():  number  {
			return this._iLastShaderId;
		}

		inline _setPassBlendId(id:  number ): void {
			this._iLastPassBlendId = id;
		}

		inline _setShaderId(id:  number ): void {
			this._iLastShaderId = id;
		}
	}
}



module akra.fx {
	export class ComponentBlend implements IAFXComponentBlend {
		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } ;
		private _pComposer: IAFXComposer = null;

		private _isReady: bool = false;
		private _sHash: string = "";
		private _bNeedToUpdateHash: bool = false;

		private _pComponentHashMap: BoolMap = null;

		private _pComponentList: IAFXComponent[] = null;
		private _pComponentShiftList:  number [] = null;
		private _pComponentPassIdList:  number [] = null;

		private _iShiftMin:  number  = 0;
		private _iShiftMax:  number  = 0;

		private _pPassesDList: IAFXPassInstruction[][] = null;
		private _pComponentInputVarBlend: ComponentPassInputBlend[] = null;

		constructor(pComposer: IAFXComposer){
			this._pComposer = pComposer;

			this._pComponentHashMap = <BoolMap>{};

			this._pComponentList = [];
			this._pComponentShiftList = [];
			this._pComponentPassIdList = [];
		}

		inline isReadyToUse(): bool {
			return this._isReady;
		}

		inline isEmpty(): bool {
			return this._pComponentList.length === 0;
		}

		inline getComponentCount():  number  {
			return this._pComponentList.length;
		}

		inline getTotalPasses():  number  {
			return !isNull(this._pPassesDList) ? this._pPassesDList.length : 0;
		}

		getHash(): string {
			if(this._bNeedToUpdateHash){
				this._sHash = this.calcHash();
				this._bNeedToUpdateHash = false;
			}

			return this._sHash;
		}

		inline containComponentWithShift(pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			return this.containComponentHash(pComponent.getHash(iShift, iPass));
		}

		inline containComponentHash(sComponentHash: string): bool {
			return (this._pComponentHashMap[sComponentHash]);
		}

		addComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): void {
			var sComponentHash: string = pComponent.getHash(iShift, iPass);
			var iPassCount:  number  = pComponent.getTotalPasses();

			if(iPass ===  0xffffff ) {

				for(var i:  number  = 0; i < iPassCount; i++){
					this.addComponent(pComponent, iShift + i, i);
				}

				return;
			}
			else if(iPass < 0 || iPass >= iPassCount){
				return;
			}

			var sComponentHash: string = pComponent.getHash(iShift, iPass);

			if(this.containComponentHash(sComponentHash)){
				logger.setSourceLocation( "fx/ComponentBlend.ts" , 93 ); logger.warning("You try to add already used component '" + sComponentHash + "' in blend."); ;
				return;
			}

			if(iShift < this._iShiftMin){
				this._iShiftMin = iShift;
			}

			if(iShift > this._iShiftMax){
				this._iShiftMax = iShift;
			}

			this._pComponentHashMap[sComponentHash] = true;
			this._pComponentList.push(pComponent);
			this._pComponentShiftList.push(iShift);
			this._pComponentPassIdList.push(iPass);

			this._isReady = false;
			this._bNeedToUpdateHash = true;

		}

		removeComponent(pComponent: IAFXComponent, iShift:  number , iPass:  number ): void {
			var sComponentHash: string = pComponent.getHash(iShift, iPass);
			var iPassCount:  number  = pComponent.getTotalPasses();

			if(!this.containComponentHash(sComponentHash)){
				logger.setSourceLocation( "fx/ComponentBlend.ts" , 120 ); logger.warning("You try to remove not used component '" + sComponentHash + "' from blend."); ;
				return;
			}

			if(iPass ===  0xffffff ) {
				for(var i:  number  = 0; i < iPassCount; i++){
					this.removeComponent(pComponent, iShift + i, i);
				}

				return;
			}
			else if(iPass < 0 || iPass >= iPassCount){
				return;
			}

			this._pComponentHashMap[sComponentHash] = false;

			for(var i:  number  = 0; i < this._pComponentList.length; i++){
				if (this._pComponentList[i] === pComponent &&
					this._pComponentShiftList[i] === iShift &&
					this._pComponentPassIdList[i] === iPass) {

					this._pComponentList.splice(i, 1);
					this._pComponentShiftList.splice(i, 1);
					this._pComponentPassIdList.splice(i, 1);
					break;
				}
			}

			if(this._iShiftMin === iShift && this._iShiftMax === iShift){
				this._iShiftMax = 0;
				this._iShiftMin = 0;

				for(var i:  number  = 0; i < this._pComponentShiftList.length; i++){
					if(this._pComponentShiftList[i] < this._iShiftMin){
						this._iShiftMin = this._pComponentShiftList[i];
					}

					if(this._pComponentShiftList[i] > this._iShiftMax){
						this._iShiftMax = this._pComponentShiftList[i];
					}
				}
			}

			this._isReady = false;
			this._bNeedToUpdateHash = true;
		}

		finalizeBlend(): bool {
			if(this._isReady){
				return true;
			}

			this._pPassesDList = [];
			this._pComponentInputVarBlend = [];

			for(var i:  number  = 0; i < this._pComponentList.length; i++){
				var pComponentTechnique: IAFXTechniqueInstruction = this._pComponentList[i].getTechnique();
				var iShift:  number  = this._pComponentShiftList[i] - this._iShiftMin;
				var iPass:  number  = this._pComponentPassIdList[i];

				var pPass: IAFXPassInstruction = pComponentTechnique.getPass(iPass);

				if(!isDef(this._pPassesDList[iShift])) {
					this._pPassesDList[iShift] = [];
					this._pComponentInputVarBlend[iShift] = new ComponentPassInputBlend();
				}

				this._pPassesDList[iShift].push(pPass);
				this._pComponentInputVarBlend[iShift].addDataFromPass(pPass);
			}

			for(var i:  number  = 0; i < this._pComponentInputVarBlend.length; i++){
				this._pComponentInputVarBlend[i].generateKeys();
			}

			this._isReady = true;

			return true;
		}

		getPassInputForPass(iPass:  number ): IAFXPassInputBlend {
			if(!this._isReady){
				return null;
			}

			if(iPass < 0 || iPass > this.getTotalPasses()){
				return null;
			}

			return this._pComponentInputVarBlend[iPass].getPassInput();
		}

		getPassListAtPass(iPass:  number ): IAFXPassInstruction[] {
			if(!this._isReady){
				return null;
			}

			if(iPass < 0 || iPass > this.getTotalPasses()){
				return null;
			}

			return this._pPassesDList[iPass];
		}

		clone(): IAFXComponentBlend {
			var pClone: IAFXComponentBlend = new ComponentBlend(this._pComposer);

			pClone._setDataForClone(this._pComponentList,
									this._pComponentShiftList,
									this._pComponentPassIdList,
									this._pComponentHashMap,
									this._iShiftMin, this._iShiftMax);
			return pClone;
		}

		inline _getComponentList(): IAFXComponent[] {
			return this._pComponentList;
		}

		inline _getComponentShiftList():  number [] {
			return this._pComponentShiftList;
		}

		inline _getComponentPassIdList():  number [] {
			return this._pComponentPassIdList;
		}

		_setDataForClone(pComponentList: IAFXComponent[],
						 pComponentShiftList:  number [],
						 pComponentPassNumnerList:  number [],
						 pComponentHashMap: BoolMap,
						 iShiftMin:  number , iShiftMax:  number ): void {

			for(var i:  number  = 0; i < pComponentList.length; i++){
				this._pComponentList.push(pComponentList[i]);
				this._pComponentShiftList.push(pComponentShiftList[i]);
				this._pComponentPassIdList.push(pComponentPassNumnerList[i]);

				var sComponentHash: string = pComponentList[i].getHash(pComponentShiftList[i], pComponentPassNumnerList[i]);

				this._pComponentHashMap[sComponentHash] = pComponentHashMap[sComponentHash];
			}

			this._iShiftMin = iShiftMin;
			this._iShiftMax = iShiftMax;
			this._bNeedToUpdateHash = true;
		}

		private calcHash(): string {
			var sHash: string = "";

			if(this.isEmpty()) {
				return  "EMPTY_BLEND" ;
			}

			for(var i:  number  = 0; i < this._pComponentList.length; i++){
				var sComponentHash: string = this._pComponentList[i].getHash(this._pComponentShiftList[i],
																			 this._pComponentPassIdList[i]);
				sHash += sComponentHash + ":";
			}

			return sHash;
		}
	}

	export class ComponentPassInputBlend implements IAFXComponentPassInputBlend {
		private _pUniformNameToRealMap: StringMap = null;
		private _pUniformByRealNameMap: IAFXVariableDeclMap = null;
		private _pUniformDefaultValueMap: any = null;

		private _pTextureNameToRealMap: StringMap = null;
		private _pTextureByRealNameMap: IAFXVariableDeclMap = null;

		private _pForeignByNameMap: IAFXVariableDeclMap = null;


		private _pUniformRealNameList: string[] = null;
		private _pUniformNameList: string[] = null;

		private _pTextureRealNameList: string[] = null;
		private _pTextureNameList: string[] = null;

		private _pForeignNameList: string[] = null;

		private _pFreePassInputBlendList: IAFXPassInputBlend[] = null;

		inline get uniformNameToReal(): StringMap{
			return this._pUniformNameToRealMap;
		}

		inline get uniformByRealName(): IAFXVariableDeclMap{
			return this._pUniformByRealNameMap;
		}

		inline get uniformDefaultValue(): any {
			return this._pUniformDefaultValueMap;
		}

		inline get textureNameToReal(): StringMap {
			return this._pTextureNameToRealMap;
		}

		inline get textureByRealName(): IAFXVariableDeclMap {
			return this._pTextureByRealNameMap;
		}

		inline get foreignByName(): IAFXVariableDeclMap {
			return this._pForeignByNameMap;
		}

		inline get uniformNameList(): string[] {
			return this._pUniformNameList;
		}

		inline get uniformRealNameList(): string[] {
			return this._pUniformRealNameList;
		}

		inline get textureNameList(): string[] {
			return this._pTextureNameList;
		}

		inline get textureRealNameList(): string[] {
			return this._pTextureRealNameList;
		}

		inline get foreignNameList(): string[] {
			return this._pForeignNameList;
		}

		constructor() {
			this._pUniformNameToRealMap = <StringMap>{};
			this._pUniformByRealNameMap = <IAFXVariableDeclMap>{};
			this._pUniformDefaultValueMap = <any>{};

			this._pTextureNameToRealMap = <StringMap>{};
			this._pTextureByRealNameMap = <IAFXVariableDeclMap><any>{
				TEXTURE0  : null,
                TEXTURE1  : null,
                TEXTURE2  : null,
                TEXTURE3  : null,
                TEXTURE4  : null,
                TEXTURE5  : null,
                TEXTURE6  : null,
                TEXTURE7  : null,
                TEXTURE8  : null,
                TEXTURE9  : null,
                TEXTURE10 : null,
                TEXTURE11 : null,
                TEXTURE12 : null,
                TEXTURE13 : null,
                TEXTURE14 : null,
                TEXTURE15 : null
			};

			this._pForeignByNameMap = <IAFXVariableDeclMap>{};
		}

		addDataFromPass(pPass: IAFXPassInstruction): void {
			var pUniformMap: IAFXVariableDeclMap = pPass._getFullUniformMap();
			var pForeignMap: IAFXVariableDeclMap = pPass._getFullForeignMap();
			var pTextureMap: IAFXVariableDeclMap = pPass._getFullTextureMap();

			var pVar: IAFXVariableDeclInstruction = null;

			for(var i in pForeignMap){
				pVar = pForeignMap[i];

				this._pForeignByNameMap[pVar.getName()] = pVar;
			}

			for(var i in pTextureMap){
				pVar = pTextureMap[i];

				this._pTextureNameToRealMap[pVar.getName()] = pVar.getRealName();
				this._pTextureByRealNameMap[pVar.getRealName()] = pVar;
			}

			for(var i in pUniformMap){
				pVar = pUniformMap[i];

				this.addUniformVariable(pVar, "", "");
			}

		}

		generateKeys(): void {
			this._pUniformNameList = Object.keys(this._pUniformNameToRealMap);
			this._pUniformRealNameList = Object.keys(this._pUniformByRealNameMap);

			this._pTextureNameList = Object.keys(this._pTextureNameToRealMap);
			this._pTextureRealNameList = Object.keys(this._pTextureByRealNameMap);

			this._pForeignNameList = Object.keys(this._pForeignByNameMap);

			this._pFreePassInputBlendList = [];

			this.generateNewPassInputs();
		}

		getPassInput(): IAFXPassInputBlend {
			if(this._pFreePassInputBlendList.length === 0){
				this.generateNewPassInputs();
			}

			return this._pFreePassInputBlendList.pop();
		}

		releasePassInput(pInput: IAFXPassInputBlend) : void {
			this._pFreePassInputBlendList.push(pInput);
		}

		private addUniformVariable(pVariable: IAFXVariableDeclInstruction,
								   sPrevName: string, sPrevRealName: string): void {
			var sName: string = "";
			var sRealName: string = "";

			if(sPrevName !== ""){
				sName = sPrevName + "." + pVariable.getName();
			}
			else {
				sName = pVariable.getName();
			}

			if(sPrevRealName !== ""){
				sRealName = sPrevRealName + "." + pVariable.getRealName();
			}
			else {
				sRealName = pVariable.getRealName();
			}

			var pHasVar: IAFXVariableDeclInstruction = this._pUniformByRealNameMap[sRealName];

			if(isDef(pHasVar) && !pHasVar.getType().isEqual(pVariable.getType())){
				logger.setSourceLocation( "fx/ComponentBlend.ts" , 455 ); logger.warning("You used uniforms with the same real-names. Now we don`t work very well with that."); ;
				return;
			}

			var pVariableType: IAFXVariableTypeInstruction = pVariable.getType();

			if(!pVariableType.isComplex()){
				this._pUniformNameToRealMap[sName] = sRealName;
				this._pUniformByRealNameMap[sRealName] = pVariable;
				this._pUniformDefaultValueMap[sRealName] = pVariable.getDefaultValue();
			}
			else {
				var pFieldNameList: string[] = pVariableType.getFieldNameList();

				for(var i:  number  = 0; i < pFieldNameList.length; i++){
					this.addUniformVariable(pVariableType.getField(pFieldNameList[i]), sName, sRealName);
				}
			}
		}

		private generateNewPassInputs(nCount?:  number  = 5): void {
			for(var i:  number  = 0; i < nCount; i++) {
				var pPassInput: IAFXPassInputBlend = new PassInputBlend(this);

				pPassInput.uniformKeys = this._pUniformRealNameList;
				pPassInput.foreignKeys = this._pForeignNameList;
				pPassInput.textureKeys = this._pTextureRealNameList;

				pPassInput.uniformsDefault = this._pUniformDefaultValueMap;

				pPassInput._init();

				this._pFreePassInputBlendList.push(pPassInput);
			}
		}
	}

}



module akra.fx {
	export class Blender implements IAFXBlender {
		private _pComposer: IAFXComposer = null;


		private _pComponentBlendByHashMap: IAFXComponentBlendMap = null;

		private _pBlendWithComponentMap: IAFXComponentBlendMap = null;
		private _pBlendWithBlendMap: IAFXComponentBlendMap = null;

		private _pPassBlendByHashMap: IAFXPassBlendMap = null;
		private _pPassBlendByIdMap: IAFXPassBlendMap = null;

		constructor(pComposer: IAFXComposer) {
			this._pComposer = pComposer;

			this._pComponentBlendByHashMap = <IAFXComponentBlendMap>{};

			this._pBlendWithComponentMap = <IAFXComponentBlendMap>{};
			this._pBlendWithBlendMap = <IAFXComponentBlendMap>{};

			this._pPassBlendByHashMap = <IAFXPassBlendMap>{};
			this._pPassBlendByIdMap = <IAFXPassBlendMap>{};
		}

		addComponentToBlend(pComponentBlend: IAFXComponentBlend,
						    pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentBlend {

			var sBlendPartHash: string = isDefAndNotNull(pComponentBlend) ? pComponentBlend.getGuid().toString() : "";
			var sComponentPartHash: string = pComponent.getHash(iShift, iPass);
			var sShortHash: string = sBlendPartHash + "+" + sComponentPartHash;

			if(isDef(this._pBlendWithComponentMap[sShortHash])){
				return this._pBlendWithComponentMap[sShortHash];
			}

			var pNewBlend: IAFXComponentBlend = null;

			if(isNull(pComponentBlend)){
				pNewBlend = new ComponentBlend(this._pComposer);
			}
			else {
				pNewBlend = pComponentBlend.clone();
			}

			var pTechnique: IAFXTechniqueInstruction = pComponent.getTechnique();
			var pTechComponentList: IAFXComponent[] = pTechnique.getFullComponentList();
			var pTechComponentShiftList:  number [] = pTechnique.getFullComponentShiftList();

			if(iPass ===  0xffffff ) {
				if(!isNull(pTechComponentList)){
					for(var i:  number  = 0; i < pTechComponentList.length; i++){
						pNewBlend.addComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift,  0xffffff );
					}
				}

				pNewBlend.addComponent(pComponent, iShift,  0xffffff );
			}
			else {
				if(!isNull(pTechComponentList)){
					for(var i:  number  = 0; i < pTechComponentList.length; i++){
						pNewBlend.addComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, iPass - pTechComponentShiftList[i]);
					}
				}

				pNewBlend.addComponent(pComponent, iShift, iPass);
			}

			this._pBlendWithComponentMap[sShortHash] = pNewBlend;

			var sNewBlendHash: string = pNewBlend.getHash();

			if(isDef(this._pComponentBlendByHashMap[sNewBlendHash])){
				return this._pComponentBlendByHashMap[sNewBlendHash];
			}
			else {
				this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
			}

			return pNewBlend;
		}

		removeComponentFromBlend(pComponentBlend: IAFXComponentBlend,
								 pComponent: IAFXComponent, iShift:  number , iPass:  number ): IAFXComponentBlend {
			if(isNull(pComponentBlend)){
				logger.setSourceLocation( "fx/Blender.ts" , 95 ); logger.warning("You try to remove component '" + pComponent.getName() + "' with shift " + iShift.toString() + "from empty blend.");
                                                                ;
				return null;
			}

			var sBlendPartHash: string = isDefAndNotNull(pComponentBlend) ? pComponentBlend.getGuid().toString() : "";
			var sComponentPartHash: string = pComponent.getHash(iShift, iPass);
			var sShortHash: string = sBlendPartHash + "-" + sComponentPartHash;

			if(isDef(this._pBlendWithComponentMap[sShortHash])){
				return this._pBlendWithComponentMap[sShortHash];
			}

			if(!pComponentBlend.containComponentHash(sComponentPartHash)){
				logger.setSourceLocation( "fx/Blender.ts" , 109 ); logger.warning("You try to remove component '" + pComponent.getName() + "' with shift " + iShift.toString() + "from blend that not contain it.");
                                                                              ;
				return null;
			}

			var pNewBlend: IAFXComponentBlend = pComponentBlend.clone();

			var pTechnique: IAFXTechniqueInstruction = pComponent.getTechnique();
			var pTechComponentList: IAFXComponent[] = pTechnique.getFullComponentList();
			var pTechComponentShiftList:  number [] = pTechnique.getFullComponentShiftList();

			if(iPass ===  0xffffff ) {
				if(!isNull(pTechComponentList)){
					for(var i:  number  = 0; i < pTechComponentList.length; i++){
						pNewBlend.removeComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift,  0xffffff );
					}
				}

				pNewBlend.removeComponent(pComponent, iShift,  0xffffff );
			}
			else {
				if(!isNull(pTechComponentList)){
					for(var i:  number  = 0; i < pTechComponentList.length; i++){
						pNewBlend.removeComponent(pTechComponentList[i], pTechComponentShiftList[i] + iShift, iPass - pTechComponentShiftList[i]);
					}
				}

				pNewBlend.removeComponent(pComponent, iShift, iPass);
			}

			this._pBlendWithComponentMap[sShortHash] = pNewBlend;

			var sNewBlendHash: string = pNewBlend.getHash();

			if(isDef(this._pComponentBlendByHashMap[sNewBlendHash])){
				return this._pComponentBlendByHashMap[sNewBlendHash];
			}
			else {
				this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
			}

			return pNewBlend;
		}

		addBlendToBlend(pComponentBlend: IAFXComponentBlend,
						pAddBlend: IAFXComponentBlend, iShift:  number ): IAFXComponentBlend {

			if(isNull(pComponentBlend)){
				return pAddBlend;
			}

			if(isNull(pAddBlend)){
				return pComponentBlend;
			}

			var sShortHash: string = pComponentBlend.getGuid().toString() + "+" + pAddBlend.getGuid().toString();
			if(isDef(this._pBlendWithBlendMap[sShortHash])){
				return this._pBlendWithBlendMap[sShortHash];
			}

			var pNewBlend: IAFXComponentBlend = pComponentBlend.clone();

			var pAddComponentList: IAFXComponent[] = pAddBlend._getComponentList();
			var pAddComponentShiftList:  number [] = pAddBlend._getComponentShiftList();
			var pAddComponentPassIdList:  number [] = pAddBlend._getComponentPassIdList();

			for(var i:  number  = 0; i < pAddComponentList.length; i++){
				pNewBlend.addComponent(pAddComponentList[i],
									   pAddComponentShiftList[i] + iShift,
									   pAddComponentPassIdList[i]);
			}

			this._pBlendWithBlendMap[sShortHash] = pNewBlend;

			var sNewBlendHash: string = pNewBlend.getHash();

			if(isDef(this._pComponentBlendByHashMap[sNewBlendHash])){
				return this._pComponentBlendByHashMap[sNewBlendHash];
			}
			else {
				this._pComponentBlendByHashMap[sNewBlendHash] = pNewBlend;
			}

			return pNewBlend;
		}


		generatePassBlend(pPassList: IAFXPassInstruction[],
						  pStates: any, pForeigns: any, pUniforms: any): IAFXPassBlend {
			var sPassBlendHash: string = "";

			for(var i:  number  = 0; i < pPassList.length; i++) {
				var pPass: IAFXPassInstruction = pPassList[i];

				pPass.evaluate({ mesh : { isSkinning : true } }, null, null);

				var pVertexShader: IAFXFunctionDeclInstruction = pPass.getVertexShader();
				var pPixelShader: IAFXFunctionDeclInstruction = pPass.getPixelShader();

				if(!isNull(pVertexShader)){
					sPassBlendHash += pVertexShader.getGuid().toString() + ":";
				}
				else {
					sPassBlendHash += "E:";
				}

				if(!isNull(pPixelShader)){
					sPassBlendHash += pPixelShader.getGuid().toString() + ":";
				}
				else {
					sPassBlendHash += "E:";
				}
			}

			if(isDef(this._pPassBlendByHashMap[sPassBlendHash])){
				return this._pPassBlendByHashMap[sPassBlendHash];
			}

			var pNewPassBlend: IAFXPassBlend = new PassBlend(this._pComposer);
			var isOk: bool = pNewPassBlend.initFromPassList(pPassList);

			if(!isOk){
				return null;
			}

			this._pPassBlendByHashMap[sPassBlendHash] = pNewPassBlend;
			this._pPassBlendByIdMap[pNewPassBlend.getGuid()] = pNewPassBlend;

			return pNewPassBlend;
		}

		inline getPassBlendById(id:  number ): IAFXPassBlend {
			return this._pPassBlendByIdMap[id] || null;
		}
	}
}







module akra {
	export interface IAFXShaderProgram {

	}
}







module akra.fx {

	export interface IPreRenderState {
		isClear: bool;

		primType: EPrimitiveTypes;
		offset:  number ;
		length:  number ;
		index: IIndexData;
//flows: IDataFlow[];
		flows: ObjectArray;
	}

	export class Composer implements IAFXComposer {
		private _pEngine: IEngine = null;

		private _pTechniqueToBlendMap: IAFXComponentBlendMap = null;
		private _pTechniqueToOwnBlendMap: IAFXComponentBlendMap = null;
		private _pTechniqueLastGlobalBlendMap: IAFXComponentBlendMap = null;
		private _pTechniqueNeedUpdateMap: BoolMap = null;

		private _pEffectResourceToComponentBlendMap: IAFXComponentBlendMap = null;
		private _pBlender: IAFXBlender = null;

		private _pGlobalEffectResorceIdStack:  number [] = null;
// private _pGlobalEffectResorceShiftStack: int[] = null;
		private _pGlobalComponentBlendStack: IAFXComponentBlend[] = null;
		private _pGlobalComponentBlend: IAFXComponentBlend = null;

//Data for render
		private _pCurrentSceneObject: ISceneObject = null;
		private _pPreRenderState: IPreRenderState = null;

//Temporary objects for fast work

		constructor(pEngine: IEngine){
			this._pEngine = pEngine;

			this._pBlender = new Blender(this);

			this._pTechniqueToBlendMap = <IAFXComponentBlendMap>{};
			this._pTechniqueToOwnBlendMap = <IAFXComponentBlendMap>{};
			this._pTechniqueLastGlobalBlendMap = <IAFXComponentBlendMap>{};
			this._pTechniqueNeedUpdateMap = <BoolMap>{};

			this._pEffectResourceToComponentBlendMap = <IAFXComponentBlendMap>{};

			this._pGlobalEffectResorceIdStack = [];
// this._pGlobalEffectResorceShiftStack = [];
			this._pGlobalComponentBlendStack = [];
			this._pGlobalComponentBlend = null;

			this._pPreRenderState = {
				isClear: true,

				primType: 0,
				offset: 0,
				length: 0,
				index: null,
				flows: new ObjectArray()
			};
// this._pTempPassInstructionList = new ObjectArray();
		}

		getComponentByName(sComponentName: string): IAFXComponent {
			return <IAFXComponent>this._pEngine.getResourceManager().componentPool.findResource(sComponentName);
		}

		inline getEngine(): IEngine {
			return this._pEngine;
		}

//-----------------------------------------------------------------------------//
//-----------------------------API for Effect-resource-------------------------//
//-----------------------------------------------------------------------------//

		getComponentCountForEffect(pEffectResource: IEffect):  number  {
			var id:  number  = pEffectResource.resourceHandle;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])) {
				return this._pEffectResourceToComponentBlendMap[id].getComponentCount();
			}
			else {
				return 0;
			}
		}

		getTotalPassesForEffect(pEffectResource: IEffect):  number  {
			var id:  number  = pEffectResource.resourceHandle;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])) {
				return this._pEffectResourceToComponentBlendMap[id].getTotalPasses();
			}
			else {
				return 0;
			}
		}

		addComponentToEffect(pEffectResource: IEffect, pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])){
				pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
			}

			var pNewBlend: IAFXComponentBlend = this._pBlender.addComponentToBlend(pCurrentBlend, pComponent, iShift, iPass);
			if(isNull(pNewBlend)){
				return false;
			}

			this._pEffectResourceToComponentBlendMap[id] = pNewBlend;
			return true;
		}

		removeComponentFromEffect(pEffectResource: IEffect, pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pEffectResourceToComponentBlendMap[id])){
				pCurrentBlend = this._pEffectResourceToComponentBlendMap[id];
			}

			var pNewBlend: IAFXComponentBlend = this._pBlender.removeComponentFromBlend(pCurrentBlend, pComponent, iShift, iPass);
			if(isNull(pNewBlend)){
				return false;
			}

			this._pEffectResourceToComponentBlendMap[id] = pNewBlend;
			return true;
		}

		activateEffectResource(pEffectResource: IEffect, iShift:  number ): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var pComponentBlend: IAFXComponentBlend = this._pEffectResourceToComponentBlendMap[id];

			if(!isDef(pComponentBlend)){
				return false
			}

			var pNewGlobalBlend: IAFXComponentBlend = null;

			if(isNull(this._pGlobalComponentBlend)){
				pNewGlobalBlend = pComponentBlend;
			}
			else {
				pNewGlobalBlend = this._pBlender.addBlendToBlend(this._pGlobalComponentBlend, pComponentBlend, iShift);
			}

			if(isNull(pNewGlobalBlend)){
				return false;
			}

			this._pGlobalEffectResorceIdStack.push(id);
			this._pGlobalComponentBlendStack.push(pNewGlobalBlend);

			this._pGlobalComponentBlend = pNewGlobalBlend;

			return true;
		}

		deactivateEffectResource(pEffectResource: IEffect): bool {
			var id:  number  = pEffectResource.resourceHandle;
			var iStackLength:  number  = this._pGlobalEffectResorceIdStack.length;

			if(iStackLength === 0){
				return false;
			}

			var iLastId:  number  = this._pGlobalEffectResorceIdStack[iStackLength - 1];

			if(iLastId !== id){
				return false;
			}

			this._pGlobalEffectResorceIdStack.splice(iStackLength - 1, 1);
			this._pGlobalComponentBlendStack.splice(iStackLength - 1, 1);

			if(iStackLength > 1){
				this._pGlobalComponentBlend = this._pGlobalComponentBlendStack[iStackLength - 2];
			}
			else {
				this._pGlobalComponentBlend = null;
			}

			return true;
		}


//-----------------------------------------------------------------------------//
//----------------------------API for RenderTechnique--------------------------//
//-----------------------------------------------------------------------------//

		getTotalPassesForTechnique(pRenderTechnique: IRenderTechnique):  number  {
			this.prepareTechniqueBlend(pRenderTechnique);

			var id:  number  = pRenderTechnique.getGuid();

			if(isDefAndNotNull(this._pTechniqueToBlendMap[id])) {
				return this._pTechniqueToBlendMap[id].getTotalPasses();
			}
			else {
				return 0;
			}
		}

		addOwnComponentToTechnique(pRenderTechnique: IRenderTechnique,
								   pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pRenderTechnique.getGuid();
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pTechniqueToOwnBlendMap[id])){
				pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
			}

			var pNewBlend: IAFXComponentBlend = this._pBlender.addComponentToBlend(pCurrentBlend, pComponent, iShift, iPass);

			if(isNull(pNewBlend)){
				return false;
			}

			this._pTechniqueToOwnBlendMap[id] = pNewBlend;
			this._pTechniqueNeedUpdateMap[id] = true;

			return true;
		}

		removeOwnComponentToTechnique(pRenderTechnique: IRenderTechnique,
									  pComponent: IAFXComponent, iShift:  number , iPass:  number ): bool {
			var id:  number  = pRenderTechnique.getGuid();
			var pCurrentBlend: IAFXComponentBlend = null;

			if(isDef(this._pTechniqueToOwnBlendMap[id])){
				pCurrentBlend = this._pTechniqueToOwnBlendMap[id];
			}

			var pNewBlend: IAFXComponentBlend = this._pBlender.removeComponentFromBlend(pCurrentBlend, pComponent, iShift, iPass);
			if(isNull(pNewBlend)){
				return false;
			}

			this._pTechniqueToOwnBlendMap[id] = pNewBlend;
			this._pTechniqueNeedUpdateMap[id] = true;
			return true;
		}

		prepareTechniqueBlend(pRenderTechnique: IRenderTechnique): bool {
			if(pRenderTechnique.isFreeze()){
				return true;
			}

			var id:  number  = pRenderTechnique.getGuid();

			var isTechniqueUpdate: bool = !!(this._pTechniqueNeedUpdateMap[id]);
			var isUpdateGlobalBlend: bool = (this._pGlobalComponentBlend !== this._pTechniqueLastGlobalBlendMap[id]);
			var isNeedToUpdatePasses: bool = false;

			if(isTechniqueUpdate || isUpdateGlobalBlend){
				var iEffect:  number  = pRenderTechnique.getMethod().effect.resourceHandle;
				var pEffectBlend: IAFXComponentBlend = this._pEffectResourceToComponentBlendMap[iEffect] || null;
				var pTechniqueBlend: IAFXComponentBlend = this._pTechniqueToOwnBlendMap[id] || null;

				var pNewBlend: IAFXComponentBlend = null;

				pNewBlend = this._pBlender.addBlendToBlend(this._pGlobalComponentBlend, pEffectBlend, 0);
				pNewBlend = this._pBlender.addBlendToBlend(pNewBlend, pTechniqueBlend, 0);

				if(this._pTechniqueToBlendMap[id] !== pNewBlend){
					isNeedToUpdatePasses = true;
				}

				this._pTechniqueToBlendMap[id] = pNewBlend;
				this._pTechniqueNeedUpdateMap[id] = false;
				this._pTechniqueLastGlobalBlendMap[id] = this._pGlobalComponentBlend;
			}

			var pBlend: IAFXComponentBlend = this._pTechniqueToBlendMap[id];

			if(isDefAndNotNull(pBlend)) {
				if(!pBlend.isReadyToUse()){
					isNeedToUpdatePasses = true;
				}

				if(!pBlend.finalizeBlend()){
					return false;
				}

				if(isNeedToUpdatePasses) {
					pRenderTechnique.updatePasses(isTechniqueUpdate);
				}
			}
			else {
				return false;
			}
		}

		markTechniqueAsNeedUpdate(pRenderTechnique: IRenderTechnique): void {
			this._pTechniqueNeedUpdateMap[pRenderTechnique.getGuid()] = true;
		}

		getPassInputBlend(pRenderTechnique: IRenderTechnique, iPass:  number ): IAFXPassInputBlend {
			var id:  number  = pRenderTechnique.getGuid();

			if(!isDef(this._pTechniqueToBlendMap[id])){
				return null;
			}

			return this._pTechniqueToBlendMap[id].getPassInputForPass(iPass);
		}


//-----------------------------------------------------------------------------//
//---------------------------------API for render------------------------------//
//-----------------------------------------------------------------------------//

		applyBufferMap(pBufferMap: BufferMap): bool {
			var pState: IPreRenderState = this._pPreRenderState;

			if(pState.isClear){
				pState.primType = pBufferMap.primType;
				pState.offset = pBufferMap.offset;
				pState.length = pBufferMap.length;
				pState.index = pBufferMap.index;
			}
			else if(pState.primType !== pBufferMap.primType ||
					pState.offset !== pBufferMap.offset ||
					pState.length !== pBufferMap.length ||
					pState.index !== pBufferMap.index) {

				logger.setSourceLocation( "fx/Composer.ts" , 354 ); logger.error("Could not blend buffer maps"); ;
				return false;
			}

			var pFlows: IDataFlow[] = BufferMap.flows;

			for(var i:  number  = 0; i < pFlows.length; i++){
				pState.flows.push(pFlows[i]);
			}

			pState.isClear = false;
		}

		setCurrentSceneObject(pSceneObject: ISceneObject): void {
			this._pCurrentSceneObject = pSceneObject;
		}

		renderTechniquePass(pRenderTechnique: IRenderTechnique, iPass:  number ): void {
			var pPass: IRenderPass = pRenderTechnique.getPass(iPass);
			var pPassInput: IAFXPassInputBlend = pPass.getPassInput();

			var pPassBlend: IAFXPassBlend = null;
			var pShader: IAFXShaderProgram = null;

			if(!pPassInput._isNeedToCalcShader()){
//TODO: set pShader to shader program by id
			}
			else {
				if(!pPassInput._isNeedToCalcBlend()){
					pPassBlend = this._pBlender.getPassBlendById(pPassInput._getLastPassBlendId());
				}
				else {
					var id:  number  = pRenderTechnique.getGuid();
					var pComponentBlend: IAFXComponentBlend = this._pTechniqueToBlendMap[id];
					var pPassInstructionList: IAFXPassInstruction[] = pComponentBlend.getPassListAtPass(iPass);

					pPassBlend = this._pBlender.generatePassBlend(pPassInstructionList, null, null, null);
				}

				if(isNull(pPassBlend)){
					logger.setSourceLocation( "fx/Composer.ts" , 394 ); logger.error("Could not render. Error with generation pass-blend."); ;
					return;
				}

//TODO: generate additional shader params and get shader program
			}

//TODO: generate input from PassInputBlend to correct unifoms and attributes list
//TODO: generate RenderEntry
		}

//-----------------------------------------------------------------------------//
//-----------------------API for load components/AFXEffects--------------------//
//-----------------------------------------------------------------------------//


		_loadEffectFromSyntaxTree(pTree: IParseTree, sFileName: string): bool {
			var pEffect: IAFXEffect = new fx.Effect(this);
// LOG(sFileName, pTree);
			pEffect.setAnalyzedFileName(sFileName);
// LOG("\n\n\n-------------------------Try to analyze '" + sFileName + "'-------------");
			var isOk: bool = pEffect.analyze(pTree);

			if(isOk){
// LOG("------ANALYZE IS GOOD '" + sFileName + "'.")
				var pTechniqueList: IAFXTechniqueInstruction[] = pEffect.getTechniqueList();

				for(var i:  number  = 0; i < pTechniqueList.length; i++){
					isOk = this.initComponent(pTechniqueList[i]);
					if(!isOk){
						logger.setSourceLocation( "fx/Composer.ts" , 424 ); logger.warning("Cannot initialize fx-component from technique '" + pTechniqueList[i].getName() + "'."); ;
						return false;
					}
				}
			}
			else {
				logger.setSourceLocation( "fx/Composer.ts" , 430 ); logger.warning("Error are occured during analyze of effect file '" + sFileName + "'."); ;
				return false;
			}

			return true;
		}


		_loadEffectFromBinary(pData: Uint8Array, sFileName: string): bool {
			return false;
		}

		private initComponent(pTechnique: IAFXTechniqueInstruction): bool {
			var sTechniqueName: string = pTechnique.getName();
			var pComponentPool: IResourcePool = this._pEngine.getResourceManager().componentPool;

			if(!isNull(pComponentPool.findResource(sTechniqueName))){
				return false;
			}

			var pComponent: IAFXComponent = <IAFXComponent>pComponentPool.createResource(sTechniqueName);
			pComponent.create();
			pComponent.setTechnique(pTechnique);

			return true;
		}

		private clearPreRenderState(): void {
			this._pPreRenderState.primType = 0;
			this._pPreRenderState.offset = 0;
			this._pPreRenderState.length = 0;
			this._pPreRenderState.index = null;
			this._pPreRenderState.flows.clear(false);

			this._pPreRenderState.isClear = true;
		}
	}
}

























module akra {


	export interface IDDSCodec extends IImgCodec{

	}


}









//  DDS_header.dwFlags










//  DDS_header.ddspf.dwFlags




















//  DDS_header.dwCaps2









//DDS_header10.dwMiscFlag

















//  DD_Sheader.ddspf.dwFourCC























module akra
{

	interface IDDSPixelFormat{
		dwSize : number ;
        dwFlags : number ;
        dwFourCC : number ;
        dwRGBBitCount : number ;
        dwRBitMask : number ;
        dwGBitMask : number ;
        dwBBitMask : number ;
        dwABitMask : number ;
	}

	interface IDDSHeader{
		dwSize:  number ;
        dwFlags:  number ;
        dwHeight:  number ;
        dwWidth:  number ;
        dwPitchOrLinearSize:  number ;
        dwDepth:  number ;
        dwMipMapCount:  number ;
/*Count 11*/
        dwReserved1:  number [];

        ddspf:IDDSPixelFormat;

        dwCaps :  number ;
        dwCaps2 :  number ;
        dwCaps3 :  number ;
        dwCaps4 :  number ;
        dwReserved2 :  number ;
	}

	interface IDDSHeaderDXT10{
		dxgiFormat:  number ;
		resourceDimension: number ;
		miscFlag: number ;
		arraySize: number ;
		reserved: number ;
	}


	export class DDSCodec extends ImgCodec implements IDDSCodec
	{
		private _sType:string="dds";
		private static _pInstance:IDDSCodec=null;

		magicNumberToFileExt(pMagicNumber: Uint8Array):string
		{
			var dwMagic4: number  = (new Uint32Array(pMagicNumber.buffer, 0, 1))[0];
			if( 0x20534444 ==dwMagic4)
			{
				return "dds";
			}

			return null;
		}

/// Static method to startup and register the DDS codec
		static startup():void
		{
			if(!isDefAndNotNull(this._pInstance))
			{
				logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 164 ); logger.log("DDS codec registering"); ;
				this._pInstance=new DDSCodec();
				Codec.registerCodec(this._pInstance);
			}
		}
/// Static method to shutdown and unregister the DDS codec
		static shutdown():void
		{
			if(isDef(this._pInstance))
			{
				Codec.unRegisterCodec(this._pInstance);
				this._pInstance=undefined;
			}
		}

		getType():string
    	{
        	return this._sType;
    	}

    	decode(pData: Uint8Array, pImgData: IImgData):Uint8Array
    	{
    		var iOffset: number =0;
    		var dwMagic4: number  = (new Uint32Array(pData.buffer, 0, 1))[0];
    		if(dwMagic4!= 0x20534444 )
    		{
    			logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 190 ); logger.criticalError("This is not a DDS file! DDSCodec.decode"); ;
    		}
//Считываем dds header
/*typedef struct {
             DWORD           dwSize;
             DWORD           dwFlags;
             DWORD           dwHeight;
             DWORD           dwWidth;
             DWORD           dwPitchOrLinearSize;
             DWORD           dwDepth;
             DWORD           dwMipMapCount;
             DWORD           dwReserved1[11];
             DDS_PIXELFORMAT ddspf;
             DWORD           dwCaps;
             DWORD           dwCaps2;
             DWORD           dwCaps3;
             DWORD           dwCaps4;
             DWORD           dwReserved2;
             } DDS_HEADER;*/


    		var pDDSHeader:Uint32Array = new Uint32Array(pData.buffer, 4, 31);

    		var pHeader:IDDSHeader=<IDDSHeader>{};

    		pHeader.dwSize = pDDSHeader[0];
            pHeader.dwFlags = pDDSHeader[1];
            pHeader.dwHeight = pDDSHeader[2];
            pHeader.dwWidth = pDDSHeader[3];
            pHeader.dwPitchOrLinearSize = pDDSHeader[4];
            pHeader.dwDepth = pDDSHeader[5];
            pHeader.dwMipMapCount = pDDSHeader[6];
            pHeader.dwReserved1=[];
            pHeader.dwReserved1[0] = pDDSHeader[7];
            pHeader.dwReserved1[1] = pDDSHeader[8];
            pHeader.dwReserved1[2] = pDDSHeader[9];
            pHeader.dwReserved1[3] = pDDSHeader[10];
            pHeader.dwReserved1[4] = pDDSHeader[11];
            pHeader.dwReserved1[5] = pDDSHeader[12];
            pHeader.dwReserved1[6] = pDDSHeader[13];
            pHeader.dwReserved1[7] = pDDSHeader[14];
            pHeader.dwReserved1[8] = pDDSHeader[15];
            pHeader.dwReserved1[9] = pDDSHeader[16];
            pHeader.dwReserved1[10] = pDDSHeader[17];
/*struct DDS_PIXELFORMAT {
             DWORD dwSize;
             DWORD dwFlags;
             DWORD dwFourCC;
             DWORD dwRGBBitCount;
             DWORD dwRBitMask;
             DWORD dwGBitMask;
             DWORD dwBBitMask;
             DWORD dwABitMask;
             };*/

            pHeader.ddspf=<IDDSPixelFormat>{};
            pHeader.ddspf.dwSize = pDDSHeader[18];
            pHeader.ddspf.dwFlags = pDDSHeader[19];
            pHeader.ddspf.dwFourCC = pDDSHeader[20];
            pHeader.ddspf.dwRGBBitCount = pDDSHeader[21];
            pHeader.ddspf.dwRBitMask = pDDSHeader[22];
            pHeader.ddspf.dwGBitMask = pDDSHeader[23];
            pHeader.ddspf.dwBBitMask = pDDSHeader[24];
            pHeader.ddspf.dwABitMask = pDDSHeader[25];
            pHeader.dwCaps = pDDSHeader[26];
            pHeader.dwCaps2 = pDDSHeader[27];
            pHeader.dwCaps3 = pDDSHeader[28];
            pHeader.dwCaps4 = pDDSHeader[29];
            pHeader.dwReserved2 = pDDSHeader[30];
            iOffset += 128;
            if (pHeader.dwSize != 124) {
                    logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 259 ); logger.error("Размер заголовка DDS всегда должэен равняться 124"); ;
            }
            if(pHeader.ddspf.dwSize!= 32){
            	logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 262 ); logger.error("Размер DDS_PIXELFORMAT всегда должен равняться 32"); ;
            }
            if (!(pHeader.dwFlags &  0x00000001 )) {
                logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 265 ); logger.error("Флаг DDSD_CAPS в заголовке DDS всегда должен быть"); ;
            }
            if (!(pHeader.dwFlags &  0x00000002 )) {
                logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 268 ); logger.error("Флаг DDSD_HEIGHT в заголовке DDS всегда должен быть"); ;
            }
            if (!(pHeader.dwFlags &  0x00000004 )) {
                logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 271 ); logger.error("Флаг DDSD_WIDTH в заголовке DDS всегда должен быть"); ;
            }
            if (!(pHeader.dwFlags &  0x00001000 )) {
                logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 274 ); logger.error("Флаг DDSD_PIXELFORMAT в заголовке DDS всегда должен быть"); ;
            }

            pImgData.width=pHeader.dwWidth;
            pImgData.height=pHeader.dwHeight;
            pImgData.depth=1;
            var nFace: number =1;

            pImgData.flags=0;

            if (pHeader.dwCaps2 &  0x200 )
			{
				pImgData.flags |=  EImageFlags.CUBEMAP;
				nFace=0;
                if (pHeader.dwCaps2 &  0x400 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.POSITIVE_X;
                }
                if (pHeader.dwCaps2 &  0x800 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.NEGATIVE_X;
                }
                if (pHeader.dwCaps2 &  0x1000 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.POSITIVE_Y;
                }
                if (pHeader.dwCaps2 &  0x2000 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.NEGATIVE_Y;
                }
                if (pHeader.dwCaps2 &  0x4000 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.POSITIVE_Z;
                }
                if (pHeader.dwCaps2 &  0x8000 ) {
                    nFace++;
                    pImgData.cubeFlags|=EImageCubeFlags.NEGATIVE_Z;
                }

                if(nFace==0){
                	logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 314 ); logger.warning("Выставлен фдлаг с кубической текстурой, а самих текстур нету"); ;
                }
			}

			if (pHeader.dwCaps2 &  0x200000 )
			{
				pImgData.flags|=EImageFlags.TEXTURE_3D;
				pImgData.depth= pHeader.dwDepth;
			}

			var eSourceFormat:EPixelFormats=EPixelFormats.UNKNOWN;

			if (pHeader.ddspf.dwFlags &  0x00000004 ) {
				if (pHeader.ddspf.dwFourCC ==  0x31545844 ) {
				    eSourceFormat = EPixelFormats.DXT1;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x32545844 ) {
				    eSourceFormat = EPixelFormats.DXT1;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x33545844 ) {
				    eSourceFormat = EPixelFormats.DXT3;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x34545844 ) {
				    eSourceFormat = EPixelFormats.DXT4;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x35545844 ) {
				    eSourceFormat = EPixelFormats.DXT5;
				}
				else if (pHeader.ddspf.dwFourCC ==  0x30315844 ) {
				    var pDDS10Header:Uint32Array = new Uint32Array(pData.buffer, 128, 5);
				    var header10:IDDSHeaderDXT10 = <IDDSHeaderDXT10>{};
				    header10.dxgiFormat = pDDS10Header[0];
				    header10.resourceDimension = pDDS10Header[1];
				    header10.miscFlag = pDDS10Header[2];
				    header10.arraySize = pDDS10Header[3];
				    header10.reserved = pDDS10Header[4];

				    logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 351 ); logger.criticalError("Формат D3DFMT_DX10 не поддерживается"); ;
/*console.log("dxgiFormat",header10.dxgiFormat);
				     console.log("resourceDimension",header10.resourceDimension);					
				     nCubeMap=1;
				     if(header10.miscFlag&RESOURCE_MISC_TEXTURECUBE)
				     {
				     nCubeMap=header10.arraySize;
				     }

				     if(nCubeMap!=6)
				     {
				     warning("Количество частей кубической текстуру не равно 6",nCubeMap);						
				     }*/

				    iOffset += 20;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x0000006F )
				{
					eSourceFormat=EPixelFormats.FLOAT16_R;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000070 )
				{
					eSourceFormat=EPixelFormats.FLOAT16_GR;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000071 )
				{
					eSourceFormat=EPixelFormats.FLOAT16_RGBA;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000072 )
				{
					eSourceFormat=EPixelFormats.FLOAT32_R;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000073 )
				{
					eSourceFormat=EPixelFormats.FLOAT32_GR;
				}
				else if(pHeader.ddspf.dwFourCC ==  0x00000074 )
				{
					eSourceFormat=EPixelFormats.FLOAT32_RGBA;
				}
				else {
				    logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 391 ); logger.criticalError("Флаг DDPF_FOURCC стоит, а подходящего dwFourCC нет"); ;
				}
			}
			else
			{
				var iAMask=pHeader.ddspf.dwFlags &  0x00000001  ? pHeader.ddspf.dwABitMask:0;
				var ePF:EPixelFormats;
				for (ePF= EPixelFormats.UNKNOWN + 1; ePF < EPixelFormats.TOTAL; ePF++)
				{


					if((!!(pHeader.ddspf.dwFlags& 0x00020000 ))!=pixelUtil.isLuminance(ePF))
					{
						continue;
					}
					if((!!(pHeader.ddspf.dwFlags& 0x00000001 ))!=pixelUtil.hasAlpha(ePF))
					{
						continue;
					}


					if (pixelUtil.getNumElemBits(ePF) == pHeader.ddspf.dwRGBBitCount)
					{
						var pTestMasks: number []=pixelUtil.getBitMasks(ePF);
						var pTestBits: number []=pixelUtil.getBitDepths(ePF);

						if (pTestMasks[0] == pHeader.ddspf.dwRBitMask && pTestMasks[1] == pHeader.ddspf.dwGBitMask &&
							pTestMasks[2] == pHeader.ddspf.dwBBitMask &&
// for alpha, deal with 'X8' formats by checking bit counts
							(pTestMasks[3] == iAMask || (iAMask == 0 && pTestBits[3] == 0)))
						{
							break;
						}
					}

				}

				if(ePF==EPixelFormats.TOTAL)
				{
					logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 430 ); logger.criticalError("Cannot determine pixel format. DDSCodec.decode"); ;
				}
				else
				{
					eSourceFormat=ePF;
				}
			}



/*if (pixelUtil.isCompressed(eSourceFormat))
			{				
				pImgData.flags |= EImageFlags.COMPRESSED;
				if (!(pHeader.dwFlags & DDSD_LINEARSIZE)) {
                    CRITICAL_ERROR("У сжатой текстуры не выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");
                }
			}
			else
			{
				if (pHeader.dwFlags & DDSD_LINEARSIZE) {
                	CRITICAL_ERROR("У несжатой текстуры выставлен флаг DDS_HEADER_FLAGS_LINEARSIZE в заголовке");
            	}
			}*/


			pImgData.format = eSourceFormat;

			if (pHeader.dwFlags &  0x00020000 ) {
                pImgData.numMipMaps = pHeader.dwMipMapCount-1;
                if (pImgData.numMipMaps!=core.pool.resources.Img.getMaxMipmaps(pImgData.width,pImgData.height,pImgData.depth,pImgData.format)) {
                logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 460 ); logger.warning("Количество мипмапов не такое чтобы уменьшить размер картинки до 1x1 " + pHeader.dwMipMapCount + "," + pHeader.dwWidth + "x" + pHeader.dwHeight + ")");
                                                                                                           ;

            	}
            }
            else{
                pImgData.numMipMaps = 0;
            }

			var pOutput:Uint8Array=new Uint8Array(pImgData.size)
			var iOutputOffset: number =0;

			for(var i: number =0;i<nFace;i++)
			{
				var iWidth: number =pImgData.width;
				var iHeight: number =pImgData.height;
				var iDepth: number =pImgData.depth;

				for(var iMip: number =0;iMip<=pImgData.numMipMaps;iMip++)
				{

					if(pixelUtil.isCompressed(pImgData.format))
					{
						var iDXTSize: number =pixelUtil.getMemorySize(iWidth, iHeight, iDepth, pImgData.format);
						for(var a: number =0;a<iDXTSize;a++)
						{
							pOutput[a+iOutputOffset]=pData[iOffset+a];

						}
						iOffset+=iDXTSize;
						iOutputOffset+=iDXTSize;

					}
					else
					{
						var iDstPitch: number =iWidth*pixelUtil.getNumElemBytes(pImgData.format);
						var iSrcPitch: number =0;
						if (pHeader.dwFlags &  0x00000008 )
						{
							iSrcPitch = pHeader.dwPitchOrLinearSize / Math.max(1, iMip * 2);
						}
						else
						{
// assume same as final pitch
							iSrcPitch = iDstPitch;
						}
						if (iSrcPitch<iDstPitch)
						{
							logger.setSourceLocation( "pixelUtil/DDSCodec.ts" , 507 ); logger.warning("Странный размер питча у картинки");
						}

						for (var z: number  = 0; z < pImgData.depth; z++)
						{
							for (var y: number  = 0; y < pImgData.height; y++)
							{

								for(var a: number =0;a<iDstPitch;a++)
								{
									pOutput[a+iOutputOffset]=pData[iOffset+a];
								}
								iOutputOffset = iOutputOffset + iDstPitch;
								iOffset=iOffset+iSrcPitch;
							}
						}

					}
					if(iWidth!=1)
					{
						iWidth=Math.floor(iWidth/2);
					}
					if(iHeight!=1)
					{
						iHeight=Math.floor(iHeight/2);
					}
					if(iDepth!=1)
					{
						iDepth=Math.floor(iDepth/2);
					}
				}
			}
			return pOutput;
		}



	}





}





//include sub creation classes.
























module akra.render {
	export interface IIndexSet {
		sName: string;
		pMap: IBufferMap;
		pIndexData: IBufferData;
		pAttribData: IVertexData;
		pI2IDataCache: IntMap;
		pAdditionCache: IntMap;
	};

	export class RenderData extends util.ReferenceCounter implements IRenderData {
/**
		 * Options.
		 */

		private _eOptions:  number  = 0;
/**
		 * Buffer, that create this class.
		 */

		private _pBuffer: IRenderDataCollection = null;
/**
		 * ID of this data.
		 */

		private _iId:  number  = -1;
/**
		 * Buffer with indices.
	     * If the data is the simplest mesh, with no more
	     * than one index, the type will be IndexBuffer,
	     * otherwise VertexBuffer.
	     */

		private _pIndexBuffer: IHardwareBuffer = null;
/**
		 * Buffer with attributes.
		 */

		private _pAttribBuffer: IVertexBuffer = null;
/**
	      * Data with indices.
	      * If _pIndexBuffer has type IndexBuffer, indices data
	      * has type IndexData, otherwise VertexData.
	      */

		private _pIndexData: IBufferData = null;
/**
	     * Data with attributes.
	     */

		private _pAttribData: IVertexData = null;
/**
	     * Buffer map for current index set.
	     */

		private _pMap: IBufferMap = null;
/**
	     * Buffer maps of all index sets.
	     */

		private _pIndicesArray: IIndexSet[] = [];
/**
	     * Current index set.
	     */

		private _iIndexSet:  number  = 0;
		private _iRenderable:  number  = 1;


		inline get buffer(): IRenderDataCollection {
			return this._pBuffer;
		}

		inline private get indexSet(): IIndexSet {
			return this._pIndicesArray[this._iIndexSet];
		}

		constructor(pCollection: IRenderDataCollection = null) {
			super();
			this._pBuffer = pCollection;
		}

/**
		 * Allocate data for rendering.
		 */

        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBuffer, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexElementInterface[], pData: ArrayBufferView, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, hasIndex: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, hasIndex: bool = true):  number ;
        allocateData(pDecl: any, pData: any, hasIndex: bool = true):  number {
        	var pDataDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);
        	var eType: ERenderDataTypes = ERenderDataTypes.INDEXED;

		    if (!hasIndex || this.useSingleIndex()) {
		        eType = ERenderDataTypes.DIRECT;
		    }
		    else if (this.useAdvancedIndex()) {
		        eType = ERenderDataTypes.I2I;
		    }

		    return this._allocateData(pDataDecl, pData, eType);
        }

/**
         * Remove data from this render data.
         */

        releaseData(iDataLocation:  number ): void {
//TODO: release data.
        }

/**
		 * Allocate attribute.
		 * Attribute - data without index.
		 */

        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
        allocateAttribute(pAttrDecl: IVertexDeclaration, pData: any): bool {
        	var pIndexData = this._pIndexData;
		    var pAttribData: IVertexData = this._pAttribData;
		    var pAttribBuffer: IVertexBuffer = this._pAttribBuffer;
		    var pBuffer: IRenderDataCollection = this._pBuffer;

		    if (!pAttribData) {
		        if (!pAttribBuffer) {
		            pAttribBuffer = pBuffer.getEngine().getResourceManager().createVertexBuffer('render_data_attrs_' + sid());
		            pAttribBuffer.create((<ArrayBufferView>pData).byteLength, EHardwareBufferFlags.BACKUP_COPY);
		            this._pAttribBuffer = pAttribBuffer;
		        }

		        this._pAttribData = this._pAttribBuffer.allocateData(pAttrDecl, pData);
		        this._pIndicesArray[this._iIndexSet].pAttribData = this._pAttribData;
		        this._pMap.flow(this._pAttribData);
		        return this._pAttribData !== null;
		    }

		    if (!pAttribData.extend(pAttrDecl, pData)) {
		        logger.setSourceLocation( "RenderData.ts" , 136 ); logger.log('invalid data for allocation:', arguments); ;
		        logger.setSourceLocation( "RenderData.ts" , 137 ); logger.warning('cannot allocate attribute in data subset..'); ;
		        return false;
		    }

		    return true;
        }

/**
		 * Allocate index.
		 */

		allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		allocateIndex(pDecl: any, pData: any): bool{
			var pAttrDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);

			if (this.useAdvancedIndex()) {
		        return this._allocateAdvancedIndex(pAttrDecl, pData);
		    }
		    return this._allocateIndex(pAttrDecl, pData);
		}

		getAdvancedIndexData(sSemantics: string): IVertexData {
			return this._getData(sSemantics, true);
		}

/**
		 * Add new set of indices.
		 */

        addIndexSet(usePreviousDataSet: bool = true, ePrimType:EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST, sName: string = null):  number  {

// if (this._pIndexData === null) {
//     return false;
// }


        	if (usePreviousDataSet) {
        	    this._pMap = this._pMap.clone(false);

        	    if (!this._pMap) {
        	        return -1;
        	    }
        	}
        	else {
        	    this._pMap = this._pBuffer.getEngine().createBufferMap();
        	    this._pAttribData = null;
        	}

        	this._pMap.primType = ePrimType;
        	this._pIndexData = null;
        	this._iIndexSet = this._pIndicesArray.length;
        	this._pIndicesArray.push({
        	                             pMap        	: this._pMap,
        	                             pIndexData  	: this._pIndexData,
        	                             pAttribData 	: this._pAttribData,
        	                             sName       	: sName,
        	                             pI2IDataCache	: <IntMap> null,
										 pAdditionCache	: <IntMap> null
        	                         });

        	return  this._iIndexSet;
        }

        getNumIndexSet():  number  {
        	return this._pIndicesArray.length;
        }

        getIndexSetName(iSet:  number  = this._iIndexSet): string {
        	return this._pIndicesArray[iSet].sName;
        }

/**
         * Select set of indices.
         */

        selectIndexSet(iSet:  number ): bool;
        selectIndexSet(sName: string): bool;
        selectIndexSet(a): bool {
        	var iSet:  number  = -1;

        	if (isString(arguments[0])) {
        		for (var i:  number  = 0; i < this._pIndicesArray.length; ++ i) {
        			if (this._pIndicesArray[i].sName === <string>arguments[0]) {
        				iSet = i;
        				break;
        			}
        		};

        		if (iSet < 0) {
        			return false;
        		}
        	}

        	var pIndexSet = this._pIndicesArray[iSet];

        	if (pIndexSet) {
        	    this._pMap = pIndexSet.pMap;
        	    this._pIndexData = pIndexSet.pIndexData;
        	    this._pAttribData = pIndexSet.pAttribData;
        	    this._iIndexSet = iSet;
        	    return true;
        	}

        	return false;
        }

/**
         * Get number of current index set.
         */

        getIndexSet():  number  {
        	return this._iIndexSet;
        }

        inline hasAttributes(): bool {
            return !isNull(this._pAttribData);
        }

/**
		 * Specifies uses advanced index.
		 */

        useAdvancedIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.ADVANCED_INDEX) != 0;
        }

        useSingleIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.SINGLE_INDEX) != 0;
        }

        useMultiIndex(): bool {
        	return (this._eOptions & ERenderDataOptions.SINGLE_INDEX) == 0;
        }

        setRenderable(bValue: bool): void;
        setRenderable(iIndexSet:  number , bValue: bool): void;
        setRenderable(iIndexSet: any, bValue?: bool = true): void {
        	if (arguments.length < 2) {
//mark all render data as renderable or not
        		if (<bool>arguments[0]) {
        			((this._eOptions) |= (ERenderDataOptions.RENDERABLE))
        		}
        		else {
        			((this._eOptions) &= ~(ERenderDataOptions.RENDERABLE)) ;
        		}
        	}

//mark index set is renderable or not
        	(bValue ? ((this._iRenderable) |= (1 << ((< number >iIndexSet))) ) : ((this._iRenderable) &= ~ (1 << ((< number >iIndexSet))) ) ) ;
        }

        isRenderable(iIndexSet?:  number ): bool;
        isRenderable(): bool;
        isRenderable(iIndexSet?:  number ): bool {
        	if (arguments.length > 0) {
//is this index set renderable ?
        		return  ((this._iRenderable & (1 << (iIndexSet)) ) != 0) ;
        	}

//is this data renderable ?
        	return this._eOptions & ERenderDataOptions.RENDERABLE ? true : false;
        }

/**
         * Check whether the semantics used in this data set.
         */

        hasSemantics(sSemantics: string, bSearchComplete: bool = true): bool {
        	return this._getFlow(sSemantics, bSearchComplete) !== null;
        }

/**
         * Get data location.
         */

        getDataLocation(sSemantics: string):  number ;
        getDataLocation(iDataLocation:  number ):  number ;
        getDataLocation(sSemantics?):  number  {
        	var pData: IVertexData = this._getData(<string>sSemantics);

        	return pData ? pData.byteOffset : -1;
        }

/**
         * Get indices that uses in current index set.
         */

        getIndices(): IBufferData {
        	return this._pIndexData;
        }

/**
         * Get number of primitives for rendering.
         */

        getPrimitiveCount():  number  {
        	return this._pMap.primCount;
        }

/**
         * Setup index.
         */

        index(sData: string, sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool;
        index(iData:  number , sSemantics: string, useSame?: bool, iBeginWith?:  number ): bool;
        index(data: any, sSemantics: string, useSame: bool = false, iBeginWith:  number  = 0): bool {
            var iData:  number  = < number >arguments[0];
        	var iFlow:  number  = -1;
        	var iAddition:  number , iRealAddition:  number , iPrevAddition:  number ;
        	var pFlow: IDataFlow;
        	var pData: IVertexData, pRealData: IVertexData;
        	var pFloat32Array: Float32Array;
        	var iIndexOffset:  number ;
        	var pIndexData: IBufferData = this._pIndexData;
        	var sData: string;
        	var iStride:  number ;
        	var iTypeSize:  number  = EDataTypeSizes.BYTES_PER_FLOAT;

        	if (this.useAdvancedIndex()) {
        	    pRealData = this._getData(<string>arguments[0]);
        	    iAddition = pRealData.byteOffset;
        	    iStride = pRealData.stride;
//индекс, который подал юзер
        	    pData = this._getData(sSemantics, true);

        	    pData.applyModifier(sSemantics, function (pTypedData: Float32Array) {
        	        for (var i:  number  = 0; i < pTypedData.length; i++) {
        	            pTypedData[i] = (pTypedData[i] * iStride + iAddition) / iTypeSize;
        	        }
        	    });

        	    iData = pData.byteOffset;
        	    sSemantics = "INDEX_" + sSemantics;
        	}
        	else if (isString(arguments[0])) {
        	    if (arguments[0] === "TEXCOORD") {
        	        iData = this.getDataLocation("TEXCOORD0");
        	    }
        	    else {
        	    	iData = this.getDataLocation(<string>arguments[0]);
        		}

        	    logger.setSourceLocation( "RenderData.ts" , 372 ); logger.assert(iData >= 0, "cannot find data with semantics: " + arguments[0]); ;
        	}

            pFlow = this._getFlow(iData);

        	if (pFlow === null) {
                logger.setSourceLocation( "RenderData.ts" , 378 ); logger.warning("Could not find data flow <" + iData + "> int buffer map: " + this._pMap.toString(true)); ;
        	    return false;
        	}

        	iFlow = pFlow.flow;
        	iIndexOffset = (<IVertexData>pIndexData).getVertexDeclaration().findElement(sSemantics).offset;
        	pFloat32Array = <Float32Array>(<IVertexData>pIndexData).getTypedData(sSemantics);
        	iAddition = iData;

        	if (!pFloat32Array) {
        	    return false;
        	}


        	iStride = pFlow.data.stride;

        	if (this.indexSet.pAdditionCache[iIndexOffset] !== iAddition) {
        	    if (!useSame) {
        	        iPrevAddition = this.indexSet.pAdditionCache[iIndexOffset] || 0;
        	        iRealAddition = iAddition - iPrevAddition;

        	        for (var i = 0; i < pFloat32Array.length; i++) {
        	            pFloat32Array[i] = (pFloat32Array[i] * iStride + iRealAddition) / iTypeSize;
        	        }
        	        ;
        	    }
        	    else {
        	        iRealAddition = iAddition;
        	        for (var i = 0; i < pFloat32Array.length; i++) {
        	            pFloat32Array[i] = (iBeginWith + iRealAddition) / iTypeSize;
        	        }
        	        ;
        	    }

//remeber addition, that we added to index.
        	    this.indexSet.pAdditionCache[iIndexOffset] = iAddition;

        	    if (!(<IVertexData>pIndexData).setData(pFloat32Array, sSemantics)) {
        	        return false;
        	    }
        	}

        	return this._pMap.mapping(iFlow, <IVertexData>pIndexData, sSemantics);
        }


/*Setup.*/

		_setup(pCollection: IRenderDataCollection, iId:  number , ePrimType: EPrimitiveTypes = EPrimitiveTypes.TRIANGLELIST, eOptions:  number  = 0): bool {
			if (this._pBuffer === null && arguments.length < 2) {
		        return false;
		    }

		    this.setRenderable(true);

		    this._eOptions |= eOptions;
		    this._pBuffer = pCollection;
		    this._iId = iId;

//setup buffer map
		    this._pMap = pCollection.getEngine().createBufferMap();
		    this._pMap.primType = ePrimType;

//setup default index set
		    this._pIndicesArray.push({
		                                 sName       	: ".main",
		                                 pMap        	: <IBufferMap>this._pMap,
		                                 pIndexData  	: <IBufferData>null,
		                                 pAttribData 	: <IVertexData>null,
		                                 pI2IDataCache	: <IntMap>{},
		                                 pAdditionCache : <IntMap>null
		                             });

		    logger.setSourceLocation( "RenderData.ts" , 450 ); logger.assert(this.useSingleIndex() === false, "single indexed data not implimented"); ;

		    return true;
		}


        private _allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, eType: ERenderDataTypes):  number ;
        private _allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, eType: ERenderDataTypes):  number ;
        private _allocateData(pDataDecl: IVertexDeclaration, pData: any, eType: ERenderDataTypes):  number  {
        	if (eType === ERenderDataTypes.DIRECT) {
		        return this.allocateAttribute(pDataDecl, pData)? 0: -1;
		    }

		    var iFlow:  number ;
		    var pVertexData: IVertexData = this._pBuffer._allocateData(pDataDecl, pData);
		    var iOffset:  number  = pVertexData.byteOffset;

		    iFlow = this._addData(pVertexData, undefined, eType);

		    if (iFlow < 0) {
		        logger.setSourceLocation( "RenderData.ts" , 470 ); logger.log("invalid data", pDataDecl, pData); ;
		        logger.setSourceLocation( "RenderData.ts" , 471 ); logger.error("cannot allocate data for submesh"); ;
		        return -1;
		    }

		    return iOffset;
        }

/**
		 * Add vertex data to this render data.
		 */

        _addData(pVertexData: IVertexData, iFlow?:  number , eType: ERenderDataTypes = ERenderDataTypes.DIRECT):  number  {

		    if ((arguments.length < 3 && this.useAdvancedIndex()) ||
		        arguments[2] === ERenderDataTypes.I2I) {
		        return this._registerData(pVertexData);
		    }

		    return (!isDef(iFlow) ? this._pMap.flow(pVertexData) :
		            this._pMap.flow(iFlow, pVertexData));
		}

/**
		 * Register data in this render.
		 * Necessary for index to index mode, when data realy
		 * not using in this render data for building final buffer map.
		 */

		private _registerData(pVertexData: IVertexData):  number  {
		    'use strict';
		    var iOffset:  number  = pVertexData.byteOffset;
		    var pDataDecl: data.VertexDeclaration = <data.VertexDeclaration>pVertexData.getVertexDeclaration();

//необходимо запоминать расположение данных, которые подаются,
//т.к. иначе их потом нельзя будет найти среди других данных
		    for (var i:  number  = 0; i < pDataDecl.length; i++) {
		        this.indexSet.pI2IDataCache[pDataDecl[i].eUsage] = iOffset;
		    }


		    return 0;
		};


/**
		 * Allocate advanced index.
		 */

		 private _allocateAdvancedIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		 private _allocateAdvancedIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		 private _allocateAdvancedIndex(pAttrDecl: any, pData: any): bool {

		    var pDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pAttrDecl);
		    var nCount:  number  = pData.byteLength / pDecl.stride;
//TODO: remove index dublicates
		    var iIndLoc:  number  = this._allocateData(pAttrDecl, pData, ERenderDataTypes.INDEXED);
		    var pI2IData: Float32Array = new Float32Array(nCount);
		    var pI2IDecl: IVertexElementInterface[] = [];

		    for (var i:  number  = 0; i < pDecl.length; i++) {
		        pI2IDecl.push(VE_FLOAT('INDEX_' + pDecl[i].eUsage, 0));
		    }


		    for (var i:  number  = 0; i < pI2IData.length; i++) {
		        pI2IData[i] = i;
		    }


		    if (!this._allocateIndex(pI2IDecl, pI2IData)) {
		        this.releaseData(iIndLoc);
		        pI2IData = null;
		        pI2IDecl = null;
		        logger.setSourceLocation( "RenderData.ts" , 543 ); logger.warning('cannot allocate index for index in render data subset'); ;
		        return false;
		    }

		    return true;
		};



/**
		 * Create IndexBuffer/IndexData for storage indices.
		 */

		private _createIndex(pAttrDecl: IVertexDeclaration, pData:ArrayBuffer): bool;
		private _createIndex(pAttrDecl: IVertexDeclaration, pData:ArrayBufferView): bool;
		private _createIndex(pAttrDecl: IVertexDeclaration, pData:any): bool{
		    'use strict';

		    if (!this._pIndexBuffer) {
		        if (this.useMultiIndex()) {
		            this._pIndexBuffer = this._pBuffer.getEngine().getResourceManager().createVertexBuffer('subset_' + sid());
		            this._pIndexBuffer.create(((<ArrayBufferView>pData).byteLength), < number >EHardwareBufferFlags.BACKUP_COPY);
		        }
		        else {
//TODO: add support for sinle indexed mesh.
		        }
		    }

		    this._pIndexData = (<IVertexBuffer>this._pIndexBuffer).allocateData(pAttrDecl, pData);
		    this.indexSet.pIndexData = this._pIndexData;
		    this.indexSet.pAdditionCache = <IntMap>{};
		    return this._pIndexData !== null;
		};

/**
		 * Allocate index.
		 */

		private _allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBuffer): bool;
		private _allocateIndex(pAttrDecl: IVertexElementInterface[], pData: ArrayBufferView): bool;
		private _allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBuffer): bool;
		private _allocateIndex(pAttrDecl: IVertexDeclaration, pData: ArrayBufferView): bool;
		private _allocateIndex(pDecl: any, pData: any): bool {
		    'use strict';
            var pAttrDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]> pDecl);

		    var pIndexData: IBufferData = this._pIndexData;
		    var pIndexBuffer: IHardwareBuffer = this._pIndexBuffer;
		    var pBuffer: IRenderDataCollection = this._pBuffer;


		    for (var i:  number  = 0; i < pAttrDecl.length; i++) {
		        if (pAttrDecl.element(i).type !== EDataTypes.FLOAT) {
		            return false;
		        }
		    }


		    if (!this._pIndexData) {
		        return this._createIndex(pAttrDecl, pData);
		    }

		    if (!(<IVertexData>this._pIndexData).extend(pAttrDecl, pData)) {
		        logger.setSourceLocation( "RenderData.ts" , 604 ); logger.log('invalid data for allocation:', arguments); ;
		        logger.setSourceLocation( "RenderData.ts" , 605 ); logger.warning('cannot allocate index in data subset..'); ;
		        return false;
		    }

		    return true;
		};


		_setIndexLength(iLength:  number ): bool {
			var bResult: bool = (<IVertexData>this._pIndexData).resize(iLength);

			if(bResult) {
				this._pMap._length = iLength;
			}

			return bResult;
		}


/**
         * Get data flow by semantics or data location.
         */

        _getFlow(iDataLocation:  number ): IDataFlow;
        _getFlow(sSemantics: string, bSearchComplete?: bool): IDataFlow;
        _getFlow(a, b?): IDataFlow {
        	if (typeof arguments[0] === 'string') {
		        return this._pMap.getFlow(arguments[0], arguments[1]);
		    }

		    for (var i:  number  = 0, n = this._pMap.limit; i < n; ++i) {
		        var pFlow = this._pMap.getFlow(i, false);

		        if (pFlow.data && pFlow.data.byteOffset === arguments[0]) {
		            return pFlow;
		        }
		    }

		    return null;
        }

/**
         * Get data by semantics or location.
         */

        _getData(iDataLocation:  number , bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(sSemanticsn: string, bSearchOnlyInCurrentMap?: bool): IVertexData;
        _getData(a, b?): IVertexData {
        	var pFlow: IDataFlow;

        	if (this.useAdvancedIndex() && arguments.length < 2) {
        	    if (typeof arguments[0] === 'string') {
        	        return this._getData(this.indexSet.pI2IDataCache[arguments[0]]);
        	    }

        	    return this._pBuffer.getData(<string>arguments[0]);
        	}

        	if (typeof arguments[0] === 'string') {
        	    for (var i = 0, n = this._pMap.limit; i < n; ++i) {
        	        pFlow = this._pMap.getFlow(i, false);
        	        if (pFlow.data != null && pFlow.data.hasSemantics(arguments[0])) {
        	            return pFlow.data;
        	        }
        	    }

//this._pBuffer._getData(arguments[0]);        	    return null;
        	}

        	pFlow = this._getFlow(arguments[0]);
        	return pFlow === null ? null : pFlow.data;
        }



/**
         * Draw this data.
         */

        _draw(): void {
        	for (var i:  number  = 0; i < this._pIndicesArray.length; i++) {
        	    if (this.isRenderable(i)) {
        	        this._pIndicesArray[i].pMap._draw();
        	    }
        	}
        }

//applyMe(): bool;

        toString(): string {
        	var s: string;
        	s = "\nRENDER DATA SUBSET: #" + this._iId + "\n";
        	s += "        ATTRIBUTES: " + (this._pAttribData ? "TRUE" : "FALSE") + "\n";
        	s += "----------------------------------------------------------------\n";
        	s += this._pMap.toString();

        	return s;
        }
	}
}





module akra.render {

	export class RenderDataCollection extends util.ReferenceCounter implements IRenderDataCollection {
		private _pDataBuffer: IVertexBuffer = null;
		private _pEngine: IEngine = null;
		private _eDataOptions: ERenderDataBufferOptions = 0;
		private _pDataArray: IRenderData[] = [];

		inline get buffer(): IVertexBuffer {
			return this._pDataBuffer;
		}

        inline get length():  number  {
            return this._pDataArray.length;
        }

        inline get byteLength():  number  {
            return this._pDataBuffer.byteLength;
        }


        constructor (pEngine: IEngine, eOptions: ERenderDataBufferOptions = 0) {
            super();
            this._pEngine = pEngine;
            this.setup(eOptions);
        }

        clone(pSrc: IRenderDataCollection): bool {
            logger.setSourceLocation( "render/RenderDataCollection.ts" , 37 ); logger.criticalError("TODO: RenderDataCollection::clone();"); ;

            return false;
        }

        getEngine(): IEngine {
        	return this._pEngine;
        }

        getOptions(): ERenderDataBufferOptions {
        	return this._eDataOptions;
        }

/**
         * Find VertexData with given semantics/usage.
         */

        getData(sUsage: string): IVertexData;
        getData(iOffset:  number ): IVertexData;
        getData(a?): IVertexData {
        	var pBuffer: IVertexBuffer = this._pDataBuffer;
            var pData: IVertexData;
            var n:  number ;

        	if (!isNull(pBuffer)) {
        	    n = this._pDataBuffer.length;

        	    if (isString(arguments[0])) {
        	        for (var i:  number  = 0; i < n; i++) {
                        pData = pBuffer.getVertexData(i);
        	            if (pData.hasSemantics(<string>arguments[0])) {
        	                return pData;
        	            }
        	        };
        	    }
        	    else {
        	        for (var i:  number  = 0; i < n; i++) {
                        pData = pBuffer.getVertexData(i);
        	            if (pData.byteOffset === < number >arguments[0]) {
        	                return pData;
        	            }
        	        };
        	    }
        	}

        	return null;
        }

/**
         * Положить данные в буфер.
         */

        _allocateData(pVertexDecl: IVertexDeclaration, iSize:  number ): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBufferView): IVertexData;
        _allocateData(pVertexDecl: IVertexDeclaration, pData: ArrayBuffer): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], iSize:  number ): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView): IVertexData;
        _allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer): IVertexData;
        _allocateData(pDecl, pData) {
        	if (!this._pDataBuffer) {
        	    this.createDataBuffer();
        	}

        	var pVertexDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);
        	var pVertexData: IVertexData;

        	if ((arguments.length < 2) || isNumber(arguments[1]) || isNull(arguments[1])) {
        	    pVertexData = this._pDataBuffer.getEmptyVertexData(< number >pData || 1, pVertexDecl);
        	}
        	else {
        	    pVertexData = this._pDataBuffer.allocateData(pVertexDecl, <ArrayBufferView>pData);
        	}

        	logger.setSourceLocation( "render/RenderDataCollection.ts" , 108 ); logger.assert(pVertexData !== null, "cannot allocate data:\n" + pVertexDecl.toString()); ;

        	return pVertexData;
        }

        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBufferView, isCommon: bool = true):  number ;
        allocateData(pDataDecl: IVertexDeclaration, pData: ArrayBuffer, isCommon: bool = true):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBufferView, isCommon: bool = true):  number ;
        allocateData(pDeclData: IVertexElementInterface[], pData: ArrayBuffer, isCommon: bool = true):  number ;

        allocateData(pDecl?, pData?, isCommon: bool = true):  number  {
        	    var pVertexData: IVertexData;
        	    var pDataDecl: data.VertexDeclaration = createVertexDeclaration(<IVertexElementInterface[]>pDecl);



        	    for (var i:  number  = 0; i < pDataDecl.length; i++) {
        	        if (this.getData(pDataDecl.element(i).usage) !== null && pDataDecl.element(i).count !== 0) {
        	            logger.setSourceLocation( "render/RenderDataCollection.ts" , 127 ); logger.warning("data buffer already contains data with similar vertex decloration <" + pDataDecl.element(i).usage + ">.");
                                                           ;
        	        }
        	    };



        	    pVertexData = this._allocateData(pDataDecl, <ArrayBufferView>pData);

        	    if (isCommon) {
        	        for (var i:  number  = 0; i < this._pDataArray.length; ++ i) {
        	            this._pDataArray[i]._addData(pVertexData);
        	        }
        	    }

        	    return pVertexData.byteOffset;
        }

        getDataLocation(sSemantics: string):  number  {
        	if (this._pDataBuffer) {
        	    var pData: IVertexData;

        	    for (var i:  number  = 0, n:  number  = this._pDataBuffer.length; i < n; i++) {
                    pData = this._pDataBuffer.getVertexData(i);
        	        if (pData.hasSemantics(sSemantics)) {
        	            return pData.byteOffset;
        	        }
        	    };
        	}

        	return -1;
        }

        private createDataBuffer() {
//TODO: add support for eOptions
            var iVbOption:  number  = 0;
            var eOptions: ERenderDataBufferOptions = this._eDataOptions;

            if (eOptions & ERenderDataBufferOptions.VB_READABLE) {
                iVbOption = ERenderDataBufferOptions.VB_READABLE;
            }

//trace('creating new video buffer for render data buffer ...');
            this._pDataBuffer = this._pEngine.getResourceManager().createVideoBuffer("render_data_buffer" + "_" + sid());
            this._pDataBuffer.create(0, iVbOption);
            this._pDataBuffer.addRef();
            return this._pDataBuffer !== null;
        };

        getRenderData(iSubset:  number ): IRenderData {
        	return this._pDataArray[iSubset];
        }

        getEmptyRenderData(ePrimType: EPrimitiveTypes, eOptions: ERenderDataBufferOptions = 0): IRenderData {

        	var iSubsetId:  number  = this._pDataArray.length;
        	var pDataset: IRenderData = new RenderData(this);

        	eOptions |= this._eDataOptions;

        	if (!pDataset._setup(this, iSubsetId, ePrimType, eOptions)) {
        	    logger.setSourceLocation( "render/RenderDataCollection.ts" , 187 ); logger.error("cannot setup submesh..."); ;
        	}


        	this._pDataArray.push(pDataset);

        	return pDataset;
        }

        _draw(): void;
        _draw(iSubset?:  number ): void {
        	if (arguments.length > 0) {
        	    this._pDataArray[iSubset]._draw();
        	}

        	for (var i:  number  = 0; i < this._pDataArray.length; i++) {
        	    this._pDataArray[i]._draw();
        	};
        }

        destroy(): void {
        	this._pDataArray = null

            if (this._pDataBuffer) {
// this._pDataBuffer.release();
                this._pDataBuffer.destroy();
                this._pDataBuffer = null;
            }

            this._pEngine = null;
            this._eDataOptions = 0;
        }

        private setup(eOptions: ERenderDataBufferOptions = 0) {
            this._eDataOptions = eOptions;
        };

// inline isValid(): bool { return true; }
// inline isDynamic(): bool { return false; }
// inline isStatic(): bool { return false; }
// inline isStream(): bool { return false; }
// inline isReadable(): bool { return true; }
// inline isBackupPresent(): bool { return true; }

	}

    export function createRenderDataCollection(pEngine: IEngine, eOptions: ERenderDataBufferOptions = 0): IRenderDataCollection {
        return new RenderDataCollection(pEngine, eOptions);
    }
}





























module akra.util {
	export interface IBuffersCompatibleMap {
		[handle:  number ]: IVertexData;
	}

	class BufferMap implements IBufferMap extends ReferenceCounter{
		private _pFlows: IDataFlow[] = null;
		private _pMappers: IDataMapper[] = null;
		private _pIndex: IIndexData = null;
		private _nLength:  number  = 0;
		private _ePrimitiveType: EPrimitiveTypes;
		private _pCompleteFlows: IDataFlow[] = null;
		private _nCompleteFlows:  number  = 0;
		private _nCompleteVideoBuffers:  number  = 0;
		private _pCompleteVideoBuffers: IVertexBuffer[] = null;
		private _nUsedFlows:  number  = 0;
		private _pEngine: IEngine = null;
		private _nStartIndex:  number  = 0;
		private _pBuffersCompatibleMap: IBuffersCompatibleMap = null;

		constructor(pEngine: IEngine){
			super();
			this._pEngine = pEngine;
			this.reset();
		};

		inline get primType(): EPrimitiveTypes{
			return this._pIndex ? this._pIndex.getPrimitiveType() : this._ePrimitiveType;
		};

		inline set primType(eType: EPrimitiveTypes){
			this._ePrimitiveType = eType;
		};

		inline get primCount():  number  {
			return data.IndexData.getPrimitiveCount(this.primType, this.length);
		};

		inline get index(): IIndexData {
			return this._pIndex;
		};

		inline set index(pIndexData: IIndexData) {
			if (this._pIndex === pIndexData) {
	            return;
	        }

	        this._pIndex = pIndexData;
	        this.update();
		};

		inline get limit():  number  {
			return this._pFlows.length;
		};

		inline get length():  number  {
			return (this._pIndex ? this._pIndex.length : this._nLength);
		}

		inline set length(nLength:  number ) {
			this._nLength = Math.min(this._nLength, nLength);
		}

		inline set _length(nLength:  number ) {
			this._nLength = nLength;
		}

		inline get startIndex():  number  {
			return this._nStartIndex;
		}

		inline get size():  number {
			return this._nCompleteFlows;
		}

		inline get flows(): IDataFlow[] {
			return this._pCompleteFlows;
		}

		inline get mappers(): IDataMapper[] {
			return this._pMappers;
		}

		inline get offset():  number  {
			return (this._pIndex? this._pIndex.byteOffset: 0);
		}

		_draw(): void {
			this._pEngine.getRenderer().getActiveProgram().applyBufferMap(this);
			isNull(this._pIndex)? this.drawArrays(): this.drawElements();
		}

		private inline drawArrays(): void {

			(<webgl.WebGLRenderer>this._pEngine.getRenderer()).getWebGLContext().drawArrays(
				webgl.getWebGLPrimitiveType(this._ePrimitiveType),
				this._nStartIndex,
				this._nLength);

		}

		private inline drawElements(): void {

			(<webgl.WebGLRenderer>this._pEngine.getRenderer()).getWebGLContext().drawElements(
				this.primCount,
				this._pIndex.getPrimitiveCount(),
				webgl.getWebGLPrimitiveType(this._pIndex.getPrimitiveType()),
				this._pIndex.byteOffset / 4);
//FIXME: offset of drawElement() in Glintptr = long long = 32 byte???

		}

		getFlow(sSemantics: string, bComplete: bool = true): IDataFlow;
		getFlow(iFlow:  number , bComplete: bool = true): IDataFlow;
		getFlow(iFlow: any, bComplete: bool = true): IDataFlow {

		    if (isString(arguments[0])) {
		        var nTotal:  number ;
		        var pFlows: IDataFlow[];

		        if (bComplete) {
		            pFlows = this._pCompleteFlows;
		            nTotal = this._nCompleteFlows;
		        }
		        else {
		            pFlows = this._pFlows;
		            nTotal = this._pFlows.length;
		        }

		        for (var i:  number  = 0; i < nTotal; ++ i) {
		            if (!pFlows[i].data) {
		                continue;
		            }
		            if (pFlows[i].data.hasSemantics(arguments[0])) {
		                return pFlows[i];
		            }
		        }

		        return null;
		    }

		    if (bComplete) {

		        for (var i:  number  = 0, pFlows = this._pCompleteFlows; i < this._nCompleteFlows; ++ i) {
		            if (pFlows[i].flow == iFlow) {
		                return pFlows[i];
		            }
		        }

		        return null;
		    }

		    return this._pFlows[iFlow];
		}

		reset(): void {
			this._pIndex = null
		    this._ePrimitiveType = EPrimitiveTypes.TRIANGLELIST;


		    var nFlowLimit:  number  = 16;

/*webgl.maxVertexTextureImageUnits*/
			nFlowLimit = Math.min(16                                    , webgl.maxVertexAttributes);


		    this._pMappers = [];
		    this._pFlows = new Array(nFlowLimit);
		    for (var i = 0; i < nFlowLimit; i++) {
		        this._pFlows[i] = {
		            flow: i,
		            data:  null,
		            type:  EDataFlowTypes.UNMAPPABLE,
		            mapper:null
		        };
		    }

		    this._nLength = MAX_INT32;
		    this._pCompleteFlows = new Array(nFlowLimit);
		    this._nCompleteFlows = 0;
		    this._nStartIndex = MAX_INT32;
		    this._pBuffersCompatibleMap = <IBuffersCompatibleMap>{};

		    this._pCompleteVideoBuffers = new Array(nFlowLimit);
		    this._nCompleteVideoBuffers = 0;
		    this._nUsedFlows = 0;
		}

		flow(pVertexData: IVertexData):  number ;
		flow(iFlow:  number , pVertexData: IVertexData):  number ;
		flow(iFlow, pData?):  number  {
			var pFlow: IDataFlow = null;
			var pVertexData: IVertexData = null;

		    if (arguments.length < 2) {
		        pVertexData = <IVertexData>arguments[0];
		        iFlow = (this._nUsedFlows ++);
		    }
// trace(iFlow, '<<==', pVertexData.getVertexDeclaration().toString());
// console.log((new Error).stack);
		    pFlow = this._pFlows[iFlow];

		    logger.setSourceLocation( "util/BufferMap.ts" , 223 ); logger.assert(iFlow < this.limit, 'Invalid strem. Maximum allowable number of stream ' + this.limit + '.');
                                                                                  ;

		    if (!pVertexData || pFlow.data === pVertexData) {
		        return -1;
		    }

/*core.pool.resources.VertexBuffer*/
		    if (pVertexData.buffer instanceof webgl.WebGLVertexBuffer                                    ) {
		        pFlow.type = EDataFlowTypes.UNMAPPABLE;
		        this.length = pVertexData.length;
//this.startIndex = pVertexData.getStartIndex();
		        logger.setSourceLocation( "util/BufferMap.ts" , 234 ); logger.assert(this.checkData(pVertexData), 'You can use several unmappable data flows from one buffer.');
                                                                           ;

		        this.pushEtalon(pVertexData);
		    }
		    else {
		        pFlow.type = EDataFlowTypes.MAPPABLE;
		    }

		    pFlow.data = pVertexData;

		    return this.update() ? iFlow : -1;
		}

		checkData(pData: IVertexData): bool {
			var pEtalon = this._pBuffersCompatibleMap[pData.getBufferHandle()];
		    if (!pEtalon || pEtalon.byteOffset === pData.byteOffset) {
		        return true;
		    }
		    return false;
		}

		/**@protected*/  findMapping(pMap, eSemantics, iAddition): IDataMapper {
		    logger.setSourceLocation( "util/BufferMap.ts" , 256 ); logger.assert(this.checkData(pMap), 'You can use several different maps from one buffer.'); ;
		    for (var i:  number  = 0, pMappers: IDataMapper[] = this._pMappers, pExistsMap; i < pMappers.length; i++) {
		        pExistsMap = pMappers[i].data;
		        if (pExistsMap === pMap) {
//если уже заданные маппинг менял свой стартовый индекс(например при расширении)
//то необходимо сменить стартовый индекс на новый
		            if (pMappers[i].semantics === eSemantics && pMappers[i].addition == iAddition) {
		                return pMappers[i];
		            }
		        }
		        else {
		            logger.setSourceLocation( "util/BufferMap.ts" , 268 ); logger.assert(pExistsMap.getStartIndex() === pMap.getStartIndex(), 'You can not use maps with different indexing');
                                                                 ;
		        }
		    }
		    return null;
		};


		mapping(iFlow:  number , pMap: IVertexData, eSemantics: string, iAddition?:  number ): bool {
			iAddition = iAddition || 0;

		    var pMapper: IDataMapper = this.findMapping(pMap, eSemantics, iAddition);
		    var pFlow: IDataFlow     = this._pFlows[iFlow];

		    logger.setSourceLocation( "util/BufferMap.ts" , 282 ); logger.assert(isDefAndNotNull(pFlow.data) && (pFlow.type === EDataFlowTypes.MAPPABLE), 'Cannot mapping empty/unmappable flow.');
                                                  ;
		    logger.setSourceLocation( "util/BufferMap.ts" , 283 ); logger.assert(isDef(pMap), 'Passed empty mapper.'); ;

		    if (!eSemantics) {
		        eSemantics = pMap.getVertexDeclaration()[0].eUsage;
		    }
		    else if (pMap.hasSemantics(eSemantics) === false) {
		        logger.setSourceLocation( "util/BufferMap.ts" , 289 ); logger.error('Passed mapper does not have semantics: ' + eSemantics + '.'); ;
		        return false;
		    }

		    if (pMapper) {
		        if (pFlow.mapper === pMapper) {
		            return pMapper.semantics === eSemantics &&
		                pMapper.addition === iAddition? true: false;
		        }
		    }
		    else {
		        pMapper = {data: pMap, semantics: eSemantics, addition: iAddition};

		        this._pMappers.push(pMapper);
		        this.length = pMap.length;
//this.startIndex = pMap.getStartIndex();
		        this.pushEtalon(pMap);
		    }

		    pFlow.mapper = pMapper;

		    return this.update();
		}

		private pushEtalon(pData: IVertexData): void {
			this._pBuffersCompatibleMap[pData.getBufferHandle()] = pData;
		}

		update(): bool {
			var pFlows: IDataFlow[] = this._pFlows;
		    var pFlow: IDataFlow;
		    var pMapper: IDataMapper;
		    var isMappable: bool = false;
		    var pCompleteFlows: IDataFlow[] = this._pCompleteFlows;
		    var nCompleteFlows:  number  = 0;
		    var pCompleteVideoBuffers: IVertexBuffer[] = this._pCompleteVideoBuffers;
		    var nCompleteVideoBuffers:  number  = 0;
		    var nUsedFlows:  number  = 0;
		    var pVideoBuffer: IVertexBuffer;
		    var isVideoBufferAdded: bool = false;
		    var nStartIndex:  number  = MAX_INT32, nCurStartIndex:  number ;

		    for (var i:  number  = 0; i < pFlows.length; i++) {
		        pFlow = pFlows[i];
		        pMapper = pFlow.mapper;
		        isMappable = (pFlow.type === EDataFlowTypes.MAPPABLE);

		        if (pFlow.data) {
		            nUsedFlows ++;
		        }

		        if (pFlow.data === null || (isMappable && pMapper === null)) {
		            continue;
		        }

		        pCompleteFlows[nCompleteFlows ++] = pFlow;

		        if (isMappable) {
		            nCurStartIndex = pMapper.data.startIndex;
		            pVideoBuffer = <IVertexBuffer>pFlow.data.buffer;
		            for (var j = 0; j < nCompleteVideoBuffers; j++) {
		                if (pCompleteVideoBuffers[j] === pVideoBuffer) {
		                    isVideoBufferAdded = true;
		                    break;
		                }
		            }
		            if (!isVideoBufferAdded) {
		                pCompleteVideoBuffers[nCompleteVideoBuffers ++] = pVideoBuffer;
		            }
		        }
		        else {
		            nCurStartIndex = pFlow.data.startIndex;
		        }

		        if (nStartIndex === MAX_INT32) {
		            nStartIndex = nCurStartIndex;
		            continue;
		        }

		        logger.setSourceLocation( "util/BufferMap.ts" , 369 ); logger.assert(nStartIndex == nCurStartIndex, 'You can not use a maps or unmappable buffers having different starting index.');
                                                                                              ;
		    }

		    this._nStartIndex = nStartIndex;
		    this._nCompleteFlows = nCompleteFlows;
		    this._nCompleteVideoBuffers = nCompleteVideoBuffers;
		    this._nUsedFlows = nUsedFlows;

		    return true;
		}
		clone(bWithMapping?: bool): IBufferMap {
			bWithMapping = isDef(bWithMapping) ? bWithMapping : true;

		    var pMap: IBufferMap = new BufferMap(this._pEngine);
		    for (var i = 0, pFlows = this._pFlows; i < pFlows.length; ++ i) {
		        if (pFlows[i].data === null) {
		            continue;
		        }

		        if (pMap.flow(pFlows[i].flow, pFlows[i].data) < 0) {
		            pMap = null;
		            return null;
		        }

		        if (!bWithMapping) {
		            continue;
		        }

		        if (pFlows[i].mapper) {
	                pMap.mapping(pFlows[i].flow,
	                pFlows[i].mapper.data,
	                pFlows[i].mapper.semantics,
	                pFlows[i].mapper.addition);
		        }
		    }

		    return pMap;
		}
		toString(bListAll: bool = false): string {
			function _an(sValue, n:  number , bBackward?: bool) {
		        sValue = String(sValue);
		        bBackward = bBackward || false;

		        if (sValue.length < n) {
		            for (var i = 0, l = sValue.length; i < n - l; ++ i) {
		                if (!bBackward) {
		                    sValue += ' ';
		                }
		                else {
		                    sValue = ' ' + sValue;
		                }
		            }
		        }

		        return sValue;
		    }

		    var s = '\n\n', t;
		    s += '      $1 Flows     : OFFSET / SIZE   |   BUFFER / OFFSET   :      Mapping  / Shift    : OFFSET |    Additional    \n';
		    s = s.replace("$1", bListAll? "   Total": "Complete");
		    t  = '-------------------------:-----------------+---------------------:--------------------------:--------+------------------\n';
// = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
// = '#%1 [ %2 ]           :     %6 / %7     |       %3 / %4       :         %5       :        |                  \n';
		    s += t;

		    var pFlows: IDataFlow[] = bListAll? this._pFlows: this._pCompleteFlows;
		    var nFlows:  number  = bListAll? this._nUsedFlows: this._nCompleteFlows;
		    for (var i:  number  = 0; i < nFlows; ++ i) {
		        var pFlow: IDataFlow = pFlows[i];
		        var pMapper: IDataMapper = pFlow.mapper;
		        var pVertexData: IVertexData = pFlow.data;
		        var pDecl: data.VertexDeclaration = pVertexData.getVertexDeclaration();
//trace(pMapper); window['pMapper'] = pMapper;
		        s += '#' + _an(pFlow.flow, 2) + ' ' +
		            _an('[ ' + (pDecl.element(0).usage !== DeclUsages.END? pDecl.element(0).usage: '<end>') + ' ]', 20) +
		            ' : ' + _an(pDecl.element(0).offset, 6, true) + ' / ' + _an(pDecl.element(0).size, 6) +
		            ' | ' +
		            _an(pVertexData.getBufferHandle(), 8, true) + ' / ' + _an(pVertexData.byteOffset, 8) +
		            ' : ' +
		            (pMapper? _an(pMapper.semantics, 15, true) + ' / ' + _an(pMapper.addition, 7) + ': ' +
		                _an(pMapper.data.getVertexDeclaration().findElement(pMapper.semantics).offset, 6) :
		            _an('-----', 25) + ': ' + _an('-----', 6)) + ' |                  \n';


		        for (var j = 1; j < pDecl.length; ++ j) {
		            s += '    ' +
		            _an('[ ' + (pDecl.element(j).usage !== DeclUsages.END? pDecl.element(j).usage: '<end>') + ' ]', 20) + ' : ' + _an(pDecl.element(j).offset, 6, true) + ' / ' + _an(pDecl.element(j).size, 6) +
		                  ' |                     :                          :        |                  \n';
		        }
		        s += t;
		    };
		    s += '=================================================================\n';
		    s += '      PRIMITIVE TYPE : ' + '0x' + Number(this.primType).toString(16) + '\n';
		    s += '     PRIMITIVE COUNT : ' + this.primCount + '\n';
		    s += '         START INDEX : ' + this.startIndex + '\n';
		    s += '              LENGTH : ' + this.length + '\n';
		    s += '  USING INDEX BUFFER : ' + (this.index? 'TRUE': 'FALSE') + '\n';
		    s += '=================================================================\n';

		    return s + '\n\n';
		}
	}

	export function createBufferMap(pEngine: IEngine): IBufferMap {
		return new BufferMap(pEngine);
	}
}



















module akra {
	 export interface IDependens {
        files?: string[];
        deps?: IDependens;
        root?: string;
        type?: string;
        loader?: (dep: IDependens, ...data: any[]) => void;
    }

    export interface IDepsManager extends IEventProvider {
    	load(pDeps: IDependens, sRoot?: string): bool;
    }
}










module akra.util {
	export enum EDepsManagerStates {
		IDLE,
		LOADING
	}

	class DepsManager implements IDepsManager {
		/**@protected*/  _eState: EDepsManagerStates = EDepsManagerStates.IDLE;
		/**@protected*/  _pEngine: IEngine;

		constructor (pEngine: IEngine) {
			this._pEngine = pEngine;
		}

		inline getEngine(): IEngine { return this._pEngine; }

		load(pDeps: IDependens, sRoot: string = null): bool {
			if (!isDefAndNotNull(pDeps)) {
				return false;
			}

			if (this._eState === EDepsManagerStates.LOADING) {
				logger.setSourceLocation( "util/DepsManager.ts" , 33 ); logger.warning("deps manager in loading state"); ;
				return false;
			}

			this.normalizeDepsPaths(pDeps, pDeps.root || sRoot);
			this.createDepsResources(pDeps);
			this.loadDeps(pDeps);

			return true;
		}

		private walk(pDeps: IDependens, fn: (pDeps: IDependens, i:  number , iDepth?:  number ) => void, iDepth:  number  = 0): void {
			var pFiles: string[] = pDeps.files;

			if (isDefAndNotNull(pFiles)) {
//normilize pathes to deps
				for (var i:  number  = 0; i < pFiles.length; ++ i) {
					fn.call(this, pDeps, i, iDepth);
				}
			}

			if (isDefAndNotNull(pDeps.deps)) {
				this.walk(pDeps.deps, fn, ++ iDepth);
			}
		}

		private normalizeDepsPaths(pDeps: IDependens, sRoot: string): void {
			this.walk(pDeps, (pDeps: IDependens, i:  number ): void => {
				pDeps.files[i] = (sRoot || "") + "/" + pDeps.files[i];
			});
		}

		private createDepsResources(pDeps: IDependens): void {
			var pRmgr: IResourcePoolManager = this.getEngine().getResourceManager();
			this.walk(pDeps, (pDeps: IDependens, i:  number ): void => {
				var pFiles: string[] = pDeps.files;
				switch (pathinfo(pFiles[i]).ext.toLowerCase()) {
					case "afx":
						if (!pRmgr.effectDataPool.findResource(pFiles[i])) {
//LOG("effectDataPool.createResource(" + pFiles[i] + ")");
							pRmgr.effectDataPool.createResource(pFiles[i]);
						}
						break;
				}
			});
		}

		private loadDeps(pDeps: IDependens): void {
			var pRmgr: IResourcePoolManager = this.getEngine().getResourceManager();
			var pRes: IResourcePoolItem;

//if got empty dependency.
			if (!isArray(pDeps.files) || pDeps.files.length === 0) {
				this._onDependencyLoad(pDeps);
			}

//walk single deps level
			this.walk({files: pDeps.files}, (pDep: IDependens, i:  number ): void => {
				var pFiles: string[] = pDeps.files;
				var pManager: DepsManager = this;

				if (isDefAndNotNull(pDep.type)) {
					if (pDep.type == "text" && isFunction(pDep.loader)) {
						io.fopen(pFiles[i], "r").read((pErr: Error, sData: string): void => {
							if (!isNull(pErr)) {
								pManager.error(pErr);
							}

							pDep.loader(pDep, sData);
							pManager._onDependencyLoad(pDeps, i);
						});
					}
				}

				switch (pathinfo(pFiles[i]).ext.toLowerCase()) {
					case "gr":
						io.fopen(pFiles[i], "r").read((pErr: Error, sData: string): void => {
							if (!isNull(pErr)) {
								pManager.error(pErr);
							}

//WARNING: only for HLSL grammar files.
							util.initAFXParser(sData);
							pManager._onDependencyLoad(pDeps, i);
						});
						break;

					case "afx":
							pRes = pRmgr.effectDataPool.findResource(pFiles[i]);

							if (pRes.loadResource(pFiles[i])) {
								pManager._handleResourceEventOnce(pRes,  "loaded" ,
									(pItem: IResourcePoolItem): void => {
//LOG("[ LOADED ]  effectDataPool.loadResource(" + pFiles[i] + ")");
										pManager._onDependencyLoad(pDeps, i);
									}
								);
							}
							else {
								this.error(new Error("could not laod resource: " + pFiles[i]));
							}

						break;

					default:
						logger.setSourceLocation( "util/DepsManager.ts" , 138 ); logger.warning("dependence " + pFiles[i] + " unknown, and will be skipped."); ;
				}
			});
		}

		_handleResourceEventOnce(pRsc: IResourcePoolItem, sSignal: string, fnHandler: (pItem: IResourcePoolItem) => void): void {
			var fn: (pItem: IResourcePoolItem) => void;

			fn = (pItem: IResourcePoolItem): void => {
				fnHandler(pItem);
				pRsc.unbind(sSignal, fn);
			}

			pRsc.bind(sSignal, fn);
		}

		_onDependencyLoad(pDeps: IDependens, n?:  number ): void {
// debug_assert(isDefAndNotNull(pDeps.files) && isString(pDeps.files[i]), "something going wrong...");

			if (isDef(n)) {
//LOG("loaded dependency: " + pDeps.files[n]);
				pDeps.files[n] = null;
			}

			for (var i:  number  = 0; i < pDeps.files.length; ++ i) {
				if (!isNull(pDeps.files[i])) {
//LOG("waiting for > " + pDeps.files[i]);
					return;
				}
			};

			if (isDefAndNotNull(pDeps.deps)) {
				this.loadDeps(pDeps.deps);
			}
			else {
				this.loaded(pDeps);
			}
		}


		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return DepsManager._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		loaded (deps): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).loaded; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, deps) : _broadcast[i].listener (_recivier, deps) ; } } } ; ;
// BROADCAST(error, CALL(pErr));

		error(pErr: Error): void {
			if (true) throw pErr;
			this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).error; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pErr) : _broadcast[i].listener (_recivier, pErr) ; } } ;
		}

	}

	export function createDepsManager(pEngine: IEngine): IDepsManager {
		logger.setSourceLocation( "util/DepsManager.ts" , 190 ); logger.assert(isDefAndNotNull(pEngine)); ;
		return new DepsManager(pEngine);
	}
}













module akra {

	export enum EGamepadCodes {
/*Face (main) buttons*/
		FACE_1 = 0,
	    FACE_2 = 1,
	    FACE_3 = 2,
	    FACE_4 = 3,
/*Top shoulder buttons*/
	    LEFT_SHOULDER = 4,
	    RIGHT_SHOULDER = 5,
/*Bottom shoulder buttons*/
	    LEFT_SHOULDER_BOTTOM = 6,
	    RIGHT_SHOULDER_BOTTOM = 7,
	    SELECT = 8,
	    START = 9,
/*Analogue sticks (if depressible)*/
	    LEFT_ANALOGUE_STICK = 10,
	    RIGHT_ANALOGUE_STICK = 11,
/*Directional (discrete) pad*/
	    PAD_TOP = 12,
	    PAD_BOTTOM = 13,
	    PAD_LEFT = 14,
	    PAD_RIGHT = 15
	}

	export enum EGamepadAxis {
		LEFT_ANALOGUE_HOR = 0,
	    LEFT_ANALOGUE_VERT = 1,
	    RIGHT_ANALOGUE_HOR = 2,
	    RIGHT_ANALOGUE_VERT = 3
	}

    export interface IGamepadMap extends IEventProvider {
    	init(): bool;
    	update(): void;
    	isActive(): bool;


    	find(sID?: string): Gamepad;
    	find(i?:  number ): Gamepad;

    	 connected(pGamepad: Gamepad): void;
    	 disconnected(pGamepad: Gamepad): void;
    	 updated(pGamepad: Gamepad): void;
    }
}










module akra.controls {
	class GamepadMap implements IGamepadMap {
		private _bTicking: bool = false;
		private _pCollection: IObjectArray = new util.ObjectArray;
		private _pPrevRawGamepadTypes: string[] = [null, null, null, null];
		private _pPrevTimestamps:  number [] = [0, 0, 0, 0];

		init(): bool {

			if (!info.api.gamepad) {
	            logger.setSourceLocation( "controls/GamepadMap.ts" , 21 ); logger.warning("Gamepad API is unsupported."); ;
	            return false;
	        }

	        var pMap: GamepadMap = this;
	        var pCollection: IObjectArray = this._pCollection;

            window.addEventListener('MozGamepadConnected', (e: GamepadEvent) => {
            	pCollection.push(e.gamepad);
			    pMap.connected(e.gamepad);
			    pMap._startPolling();
            }, false);

            window.addEventListener('MozGamepadDisconnected', (e: GamepadEvent) => {
		        for (var i:  number  = 0; i <pCollection.length; ++ i) {
		            if (< number >pCollection.value(i).index == e.gamepad.index) {
		                pMap.disconnected(pCollection.takeAt(i));
		                break;
		            }
		        }

		        if (pCollection.length == 0) {
		            pMap._stopPolling();
		        }
            }, false);

            if ( !! navigator.gamepads || !! navigator.getGamepads) {
                this._startPolling();
                return true;
            }

            return false;
		}

		inline isActive(): bool {
			return this._bTicking;
		}


		find(sID?: string): Gamepad;
    	find(i?:  number ): Gamepad;
    	find(id?): Gamepad {
    		var sID: string = null;
    		var i:  number  = 0;

    		if (arguments.length) {
    			if (isString(arguments[0])) {
    				sID = <string>arguments[0];
    			}
    			else if (isInt(arguments[0])) {
    				i = < number >arguments[0];
    			}
    		}

    		if (!isNull(sID)) {
    			for (i = 0; i < this._pCollection.length; ++ i) {
    				if (this._pCollection.value(i).id == sID) {
    					return this._pCollection.value(i);
    				}
    			}
    		}

    		return this._pCollection.value(i);
    	}

		inline _startPolling(): void {
			 if (!this._bTicking) {
	            this._bTicking = true;
	            this.update();
	        }
		}

		inline _stopPolling(): void {
			this._bTicking = false;
		}

		inline update(): void {
			this.pollStatus();
		}

		private pollStatus(): void {
			if (!this._bTicking) {
				return;
			}

			this.pollGamepads();

	        for (var i = 0; i < this._pCollection.length; ++ i) {
	            var pGamepad: Gamepad = this._pCollection.value(i);

	            if (pGamepad.timestamp && (pGamepad.timestamp == this._pPrevTimestamps[i])) {
	                continue;
	            }

	            this._pPrevTimestamps[i] = pGamepad.timestamp;
	        }
		}

		private pollGamepads(): void {
			var pRawGamepads: Gamepad[] = (navigator.getGamepads && navigator.getGamepads()) || navigator.gamepads;
	        if (isDefAndNotNull(pRawGamepads)) {
//debug_print("get raw gamepads");

	            this._pCollection.clear();

	            var isGamepadsChanged: bool = false;

	            for (var i:  number  = 0; i < pRawGamepads.length; i++) {
	                if (typeof pRawGamepads[i] != this._pPrevRawGamepadTypes[i]) {

	                    isGamepadsChanged = true;
	                    this._pPrevRawGamepadTypes[i] = typeof pRawGamepads[i];

	                    if (isDefAndNotNull(pRawGamepads[i])) {
	                   		logger.setSourceLocation( "controls/GamepadMap.ts" , 135 ); logger.log("gamepad " + i + " updated: " + pRawGamepads[i].id); ;
	                        this.updated(pRawGamepads[i]);
	                    }
	                }

	                if (isDefAndNotNull(pRawGamepads[i])) {
	                    this._pCollection.push(pRawGamepads[i]);
	                }
	            }

//if (isGamepadsChanged) {
//todo: collection changed...
//}
	        }
		}

		/**@protected*/ _iGuid: number = sid(); inline getGuid(): number { return this._iGuid; } /**@protected*/ _pUnicastSlotMap: IEventSlotMap = null; /**@protected*/ _pBroadcastSlotList: IEventSlotListMap = null; /**@protected*/ static _pEventTable: IEventTable = new events.EventTable(); getEventTable(): IEventTable { return GamepadMap._pEventTable; } inline connect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().addDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); }; inline disconnect(pSender: IEventProvider, sSignal: string, sSlot: string, eType?: EEventTypes): bool { return pSender.getEventTable().removeDestination((<events.EventProvider>pSender).getGuid(), sSignal, this, sSlot, eType); } inline bind(sSignal: string, fnListener: Function, eType?: EEventTypes): bool { return this.getEventTable().addListener(this.getGuid(), sSignal, fnListener, eType); } inline unbind(sSignal: string, fnListener?: Function, eType?: EEventTypes): bool { return this.getEventTable().removeListener(this.getGuid(), sSignal, fnListener, eType); } ;
		connected (pGamepad): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).connected; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pGamepad) : _broadcast[i].listener (_recivier, pGamepad) ; } } } ; ;
		disconnected (pGamepad): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).disconnected; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pGamepad) : _broadcast[i].listener (_recivier, pGamepad) ; } } } ; ;
		updated (pGamepad): void { this._pBroadcastSlotList = this._pBroadcastSlotList || (<events.EventTable>this.getEventTable()).findBroadcastList(this._iGuid); var _broadcast: IEventSlot[] = (<any>this._pBroadcastSlotList).updated; var _recivier: any = this; if(isDef(_broadcast)){ for (var i = 0; i < _broadcast.length; ++ i) { _broadcast[i].target? _broadcast[i].target[_broadcast[i].callback] (_recivier, pGamepad) : _broadcast[i].listener (_recivier, pGamepad) ; } } } ; ;
	}

	export function createGamepadMap(): IGamepadMap {
		return new GamepadMap;
	}
}














module akra {
	export interface IPoint {
		x:  number ;
		y:  number ;
	}
}






module akra {
	export interface IOffset {
		x:  number ;
		y:  number ;
	}
}



module akra {
	export enum EKeyCodes {
		BACKSPACE = 8,
        TAB = 9,
		ENTER = 13,
		SHIFT = 16, CTRL, ALT,
		PAUSE = 19, BREAK = 19,
		CAPSLOCK = 20,
		ESCAPE = 27,
		SPACE = 32,
		PAGEUP = 33, PAGEDOWN,
		END = 35, HOME,
		LEFT = 37, UP, RIGHT, DOWN,
		INSERT = 45, DELETE,
		N0 = 48, N1, N2, N3, N4, N5, N6, N7, N8, N9,
		A = 65, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
		LEFTWINDOWKEY = 91, RIGHTWINDOWKEY, SELECTKEY,
		NUMPAD0 = 96, NUMPAD1, NUMPAD2, NUMPAD3, NUMPAD4, NUMPAD5, NUMPAD6, NUMPAD7, NUMPAD8, NUMPAD9,
		MULTIPLY = 106, ADD, SUBTRACT = 109, DECIMALPOINT, DIVIDE,
		F1 = 112, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
		NUMLOCK = 144, SCROLLLOCK,
		SEMICOLON = 186, EQUALSIGN, COMMA, DASH, PERIOD, FORWARDSLASH, GRAVEACCENT,
		OPENBRACKET = 219, BACKSLASH, CLOSEBRACKET, SINGLEQUOTE,
		TOTAL = 256
	}

	export interface IKeyMap {
		isKeyPress(iCode:  number );
		isKeyPress(eCode: EKeyCodes);

		getMouse(): IPoint;
/*get offset from last frame*/

		getMouseShift(): IOffset;
		isMouseMoved(): bool;
		isMousePress(): bool;

		captureMouse(pMouseTarget: Node): void;
		captureKeyboard(pKeyboardTarget: Node): void;
		capture(pTarget: Node): void;

		update(): void;
	}
}



module akra.controls {
	class KeyMap implements IKeyMap {
		private _pMap: bool[] = new Array(256);

		private _bAlt: bool = false;
		private _bCtrl: bool = false;
		private _bShift: bool = false;

		private _bMouseDown: bool = false;
		private _v2iMousePosition: IVec2 = new Vec2;
		private _v2iMousePrevPosition: IVec2 = new Vec2;
		private _v2iMouseShift: IVec2 = new Vec2;

		constructor(pTarget?: HTMLElement) {
			for (var i = EKeyCodes.TOTAL; i--;) {
		        this._pMap[i] = false;
		    }

		    if (isDefAndNotNull(pTarget)) {
		    	this.capture(pTarget);
		    }
		}

		capture(pTarget: HTMLElement): void {
			this.captureMouse(pTarget);
			this.captureKeyboard(pTarget);
		}

		captureMouse(pTarget: HTMLElement): void {
			var pKeys: KeyMap = this;
		    var fn: EventListener = function (e: Event) {
		        pKeys.dispatch(<MouseEvent>e);
		    };

		    if (pTarget